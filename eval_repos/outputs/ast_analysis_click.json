{
  "docs/conf.py": {
    "filepath": "../click/docs/conf.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "pallets_sphinx_themes",
        "name": "get_version",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "pallets_sphinx_themes",
        "name": "ProjectLink",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "project",
        "assigned_to": "str",
        "lineno": 6
      },
      {
        "name": "copyright",
        "assigned_to": "str",
        "lineno": 7
      },
      {
        "name": "author",
        "assigned_to": "str",
        "lineno": 8
      },
      {
        "name": "master_doc",
        "assigned_to": "str",
        "lineno": 13
      },
      {
        "name": "default_role",
        "assigned_to": "str",
        "lineno": 14
      },
      {
        "name": "extensions",
        "assigned_to": null,
        "lineno": 15
      },
      {
        "name": "autodoc_member_order",
        "assigned_to": "str",
        "lineno": 24
      },
      {
        "name": "autodoc_typehints",
        "assigned_to": "str",
        "lineno": 25
      },
      {
        "name": "autodoc_preserve_defaults",
        "assigned_to": "bool",
        "lineno": 26
      },
      {
        "name": "extlinks",
        "assigned_to": null,
        "lineno": 27
      },
      {
        "name": "intersphinx_mapping",
        "assigned_to": null,
        "lineno": 31
      },
      {
        "name": "html_theme",
        "assigned_to": "str",
        "lineno": 37
      },
      {
        "name": "html_theme_options",
        "assigned_to": null,
        "lineno": 38
      },
      {
        "name": "html_context",
        "assigned_to": null,
        "lineno": 39
      },
      {
        "name": "html_sidebars",
        "assigned_to": null,
        "lineno": 48
      },
      {
        "name": "singlehtml_sidebars",
        "assigned_to": null,
        "lineno": 52
      },
      {
        "name": "html_static_path",
        "assigned_to": null,
        "lineno": 53
      },
      {
        "name": "html_favicon",
        "assigned_to": "str",
        "lineno": 54
      },
      {
        "name": "html_logo",
        "assigned_to": "str",
        "lineno": 55
      },
      {
        "name": "html_title",
        "assigned_to": null,
        "lineno": 56
      },
      {
        "name": "html_show_sourcelink",
        "assigned_to": "bool",
        "lineno": 57
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "get_version",
        "ProjectLink"
      ],
      "class_instantiations": [
        "ProjectLink"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "pallets_sphinx_themes"
        ]
      },
      "tech_stack": []
    },
    "line_count": 58
  },
  "examples/aliases/aliases.py": {
    "filepath": "../click/examples/aliases/aliases.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "read_config",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "param"
          },
          {
            "name": "value"
          }
        ],
        "return_type": null,
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Config",
          "value",
          "__file__",
          "os.path.dirname",
          "cfg.read_config",
          "ctx.ensure_object",
          "os.path.join"
        ],
        "docstring": "Callback that is used whenever --config is passed.  We use this to\nalways load the correct config.  This means that the config is loaded\neven if the group itself never executes so our aliases stay always\navailable.",
        "code": "def read_config(ctx, param, value):\n    \"\"\"Callback that is used whenever --config is passed.  We use this to\n    always load the correct config.  This means that the config is loaded\n    even if the group itself never executes so our aliases stay always\n    available.\n    \"\"\"\n    cfg = ctx.ensure_object(Config)\n    if value is None:\n        value = os.path.join(os.path.dirname(__file__), \"aliases.ini\")\n    cfg.read_config(value)\n    return value",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "cli",
        "args": [],
        "return_type": null,
        "lineno": 97,
        "decorators": [
          {
            "name": "click.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--config"
            ],
            "kwargs": {
              "expose_value": false,
              "help": "The config file to use instead of the default."
            }
          }
        ],
        "is_async": false,
        "calls": [
          "click.command",
          "AliasedGroup",
          "read_config",
          "click.option",
          "click.Path"
        ],
        "docstring": "An example application that supports aliases.",
        "code": "def cli():\n    \"\"\"An example application that supports aliases.\"\"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "push",
        "args": [],
        "return_type": null,
        "lineno": 102,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.echo"
        ],
        "docstring": "Pushes changes.",
        "code": "def push():\n    \"\"\"Pushes changes.\"\"\"\n    click.echo(\"Push\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "pull",
        "args": [],
        "return_type": null,
        "lineno": 108,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.echo"
        ],
        "docstring": "Pulls changes.",
        "code": "def pull():\n    \"\"\"Pulls changes.\"\"\"\n    click.echo(\"Pull\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "clone",
        "args": [],
        "return_type": null,
        "lineno": 114,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.echo"
        ],
        "docstring": "Clones a repository.",
        "code": "def clone():\n    \"\"\"Clones a repository.\"\"\"\n    click.echo(\"Clone\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "commit",
        "args": [],
        "return_type": null,
        "lineno": 120,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.echo"
        ],
        "docstring": "Commits pending changes.",
        "code": "def commit():\n    \"\"\"Commits pending changes.\"\"\"\n    click.echo(\"Commit\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "status",
        "args": [
          {
            "name": "config"
          }
        ],
        "return_type": null,
        "lineno": 127,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "pass_config",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.echo"
        ],
        "docstring": "Shows the status.",
        "code": "def status(config):\n    \"\"\"Shows the status.\"\"\"\n    click.echo(f\"Status for {config.path}\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "alias",
        "args": [
          {
            "name": "config"
          },
          {
            "name": "alias_"
          },
          {
            "name": "cmd"
          },
          {
            "name": "config_file"
          }
        ],
        "return_type": null,
        "lineno": 139,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "pass_config",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "alias_"
            ],
            "kwargs": {
              "metavar": "ALIAS"
            }
          },
          {
            "name": "click.argument",
            "args": [
              "cmd"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--config_file"
            ],
            "kwargs": {
              "default": "aliases.ini"
            }
          }
        ],
        "is_async": false,
        "calls": [
          "alias_",
          "click.echo",
          "click.argument",
          "config.write_config",
          "click.option",
          "cli.command",
          "config_file",
          "click.STRING",
          "config.add_alias",
          "cmd",
          "click.Path"
        ],
        "docstring": "Adds an alias to the specified configuration file.",
        "code": "def alias(config, alias_, cmd, config_file):\n    \"\"\"Adds an alias to the specified configuration file.\"\"\"\n    config.add_alias(alias_, cmd)\n    config.write_config(config_file)\n    click.echo(f\"Added '{alias_}' as alias for '{cmd}'\")",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 10,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.getcwd"
        ],
        "docstring": null,
        "code": "def __init__(self):\n        self.path = os.getcwd()\n        self.aliases = {}",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "add_alias",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "alias"
          },
          {
            "name": "cmd"
          }
        ],
        "return_type": null,
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.aliases.update"
        ],
        "docstring": null,
        "code": "def add_alias(self, alias, cmd):\n        self.aliases.update({alias: cmd})",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "read_config",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "filename"
          }
        ],
        "return_type": null,
        "lineno": 17,
        "decorators": [],
        "is_async": false,
        "calls": [
          "configparser.RawConfigParser",
          "parser.read",
          "self.aliases.update",
          "parser.items"
        ],
        "docstring": null,
        "code": "def read_config(self, filename):\n        parser = configparser.RawConfigParser()\n        parser.read([filename])\n        try:\n            self.aliases.update(parser.items(\"aliases\"))\n        except configparser.NoSectionError:\n            pass",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "write_config",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "filename"
          }
        ],
        "return_type": null,
        "lineno": 25,
        "decorators": [],
        "is_async": false,
        "calls": [
          "filename",
          "key",
          "configparser.RawConfigParser",
          "open",
          "parser.write",
          "parser.set",
          "value",
          "file",
          "self.aliases.items",
          "parser.add_section"
        ],
        "docstring": null,
        "code": "def write_config(self, filename):\n        parser = configparser.RawConfigParser()\n        parser.add_section(\"aliases\")\n        for key, value in self.aliases.items():\n            parser.set(\"aliases\", key, value)\n        with open(filename, \"wb\") as file:\n            parser.write(file)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "get_command",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx"
          },
          {
            "name": "cmd_name"
          }
        ],
        "return_type": null,
        "lineno": 42,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Config",
          "click.Group.get_command",
          "unknown.join",
          "self",
          "ctx",
          "actual_cmd",
          "len",
          "sorted",
          "cmd_name",
          "ctx.fail",
          "cmd_name.lower",
          "matches",
          "x.lower",
          "unknown.startswith",
          "ctx.ensure_object",
          "self.list_commands"
        ],
        "docstring": null,
        "code": "def get_command(self, ctx, cmd_name):\n        # Step one: bulitin commands as normal\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n\n        # Step two: find the config object and ensure it's there.  This\n        # will create the config object is missing.\n        cfg = ctx.ensure_object(Config)\n\n        # Step three: look up an explicit command alias in the config\n        if cmd_name in cfg.aliases:\n            actual_cmd = cfg.aliases[cmd_name]\n            return click.Group.get_command(self, ctx, actual_cmd)\n\n        # Alternative option: if we did not find an explicit alias we\n        # allow automatic abbreviation of the command.  \"status\" for\n        # instance will match \"st\".  We only allow that however if\n        # there is only one command.\n        matches = [\n            x for x in self.list_commands(ctx) if x.lower().startswith(cmd_name.lower())\n        ]\n        if not matches:\n            return None\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail(f\"Too many matches: {', '.join(sorted(matches))}\")",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "resolve_command",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx"
          },
          {
            "name": "args"
          }
        ],
        "return_type": null,
        "lineno": 70,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "super",
          "args",
          "unknown.resolve_command"
        ],
        "docstring": null,
        "code": "def resolve_command(self, ctx, args):\n        # always return the command's name, not the alias\n        _, cmd, args = super().resolve_command(ctx, args)\n        return cmd.name, cmd, args",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Config",
        "methods": [
          "__init__",
          "add_alias",
          "read_config",
          "write_config"
        ],
        "base_classes": [],
        "lineno": 7,
        "docstring": "The config in this example only holds aliases."
      },
      {
        "name": "AliasedGroup",
        "methods": [
          "get_command",
          "resolve_command"
        ],
        "base_classes": [
          "click.Group"
        ],
        "lineno": 37,
        "docstring": "This subclass of a group supports looking up aliases in a config\nfile and with a bit of magic."
      }
    ],
    "imports": [
      {
        "module": "configparser",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 4,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "pass_config",
        "assigned_to": "click.make_pass_decorator",
        "lineno": 34
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Config",
        "click.make_pass_decorator"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "os"
      ],
      "third_party": {
        "other": [
          "configparser",
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 144
  },
  "examples/colors/colors.py": {
    "filepath": "../click/examples/colors/colors.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [],
        "return_type": null,
        "lineno": 25,
        "decorators": [
          {
            "name": "click.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.style",
          "click.command",
          "click.echo",
          "color"
        ],
        "docstring": "This script prints some colors. It will also automatically remove\nall ANSI styles if data is piped into a file.\n\nGive it a try!",
        "code": "def cli():\n    \"\"\"This script prints some colors. It will also automatically remove\n    all ANSI styles if data is piped into a file.\n\n    Give it a try!\n    \"\"\"\n    for color in all_colors:\n        click.echo(click.style(f\"I am colored {color}\", fg=color))\n    for color in all_colors:\n        click.echo(click.style(f\"I am colored {color} and bold\", fg=color, bold=True))\n    for color in all_colors:\n        click.echo(click.style(f\"I am reverse colored {color}\", fg=color, reverse=True))\n\n    click.echo(click.style(\"I am blinking\", blink=True))\n    click.echo(click.style(\"I am underlined\", underline=True))",
        "line_count": 15,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "click",
        "alias": null,
        "lineno": 1,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "all_colors",
        "assigned_to": null,
        "lineno": 4
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 40
  },
  "examples/completion/completion.py": {
    "filepath": "../click/examples/completion/completion.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [],
        "return_type": null,
        "lineno": 8,
        "decorators": [
          {
            "name": "click.group",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.group"
        ],
        "docstring": null,
        "code": "def cli():\n    pass",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "ls",
        "args": [
          {
            "name": "dir"
          }
        ],
        "return_type": null,
        "lineno": 14,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--dir"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "unknown.join",
          "os.listdir",
          "click.echo",
          "dir",
          "click.option",
          "cli.command",
          "click.Path"
        ],
        "docstring": null,
        "code": "def ls(dir):\n    click.echo(\"\\n\".join(os.listdir(dir)))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "get_env_vars",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "param"
          },
          {
            "name": "incomplete"
          }
        ],
        "return_type": null,
        "lineno": 18,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_env_vars(ctx, param, incomplete):\n    # Returning a list of values is a shortcut to returning a list of\n    # CompletionItem(value).\n    return [k for k in os.environ if incomplete in k]",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "show_env",
        "args": [
          {
            "name": "envvar"
          }
        ],
        "return_type": null,
        "lineno": 26,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {
              "help": "A command to print environment variables"
            }
          },
          {
            "name": "click.argument",
            "args": [
              "envvar"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "get_env_vars",
          "cli.command",
          "click.echo",
          "click.argument"
        ],
        "docstring": null,
        "code": "def show_env(envvar):\n    click.echo(f\"Environment variable: {envvar}\")\n    click.echo(f\"Value: {os.environ[envvar]}\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "group",
        "args": [],
        "return_type": null,
        "lineno": 32,
        "decorators": [
          {
            "name": "cli.group",
            "args": [],
            "kwargs": {
              "help": "A group that holds a subcommand"
            }
          }
        ],
        "is_async": false,
        "calls": [
          "cli.group"
        ],
        "docstring": null,
        "code": "def group():\n    pass",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "list_users",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "param"
          },
          {
            "name": "incomplete"
          }
        ],
        "return_type": null,
        "lineno": 36,
        "decorators": [],
        "is_async": false,
        "calls": [
          "help",
          "out.append",
          "CompletionItem",
          "value"
        ],
        "docstring": null,
        "code": "def list_users(ctx, param, incomplete):\n    # You can generate completions with help strings by returning a list\n    # of CompletionItem. You can match on whatever you want, including\n    # the help.\n    items = [(\"bob\", \"butcher\"), (\"alice\", \"baker\"), (\"jerry\", \"candlestick maker\")]\n    out = []\n\n    for value, help in items:\n        if incomplete in value or incomplete in help:\n            out.append(CompletionItem(value, help=help))\n\n    return out",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "select_user",
        "args": [
          {
            "name": "user"
          }
        ],
        "return_type": null,
        "lineno": 52,
        "decorators": [
          {
            "name": "group.command",
            "args": [],
            "kwargs": {
              "help": "Choose a user"
            }
          },
          {
            "name": "click.argument",
            "args": [
              "user"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "group.command",
          "list_users",
          "click.echo",
          "click.argument"
        ],
        "docstring": null,
        "code": "def select_user(user):\n    click.echo(f\"Chosen user is {user}\")",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "os",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "click.shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "group",
        "cli.add_command"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "os"
      ],
      "third_party": {
        "other": [
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 57
  },
  "examples/complex/complex/__init__.py": {
    "filepath": "../click/examples/complex/complex/__init__.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 1
  },
  "examples/complex/complex/cli.py": {
    "filepath": "../click/examples/complex/complex/cli.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "verbose"
          },
          {
            "name": "home"
          }
        ],
        "return_type": null,
        "lineno": 56,
        "decorators": [
          {
            "name": "click.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--home"
            ],
            "kwargs": {
              "help": "Changes the folder to operate on."
            }
          },
          {
            "name": "click.option",
            "args": [
              "-v",
              "--verbose"
            ],
            "kwargs": {
              "is_flag": true,
              "help": "Enables verbose mode."
            }
          },
          {
            "name": "pass_environment",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "home",
          "click.command",
          "verbose",
          "click.option",
          "CONTEXT_SETTINGS",
          "ComplexCLI",
          "click.Path"
        ],
        "docstring": "A complex command line interface.",
        "code": "def cli(ctx, verbose, home):\n    \"\"\"A complex command line interface.\"\"\"\n    ctx.verbose = verbose\n    if home is not None:\n        ctx.home = home",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 11,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.getcwd"
        ],
        "docstring": null,
        "code": "def __init__(self):\n        self.verbose = False\n        self.home = os.getcwd()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "log",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "msg"
          }
        ],
        "return_type": null,
        "lineno": 15,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sys.stderr",
          "msg",
          "click.echo"
        ],
        "docstring": "Logs a message to stderr.",
        "code": "def log(self, msg, *args):\n        \"\"\"Logs a message to stderr.\"\"\"\n        if args:\n            msg %= args\n        click.echo(msg, file=sys.stderr)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "vlog",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "msg"
          }
        ],
        "return_type": null,
        "lineno": 21,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.log",
          "msg"
        ],
        "docstring": "Logs a message to stderr only if verbose is enabled.",
        "code": "def vlog(self, msg, *args):\n        \"\"\"Logs a message to stderr only if verbose is enabled.\"\"\"\n        if self.verbose:\n            self.log(msg, *args)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "list_commands",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx"
          }
        ],
        "return_type": null,
        "lineno": 32,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.listdir",
          "filename.startswith",
          "rv.append",
          "cmd_folder",
          "filename.endswith",
          "rv.sort"
        ],
        "docstring": null,
        "code": "def list_commands(self, ctx):\n        rv = []\n        for filename in os.listdir(cmd_folder):\n            if filename.endswith(\".py\") and filename.startswith(\"cmd_\"):\n                rv.append(filename[4:-3])\n        rv.sort()\n        return rv",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "get_command",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx"
          },
          {
            "name": "name"
          }
        ],
        "return_type": null,
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "__import__"
        ],
        "docstring": null,
        "code": "def get_command(self, ctx, name):\n        try:\n            mod = __import__(f\"complex.commands.cmd_{name}\", None, None, [\"cli\"])\n        except ImportError:\n            return\n        return mod.cli",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Environment",
        "methods": [
          "__init__",
          "log",
          "vlog"
        ],
        "base_classes": [],
        "lineno": 10,
        "docstring": null
      },
      {
        "name": "ComplexCLI",
        "methods": [
          "list_commands",
          "get_command"
        ],
        "base_classes": [
          "click.Group"
        ],
        "lineno": 31,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "os",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 4,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "CONTEXT_SETTINGS",
        "assigned_to": "dict",
        "lineno": 7
      },
      {
        "name": "pass_environment",
        "assigned_to": "click.make_pass_decorator",
        "lineno": 27
      },
      {
        "name": "cmd_folder",
        "assigned_to": "os.path.abspath",
        "lineno": 28
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "dict",
        "__file__",
        "os.path.dirname",
        "click.make_pass_decorator",
        "os.path.abspath",
        "Environment",
        "os.path.join"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "os",
        "sys"
      ],
      "third_party": {
        "other": [
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 61
  },
  "examples/complex/complex/commands/__init__.py": {
    "filepath": "../click/examples/complex/complex/commands/__init__.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 1
  },
  "examples/complex/complex/commands/cmd_init.py": {
    "filepath": "../click/examples/complex/complex/commands/cmd_init.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "path"
          }
        ],
        "return_type": null,
        "lineno": 9,
        "decorators": [
          {
            "name": "click.command",
            "args": [
              "init"
            ],
            "kwargs": {
              "short_help": "Initializes a repo."
            }
          },
          {
            "name": "click.argument",
            "args": [
              "path"
            ],
            "kwargs": {
              "required": false
            }
          },
          {
            "name": "pass_environment",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.command",
          "path",
          "click.argument",
          "ctx.log",
          "click.format_filename",
          "ctx.home",
          "click.Path"
        ],
        "docstring": "Initializes a repository.",
        "code": "def cli(ctx, path):\n    \"\"\"Initializes a repository.\"\"\"\n    if path is None:\n        path = ctx.home\n    ctx.log(f\"Initialized the repository in {click.format_filename(path)}\")",
        "line_count": 5,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "complex.cli",
        "name": "pass_environment",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 3,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "complex",
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 14
  },
  "examples/complex/complex/commands/cmd_status.py": {
    "filepath": "../click/examples/complex/complex/commands/cmd_status.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [
          {
            "name": "ctx"
          }
        ],
        "return_type": null,
        "lineno": 8,
        "decorators": [
          {
            "name": "click.command",
            "args": [
              "status"
            ],
            "kwargs": {
              "short_help": "Shows file changes."
            }
          },
          {
            "name": "pass_environment",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ctx.log",
          "click.command",
          "ctx.vlog"
        ],
        "docstring": "Shows file changes in the current working directory.",
        "code": "def cli(ctx):\n    \"\"\"Shows file changes in the current working directory.\"\"\"\n    ctx.log(\"Changed files: none\")\n    ctx.vlog(\"bla bla bla, debug info\")",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "complex.cli",
        "name": "pass_environment",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 3,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "complex",
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 12
  },
  "examples/imagepipe/imagepipe.py": {
    "filepath": "../click/examples/imagepipe/imagepipe.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [],
        "return_type": null,
        "lineno": 11,
        "decorators": [
          {
            "name": "click.group",
            "args": [],
            "kwargs": {
              "chain": true
            }
          }
        ],
        "is_async": false,
        "calls": [
          "click.group"
        ],
        "docstring": "This script processes a bunch of images through pillow in a unix\npipe.  One commands feeds into the next.\n\nExample:\n\n\b\n    imagepipe open -i example01.jpg resize -w 128 display\n    imagepipe open -i example02.jpg blur save",
        "code": "def cli():\n    \"\"\"This script processes a bunch of images through pillow in a unix\n    pipe.  One commands feeds into the next.\n\n    Example:\n\n    \\b\n        imagepipe open -i example01.jpg resize -w 128 display\n        imagepipe open -i example02.jpg blur save\n    \"\"\"",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "process_commands",
        "args": [
          {
            "name": "processors"
          }
        ],
        "return_type": null,
        "lineno": 24,
        "decorators": [
          {
            "name": "cli.result_callback",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.result_callback",
          "stream",
          "processor"
        ],
        "docstring": "This result callback is invoked with an iterable of all the chained\nsubcommands.  As in this example each subcommand returns a function\nwe can chain them together to feed one into the other, similar to how\na pipe on unix works.",
        "code": "def process_commands(processors):\n    \"\"\"This result callback is invoked with an iterable of all the chained\n    subcommands.  As in this example each subcommand returns a function\n    we can chain them together to feed one into the other, similar to how\n    a pipe on unix works.\n    \"\"\"\n    # Start with an empty iterable.\n    stream = ()\n\n    # Pipe it through all stream processors.\n    for processor in processors:\n        stream = processor(stream)\n\n    # Evaluate the stream and throw away the items.\n    for _ in stream:\n        pass",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "processor",
        "args": [
          {
            "name": "f"
          }
        ],
        "return_type": null,
        "lineno": 42,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f",
          "new_func",
          "update_wrapper",
          "kwargs",
          "stream"
        ],
        "docstring": "Helper decorator to rewrite a function so that it returns another\nfunction from it.",
        "code": "def processor(f):\n    \"\"\"Helper decorator to rewrite a function so that it returns another\n    function from it.\n    \"\"\"\n\n    def new_func(*args, **kwargs):\n        def processor(stream):\n            return f(stream, *args, **kwargs)\n\n        return processor\n\n    return update_wrapper(new_func, f)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "generator",
        "args": [
          {
            "name": "f"
          }
        ],
        "return_type": null,
        "lineno": 56,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f",
          "update_wrapper",
          "new_func",
          "kwargs"
        ],
        "docstring": "Similar to the :func:`processor` but passes through old values\nunchanged and does not pass through the values as parameter.",
        "code": "def generator(f):\n    \"\"\"Similar to the :func:`processor` but passes through old values\n    unchanged and does not pass through the values as parameter.\n    \"\"\"\n\n    @processor\n    def new_func(stream, *args, **kwargs):\n        yield from stream\n        yield from f(*args, **kwargs)\n\n    return update_wrapper(new_func, f)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "copy_filename",
        "args": [
          {
            "name": "new"
          },
          {
            "name": "old"
          }
        ],
        "return_type": null,
        "lineno": 69,
        "decorators": [],
        "is_async": false,
        "calls": [
          "old.filename"
        ],
        "docstring": null,
        "code": "def copy_filename(new, old):\n    new.filename = old.filename\n    return new",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "open_cmd",
        "args": [
          {
            "name": "images"
          }
        ],
        "return_type": null,
        "lineno": 84,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "open"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "-i",
              "--image",
              "images"
            ],
            "kwargs": {
              "multiple": true,
              "help": "The image file to open."
            }
          },
          {
            "name": "generator",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.echo",
          "image",
          "Image.open",
          "click.get_binary_stdin",
          "click.option",
          "cli.command",
          "click.Path"
        ],
        "docstring": "Loads one or multiple images for processing.  The input parameter\ncan be specified multiple times to load more than one image.",
        "code": "def open_cmd(images):\n    \"\"\"Loads one or multiple images for processing.  The input parameter\n    can be specified multiple times to load more than one image.\n    \"\"\"\n    for image in images:\n        try:\n            click.echo(f\"Opening '{image}'\")\n            if image == \"-\":\n                img = Image.open(click.get_binary_stdin())\n                img.filename = \"-\"\n            else:\n                img = Image.open(image)\n            yield img\n        except Exception as e:\n            click.echo(f\"Could not open image '{image}': {e}\", err=True)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "save_cmd",
        "args": [
          {
            "name": "images"
          },
          {
            "name": "filename"
          }
        ],
        "return_type": null,
        "lineno": 110,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "save"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--filename"
            ],
            "kwargs": {
              "default": "processed-{:04}.png",
              "help": "The format for the filename.",
              "show_default": true
            }
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "enumerate",
          "fn",
          "click.echo",
          "images",
          "click.option",
          "cli.command",
          "filename.format",
          "image.save",
          "click.Path"
        ],
        "docstring": "Saves all processed images to a series of files.",
        "code": "def save_cmd(images, filename):\n    \"\"\"Saves all processed images to a series of files.\"\"\"\n    for idx, image in enumerate(images):\n        try:\n            fn = filename.format(idx + 1)\n            click.echo(f\"Saving '{image.filename}' as '{fn}'\")\n            yield image.save(fn)\n        except Exception as e:\n            click.echo(f\"Could not save image '{image.filename}': {e}\", err=True)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "display_cmd",
        "args": [
          {
            "name": "images"
          }
        ],
        "return_type": null,
        "lineno": 123,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "display"
            ],
            "kwargs": {}
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "image.show",
          "cli.command",
          "click.echo"
        ],
        "docstring": "Opens all images in an image viewer.",
        "code": "def display_cmd(images):\n    \"\"\"Opens all images in an image viewer.\"\"\"\n    for image in images:\n        click.echo(f\"Displaying '{image.filename}'\")\n        image.show()\n        yield image",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "resize_cmd",
        "args": [
          {
            "name": "images"
          },
          {
            "name": "width"
          },
          {
            "name": "height"
          }
        ],
        "return_type": null,
        "lineno": 135,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "resize"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "-w",
              "--width"
            ],
            "kwargs": {
              "help": "The new width of the image."
            }
          },
          {
            "name": "click.option",
            "args": [
              "-h",
              "--height"
            ],
            "kwargs": {
              "help": "The new height of the image."
            }
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "image.thumbnail",
          "click.echo",
          "int",
          "click.option",
          "cli.command"
        ],
        "docstring": "Resizes an image by fitting it into the box without changing\nthe aspect ratio.",
        "code": "def resize_cmd(images, width, height):\n    \"\"\"Resizes an image by fitting it into the box without changing\n    the aspect ratio.\n    \"\"\"\n    for image in images:\n        w, h = (width or image.size[0], height or image.size[1])\n        click.echo(f\"Resizing '{image.filename}' to {w}x{h}\")\n        image.thumbnail((w, h))\n        yield image",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "crop_cmd",
        "args": [
          {
            "name": "images"
          },
          {
            "name": "border"
          }
        ],
        "return_type": null,
        "lineno": 151,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "crop"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "-b",
              "--border"
            ],
            "kwargs": {
              "help": "Crop the image from all sides by this amount."
            }
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "enumerate",
          "click.echo",
          "image",
          "max",
          "int",
          "copy_filename",
          "box",
          "click.option",
          "cli.command",
          "image.crop"
        ],
        "docstring": "Crops an image from all edges.",
        "code": "def crop_cmd(images, border):\n    \"\"\"Crops an image from all edges.\"\"\"\n    for image in images:\n        box = [0, 0, image.size[0], image.size[1]]\n\n        if border is not None:\n            for idx, val in enumerate(box):\n                box[idx] = max(0, val - border)\n            click.echo(f\"Cropping '{image.filename}' by {border}px\")\n            yield copy_filename(image.crop(box), image)\n        else:\n            yield image",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "convert_rotation",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "param"
          },
          {
            "name": "value"
          }
        ],
        "return_type": null,
        "lineno": 165,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value.lower",
          "click.BadParameter"
        ],
        "docstring": null,
        "code": "def convert_rotation(ctx, param, value):\n    if value is None:\n        return\n    value = value.lower()\n    if value in (\"90\", \"r\", \"right\"):\n        return (Image.ROTATE_90, 90)\n    if value in (\"180\", \"-180\"):\n        return (Image.ROTATE_180, 180)\n    if value in (\"-90\", \"270\", \"l\", \"left\"):\n        return (Image.ROTATE_270, 270)\n    raise click.BadParameter(f\"invalid rotation '{value}'\")",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "convert_flip",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "param"
          },
          {
            "name": "value"
          }
        ],
        "return_type": null,
        "lineno": 178,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value.lower",
          "click.BadParameter"
        ],
        "docstring": null,
        "code": "def convert_flip(ctx, param, value):\n    if value is None:\n        return\n    value = value.lower()\n    if value in (\"lr\", \"leftright\"):\n        return (Image.FLIP_LEFT_RIGHT, \"left to right\")\n    if value in (\"tb\", \"topbottom\", \"upsidedown\", \"ud\"):\n        return (Image.FLIP_LEFT_RIGHT, \"top to bottom\")\n    raise click.BadParameter(f\"invalid flip '{value}'\")",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "transpose_cmd",
        "args": [
          {
            "name": "images"
          },
          {
            "name": "rotate"
          },
          {
            "name": "flip"
          }
        ],
        "return_type": null,
        "lineno": 195,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "transpose"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "-r",
              "--rotate"
            ],
            "kwargs": {
              "help": "Rotates the image (in degrees)"
            }
          },
          {
            "name": "click.option",
            "args": [
              "-f",
              "--flip"
            ],
            "kwargs": {
              "help": "Flips the image  [LR / TB]"
            }
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "mode",
          "click.echo",
          "image",
          "rotate",
          "convert_rotation",
          "copy_filename",
          "click.option",
          "cli.command",
          "flip",
          "convert_flip",
          "image.transpose"
        ],
        "docstring": "Transposes an image by either rotating or flipping it.",
        "code": "def transpose_cmd(images, rotate, flip):\n    \"\"\"Transposes an image by either rotating or flipping it.\"\"\"\n    for image in images:\n        if rotate is not None:\n            mode, degrees = rotate\n            click.echo(f\"Rotate '{image.filename}' by {degrees}deg\")\n            image = copy_filename(image.transpose(mode), image)\n        if flip is not None:\n            mode, direction = flip\n            click.echo(f\"Flip '{image.filename}' {direction}\")\n            image = copy_filename(image.transpose(mode), image)\n        yield image",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "blur_cmd",
        "args": [
          {
            "name": "images"
          },
          {
            "name": "radius"
          }
        ],
        "return_type": null,
        "lineno": 212,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "blur"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "-r",
              "--radius"
            ],
            "kwargs": {
              "default": 2,
              "show_default": true,
              "help": "The blur radius."
            }
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.echo",
          "ImageFilter.GaussianBlur",
          "image",
          "image.filter",
          "blur",
          "copy_filename",
          "click.option",
          "cli.command",
          "radius"
        ],
        "docstring": "Applies gaussian blur.",
        "code": "def blur_cmd(images, radius):\n    \"\"\"Applies gaussian blur.\"\"\"\n    blur = ImageFilter.GaussianBlur(radius)\n    for image in images:\n        click.echo(f\"Blurring '{image.filename}' by {radius}px\")\n        yield copy_filename(image.filter(blur), image)",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "smoothen_cmd",
        "args": [
          {
            "name": "images"
          },
          {
            "name": "iterations"
          }
        ],
        "return_type": null,
        "lineno": 229,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "smoothen"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "-i",
              "--iterations"
            ],
            "kwargs": {
              "default": 1,
              "show_default": true,
              "help": "How many iterations of the smoothen filter to run."
            }
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "iterations",
          "click.echo",
          "image",
          "image.filter",
          "copy_filename",
          "click.option",
          "cli.command",
          "ImageFilter.BLUR",
          "range"
        ],
        "docstring": "Applies a smoothening filter.",
        "code": "def smoothen_cmd(images, iterations):\n    \"\"\"Applies a smoothening filter.\"\"\"\n    for image in images:\n        click.echo(\n            f\"Smoothening {image.filename!r} {iterations}\"\n            f\" time{'s' if iterations != 1 else ''}\"\n        )\n        for _ in range(iterations):\n            image = copy_filename(image.filter(ImageFilter.BLUR), image)\n        yield image",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "emboss_cmd",
        "args": [
          {
            "name": "images"
          }
        ],
        "return_type": null,
        "lineno": 243,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "emboss"
            ],
            "kwargs": {}
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "image",
          "click.echo",
          "image.filter",
          "copy_filename",
          "cli.command",
          "ImageFilter.EMBOSS"
        ],
        "docstring": "Embosses an image.",
        "code": "def emboss_cmd(images):\n    \"\"\"Embosses an image.\"\"\"\n    for image in images:\n        click.echo(f\"Embossing '{image.filename}'\")\n        yield copy_filename(image.filter(ImageFilter.EMBOSS), image)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "sharpen_cmd",
        "args": [
          {
            "name": "images"
          },
          {
            "name": "factor"
          }
        ],
        "return_type": null,
        "lineno": 255,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "sharpen"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "-f",
              "--factor"
            ],
            "kwargs": {
              "default": 2.0,
              "help": "Sharpens the image.",
              "show_default": true
            }
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ImageEnhance.Sharpness",
          "image",
          "click.echo",
          "max",
          "copy_filename",
          "click.option",
          "cli.command",
          "enhancer.enhance",
          "factor"
        ],
        "docstring": "Sharpens an image.",
        "code": "def sharpen_cmd(images, factor):\n    \"\"\"Sharpens an image.\"\"\"\n    for image in images:\n        click.echo(f\"Sharpen '{image.filename}' by {factor}\")\n        enhancer = ImageEnhance.Sharpness(image)\n        yield copy_filename(enhancer.enhance(max(1.0, factor)), image)",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "paste_cmd",
        "args": [
          {
            "name": "images"
          },
          {
            "name": "left"
          },
          {
            "name": "right"
          }
        ],
        "return_type": null,
        "lineno": 267,
        "decorators": [
          {
            "name": "cli.command",
            "args": [
              "paste"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "-l",
              "--left"
            ],
            "kwargs": {
              "default": 0,
              "help": "Offset from left."
            }
          },
          {
            "name": "click.option",
            "args": [
              "-r",
              "--right"
            ],
            "kwargs": {
              "default": 0,
              "help": "Offset from right."
            }
          },
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.echo",
          "next",
          "images",
          "click.option",
          "cli.command",
          "imageiter",
          "to_paste",
          "image.paste",
          "iter",
          "mask"
        ],
        "docstring": "Pastes the second image on the first image and leaves the rest\nunchanged.",
        "code": "def paste_cmd(images, left, right):\n    \"\"\"Pastes the second image on the first image and leaves the rest\n    unchanged.\n    \"\"\"\n    imageiter = iter(images)\n    image = next(imageiter, None)\n    to_paste = next(imageiter, None)\n\n    if to_paste is None:\n        if image is not None:\n            yield image\n        return\n\n    click.echo(f\"Paste '{to_paste.filename}' on '{image.filename}'\")\n    mask = None\n    if to_paste.mode == \"RGBA\" or \"transparency\" in to_paste.info:\n        mask = to_paste\n    image.paste(to_paste, (left, right), mask)\n    image.filename += f\"+{to_paste.filename}\"\n    yield image\n\n    yield from imageiter",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "new_func",
        "args": [],
        "return_type": null,
        "lineno": 47,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "f",
          "kwargs"
        ],
        "docstring": null,
        "code": "def new_func(*args, **kwargs):\n        def processor(stream):\n            return f(stream, *args, **kwargs)\n\n        return processor",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "new_func",
        "args": [
          {
            "name": "stream"
          }
        ],
        "return_type": null,
        "lineno": 62,
        "decorators": [
          {
            "name": "processor",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "f",
          "kwargs"
        ],
        "docstring": null,
        "code": "def new_func(stream, *args, **kwargs):\n        yield from stream\n        yield from f(*args, **kwargs)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "processor",
        "args": [
          {
            "name": "stream"
          }
        ],
        "return_type": null,
        "lineno": 48,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "f",
          "kwargs"
        ],
        "docstring": null,
        "code": "def processor(stream):\n            return f(stream, *args, **kwargs)",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "functools",
        "name": "update_wrapper",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "PIL",
        "name": "Image",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "PIL",
        "name": "ImageEnhance",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "PIL",
        "name": "ImageFilter",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 7,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "functools"
      ],
      "third_party": {
        "other": [
          "PIL",
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 289
  },
  "examples/inout/inout.py": {
    "filepath": "../click/examples/inout/inout.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [
          {
            "name": "input"
          },
          {
            "name": "output"
          }
        ],
        "return_type": null,
        "lineno": 7,
        "decorators": [
          {
            "name": "click.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "input"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "output"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.command",
          "output.write",
          "output.flush",
          "click.argument",
          "chunk",
          "click.File",
          "f.read"
        ],
        "docstring": "This script works similar to the Unix `cat` command but it writes\ninto a specific file (which could be the standard output as denoted by\nthe ``-`` sign).\n\n\b\nCopy stdin to stdout:\n    inout - -\n\n\b\nCopy foo.txt and bar.txt to stdout:\n    inout foo.txt bar.txt -\n\n\b\nWrite stdin into the file foo.txt\n    inout - foo.txt",
        "code": "def cli(input, output):\n    \"\"\"This script works similar to the Unix `cat` command but it writes\n    into a specific file (which could be the standard output as denoted by\n    the ``-`` sign).\n\n    \\b\n    Copy stdin to stdout:\n        inout - -\n\n    \\b\n    Copy foo.txt and bar.txt to stdout:\n        inout foo.txt bar.txt -\n\n    \\b\n    Write stdin into the file foo.txt\n        inout - foo.txt\n    \"\"\"\n    for f in input:\n        while True:\n            chunk = f.read(1024)\n            if not chunk:\n                break\n            output.write(chunk)\n            output.flush()",
        "line_count": 24,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "click",
        "alias": null,
        "lineno": 1,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 31
  },
  "examples/naval/naval.py": {
    "filepath": "../click/examples/naval/naval.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [],
        "return_type": null,
        "lineno": 6,
        "decorators": [
          {
            "name": "click.group",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.version_option",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.version_option",
          "click.group"
        ],
        "docstring": "Naval Fate.\n\nThis is the docopt example adopted to Click but with some actual\ncommands implemented and not just the empty parsing which really\nis not all that interesting.",
        "code": "def cli():\n    \"\"\"Naval Fate.\n\n    This is the docopt example adopted to Click but with some actual\n    commands implemented and not just the empty parsing which really\n    is not all that interesting.\n    \"\"\"",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "ship",
        "args": [],
        "return_type": null,
        "lineno": 16,
        "decorators": [
          {
            "name": "cli.group",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.group"
        ],
        "docstring": "Manages ships.",
        "code": "def ship():\n    \"\"\"Manages ships.\"\"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "ship_new",
        "args": [
          {
            "name": "name"
          }
        ],
        "return_type": null,
        "lineno": 22,
        "decorators": [
          {
            "name": "ship.command",
            "args": [
              "new"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "name"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ship.command",
          "click.echo",
          "click.argument"
        ],
        "docstring": "Creates a new ship.",
        "code": "def ship_new(name):\n    \"\"\"Creates a new ship.\"\"\"\n    click.echo(f\"Created ship {name}\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "ship_move",
        "args": [
          {
            "name": "ship"
          },
          {
            "name": "x"
          },
          {
            "name": "y"
          },
          {
            "name": "speed"
          }
        ],
        "return_type": null,
        "lineno": 32,
        "decorators": [
          {
            "name": "ship.command",
            "args": [
              "move"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "ship"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "x"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "y"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--speed"
            ],
            "kwargs": {
              "metavar": "KN",
              "default": 10,
              "help": "Speed in knots."
            }
          }
        ],
        "is_async": false,
        "calls": [
          "click.echo",
          "click.argument",
          "click.option",
          "float",
          "ship.command"
        ],
        "docstring": "Moves SHIP to the new location X,Y.",
        "code": "def ship_move(ship, x, y, speed):\n    \"\"\"Moves SHIP to the new location X,Y.\"\"\"\n    click.echo(f\"Moving ship {ship} to {x},{y} with speed {speed}\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "ship_shoot",
        "args": [
          {
            "name": "ship"
          },
          {
            "name": "x"
          },
          {
            "name": "y"
          }
        ],
        "return_type": null,
        "lineno": 41,
        "decorators": [
          {
            "name": "ship.command",
            "args": [
              "shoot"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "ship"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "x"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "y"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "float",
          "ship.command",
          "click.echo",
          "click.argument"
        ],
        "docstring": "Makes SHIP fire to X,Y.",
        "code": "def ship_shoot(ship, x, y):\n    \"\"\"Makes SHIP fire to X,Y.\"\"\"\n    click.echo(f\"Ship {ship} fires to {x},{y}\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "mine",
        "args": [],
        "return_type": null,
        "lineno": 47,
        "decorators": [
          {
            "name": "cli.group",
            "args": [
              "mine"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.group"
        ],
        "docstring": "Manages mines.",
        "code": "def mine():\n    \"\"\"Manages mines.\"\"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "mine_set",
        "args": [
          {
            "name": "x"
          },
          {
            "name": "y"
          },
          {
            "name": "ty"
          }
        ],
        "return_type": null,
        "lineno": 62,
        "decorators": [
          {
            "name": "mine.command",
            "args": [
              "set"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "x"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "y"
            ],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "ty",
              "--moored"
            ],
            "kwargs": {
              "flag_value": "moored",
              "default": true,
              "help": "Moored (anchored) mine. Default."
            }
          },
          {
            "name": "click.option",
            "args": [
              "ty",
              "--drifting"
            ],
            "kwargs": {
              "flag_value": "drifting",
              "help": "Drifting mine."
            }
          }
        ],
        "is_async": false,
        "calls": [
          "click.echo",
          "click.argument",
          "click.option",
          "float",
          "mine.command"
        ],
        "docstring": "Sets a mine at a specific coordinate.",
        "code": "def mine_set(x, y, ty):\n    \"\"\"Sets a mine at a specific coordinate.\"\"\"\n    click.echo(f\"Set {ty} mine at {x},{y}\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "mine_remove",
        "args": [
          {
            "name": "x"
          },
          {
            "name": "y"
          }
        ],
        "return_type": null,
        "lineno": 70,
        "decorators": [
          {
            "name": "mine.command",
            "args": [
              "remove"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "x"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "y"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "mine.command",
          "float",
          "click.echo",
          "click.argument"
        ],
        "docstring": "Removes a mine at a specific coordinate.",
        "code": "def mine_remove(x, y):\n    \"\"\"Removes a mine at a specific coordinate.\"\"\"\n    click.echo(f\"Removed mine at {x},{y}\")",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "click",
        "alias": null,
        "lineno": 1,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 73
  },
  "examples/repo/repo.py": {
    "filepath": "../click/examples/repo/repo.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "repo_home"
          },
          {
            "name": "config"
          },
          {
            "name": "verbose"
          }
        ],
        "return_type": null,
        "lineno": 44,
        "decorators": [
          {
            "name": "click.group",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--repo-home"
            ],
            "kwargs": {
              "envvar": "REPO_HOME",
              "default": ".repo",
              "metavar": "PATH",
              "help": "Changes the repository folder location."
            }
          },
          {
            "name": "click.option",
            "args": [
              "--config"
            ],
            "kwargs": {
              "nargs": 2,
              "multiple": true,
              "metavar": "KEY VALUE",
              "help": "Overrides a config key/value pair."
            }
          },
          {
            "name": "click.option",
            "args": [
              "--verbose",
              "-v"
            ],
            "kwargs": {
              "is_flag": true,
              "help": "Enables verbose mode."
            }
          },
          {
            "name": "click.version_option",
            "args": [
              "1.0"
            ],
            "kwargs": {}
          },
          {
            "name": "click.pass_context",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "os.path.abspath",
          "Repo",
          "key",
          "verbose",
          "ctx.obj.set_config",
          "value",
          "click.option",
          "click.group",
          "click.version_option",
          "repo_home"
        ],
        "docstring": "Repo is a command line tool that showcases how to build complex\ncommand line interfaces with Click.\n\nThis tool is supposed to look like a distributed version control\nsystem to show how something like this can be structured.",
        "code": "def cli(ctx, repo_home, config, verbose):\n    \"\"\"Repo is a command line tool that showcases how to build complex\n    command line interfaces with Click.\n\n    This tool is supposed to look like a distributed version control\n    system to show how something like this can be structured.\n    \"\"\"\n    # Create a repo object and remember it as as the context object.  From\n    # this point onwards other commands can refer to it by using the\n    # @pass_repo decorator.\n    ctx.obj = Repo(os.path.abspath(repo_home))\n    ctx.obj.verbose = verbose\n    for key, value in config:\n        ctx.obj.set_config(key, value)",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "clone",
        "args": [
          {
            "name": "repo"
          },
          {
            "name": "src"
          },
          {
            "name": "dest"
          },
          {
            "name": "shallow"
          },
          {
            "name": "rev"
          }
        ],
        "return_type": null,
        "lineno": 72,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "src"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "dest"
            ],
            "kwargs": {
              "required": false
            }
          },
          {
            "name": "click.option",
            "args": [
              "--shallow/--deep"
            ],
            "kwargs": {
              "default": false,
              "help": "Makes a checkout shallow or deep.  Deep by default."
            }
          },
          {
            "name": "click.option",
            "args": [
              "--rev",
              "-r"
            ],
            "kwargs": {
              "default": "HEAD",
              "help": "Clone a specific revision instead of HEAD."
            }
          },
          {
            "name": "pass_repo",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "src",
          "dest",
          "click.echo",
          "click.argument",
          "posixpath.split",
          "click.option",
          "cli.command",
          "os.path.basename"
        ],
        "docstring": "Clones a repository.\n\nThis will clone the repository at SRC into the folder DEST.  If DEST\nis not provided this will automatically use the last path component\nof SRC and create that folder.",
        "code": "def clone(repo, src, dest, shallow, rev):\n    \"\"\"Clones a repository.\n\n    This will clone the repository at SRC into the folder DEST.  If DEST\n    is not provided this will automatically use the last path component\n    of SRC and create that folder.\n    \"\"\"\n    if dest is None:\n        dest = posixpath.split(src)[-1] or \".\"\n    click.echo(f\"Cloning repo {src} to {os.path.basename(dest)}\")\n    repo.home = dest\n    if shallow:\n        click.echo(\"Making shallow checkout\")\n    click.echo(f\"Checking out revision {rev}\")",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "delete",
        "args": [
          {
            "name": "repo"
          }
        ],
        "return_type": null,
        "lineno": 91,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.confirmation_option",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "pass_repo",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.echo",
          "click.confirmation_option"
        ],
        "docstring": "Deletes a repository.\n\nThis will throw away the current repository.",
        "code": "def delete(repo):\n    \"\"\"Deletes a repository.\n\n    This will throw away the current repository.\n    \"\"\"\n    click.echo(f\"Destroying repo {repo.home}\")\n    click.echo(\"Deleted!\")",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "setuser",
        "args": [
          {
            "name": "repo"
          },
          {
            "name": "username"
          },
          {
            "name": "email"
          },
          {
            "name": "password"
          }
        ],
        "return_type": null,
        "lineno": 105,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--username"
            ],
            "kwargs": {
              "prompt": true,
              "help": "The developer's shown username."
            }
          },
          {
            "name": "click.option",
            "args": [
              "--email"
            ],
            "kwargs": {
              "prompt": "E-Mail",
              "help": "The developer's email address"
            }
          },
          {
            "name": "click.password_option",
            "args": [],
            "kwargs": {
              "help": "The login password."
            }
          },
          {
            "name": "pass_repo",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.echo",
          "click.password_option",
          "len",
          "password",
          "click.option",
          "cli.command",
          "username",
          "repo.set_config",
          "email"
        ],
        "docstring": "Sets the user credentials.\n\nThis will override the current user config.",
        "code": "def setuser(repo, username, email, password):\n    \"\"\"Sets the user credentials.\n\n    This will override the current user config.\n    \"\"\"\n    repo.set_config(\"username\", username)\n    repo.set_config(\"email\", email)\n    repo.set_config(\"password\", \"*\" * len(password))\n    click.echo(\"Changed credentials.\")",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "commit",
        "args": [
          {
            "name": "repo"
          },
          {
            "name": "files"
          },
          {
            "name": "message"
          }
        ],
        "return_type": null,
        "lineno": 126,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--message",
              "-m"
            ],
            "kwargs": {
              "multiple": true,
              "help": "The commit message.  If provided multiple times each argument gets converted into a new line."
            }
          },
          {
            "name": "click.argument",
            "args": [
              "files"
            ],
            "kwargs": {}
          },
          {
            "name": "pass_repo",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "unknown.join",
          "click.echo",
          "click.argument",
          "message",
          "hint",
          "click.edit",
          "message.split",
          "marker",
          "click.option",
          "cli.command",
          "hint.append",
          "click.Path",
          "unknown.rstrip"
        ],
        "docstring": "Commits outstanding changes.\n\nCommit changes to the given files into the repository.  You will need to\n\"repo push\" to push up your changes to other repositories.\n\nIf a list of files is omitted, all changes reported by \"repo status\"\nwill be committed.",
        "code": "def commit(repo, files, message):\n    \"\"\"Commits outstanding changes.\n\n    Commit changes to the given files into the repository.  You will need to\n    \"repo push\" to push up your changes to other repositories.\n\n    If a list of files is omitted, all changes reported by \"repo status\"\n    will be committed.\n    \"\"\"\n    if not message:\n        marker = \"# Files to be committed:\"\n        hint = [\"\", \"\", marker, \"#\"]\n        for file in files:\n            hint.append(f\"#   U {file}\")\n        message = click.edit(\"\\n\".join(hint))\n        if message is None:\n            click.echo(\"Aborted!\")\n            return\n        msg = message.split(marker)[0].rstrip()\n        if not msg:\n            click.echo(\"Aborted! Empty commit message\")\n            return\n    else:\n        msg = \"\\n\".join(message)\n    click.echo(f\"Files to be committed: {files}\")\n    click.echo(f\"Commit message:\\n{msg}\")",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "copy",
        "args": [
          {
            "name": "repo"
          },
          {
            "name": "src"
          },
          {
            "name": "dst"
          },
          {
            "name": "force"
          }
        ],
        "return_type": null,
        "lineno": 161,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {
              "short_help": "Copies files."
            }
          },
          {
            "name": "click.option",
            "args": [
              "--force"
            ],
            "kwargs": {
              "is_flag": true,
              "help": "forcibly copy over an existing managed file"
            }
          },
          {
            "name": "click.argument",
            "args": [
              "src"
            ],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "dst"
            ],
            "kwargs": {}
          },
          {
            "name": "pass_repo",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.echo",
          "click.argument",
          "click.option",
          "cli.command",
          "click.Path"
        ],
        "docstring": "Copies one or multiple files to a new location.  This copies all\nfiles from SRC to DST.",
        "code": "def copy(repo, src, dst, force):\n    \"\"\"Copies one or multiple files to a new location.  This copies all\n    files from SRC to DST.\n    \"\"\"\n    for fn in src:\n        click.echo(f\"Copy from {fn} -> {dst}\")",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "home"
          }
        ],
        "return_type": null,
        "lineno": 9,
        "decorators": [],
        "is_async": false,
        "calls": [
          "home"
        ],
        "docstring": null,
        "code": "def __init__(self, home):\n        self.home = home\n        self.config = {}\n        self.verbose = False",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "set_config",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "key"
          },
          {
            "name": "value"
          }
        ],
        "return_type": null,
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sys.stderr",
          "click.echo",
          "value"
        ],
        "docstring": null,
        "code": "def set_config(self, key, value):\n        self.config[key] = value\n        if self.verbose:\n            click.echo(f\"  config[{key}] = {value}\", file=sys.stderr)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 19,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self):\n        return f\"<Repo {self.home}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "Repo",
        "methods": [
          "__init__",
          "set_config",
          "__repr__"
        ],
        "base_classes": [],
        "lineno": 8,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "os",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "posixpath",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 5,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "pass_repo",
        "assigned_to": "click.make_pass_decorator",
        "lineno": 23
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Repo",
        "click.make_pass_decorator"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "os",
        "sys"
      ],
      "third_party": {
        "other": [
          "posixpath",
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 167
  },
  "examples/termui/termui.py": {
    "filepath": "../click/examples/termui/termui.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cli",
        "args": [],
        "return_type": null,
        "lineno": 9,
        "decorators": [
          {
            "name": "click.group",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.group"
        ],
        "docstring": "This script showcases different terminal UI helpers in Click.",
        "code": "def cli():\n    \"\"\"This script showcases different terminal UI helpers in Click.\"\"\"\n    pass",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "colordemo",
        "args": [],
        "return_type": null,
        "lineno": 15,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "click.style",
          "cli.command",
          "click.echo",
          "color"
        ],
        "docstring": "Demonstrates ANSI color support.",
        "code": "def colordemo():\n    \"\"\"Demonstrates ANSI color support.\"\"\"\n    for color in \"red\", \"green\", \"blue\":\n        click.echo(click.style(f\"I am colored {color}\", fg=color))\n        click.echo(click.style(f\"I am background colored {color}\", bg=color))",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "pager",
        "args": [],
        "return_type": null,
        "lineno": 23,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "unknown.join",
          "lines.append",
          "str",
          "lines",
          "click.style",
          "cli.command",
          "range",
          "click.echo_via_pager",
          "x"
        ],
        "docstring": "Demonstrates using the pager.",
        "code": "def pager():\n    \"\"\"Demonstrates using the pager.\"\"\"\n    lines = []\n    for x in range(200):\n        lines.append(f\"{click.style(str(x), fg='green')}. Hello World!\")\n    click.echo_via_pager(\"\\n\".join(lines))",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "progress",
        "args": [
          {
            "name": "count"
          }
        ],
        "return_type": null,
        "lineno": 38,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--count"
            ],
            "kwargs": {
              "default": 8000,
              "help": "The number of items to process."
            }
          }
        ],
        "is_async": false,
        "calls": [
          "show_item",
          "int",
          "math.exp",
          "random.random",
          "count",
          "item",
          "bar.update",
          "items",
          "click.IntRange",
          "sum",
          "filter",
          "time.sleep",
          "click.option",
          "process_slowly",
          "steps",
          "range",
          "click.progressbar",
          "click.style",
          "cli.command"
        ],
        "docstring": "Demonstrates the progress bar.",
        "code": "def progress(count):\n    \"\"\"Demonstrates the progress bar.\"\"\"\n    items = range(count)\n\n    def process_slowly(item):\n        time.sleep(0.002 * random.random())\n\n    def filter(items):\n        for item in items:\n            if random.random() > 0.3:\n                yield item\n\n    with click.progressbar(\n        items, label=\"Processing accounts\", fill_char=click.style(\"#\", fg=\"green\")\n    ) as bar:\n        for item in bar:\n            process_slowly(item)\n\n    def show_item(item):\n        if item is not None:\n            return f\"Item #{item}\"\n\n    with click.progressbar(\n        filter(items),\n        label=\"Committing transaction\",\n        fill_char=click.style(\"#\", fg=\"yellow\"),\n        item_show_func=show_item,\n    ) as bar:\n        for item in bar:\n            process_slowly(item)\n\n    with click.progressbar(\n        length=count,\n        label=\"Counting\",\n        bar_template=\"%(label)s  %(bar)s | %(info)s\",\n        fill_char=click.style(\"\u2588\", fg=\"cyan\"),\n        empty_char=\" \",\n    ) as bar:\n        for item in bar:\n            process_slowly(item)\n\n    with click.progressbar(\n        length=count,\n        width=0,\n        show_percent=False,\n        show_eta=False,\n        fill_char=click.style(\"#\", fg=\"magenta\"),\n    ) as bar:\n        for item in bar:\n            process_slowly(item)\n\n    # 'Non-linear progress bar'\n    steps = [math.exp(x * 1.0 / 20) - 1 for x in range(20)]\n    count = int(sum(steps))\n    with click.progressbar(\n        length=count,\n        show_percent=False,\n        label=\"Slowing progress bar\",\n        fill_char=click.style(\"\u2588\", fg=\"green\"),\n    ) as bar:\n        for item in steps:\n            time.sleep(item)\n            bar.update(item)",
        "line_count": 63,
        "needs_llm_summary": true
      },
      {
        "name": "open",
        "args": [
          {
            "name": "url"
          }
        ],
        "return_type": null,
        "lineno": 105,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "url"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "url",
          "click.launch",
          "cli.command",
          "click.argument"
        ],
        "docstring": "Opens a file or URL In the default application.",
        "code": "def open(url):\n    \"\"\"Opens a file or URL In the default application.\"\"\"\n    click.launch(url)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "locate",
        "args": [
          {
            "name": "url"
          }
        ],
        "return_type": null,
        "lineno": 112,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.argument",
            "args": [
              "url"
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "url",
          "click.launch",
          "cli.command",
          "click.argument"
        ],
        "docstring": "Opens a file or URL In the default application.",
        "code": "def locate(url):\n    \"\"\"Opens a file or URL In the default application.\"\"\"\n    click.launch(url, locate=True)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "edit",
        "args": [],
        "return_type": null,
        "lineno": 118,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "MARKER",
          "click.echo",
          "click.edit",
          "message.split",
          "cli.command",
          "unknown.rstrip"
        ],
        "docstring": "Opens an editor with some text in it.",
        "code": "def edit():\n    \"\"\"Opens an editor with some text in it.\"\"\"\n    MARKER = \"# Everything below is ignored\\n\"\n    message = click.edit(f\"\\n\\n{MARKER}\")\n    if message is not None:\n        msg = message.split(MARKER, 1)[0].rstrip(\"\\n\")\n        if not msg:\n            click.echo(\"Empty message!\")\n        else:\n            click.echo(f\"Message:\\n{msg}\")\n    else:\n        click.echo(\"You did not enter anything!\")",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "clear",
        "args": [],
        "return_type": null,
        "lineno": 133,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.clear"
        ],
        "docstring": "Clears the entire screen.",
        "code": "def clear():\n    \"\"\"Clears the entire screen.\"\"\"\n    click.clear()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "pause",
        "args": [],
        "return_type": null,
        "lineno": 139,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.pause"
        ],
        "docstring": "Waits for the user to press a button.",
        "code": "def pause():\n    \"\"\"Waits for the user to press a button.\"\"\"\n    click.pause()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "menu",
        "args": [],
        "return_type": null,
        "lineno": 145,
        "decorators": [
          {
            "name": "cli.command",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cli.command",
          "click.getchar",
          "click.echo"
        ],
        "docstring": "Shows a simple menu.",
        "code": "def menu():\n    \"\"\"Shows a simple menu.\"\"\"\n    menu = \"main\"\n    while True:\n        if menu == \"main\":\n            click.echo(\"Main menu:\")\n            click.echo(\"  d: debug menu\")\n            click.echo(\"  q: quit\")\n            char = click.getchar()\n            if char == \"d\":\n                menu = \"debug\"\n            elif char == \"q\":\n                menu = \"quit\"\n            else:\n                click.echo(\"Invalid input\")\n        elif menu == \"debug\":\n            click.echo(\"Debug menu\")\n            click.echo(\"  b: back\")\n            char = click.getchar()\n            if char == \"b\":\n                menu = \"main\"\n            else:\n                click.echo(\"Invalid input\")\n        elif menu == \"quit\":\n            return",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "process_slowly",
        "args": [
          {
            "name": "item"
          }
        ],
        "return_type": null,
        "lineno": 42,
        "decorators": [],
        "is_async": false,
        "calls": [
          "random.random",
          "time.sleep"
        ],
        "docstring": null,
        "code": "def process_slowly(item):\n        time.sleep(0.002 * random.random())",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "filter",
        "args": [
          {
            "name": "items"
          }
        ],
        "return_type": null,
        "lineno": 45,
        "decorators": [],
        "is_async": false,
        "calls": [
          "random.random"
        ],
        "docstring": null,
        "code": "def filter(items):\n        for item in items:\n            if random.random() > 0.3:\n                yield item",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "show_item",
        "args": [
          {
            "name": "item"
          }
        ],
        "return_type": null,
        "lineno": 56,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def show_item(item):\n        if item is not None:\n            return f\"Item #{item}\"",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "math",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "random",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "time",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 5,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "math",
        "random",
        "time"
      ],
      "third_party": {
        "other": [
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 170
  },
  "examples/validation/validation.py": {
    "filepath": "../click/examples/validation/validation.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "validate_count",
        "args": [
          {
            "name": "ctx"
          },
          {
            "name": "param"
          },
          {
            "name": "value"
          }
        ],
        "return_type": null,
        "lineno": 6,
        "decorators": [],
        "is_async": false,
        "calls": [
          "click.BadParameter"
        ],
        "docstring": null,
        "code": "def validate_count(ctx, param, value):\n    if value < 0 or value % 2 != 0:\n        raise click.BadParameter(\"Should be a positive, even integer.\")\n    return value",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "cli",
        "args": [
          {
            "name": "count"
          },
          {
            "name": "foo"
          },
          {
            "name": "url"
          }
        ],
        "return_type": null,
        "lineno": 34,
        "decorators": [
          {
            "name": "click.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--count"
            ],
            "kwargs": {
              "default": 2,
              "help": "A positive even number."
            }
          },
          {
            "name": "click.option",
            "args": [
              "--foo"
            ],
            "kwargs": {
              "help": "A mysterious parameter."
            }
          },
          {
            "name": "click.option",
            "args": [
              "--url"
            ],
            "kwargs": {
              "help": "A URL"
            }
          },
          {
            "name": "click.version_option",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "URL",
          "click.command",
          "click.echo",
          "validate_count",
          "click.option",
          "click.version_option",
          "click.BadParameter"
        ],
        "docstring": "Validation.\n\nThis example validates parameters in different ways.  It does it\nthrough callbacks, through a custom type as well as by validating\nmanually in the function.",
        "code": "def cli(count, foo, url):\n    \"\"\"Validation.\n\n    This example validates parameters in different ways.  It does it\n    through callbacks, through a custom type as well as by validating\n    manually in the function.\n    \"\"\"\n    if foo is not None and foo != \"wat\":\n        raise click.BadParameter(\n            'If a value is provided it needs to be the value \"wat\".',\n            param_hint=[\"--foo\"],\n        )\n    click.echo(f\"count: {count}\")\n    click.echo(f\"foo: {foo}\")\n    click.echo(f\"url: {url!r}\")",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value"
          },
          {
            "name": "param"
          },
          {
            "name": "ctx"
          }
        ],
        "return_type": null,
        "lineno": 15,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "urlparse.urlparse",
          "value",
          "param",
          "ctx",
          "isinstance",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(self, value, param, ctx):\n        if not isinstance(value, tuple):\n            value = urlparse.urlparse(value)\n            if value.scheme not in (\"http\", \"https\"):\n                self.fail(\n                    f\"invalid URL scheme ({value.scheme}). Only HTTP URLs are allowed\",\n                    param,\n                    ctx,\n                )\n        return value",
        "line_count": 10,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "URL",
        "methods": [
          "convert"
        ],
        "base_classes": [
          "click.ParamType"
        ],
        "lineno": 12,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "urllib",
        "name": "parse",
        "alias": "urlparse",
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 3,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "urllib",
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 49
  },
  "src/click/__init__.py": {
    "filepath": "../click/src/click/__init__.py",
    "module_docstring": "Click is a simple Python module inspired by the stdlib optparse to make\nwriting command line scripts fun. Unlike other modules, it's based\naround a simple API that does not come with too much magic and is\ncomposable.",
    "functions": [
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "object",
        "lineno": 74,
        "decorators": [],
        "is_async": false,
        "calls": [
          "AttributeError",
          "importlib.metadata.version",
          "warnings.warn",
          "name",
          "DeprecationWarning"
        ],
        "docstring": null,
        "code": "def __getattr__(name: str) -> object:\n    import warnings\n\n    if name == \"BaseCommand\":\n        from .core import _BaseCommand\n\n        warnings.warn(\n            \"'BaseCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 'Command' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _BaseCommand\n\n    if name == \"MultiCommand\":\n        from .core import _MultiCommand\n\n        warnings.warn(\n            \"'MultiCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 'Group' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _MultiCommand\n\n    if name == \"OptionParser\":\n        from .parser import _OptionParser\n\n        warnings.warn(\n            \"'OptionParser' is deprecated and will be removed in Click 9.0. The\"\n            \" old parser is available in 'optparse'.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _OptionParser\n\n    if name == \"__version__\":\n        import importlib.metadata\n        import warnings\n\n        warnings.warn(\n            \"The '__version__' attribute is deprecated and will be removed in\"\n            \" Click 9.1. Use feature detection or\"\n            \" 'importlib.metadata.version(\\\"click\\\")' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return importlib.metadata.version(\"click\")\n\n    raise AttributeError(name)",
        "line_count": 50,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Argument",
        "alias": "Argument",
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Command",
        "alias": "Command",
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "CommandCollection",
        "alias": "CommandCollection",
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Context",
        "alias": "Context",
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Group",
        "alias": "Group",
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Option",
        "alias": "Option",
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Parameter",
        "alias": "Parameter",
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "argument",
        "alias": "argument",
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "command",
        "alias": "command",
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "confirmation_option",
        "alias": "confirmation_option",
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "group",
        "alias": "group",
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "help_option",
        "alias": "help_option",
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "make_pass_decorator",
        "alias": "make_pass_decorator",
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "option",
        "alias": "option",
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "pass_context",
        "alias": "pass_context",
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "pass_obj",
        "alias": "pass_obj",
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "password_option",
        "alias": "password_option",
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "version_option",
        "alias": "version_option",
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "Abort",
        "alias": "Abort",
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "BadArgumentUsage",
        "alias": "BadArgumentUsage",
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "BadOptionUsage",
        "alias": "BadOptionUsage",
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "BadParameter",
        "alias": "BadParameter",
        "lineno": 31,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "ClickException",
        "alias": "ClickException",
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "FileError",
        "alias": "FileError",
        "lineno": 33,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "MissingParameter",
        "alias": "MissingParameter",
        "lineno": 34,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "NoSuchOption",
        "alias": "NoSuchOption",
        "lineno": 35,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "UsageError",
        "alias": "UsageError",
        "lineno": 36,
        "type": "from_import"
      },
      {
        "module": "formatting",
        "name": "HelpFormatter",
        "alias": "HelpFormatter",
        "lineno": 37,
        "type": "from_import"
      },
      {
        "module": "formatting",
        "name": "wrap_text",
        "alias": "wrap_text",
        "lineno": 38,
        "type": "from_import"
      },
      {
        "module": "globals",
        "name": "get_current_context",
        "alias": "get_current_context",
        "lineno": 39,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "clear",
        "alias": "clear",
        "lineno": 40,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "confirm",
        "alias": "confirm",
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "echo_via_pager",
        "alias": "echo_via_pager",
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "edit",
        "alias": "edit",
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "getchar",
        "alias": "getchar",
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "launch",
        "alias": "launch",
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "pause",
        "alias": "pause",
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "progressbar",
        "alias": "progressbar",
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "prompt",
        "alias": "prompt",
        "lineno": 48,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "secho",
        "alias": "secho",
        "lineno": 49,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "style",
        "alias": "style",
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "unstyle",
        "alias": "unstyle",
        "lineno": 51,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "BOOL",
        "alias": "BOOL",
        "lineno": 52,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "Choice",
        "alias": "Choice",
        "lineno": 53,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "DateTime",
        "alias": "DateTime",
        "lineno": 54,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "File",
        "alias": "File",
        "lineno": 55,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "FLOAT",
        "alias": "FLOAT",
        "lineno": 56,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "FloatRange",
        "alias": "FloatRange",
        "lineno": 57,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "INT",
        "alias": "INT",
        "lineno": 58,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "IntRange",
        "alias": "IntRange",
        "lineno": 59,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "ParamType",
        "alias": "ParamType",
        "lineno": 60,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "Path",
        "alias": "Path",
        "lineno": 61,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "STRING",
        "alias": "STRING",
        "lineno": 62,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "Tuple",
        "alias": "Tuple",
        "lineno": 63,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "UNPROCESSED",
        "alias": "UNPROCESSED",
        "lineno": 64,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "UUID",
        "alias": "UUID",
        "lineno": 65,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "echo",
        "alias": "echo",
        "lineno": 66,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "format_filename",
        "alias": "format_filename",
        "lineno": 67,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "get_app_dir",
        "alias": "get_app_dir",
        "lineno": 68,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "get_binary_stream",
        "alias": "get_binary_stream",
        "lineno": 69,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "get_text_stream",
        "alias": "get_text_stream",
        "lineno": 70,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "open_file",
        "alias": "open_file",
        "lineno": 71,
        "type": "from_import"
      },
      {
        "module": "warnings",
        "alias": null,
        "lineno": 75,
        "type": "import"
      },
      {
        "module": "core",
        "name": "_BaseCommand",
        "alias": null,
        "lineno": 78,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "_MultiCommand",
        "alias": null,
        "lineno": 89,
        "type": "from_import"
      },
      {
        "module": "parser",
        "name": "_OptionParser",
        "alias": null,
        "lineno": 100,
        "type": "from_import"
      },
      {
        "module": "importlib.metadata",
        "alias": null,
        "lineno": 111,
        "type": "import"
      },
      {
        "module": "warnings",
        "alias": null,
        "lineno": 112,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "warnings"
      ],
      "third_party": {
        "other": [
          "__future__",
          "core",
          "decorators",
          "exceptions",
          "formatting",
          "globals",
          "termui",
          "types",
          "utils",
          "parser",
          "importlib"
        ]
      },
      "tech_stack": []
    },
    "line_count": 124
  },
  "src/click/_compat.py": {
    "filepath": "../click/src/click/_compat.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_make_text_stream",
        "args": [
          {
            "name": "stream",
            "type": "t.BinaryIO"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "force_readable",
            "type": "bool"
          },
          {
            "name": "force_writable",
            "type": "bool"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 19,
        "decorators": [],
        "is_async": false,
        "calls": [
          "force_writable",
          "_NonClosingTextIOWrapper",
          "errors",
          "force_readable",
          "get_best_encoding",
          "stream",
          "encoding"
        ],
        "docstring": null,
        "code": "def _make_text_stream(\n    stream: t.BinaryIO,\n    encoding: str | None,\n    errors: str | None,\n    force_readable: bool = False,\n    force_writable: bool = False,\n) -> t.TextIO:\n    if encoding is None:\n        encoding = get_best_encoding(stream)\n    if errors is None:\n        errors = \"replace\"\n    return _NonClosingTextIOWrapper(\n        stream,\n        encoding,\n        errors,\n        line_buffering=True,\n        force_readable=force_readable,\n        force_writable=force_writable,\n    )",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "is_ascii_encoding",
        "args": [
          {
            "name": "encoding",
            "type": "str"
          }
        ],
        "return_type": "bool",
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "codecs.lookup",
          "encoding"
        ],
        "docstring": "Checks if a given encoding is ascii.",
        "code": "def is_ascii_encoding(encoding: str) -> bool:\n    \"\"\"Checks if a given encoding is ascii.\"\"\"\n    try:\n        return codecs.lookup(encoding).name == \"ascii\"\n    except LookupError:\n        return False",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "get_best_encoding",
        "args": [
          {
            "name": "stream",
            "type": "t.IO[t.Any]"
          }
        ],
        "return_type": "str",
        "lineno": 48,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sys.getdefaultencoding",
          "rv",
          "stream",
          "is_ascii_encoding",
          "getattr"
        ],
        "docstring": "Returns the default stream encoding if not found.",
        "code": "def get_best_encoding(stream: t.IO[t.Any]) -> str:\n    \"\"\"Returns the default stream encoding if not found.\"\"\"\n    rv = getattr(stream, \"encoding\", None) or sys.getdefaultencoding()\n    if is_ascii_encoding(rv):\n        return \"utf-8\"\n    return rv",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "_is_binary_reader",
        "args": [
          {
            "name": "stream",
            "type": "t.IO[t.Any]"
          },
          {
            "name": "default",
            "type": "bool"
          }
        ],
        "return_type": "bool",
        "lineno": 151,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream.read",
          "bytes",
          "isinstance"
        ],
        "docstring": null,
        "code": "def _is_binary_reader(stream: t.IO[t.Any], default: bool = False) -> bool:\n    try:\n        return isinstance(stream.read(0), bytes)\n    except Exception:\n        return default",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "_is_binary_writer",
        "args": [
          {
            "name": "stream",
            "type": "t.IO[t.Any]"
          },
          {
            "name": "default",
            "type": "bool"
          }
        ],
        "return_type": "bool",
        "lineno": 160,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream.write"
        ],
        "docstring": null,
        "code": "def _is_binary_writer(stream: t.IO[t.Any], default: bool = False) -> bool:\n    try:\n        stream.write(b\"\")\n    except Exception:\n        try:\n            stream.write(\"\")\n            return False\n        except Exception:\n            pass\n        return default\n    return True",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "_find_binary_reader",
        "args": [
          {
            "name": "stream",
            "type": "t.IO[t.Any]"
          }
        ],
        "return_type": "Any",
        "lineno": 173,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_is_binary_reader",
          "t.cast",
          "buf",
          "stream",
          "getattr",
          "t.BinaryIO"
        ],
        "docstring": null,
        "code": "def _find_binary_reader(stream: t.IO[t.Any]) -> t.BinaryIO | None:\n    # We need to figure out if the given stream is already binary.\n    # This can happen because the official docs recommend detaching\n    # the streams to get binary streams.  Some code might do this, so\n    # we need to deal with this case explicitly.\n    if _is_binary_reader(stream, False):\n        return t.cast(t.BinaryIO, stream)\n\n    buf = getattr(stream, \"buffer\", None)\n\n    # Same situation here; this time we assume that the buffer is\n    # actually binary in case it's closed.\n    if buf is not None and _is_binary_reader(buf, True):\n        return t.cast(t.BinaryIO, buf)\n\n    return None",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "_find_binary_writer",
        "args": [
          {
            "name": "stream",
            "type": "t.IO[t.Any]"
          }
        ],
        "return_type": "Any",
        "lineno": 191,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_is_binary_writer",
          "t.cast",
          "buf",
          "stream",
          "getattr",
          "t.BinaryIO"
        ],
        "docstring": null,
        "code": "def _find_binary_writer(stream: t.IO[t.Any]) -> t.BinaryIO | None:\n    # We need to figure out if the given stream is already binary.\n    # This can happen because the official docs recommend detaching\n    # the streams to get binary streams.  Some code might do this, so\n    # we need to deal with this case explicitly.\n    if _is_binary_writer(stream, False):\n        return t.cast(t.BinaryIO, stream)\n\n    buf = getattr(stream, \"buffer\", None)\n\n    # Same situation here; this time we assume that the buffer is\n    # actually binary in case it's closed.\n    if buf is not None and _is_binary_writer(buf, True):\n        return t.cast(t.BinaryIO, buf)\n\n    return None",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "_stream_is_misconfigured",
        "args": [
          {
            "name": "stream",
            "type": "t.TextIO"
          }
        ],
        "return_type": "bool",
        "lineno": 209,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "is_ascii_encoding",
          "getattr"
        ],
        "docstring": "A stream is misconfigured if its encoding is ASCII.",
        "code": "def _stream_is_misconfigured(stream: t.TextIO) -> bool:\n    \"\"\"A stream is misconfigured if its encoding is ASCII.\"\"\"\n    # If the stream does not have an encoding set, we assume it's set\n    # to ASCII.  This appears to happen in certain unittest\n    # environments.  It's not quite clear what the correct behavior is\n    # but this at least will force Click to recover somehow.\n    return is_ascii_encoding(getattr(stream, \"encoding\", None) or \"ascii\")",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_is_compat_stream_attr",
        "args": [
          {
            "name": "stream",
            "type": "t.TextIO"
          },
          {
            "name": "attr",
            "type": "str"
          },
          {
            "name": "value",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 218,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "attr",
          "getattr"
        ],
        "docstring": "A stream attribute is compatible if it is equal to the\ndesired value or the desired value is unset and the attribute\nhas a value.",
        "code": "def _is_compat_stream_attr(stream: t.TextIO, attr: str, value: str | None) -> bool:\n    \"\"\"A stream attribute is compatible if it is equal to the\n    desired value or the desired value is unset and the attribute\n    has a value.\n    \"\"\"\n    stream_value = getattr(stream, attr, None)\n    return stream_value == value or (value is None and stream_value is not None)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_is_compatible_text_stream",
        "args": [
          {
            "name": "stream",
            "type": "t.TextIO"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 227,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "errors",
          "_is_compat_stream_attr",
          "encoding"
        ],
        "docstring": "Check if a stream's encoding and errors attributes are\ncompatible with the desired values.",
        "code": "def _is_compatible_text_stream(\n    stream: t.TextIO, encoding: str | None, errors: str | None\n) -> bool:\n    \"\"\"Check if a stream's encoding and errors attributes are\n    compatible with the desired values.\n    \"\"\"\n    return _is_compat_stream_attr(\n        stream, \"encoding\", encoding\n    ) and _is_compat_stream_attr(stream, \"errors\", errors)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "_force_correct_text_stream",
        "args": [
          {
            "name": "text_stream",
            "type": "t.IO[t.Any]"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "is_binary",
            "type": "t.Callable[Any, bool]"
          },
          {
            "name": "find_binary",
            "type": "t.Callable[Any, Any]"
          },
          {
            "name": "force_readable",
            "type": "bool"
          },
          {
            "name": "force_writable",
            "type": "bool"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 238,
        "decorators": [],
        "is_async": false,
        "calls": [
          "binary_reader",
          "t.TextIO",
          "_make_text_stream",
          "force_writable",
          "find_binary",
          "_stream_is_misconfigured",
          "text_stream",
          "t.cast",
          "errors",
          "force_readable",
          "possible_binary_reader",
          "_is_compatible_text_stream",
          "encoding",
          "t.BinaryIO",
          "is_binary"
        ],
        "docstring": null,
        "code": "def _force_correct_text_stream(\n    text_stream: t.IO[t.Any],\n    encoding: str | None,\n    errors: str | None,\n    is_binary: t.Callable[[t.IO[t.Any], bool], bool],\n    find_binary: t.Callable[[t.IO[t.Any]], t.BinaryIO | None],\n    force_readable: bool = False,\n    force_writable: bool = False,\n) -> t.TextIO:\n    if is_binary(text_stream, False):\n        binary_reader = t.cast(t.BinaryIO, text_stream)\n    else:\n        text_stream = t.cast(t.TextIO, text_stream)\n        # If the stream looks compatible, and won't default to a\n        # misconfigured ascii encoding, return it as-is.\n        if _is_compatible_text_stream(text_stream, encoding, errors) and not (\n            encoding is None and _stream_is_misconfigured(text_stream)\n        ):\n            return text_stream\n\n        # Otherwise, get the underlying binary reader.\n        possible_binary_reader = find_binary(text_stream)\n\n        # If that's not possible, silently use the original reader\n        # and get mojibake instead of exceptions.\n        if possible_binary_reader is None:\n            return text_stream\n\n        binary_reader = possible_binary_reader\n\n    # Default errors to replace instead of strict in order to get\n    # something that works.\n    if errors is None:\n        errors = \"replace\"\n\n    # Wrap the binary stream in a text stream with the correct\n    # encoding parameters.\n    return _make_text_stream(\n        binary_reader,\n        encoding,\n        errors,\n        force_readable=force_readable,\n        force_writable=force_writable,\n    )",
        "line_count": 44,
        "needs_llm_summary": true
      },
      {
        "name": "_force_correct_text_reader",
        "args": [
          {
            "name": "text_reader",
            "type": "t.IO[t.Any]"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "force_readable",
            "type": "bool"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 284,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text_reader",
          "_is_binary_reader",
          "_force_correct_text_stream",
          "_find_binary_reader",
          "errors",
          "force_readable",
          "encoding"
        ],
        "docstring": null,
        "code": "def _force_correct_text_reader(\n    text_reader: t.IO[t.Any],\n    encoding: str | None,\n    errors: str | None,\n    force_readable: bool = False,\n) -> t.TextIO:\n    return _force_correct_text_stream(\n        text_reader,\n        encoding,\n        errors,\n        _is_binary_reader,\n        _find_binary_reader,\n        force_readable=force_readable,\n    )",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "_force_correct_text_writer",
        "args": [
          {
            "name": "text_writer",
            "type": "t.IO[t.Any]"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "force_writable",
            "type": "bool"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 300,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_is_binary_writer",
          "force_writable",
          "_force_correct_text_stream",
          "text_writer",
          "errors",
          "encoding",
          "_find_binary_writer"
        ],
        "docstring": null,
        "code": "def _force_correct_text_writer(\n    text_writer: t.IO[t.Any],\n    encoding: str | None,\n    errors: str | None,\n    force_writable: bool = False,\n) -> t.TextIO:\n    return _force_correct_text_stream(\n        text_writer,\n        encoding,\n        errors,\n        _is_binary_writer,\n        _find_binary_writer,\n        force_writable=force_writable,\n    )",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "get_binary_stdin",
        "args": [],
        "return_type": "t.BinaryIO",
        "lineno": 316,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_find_binary_reader",
          "RuntimeError",
          "sys.stdin"
        ],
        "docstring": null,
        "code": "def get_binary_stdin() -> t.BinaryIO:\n    reader = _find_binary_reader(sys.stdin)\n    if reader is None:\n        raise RuntimeError(\"Was not able to determine binary stream for sys.stdin.\")\n    return reader",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_binary_stdout",
        "args": [],
        "return_type": "t.BinaryIO",
        "lineno": 323,
        "decorators": [],
        "is_async": false,
        "calls": [
          "RuntimeError",
          "sys.stdout",
          "_find_binary_writer"
        ],
        "docstring": null,
        "code": "def get_binary_stdout() -> t.BinaryIO:\n    writer = _find_binary_writer(sys.stdout)\n    if writer is None:\n        raise RuntimeError(\"Was not able to determine binary stream for sys.stdout.\")\n    return writer",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_binary_stderr",
        "args": [],
        "return_type": "t.BinaryIO",
        "lineno": 330,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sys.stderr",
          "RuntimeError",
          "_find_binary_writer"
        ],
        "docstring": null,
        "code": "def get_binary_stderr() -> t.BinaryIO:\n    writer = _find_binary_writer(sys.stderr)\n    if writer is None:\n        raise RuntimeError(\"Was not able to determine binary stream for sys.stderr.\")\n    return writer",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_text_stdin",
        "args": [
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 337,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_get_windows_console_stream",
          "sys.stdin",
          "_force_correct_text_reader",
          "errors",
          "encoding"
        ],
        "docstring": null,
        "code": "def get_text_stdin(encoding: str | None = None, errors: str | None = None) -> t.TextIO:\n    rv = _get_windows_console_stream(sys.stdin, encoding, errors)\n    if rv is not None:\n        return rv\n    return _force_correct_text_reader(sys.stdin, encoding, errors, force_readable=True)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_text_stdout",
        "args": [
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 344,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_get_windows_console_stream",
          "sys.stdout",
          "_force_correct_text_writer",
          "errors",
          "encoding"
        ],
        "docstring": null,
        "code": "def get_text_stdout(encoding: str | None = None, errors: str | None = None) -> t.TextIO:\n    rv = _get_windows_console_stream(sys.stdout, encoding, errors)\n    if rv is not None:\n        return rv\n    return _force_correct_text_writer(sys.stdout, encoding, errors, force_writable=True)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_text_stderr",
        "args": [
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 351,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_get_windows_console_stream",
          "sys.stderr",
          "_force_correct_text_writer",
          "errors",
          "encoding"
        ],
        "docstring": null,
        "code": "def get_text_stderr(encoding: str | None = None, errors: str | None = None) -> t.TextIO:\n    rv = _get_windows_console_stream(sys.stderr, encoding, errors)\n    if rv is not None:\n        return rv\n    return _force_correct_text_writer(sys.stderr, encoding, errors, force_writable=True)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "_wrap_io_open",
        "args": [
          {
            "name": "file",
            "type": "Any"
          },
          {
            "name": "mode",
            "type": "str"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          }
        ],
        "return_type": "t.IO[t.Any]",
        "lineno": 358,
        "decorators": [],
        "is_async": false,
        "calls": [
          "mode",
          "file",
          "errors",
          "open",
          "encoding"
        ],
        "docstring": "Handles not passing ``encoding`` and ``errors`` in binary mode.",
        "code": "def _wrap_io_open(\n    file: str | os.PathLike[str] | int,\n    mode: str,\n    encoding: str | None,\n    errors: str | None,\n) -> t.IO[t.Any]:\n    \"\"\"Handles not passing ``encoding`` and ``errors`` in binary mode.\"\"\"\n    if \"b\" in mode:\n        return open(file, mode)\n\n    return open(file, mode, encoding=encoding, errors=errors)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "open_stream",
        "args": [
          {
            "name": "filename",
            "type": "Any"
          },
          {
            "name": "mode",
            "type": "str"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "atomic",
            "type": "bool"
          }
        ],
        "return_type": "tuple[t.IO[t.Any], bool]",
        "lineno": 371,
        "decorators": [],
        "is_async": false,
        "calls": [
          "random.randrange",
          "os.stat",
          "f",
          "os",
          "ValueError",
          "os.path.realpath",
          "encoding",
          "os.fspath",
          "filename",
          "os.fsdecode",
          "os.access",
          "get_binary_stdout",
          "os.chmod",
          "any",
          "os.path.dirname",
          "errors",
          "_wrap_io_open",
          "perm",
          "af",
          "tmp_filename",
          "get_binary_stdin",
          "os.path.isdir",
          "os.path.join",
          "getattr",
          "os.open",
          "_AtomicFile",
          "get_text_stdout",
          "get_text_stdin",
          "e.filename",
          "fd",
          "mode",
          "t.cast",
          "flags",
          "os.W_OK"
        ],
        "docstring": null,
        "code": "def open_stream(\n    filename: str | os.PathLike[str],\n    mode: str = \"r\",\n    encoding: str | None = None,\n    errors: str | None = \"strict\",\n    atomic: bool = False,\n) -> tuple[t.IO[t.Any], bool]:\n    binary = \"b\" in mode\n    filename = os.fspath(filename)\n\n    # Standard streams first. These are simple because they ignore the\n    # atomic flag. Use fsdecode to handle Path(\"-\").\n    if os.fsdecode(filename) == \"-\":\n        if any(m in mode for m in [\"w\", \"a\", \"x\"]):\n            if binary:\n                return get_binary_stdout(), False\n            return get_text_stdout(encoding=encoding, errors=errors), False\n        if binary:\n            return get_binary_stdin(), False\n        return get_text_stdin(encoding=encoding, errors=errors), False\n\n    # Non-atomic writes directly go out through the regular open functions.\n    if not atomic:\n        return _wrap_io_open(filename, mode, encoding, errors), True\n\n    # Some usability stuff for atomic writes\n    if \"a\" in mode:\n        raise ValueError(\n            \"Appending to an existing file is not supported, because that\"\n            \" would involve an expensive `copy`-operation to a temporary\"\n            \" file. Open the file in normal `w`-mode and copy explicitly\"\n            \" if that's what you're after.\"\n        )\n    if \"x\" in mode:\n        raise ValueError(\"Use the `overwrite`-parameter instead.\")\n    if \"w\" not in mode:\n        raise ValueError(\"Atomic writes only make sense with `w`-mode.\")\n\n    # Atomic writes are more complicated.  They work by opening a file\n    # as a proxy in the same folder and then using the fdopen\n    # functionality to wrap it in a Python file.  Then we wrap it in an\n    # atomic file that moves the file over on close.\n    import errno\n    import random\n\n    try:\n        perm: int | None = os.stat(filename).st_mode\n    except OSError:\n        perm = None\n\n    flags = os.O_RDWR | os.O_CREAT | os.O_EXCL\n\n    if binary:\n        flags |= getattr(os, \"O_BINARY\", 0)\n\n    while True:\n        tmp_filename = os.path.join(\n            os.path.dirname(filename),\n            f\".__atomic-write{random.randrange(1 << 32):08x}\",\n        )\n        try:\n            fd = os.open(tmp_filename, flags, 0o666 if perm is None else perm)\n            break\n        except OSError as e:\n            if e.errno == errno.EEXIST or (\n                os.name == \"nt\"\n                and e.errno == errno.EACCES\n                and os.path.isdir(e.filename)\n                and os.access(e.filename, os.W_OK)\n            ):\n                continue\n            raise\n\n    if perm is not None:\n        os.chmod(tmp_filename, perm)  # in case perm includes bits in umask\n\n    f = _wrap_io_open(fd, mode, encoding, errors)\n    af = _AtomicFile(f, tmp_filename, os.path.realpath(filename))\n    return t.cast(t.IO[t.Any], af), True",
        "line_count": 79,
        "needs_llm_summary": true
      },
      {
        "name": "strip_ansi",
        "args": [
          {
            "name": "value",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 488,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_ansi_re.sub",
          "value"
        ],
        "docstring": null,
        "code": "def strip_ansi(value: str) -> str:\n    return _ansi_re.sub(\"\", value)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_is_jupyter_kernel_output",
        "args": [
          {
            "name": "stream",
            "type": "t.IO[t.Any]"
          }
        ],
        "return_type": "bool",
        "lineno": 492,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "isinstance",
          "stream.__class__.__module__.startswith",
          "stream._stream"
        ],
        "docstring": null,
        "code": "def _is_jupyter_kernel_output(stream: t.IO[t.Any]) -> bool:\n    while isinstance(stream, (_FixupStream, _NonClosingTextIOWrapper)):\n        stream = stream._stream\n\n    return stream.__class__.__module__.startswith(\"ipykernel.\")",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "should_strip_ansi",
        "args": [
          {
            "name": "stream",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 499,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "isatty",
          "sys.stdin",
          "_is_jupyter_kernel_output"
        ],
        "docstring": null,
        "code": "def should_strip_ansi(\n    stream: t.IO[t.Any] | None = None, color: bool | None = None\n) -> bool:\n    if color is None:\n        if stream is None:\n            stream = sys.stdin\n        return not isatty(stream) and not _is_jupyter_kernel_output(stream)\n    return not color",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "term_len",
        "args": [
          {
            "name": "x",
            "type": "str"
          }
        ],
        "return_type": "int",
        "lineno": 568,
        "decorators": [],
        "is_async": false,
        "calls": [
          "strip_ansi",
          "len",
          "x"
        ],
        "docstring": null,
        "code": "def term_len(x: str) -> int:\n    return len(strip_ansi(x))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "isatty",
        "args": [
          {
            "name": "stream",
            "type": "t.IO[t.Any]"
          }
        ],
        "return_type": "bool",
        "lineno": 572,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream.isatty"
        ],
        "docstring": null,
        "code": "def isatty(stream: t.IO[t.Any]) -> bool:\n    try:\n        return stream.isatty()\n    except Exception:\n        return False",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "_make_cached_stream_func",
        "args": [
          {
            "name": "src_func",
            "type": "t.Callable[Any, Any]"
          },
          {
            "name": "wrapper_func",
            "type": "t.Callable[Any, t.TextIO]"
          }
        ],
        "return_type": "t.Callable[Any, Any]",
        "lineno": 579,
        "decorators": [],
        "is_async": false,
        "calls": [
          "WeakKeyDictionary",
          "cache.get",
          "rv",
          "src_func",
          "wrapper_func",
          "stream"
        ],
        "docstring": null,
        "code": "def _make_cached_stream_func(\n    src_func: t.Callable[[], t.TextIO | None],\n    wrapper_func: t.Callable[[], t.TextIO],\n) -> t.Callable[[], t.TextIO | None]:\n    cache: cabc.MutableMapping[t.TextIO, t.TextIO] = WeakKeyDictionary()\n\n    def func() -> t.TextIO | None:\n        stream = src_func()\n\n        if stream is None:\n            return None\n\n        try:\n            rv = cache.get(stream)\n        except Exception:\n            rv = None\n        if rv is not None:\n            return rv\n        rv = wrapper_func()\n        try:\n            cache[stream] = rv\n        except Exception:\n            pass\n        return rv\n\n    return func",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "stream",
            "type": "t.BinaryIO"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "force_readable",
            "type": "bool"
          },
          {
            "name": "force_writable",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 57,
        "decorators": [],
        "is_async": false,
        "calls": [
          "force_writable",
          "super",
          "unknown.__init__",
          "t.cast",
          "errors",
          "force_readable",
          "stream",
          "extra",
          "_FixupStream",
          "encoding",
          "t.BinaryIO"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        stream: t.BinaryIO,\n        encoding: str | None,\n        errors: str | None,\n        force_readable: bool = False,\n        force_writable: bool = False,\n        **extra: t.Any,\n    ) -> None:\n        self._stream = stream = t.cast(\n            t.BinaryIO, _FixupStream(stream, force_readable, force_writable)\n        )\n        super().__init__(stream, encoding, errors, **extra)",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__del__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 71,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.detach"
        ],
        "docstring": null,
        "code": "def __del__(self) -> None:\n        try:\n            self.detach()\n        except Exception:\n            pass",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "isatty",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 77,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._stream.isatty"
        ],
        "docstring": null,
        "code": "def isatty(self) -> bool:\n        # https://bitbucket.org/pypy/pypy/issue/1803\n        return self._stream.isatty()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "stream",
            "type": "t.BinaryIO"
          },
          {
            "name": "force_readable",
            "type": "bool"
          },
          {
            "name": "force_writable",
            "type": "bool"
          }
        ],
        "return_type": null,
        "lineno": 92,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "force_readable",
          "force_writable"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        stream: t.BinaryIO,\n        force_readable: bool = False,\n        force_writable: bool = False,\n    ):\n        self._stream = stream\n        self._force_readable = force_readable\n        self._force_writable = force_writable",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "t.Any",
        "lineno": 102,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._stream",
          "name",
          "getattr"
        ],
        "docstring": null,
        "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._stream, name)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "read1",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "size",
            "type": "int"
          }
        ],
        "return_type": "bytes",
        "lineno": 105,
        "decorators": [],
        "is_async": false,
        "calls": [
          "size",
          "bytes",
          "f",
          "t.cast",
          "self._stream",
          "self._stream.read",
          "getattr"
        ],
        "docstring": null,
        "code": "def read1(self, size: int) -> bytes:\n        f = getattr(self._stream, \"read1\", None)\n\n        if f is not None:\n            return t.cast(bytes, f(size))\n\n        return self._stream.read(size)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "readable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 113,
        "decorators": [],
        "is_async": false,
        "calls": [
          "t.cast",
          "self._stream",
          "self._stream.read",
          "bool",
          "x",
          "getattr"
        ],
        "docstring": null,
        "code": "def readable(self) -> bool:\n        if self._force_readable:\n            return True\n        x = getattr(self._stream, \"readable\", None)\n        if x is not None:\n            return t.cast(bool, x())\n        try:\n            self._stream.read(0)\n        except Exception:\n            return False\n        return True",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "writable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 125,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._stream.write",
          "t.cast",
          "self._stream",
          "bool",
          "x",
          "getattr"
        ],
        "docstring": null,
        "code": "def writable(self) -> bool:\n        if self._force_writable:\n            return True\n        x = getattr(self._stream, \"writable\", None)\n        if x is not None:\n            return t.cast(bool, x())\n        try:\n            self._stream.write(b\"\")\n        except Exception:\n            try:\n                self._stream.write(b\"\")\n            except Exception:\n                return False\n        return True",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "seekable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 140,
        "decorators": [],
        "is_async": false,
        "calls": [
          "t.cast",
          "self._stream.tell",
          "self._stream",
          "bool",
          "self._stream.seek",
          "x",
          "getattr"
        ],
        "docstring": null,
        "code": "def seekable(self) -> bool:\n        x = getattr(self._stream, \"seekable\", None)\n        if x is not None:\n            return t.cast(bool, x())\n        try:\n            self._stream.seek(self._stream.tell())\n        except Exception:\n            return False\n        return True",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "f",
            "type": "t.IO[t.Any]"
          },
          {
            "name": "tmp_filename",
            "type": "str"
          },
          {
            "name": "real_filename",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 453,
        "decorators": [],
        "is_async": false,
        "calls": [
          "real_filename",
          "f",
          "tmp_filename"
        ],
        "docstring": null,
        "code": "def __init__(self, f: t.IO[t.Any], tmp_filename: str, real_filename: str) -> None:\n        self._f = f\n        self._tmp_filename = tmp_filename\n        self._real_filename = real_filename\n        self.closed = False",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "name",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 460,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def name(self) -> str:\n        return self._real_filename",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "delete",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 463,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.replace",
          "self._real_filename",
          "self._f.close",
          "self._tmp_filename"
        ],
        "docstring": null,
        "code": "def close(self, delete: bool = False) -> None:\n        if self.closed:\n            return\n        self._f.close()\n        os.replace(self._tmp_filename, self._real_filename)\n        self.closed = True",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "t.Any",
        "lineno": 470,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "self._f",
          "getattr"
        ],
        "docstring": null,
        "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._f, name)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "_AtomicFile",
        "lineno": 473,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __enter__(self) -> _AtomicFile:\n        return self",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Any"
          },
          {
            "name": "exc_value",
            "type": "Any"
          },
          {
            "name": "tb",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 476,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.close"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.close(delete=exc_type is not None)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 484,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "self._f"
        ],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return repr(self._f)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_get_argv_encoding",
        "args": [],
        "return_type": "str",
        "lineno": 515,
        "decorators": [],
        "is_async": false,
        "calls": [
          "locale.getpreferredencoding"
        ],
        "docstring": null,
        "code": "def _get_argv_encoding() -> str:\n        import locale\n\n        return locale.getpreferredencoding()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "auto_wrap_for_ansi",
        "args": [
          {
            "name": "stream",
            "type": "t.TextIO"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 522,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ansi_wrapper.stream",
          "colorama.AnsiToWin32",
          "t.TextIO",
          "s",
          "ansi_wrapper.reset_all",
          "strip",
          "rv",
          "t.cast",
          "_write",
          "should_strip_ansi",
          "_safe_write",
          "color",
          "rv.write",
          "_ansi_stream_wrappers.get",
          "stream"
        ],
        "docstring": "Support ANSI color and style codes on Windows by wrapping a\nstream with colorama.",
        "code": "def auto_wrap_for_ansi(stream: t.TextIO, color: bool | None = None) -> t.TextIO:\n        \"\"\"Support ANSI color and style codes on Windows by wrapping a\n        stream with colorama.\n        \"\"\"\n        try:\n            cached = _ansi_stream_wrappers.get(stream)\n        except Exception:\n            cached = None\n\n        if cached is not None:\n            return cached\n\n        import colorama\n\n        strip = should_strip_ansi(stream, color)\n        ansi_wrapper = colorama.AnsiToWin32(stream, strip=strip)\n        rv = t.cast(t.TextIO, ansi_wrapper.stream)\n        _write = rv.write\n\n        def _safe_write(s: str) -> int:\n            try:\n                return _write(s)\n            except BaseException:\n                ansi_wrapper.reset_all()\n                raise\n\n        rv.write = _safe_write  # type: ignore[method-assign]\n\n        try:\n            _ansi_stream_wrappers[stream] = rv\n        except Exception:\n            pass\n\n        return rv",
        "line_count": 34,
        "needs_llm_summary": true
      },
      {
        "name": "_get_argv_encoding",
        "args": [],
        "return_type": "str",
        "lineno": 559,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sys.getfilesystemencoding",
          "sys.stdin",
          "getattr"
        ],
        "docstring": null,
        "code": "def _get_argv_encoding() -> str:\n        return getattr(sys.stdin, \"encoding\", None) or sys.getfilesystemencoding()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_get_windows_console_stream",
        "args": [
          {
            "name": "f",
            "type": "t.TextIO"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 562,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def _get_windows_console_stream(\n        f: t.TextIO, encoding: str | None, errors: str | None\n    ) -> t.TextIO | None:\n        return None",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "func",
        "args": [],
        "return_type": "Any",
        "lineno": 585,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cache.get",
          "rv",
          "src_func",
          "wrapper_func",
          "stream"
        ],
        "docstring": null,
        "code": "def func() -> t.TextIO | None:\n        stream = src_func()\n\n        if stream is None:\n            return None\n\n        try:\n            rv = cache.get(stream)\n        except Exception:\n            rv = None\n        if rv is not None:\n            return rv\n        rv = wrapper_func()\n        try:\n            cache[stream] = rv\n        except Exception:\n            pass\n        return rv",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "_safe_write",
        "args": [
          {
            "name": "s",
            "type": "str"
          }
        ],
        "return_type": "int",
        "lineno": 541,
        "decorators": [],
        "is_async": false,
        "calls": [
          "s",
          "ansi_wrapper.reset_all",
          "_write"
        ],
        "docstring": null,
        "code": "def _safe_write(s: str) -> int:\n            try:\n                return _write(s)\n            except BaseException:\n                ansi_wrapper.reset_all()\n                raise",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "_NonClosingTextIOWrapper",
        "methods": [
          "__init__",
          "__del__",
          "isatty"
        ],
        "base_classes": [
          "io.TextIOWrapper"
        ],
        "lineno": 56,
        "docstring": null
      },
      {
        "name": "_FixupStream",
        "methods": [
          "__init__",
          "__getattr__",
          "read1",
          "readable",
          "writable",
          "seekable"
        ],
        "base_classes": [],
        "lineno": 82,
        "docstring": "The new io interface needs more from streams than streams\ntraditionally implement.  As such, this fix-up code is necessary in\nsome circumstances.\n\nThe forcing of readable and writable flags are there because some tools\nput badly patched objects on sys (one such offender are certain version\nof jupyter notebook)."
      },
      {
        "name": "_AtomicFile",
        "methods": [
          "__init__",
          "name",
          "close",
          "__getattr__",
          "__enter__",
          "__exit__",
          "__repr__"
        ],
        "base_classes": [],
        "lineno": 452,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "codecs",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "re",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 8,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 9,
        "type": "import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "weakref",
        "name": "WeakKeyDictionary",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "errno",
        "alias": null,
        "lineno": 413,
        "type": "import"
      },
      {
        "module": "random",
        "alias": null,
        "lineno": 414,
        "type": "import"
      },
      {
        "module": "_winconsole",
        "name": "_get_windows_console_stream",
        "alias": null,
        "lineno": 513,
        "type": "from_import"
      },
      {
        "module": "locale",
        "alias": null,
        "lineno": 516,
        "type": "import"
      },
      {
        "module": "colorama",
        "alias": null,
        "lineno": 534,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "CYGWIN",
        "assigned_to": "sys.platform.startswith",
        "lineno": 13
      },
      {
        "name": "WIN",
        "assigned_to": "sys.platform.startswith",
        "lineno": 14
      },
      {
        "name": "_ansi_re",
        "assigned_to": "re.compile",
        "lineno": 16
      },
      {
        "name": "_default_text_stdin",
        "assigned_to": "_make_cached_stream_func",
        "lineno": 607
      },
      {
        "name": "_default_text_stdout",
        "assigned_to": "_make_cached_stream_func",
        "lineno": 608
      },
      {
        "name": "_default_text_stderr",
        "assigned_to": "_make_cached_stream_func",
        "lineno": 609
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "colorama.AnsiToWin32",
        "t.TextIO",
        "strip",
        "get_text_stderr",
        "sys.getfilesystemencoding",
        "_make_cached_stream_func",
        "sys.stdin",
        "s",
        "ansi_wrapper.reset_all",
        "WeakKeyDictionary",
        "rv",
        "should_strip_ansi",
        "_safe_write",
        "_ansi_stream_wrappers.get",
        "stream",
        "_write",
        "getattr",
        "locale.getpreferredencoding",
        "color",
        "re.compile",
        "rv.write",
        "sys.platform.startswith",
        "get_text_stdout",
        "get_text_stdin",
        "t.cast",
        "ansi_wrapper.stream"
      ],
      "class_instantiations": [
        "WeakKeyDictionary"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "re",
        "typing",
        "random",
        "os",
        "collections",
        "io"
      ],
      "third_party": {
        "other": [
          "__future__",
          "codecs",
          "types",
          "weakref",
          "errno",
          "_winconsole",
          "locale",
          "colorama"
        ]
      },
      "tech_stack": []
    },
    "line_count": 623
  },
  "src/click/_termui_impl.py": {
    "filepath": "../click/src/click/_termui_impl.py",
    "module_docstring": "This module contains implementations for the termui module. To keep the\nimport time of Click down, some infrequently used functionality is\nplaced in this module and only imported as needed.",
    "functions": [
      {
        "name": "pager",
        "args": [
          {
            "name": "generator",
            "type": "cabc.Iterable[str]"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 369,
        "decorators": [],
        "is_async": false,
        "calls": [
          "pager_cmd_parts",
          "sys.stdin",
          "filename",
          "tempfile.mkstemp",
          "_tempfilepager",
          "_default_text_stdout",
          "_nullpager",
          "StringIO",
          "os.environ.get",
          "_pipepager",
          "os.unlink",
          "stdout",
          "os.close",
          "color",
          "sys.platform.startswith",
          "fd",
          "generator",
          "isatty",
          "shlex.split"
        ],
        "docstring": "Decide what method to use for paging through text.",
        "code": "def pager(generator: cabc.Iterable[str], color: bool | None = None) -> None:\n    \"\"\"Decide what method to use for paging through text.\"\"\"\n    stdout = _default_text_stdout()\n\n    # There are no standard streams attached to write to. For example,\n    # pythonw on Windows.\n    if stdout is None:\n        stdout = StringIO()\n\n    if not isatty(sys.stdin) or not isatty(stdout):\n        return _nullpager(stdout, generator, color)\n\n    # Split and normalize the pager command into parts.\n    pager_cmd_parts = shlex.split(os.environ.get(\"PAGER\", \"\"), posix=False)\n    if pager_cmd_parts:\n        if WIN:\n            if _tempfilepager(generator, pager_cmd_parts, color):\n                return\n        elif _pipepager(generator, pager_cmd_parts, color):\n            return\n\n    if os.environ.get(\"TERM\") in (\"dumb\", \"emacs\"):\n        return _nullpager(stdout, generator, color)\n    if (WIN or sys.platform.startswith(\"os2\")) and _tempfilepager(\n        generator, [\"more\"], color\n    ):\n        return\n    if _pipepager(generator, [\"less\"], color):\n        return\n\n    import tempfile\n\n    fd, filename = tempfile.mkstemp()\n    os.close(fd)\n    try:\n        if _pipepager(generator, [\"more\"], color):\n            return\n        return _nullpager(stdout, generator, color)\n    finally:\n        os.unlink(filename)",
        "line_count": 40,
        "needs_llm_summary": true
      },
      {
        "name": "_pipepager",
        "args": [
          {
            "name": "generator",
            "type": "cabc.Iterable[str]"
          },
          {
            "name": "cmd_parts",
            "type": "list[str]"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 411,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cmd_path.name",
          "cmd_filepath",
          "text",
          "Path",
          "cmd",
          "strip_ansi",
          "dict",
          "c.stdin.write",
          "c.terminate",
          "cmd_params",
          "os.environ.get",
          "str",
          "c.stdin.close",
          "shutil.which",
          "subprocess.PIPE",
          "unknown.join",
          "unknown.absolute",
          "c.wait",
          "os.environ",
          "subprocess.Popen",
          "env",
          "cmd_path"
        ],
        "docstring": "Page through text by feeding it to another program. Invoking a\npager through this might support colors.\n\nReturns `True` if the command was found, `False` otherwise and thus another\npager should be attempted.",
        "code": "def _pipepager(\n    generator: cabc.Iterable[str], cmd_parts: list[str], color: bool | None\n) -> bool:\n    \"\"\"Page through text by feeding it to another program. Invoking a\n    pager through this might support colors.\n\n    Returns `True` if the command was found, `False` otherwise and thus another\n    pager should be attempted.\n    \"\"\"\n    # Split the command into the invoked CLI and its parameters.\n    if not cmd_parts:\n        return False\n\n    import shutil\n\n    cmd = cmd_parts[0]\n    cmd_params = cmd_parts[1:]\n\n    cmd_filepath = shutil.which(cmd)\n    if not cmd_filepath:\n        return False\n\n    # Produces a normalized absolute path string.\n    # multi-call binaries such as busybox derive their identity from the symlink\n    # less -> busybox. resolve() causes them to misbehave. (eg. less becomes busybox)\n    cmd_path = Path(cmd_filepath).absolute()\n    cmd_name = cmd_path.name\n\n    import subprocess\n\n    # Make a local copy of the environment to not affect the global one.\n    env = dict(os.environ)\n\n    # If we're piping to less and the user hasn't decided on colors, we enable\n    # them by default we find the -R flag in the command line arguments.\n    if color is None and cmd_name == \"less\":\n        less_flags = f\"{os.environ.get('LESS', '')}{' '.join(cmd_params)}\"\n        if not less_flags:\n            env[\"LESS\"] = \"-R\"\n            color = True\n        elif \"r\" in less_flags or \"R\" in less_flags:\n            color = True\n\n    c = subprocess.Popen(\n        [str(cmd_path)] + cmd_params,\n        shell=False,\n        stdin=subprocess.PIPE,\n        env=env,\n        errors=\"replace\",\n        text=True,\n    )\n    assert c.stdin is not None\n    try:\n        for text in generator:\n            if not color:\n                text = strip_ansi(text)\n\n            c.stdin.write(text)\n    except BrokenPipeError:\n        # In case the pager exited unexpectedly, ignore the broken pipe error.\n        pass\n    except Exception as e:\n        # In case there is an exception we want to close the pager immediately\n        # and let the caller handle it.\n        # Otherwise the pager will keep running, and the user may not notice\n        # the error message, or worse yet it may leave the terminal in a broken state.\n        c.terminate()\n        raise e\n    finally:\n        # We must close stdin and wait for the pager to exit before we continue\n        try:\n            c.stdin.close()\n        # Close implies flush, so it might throw a BrokenPipeError if the pager\n        # process exited already.\n        except BrokenPipeError:\n            pass\n\n        # Less doesn't respect ^C, but catches it for its own UI purposes (aborting\n        # search or other commands inside less).\n        #\n        # That means when the user hits ^C, the parent process (click) terminates,\n        # but less is still alive, paging the output and messing up the terminal.\n        #\n        # If the user wants to make the pager exit on ^C, they should set\n        # `LESS='-K'`. It's not our decision to make.\n        while True:\n            try:\n                c.wait()\n            except KeyboardInterrupt:\n                pass\n            else:\n                break\n\n    return True",
        "line_count": 94,
        "needs_llm_summary": true
      },
      {
        "name": "_tempfilepager",
        "args": [
          {
            "name": "generator",
            "type": "cabc.Iterable[str]"
          },
          {
            "name": "cmd_parts",
            "type": "list[str]"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 507,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "cmd_filepath",
          "Path",
          "f.write",
          "get_best_encoding",
          "cmd",
          "encoding",
          "strip_ansi",
          "filename",
          "tempfile.mkstemp",
          "open_stream",
          "str",
          "os.unlink",
          "shutil.which",
          "os.close",
          "fd",
          "unknown.join",
          "generator",
          "sys.stdout",
          "text.encode",
          "unknown.absolute",
          "subprocess.call",
          "cmd_path"
        ],
        "docstring": "Page through text by invoking a program on a temporary file.\n\nReturns `True` if the command was found, `False` otherwise and thus another\npager should be attempted.",
        "code": "def _tempfilepager(\n    generator: cabc.Iterable[str], cmd_parts: list[str], color: bool | None\n) -> bool:\n    \"\"\"Page through text by invoking a program on a temporary file.\n\n    Returns `True` if the command was found, `False` otherwise and thus another\n    pager should be attempted.\n    \"\"\"\n    # Split the command into the invoked CLI and its parameters.\n    if not cmd_parts:\n        return False\n\n    import shutil\n\n    cmd = cmd_parts[0]\n\n    cmd_filepath = shutil.which(cmd)\n    if not cmd_filepath:\n        return False\n    # Produces a normalized absolute path string.\n    # multi-call binaries such as busybox derive their identity from the symlink\n    # less -> busybox. resolve() causes them to misbehave. (eg. less becomes busybox)\n    cmd_path = Path(cmd_filepath).absolute()\n\n    import subprocess\n    import tempfile\n\n    fd, filename = tempfile.mkstemp()\n    # TODO: This never terminates if the passed generator never terminates.\n    text = \"\".join(generator)\n    if not color:\n        text = strip_ansi(text)\n    encoding = get_best_encoding(sys.stdout)\n    with open_stream(filename, \"wb\")[0] as f:\n        f.write(text.encode(encoding))\n    try:\n        subprocess.call([str(cmd_path), filename])\n    except OSError:\n        # Command not found\n        pass\n    finally:\n        os.close(fd)\n        os.unlink(filename)\n\n    return True",
        "line_count": 45,
        "needs_llm_summary": true
      },
      {
        "name": "_nullpager",
        "args": [
          {
            "name": "stream",
            "type": "t.TextIO"
          },
          {
            "name": "generator",
            "type": "cabc.Iterable[str]"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 554,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "strip_ansi",
          "stream.write"
        ],
        "docstring": "Simply print unformatted text.  This is the ultimate fallback.",
        "code": "def _nullpager(\n    stream: t.TextIO, generator: cabc.Iterable[str], color: bool | None\n) -> None:\n    \"\"\"Simply print unformatted text.  This is the ultimate fallback.\"\"\"\n    for text in generator:\n        if not color:\n            text = strip_ansi(text)\n        stream.write(text)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "open_url",
        "args": [
          {
            "name": "url",
            "type": "str"
          },
          {
            "name": "wait",
            "type": "bool"
          },
          {
            "name": "locate",
            "type": "bool"
          }
        ],
        "return_type": "int",
        "lineno": 676,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.wait",
          "null",
          "unquote",
          "args.append",
          "url",
          "c.wait",
          "os.path.dirname",
          "webbrowser.open",
          "subprocess.call",
          "null.close",
          "args",
          "url.startswith",
          "open",
          "subprocess.Popen",
          "_unquote_file"
        ],
        "docstring": null,
        "code": "def open_url(url: str, wait: bool = False, locate: bool = False) -> int:\n    import subprocess\n\n    def _unquote_file(url: str) -> str:\n        from urllib.parse import unquote\n\n        if url.startswith(\"file://\"):\n            url = unquote(url[7:])\n\n        return url\n\n    if sys.platform == \"darwin\":\n        args = [\"open\"]\n        if wait:\n            args.append(\"-W\")\n        if locate:\n            args.append(\"-R\")\n        args.append(_unquote_file(url))\n        null = open(\"/dev/null\", \"w\")\n        try:\n            return subprocess.Popen(args, stderr=null).wait()\n        finally:\n            null.close()\n    elif WIN:\n        if locate:\n            url = _unquote_file(url)\n            args = [\"explorer\", f\"/select,{url}\"]\n        else:\n            args = [\"start\"]\n            if wait:\n                args.append(\"/WAIT\")\n            args.append(\"\")\n            args.append(url)\n        try:\n            return subprocess.call(args)\n        except OSError:\n            # Command not found\n            return 127\n    elif CYGWIN:\n        if locate:\n            url = _unquote_file(url)\n            args = [\"cygstart\", os.path.dirname(url)]\n        else:\n            args = [\"cygstart\"]\n            if wait:\n                args.append(\"-w\")\n            args.append(url)\n        try:\n            return subprocess.call(args)\n        except OSError:\n            # Command not found\n            return 127\n\n    try:\n        if locate:\n            url = os.path.dirname(_unquote_file(url)) or \".\"\n        else:\n            url = _unquote_file(url)\n        c = subprocess.Popen([\"xdg-open\", url])\n        if wait:\n            return c.wait()\n        return 0\n    except OSError:\n        if url.startswith((\"http://\", \"https://\")) and not locate and not wait:\n            import webbrowser\n\n            webbrowser.open(url)\n            return 0\n        return 1",
        "line_count": 69,
        "needs_llm_summary": true
      },
      {
        "name": "_translate_ch_to_exc",
        "args": [
          {
            "name": "ch",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 747,
        "decorators": [],
        "is_async": false,
        "calls": [
          "KeyboardInterrupt",
          "EOFError"
        ],
        "docstring": null,
        "code": "def _translate_ch_to_exc(ch: str) -> None:\n    if ch == \"\\x03\":\n        raise KeyboardInterrupt()\n\n    if ch == \"\\x04\" and not WIN:  # Unix-like, Ctrl+D\n        raise EOFError()\n\n    if ch == \"\\x1a\" and WIN:  # Windows, Ctrl+Z\n        raise EOFError()\n\n    return None",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "iterable",
            "type": "Any"
          },
          {
            "name": "length",
            "type": "Any"
          },
          {
            "name": "fill_char",
            "type": "str"
          },
          {
            "name": "empty_char",
            "type": "str"
          },
          {
            "name": "bar_template",
            "type": "str"
          },
          {
            "name": "info_sep",
            "type": "str"
          },
          {
            "name": "hidden",
            "type": "bool"
          },
          {
            "name": "show_eta",
            "type": "bool"
          },
          {
            "name": "show_percent",
            "type": "Any"
          },
          {
            "name": "show_pos",
            "type": "bool"
          },
          {
            "name": "item_show_func",
            "type": "Any"
          },
          {
            "name": "label",
            "type": "Any"
          },
          {
            "name": "file",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "Any"
          },
          {
            "name": "update_min_steps",
            "type": "int"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 44,
        "decorators": [],
        "is_async": false,
        "calls": [
          "length_hint",
          "TypeError",
          "update_min_steps",
          "iter",
          "info_sep",
          "fill_char",
          "show_percent",
          "show_pos",
          "file",
          "length",
          "show_eta",
          "_default_text_stdout",
          "hidden",
          "item_show_func",
          "bar_template",
          "StringIO",
          "iterable",
          "color",
          "range",
          "time.time",
          "empty_char",
          "isatty",
          "t.cast",
          "self.file"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        iterable: cabc.Iterable[V] | None,\n        length: int | None = None,\n        fill_char: str = \"#\",\n        empty_char: str = \" \",\n        bar_template: str = \"%(bar)s\",\n        info_sep: str = \"  \",\n        hidden: bool = False,\n        show_eta: bool = True,\n        show_percent: bool | None = None,\n        show_pos: bool = False,\n        item_show_func: t.Callable[[V | None], str | None] | None = None,\n        label: str | None = None,\n        file: t.TextIO | None = None,\n        color: bool | None = None,\n        update_min_steps: int = 1,\n        width: int = 30,\n    ) -> None:\n        self.fill_char = fill_char\n        self.empty_char = empty_char\n        self.bar_template = bar_template\n        self.info_sep = info_sep\n        self.hidden = hidden\n        self.show_eta = show_eta\n        self.show_percent = show_percent\n        self.show_pos = show_pos\n        self.item_show_func = item_show_func\n        self.label: str = label or \"\"\n\n        if file is None:\n            file = _default_text_stdout()\n\n            # There are no standard streams attached to write to. For example,\n            # pythonw on Windows.\n            if file is None:\n                file = StringIO()\n\n        self.file = file\n        self.color = color\n        self.update_min_steps = update_min_steps\n        self._completed_intervals = 0\n        self.width: int = width\n        self.autowidth: bool = width == 0\n\n        if length is None:\n            from operator import length_hint\n\n            length = length_hint(iterable, -1)\n\n            if length == -1:\n                length = None\n        if iterable is None:\n            if length is None:\n                raise TypeError(\"iterable or length is required\")\n            iterable = t.cast(\"cabc.Iterable[V]\", range(length))\n        self.iter: cabc.Iterable[V] = iter(iterable)\n        self.length = length\n        self.pos: int = 0\n        self.avg: list[float] = []\n        self.last_eta: float\n        self.start: float\n        self.start = self.last_eta = time.time()\n        self.eta_known: bool = False\n        self.finished: bool = False\n        self.max_width: int | None = None\n        self.entered: bool = False\n        self.current_item: V | None = None\n        self._is_atty = isatty(self.file)\n        self._last_line: str | None = None",
        "line_count": 70,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ProgressBar[V]",
        "lineno": 115,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.render_progress"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> ProgressBar[V]:\n        self.entered = True\n        self.render_progress()\n        return self",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Any"
          },
          {
            "name": "exc_value",
            "type": "Any"
          },
          {
            "name": "tb",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 120,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.render_finish"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.render_finish()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__iter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "cabc.Iterator[V]",
        "lineno": 128,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.generator",
          "RuntimeError",
          "self.render_progress"
        ],
        "docstring": null,
        "code": "def __iter__(self) -> cabc.Iterator[V]:\n        if not self.entered:\n            raise RuntimeError(\"You need to use progress bars in a with block.\")\n        self.render_progress()\n        return self.generator()",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__next__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "V",
        "lineno": 134,
        "decorators": [],
        "is_async": false,
        "calls": [
          "next",
          "iter",
          "self"
        ],
        "docstring": null,
        "code": "def __next__(self) -> V:\n        # Iteration is defined in terms of a generator function,\n        # returned by iter(self); use that to define next(). This works\n        # because `self.iter` is an iterable consumed by that generator,\n        # so it is re-entry safe. Calling `next(self.generator())`\n        # twice works and does \"what you want\".\n        return next(iter(self))",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "render_finish",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 142,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.file.write",
          "AFTER_BAR",
          "self.file.flush"
        ],
        "docstring": null,
        "code": "def render_finish(self) -> None:\n        if self.hidden or not self._is_atty:\n            return\n        self.file.write(AFTER_BAR)\n        self.file.flush()",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "pct",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "float",
        "lineno": 149,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "min",
          "float"
        ],
        "docstring": null,
        "code": "def pct(self) -> float:\n        if self.finished:\n            return 1.0\n        return min(self.pos / (float(self.length or 1) or 1), 1.0)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "time_per_iteration",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "float",
        "lineno": 155,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.avg",
          "len",
          "float",
          "sum"
        ],
        "docstring": null,
        "code": "def time_per_iteration(self) -> float:\n        if not self.avg:\n            return 0.0\n        return sum(self.avg) / float(len(self.avg))",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "eta",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "float",
        "lineno": 161,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def eta(self) -> float:\n        if self.length is not None and not self.finished:\n            return self.time_per_iteration * (self.length - self.pos)\n        return 0.0",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "format_eta",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 166,
        "decorators": [],
        "is_async": false,
        "calls": [
          "int",
          "self.eta"
        ],
        "docstring": null,
        "code": "def format_eta(self) -> str:\n        if self.eta_known:\n            t = int(self.eta)\n            seconds = t % 60\n            t //= 60\n            minutes = t % 60\n            t //= 60\n            hours = t % 24\n            t //= 24\n            if t > 0:\n                return f\"{t}d {hours:02}:{minutes:02}:{seconds:02}\"\n            else:\n                return f\"{hours:02}:{minutes:02}:{seconds:02}\"\n        return \"\"",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "format_pos",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 181,
        "decorators": [],
        "is_async": false,
        "calls": [
          "str",
          "self.pos"
        ],
        "docstring": null,
        "code": "def format_pos(self) -> str:\n        pos = str(self.pos)\n        if self.length is not None:\n            pos += f\"/{self.length}\"\n        return pos",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "format_pct",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 187,
        "decorators": [],
        "is_async": false,
        "calls": [
          "int"
        ],
        "docstring": null,
        "code": "def format_pct(self) -> str:\n        return f\"{int(self.pct * 100): 4}%\"[1:]",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "format_bar",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 190,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "int",
          "list",
          "math.cos",
          "self.fill_char",
          "chars"
        ],
        "docstring": null,
        "code": "def format_bar(self) -> str:\n        if self.length is not None:\n            bar_length = int(self.pct * self.width)\n            bar = self.fill_char * bar_length\n            bar += self.empty_char * (self.width - bar_length)\n        elif self.finished:\n            bar = self.fill_char * self.width\n        else:\n            chars = list(self.empty_char * (self.width or 1))\n            if self.time_per_iteration != 0:\n                chars[\n                    int(\n                        (math.cos(self.pos * self.time_per_iteration) / 2.0 + 0.5)\n                        * self.width\n                    )\n                ] = self.fill_char\n            bar = \"\".join(chars)\n        return bar",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "format_progress_line",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 209,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.format_bar",
          "item_info",
          "self.info_sep.join",
          "self.format_eta",
          "self.format_pos",
          "self.item_show_func",
          "self.format_pct",
          "info_bits.append",
          "self.current_item",
          "self.show_percent",
          "info_bits",
          "unknown.rstrip"
        ],
        "docstring": null,
        "code": "def format_progress_line(self) -> str:\n        show_percent = self.show_percent\n\n        info_bits = []\n        if self.length is not None and show_percent is None:\n            show_percent = not self.show_pos\n\n        if self.show_pos:\n            info_bits.append(self.format_pos())\n        if show_percent:\n            info_bits.append(self.format_pct())\n        if self.show_eta and self.eta_known and not self.finished:\n            info_bits.append(self.format_eta())\n        if self.item_show_func is not None:\n            item_info = self.item_show_func(self.current_item)\n            if item_info is not None:\n                info_bits.append(item_info)\n\n        return (\n            self.bar_template\n            % {\n                \"label\": self.label,\n                \"bar\": self.format_bar(),\n                \"info\": self.info_sep.join(info_bits),\n            }\n        ).rstrip()",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "render_progress",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 236,
        "decorators": [],
        "is_async": false,
        "calls": [
          "BEFORE_BAR",
          "echo",
          "buf.append",
          "term_len",
          "self.format_progress_line",
          "unknown.join",
          "shutil.get_terminal_size",
          "max",
          "new_width",
          "line_len",
          "self.max_width",
          "self.file",
          "self.color",
          "self.file.flush",
          "self.width",
          "line",
          "buf",
          "self.label"
        ],
        "docstring": null,
        "code": "def render_progress(self) -> None:\n        if self.hidden:\n            return\n\n        if not self._is_atty:\n            # Only output the label once if the output is not a TTY.\n            if self._last_line != self.label:\n                self._last_line = self.label\n                echo(self.label, file=self.file, color=self.color)\n            return\n\n        buf = []\n        # Update width in case the terminal has been resized\n        if self.autowidth:\n            import shutil\n\n            old_width = self.width\n            self.width = 0\n            clutter_length = term_len(self.format_progress_line())\n            new_width = max(0, shutil.get_terminal_size().columns - clutter_length)\n            if new_width < old_width and self.max_width is not None:\n                buf.append(BEFORE_BAR)\n                buf.append(\" \" * self.max_width)\n                self.max_width = new_width\n            self.width = new_width\n\n        clear_width = self.width\n        if self.max_width is not None:\n            clear_width = self.max_width\n\n        buf.append(BEFORE_BAR)\n        line = self.format_progress_line()\n        line_len = term_len(line)\n        if self.max_width is None or self.max_width < line_len:\n            self.max_width = line_len\n\n        buf.append(line)\n        buf.append(\" \" * (clear_width - line_len))\n        line = \"\".join(buf)\n        # Render the line only if it changed.\n\n        if line != self._last_line:\n            self._last_line = line\n            echo(line, file=self.file, color=self.color, nl=False)\n            self.file.flush()",
        "line_count": 45,
        "needs_llm_summary": true
      },
      {
        "name": "make_step",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "n_steps",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 282,
        "decorators": [],
        "is_async": false,
        "calls": [
          "time.time"
        ],
        "docstring": null,
        "code": "def make_step(self, n_steps: int) -> None:\n        self.pos += n_steps\n        if self.length is not None and self.pos >= self.length:\n            self.finished = True\n\n        if (time.time() - self.last_eta) < 1.0:\n            return\n\n        self.last_eta = time.time()\n\n        # self.avg is a rolling list of length <= 7 of steps where steps are\n        # defined as time elapsed divided by the total progress through\n        # self.length.\n        if self.pos:\n            step = (time.time() - self.start) / self.pos\n        else:\n            step = time.time() - self.start\n\n        self.avg = self.avg[-6:] + [step]\n\n        self.eta_known = self.length is not None",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "n_steps",
            "type": "int"
          },
          {
            "name": "current_item",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 304,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._completed_intervals",
          "self.make_step",
          "current_item",
          "self.render_progress"
        ],
        "docstring": "Update the progress bar by advancing a specified number of\nsteps, and optionally set the ``current_item`` for this new\nposition.\n\n:param n_steps: Number of steps to advance.\n:param current_item: Optional item to set as ``current_item``\n    for the updated position.\n\n.. versionchanged:: 8.0\n    Added the ``current_item`` optional parameter.\n\n.. versionchanged:: 8.0\n    Only render when the number of steps meets the\n    ``update_min_steps`` threshold.",
        "code": "def update(self, n_steps: int, current_item: V | None = None) -> None:\n        \"\"\"Update the progress bar by advancing a specified number of\n        steps, and optionally set the ``current_item`` for this new\n        position.\n\n        :param n_steps: Number of steps to advance.\n        :param current_item: Optional item to set as ``current_item``\n            for the updated position.\n\n        .. versionchanged:: 8.0\n            Added the ``current_item`` optional parameter.\n\n        .. versionchanged:: 8.0\n            Only render when the number of steps meets the\n            ``update_min_steps`` threshold.\n        \"\"\"\n        if current_item is not None:\n            self.current_item = current_item\n\n        self._completed_intervals += n_steps\n\n        if self._completed_intervals >= self.update_min_steps:\n            self.make_step(self._completed_intervals)\n            self.render_progress()\n            self._completed_intervals = 0",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "finish",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 330,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def finish(self) -> None:\n        self.eta_known = False\n        self.current_item = None\n        self.finished = True",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "generator",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "cabc.Iterator[V]",
        "lineno": 335,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.update",
          "rv",
          "RuntimeError",
          "self.render_progress",
          "self.finish"
        ],
        "docstring": "Return a generator which yields the items added to the bar\nduring construction, and updates the progress bar *after* the\nyielded block returns.",
        "code": "def generator(self) -> cabc.Iterator[V]:\n        \"\"\"Return a generator which yields the items added to the bar\n        during construction, and updates the progress bar *after* the\n        yielded block returns.\n        \"\"\"\n        # WARNING: the iterator interface for `ProgressBar` relies on\n        # this and only works because this is a simple generator which\n        # doesn't create or manage additional state. If this function\n        # changes, the impact should be evaluated both against\n        # `iter(bar)` and `next(bar)`. `next()` in particular may call\n        # `self.generator()` repeatedly, and this must remain safe in\n        # order for that interface to work.\n        if not self.entered:\n            raise RuntimeError(\"You need to use progress bars in a with block.\")\n\n        if not self._is_atty:\n            yield from self.iter\n        else:\n            for rv in self.iter:\n                self.current_item = rv\n\n                # This allows show_item_func to be updated before the\n                # item is processed. Only trigger at the beginning of\n                # the update interval.\n                if self._completed_intervals == 0:\n                    self.render_progress()\n\n                yield rv\n                self.update(1)\n\n            self.finish()\n            self.render_progress()",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "editor",
            "type": "Any"
          },
          {
            "name": "env",
            "type": "Any"
          },
          {
            "name": "require_save",
            "type": "bool"
          },
          {
            "name": "extension",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 565,
        "decorators": [],
        "is_async": false,
        "calls": [
          "require_save",
          "env",
          "extension",
          "editor"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        editor: str | None = None,\n        env: cabc.Mapping[str, str] | None = None,\n        require_save: bool = True,\n        extension: str = \".txt\",\n    ) -> None:\n        self.editor = editor\n        self.env = env\n        self.require_save = require_save\n        self.extension = extension",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "get_editor",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 577,
        "decorators": [],
        "is_async": false,
        "calls": [
          "editor",
          "key",
          "which",
          "os.environ.get"
        ],
        "docstring": null,
        "code": "def get_editor(self) -> str:\n        if self.editor is not None:\n            return self.editor\n        for key in \"VISUAL\", \"EDITOR\":\n            rv = os.environ.get(key)\n            if rv:\n                return rv\n        if WIN:\n            return \"notepad\"\n\n        from shutil import which\n\n        for editor in \"sensible-editor\", \"vim\", \"nano\":\n            if which(editor) is not None:\n                return editor\n        return \"vi\"",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "edit_files",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "filenames",
            "type": "cabc.Iterable[str]"
          }
        ],
        "return_type": "None",
        "lineno": 594,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.get_editor",
          "ClickException",
          "e",
          "unknown.join",
          "c.wait",
          "editor",
          "_",
          "environ.update",
          "os.environ.copy",
          "subprocess.Popen",
          "environ",
          "unknown.format",
          "self.env"
        ],
        "docstring": null,
        "code": "def edit_files(self, filenames: cabc.Iterable[str]) -> None:\n        import subprocess\n\n        editor = self.get_editor()\n        environ: dict[str, str] | None = None\n\n        if self.env:\n            environ = os.environ.copy()\n            environ.update(self.env)\n\n        exc_filename = \" \".join(f'\"{filename}\"' for filename in filenames)\n\n        try:\n            c = subprocess.Popen(\n                args=f\"{editor} {exc_filename}\", env=environ, shell=True\n            )\n            exit_code = c.wait()\n            if exit_code != 0:\n                raise ClickException(\n                    _(\"{editor}: Editing failed\").format(editor=editor)\n                )\n        except OSError as e:\n            raise ClickException(\n                _(\"{editor}: Editing failed: {e}\").format(editor=editor, e=e)\n            ) from e",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "edit",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 621,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def edit(self, text: bytes | bytearray) -> bytes | None: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "edit",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 626,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def edit(self, text: str | None) -> str | None: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "edit",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 628,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "data",
          "f.write",
          "isinstance",
          "f.read",
          "os.path.getmtime",
          "text.endswith",
          "tempfile.mkstemp",
          "self.edit_files",
          "name",
          "rv.decode",
          "unknown.replace",
          "os.path.getatime",
          "text.replace",
          "os.unlink",
          "unknown.encode",
          "os.utime",
          "open",
          "fd",
          "os.fdopen",
          "self.extension",
          "text.encode"
        ],
        "docstring": null,
        "code": "def edit(self, text: str | bytes | bytearray | None) -> str | bytes | None:\n        import tempfile\n\n        if text is None:\n            data: bytes | bytearray = b\"\"\n        elif isinstance(text, (bytes, bytearray)):\n            data = text\n        else:\n            if text and not text.endswith(\"\\n\"):\n                text += \"\\n\"\n\n            if WIN:\n                data = text.replace(\"\\n\", \"\\r\\n\").encode(\"utf-8-sig\")\n            else:\n                data = text.encode(\"utf-8\")\n\n        fd, name = tempfile.mkstemp(prefix=\"editor-\", suffix=self.extension)\n        f: t.BinaryIO\n\n        try:\n            with os.fdopen(fd, \"wb\") as f:\n                f.write(data)\n\n            # If the filesystem resolution is 1 second, like Mac OS\n            # 10.12 Extended, or 2 seconds, like FAT32, and the editor\n            # closes very fast, require_save can fail. Set the modified\n            # time to be 2 seconds in the past to work around this.\n            os.utime(name, (os.path.getatime(name), os.path.getmtime(name) - 2))\n            # Depending on the resolution, the exact value might not be\n            # recorded, so get the new recorded value.\n            timestamp = os.path.getmtime(name)\n\n            self.edit_files((name,))\n\n            if self.require_save and os.path.getmtime(name) == timestamp:\n                return None\n\n            with open(name, \"rb\") as f:\n                rv = f.read()\n\n            if isinstance(text, (bytes, bytearray)):\n                return rv\n\n            return rv.decode(\"utf-8-sig\").replace(\"\\r\\n\", \"\\n\")\n        finally:\n            os.unlink(name)",
        "line_count": 46,
        "needs_llm_summary": true
      },
      {
        "name": "_unquote_file",
        "args": [
          {
            "name": "url",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 679,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unquote",
          "url.startswith"
        ],
        "docstring": null,
        "code": "def _unquote_file(url: str) -> str:\n        from urllib.parse import unquote\n\n        if url.startswith(\"file://\"):\n            url = unquote(url[7:])\n\n        return url",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "raw_terminal",
        "args": [],
        "return_type": "cabc.Iterator[int]",
        "lineno": 764,
        "decorators": [
          {
            "name": "contextlib.contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def raw_terminal() -> cabc.Iterator[int]:\n        yield -1",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "getchar",
        "args": [
          {
            "name": "echo",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 767,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_translate_ch_to_exc",
          "msvcrt.getwch",
          "rv",
          "t.cast",
          "func",
          "msvcrt.getwche"
        ],
        "docstring": null,
        "code": "def getchar(echo: bool) -> str:\n        # The function `getch` will return a bytes object corresponding to\n        # the pressed character. Since Windows 10 build 1803, it will also\n        # return \\x00 when called a second time after pressing a regular key.\n        #\n        # `getwch` does not share this probably-bugged behavior. Moreover, it\n        # returns a Unicode object by default, which is what we want.\n        #\n        # Either of these functions will return \\x00 or \\xe0 to indicate\n        # a special key, and you need to call the same function again to get\n        # the \"rest\" of the code. The fun part is that \\u00e0 is\n        # \"latin small letter a with grave\", so if you type that on a French\n        # keyboard, you _also_ get a \\xe0.\n        # E.g., consider the Up arrow. This returns \\xe0 and then \\x48. The\n        # resulting Unicode string reads as \"a with grave\" + \"capital H\".\n        # This is indistinguishable from when the user actually types\n        # \"a with grave\" and then \"capital H\".\n        #\n        # When \\xe0 is returned, we assume it's part of a special-key sequence\n        # and call `getwch` again, but that means that when the user types\n        # the \\u00e0 character, `getchar` doesn't return until a second\n        # character is typed.\n        # The alternative is returning immediately, but that would mess up\n        # cross-platform handling of arrow keys and others that start with\n        # \\xe0. Another option is using `getch`, but then we can't reliably\n        # read non-ASCII characters, because return values of `getch` are\n        # limited to the current 8-bit codepage.\n        #\n        # Anyway, Click doesn't claim to do this Right(tm), and using `getwch`\n        # is doing the right thing in more situations than with `getch`.\n\n        if echo:\n            func = t.cast(t.Callable[[], str], msvcrt.getwche)\n        else:\n            func = t.cast(t.Callable[[], str], msvcrt.getwch)\n\n        rv = func()\n\n        if rv in (\"\\x00\", \"\\xe0\"):\n            # \\x00 and \\xe0 are control characters that indicate special key,\n            # see above.\n            rv += func()\n\n        _translate_ch_to_exc(rv)\n        return rv",
        "line_count": 45,
        "needs_llm_summary": true
      },
      {
        "name": "raw_terminal",
        "args": [],
        "return_type": "cabc.Iterator[int]",
        "lineno": 818,
        "decorators": [
          {
            "name": "contextlib.contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "old_settings",
          "f.fileno",
          "isatty",
          "f.close",
          "tty.setraw",
          "sys.stdout.flush",
          "termios.tcsetattr",
          "open",
          "sys.stdin.fileno",
          "termios.tcgetattr",
          "termios.TCSADRAIN",
          "sys.stdin",
          "fd"
        ],
        "docstring": null,
        "code": "def raw_terminal() -> cabc.Iterator[int]:\n        f: t.TextIO | None\n        fd: int\n\n        if not isatty(sys.stdin):\n            f = open(\"/dev/tty\")\n            fd = f.fileno()\n        else:\n            fd = sys.stdin.fileno()\n            f = None\n\n        try:\n            old_settings = termios.tcgetattr(fd)\n\n            try:\n                tty.setraw(fd)\n                yield fd\n            finally:\n                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n                sys.stdout.flush()\n\n                if f is not None:\n                    f.close()\n        except termios.error:\n            pass",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "getchar",
        "args": [
          {
            "name": "echo",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 844,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sys.stdout",
          "os.read",
          "_translate_ch_to_exc",
          "ch",
          "raw_terminal",
          "isatty",
          "get_best_encoding",
          "sys.stdout.write",
          "unknown.decode",
          "sys.stdin",
          "fd"
        ],
        "docstring": null,
        "code": "def getchar(echo: bool) -> str:\n        with raw_terminal() as fd:\n            ch = os.read(fd, 32).decode(get_best_encoding(sys.stdin), \"replace\")\n\n            if echo and isatty(sys.stdout):\n                sys.stdout.write(ch)\n\n            _translate_ch_to_exc(ch)\n            return ch",
        "line_count": 9,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ProgressBar",
        "methods": [
          "__init__",
          "__enter__",
          "__exit__",
          "__iter__",
          "__next__",
          "render_finish",
          "pct",
          "time_per_iteration",
          "eta",
          "format_eta",
          "format_pos",
          "format_pct",
          "format_bar",
          "format_progress_line",
          "render_progress",
          "make_step",
          "update",
          "finish",
          "generator"
        ],
        "base_classes": [
          "unknown"
        ],
        "lineno": 43,
        "docstring": null
      },
      {
        "name": "Editor",
        "methods": [
          "__init__",
          "get_editor",
          "edit_files",
          "edit",
          "edit",
          "edit"
        ],
        "base_classes": [],
        "lineno": 564,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 9,
        "type": "import"
      },
      {
        "module": "contextlib",
        "alias": null,
        "lineno": 10,
        "type": "import"
      },
      {
        "module": "math",
        "alias": null,
        "lineno": 11,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 12,
        "type": "import"
      },
      {
        "module": "shlex",
        "alias": null,
        "lineno": 13,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 14,
        "type": "import"
      },
      {
        "module": "time",
        "alias": null,
        "lineno": 15,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 16,
        "type": "import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "io",
        "name": "StringIO",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "pathlib",
        "name": "Path",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "_default_text_stdout",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "CYGWIN",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "get_best_encoding",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "isatty",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "open_stream",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "strip_ansi",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "term_len",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "WIN",
        "alias": null,
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "ClickException",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "echo",
        "alias": null,
        "lineno": 31,
        "type": "from_import"
      },
      {
        "module": "tempfile",
        "alias": null,
        "lineno": 399,
        "type": "import"
      },
      {
        "module": "shutil",
        "alias": null,
        "lineno": 424,
        "type": "import"
      },
      {
        "module": "subprocess",
        "alias": null,
        "lineno": 439,
        "type": "import"
      },
      {
        "module": "shutil",
        "alias": null,
        "lineno": 519,
        "type": "import"
      },
      {
        "module": "subprocess",
        "alias": null,
        "lineno": 531,
        "type": "import"
      },
      {
        "module": "tempfile",
        "alias": null,
        "lineno": 532,
        "type": "import"
      },
      {
        "module": "subprocess",
        "alias": null,
        "lineno": 677,
        "type": "import"
      },
      {
        "module": "msvcrt",
        "alias": null,
        "lineno": 761,
        "type": "import"
      },
      {
        "module": "termios",
        "alias": null,
        "lineno": 814,
        "type": "import"
      },
      {
        "module": "tty",
        "alias": null,
        "lineno": 815,
        "type": "import"
      },
      {
        "module": "shutil",
        "name": "which",
        "alias": null,
        "lineno": 587,
        "type": "from_import"
      },
      {
        "module": "subprocess",
        "alias": null,
        "lineno": 595,
        "type": "import"
      },
      {
        "module": "tempfile",
        "alias": null,
        "lineno": 629,
        "type": "import"
      },
      {
        "module": "urllib.parse",
        "name": "unquote",
        "alias": null,
        "lineno": 680,
        "type": "from_import"
      },
      {
        "module": "operator",
        "name": "length_hint",
        "alias": null,
        "lineno": 90,
        "type": "from_import"
      },
      {
        "module": "shutil",
        "alias": null,
        "lineno": 250,
        "type": "import"
      },
      {
        "module": "webbrowser",
        "alias": null,
        "lineno": 740,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "V",
        "assigned_to": "t.TypeVar",
        "lineno": 33
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "os.read",
        "ch",
        "raw_terminal",
        "f.close",
        "t.TypeVar",
        "get_best_encoding",
        "sys.stdout.write",
        "sys.stdin.fileno",
        "sys.stdin",
        "sys.stdout.flush",
        "rv",
        "func",
        "msvcrt.getwche",
        "termios.TCSADRAIN",
        "f.fileno",
        "_translate_ch_to_exc",
        "msvcrt.getwch",
        "termios.tcsetattr",
        "open",
        "fd",
        "old_settings",
        "sys.stdout",
        "isatty",
        "tty.setraw",
        "t.cast",
        "termios.tcgetattr",
        "unknown.decode"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "contextlib",
        "sys",
        "shutil",
        "typing",
        "pathlib",
        "math",
        "time",
        "os",
        "tempfile",
        "subprocess",
        "collections",
        "io"
      ],
      "third_party": {
        "other": [
          "__future__",
          "shlex",
          "gettext",
          "types",
          "_compat",
          "exceptions",
          "utils",
          "msvcrt",
          "termios",
          "tty",
          "urllib",
          "operator",
          "webbrowser"
        ]
      },
      "tech_stack": []
    },
    "line_count": 853
  },
  "src/click/_textwrap.py": {
    "filepath": "../click/src/click/_textwrap.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_handle_long_word",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "reversed_chunks",
            "type": "list[str]"
          },
          {
            "name": "cur_line",
            "type": "list[str]"
          },
          {
            "name": "cur_len",
            "type": "int"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 9,
        "decorators": [],
        "is_async": false,
        "calls": [
          "max",
          "cut",
          "res",
          "reversed_chunks.pop",
          "cur_line.append"
        ],
        "docstring": null,
        "code": "def _handle_long_word(\n        self,\n        reversed_chunks: list[str],\n        cur_line: list[str],\n        cur_len: int,\n        width: int,\n    ) -> None:\n        space_left = max(width - cur_len, 1)\n\n        if self.break_long_words:\n            last = reversed_chunks[-1]\n            cut = last[:space_left]\n            res = last[space_left:]\n            cur_line.append(cut)\n            reversed_chunks[-1] = res\n        elif not cur_line:\n            cur_line.append(reversed_chunks.pop())",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "extra_indent",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "indent",
            "type": "str"
          }
        ],
        "return_type": "cabc.Iterator[None]",
        "lineno": 28,
        "decorators": [
          {
            "name": "contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "old_subsequent_indent",
          "self.initial_indent",
          "old_initial_indent",
          "self.subsequent_indent"
        ],
        "docstring": null,
        "code": "def extra_indent(self, indent: str) -> cabc.Iterator[None]:\n        old_initial_indent = self.initial_indent\n        old_subsequent_indent = self.subsequent_indent\n        self.initial_indent += indent\n        self.subsequent_indent += indent\n\n        try:\n            yield\n        finally:\n            self.initial_indent = old_initial_indent\n            self.subsequent_indent = old_subsequent_indent",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "indent_only",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "unknown.join",
          "self.subsequent_indent",
          "text.splitlines",
          "rv",
          "self.initial_indent",
          "rv.append"
        ],
        "docstring": null,
        "code": "def indent_only(self, text: str) -> str:\n        rv = []\n\n        for idx, line in enumerate(text.splitlines()):\n            indent = self.initial_indent\n\n            if idx > 0:\n                indent = self.subsequent_indent\n\n            rv.append(f\"{indent}{line}\")\n\n        return \"\\n\".join(rv)",
        "line_count": 12,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "TextWrapper",
        "methods": [
          "_handle_long_word",
          "extra_indent",
          "indent_only"
        ],
        "base_classes": [
          "textwrap.TextWrapper"
        ],
        "lineno": 8,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "textwrap",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "contextlib",
        "name": "contextmanager",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "collections",
        "contextlib"
      ],
      "third_party": {
        "other": [
          "__future__",
          "textwrap"
        ]
      },
      "tech_stack": []
    },
    "line_count": 52
  },
  "src/click/_utils.py": {
    "filepath": "../click/src/click/_utils.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 18,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}.{self.name}\"",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "Sentinel",
        "methods": [
          "__repr__"
        ],
        "base_classes": [
          "enum.Enum"
        ],
        "lineno": 7,
        "docstring": "Enum used to define sentinel values.\n\n.. seealso::\n\n    `PEP 661 - Sentinel Values <https://peps.python.org/pep-0661/>`_."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "enum",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 4,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "UNSET",
        "assigned_to": null,
        "lineno": 22
      },
      {
        "name": "FLAG_NEEDS_VALUE",
        "assigned_to": null,
        "lineno": 25
      },
      {
        "name": "T_UNSET",
        "assigned_to": null,
        "lineno": 32
      },
      {
        "name": "T_FLAG_NEEDS_VALUE",
        "assigned_to": null,
        "lineno": 35
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Sentinel.UNSET",
        "Sentinel.FLAG_NEEDS_VALUE"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "enum",
        "typing"
      ],
      "third_party": {
        "other": [
          "__future__"
        ]
      },
      "tech_stack": []
    },
    "line_count": 37
  },
  "src/click/_winconsole.py": {
    "filepath": "../click/src/click/_winconsole.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_get_text_stdin",
        "args": [
          {
            "name": "buffer_stream",
            "type": "t.BinaryIO"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 226,
        "decorators": [],
        "is_async": false,
        "calls": [
          "t.TextIO",
          "STDIN_HANDLE",
          "_NonClosingTextIOWrapper",
          "text_stream",
          "t.cast",
          "buffer_stream",
          "ConsoleStream",
          "_WindowsConsoleReader",
          "io.BufferedReader"
        ],
        "docstring": null,
        "code": "def _get_text_stdin(buffer_stream: t.BinaryIO) -> t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        io.BufferedReader(_WindowsConsoleReader(STDIN_HANDLE)),\n        \"utf-16-le\",\n        \"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "_get_text_stdout",
        "args": [
          {
            "name": "buffer_stream",
            "type": "t.BinaryIO"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 236,
        "decorators": [],
        "is_async": false,
        "calls": [
          "t.TextIO",
          "_NonClosingTextIOWrapper",
          "text_stream",
          "t.cast",
          "buffer_stream",
          "STDOUT_HANDLE",
          "ConsoleStream",
          "_WindowsConsoleWriter",
          "io.BufferedWriter"
        ],
        "docstring": null,
        "code": "def _get_text_stdout(buffer_stream: t.BinaryIO) -> t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        io.BufferedWriter(_WindowsConsoleWriter(STDOUT_HANDLE)),\n        \"utf-16-le\",\n        \"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "_get_text_stderr",
        "args": [
          {
            "name": "buffer_stream",
            "type": "t.BinaryIO"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 246,
        "decorators": [],
        "is_async": false,
        "calls": [
          "t.TextIO",
          "_NonClosingTextIOWrapper",
          "text_stream",
          "t.cast",
          "buffer_stream",
          "ConsoleStream",
          "_WindowsConsoleWriter",
          "io.BufferedWriter",
          "STDERR_HANDLE"
        ],
        "docstring": null,
        "code": "def _get_text_stderr(buffer_stream: t.BinaryIO) -> t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        io.BufferedWriter(_WindowsConsoleWriter(STDERR_HANDLE)),\n        \"utf-16-le\",\n        \"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "_is_console",
        "args": [
          {
            "name": "f",
            "type": "t.TextIO"
          }
        ],
        "return_type": "bool",
        "lineno": 263,
        "decorators": [],
        "is_async": false,
        "calls": [
          "msvcrt.get_osfhandle",
          "f.fileno",
          "hasattr",
          "f",
          "byref",
          "GetConsoleMode",
          "handle",
          "bool",
          "DWORD",
          "fileno"
        ],
        "docstring": null,
        "code": "def _is_console(f: t.TextIO) -> bool:\n    if not hasattr(f, \"fileno\"):\n        return False\n\n    try:\n        fileno = f.fileno()\n    except (OSError, io.UnsupportedOperation):\n        return False\n\n    handle = msvcrt.get_osfhandle(fileno)\n    return bool(GetConsoleMode(handle, byref(DWORD())))",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "_get_windows_console_stream",
        "args": [
          {
            "name": "f",
            "type": "t.TextIO"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 276,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f.fileno",
          "b",
          "f",
          "func",
          "_is_console",
          "_stream_factories.get",
          "getattr"
        ],
        "docstring": null,
        "code": "def _get_windows_console_stream(\n    f: t.TextIO, encoding: str | None, errors: str | None\n) -> t.TextIO | None:\n    if (\n        get_buffer is None\n        or encoding not in {\"utf-16-le\", None}\n        or errors not in {\"strict\", None}\n        or not _is_console(f)\n    ):\n        return None\n\n    func = _stream_factories.get(f.fileno())\n    if func is None:\n        return None\n\n    b = getattr(f, \"buffer\", None)\n\n    if b is None:\n        return None\n\n    return func(b)",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "get_buffer",
        "args": [
          {
            "name": "obj",
            "type": "Buffer"
          },
          {
            "name": "writable",
            "type": "bool"
          }
        ],
        "return_type": "Array[c_char]",
        "lineno": 105,
        "decorators": [],
        "is_async": false,
        "calls": [
          "py_object",
          "PyBuffer_Release",
          "buffer_type.from_address",
          "Py_buffer",
          "byref",
          "PyObject_GetBuffer",
          "flags",
          "buf.buf",
          "obj",
          "buf"
        ],
        "docstring": null,
        "code": "def get_buffer(obj: Buffer, writable: bool = False) -> Array[c_char]:\n        buf = Py_buffer()\n        flags: int = PyBUF_WRITABLE if writable else PyBUF_SIMPLE\n        PyObject_GetBuffer(py_object(obj), byref(buf), flags)\n\n        try:\n            buffer_type = c_char * buf.len\n            out: Array[c_char] = buffer_type.from_address(buf.buf)\n            return out\n        finally:\n            PyBuffer_Release(byref(buf))",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "handle",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 119,
        "decorators": [],
        "is_async": false,
        "calls": [
          "handle"
        ],
        "docstring": null,
        "code": "def __init__(self, handle: int | None) -> None:\n        self.handle = handle",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "isatty",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "t.Literal[True]",
        "lineno": 122,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.isatty",
          "super"
        ],
        "docstring": null,
        "code": "def isatty(self) -> t.Literal[True]:\n        super().isatty()\n        return True",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "readable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "t.Literal[True]",
        "lineno": 128,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def readable(self) -> t.Literal[True]:\n        return True",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "readinto",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "b",
            "type": "Buffer"
          }
        ],
        "return_type": "int",
        "lineno": 131,
        "decorators": [],
        "is_async": false,
        "calls": [
          "code_units_to_be_read",
          "GetLastError",
          "get_buffer",
          "HANDLE",
          "time.sleep",
          "OSError",
          "b",
          "len",
          "ReadConsoleW",
          "buffer",
          "self.handle",
          "c_ulong",
          "byref",
          "code_units_read",
          "ValueError"
        ],
        "docstring": null,
        "code": "def readinto(self, b: Buffer) -> int:\n        bytes_to_be_read = len(b)\n        if not bytes_to_be_read:\n            return 0\n        elif bytes_to_be_read % 2:\n            raise ValueError(\n                \"cannot read odd number of bytes from UTF-16-LE encoded console\"\n            )\n\n        buffer = get_buffer(b, writable=True)\n        code_units_to_be_read = bytes_to_be_read // 2\n        code_units_read = c_ulong()\n\n        rv = ReadConsoleW(\n            HANDLE(self.handle),\n            buffer,\n            code_units_to_be_read,\n            byref(code_units_read),\n            None,\n        )\n        if GetLastError() == ERROR_OPERATION_ABORTED:\n            # wait for KeyboardInterrupt\n            time.sleep(0.1)\n        if not rv:\n            raise OSError(f\"Windows error: {GetLastError()}\")\n\n        if buffer[0] == EOF:\n            return 0\n        return 2 * code_units_read.value",
        "line_count": 29,
        "needs_llm_summary": true
      },
      {
        "name": "writable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "t.Literal[True]",
        "lineno": 163,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def writable(self) -> t.Literal[True]:\n        return True",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_get_error_message",
        "args": [
          {
            "name": "errno",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 167,
        "decorators": [
          {
            "name": "staticmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def _get_error_message(errno: int) -> str:\n        if errno == ERROR_SUCCESS:\n            return \"ERROR_SUCCESS\"\n        elif errno == ERROR_NOT_ENOUGH_MEMORY:\n            return \"ERROR_NOT_ENOUGH_MEMORY\"\n        return f\"Windows error {errno}\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "write",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "b",
            "type": "Buffer"
          }
        ],
        "return_type": "int",
        "lineno": 174,
        "decorators": [],
        "is_async": false,
        "calls": [
          "GetLastError",
          "get_buffer",
          "bytes_to_be_written",
          "HANDLE",
          "code_units_written",
          "b",
          "len",
          "OSError",
          "self.handle",
          "WriteConsoleW",
          "c_ulong",
          "code_units_to_be_written",
          "min",
          "byref",
          "MAX_BYTES_WRITTEN",
          "self._get_error_message",
          "buf"
        ],
        "docstring": null,
        "code": "def write(self, b: Buffer) -> int:\n        bytes_to_be_written = len(b)\n        buf = get_buffer(b)\n        code_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2\n        code_units_written = c_ulong()\n\n        WriteConsoleW(\n            HANDLE(self.handle),\n            buf,\n            code_units_to_be_written,\n            byref(code_units_written),\n            None,\n        )\n        bytes_written = 2 * code_units_written.value\n\n        if bytes_written == 0 and bytes_to_be_written > 0:\n            raise OSError(self._get_error_message(GetLastError()))\n        return bytes_written",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text_stream",
            "type": "t.TextIO"
          },
          {
            "name": "byte_stream",
            "type": "t.BinaryIO"
          }
        ],
        "return_type": "None",
        "lineno": 195,
        "decorators": [],
        "is_async": false,
        "calls": [
          "byte_stream",
          "text_stream"
        ],
        "docstring": null,
        "code": "def __init__(self, text_stream: t.TextIO, byte_stream: t.BinaryIO) -> None:\n        self._text_stream = text_stream\n        self.buffer = byte_stream",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "name",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 200,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def name(self) -> str:\n        return self.buffer.name",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "write",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "x",
            "type": "t.AnyStr"
          }
        ],
        "return_type": "int",
        "lineno": 203,
        "decorators": [],
        "is_async": false,
        "calls": [
          "str",
          "self.buffer.write",
          "self._text_stream.write",
          "self.flush",
          "isinstance",
          "x"
        ],
        "docstring": null,
        "code": "def write(self, x: t.AnyStr) -> int:\n        if isinstance(x, str):\n            return self._text_stream.write(x)\n        try:\n            self.flush()\n        except Exception:\n            pass\n        return self.buffer.write(x)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "writelines",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lines",
            "type": "cabc.Iterable[t.AnyStr]"
          }
        ],
        "return_type": "None",
        "lineno": 212,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line",
          "self.write"
        ],
        "docstring": null,
        "code": "def writelines(self, lines: cabc.Iterable[t.AnyStr]) -> None:\n        for line in lines:\n            self.write(line)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "t.Any",
        "lineno": 216,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "self._text_stream",
          "getattr"
        ],
        "docstring": null,
        "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._text_stream, name)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "isatty",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 219,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.buffer.isatty"
        ],
        "docstring": null,
        "code": "def isatty(self) -> bool:\n        return self.buffer.isatty()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 222,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"<ConsoleStream name={self.name!r} encoding={self.encoding!r}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "_WindowsConsoleRawIOBase",
        "methods": [
          "__init__",
          "isatty"
        ],
        "base_classes": [
          "io.RawIOBase"
        ],
        "lineno": 118,
        "docstring": null
      },
      {
        "name": "_WindowsConsoleReader",
        "methods": [
          "readable",
          "readinto"
        ],
        "base_classes": [
          "_WindowsConsoleRawIOBase"
        ],
        "lineno": 127,
        "docstring": null
      },
      {
        "name": "_WindowsConsoleWriter",
        "methods": [
          "writable",
          "_get_error_message",
          "write"
        ],
        "base_classes": [
          "_WindowsConsoleRawIOBase"
        ],
        "lineno": 162,
        "docstring": null
      },
      {
        "name": "ConsoleStream",
        "methods": [
          "__init__",
          "name",
          "write",
          "writelines",
          "__getattr__",
          "isatty",
          "__repr__"
        ],
        "base_classes": [],
        "lineno": 194,
        "docstring": null
      },
      {
        "name": "Py_buffer",
        "methods": [],
        "base_classes": [
          "Structure"
        ],
        "lineno": 87,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 11,
        "type": "import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 12,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 13,
        "type": "import"
      },
      {
        "module": "time",
        "alias": null,
        "lineno": 14,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 15,
        "type": "import"
      },
      {
        "module": "ctypes",
        "name": "Array",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "byref",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "c_char",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "c_char_p",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "c_int",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "c_ssize_t",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "c_ulong",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "c_void_p",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "POINTER",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "py_object",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "Structure",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "ctypes.wintypes",
        "name": "DWORD",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "ctypes.wintypes",
        "name": "HANDLE",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "ctypes.wintypes",
        "name": "LPCWSTR",
        "alias": null,
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "ctypes.wintypes",
        "name": "LPWSTR",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "_NonClosingTextIOWrapper",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "msvcrt",
        "alias": null,
        "lineno": 35,
        "type": "import"
      },
      {
        "module": "ctypes",
        "name": "windll",
        "alias": null,
        "lineno": 36,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "WINFUNCTYPE",
        "alias": null,
        "lineno": 37,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "pythonapi",
        "alias": null,
        "lineno": 80,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "name": "Buffer",
        "alias": null,
        "lineno": 75,
        "type": "from_import"
      },
      {
        "module": "typing_extensions",
        "name": "Buffer",
        "alias": null,
        "lineno": 77,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "c_ssize_p",
        "assigned_to": "POINTER",
        "lineno": 39
      },
      {
        "name": "kernel32",
        "assigned_to": null,
        "lineno": 41
      },
      {
        "name": "GetStdHandle",
        "assigned_to": null,
        "lineno": 42
      },
      {
        "name": "ReadConsoleW",
        "assigned_to": null,
        "lineno": 43
      },
      {
        "name": "WriteConsoleW",
        "assigned_to": null,
        "lineno": 44
      },
      {
        "name": "GetConsoleMode",
        "assigned_to": null,
        "lineno": 45
      },
      {
        "name": "GetLastError",
        "assigned_to": null,
        "lineno": 46
      },
      {
        "name": "GetCommandLineW",
        "assigned_to": null,
        "lineno": 47
      },
      {
        "name": "CommandLineToArgvW",
        "assigned_to": null,
        "lineno": 48
      },
      {
        "name": "LocalFree",
        "assigned_to": null,
        "lineno": 51
      },
      {
        "name": "STDIN_HANDLE",
        "assigned_to": "GetStdHandle",
        "lineno": 53
      },
      {
        "name": "STDOUT_HANDLE",
        "assigned_to": "GetStdHandle",
        "lineno": 54
      },
      {
        "name": "STDERR_HANDLE",
        "assigned_to": "GetStdHandle",
        "lineno": 55
      },
      {
        "name": "PyBUF_SIMPLE",
        "assigned_to": "int",
        "lineno": 57
      },
      {
        "name": "PyBUF_WRITABLE",
        "assigned_to": "int",
        "lineno": 58
      },
      {
        "name": "ERROR_SUCCESS",
        "assigned_to": "int",
        "lineno": 60
      },
      {
        "name": "ERROR_NOT_ENOUGH_MEMORY",
        "assigned_to": "int",
        "lineno": 61
      },
      {
        "name": "ERROR_OPERATION_ABORTED",
        "assigned_to": "int",
        "lineno": 62
      },
      {
        "name": "STDIN_FILENO",
        "assigned_to": "int",
        "lineno": 64
      },
      {
        "name": "STDOUT_FILENO",
        "assigned_to": "int",
        "lineno": 65
      },
      {
        "name": "STDERR_FILENO",
        "assigned_to": "int",
        "lineno": 66
      },
      {
        "name": "EOF",
        "assigned_to": "bytes",
        "lineno": 68
      },
      {
        "name": "MAX_BYTES_WRITTEN",
        "assigned_to": "int",
        "lineno": 69
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "pythonapi.PyBuffer_Release",
        "kernel32.WriteConsoleW",
        "py_object",
        "POINTER",
        "GetStdHandle",
        "c_ssize_t",
        "kernel32.GetConsoleMode",
        "Py_buffer",
        "LPCWSTR",
        "byref",
        "PyObject_GetBuffer",
        "buf.buf",
        "obj",
        "kernel32.ReadConsoleW",
        "buf",
        "windll.kernel32",
        "pythonapi.PyObject_GetBuffer",
        "c_int",
        "LPWSTR",
        "buffer_type.from_address",
        "PyBuffer_Release",
        "WINFUNCTYPE",
        "flags",
        "kernel32.GetLastError",
        "c_void_p",
        "kernel32.GetStdHandle"
      ],
      "class_instantiations": [
        "PyBuffer_Release",
        "POINTER",
        "Py_buffer",
        "WINFUNCTYPE",
        "GetStdHandle",
        "PyObject_GetBuffer"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "typing",
        "time",
        "collections",
        "io"
      ],
      "third_party": {
        "other": [
          "__future__",
          "ctypes",
          "_compat",
          "msvcrt",
          "typing_extensions"
        ]
      },
      "tech_stack": []
    },
    "line_count": 297
  },
  "src/click/core.py": {
    "filepath": "../click/src/click/core.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_complete_visible_commands",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "cabc.Iterator[tuple[str, Command]]",
        "lineno": 54,
        "decorators": [],
        "is_async": false,
        "calls": [
          "incomplete",
          "ctx",
          "multi.get_command",
          "name",
          "t.cast",
          "name.startswith",
          "multi.list_commands",
          "ctx.command",
          "Group"
        ],
        "docstring": "List all the subcommands of a group that start with the\nincomplete value and aren't hidden.\n\n:param ctx: Invocation context for the group.\n:param incomplete: Value being completed. May be empty.",
        "code": "def _complete_visible_commands(\n    ctx: Context, incomplete: str\n) -> cabc.Iterator[tuple[str, Command]]:\n    \"\"\"List all the subcommands of a group that start with the\n    incomplete value and aren't hidden.\n\n    :param ctx: Invocation context for the group.\n    :param incomplete: Value being completed. May be empty.\n    \"\"\"\n    multi = t.cast(Group, ctx.command)\n\n    for name in multi.list_commands(ctx):\n        if name.startswith(incomplete):\n            command = multi.get_command(ctx, name)\n\n            if command is not None and not command.hidden:\n                yield name, command",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "_check_nested_chain",
        "args": [
          {
            "name": "base_command",
            "type": "Group"
          },
          {
            "name": "cmd_name",
            "type": "str"
          },
          {
            "name": "cmd",
            "type": "Command"
          },
          {
            "name": "register",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 73,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Group",
          "message",
          "RuntimeError",
          "isinstance",
          "cmd"
        ],
        "docstring": null,
        "code": "def _check_nested_chain(\n    base_command: Group, cmd_name: str, cmd: Command, register: bool = False\n) -> None:\n    if not base_command.chain or not isinstance(cmd, Group):\n        return\n\n    if register:\n        message = (\n            f\"It is not possible to add the group {cmd_name!r} to another\"\n            f\" group {base_command.name!r} that is in chain mode.\"\n        )\n    else:\n        message = (\n            f\"Found the group {cmd_name!r} as subcommand to another group \"\n            f\" {base_command.name!r} that is in chain mode. This is not supported.\"\n        )\n\n    raise RuntimeError(message)",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "batch",
        "args": [
          {
            "name": "iterable",
            "type": "cabc.Iterable[V]"
          },
          {
            "name": "batch_size",
            "type": "int"
          }
        ],
        "return_type": "list[tuple[V, Ellipsis]]",
        "lineno": 93,
        "decorators": [],
        "is_async": false,
        "calls": [
          "iterable",
          "iter",
          "repeat",
          "list",
          "batch_size",
          "zip"
        ],
        "docstring": null,
        "code": "def batch(iterable: cabc.Iterable[V], batch_size: int) -> list[tuple[V, ...]]:\n    return list(zip(*repeat(iter(iterable), batch_size), strict=False))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "augment_usage_errors",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Any"
          }
        ],
        "return_type": "cabc.Iterator[None]",
        "lineno": 98,
        "decorators": [
          {
            "name": "contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ctx",
          "param"
        ],
        "docstring": "Context manager that attaches extra information to exceptions.",
        "code": "def augment_usage_errors(\n    ctx: Context, param: Parameter | None = None\n) -> cabc.Iterator[None]:\n    \"\"\"Context manager that attaches extra information to exceptions.\"\"\"\n    try:\n        yield\n    except BadParameter as e:\n        if e.ctx is None:\n            e.ctx = ctx\n        if param is not None and e.param is None:\n            e.param = param\n        raise\n    except UsageError as e:\n        if e.ctx is None:\n            e.ctx = ctx\n        raise",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "iter_params_for_processing",
        "args": [
          {
            "name": "invocation_order",
            "type": "cabc.Sequence[Parameter]"
          },
          {
            "name": "declaration_order",
            "type": "cabc.Sequence[Parameter]"
          }
        ],
        "return_type": "list[Parameter]",
        "lineno": 116,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sort_key",
          "float",
          "declaration_order",
          "item",
          "sorted",
          "invocation_order.index"
        ],
        "docstring": "Returns all declared parameters in the order they should be processed.\n\nThe declared parameters are re-shuffled depending on the order in which\nthey were invoked, as well as the eagerness of each parameters.\n\nThe invocation order takes precedence over the declaration order. I.e. the\norder in which the user provided them to the CLI is respected.\n\nThis behavior and its effect on callback evaluation is detailed at:\nhttps://click.palletsprojects.com/en/stable/advanced/#callback-evaluation-order",
        "code": "def iter_params_for_processing(\n    invocation_order: cabc.Sequence[Parameter],\n    declaration_order: cabc.Sequence[Parameter],\n) -> list[Parameter]:\n    \"\"\"Returns all declared parameters in the order they should be processed.\n\n    The declared parameters are re-shuffled depending on the order in which\n    they were invoked, as well as the eagerness of each parameters.\n\n    The invocation order takes precedence over the declaration order. I.e. the\n    order in which the user provided them to the CLI is respected.\n\n    This behavior and its effect on callback evaluation is detailed at:\n    https://click.palletsprojects.com/en/stable/advanced/#callback-evaluation-order\n    \"\"\"\n\n    def sort_key(item: Parameter) -> tuple[bool, float]:\n        try:\n            idx: float = invocation_order.index(item)\n        except ValueError:\n            idx = float(\"inf\")\n\n        return not item.is_eager, idx\n\n    return sorted(declaration_order, key=sort_key)",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "_check_iter",
        "args": [
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "cabc.Iterator[t.Any]",
        "lineno": 2017,
        "decorators": [],
        "is_async": false,
        "calls": [
          "str",
          "isinstance",
          "iter",
          "value"
        ],
        "docstring": "Check if the value is iterable but not a string. Raises a type\nerror, or return an iterator over the value.",
        "code": "def _check_iter(value: t.Any) -> cabc.Iterator[t.Any]:\n    \"\"\"Check if the value is iterable but not a string. Raises a type\n    error, or return an iterator over the value.\n    \"\"\"\n    if isinstance(value, str):\n        raise TypeError\n\n    return iter(value)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "object",
        "lineno": 3397,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "AttributeError",
          "DeprecationWarning",
          "warnings.warn"
        ],
        "docstring": null,
        "code": "def __getattr__(name: str) -> object:\n    import warnings\n\n    if name == \"BaseCommand\":\n        warnings.warn(\n            \"'BaseCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 'Command' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _BaseCommand\n\n    if name == \"MultiCommand\":\n        warnings.warn(\n            \"'MultiCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 'Group' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _MultiCommand\n\n    raise AttributeError(name)",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "sort_key",
        "args": [
          {
            "name": "item",
            "type": "Parameter"
          }
        ],
        "return_type": "tuple[bool, float]",
        "lineno": 132,
        "decorators": [],
        "is_async": false,
        "calls": [
          "item",
          "float",
          "invocation_order.index"
        ],
        "docstring": null,
        "code": "def sort_key(item: Parameter) -> tuple[bool, float]:\n        try:\n            idx: float = invocation_order.index(item)\n        except ValueError:\n            idx = float(\"inf\")\n\n        return not item.is_eager, idx",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "command",
            "type": "Command"
          },
          {
            "name": "parent",
            "type": "Any"
          },
          {
            "name": "info_name",
            "type": "Any"
          },
          {
            "name": "obj",
            "type": "Any"
          },
          {
            "name": "auto_envvar_prefix",
            "type": "Any"
          },
          {
            "name": "default_map",
            "type": "Any"
          },
          {
            "name": "terminal_width",
            "type": "Any"
          },
          {
            "name": "max_content_width",
            "type": "Any"
          },
          {
            "name": "resilient_parsing",
            "type": "bool"
          },
          {
            "name": "allow_extra_args",
            "type": "Any"
          },
          {
            "name": "allow_interspersed_args",
            "type": "Any"
          },
          {
            "name": "ignore_unknown_options",
            "type": "Any"
          },
          {
            "name": "help_option_names",
            "type": "Any"
          },
          {
            "name": "token_normalize_func",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "Any"
          },
          {
            "name": "show_default",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 273,
        "decorators": [],
        "is_async": false,
        "calls": [
          "set",
          "parent.default_map.get",
          "parent.terminal_width",
          "parent",
          "parent._opt_prefixes",
          "command.allow_extra_args",
          "parent.obj",
          "parent.max_content_width",
          "getattr",
          "ExitStack",
          "command.allow_interspersed_args",
          "auto_envvar_prefix.replace",
          "command.ignore_unknown_options",
          "parent.token_normalize_func",
          "info_name",
          "allow_extra_args",
          "self.info_name.upper",
          "auto_envvar_prefix.upper",
          "command",
          "parent.show_default",
          "parent.color",
          "parent.help_option_names"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        command: Command,\n        parent: Context | None = None,\n        info_name: str | None = None,\n        obj: t.Any | None = None,\n        auto_envvar_prefix: str | None = None,\n        default_map: cabc.MutableMapping[str, t.Any] | None = None,\n        terminal_width: int | None = None,\n        max_content_width: int | None = None,\n        resilient_parsing: bool = False,\n        allow_extra_args: bool | None = None,\n        allow_interspersed_args: bool | None = None,\n        ignore_unknown_options: bool | None = None,\n        help_option_names: list[str] | None = None,\n        token_normalize_func: t.Callable[[str], str] | None = None,\n        color: bool | None = None,\n        show_default: bool | None = None,\n    ) -> None:\n        #: the parent context or `None` if none exists.\n        self.parent = parent\n        #: the :class:`Command` for this context.\n        self.command = command\n        #: the descriptive information name\n        self.info_name = info_name\n        #: Map of parameter names to their parsed values. Parameters\n        #: with ``expose_value=False`` are not stored.\n        self.params: dict[str, t.Any] = {}\n        #: the leftover arguments.\n        self.args: list[str] = []\n        #: protected arguments.  These are arguments that are prepended\n        #: to `args` when certain parsing scenarios are encountered but\n        #: must be never propagated to another arguments.  This is used\n        #: to implement nested parsing.\n        self._protected_args: list[str] = []\n        #: the collected prefixes of the command's options.\n        self._opt_prefixes: set[str] = set(parent._opt_prefixes) if parent else set()\n\n        if obj is None and parent is not None:\n            obj = parent.obj\n\n        #: the user object stored.\n        self.obj: t.Any = obj\n        self._meta: dict[str, t.Any] = getattr(parent, \"meta\", {})\n\n        #: A dictionary (-like object) with defaults for parameters.\n        if (\n            default_map is None\n            and info_name is not None\n            and parent is not None\n            and parent.default_map is not None\n        ):\n            default_map = parent.default_map.get(info_name)\n\n        self.default_map: cabc.MutableMapping[str, t.Any] | None = default_map\n\n        #: This flag indicates if a subcommand is going to be executed. A\n        #: group callback can use this information to figure out if it's\n        #: being executed directly or because the execution flow passes\n        #: onwards to a subcommand. By default it's None, but it can be\n        #: the name of the subcommand to execute.\n        #:\n        #: If chaining is enabled this will be set to ``'*'`` in case\n        #: any commands are executed.  It is however not possible to\n        #: figure out which ones.  If you require this knowledge you\n        #: should use a :func:`result_callback`.\n        self.invoked_subcommand: str | None = None\n\n        if terminal_width is None and parent is not None:\n            terminal_width = parent.terminal_width\n\n        #: The width of the terminal (None is autodetection).\n        self.terminal_width: int | None = terminal_width\n\n        if max_content_width is None and parent is not None:\n            max_content_width = parent.max_content_width\n\n        #: The maximum width of formatted content (None implies a sensible\n        #: default which is 80 for most things).\n        self.max_content_width: int | None = max_content_width\n\n        if allow_extra_args is None:\n            allow_extra_args = command.allow_extra_args\n\n        #: Indicates if the context allows extra args or if it should\n        #: fail on parsing.\n        #:\n        #: .. versionadded:: 3.0\n        self.allow_extra_args = allow_extra_args\n\n        if allow_interspersed_args is None:\n            allow_interspersed_args = command.allow_interspersed_args\n\n        #: Indicates if the context allows mixing of arguments and\n        #: options or not.\n        #:\n        #: .. versionadded:: 3.0\n        self.allow_interspersed_args: bool = allow_interspersed_args\n\n        if ignore_unknown_options is None:\n            ignore_unknown_options = command.ignore_unknown_options\n\n        #: Instructs click to ignore options that a command does not\n        #: understand and will store it on the context for later\n        #: processing.  This is primarily useful for situations where you\n        #: want to call into external programs.  Generally this pattern is\n        #: strongly discouraged because it's not possibly to losslessly\n        #: forward all arguments.\n        #:\n        #: .. versionadded:: 4.0\n        self.ignore_unknown_options: bool = ignore_unknown_options\n\n        if help_option_names is None:\n            if parent is not None:\n                help_option_names = parent.help_option_names\n            else:\n                help_option_names = [\"--help\"]\n\n        #: The names for the help options.\n        self.help_option_names: list[str] = help_option_names\n\n        if token_normalize_func is None and parent is not None:\n            token_normalize_func = parent.token_normalize_func\n\n        #: An optional normalization function for tokens.  This is\n        #: options, choices, commands etc.\n        self.token_normalize_func: t.Callable[[str], str] | None = token_normalize_func\n\n        #: Indicates if resilient parsing is enabled.  In that case Click\n        #: will do its best to not cause any failures and default values\n        #: will be ignored. Useful for completion.\n        self.resilient_parsing: bool = resilient_parsing\n\n        # If there is no envvar prefix yet, but the parent has one and\n        # the command on this level has a name, we can expand the envvar\n        # prefix automatically.\n        if auto_envvar_prefix is None:\n            if (\n                parent is not None\n                and parent.auto_envvar_prefix is not None\n                and self.info_name is not None\n            ):\n                auto_envvar_prefix = (\n                    f\"{parent.auto_envvar_prefix}_{self.info_name.upper()}\"\n                )\n        else:\n            auto_envvar_prefix = auto_envvar_prefix.upper()\n\n        if auto_envvar_prefix is not None:\n            auto_envvar_prefix = auto_envvar_prefix.replace(\"-\", \"_\")\n\n        self.auto_envvar_prefix: str | None = auto_envvar_prefix\n\n        if color is None and parent is not None:\n            color = parent.color\n\n        #: Controls if styling output is wanted or not.\n        self.color: bool | None = color\n\n        if show_default is None and parent is not None:\n            show_default = parent.show_default\n\n        #: Show option default values when formatting help text.\n        self.show_default: bool | None = show_default\n\n        self._close_callbacks: list[t.Callable[[], t.Any]] = []\n        self._depth = 0\n        self._parameter_source: dict[str, ParameterSource] = {}\n        self._exit_stack = ExitStack()",
        "line_count": 169,
        "needs_llm_summary": true
      },
      {
        "name": "protected_args",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "list[str]",
        "lineno": 444,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "DeprecationWarning",
          "warnings.warn"
        ],
        "docstring": null,
        "code": "def protected_args(self) -> list[str]:\n        import warnings\n\n        warnings.warn(\n            \"'protected_args' is deprecated and will be removed in Click 9.0.\"\n            \" 'args' will contain remaining unparsed tokens.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self._protected_args",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 455,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.command.to_info_dict",
          "self"
        ],
        "docstring": "Gather information that could be useful for a tool generating\nuser-facing documentation. This traverses the entire CLI\nstructure.\n\n.. code-block:: python\n\n    with Context(cli) as ctx:\n        info = ctx.to_info_dict()\n\n.. versionadded:: 8.0",
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        \"\"\"Gather information that could be useful for a tool generating\n        user-facing documentation. This traverses the entire CLI\n        structure.\n\n        .. code-block:: python\n\n            with Context(cli) as ctx:\n                info = ctx.to_info_dict()\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return {\n            \"command\": self.command.to_info_dict(self),\n            \"info_name\": self.info_name,\n            \"allow_extra_args\": self.allow_extra_args,\n            \"allow_interspersed_args\": self.allow_interspersed_args,\n            \"ignore_unknown_options\": self.ignore_unknown_options,\n            \"auto_envvar_prefix\": self.auto_envvar_prefix,\n        }",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Context",
        "lineno": 476,
        "decorators": [],
        "is_async": false,
        "calls": [
          "push_context",
          "self"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> Context:\n        self._depth += 1\n        push_context(self)\n        return self",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Any"
          },
          {
            "name": "exc_value",
            "type": "Any"
          },
          {
            "name": "tb",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 481,
        "decorators": [],
        "is_async": false,
        "calls": [
          "exc_type",
          "pop_context",
          "tb",
          "self._close_with_exception_info",
          "exc_value"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> bool | None:\n        self._depth -= 1\n        exit_result: bool | None = None\n        if self._depth == 0:\n            exit_result = self._close_with_exception_info(exc_type, exc_value, tb)\n        pop_context()\n\n        return exit_result",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "scope",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "cleanup",
            "type": "bool"
          }
        ],
        "return_type": "cabc.Iterator[Context]",
        "lineno": 496,
        "decorators": [
          {
            "name": "contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "This helper method can be used with the context object to promote\nit to the current thread local (see :func:`get_current_context`).\nThe default behavior of this is to invoke the cleanup functions which\ncan be disabled by setting `cleanup` to `False`.  The cleanup\nfunctions are typically used for things such as closing file handles.\n\nIf the cleanup is intended the context object can also be directly\nused as a context manager.\n\nExample usage::\n\n    with ctx.scope():\n        assert get_current_context() is ctx\n\nThis is equivalent::\n\n    with ctx:\n        assert get_current_context() is ctx\n\n.. versionadded:: 5.0\n\n:param cleanup: controls if the cleanup functions should be run or\n                not.  The default is to run these functions.  In\n                some situations the context only wants to be\n                temporarily pushed in which case this can be disabled.\n                Nested pushes automatically defer the cleanup.",
        "code": "def scope(self, cleanup: bool = True) -> cabc.Iterator[Context]:\n        \"\"\"This helper method can be used with the context object to promote\n        it to the current thread local (see :func:`get_current_context`).\n        The default behavior of this is to invoke the cleanup functions which\n        can be disabled by setting `cleanup` to `False`.  The cleanup\n        functions are typically used for things such as closing file handles.\n\n        If the cleanup is intended the context object can also be directly\n        used as a context manager.\n\n        Example usage::\n\n            with ctx.scope():\n                assert get_current_context() is ctx\n\n        This is equivalent::\n\n            with ctx:\n                assert get_current_context() is ctx\n\n        .. versionadded:: 5.0\n\n        :param cleanup: controls if the cleanup functions should be run or\n                        not.  The default is to run these functions.  In\n                        some situations the context only wants to be\n                        temporarily pushed in which case this can be disabled.\n                        Nested pushes automatically defer the cleanup.\n        \"\"\"\n        if not cleanup:\n            self._depth += 1\n        try:\n            with self as rv:\n                yield rv\n        finally:\n            if not cleanup:\n                self._depth -= 1",
        "line_count": 36,
        "needs_llm_summary": true
      },
      {
        "name": "meta",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 534,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "This is a dictionary which is shared with all the contexts\nthat are nested.  It exists so that click utilities can store some\nstate here if they need to.  It is however the responsibility of\nthat code to manage this dictionary well.\n\nThe keys are supposed to be unique dotted strings.  For instance\nmodule paths are a good choice for it.  What is stored in there is\nirrelevant for the operation of click.  However what is important is\nthat code that places data here adheres to the general semantics of\nthe system.\n\nExample usage::\n\n    LANG_KEY = f'{__name__}.lang'\n\n    def set_language(value):\n        ctx = get_current_context()\n        ctx.meta[LANG_KEY] = value\n\n    def get_language():\n        return get_current_context().meta.get(LANG_KEY, 'en_US')\n\n.. versionadded:: 5.0",
        "code": "def meta(self) -> dict[str, t.Any]:\n        \"\"\"This is a dictionary which is shared with all the contexts\n        that are nested.  It exists so that click utilities can store some\n        state here if they need to.  It is however the responsibility of\n        that code to manage this dictionary well.\n\n        The keys are supposed to be unique dotted strings.  For instance\n        module paths are a good choice for it.  What is stored in there is\n        irrelevant for the operation of click.  However what is important is\n        that code that places data here adheres to the general semantics of\n        the system.\n\n        Example usage::\n\n            LANG_KEY = f'{__name__}.lang'\n\n            def set_language(value):\n                ctx = get_current_context()\n                ctx.meta[LANG_KEY] = value\n\n            def get_language():\n                return get_current_context().meta.get(LANG_KEY, 'en_US')\n\n        .. versionadded:: 5.0\n        \"\"\"\n        return self._meta",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "make_formatter",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "HelpFormatter",
        "lineno": 561,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.max_content_width",
          "self.formatter_class",
          "self.terminal_width"
        ],
        "docstring": "Creates the :class:`~click.HelpFormatter` for the help and\nusage output.\n\nTo quickly customize the formatter class used without overriding\nthis method, set the :attr:`formatter_class` attribute.\n\n.. versionchanged:: 8.0\n    Added the :attr:`formatter_class` attribute.",
        "code": "def make_formatter(self) -> HelpFormatter:\n        \"\"\"Creates the :class:`~click.HelpFormatter` for the help and\n        usage output.\n\n        To quickly customize the formatter class used without overriding\n        this method, set the :attr:`formatter_class` attribute.\n\n        .. versionchanged:: 8.0\n            Added the :attr:`formatter_class` attribute.\n        \"\"\"\n        return self.formatter_class(\n            width=self.terminal_width, max_width=self.max_content_width\n        )",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "with_resource",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context_manager",
            "type": "AbstractContextManager[V]"
          }
        ],
        "return_type": "V",
        "lineno": 575,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._exit_stack.enter_context",
          "context_manager"
        ],
        "docstring": "Register a resource as if it were used in a ``with``\nstatement. The resource will be cleaned up when the context is\npopped.\n\nUses :meth:`contextlib.ExitStack.enter_context`. It calls the\nresource's ``__enter__()`` method and returns the result. When\nthe context is popped, it closes the stack, which calls the\nresource's ``__exit__()`` method.\n\nTo register a cleanup function for something that isn't a\ncontext manager, use :meth:`call_on_close`. Or use something\nfrom :mod:`contextlib` to turn it into a context manager first.\n\n.. code-block:: python\n\n    @click.group()\n    @click.option(\"--name\")\n    @click.pass_context\n    def cli(ctx):\n        ctx.obj = ctx.with_resource(connect_db(name))\n\n:param context_manager: The context manager to enter.\n:return: Whatever ``context_manager.__enter__()`` returns.\n\n.. versionadded:: 8.0",
        "code": "def with_resource(self, context_manager: AbstractContextManager[V]) -> V:\n        \"\"\"Register a resource as if it were used in a ``with``\n        statement. The resource will be cleaned up when the context is\n        popped.\n\n        Uses :meth:`contextlib.ExitStack.enter_context`. It calls the\n        resource's ``__enter__()`` method and returns the result. When\n        the context is popped, it closes the stack, which calls the\n        resource's ``__exit__()`` method.\n\n        To register a cleanup function for something that isn't a\n        context manager, use :meth:`call_on_close`. Or use something\n        from :mod:`contextlib` to turn it into a context manager first.\n\n        .. code-block:: python\n\n            @click.group()\n            @click.option(\"--name\")\n            @click.pass_context\n            def cli(ctx):\n                ctx.obj = ctx.with_resource(connect_db(name))\n\n        :param context_manager: The context manager to enter.\n        :return: Whatever ``context_manager.__enter__()`` returns.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return self._exit_stack.enter_context(context_manager)",
        "line_count": 28,
        "needs_llm_summary": true
      },
      {
        "name": "call_on_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "f",
            "type": "t.Callable[Ellipsis, t.Any]"
          }
        ],
        "return_type": "t.Callable[Ellipsis, t.Any]",
        "lineno": 604,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._exit_stack.callback",
          "f"
        ],
        "docstring": "Register a function to be called when the context tears down.\n\nThis can be used to close resources opened during the script\nexecution. Resources that support Python's context manager\nprotocol which would be used in a ``with`` statement should be\nregistered with :meth:`with_resource` instead.\n\n:param f: The function to execute on teardown.",
        "code": "def call_on_close(self, f: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:\n        \"\"\"Register a function to be called when the context tears down.\n\n        This can be used to close resources opened during the script\n        execution. Resources that support Python's context manager\n        protocol which would be used in a ``with`` statement should be\n        registered with :meth:`with_resource` instead.\n\n        :param f: The function to execute on teardown.\n        \"\"\"\n        return self._exit_stack.callback(f)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "close",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 616,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._close_with_exception_info"
        ],
        "docstring": "Invoke all close callbacks registered with\n:meth:`call_on_close`, and exit all context managers entered\nwith :meth:`with_resource`.",
        "code": "def close(self) -> None:\n        \"\"\"Invoke all close callbacks registered with\n        :meth:`call_on_close`, and exit all context managers entered\n        with :meth:`with_resource`.\n        \"\"\"\n        self._close_with_exception_info(None, None, None)",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "_close_with_exception_info",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Any"
          },
          {
            "name": "exc_value",
            "type": "Any"
          },
          {
            "name": "tb",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 623,
        "decorators": [],
        "is_async": false,
        "calls": [
          "exc_type",
          "ExitStack",
          "tb",
          "exc_value",
          "self._exit_stack.__exit__"
        ],
        "docstring": "Unwind the exit stack by calling its :meth:`__exit__` providing the exception\ninformation to allow for exception handling by the various resources registered\nusing :meth;`with_resource`\n\n:return: Whatever ``exit_stack.__exit__()`` returns.",
        "code": "def _close_with_exception_info(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> bool | None:\n        \"\"\"Unwind the exit stack by calling its :meth:`__exit__` providing the exception\n        information to allow for exception handling by the various resources registered\n        using :meth;`with_resource`\n\n        :return: Whatever ``exit_stack.__exit__()`` returns.\n        \"\"\"\n        exit_result = self._exit_stack.__exit__(exc_type, exc_value, tb)\n        # In case the context is reused, create a new exit stack.\n        self._exit_stack = ExitStack()\n\n        return exit_result",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "command_path",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 642,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "parent_command_path.extend",
          "self",
          "unknown.join",
          "rv.lstrip",
          "self.parent.command.get_params",
          "self.info_name",
          "isinstance",
          "param.get_usage_pieces",
          "parent_command_path",
          "Command",
          "self.parent.command"
        ],
        "docstring": "The computed command path.  This is used for the ``usage``\ninformation on the help page.  It's automatically created by\ncombining the info names of the chain of contexts to the root.",
        "code": "def command_path(self) -> str:\n        \"\"\"The computed command path.  This is used for the ``usage``\n        information on the help page.  It's automatically created by\n        combining the info names of the chain of contexts to the root.\n        \"\"\"\n        rv = \"\"\n        if self.info_name is not None:\n            rv = self.info_name\n        if self.parent is not None:\n            parent_command_path = [self.parent.command_path]\n\n            if isinstance(self.parent.command, Command):\n                for param in self.parent.command.get_params(self):\n                    parent_command_path.extend(param.get_usage_pieces(self))\n\n            rv = f\"{' '.join(parent_command_path)} {rv}\"\n        return rv.lstrip()",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "find_root",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Context",
        "lineno": 660,
        "decorators": [],
        "is_async": false,
        "calls": [
          "node.parent",
          "self"
        ],
        "docstring": "Finds the outermost context.",
        "code": "def find_root(self) -> Context:\n        \"\"\"Finds the outermost context.\"\"\"\n        node = self\n        while node.parent is not None:\n            node = node.parent\n        return node",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "find_object",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "object_type",
            "type": "type[V]"
          }
        ],
        "return_type": "Any",
        "lineno": 667,
        "decorators": [],
        "is_async": false,
        "calls": [
          "object_type",
          "node.parent",
          "node.obj",
          "isinstance"
        ],
        "docstring": "Finds the closest object of a given type.",
        "code": "def find_object(self, object_type: type[V]) -> V | None:\n        \"\"\"Finds the closest object of a given type.\"\"\"\n        node: Context | None = self\n\n        while node is not None:\n            if isinstance(node.obj, object_type):\n                return node.obj\n\n            node = node.parent\n\n        return None",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "ensure_object",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "object_type",
            "type": "type[V]"
          }
        ],
        "return_type": "V",
        "lineno": 679,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.find_object",
          "object_type"
        ],
        "docstring": "Like :meth:`find_object` but sets the innermost object to a\nnew instance of `object_type` if it does not exist.",
        "code": "def ensure_object(self, object_type: type[V]) -> V:\n        \"\"\"Like :meth:`find_object` but sets the innermost object to a\n        new instance of `object_type` if it does not exist.\n        \"\"\"\n        rv = self.find_object(object_type)\n        if rv is None:\n            self.obj = rv = object_type()\n        return rv",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "lookup_default",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "call",
            "type": "t.Literal[True]"
          }
        ],
        "return_type": "Any",
        "lineno": 689,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def lookup_default(\n        self, name: str, call: t.Literal[True] = True\n    ) -> t.Any | None: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "lookup_default",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "call",
            "type": "t.Literal[False]"
          }
        ],
        "return_type": "Any",
        "lineno": 694,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def lookup_default(\n        self, name: str, call: t.Literal[False] = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "lookup_default",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "call",
            "type": "bool"
          }
        ],
        "return_type": "Any",
        "lineno": 698,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.default_map.get",
          "UNSET",
          "value",
          "name",
          "callable"
        ],
        "docstring": "Get the default for a parameter from :attr:`default_map`.\n\n:param name: Name of the parameter.\n:param call: If the default is a callable, call it. Disable to\n    return the callable instead.\n\n.. versionchanged:: 8.0\n    Added the ``call`` parameter.",
        "code": "def lookup_default(self, name: str, call: bool = True) -> t.Any | None:\n        \"\"\"Get the default for a parameter from :attr:`default_map`.\n\n        :param name: Name of the parameter.\n        :param call: If the default is a callable, call it. Disable to\n            return the callable instead.\n\n        .. versionchanged:: 8.0\n            Added the ``call`` parameter.\n        \"\"\"\n        if self.default_map is not None:\n            value = self.default_map.get(name, UNSET)\n\n            if call and callable(value):\n                return value()\n\n            return value\n\n        return UNSET",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "fail",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "message",
            "type": "str"
          }
        ],
        "return_type": "t.NoReturn",
        "lineno": 718,
        "decorators": [],
        "is_async": false,
        "calls": [
          "UsageError",
          "self",
          "message"
        ],
        "docstring": "Aborts the execution of the program with a specific error\nmessage.\n\n:param message: the error message to fail with.",
        "code": "def fail(self, message: str) -> t.NoReturn:\n        \"\"\"Aborts the execution of the program with a specific error\n        message.\n\n        :param message: the error message to fail with.\n        \"\"\"\n        raise UsageError(message, self)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "abort",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "t.NoReturn",
        "lineno": 726,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Abort"
        ],
        "docstring": "Aborts the script.",
        "code": "def abort(self) -> t.NoReturn:\n        \"\"\"Aborts the script.\"\"\"\n        raise Abort()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "exit",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "code",
            "type": "int"
          }
        ],
        "return_type": "t.NoReturn",
        "lineno": 730,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.close",
          "code",
          "Exit"
        ],
        "docstring": "Exits the application with a given exit code.\n\n.. versionchanged:: 8.2\n    Callbacks and context managers registered with :meth:`call_on_close`\n    and :meth:`with_resource` are closed before exiting.",
        "code": "def exit(self, code: int = 0) -> t.NoReturn:\n        \"\"\"Exits the application with a given exit code.\n\n        .. versionchanged:: 8.2\n            Callbacks and context managers registered with :meth:`call_on_close`\n            and :meth:`with_resource` are closed before exiting.\n        \"\"\"\n        self.close()\n        raise Exit(code)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "get_usage",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 740,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.command.get_usage",
          "self"
        ],
        "docstring": "Helper method to get formatted usage string for the current\ncontext and command.",
        "code": "def get_usage(self) -> str:\n        \"\"\"Helper method to get formatted usage string for the current\n        context and command.\n        \"\"\"\n        return self.command.get_usage(self)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_help",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 746,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.command.get_help",
          "self"
        ],
        "docstring": "Helper method to get formatted help page for the current\ncontext and command.",
        "code": "def get_help(self) -> str:\n        \"\"\"Helper method to get formatted help page for the current\n        context and command.\n        \"\"\"\n        return self.command.get_help(self)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "_make_sub_context",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "command",
            "type": "Command"
          }
        ],
        "return_type": "Context",
        "lineno": 752,
        "decorators": [],
        "is_async": false,
        "calls": [
          "command.name",
          "type",
          "command",
          "self"
        ],
        "docstring": "Create a new context of the same type as this context, but\nfor a new command.\n\n:meta private:",
        "code": "def _make_sub_context(self, command: Command) -> Context:\n        \"\"\"Create a new context of the same type as this context, but\n        for a new command.\n\n        :meta private:\n        \"\"\"\n        return type(self)(command, info_name=command.name, parent=self)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "invoke",
        "args": [],
        "return_type": "V",
        "lineno": 761,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def invoke(\n        self, callback: t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any\n    ) -> V: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "invoke",
        "args": [],
        "return_type": "t.Any",
        "lineno": 766,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def invoke(self, callback: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "invoke",
        "args": [],
        "return_type": "Any",
        "lineno": 768,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.params.update",
          "self",
          "ctx",
          "param.get_default",
          "param.type_cast_value",
          "other_cmd.callback",
          "callback",
          "t.cast",
          "TypeError",
          "isinstance",
          "default_value",
          "kwargs",
          "augment_usage_errors",
          "other_cmd",
          "self._make_sub_context",
          "Command"
        ],
        "docstring": "Invokes a command callback in exactly the way it expects.  There\nare two ways to invoke this method:\n\n1.  the first argument can be a callback and all other arguments and\n    keyword arguments are forwarded directly to the function.\n2.  the first argument is a click command object.  In that case all\n    arguments are forwarded as well but proper click parameters\n    (options and click arguments) must be keyword arguments and Click\n    will fill in defaults.\n\n.. versionchanged:: 8.0\n    All ``kwargs`` are tracked in :attr:`params` so they will be\n    passed if :meth:`forward` is called at multiple levels.\n\n.. versionchanged:: 3.2\n    A new context is created, and missing arguments use default values.",
        "code": "def invoke(\n        self, callback: Command | t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any\n    ) -> t.Any | V:\n        \"\"\"Invokes a command callback in exactly the way it expects.  There\n        are two ways to invoke this method:\n\n        1.  the first argument can be a callback and all other arguments and\n            keyword arguments are forwarded directly to the function.\n        2.  the first argument is a click command object.  In that case all\n            arguments are forwarded as well but proper click parameters\n            (options and click arguments) must be keyword arguments and Click\n            will fill in defaults.\n\n        .. versionchanged:: 8.0\n            All ``kwargs`` are tracked in :attr:`params` so they will be\n            passed if :meth:`forward` is called at multiple levels.\n\n        .. versionchanged:: 3.2\n            A new context is created, and missing arguments use default values.\n        \"\"\"\n        if isinstance(callback, Command):\n            other_cmd = callback\n\n            if other_cmd.callback is None:\n                raise TypeError(\n                    \"The given command does not have a callback that can be invoked.\"\n                )\n            else:\n                callback = t.cast(\"t.Callable[..., V]\", other_cmd.callback)\n\n            ctx = self._make_sub_context(other_cmd)\n\n            for param in other_cmd.params:\n                if param.name not in kwargs and param.expose_value:\n                    default_value = param.get_default(ctx)\n                    # We explicitly hide the :attr:`UNSET` value to the user, as we\n                    # choose to make it an implementation detail. And because ``invoke``\n                    # has been designed as part of Click public API, we return ``None``\n                    # instead. Refs:\n                    # https://github.com/pallets/click/issues/3066\n                    # https://github.com/pallets/click/issues/3065\n                    # https://github.com/pallets/click/pull/3068\n                    if default_value is UNSET:\n                        default_value = None\n                    kwargs[param.name] = param.type_cast_value(  # type: ignore\n                        ctx, default_value\n                    )\n\n            # Track all kwargs as params, so that forward() will pass\n            # them on in subsequent calls.\n            ctx.params.update(kwargs)\n        else:\n            ctx = self\n\n        with augment_usage_errors(self):\n            with ctx:\n                return callback(*args, **kwargs)",
        "line_count": 57,
        "needs_llm_summary": true
      },
      {
        "name": "forward",
        "args": [],
        "return_type": "t.Any",
        "lineno": 826,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.invoke",
          "TypeError",
          "isinstance",
          "kwargs",
          "Command",
          "cmd"
        ],
        "docstring": "Similar to :meth:`invoke` but fills in default keyword\narguments from the current context if the other command expects\nit.  This cannot invoke callbacks directly, only other commands.\n\n.. versionchanged:: 8.0\n    All ``kwargs`` are tracked in :attr:`params` so they will be\n    passed if ``forward`` is called at multiple levels.",
        "code": "def forward(self, cmd: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Similar to :meth:`invoke` but fills in default keyword\n        arguments from the current context if the other command expects\n        it.  This cannot invoke callbacks directly, only other commands.\n\n        .. versionchanged:: 8.0\n            All ``kwargs`` are tracked in :attr:`params` so they will be\n            passed if ``forward`` is called at multiple levels.\n        \"\"\"\n        # Can only forward to other commands, not direct callbacks.\n        if not isinstance(cmd, Command):\n            raise TypeError(\"Callback is not a command.\")\n\n        for param in self.params:\n            if param not in kwargs:\n                kwargs[param] = self.params[param]\n\n        return self.invoke(cmd, *args, **kwargs)",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "set_parameter_source",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "source",
            "type": "ParameterSource"
          }
        ],
        "return_type": "None",
        "lineno": 845,
        "decorators": [],
        "is_async": false,
        "calls": [
          "source"
        ],
        "docstring": "Set the source of a parameter. This indicates the location\nfrom which the value of the parameter was obtained.\n\n:param name: The name of the parameter.\n:param source: A member of :class:`~click.core.ParameterSource`.",
        "code": "def set_parameter_source(self, name: str, source: ParameterSource) -> None:\n        \"\"\"Set the source of a parameter. This indicates the location\n        from which the value of the parameter was obtained.\n\n        :param name: The name of the parameter.\n        :param source: A member of :class:`~click.core.ParameterSource`.\n        \"\"\"\n        self._parameter_source[name] = source",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "get_parameter_source",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 854,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "self._parameter_source.get"
        ],
        "docstring": "Get the source of a parameter. This indicates the location\nfrom which the value of the parameter was obtained.\n\nThis can be useful for determining when a user specified a value\non the command line that is the same as the default value. It\nwill be :attr:`~click.core.ParameterSource.DEFAULT` only if the\nvalue was actually taken from the default.\n\n:param name: The name of the parameter.\n:rtype: ParameterSource\n\n.. versionchanged:: 8.0\n    Returns ``None`` if the parameter was not provided from any\n    source.",
        "code": "def get_parameter_source(self, name: str) -> ParameterSource | None:\n        \"\"\"Get the source of a parameter. This indicates the location\n        from which the value of the parameter was obtained.\n\n        This can be useful for determining when a user specified a value\n        on the command line that is the same as the default value. It\n        will be :attr:`~click.core.ParameterSource.DEFAULT` only if the\n        value was actually taken from the default.\n\n        :param name: The name of the parameter.\n        :rtype: ParameterSource\n\n        .. versionchanged:: 8.0\n            Returns ``None`` if the parameter was not provided from any\n            source.\n        \"\"\"\n        return self._parameter_source.get(name)",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "context_settings",
            "type": "Any"
          },
          {
            "name": "callback",
            "type": "Any"
          },
          {
            "name": "params",
            "type": "Any"
          },
          {
            "name": "help",
            "type": "Any"
          },
          {
            "name": "epilog",
            "type": "Any"
          },
          {
            "name": "short_help",
            "type": "Any"
          },
          {
            "name": "options_metavar",
            "type": "Any"
          },
          {
            "name": "add_help_option",
            "type": "bool"
          },
          {
            "name": "no_args_is_help",
            "type": "bool"
          },
          {
            "name": "hidden",
            "type": "bool"
          },
          {
            "name": "deprecated",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 935,
        "decorators": [],
        "is_async": false,
        "calls": [
          "options_metavar",
          "epilog",
          "no_args_is_help",
          "deprecated",
          "name",
          "callback",
          "short_help",
          "help",
          "add_help_option",
          "hidden"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        name: str | None,\n        context_settings: cabc.MutableMapping[str, t.Any] | None = None,\n        callback: t.Callable[..., t.Any] | None = None,\n        params: list[Parameter] | None = None,\n        help: str | None = None,\n        epilog: str | None = None,\n        short_help: str | None = None,\n        options_metavar: str | None = \"[OPTIONS]\",\n        add_help_option: bool = True,\n        no_args_is_help: bool = False,\n        hidden: bool = False,\n        deprecated: bool | str = False,\n    ) -> None:\n        #: the name the command thinks it has.  Upon registering a command\n        #: on a :class:`Group` the group will default the command name\n        #: with this information.  You should instead use the\n        #: :class:`Context`\\'s :attr:`~Context.info_name` attribute.\n        self.name = name\n\n        if context_settings is None:\n            context_settings = {}\n\n        #: an optional dictionary with defaults passed to the context.\n        self.context_settings: cabc.MutableMapping[str, t.Any] = context_settings\n\n        #: the callback to execute when the command fires.  This might be\n        #: `None` in which case nothing happens.\n        self.callback = callback\n        #: the list of parameters for this command in the order they\n        #: should show up in the help page and execute.  Eager parameters\n        #: will automatically be handled before non eager ones.\n        self.params: list[Parameter] = params or []\n        self.help = help\n        self.epilog = epilog\n        self.options_metavar = options_metavar\n        self.short_help = short_help\n        self.add_help_option = add_help_option\n        self._help_option = None\n        self.no_args_is_help = no_args_is_help\n        self.hidden = hidden\n        self.deprecated = deprecated",
        "line_count": 43,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 979,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "param.to_info_dict",
          "self.get_params"
        ],
        "docstring": null,
        "code": "def to_info_dict(self, ctx: Context) -> dict[str, t.Any]:\n        return {\n            \"name\": self.name,\n            \"params\": [param.to_info_dict() for param in self.get_params(ctx)],\n            \"help\": self.help,\n            \"epilog\": self.epilog,\n            \"short_help\": self.short_help,\n            \"hidden\": self.hidden,\n            \"deprecated\": self.deprecated,\n        }",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 990,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} {self.name}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "get_usage",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "str",
        "lineno": 993,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.format_usage",
          "formatter.getvalue",
          "ctx",
          "ctx.make_formatter",
          "formatter",
          "unknown.rstrip"
        ],
        "docstring": "Formats the usage line into a string and returns it.\n\nCalls :meth:`format_usage` internally.",
        "code": "def get_usage(self, ctx: Context) -> str:\n        \"\"\"Formats the usage line into a string and returns it.\n\n        Calls :meth:`format_usage` internally.\n        \"\"\"\n        formatter = ctx.make_formatter()\n        self.format_usage(ctx, formatter)\n        return formatter.getvalue().rstrip(\"\\n\")",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "get_params",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "list[Parameter]",
        "lineno": 1002,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.get_help_option",
          "opts_counter.items",
          "warnings.warn",
          "ctx",
          "opts",
          "Counter",
          "self.params"
        ],
        "docstring": null,
        "code": "def get_params(self, ctx: Context) -> list[Parameter]:\n        params = self.params\n        help_option = self.get_help_option(ctx)\n\n        if help_option is not None:\n            params = [*params, help_option]\n\n        if __debug__:\n            import warnings\n\n            opts = [opt for param in params for opt in param.opts]\n            opts_counter = Counter(opts)\n            duplicate_opts = (opt for opt, count in opts_counter.items() if count > 1)\n\n            for duplicate_opt in duplicate_opts:\n                warnings.warn(\n                    (\n                        f\"The parameter {duplicate_opt} is used more than once. \"\n                        \"Remove its duplicate as parameters should be unique.\"\n                    ),\n                    stacklevel=3,\n                )\n\n        return params",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "format_usage",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "formatter",
            "type": "HelpFormatter"
          }
        ],
        "return_type": "None",
        "lineno": 1027,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "ctx.command_path",
          "ctx",
          "formatter.write_usage",
          "self.collect_usage_pieces",
          "pieces"
        ],
        "docstring": "Writes the usage line into the formatter.\n\nThis is a low-level method called by :meth:`get_usage`.",
        "code": "def format_usage(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the usage line into the formatter.\n\n        This is a low-level method called by :meth:`get_usage`.\n        \"\"\"\n        pieces = self.collect_usage_pieces(ctx)\n        formatter.write_usage(ctx.command_path, \" \".join(pieces))",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "collect_usage_pieces",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "list[str]",
        "lineno": 1035,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "param.get_usage_pieces",
          "rv.extend",
          "self.get_params"
        ],
        "docstring": "Returns all the pieces that go into the usage line and returns\nit as a list of strings.",
        "code": "def collect_usage_pieces(self, ctx: Context) -> list[str]:\n        \"\"\"Returns all the pieces that go into the usage line and returns\n        it as a list of strings.\n        \"\"\"\n        rv = [self.options_metavar] if self.options_metavar else []\n\n        for param in self.get_params(ctx):\n            rv.extend(param.get_usage_pieces(ctx))\n\n        return rv",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "get_help_option_names",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "list[str]",
        "lineno": 1046,
        "decorators": [],
        "is_async": false,
        "calls": [
          "param.opts",
          "set",
          "all_names.difference_update",
          "list",
          "param.secondary_opts",
          "ctx.help_option_names",
          "all_names"
        ],
        "docstring": "Returns the names for the help option.",
        "code": "def get_help_option_names(self, ctx: Context) -> list[str]:\n        \"\"\"Returns the names for the help option.\"\"\"\n        all_names = set(ctx.help_option_names)\n        for param in self.params:\n            all_names.difference_update(param.opts)\n            all_names.difference_update(param.secondary_opts)\n        return list(all_names)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "get_help_option",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 1054,
        "decorators": [],
        "is_async": false,
        "calls": [
          "help_option",
          "self",
          "ctx",
          "self.get_help_option_names",
          "self.params.pop"
        ],
        "docstring": "Returns the help option object.\n\nSkipped if :attr:`add_help_option` is ``False``.\n\n.. versionchanged:: 8.1.8\n    The help option is now cached to avoid creating it multiple times.",
        "code": "def get_help_option(self, ctx: Context) -> Option | None:\n        \"\"\"Returns the help option object.\n\n        Skipped if :attr:`add_help_option` is ``False``.\n\n        .. versionchanged:: 8.1.8\n            The help option is now cached to avoid creating it multiple times.\n        \"\"\"\n        help_option_names = self.get_help_option_names(ctx)\n\n        if not help_option_names or not self.add_help_option:\n            return None\n\n        # Cache the help option object in private _help_option attribute to\n        # avoid creating it multiple times. Not doing this will break the\n        # callback odering by iter_params_for_processing(), which relies on\n        # object comparison.\n        if self._help_option is None:\n            # Avoid circular import.\n            from .decorators import help_option\n\n            # Apply help_option decorator and pop resulting option\n            help_option(*help_option_names)(self)\n            self._help_option = self.params.pop()  # type: ignore[assignment]\n\n        return self._help_option",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "make_parser",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "_OptionParser",
        "lineno": 1081,
        "decorators": [],
        "is_async": false,
        "calls": [
          "param.add_to_parser",
          "self.get_params",
          "ctx",
          "parser",
          "_OptionParser"
        ],
        "docstring": "Creates the underlying option parser for this command.",
        "code": "def make_parser(self, ctx: Context) -> _OptionParser:\n        \"\"\"Creates the underlying option parser for this command.\"\"\"\n        parser = _OptionParser(ctx)\n        for param in self.get_params(ctx):\n            param.add_to_parser(parser, ctx)\n        return parser",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "get_help",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "str",
        "lineno": 1088,
        "decorators": [],
        "is_async": false,
        "calls": [
          "formatter.getvalue",
          "ctx",
          "ctx.make_formatter",
          "self.format_help",
          "formatter",
          "unknown.rstrip"
        ],
        "docstring": "Formats the help into a string and returns it.\n\nCalls :meth:`format_help` internally.",
        "code": "def get_help(self, ctx: Context) -> str:\n        \"\"\"Formats the help into a string and returns it.\n\n        Calls :meth:`format_help` internally.\n        \"\"\"\n        formatter = ctx.make_formatter()\n        self.format_help(ctx, formatter)\n        return formatter.getvalue().rstrip(\"\\n\")",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "get_short_help_str",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "limit",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 1097,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "text.strip",
          "self.help",
          "str",
          "deprecated_message",
          "_",
          "make_default_short_help",
          "isinstance",
          "inspect.cleandoc",
          "limit",
          "self.short_help",
          "unknown.format",
          "self.deprecated"
        ],
        "docstring": "Gets short help for the command or makes it by shortening the\nlong help string.",
        "code": "def get_short_help_str(self, limit: int = 45) -> str:\n        \"\"\"Gets short help for the command or makes it by shortening the\n        long help string.\n        \"\"\"\n        if self.short_help:\n            text = inspect.cleandoc(self.short_help)\n        elif self.help:\n            text = make_default_short_help(self.help, limit)\n        else:\n            text = \"\"\n\n        if self.deprecated:\n            deprecated_message = (\n                f\"(DEPRECATED: {self.deprecated})\"\n                if isinstance(self.deprecated, str)\n                else \"(DEPRECATED)\"\n            )\n            text = _(\"{text} {deprecated_message}\").format(\n                text=text, deprecated_message=deprecated_message\n            )\n\n        return text.strip()",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "format_help",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "formatter",
            "type": "HelpFormatter"
          }
        ],
        "return_type": "None",
        "lineno": 1120,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.format_usage",
          "ctx",
          "self.format_options",
          "formatter",
          "self.format_help_text",
          "self.format_epilog"
        ],
        "docstring": "Writes the help into the formatter if it exists.\n\nThis is a low-level method called by :meth:`get_help`.\n\nThis calls the following methods:\n\n-   :meth:`format_usage`\n-   :meth:`format_help_text`\n-   :meth:`format_options`\n-   :meth:`format_epilog`",
        "code": "def format_help(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the help into the formatter if it exists.\n\n        This is a low-level method called by :meth:`get_help`.\n\n        This calls the following methods:\n\n        -   :meth:`format_usage`\n        -   :meth:`format_help_text`\n        -   :meth:`format_options`\n        -   :meth:`format_epilog`\n        \"\"\"\n        self.format_usage(ctx, formatter)\n        self.format_help_text(ctx, formatter)\n        self.format_options(ctx, formatter)\n        self.format_epilog(ctx, formatter)",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "format_help_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "formatter",
            "type": "HelpFormatter"
          }
        ],
        "return_type": "None",
        "lineno": 1137,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "formatter.write_text",
          "self.help",
          "formatter.indentation",
          "str",
          "deprecated_message",
          "_",
          "isinstance",
          "inspect.cleandoc",
          "formatter.write_paragraph",
          "unknown.format",
          "self.deprecated",
          "unknown.partition"
        ],
        "docstring": "Writes the help text to the formatter if it exists.",
        "code": "def format_help_text(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the help text to the formatter if it exists.\"\"\"\n        if self.help is not None:\n            # truncate the help text to the first form feed\n            text = inspect.cleandoc(self.help).partition(\"\\f\")[0]\n        else:\n            text = \"\"\n\n        if self.deprecated:\n            deprecated_message = (\n                f\"(DEPRECATED: {self.deprecated})\"\n                if isinstance(self.deprecated, str)\n                else \"(DEPRECATED)\"\n            )\n            text = _(\"{text} {deprecated_message}\").format(\n                text=text, deprecated_message=deprecated_message\n            )\n\n        if text:\n            formatter.write_paragraph()\n\n            with formatter.indentation():\n                formatter.write_text(text)",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "format_options",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "formatter",
            "type": "HelpFormatter"
          }
        ],
        "return_type": "None",
        "lineno": 1161,
        "decorators": [],
        "is_async": false,
        "calls": [
          "formatter.write_dl",
          "opts.append",
          "ctx",
          "self.get_params",
          "rv",
          "opts",
          "param.get_help_record",
          "_",
          "formatter.section"
        ],
        "docstring": "Writes all the options into the formatter if they exist.",
        "code": "def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes all the options into the formatter if they exist.\"\"\"\n        opts = []\n        for param in self.get_params(ctx):\n            rv = param.get_help_record(ctx)\n            if rv is not None:\n                opts.append(rv)\n\n        if opts:\n            with formatter.section(_(\"Options\")):\n                formatter.write_dl(opts)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "format_epilog",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "formatter",
            "type": "HelpFormatter"
          }
        ],
        "return_type": "None",
        "lineno": 1173,
        "decorators": [],
        "is_async": false,
        "calls": [
          "formatter.write_text",
          "epilog",
          "formatter.indentation",
          "inspect.cleandoc",
          "formatter.write_paragraph",
          "self.epilog"
        ],
        "docstring": "Writes the epilog into the formatter if it exists.",
        "code": "def format_epilog(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the epilog into the formatter if it exists.\"\"\"\n        if self.epilog:\n            epilog = inspect.cleandoc(self.epilog)\n            formatter.write_paragraph()\n\n            with formatter.indentation():\n                formatter.write_text(epilog)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "make_context",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "info_name",
            "type": "Any"
          },
          {
            "name": "args",
            "type": "list[str]"
          },
          {
            "name": "parent",
            "type": "Any"
          }
        ],
        "return_type": "Context",
        "lineno": 1182,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.context_class",
          "self",
          "parent",
          "value",
          "ctx",
          "self.context_settings.items",
          "self.parse_args",
          "args",
          "ctx.scope",
          "extra",
          "info_name"
        ],
        "docstring": "This function when given an info name and arguments will kick\noff the parsing and create a new :class:`Context`.  It does not\ninvoke the actual command callback though.\n\nTo quickly customize the context class used without overriding\nthis method, set the :attr:`context_class` attribute.\n\n:param info_name: the info name for this invocation.  Generally this\n                  is the most descriptive name for the script or\n                  command.  For the toplevel script it's usually\n                  the name of the script, for commands below it's\n                  the name of the command.\n:param args: the arguments to parse as list of strings.\n:param parent: the parent context if available.\n:param extra: extra keyword arguments forwarded to the context\n              constructor.\n\n.. versionchanged:: 8.0\n    Added the :attr:`context_class` attribute.",
        "code": "def make_context(\n        self,\n        info_name: str | None,\n        args: list[str],\n        parent: Context | None = None,\n        **extra: t.Any,\n    ) -> Context:\n        \"\"\"This function when given an info name and arguments will kick\n        off the parsing and create a new :class:`Context`.  It does not\n        invoke the actual command callback though.\n\n        To quickly customize the context class used without overriding\n        this method, set the :attr:`context_class` attribute.\n\n        :param info_name: the info name for this invocation.  Generally this\n                          is the most descriptive name for the script or\n                          command.  For the toplevel script it's usually\n                          the name of the script, for commands below it's\n                          the name of the command.\n        :param args: the arguments to parse as list of strings.\n        :param parent: the parent context if available.\n        :param extra: extra keyword arguments forwarded to the context\n                      constructor.\n\n        .. versionchanged:: 8.0\n            Added the :attr:`context_class` attribute.\n        \"\"\"\n        for key, value in self.context_settings.items():\n            if key not in extra:\n                extra[key] = value\n\n        ctx = self.context_class(self, info_name=info_name, parent=parent, **extra)\n\n        with ctx.scope(cleanup=False):\n            self.parse_args(ctx, args)\n        return ctx",
        "line_count": 36,
        "needs_llm_summary": true
      },
      {
        "name": "parse_args",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "args",
            "type": "list[str]"
          }
        ],
        "return_type": "list[str]",
        "lineno": 1219,
        "decorators": [],
        "is_async": false,
        "calls": [
          "iter_params_for_processing",
          "param_order",
          "ctx",
          "len",
          "ctx._opt_prefixes.update",
          "ctx.params.items",
          "opts",
          "self.make_parser",
          "unknown.format",
          "NoArgsIsHelpError",
          "param.handle_parse_result",
          "parser.parse_args",
          "self.get_params",
          "str",
          "ctx.fail",
          "args",
          "parser._opt_prefixes",
          "unknown.join",
          "ngettext",
          "map"
        ],
        "docstring": null,
        "code": "def parse_args(self, ctx: Context, args: list[str]) -> list[str]:\n        if not args and self.no_args_is_help and not ctx.resilient_parsing:\n            raise NoArgsIsHelpError(ctx)\n\n        parser = self.make_parser(ctx)\n        opts, args, param_order = parser.parse_args(args=args)\n\n        for param in iter_params_for_processing(param_order, self.get_params(ctx)):\n            _, args = param.handle_parse_result(ctx, opts, args)\n\n        # We now have all parameters' values into `ctx.params`, but the data may contain\n        # the `UNSET` sentinel.\n        # Convert `UNSET` to `None` to ensure that the user doesn't see `UNSET`.\n        #\n        # Waiting until after the initial parse to convert allows us to treat `UNSET`\n        # more like a missing value when multiple params use the same name.\n        # Refs:\n        # https://github.com/pallets/click/issues/3071\n        # https://github.com/pallets/click/pull/3079\n        for name, value in ctx.params.items():\n            if value is UNSET:\n                ctx.params[name] = None\n\n        if args and not ctx.allow_extra_args and not ctx.resilient_parsing:\n            ctx.fail(\n                ngettext(\n                    \"Got unexpected extra argument ({args})\",\n                    \"Got unexpected extra arguments ({args})\",\n                    len(args),\n                ).format(args=\" \".join(map(str, args)))\n            )\n\n        ctx.args = args\n        ctx._opt_prefixes.update(parser._opt_prefixes)\n        return args",
        "line_count": 35,
        "needs_llm_summary": true
      },
      {
        "name": "invoke",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "t.Any",
        "lineno": 1255,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "unknown.format",
          "message",
          "str",
          "self.name",
          "_",
          "ctx.params",
          "extra_message",
          "isinstance",
          "self.callback",
          "style",
          "ctx.invoke",
          "self.deprecated"
        ],
        "docstring": "Given a context, this invokes the attached callback (if it exists)\nin the right way.",
        "code": "def invoke(self, ctx: Context) -> t.Any:\n        \"\"\"Given a context, this invokes the attached callback (if it exists)\n        in the right way.\n        \"\"\"\n        if self.deprecated:\n            extra_message = (\n                f\" {self.deprecated}\" if isinstance(self.deprecated, str) else \"\"\n            )\n            message = _(\n                \"DeprecationWarning: The command {name!r} is deprecated.{extra_message}\"\n            ).format(name=self.name, extra_message=extra_message)\n            echo(style(message, fg=\"red\"), err=True)\n\n        if self.callback is not None:\n            return ctx.invoke(self.callback, **ctx.params)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "shell_complete",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "list[CompletionItem]",
        "lineno": 1271,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "param.name",
          "ctx.parent",
          "unknown.isalnum",
          "isinstance",
          "param.help",
          "Group",
          "incomplete",
          "ctx.get_parameter_source",
          "name",
          "results.extend",
          "CompletionItem",
          "self.get_params",
          "param",
          "Option",
          "ctx.command",
          "_complete_visible_commands",
          "name.startswith",
          "command.get_short_help_str"
        ],
        "docstring": "Return a list of completions for the incomplete value. Looks\nat the names of options and chained multi-commands.\n\nAny command could be part of a chained multi-command, so sibling\ncommands are valid at any point during command completion.\n\n:param ctx: Invocation context for this command.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
        "code": "def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of completions for the incomplete value. Looks\n        at the names of options and chained multi-commands.\n\n        Any command could be part of a chained multi-command, so sibling\n        commands are valid at any point during command completion.\n\n        :param ctx: Invocation context for this command.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        results: list[CompletionItem] = []\n\n        if incomplete and not incomplete[0].isalnum():\n            for param in self.get_params(ctx):\n                if (\n                    not isinstance(param, Option)\n                    or param.hidden\n                    or (\n                        not param.multiple\n                        and ctx.get_parameter_source(param.name)  # type: ignore\n                        is ParameterSource.COMMANDLINE\n                    )\n                ):\n                    continue\n\n                results.extend(\n                    CompletionItem(name, help=param.help)\n                    for name in [*param.opts, *param.secondary_opts]\n                    if name.startswith(incomplete)\n                )\n\n        while ctx.parent is not None:\n            ctx = ctx.parent\n\n            if isinstance(ctx.command, Group) and ctx.command.chain:\n                results.extend(\n                    CompletionItem(name, help=command.get_short_help_str())\n                    for name, command in _complete_visible_commands(ctx, incomplete)\n                    if name not in ctx._protected_args\n                )\n\n        return results",
        "line_count": 46,
        "needs_llm_summary": true
      },
      {
        "name": "main",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "args",
            "type": "Any"
          },
          {
            "name": "prog_name",
            "type": "Any"
          },
          {
            "name": "complete_var",
            "type": "Any"
          },
          {
            "name": "standalone_mode",
            "type": "t.Literal[True]"
          }
        ],
        "return_type": "t.NoReturn",
        "lineno": 1319,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def main(\n        self,\n        args: cabc.Sequence[str] | None = None,\n        prog_name: str | None = None,\n        complete_var: str | None = None,\n        standalone_mode: t.Literal[True] = True,\n        **extra: t.Any,\n    ) -> t.NoReturn: ...",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "main",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "args",
            "type": "Any"
          },
          {
            "name": "prog_name",
            "type": "Any"
          },
          {
            "name": "complete_var",
            "type": "Any"
          },
          {
            "name": "standalone_mode",
            "type": "bool"
          }
        ],
        "return_type": "t.Any",
        "lineno": 1329,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def main(\n        self,\n        args: cabc.Sequence[str] | None = None,\n        prog_name: str | None = None,\n        complete_var: str | None = None,\n        standalone_mode: bool = ...,\n        **extra: t.Any,\n    ) -> t.Any: ...",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "main",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "args",
            "type": "Any"
          },
          {
            "name": "prog_name",
            "type": "Any"
          },
          {
            "name": "complete_var",
            "type": "Any"
          },
          {
            "name": "standalone_mode",
            "type": "bool"
          },
          {
            "name": "windows_expand_args",
            "type": "bool"
          }
        ],
        "return_type": "t.Any",
        "lineno": 1338,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "t.TextIO",
          "e.exit_code",
          "ctx",
          "PacifyFlushWrapper",
          "sys.exit",
          "extra",
          "self.make_context",
          "_expand_args",
          "_",
          "self.invoke",
          "Abort",
          "complete_var",
          "sys.stderr",
          "ctx.exit",
          "self._main_shell_completion",
          "args",
          "sys.stdout",
          "list",
          "t.cast",
          "_detect_program_name",
          "prog_name",
          "e.show"
        ],
        "docstring": "This is the way to invoke a script with all the bells and\nwhistles as a command line application.  This will always terminate\nthe application after a call.  If this is not wanted, ``SystemExit``\nneeds to be caught.\n\nThis method is also available by directly calling the instance of\na :class:`Command`.\n\n:param args: the arguments that should be used for parsing.  If not\n             provided, ``sys.argv[1:]`` is used.\n:param prog_name: the program name that should be used.  By default\n                  the program name is constructed by taking the file\n                  name from ``sys.argv[0]``.\n:param complete_var: the environment variable that controls the\n                     bash completion support.  The default is\n                     ``\"_<prog_name>_COMPLETE\"`` with prog_name in\n                     uppercase.\n:param standalone_mode: the default behavior is to invoke the script\n                        in standalone mode.  Click will then\n                        handle exceptions and convert them into\n                        error messages and the function will never\n                        return but shut down the interpreter.  If\n                        this is set to `False` they will be\n                        propagated to the caller and the return\n                        value of this function is the return value\n                        of :meth:`invoke`.\n:param windows_expand_args: Expand glob patterns, user dir, and\n    env vars in command line args on Windows.\n:param extra: extra keyword arguments are forwarded to the context\n              constructor.  See :class:`Context` for more information.\n\n.. versionchanged:: 8.0.1\n    Added the ``windows_expand_args`` parameter to allow\n    disabling command line arg expansion on Windows.\n\n.. versionchanged:: 8.0\n    When taking arguments from ``sys.argv`` on Windows, glob\n    patterns, user dir, and env vars are expanded.\n\n.. versionchanged:: 3.0\n   Added the ``standalone_mode`` parameter.",
        "code": "def main(\n        self,\n        args: cabc.Sequence[str] | None = None,\n        prog_name: str | None = None,\n        complete_var: str | None = None,\n        standalone_mode: bool = True,\n        windows_expand_args: bool = True,\n        **extra: t.Any,\n    ) -> t.Any:\n        \"\"\"This is the way to invoke a script with all the bells and\n        whistles as a command line application.  This will always terminate\n        the application after a call.  If this is not wanted, ``SystemExit``\n        needs to be caught.\n\n        This method is also available by directly calling the instance of\n        a :class:`Command`.\n\n        :param args: the arguments that should be used for parsing.  If not\n                     provided, ``sys.argv[1:]`` is used.\n        :param prog_name: the program name that should be used.  By default\n                          the program name is constructed by taking the file\n                          name from ``sys.argv[0]``.\n        :param complete_var: the environment variable that controls the\n                             bash completion support.  The default is\n                             ``\"_<prog_name>_COMPLETE\"`` with prog_name in\n                             uppercase.\n        :param standalone_mode: the default behavior is to invoke the script\n                                in standalone mode.  Click will then\n                                handle exceptions and convert them into\n                                error messages and the function will never\n                                return but shut down the interpreter.  If\n                                this is set to `False` they will be\n                                propagated to the caller and the return\n                                value of this function is the return value\n                                of :meth:`invoke`.\n        :param windows_expand_args: Expand glob patterns, user dir, and\n            env vars in command line args on Windows.\n        :param extra: extra keyword arguments are forwarded to the context\n                      constructor.  See :class:`Context` for more information.\n\n        .. versionchanged:: 8.0.1\n            Added the ``windows_expand_args`` parameter to allow\n            disabling command line arg expansion on Windows.\n\n        .. versionchanged:: 8.0\n            When taking arguments from ``sys.argv`` on Windows, glob\n            patterns, user dir, and env vars are expanded.\n\n        .. versionchanged:: 3.0\n           Added the ``standalone_mode`` parameter.\n        \"\"\"\n        if args is None:\n            args = sys.argv[1:]\n\n            if os.name == \"nt\" and windows_expand_args:\n                args = _expand_args(args)\n        else:\n            args = list(args)\n\n        if prog_name is None:\n            prog_name = _detect_program_name()\n\n        # Process shell completion requests and exit early.\n        self._main_shell_completion(extra, prog_name, complete_var)\n\n        try:\n            try:\n                with self.make_context(prog_name, args, **extra) as ctx:\n                    rv = self.invoke(ctx)\n                    if not standalone_mode:\n                        return rv\n                    # it's not safe to `ctx.exit(rv)` here!\n                    # note that `rv` may actually contain data like \"1\" which\n                    # has obvious effects\n                    # more subtle case: `rv=[None, None]` can come out of\n                    # chained commands which all returned `None` -- so it's not\n                    # even always obvious that `rv` indicates success/failure\n                    # by its truthiness/falsiness\n                    ctx.exit()\n            except (EOFError, KeyboardInterrupt) as e:\n                echo(file=sys.stderr)\n                raise Abort() from e\n            except ClickException as e:\n                if not standalone_mode:\n                    raise\n                e.show()\n                sys.exit(e.exit_code)\n            except OSError as e:\n                if e.errno == errno.EPIPE:\n                    sys.stdout = t.cast(t.TextIO, PacifyFlushWrapper(sys.stdout))\n                    sys.stderr = t.cast(t.TextIO, PacifyFlushWrapper(sys.stderr))\n                    sys.exit(1)\n                else:\n                    raise\n        except Exit as e:\n            if standalone_mode:\n                sys.exit(e.exit_code)\n            else:\n                # in non-standalone mode, return the exit code\n                # note that this is only reached if `self.invoke` above raises\n                # an Exit explicitly -- thus bypassing the check there which\n                # would return its result\n                # the results of non-standalone execution may therefore be\n                # somewhat ambiguous: if there are codepaths which lead to\n                # `ctx.exit(1)` and to `return 1`, the caller won't be able to\n                # tell the difference between the two\n                return e.exit_code\n        except Abort:\n            if not standalone_mode:\n                raise\n            echo(_(\"Aborted!\"), file=sys.stderr)\n            sys.exit(1)",
        "line_count": 112,
        "needs_llm_summary": true
      },
      {
        "name": "_main_shell_completion",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx_args",
            "type": "cabc.MutableMapping[str, t.Any]"
          },
          {
            "name": "prog_name",
            "type": "str"
          },
          {
            "name": "complete_var",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 1451,
        "decorators": [],
        "is_async": false,
        "calls": [
          "shell_complete",
          "os.environ.get",
          "self",
          "prog_name.replace",
          "rv",
          "prog_name",
          "unknown.upper",
          "ctx_args",
          "instruction",
          "unknown.replace",
          "sys.exit",
          "complete_var"
        ],
        "docstring": "Check if the shell is asking for tab completion, process\nthat, then exit early. Called from :meth:`main` before the\nprogram is invoked.\n\n:param prog_name: Name of the executable in the shell.\n:param complete_var: Name of the environment variable that holds\n    the completion instruction. Defaults to\n    ``_{PROG_NAME}_COMPLETE``.\n\n.. versionchanged:: 8.2.0\n    Dots (``.``) in ``prog_name`` are replaced with underscores (``_``).",
        "code": "def _main_shell_completion(\n        self,\n        ctx_args: cabc.MutableMapping[str, t.Any],\n        prog_name: str,\n        complete_var: str | None = None,\n    ) -> None:\n        \"\"\"Check if the shell is asking for tab completion, process\n        that, then exit early. Called from :meth:`main` before the\n        program is invoked.\n\n        :param prog_name: Name of the executable in the shell.\n        :param complete_var: Name of the environment variable that holds\n            the completion instruction. Defaults to\n            ``_{PROG_NAME}_COMPLETE``.\n\n        .. versionchanged:: 8.2.0\n            Dots (``.``) in ``prog_name`` are replaced with underscores (``_``).\n        \"\"\"\n        if complete_var is None:\n            complete_name = prog_name.replace(\"-\", \"_\").replace(\".\", \"_\")\n            complete_var = f\"_{complete_name}_COMPLETE\".upper()\n\n        instruction = os.environ.get(complete_var)\n\n        if not instruction:\n            return\n\n        from .shell_completion import shell_complete\n\n        rv = shell_complete(self, ctx_args, prog_name, complete_var, instruction)\n        sys.exit(rv)",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "t.Any",
        "lineno": 1483,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.main",
          "kwargs"
        ],
        "docstring": "Alias for :meth:`main`.",
        "code": "def __call__(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Alias for :meth:`main`.\"\"\"\n        return self.main(*args, **kwargs)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__subclasscheck__",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "subclass",
            "type": "type"
          }
        ],
        "return_type": "bool",
        "lineno": 1489,
        "decorators": [],
        "is_async": false,
        "calls": [
          "subclass",
          "issubclass"
        ],
        "docstring": null,
        "code": "def __subclasscheck__(cls, subclass: type) -> bool:\n        return issubclass(subclass, cls.__bases__[0])",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__instancecheck__",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "instance",
            "type": "t.Any"
          }
        ],
        "return_type": "bool",
        "lineno": 1492,
        "decorators": [],
        "is_async": false,
        "calls": [
          "instance",
          "isinstance"
        ],
        "docstring": null,
        "code": "def __instancecheck__(cls, instance: t.Any) -> bool:\n        return isinstance(instance, cls.__bases__[0])",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "commands",
            "type": "Any"
          },
          {
            "name": "invoke_without_command",
            "type": "bool"
          },
          {
            "name": "no_args_is_help",
            "type": "Any"
          },
          {
            "name": "subcommand_metavar",
            "type": "Any"
          },
          {
            "name": "chain",
            "type": "bool"
          },
          {
            "name": "result_callback",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 1556,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Argument",
          "subcommand_metavar",
          "no_args_is_help",
          "result_callback",
          "param",
          "unknown.__init__",
          "name",
          "RuntimeError",
          "isinstance",
          "chain",
          "commands",
          "kwargs",
          "abc.Sequence",
          "super",
          "invoke_without_command"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        name: str | None = None,\n        commands: cabc.MutableMapping[str, Command]\n        | cabc.Sequence[Command]\n        | None = None,\n        invoke_without_command: bool = False,\n        no_args_is_help: bool | None = None,\n        subcommand_metavar: str | None = None,\n        chain: bool = False,\n        result_callback: t.Callable[..., t.Any] | None = None,\n        **kwargs: t.Any,\n    ) -> None:\n        super().__init__(name, **kwargs)\n\n        if commands is None:\n            commands = {}\n        elif isinstance(commands, abc.Sequence):\n            commands = {c.name: c for c in commands if c.name is not None}\n\n        #: The registered subcommands by their exported names.\n        self.commands: cabc.MutableMapping[str, Command] = commands\n\n        if no_args_is_help is None:\n            no_args_is_help = not invoke_without_command\n\n        self.no_args_is_help = no_args_is_help\n        self.invoke_without_command = invoke_without_command\n\n        if subcommand_metavar is None:\n            if chain:\n                subcommand_metavar = \"COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]...\"\n            else:\n                subcommand_metavar = \"COMMAND [ARGS]...\"\n\n        self.subcommand_metavar = subcommand_metavar\n        self.chain = chain\n        # The result callback that is stored. This can be set or\n        # overridden with the :func:`result_callback` decorator.\n        self._result_callback = result_callback\n\n        if self.chain:\n            for param in self.params:\n                if isinstance(param, Argument) and not param.required:\n                    raise RuntimeError(\n                        \"A group in chain mode cannot have optional arguments.\"\n                    )",
        "line_count": 47,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 1604,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "self.chain",
          "unknown.to_info_dict",
          "self.get_command",
          "name",
          "command",
          "command.to_info_dict",
          "sub_ctx",
          "commands",
          "super",
          "info_dict.update",
          "ctx._make_sub_context",
          "self.list_commands",
          "sub_ctx.scope"
        ],
        "docstring": null,
        "code": "def to_info_dict(self, ctx: Context) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict(ctx)\n        commands = {}\n\n        for name in self.list_commands(ctx):\n            command = self.get_command(ctx, name)\n\n            if command is None:\n                continue\n\n            sub_ctx = ctx._make_sub_context(command)\n\n            with sub_ctx.scope(cleanup=False):\n                commands[name] = command.to_info_dict(sub_ctx)\n\n        info_dict.update(commands=commands, chain=self.chain)\n        return info_dict",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "add_command",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "cmd",
            "type": "Command"
          },
          {
            "name": "name",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 1622,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self",
          "name",
          "_check_nested_chain",
          "TypeError",
          "cmd"
        ],
        "docstring": "Registers another :class:`Command` with this group.  If the name\nis not provided, the name of the command is used.",
        "code": "def add_command(self, cmd: Command, name: str | None = None) -> None:\n        \"\"\"Registers another :class:`Command` with this group.  If the name\n        is not provided, the name of the command is used.\n        \"\"\"\n        name = name or cmd.name\n        if name is None:\n            raise TypeError(\"Command has no name.\")\n        _check_nested_chain(self, name, cmd, register=True)\n        self.commands[name] = cmd",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "command",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__func",
            "type": "t.Callable[Ellipsis, t.Any]"
          }
        ],
        "return_type": "Command",
        "lineno": 1633,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def command(self, __func: t.Callable[..., t.Any]) -> Command: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "command",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "t.Callable[Any, Command]",
        "lineno": 1636,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def command(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Command]: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "command",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Any",
        "lineno": 1640,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.add_command",
          "decorator",
          "len",
          "f",
          "command",
          "func",
          "self.command_class",
          "args",
          "kwargs",
          "callable",
          "cmd",
          "kwargs.get"
        ],
        "docstring": "A shortcut decorator for declaring and attaching a command to\nthe group. This takes the same arguments as :func:`command` and\nimmediately registers the created command with this group by\ncalling :meth:`add_command`.\n\nTo customize the command class used, set the\n:attr:`command_class` attribute.\n\n.. versionchanged:: 8.1\n    This decorator can be applied without parentheses.\n\n.. versionchanged:: 8.0\n    Added the :attr:`command_class` attribute.",
        "code": "def command(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Command] | Command:\n        \"\"\"A shortcut decorator for declaring and attaching a command to\n        the group. This takes the same arguments as :func:`command` and\n        immediately registers the created command with this group by\n        calling :meth:`add_command`.\n\n        To customize the command class used, set the\n        :attr:`command_class` attribute.\n\n        .. versionchanged:: 8.1\n            This decorator can be applied without parentheses.\n\n        .. versionchanged:: 8.0\n            Added the :attr:`command_class` attribute.\n        \"\"\"\n        from .decorators import command\n\n        func: t.Callable[..., t.Any] | None = None\n\n        if args and callable(args[0]):\n            assert len(args) == 1 and not kwargs, (\n                \"Use 'command(**kwargs)(callable)' to provide arguments.\"\n            )\n            (func,) = args\n            args = ()\n\n        if self.command_class and kwargs.get(\"cls\") is None:\n            kwargs[\"cls\"] = self.command_class\n\n        def decorator(f: t.Callable[..., t.Any]) -> Command:\n            cmd: Command = command(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return cmd\n\n        if func is not None:\n            return decorator(func)\n\n        return decorator",
        "line_count": 40,
        "needs_llm_summary": true
      },
      {
        "name": "group",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__func",
            "type": "t.Callable[Ellipsis, t.Any]"
          }
        ],
        "return_type": "Group",
        "lineno": 1682,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def group(self, __func: t.Callable[..., t.Any]) -> Group: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "group",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "t.Callable[Any, Group]",
        "lineno": 1685,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def group(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Group]: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "group",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Any",
        "lineno": 1689,
        "decorators": [],
        "is_async": false,
        "calls": [
          "type",
          "self.add_command",
          "self",
          "decorator",
          "len",
          "f",
          "group",
          "func",
          "args",
          "kwargs",
          "callable",
          "kwargs.get",
          "cmd",
          "self.group_class"
        ],
        "docstring": "A shortcut decorator for declaring and attaching a group to\nthe group. This takes the same arguments as :func:`group` and\nimmediately registers the created group with this group by\ncalling :meth:`add_command`.\n\nTo customize the group class used, set the :attr:`group_class`\nattribute.\n\n.. versionchanged:: 8.1\n    This decorator can be applied without parentheses.\n\n.. versionchanged:: 8.0\n    Added the :attr:`group_class` attribute.",
        "code": "def group(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Group] | Group:\n        \"\"\"A shortcut decorator for declaring and attaching a group to\n        the group. This takes the same arguments as :func:`group` and\n        immediately registers the created group with this group by\n        calling :meth:`add_command`.\n\n        To customize the group class used, set the :attr:`group_class`\n        attribute.\n\n        .. versionchanged:: 8.1\n            This decorator can be applied without parentheses.\n\n        .. versionchanged:: 8.0\n            Added the :attr:`group_class` attribute.\n        \"\"\"\n        from .decorators import group\n\n        func: t.Callable[..., t.Any] | None = None\n\n        if args and callable(args[0]):\n            assert len(args) == 1 and not kwargs, (\n                \"Use 'group(**kwargs)(callable)' to provide arguments.\"\n            )\n            (func,) = args\n            args = ()\n\n        if self.group_class is not None and kwargs.get(\"cls\") is None:\n            if self.group_class is type:\n                kwargs[\"cls\"] = type(self)\n            else:\n                kwargs[\"cls\"] = self.group_class\n\n        def decorator(f: t.Callable[..., t.Any]) -> Group:\n            cmd: Group = group(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return cmd\n\n        if func is not None:\n            return decorator(func)\n\n        return decorator",
        "line_count": 43,
        "needs_llm_summary": true
      },
      {
        "name": "result_callback",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "replace",
            "type": "bool"
          }
        ],
        "return_type": "t.Callable[Any, F]",
        "lineno": 1733,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value",
          "old_callback",
          "f",
          "t.cast",
          "function",
          "update_wrapper",
          "kwargs",
          "inner",
          "F",
          "self._result_callback"
        ],
        "docstring": "Adds a result callback to the command.  By default if a\nresult callback is already registered this will chain them but\nthis can be disabled with the `replace` parameter.  The result\ncallback is invoked with the return value of the subcommand\n(or the list of return values from all subcommands if chaining\nis enabled) as well as the parameters as they would be passed\nto the main callback.\n\nExample::\n\n    @click.group()\n    @click.option('-i', '--input', default=23)\n    def cli(input):\n        return 42\n\n    @cli.result_callback()\n    def process_result(result, input):\n        return result + input\n\n:param replace: if set to `True` an already existing result\n                callback will be removed.\n\n.. versionchanged:: 8.0\n    Renamed from ``resultcallback``.\n\n.. versionadded:: 3.0",
        "code": "def result_callback(self, replace: bool = False) -> t.Callable[[F], F]:\n        \"\"\"Adds a result callback to the command.  By default if a\n        result callback is already registered this will chain them but\n        this can be disabled with the `replace` parameter.  The result\n        callback is invoked with the return value of the subcommand\n        (or the list of return values from all subcommands if chaining\n        is enabled) as well as the parameters as they would be passed\n        to the main callback.\n\n        Example::\n\n            @click.group()\n            @click.option('-i', '--input', default=23)\n            def cli(input):\n                return 42\n\n            @cli.result_callback()\n            def process_result(result, input):\n                return result + input\n\n        :param replace: if set to `True` an already existing result\n                        callback will be removed.\n\n        .. versionchanged:: 8.0\n            Renamed from ``resultcallback``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            old_callback = self._result_callback\n\n            if old_callback is None or replace:\n                self._result_callback = f\n                return f\n\n            def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n                inner = old_callback(value, *args, **kwargs)\n                return f(inner, *args, **kwargs)\n\n            self._result_callback = rv = update_wrapper(t.cast(F, function), f)\n            return rv  # type: ignore[return-value]\n\n        return decorator",
        "line_count": 44,
        "needs_llm_summary": true
      },
      {
        "name": "get_command",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "cmd_name",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 1778,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cmd_name",
          "self.commands.get"
        ],
        "docstring": "Given a context and a command name, this returns a :class:`Command`\nobject if it exists or returns ``None``.",
        "code": "def get_command(self, ctx: Context, cmd_name: str) -> Command | None:\n        \"\"\"Given a context and a command name, this returns a :class:`Command`\n        object if it exists or returns ``None``.\n        \"\"\"\n        return self.commands.get(cmd_name)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "list_commands",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "list[str]",
        "lineno": 1784,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.commands",
          "sorted"
        ],
        "docstring": "Returns a list of subcommand names in the order they should appear.",
        "code": "def list_commands(self, ctx: Context) -> list[str]:\n        \"\"\"Returns a list of subcommand names in the order they should appear.\"\"\"\n        return sorted(self.commands)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "collect_usage_pieces",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "list[str]",
        "lineno": 1788,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "unknown.collect_usage_pieces",
          "rv.append",
          "super",
          "self.subcommand_metavar"
        ],
        "docstring": null,
        "code": "def collect_usage_pieces(self, ctx: Context) -> list[str]:\n        rv = super().collect_usage_pieces(ctx)\n        rv.append(self.subcommand_metavar)\n        return rv",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "format_options",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "formatter",
            "type": "HelpFormatter"
          }
        ],
        "return_type": "None",
        "lineno": 1793,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.format_options",
          "ctx",
          "self.format_commands",
          "super",
          "formatter"
        ],
        "docstring": null,
        "code": "def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:\n        super().format_options(ctx, formatter)\n        self.format_commands(ctx, formatter)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "format_commands",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "formatter",
            "type": "HelpFormatter"
          }
        ],
        "return_type": "None",
        "lineno": 1797,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cmd.get_short_help_str",
          "commands.append",
          "formatter.write_dl",
          "ctx",
          "max",
          "len",
          "self.get_command",
          "rows",
          "_",
          "limit",
          "commands",
          "formatter.section",
          "subcommand",
          "rows.append",
          "self.list_commands"
        ],
        "docstring": "Extra format methods for multi methods that adds all the commands\nafter the options.",
        "code": "def format_commands(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Extra format methods for multi methods that adds all the commands\n        after the options.\n        \"\"\"\n        commands = []\n        for subcommand in self.list_commands(ctx):\n            cmd = self.get_command(ctx, subcommand)\n            # What is this, the tool lied about a command.  Ignore it\n            if cmd is None:\n                continue\n            if cmd.hidden:\n                continue\n\n            commands.append((subcommand, cmd))\n\n        # allow for 3 times the default spacing\n        if len(commands):\n            limit = formatter.width - 6 - max(len(cmd[0]) for cmd in commands)\n\n            rows = []\n            for subcommand, cmd in commands:\n                help = cmd.get_short_help_str(limit)\n                rows.append((subcommand, help))\n\n            if rows:\n                with formatter.section(_(\"Commands\")):\n                    formatter.write_dl(rows)",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "parse_args",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "args",
            "type": "list[str]"
          }
        ],
        "return_type": "list[str]",
        "lineno": 1825,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.parse_args",
          "rest",
          "ctx",
          "NoArgsIsHelpError",
          "args",
          "super"
        ],
        "docstring": null,
        "code": "def parse_args(self, ctx: Context, args: list[str]) -> list[str]:\n        if not args and self.no_args_is_help and not ctx.resilient_parsing:\n            raise NoArgsIsHelpError(ctx)\n\n        rest = super().parse_args(ctx, args)\n\n        if self.chain:\n            ctx._protected_args = rest\n            ctx.args = []\n        elif rest:\n            ctx._protected_args, ctx.args = rest[:1], rest[1:]\n\n        return ctx.args",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "invoke",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "t.Any",
        "lineno": 1839,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sub_ctx.command.invoke",
          "ctx",
          "rv.append",
          "self._result_callback",
          "self.resolve_command",
          "rv",
          "_",
          "unknown.invoke",
          "ctx.params",
          "ctx.fail",
          "cmd_name",
          "args",
          "contexts.append",
          "cmd.make_context",
          "value",
          "_process_result",
          "super",
          "ctx.invoke",
          "sub_ctx"
        ],
        "docstring": null,
        "code": "def invoke(self, ctx: Context) -> t.Any:\n        def _process_result(value: t.Any) -> t.Any:\n            if self._result_callback is not None:\n                value = ctx.invoke(self._result_callback, value, **ctx.params)\n            return value\n\n        if not ctx._protected_args:\n            if self.invoke_without_command:\n                # No subcommand was invoked, so the result callback is\n                # invoked with the group return value for regular\n                # groups, or an empty list for chained groups.\n                with ctx:\n                    rv = super().invoke(ctx)\n                    return _process_result([] if self.chain else rv)\n            ctx.fail(_(\"Missing command.\"))\n\n        # Fetch args back out\n        args = [*ctx._protected_args, *ctx.args]\n        ctx.args = []\n        ctx._protected_args = []\n\n        # If we're not in chain mode, we only allow the invocation of a\n        # single command but we also inform the current context about the\n        # name of the command to invoke.\n        if not self.chain:\n            # Make sure the context is entered so we do not clean up\n            # resources until the result processor has worked.\n            with ctx:\n                cmd_name, cmd, args = self.resolve_command(ctx, args)\n                assert cmd is not None\n                ctx.invoked_subcommand = cmd_name\n                super().invoke(ctx)\n                sub_ctx = cmd.make_context(cmd_name, args, parent=ctx)\n                with sub_ctx:\n                    return _process_result(sub_ctx.command.invoke(sub_ctx))\n\n        # In chain mode we create the contexts step by step, but after the\n        # base command has been invoked.  Because at that point we do not\n        # know the subcommands yet, the invoked subcommand attribute is\n        # set to ``*`` to inform the command that subcommands are executed\n        # but nothing else.\n        with ctx:\n            ctx.invoked_subcommand = \"*\" if args else None\n            super().invoke(ctx)\n\n            # Otherwise we make every single context and invoke them in a\n            # chain.  In that case the return value to the result processor\n            # is the list of all invoked subcommand's results.\n            contexts = []\n            while args:\n                cmd_name, cmd, args = self.resolve_command(ctx, args)\n                assert cmd is not None\n                sub_ctx = cmd.make_context(\n                    cmd_name,\n                    args,\n                    parent=ctx,\n                    allow_extra_args=True,\n                    allow_interspersed_args=False,\n                )\n                contexts.append(sub_ctx)\n                args, sub_ctx.args = sub_ctx.args, []\n\n            rv = []\n            for sub_ctx in contexts:\n                with sub_ctx:\n                    rv.append(sub_ctx.command.invoke(sub_ctx))\n            return _process_result(rv)",
        "line_count": 67,
        "needs_llm_summary": true
      },
      {
        "name": "resolve_command",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "args",
            "type": "list[str]"
          }
        ],
        "return_type": "tuple[Any, Any, list[str]]",
        "lineno": 1907,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.token_normalize_func",
          "original_cmd_name",
          "ctx",
          "self.get_command",
          "make_str",
          "_",
          "cmd_name",
          "ctx.fail",
          "self.parse_args",
          "args",
          "_split_opt",
          "unknown.format"
        ],
        "docstring": null,
        "code": "def resolve_command(\n        self, ctx: Context, args: list[str]\n    ) -> tuple[str | None, Command | None, list[str]]:\n        cmd_name = make_str(args[0])\n        original_cmd_name = cmd_name\n\n        # Get the command\n        cmd = self.get_command(ctx, cmd_name)\n\n        # If we can't find the command but there is a normalization\n        # function available, we try with that one.\n        if cmd is None and ctx.token_normalize_func is not None:\n            cmd_name = ctx.token_normalize_func(cmd_name)\n            cmd = self.get_command(ctx, cmd_name)\n\n        # If we don't find the command we want to show an error message\n        # to the user that it was not provided.  However, there is\n        # something else we should do: if the first argument looks like\n        # an option we want to kick off parsing again for arguments to\n        # resolve things like --help which now should go to the main\n        # place.\n        if cmd is None and not ctx.resilient_parsing:\n            if _split_opt(cmd_name)[0]:\n                self.parse_args(ctx, args)\n            ctx.fail(_(\"No such command {name!r}.\").format(name=original_cmd_name))\n        return cmd_name if cmd else None, cmd, args[1:]",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "shell_complete",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "list[CompletionItem]",
        "lineno": 1934,
        "decorators": [],
        "is_async": false,
        "calls": [
          "incomplete",
          "ctx",
          "name",
          "results.extend",
          "CompletionItem",
          "unknown.shell_complete",
          "super",
          "command.get_short_help_str",
          "_complete_visible_commands"
        ],
        "docstring": "Return a list of completions for the incomplete value. Looks\nat the names of options, subcommands, and chained\nmulti-commands.\n\n:param ctx: Invocation context for this command.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
        "code": "def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of completions for the incomplete value. Looks\n        at the names of options, subcommands, and chained\n        multi-commands.\n\n        :param ctx: Invocation context for this command.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        results = [\n            CompletionItem(name, help=command.get_short_help_str())\n            for name, command in _complete_visible_commands(ctx, incomplete)\n        ]\n        results.extend(super().shell_complete(ctx, incomplete))\n        return results",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "sources",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 1977,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.__init__",
          "name",
          "super",
          "kwargs"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        name: str | None = None,\n        sources: list[Group] | None = None,\n        **kwargs: t.Any,\n    ) -> None:\n        super().__init__(name, **kwargs)\n        #: The list of registered groups.\n        self.sources: list[Group] = sources or []",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "add_source",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "group",
            "type": "Group"
          }
        ],
        "return_type": "None",
        "lineno": 1987,
        "decorators": [],
        "is_async": false,
        "calls": [
          "group",
          "self.sources.append"
        ],
        "docstring": "Add a group as a source of commands.",
        "code": "def add_source(self, group: Group) -> None:\n        \"\"\"Add a group as a source of commands.\"\"\"\n        self.sources.append(group)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get_command",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "cmd_name",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 1991,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.get_command",
          "self",
          "ctx",
          "rv",
          "_check_nested_chain",
          "cmd_name",
          "source.get_command",
          "super"
        ],
        "docstring": null,
        "code": "def get_command(self, ctx: Context, cmd_name: str) -> Command | None:\n        rv = super().get_command(ctx, cmd_name)\n\n        if rv is not None:\n            return rv\n\n        for source in self.sources:\n            rv = source.get_command(ctx, cmd_name)\n\n            if rv is not None:\n                if self.chain:\n                    _check_nested_chain(self, cmd_name, rv)\n\n                return rv\n\n        return None",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "list_commands",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "list[str]",
        "lineno": 2008,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "set",
          "ctx",
          "rv",
          "source.list_commands",
          "rv.update",
          "unknown.list_commands",
          "sorted"
        ],
        "docstring": null,
        "code": "def list_commands(self, ctx: Context) -> list[str]:\n        rv: set[str] = set(super().list_commands(ctx))\n\n        for source in self.sources:\n            rv.update(source.list_commands(ctx))\n\n        return sorted(rv)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "param_decls",
            "type": "Any"
          },
          {
            "name": "type",
            "type": "Any"
          },
          {
            "name": "required",
            "type": "bool"
          },
          {
            "name": "default",
            "type": "Any"
          },
          {
            "name": "callback",
            "type": "Any"
          },
          {
            "name": "nargs",
            "type": "Any"
          },
          {
            "name": "multiple",
            "type": "bool"
          },
          {
            "name": "metavar",
            "type": "Any"
          },
          {
            "name": "expose_value",
            "type": "bool"
          },
          {
            "name": "is_eager",
            "type": "bool"
          },
          {
            "name": "envvar",
            "type": "Any"
          },
          {
            "name": "shell_complete",
            "type": "Any"
          },
          {
            "name": "deprecated",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 2120,
        "decorators": [],
        "is_async": false,
        "calls": [
          "shell_complete",
          "is_eager",
          "self._parse_decls",
          "type",
          "metavar",
          "deprecated",
          "expose_value",
          "callback",
          "required",
          "nargs",
          "envvar",
          "types.convert_type",
          "multiple",
          "self.type.arity",
          "default",
          "ValueError"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        param_decls: cabc.Sequence[str] | None = None,\n        type: types.ParamType | t.Any | None = None,\n        required: bool = False,\n        # XXX The default historically embed two concepts:\n        # - the declaration of a Parameter object carrying the default (handy to\n        #   arbitrage the default value of coupled Parameters sharing the same\n        #   self.name, like flag options),\n        # - and the actual value of the default.\n        # It is confusing and is the source of many issues discussed in:\n        # https://github.com/pallets/click/pull/3030\n        # In the future, we might think of splitting it in two, not unlike\n        # Option.is_flag and Option.flag_value: we could have something like\n        # Parameter.is_default and Parameter.default_value.\n        default: t.Any | t.Callable[[], t.Any] | None = UNSET,\n        callback: t.Callable[[Context, Parameter, t.Any], t.Any] | None = None,\n        nargs: int | None = None,\n        multiple: bool = False,\n        metavar: str | None = None,\n        expose_value: bool = True,\n        is_eager: bool = False,\n        envvar: str | cabc.Sequence[str] | None = None,\n        shell_complete: t.Callable[\n            [Context, Parameter, str], list[CompletionItem] | list[str]\n        ]\n        | None = None,\n        deprecated: bool | str = False,\n    ) -> None:\n        self.name: str | None\n        self.opts: list[str]\n        self.secondary_opts: list[str]\n        self.name, self.opts, self.secondary_opts = self._parse_decls(\n            param_decls or (), expose_value\n        )\n        self.type: types.ParamType = types.convert_type(type, default)\n\n        # Default nargs to what the type tells us if we have that\n        # information available.\n        if nargs is None:\n            if self.type.is_composite:\n                nargs = self.type.arity\n            else:\n                nargs = 1\n\n        self.required = required\n        self.callback = callback\n        self.nargs = nargs\n        self.multiple = multiple\n        self.expose_value = expose_value\n        self.default: t.Any | t.Callable[[], t.Any] | None = default\n        self.is_eager = is_eager\n        self.metavar = metavar\n        self.envvar = envvar\n        self._custom_shell_complete = shell_complete\n        self.deprecated = deprecated\n\n        if __debug__:\n            if self.type.is_composite and nargs != self.type.arity:\n                raise ValueError(\n                    f\"'nargs' must be {self.type.arity} (or None) for\"\n                    f\" type {self.type!r}, but it was {nargs}.\"\n                )\n\n            if required and deprecated:\n                raise ValueError(\n                    f\"The {self.param_type_name} '{self.human_readable_name}' \"\n                    \"is deprecated and still required. A deprecated \"\n                    f\"{self.param_type_name} cannot be required.\"\n                )",
        "line_count": 70,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 2191,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.type.to_info_dict"
        ],
        "docstring": "Gather information that could be useful for a tool generating\nuser-facing documentation.\n\nUse :meth:`click.Context.to_info_dict` to traverse the entire\nCLI structure.\n\n.. versionchanged:: 8.3.0\n    Returns ``None`` for the :attr:`default` if it was not set.\n\n.. versionadded:: 8.0",
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        \"\"\"Gather information that could be useful for a tool generating\n        user-facing documentation.\n\n        Use :meth:`click.Context.to_info_dict` to traverse the entire\n        CLI structure.\n\n        .. versionchanged:: 8.3.0\n            Returns ``None`` for the :attr:`default` if it was not set.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"param_type_name\": self.param_type_name,\n            \"opts\": self.opts,\n            \"secondary_opts\": self.secondary_opts,\n            \"type\": self.type.to_info_dict(),\n            \"required\": self.required,\n            \"nargs\": self.nargs,\n            \"multiple\": self.multiple,\n            # We explicitly hide the :attr:`UNSET` value to the user, as we choose to\n            # make it an implementation detail. And because ``to_info_dict`` has been\n            # designed for documentation purposes, we return ``None`` instead.\n            \"default\": self.default if self.default is not UNSET else None,\n            \"envvar\": self.envvar,\n        }",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 2219,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} {self.name}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_parse_decls",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "decls",
            "type": "cabc.Sequence[str]"
          },
          {
            "name": "expose_value",
            "type": "bool"
          }
        ],
        "return_type": "tuple[Any, list[str], list[str]]",
        "lineno": 2222,
        "decorators": [],
        "is_async": false,
        "calls": [
          "NotImplementedError"
        ],
        "docstring": null,
        "code": "def _parse_decls(\n        self, decls: cabc.Sequence[str], expose_value: bool\n    ) -> tuple[str | None, list[str], list[str]]:\n        raise NotImplementedError()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "human_readable_name",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 2228,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Returns the human readable name of this parameter.  This is the\nsame as the name for options, but the metavar for arguments.",
        "code": "def human_readable_name(self) -> str:\n        \"\"\"Returns the human readable name of this parameter.  This is the\n        same as the name for options, but the metavar for arguments.\n        \"\"\"\n        return self.name",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "make_metavar",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "str",
        "lineno": 2234,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "self.type.name.upper",
          "self",
          "self.type.get_metavar"
        ],
        "docstring": null,
        "code": "def make_metavar(self, ctx: Context) -> str:\n        if self.metavar is not None:\n            return self.metavar\n\n        metavar = self.type.get_metavar(param=self, ctx=ctx)\n\n        if metavar is None:\n            metavar = self.type.name.upper()\n\n        if self.nargs != 1:\n            metavar += \"...\"\n\n        return metavar",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "get_default",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "call",
            "type": "t.Literal[True]"
          }
        ],
        "return_type": "Any",
        "lineno": 2249,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_default(\n        self, ctx: Context, call: t.Literal[True] = True\n    ) -> t.Any | None: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get_default",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "call",
            "type": "bool"
          }
        ],
        "return_type": "Any",
        "lineno": 2254,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_default(\n        self, ctx: Context, call: bool = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get_default",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "call",
            "type": "bool"
          }
        ],
        "return_type": "Any",
        "lineno": 2258,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.lookup_default",
          "value",
          "self.name",
          "self.default",
          "callable"
        ],
        "docstring": "Get the default for the parameter. Tries\n:meth:`Context.lookup_default` first, then the local default.\n\n:param ctx: Current context.\n:param call: If the default is a callable, call it. Disable to\n    return the callable instead.\n\n.. versionchanged:: 8.0.2\n    Type casting is no longer performed when getting a default.\n\n.. versionchanged:: 8.0.1\n    Type casting can fail in resilient parsing mode. Invalid\n    defaults will not prevent showing help text.\n\n.. versionchanged:: 8.0\n    Looks at ``ctx.default_map`` first.\n\n.. versionchanged:: 8.0\n    Added the ``call`` parameter.",
        "code": "def get_default(\n        self, ctx: Context, call: bool = True\n    ) -> t.Any | t.Callable[[], t.Any] | None:\n        \"\"\"Get the default for the parameter. Tries\n        :meth:`Context.lookup_default` first, then the local default.\n\n        :param ctx: Current context.\n        :param call: If the default is a callable, call it. Disable to\n            return the callable instead.\n\n        .. versionchanged:: 8.0.2\n            Type casting is no longer performed when getting a default.\n\n        .. versionchanged:: 8.0.1\n            Type casting can fail in resilient parsing mode. Invalid\n            defaults will not prevent showing help text.\n\n        .. versionchanged:: 8.0\n            Looks at ``ctx.default_map`` first.\n\n        .. versionchanged:: 8.0\n            Added the ``call`` parameter.\n        \"\"\"\n        value = ctx.lookup_default(self.name, call=False)  # type: ignore\n\n        if value is UNSET:\n            value = self.default\n\n        if call and callable(value):\n            value = value()\n\n        return value",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "add_to_parser",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "parser",
            "type": "_OptionParser"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "None",
        "lineno": 2291,
        "decorators": [],
        "is_async": false,
        "calls": [
          "NotImplementedError"
        ],
        "docstring": null,
        "code": "def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:\n        raise NotImplementedError()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "consume_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "opts",
            "type": "cabc.Mapping[str, t.Any]"
          }
        ],
        "return_type": "tuple[t.Any, ParameterSource]",
        "lineno": 2294,
        "decorators": [],
        "is_async": false,
        "calls": [
          "opts.get",
          "default_map_value",
          "UNSET",
          "self.value_from_envvar",
          "ParameterSource.ENVIRONMENT",
          "ctx.lookup_default",
          "ctx",
          "ParameterSource.DEFAULT",
          "self.name",
          "default_value",
          "self.get_default",
          "ParameterSource.DEFAULT_MAP",
          "envvar_value"
        ],
        "docstring": "Returns the parameter value produced by the parser.\n\nIf the parser did not produce a value from user input, the value is either\nsourced from the environment variable, the default map, or the parameter's\ndefault value. In that order of precedence.\n\nIf no value is found, an internal sentinel value is returned.\n\n:meta private:",
        "code": "def consume_value(\n        self, ctx: Context, opts: cabc.Mapping[str, t.Any]\n    ) -> tuple[t.Any, ParameterSource]:\n        \"\"\"Returns the parameter value produced by the parser.\n\n        If the parser did not produce a value from user input, the value is either\n        sourced from the environment variable, the default map, or the parameter's\n        default value. In that order of precedence.\n\n        If no value is found, an internal sentinel value is returned.\n\n        :meta private:\n        \"\"\"\n        # Collect from the parse the value passed by the user to the CLI.\n        value = opts.get(self.name, UNSET)  # type: ignore\n        # If the value is set, it means it was sourced from the command line by the\n        # parser, otherwise it left unset by default.\n        source = (\n            ParameterSource.COMMANDLINE\n            if value is not UNSET\n            else ParameterSource.DEFAULT\n        )\n\n        if value is UNSET:\n            envvar_value = self.value_from_envvar(ctx)\n            if envvar_value is not None:\n                value = envvar_value\n                source = ParameterSource.ENVIRONMENT\n\n        if value is UNSET:\n            default_map_value = ctx.lookup_default(self.name)  # type: ignore\n            if default_map_value is not UNSET:\n                value = default_map_value\n                source = ParameterSource.DEFAULT_MAP\n\n        if value is UNSET:\n            default_value = self.get_default(ctx)\n            if default_value is not UNSET:\n                value = default_value\n                source = ParameterSource.DEFAULT\n\n        return value, source",
        "line_count": 42,
        "needs_llm_summary": true
      },
      {
        "name": "type_cast_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 2337,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "check_iter",
          "self",
          "_check_iter",
          "value",
          "ctx",
          "convert",
          "len",
          "_",
          "ngettext",
          "self.type",
          "BadParameter",
          "self.nargs",
          "unknown.format",
          "x"
        ],
        "docstring": "Convert and validate a value against the parameter's\n:attr:`type`, :attr:`multiple`, and :attr:`nargs`.",
        "code": "def type_cast_value(self, ctx: Context, value: t.Any) -> t.Any:\n        \"\"\"Convert and validate a value against the parameter's\n        :attr:`type`, :attr:`multiple`, and :attr:`nargs`.\n        \"\"\"\n        if value is None:\n            if self.multiple or self.nargs == -1:\n                return ()\n            else:\n                return value\n\n        def check_iter(value: t.Any) -> cabc.Iterator[t.Any]:\n            try:\n                return _check_iter(value)\n            except TypeError:\n                # This should only happen when passing in args manually,\n                # the parser should construct an iterable when parsing\n                # the command line.\n                raise BadParameter(\n                    _(\"Value must be an iterable.\"), ctx=ctx, param=self\n                ) from None\n\n        # Define the conversion function based on nargs and type.\n\n        if self.nargs == 1 or self.type.is_composite:\n\n            def convert(value: t.Any) -> t.Any:\n                return self.type(value, param=self, ctx=ctx)\n\n        elif self.nargs == -1:\n\n            def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]\n                return tuple(self.type(x, self, ctx) for x in check_iter(value))\n\n        else:  # nargs > 1\n\n            def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]\n                value = tuple(check_iter(value))\n\n                if len(value) != self.nargs:\n                    raise BadParameter(\n                        ngettext(\n                            \"Takes {nargs} values but 1 was given.\",\n                            \"Takes {nargs} values but {len} were given.\",\n                            len(value),\n                        ).format(nargs=self.nargs, len=len(value)),\n                        ctx=ctx,\n                        param=self,\n                    )\n\n                return tuple(self.type(x, self, ctx) for x in value)\n\n        if self.multiple:\n            return tuple(convert(x) for x in check_iter(value))\n\n        return convert(value)",
        "line_count": 55,
        "needs_llm_summary": true
      },
      {
        "name": "value_is_missing",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "bool",
        "lineno": 2393,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "A value is considered missing if:\n\n- it is :attr:`UNSET`,\n- or if it is an empty sequence while the parameter is suppose to have\n  non-single value (i.e. :attr:`nargs` is not ``1`` or :attr:`multiple` is\n  set).\n\n:meta private:",
        "code": "def value_is_missing(self, value: t.Any) -> bool:\n        \"\"\"A value is considered missing if:\n\n        - it is :attr:`UNSET`,\n        - or if it is an empty sequence while the parameter is suppose to have\n          non-single value (i.e. :attr:`nargs` is not ``1`` or :attr:`multiple` is\n          set).\n\n        :meta private:\n        \"\"\"\n        if value is UNSET:\n            return True\n\n        if (self.nargs != 1 or self.multiple) and value == ():\n            return True\n\n        return False",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "process_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 2411,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self",
          "value",
          "ctx",
          "MissingParameter",
          "ctx.params.items",
          "self.type_cast_value",
          "self.callback",
          "self.value_is_missing",
          "unset_keys",
          "ctx.params.update"
        ],
        "docstring": "Process the value of this parameter:\n\n1. Type cast the value using :meth:`type_cast_value`.\n2. Check if the value is missing (see: :meth:`value_is_missing`), and raise\n   :exc:`MissingParameter` if it is required.\n3. If a :attr:`callback` is set, call it to have the value replaced by the\n   result of the callback. If the value was not set, the callback receive\n   ``None``. This keep the legacy behavior as it was before the introduction of\n   the :attr:`UNSET` sentinel.\n\n:meta private:",
        "code": "def process_value(self, ctx: Context, value: t.Any) -> t.Any:\n        \"\"\"Process the value of this parameter:\n\n        1. Type cast the value using :meth:`type_cast_value`.\n        2. Check if the value is missing (see: :meth:`value_is_missing`), and raise\n           :exc:`MissingParameter` if it is required.\n        3. If a :attr:`callback` is set, call it to have the value replaced by the\n           result of the callback. If the value was not set, the callback receive\n           ``None``. This keep the legacy behavior as it was before the introduction of\n           the :attr:`UNSET` sentinel.\n\n        :meta private:\n        \"\"\"\n        # shelter `type_cast_value` from ever seeing an `UNSET` value by handling the\n        # cases in which `UNSET` gets special treatment explicitly at this layer\n        #\n        # Refs:\n        # https://github.com/pallets/click/issues/3069\n        if value is UNSET:\n            if self.multiple or self.nargs == -1:\n                value = ()\n        else:\n            value = self.type_cast_value(ctx, value)\n\n        if self.required and self.value_is_missing(value):\n            raise MissingParameter(ctx=ctx, param=self)\n\n        if self.callback is not None:\n            # Legacy case: UNSET is not exposed directly to the callback, but converted\n            # to None.\n            if value is UNSET:\n                value = None\n\n            # Search for parameters with UNSET values in the context.\n            unset_keys = {k: None for k, v in ctx.params.items() if v is UNSET}\n            # No UNSET values, call the callback as usual.\n            if not unset_keys:\n                value = self.callback(ctx, self, value)\n\n            # Legacy case: provide a temporarily manipulated context to the callback\n            # to hide UNSET values as None.\n            #\n            # Refs:\n            # https://github.com/pallets/click/issues/3136\n            # https://github.com/pallets/click/pull/3137\n            else:\n                # Add another layer to the context stack to clearly hint that the\n                # context is temporarily modified.\n                with ctx:\n                    # Update the context parameters to replace UNSET with None.\n                    ctx.params.update(unset_keys)\n                    # Feed these fake context parameters to the callback.\n                    value = self.callback(ctx, self, value)\n                    # Restore the UNSET values in the context parameters.\n                    ctx.params.update(\n                        {\n                            k: UNSET\n                            for k in unset_keys\n                            # Only restore keys that are present and still None, in case\n                            # the callback modified other parameters.\n                            if k in ctx.params and ctx.params[k] is None\n                        }\n                    )\n\n        return value",
        "line_count": 65,
        "needs_llm_summary": true
      },
      {
        "name": "resolve_envvar_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 2477,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.environ.get",
          "str",
          "self.envvar",
          "envvar",
          "isinstance"
        ],
        "docstring": "Returns the value found in the environment variable(s) attached to this\nparameter.\n\nEnvironment variables values are `always returned as strings\n<https://docs.python.org/3/library/os.html#os.environ>`_.\n\nThis method returns ``None`` if:\n\n- the :attr:`envvar` property is not set on the :class:`Parameter`,\n- the environment variable is not found in the environment,\n- the variable is found in the environment but its value is empty (i.e. the\n  environment variable is present but has an empty string).\n\nIf :attr:`envvar` is setup with multiple environment variables,\nthen only the first non-empty value is returned.\n\n.. caution::\n\n    The raw value extracted from the environment is not normalized and is\n    returned as-is. Any normalization or reconciliation is performed later by\n    the :class:`Parameter`'s :attr:`type`.\n\n:meta private:",
        "code": "def resolve_envvar_value(self, ctx: Context) -> str | None:\n        \"\"\"Returns the value found in the environment variable(s) attached to this\n        parameter.\n\n        Environment variables values are `always returned as strings\n        <https://docs.python.org/3/library/os.html#os.environ>`_.\n\n        This method returns ``None`` if:\n\n        - the :attr:`envvar` property is not set on the :class:`Parameter`,\n        - the environment variable is not found in the environment,\n        - the variable is found in the environment but its value is empty (i.e. the\n          environment variable is present but has an empty string).\n\n        If :attr:`envvar` is setup with multiple environment variables,\n        then only the first non-empty value is returned.\n\n        .. caution::\n\n            The raw value extracted from the environment is not normalized and is\n            returned as-is. Any normalization or reconciliation is performed later by\n            the :class:`Parameter`'s :attr:`type`.\n\n        :meta private:\n        \"\"\"\n        if not self.envvar:\n            return None\n\n        if isinstance(self.envvar, str):\n            rv = os.environ.get(self.envvar)\n\n            if rv:\n                return rv\n        else:\n            for envvar in self.envvar:\n                rv = os.environ.get(envvar)\n\n                # Return the first non-empty value of the list of environment variables.\n                if rv:\n                    return rv\n                # Else, absence of value is interpreted as an environment variable that\n                # is not set, so proceed to the next one.\n\n        return None",
        "line_count": 44,
        "needs_llm_summary": true
      },
      {
        "name": "value_from_envvar",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 2522,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "self.resolve_envvar_value",
          "rv",
          "self.type.split_envvar_value"
        ],
        "docstring": "Process the raw environment variable string for this parameter.\n\nReturns the string as-is or splits it into a sequence of strings if the\nparameter is expecting multiple values (i.e. its :attr:`nargs` property is set\nto a value other than ``1``).\n\n:meta private:",
        "code": "def value_from_envvar(self, ctx: Context) -> str | cabc.Sequence[str] | None:\n        \"\"\"Process the raw environment variable string for this parameter.\n\n        Returns the string as-is or splits it into a sequence of strings if the\n        parameter is expecting multiple values (i.e. its :attr:`nargs` property is set\n        to a value other than ``1``).\n\n        :meta private:\n        \"\"\"\n        rv = self.resolve_envvar_value(ctx)\n\n        if rv is not None and self.nargs != 1:\n            return self.type.split_envvar_value(rv)\n\n        return rv",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "handle_parse_result",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "opts",
            "type": "cabc.Mapping[str, t.Any]"
          },
          {
            "name": "args",
            "type": "list[str]"
          }
        ],
        "return_type": "tuple[t.Any, list[str]]",
        "lineno": 2538,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "message",
          "ctx",
          "opts",
          "isinstance",
          "style",
          "unknown.format",
          "self.consume_value",
          "self.human_readable_name",
          "self.param_type_name",
          "self",
          "self.process_value",
          "self.name",
          "_",
          "augment_usage_errors",
          "UNSET",
          "source",
          "str",
          "extra_message",
          "value",
          "ctx.set_parameter_source",
          "self.deprecated"
        ],
        "docstring": "Process the value produced by the parser from user input.\n\nAlways process the value through the Parameter's :attr:`type`, wherever it\ncomes from.\n\nIf the parameter is deprecated, this method warn the user about it. But only if\nthe value has been explicitly set by the user (and as such, is not coming from\na default).\n\n:meta private:",
        "code": "def handle_parse_result(\n        self, ctx: Context, opts: cabc.Mapping[str, t.Any], args: list[str]\n    ) -> tuple[t.Any, list[str]]:\n        \"\"\"Process the value produced by the parser from user input.\n\n        Always process the value through the Parameter's :attr:`type`, wherever it\n        comes from.\n\n        If the parameter is deprecated, this method warn the user about it. But only if\n        the value has been explicitly set by the user (and as such, is not coming from\n        a default).\n\n        :meta private:\n        \"\"\"\n        with augment_usage_errors(ctx, param=self):\n            value, source = self.consume_value(ctx, opts)\n\n            ctx.set_parameter_source(self.name, source)  # type: ignore\n\n            # Display a deprecation warning if necessary.\n            if (\n                self.deprecated\n                and value is not UNSET\n                and source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)\n            ):\n                extra_message = (\n                    f\" {self.deprecated}\" if isinstance(self.deprecated, str) else \"\"\n                )\n                message = _(\n                    \"DeprecationWarning: The {param_type} {name!r} is deprecated.\"\n                    \"{extra_message}\"\n                ).format(\n                    param_type=self.param_type_name,\n                    name=self.human_readable_name,\n                    extra_message=extra_message,\n                )\n                echo(style(message, fg=\"red\"), err=True)\n\n            # Process the value through the parameter's type.\n            try:\n                value = self.process_value(ctx, value)\n            except Exception:\n                if not ctx.resilient_parsing:\n                    raise\n                # In resilient parsing mode, we do not want to fail the command if the\n                # value is incompatible with the parameter type, so we reset the value\n                # to UNSET, which will be interpreted as a missing value.\n                value = UNSET\n\n        # Add parameter's value to the context.\n        if (\n            self.expose_value\n            # We skip adding the value if it was previously set by another parameter\n            # targeting the same variable name. This prevents parameters competing for\n            # the same name to override each other.\n            and (self.name not in ctx.params or ctx.params[self.name] is UNSET)\n        ):\n            # Click is logically enforcing that the name is None if the parameter is\n            # not to be exposed. We still assert it here to please the type checker.\n            assert self.name is not None, (\n                f\"{self!r} parameter's name should not be None when exposing value.\"\n            )\n            ctx.params[self.name] = value\n\n        return value, args",
        "line_count": 65,
        "needs_llm_summary": true
      },
      {
        "name": "get_help_record",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 2604,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_help_record(self, ctx: Context) -> tuple[str, str] | None:\n        pass",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "get_usage_pieces",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "list[str]",
        "lineno": 2607,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_usage_pieces(self, ctx: Context) -> list[str]:\n        return []",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "get_error_hint",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "str",
        "lineno": 2610,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join"
        ],
        "docstring": "Get a stringified version of the param for use in error messages to\nindicate which param caused the error.",
        "code": "def get_error_hint(self, ctx: Context) -> str:\n        \"\"\"Get a stringified version of the param for use in error messages to\n        indicate which param caused the error.\n        \"\"\"\n        hint_list = self.opts or [self.human_readable_name]\n        return \" / \".join(f\"'{x}'\" for x in hint_list)",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "shell_complete",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "list[CompletionItem]",
        "lineno": 2617,
        "decorators": [],
        "is_async": false,
        "calls": [
          "c",
          "incomplete",
          "self",
          "ctx",
          "str",
          "t.cast",
          "self.type.shell_complete",
          "self._custom_shell_complete",
          "isinstance",
          "CompletionItem",
          "results"
        ],
        "docstring": "Return a list of completions for the incomplete value. If a\n``shell_complete`` function was given during init, it is used.\nOtherwise, the :attr:`type`\n:meth:`~click.types.ParamType.shell_complete` function is used.\n\n:param ctx: Invocation context for this command.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
        "code": "def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of completions for the incomplete value. If a\n        ``shell_complete`` function was given during init, it is used.\n        Otherwise, the :attr:`type`\n        :meth:`~click.types.ParamType.shell_complete` function is used.\n\n        :param ctx: Invocation context for this command.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        if self._custom_shell_complete is not None:\n            results = self._custom_shell_complete(ctx, self, incomplete)\n\n            if results and isinstance(results[0], str):\n                from click.shell_completion import CompletionItem\n\n                results = [CompletionItem(c) for c in results]\n\n            return t.cast(\"list[CompletionItem]\", results)\n\n        return self.type.shell_complete(ctx, self, incomplete)",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "param_decls",
            "type": "Any"
          },
          {
            "name": "show_default",
            "type": "Any"
          },
          {
            "name": "prompt",
            "type": "Any"
          },
          {
            "name": "confirmation_prompt",
            "type": "Any"
          },
          {
            "name": "prompt_required",
            "type": "bool"
          },
          {
            "name": "hide_input",
            "type": "bool"
          },
          {
            "name": "is_flag",
            "type": "Any"
          },
          {
            "name": "flag_value",
            "type": "t.Any"
          },
          {
            "name": "multiple",
            "type": "bool"
          },
          {
            "name": "count",
            "type": "bool"
          },
          {
            "name": "allow_from_autoenv",
            "type": "bool"
          },
          {
            "name": "type",
            "type": "Any"
          },
          {
            "name": "help",
            "type": "Any"
          },
          {
            "name": "hidden",
            "type": "bool"
          },
          {
            "name": "show_choices",
            "type": "bool"
          },
          {
            "name": "show_envvar",
            "type": "bool"
          },
          {
            "name": "deprecated",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 2709,
        "decorators": [],
        "is_async": false,
        "calls": [
          "confirmation_prompt",
          "prompt_required",
          "type",
          "unknown.__init__",
          "hide_input",
          "self.name.replace",
          "count",
          "TypeError",
          "isinstance",
          "attrs",
          "show_envvar",
          "allow_from_autoenv",
          "ValueError",
          "types.IntRange",
          "deprecated",
          "flag_value",
          "prompt_text",
          "show_choices",
          "inspect.cleandoc",
          "hidden",
          "types.BoolParamType",
          "str",
          "unknown.capitalize",
          "help",
          "show_default",
          "multiple",
          "bool",
          "self.flag_value",
          "is_flag",
          "prompt",
          "types.convert_type",
          "self.type",
          "super",
          "param_decls"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        param_decls: cabc.Sequence[str] | None = None,\n        show_default: bool | str | None = None,\n        prompt: bool | str = False,\n        confirmation_prompt: bool | str = False,\n        prompt_required: bool = True,\n        hide_input: bool = False,\n        is_flag: bool | None = None,\n        flag_value: t.Any = UNSET,\n        multiple: bool = False,\n        count: bool = False,\n        allow_from_autoenv: bool = True,\n        type: types.ParamType | t.Any | None = None,\n        help: str | None = None,\n        hidden: bool = False,\n        show_choices: bool = True,\n        show_envvar: bool = False,\n        deprecated: bool | str = False,\n        **attrs: t.Any,\n    ) -> None:\n        if help:\n            help = inspect.cleandoc(help)\n\n        super().__init__(\n            param_decls, type=type, multiple=multiple, deprecated=deprecated, **attrs\n        )\n\n        if prompt is True:\n            if self.name is None:\n                raise TypeError(\"'name' is required with 'prompt=True'.\")\n\n            prompt_text: str | None = self.name.replace(\"_\", \" \").capitalize()\n        elif prompt is False:\n            prompt_text = None\n        else:\n            prompt_text = prompt\n\n        if deprecated:\n            deprecated_message = (\n                f\"(DEPRECATED: {deprecated})\"\n                if isinstance(deprecated, str)\n                else \"(DEPRECATED)\"\n            )\n            help = help + deprecated_message if help is not None else deprecated_message\n\n        self.prompt = prompt_text\n        self.confirmation_prompt = confirmation_prompt\n        self.prompt_required = prompt_required\n        self.hide_input = hide_input\n        self.hidden = hidden\n\n        # The _flag_needs_value property tells the parser that this option is a flag\n        # that cannot be used standalone and needs a value. With this information, the\n        # parser can determine whether to consider the next user-provided argument in\n        # the CLI as a value for this flag or as a new option.\n        # If prompt is enabled but not required, then it opens the possibility for the\n        # option to gets its value from the user.\n        self._flag_needs_value = self.prompt is not None and not self.prompt_required\n\n        # Auto-detect if this is a flag or not.\n        if is_flag is None:\n            # Implicitly a flag because flag_value was set.\n            if flag_value is not UNSET:\n                is_flag = True\n            # Not a flag, but when used as a flag it shows a prompt.\n            elif self._flag_needs_value:\n                is_flag = False\n            # Implicitly a flag because secondary options names were given.\n            elif self.secondary_opts:\n                is_flag = True\n\n        # The option is explicitly not a flag, but to determine whether or not it needs\n        # value, we need to check if `flag_value` or `default` was set. Either one is\n        # sufficient.\n        # Ref: https://github.com/pallets/click/issues/3084\n        elif is_flag is False and not self._flag_needs_value:\n            self._flag_needs_value = flag_value is not UNSET or self.default is UNSET\n\n        if is_flag:\n            # Set missing default for flags if not explicitly required or prompted.\n            if self.default is UNSET and not self.required and not self.prompt:\n                if multiple:\n                    self.default = ()\n\n            # Auto-detect the type of the flag based on the flag_value.\n            if type is None:\n                # A flag without a flag_value is a boolean flag.\n                if flag_value is UNSET:\n                    self.type: types.ParamType = types.BoolParamType()\n                # If the flag value is a boolean, use BoolParamType.\n                elif isinstance(flag_value, bool):\n                    self.type = types.BoolParamType()\n                # Otherwise, guess the type from the flag value.\n                else:\n                    self.type = types.convert_type(None, flag_value)\n\n        self.is_flag: bool = bool(is_flag)\n        self.is_bool_flag: bool = bool(\n            is_flag and isinstance(self.type, types.BoolParamType)\n        )\n        self.flag_value: t.Any = flag_value\n\n        # Set boolean flag default to False if unset and not required.\n        if self.is_bool_flag:\n            if self.default is UNSET and not self.required:\n                self.default = False\n\n        # Support the special case of aligning the default value with the flag_value\n        # for flags whose default is explicitly set to True. Note that as long as we\n        # have this condition, there is no way a flag can have a default set to True,\n        # and a flag_value set to something else. Refs:\n        # https://github.com/pallets/click/issues/3024#issuecomment-3146199461\n        # https://github.com/pallets/click/pull/3030/commits/06847da\n        if self.default is True and self.flag_value is not UNSET:\n            self.default = self.flag_value\n\n        # Set the default flag_value if it is not set.\n        if self.flag_value is UNSET:\n            if self.is_flag:\n                self.flag_value = True\n            else:\n                self.flag_value = None\n\n        # Counting.\n        self.count = count\n        if count:\n            if type is None:\n                self.type = types.IntRange(min=0)\n            if self.default is UNSET:\n                self.default = 0\n\n        self.allow_from_autoenv = allow_from_autoenv\n        self.help = help\n        self.show_default = show_default\n        self.show_choices = show_choices\n        self.show_envvar = show_envvar\n\n        if __debug__:\n            if deprecated and prompt:\n                raise ValueError(\"`deprecated` options cannot use `prompt`.\")\n\n            if self.nargs == -1:\n                raise TypeError(\"nargs=-1 is not supported for options.\")\n\n            if not self.is_bool_flag and self.secondary_opts:\n                raise TypeError(\"Secondary flag is not valid for non-boolean flag.\")\n\n            if self.is_bool_flag and self.hide_input and self.prompt is not None:\n                raise TypeError(\n                    \"'prompt' with 'hide_input' is not valid for boolean flag.\"\n                )\n\n            if self.count:\n                if self.multiple:\n                    raise TypeError(\"'count' is not valid with 'multiple'.\")\n\n                if self.is_flag:\n                    raise TypeError(\"'count' is not valid with 'is_flag'.\")",
        "line_count": 159,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 2869,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.is_flag",
          "self.help",
          "unknown.to_info_dict",
          "self.count",
          "self.hidden",
          "super",
          "info_dict.update",
          "self.prompt"
        ],
        "docstring": ".. versionchanged:: 8.3.0\n    Returns ``None`` for the :attr:`flag_value` if it was not set.",
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        \"\"\"\n        .. versionchanged:: 8.3.0\n            Returns ``None`` for the :attr:`flag_value` if it was not set.\n        \"\"\"\n        info_dict = super().to_info_dict()\n        info_dict.update(\n            help=self.help,\n            prompt=self.prompt,\n            is_flag=self.is_flag,\n            # We explicitly hide the :attr:`UNSET` value to the user, as we choose to\n            # make it an implementation detail. And because ``to_info_dict`` has been\n            # designed for documentation purposes, we return ``None`` instead.\n            flag_value=self.flag_value if self.flag_value is not UNSET else None,\n            count=self.count,\n            hidden=self.hidden,\n        )\n        return info_dict",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "get_error_hint",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "str",
        "lineno": 2888,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "super",
          "unknown.get_error_hint"
        ],
        "docstring": null,
        "code": "def get_error_hint(self, ctx: Context) -> str:\n        result = super().get_error_hint(ctx)\n        if self.show_envvar and self.envvar is not None:\n            result += f\" (env var: '{self.envvar}')\"\n        return result",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "_parse_decls",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "decls",
            "type": "cabc.Sequence[str]"
          },
          {
            "name": "expose_value",
            "type": "bool"
          }
        ],
        "return_type": "tuple[Any, list[str], list[str]]",
        "lineno": 2894,
        "decorators": [],
        "is_async": false,
        "calls": [
          "possible_names.sort",
          "name.isidentifier",
          "opts.append",
          "possible_names.append",
          "decl.split",
          "unknown.lower",
          "len",
          "second.lstrip",
          "decl.isidentifier",
          "decl",
          "TypeError",
          "first.rstrip",
          "unknown.replace",
          "secondary_opts.append",
          "_split_opt",
          "split_char",
          "ValueError",
          "first"
        ],
        "docstring": null,
        "code": "def _parse_decls(\n        self, decls: cabc.Sequence[str], expose_value: bool\n    ) -> tuple[str | None, list[str], list[str]]:\n        opts = []\n        secondary_opts = []\n        name = None\n        possible_names = []\n\n        for decl in decls:\n            if decl.isidentifier():\n                if name is not None:\n                    raise TypeError(f\"Name '{name}' defined twice\")\n                name = decl\n            else:\n                split_char = \";\" if decl[:1] == \"/\" else \"/\"\n                if split_char in decl:\n                    first, second = decl.split(split_char, 1)\n                    first = first.rstrip()\n                    if first:\n                        possible_names.append(_split_opt(first))\n                        opts.append(first)\n                    second = second.lstrip()\n                    if second:\n                        secondary_opts.append(second.lstrip())\n                    if first == second:\n                        raise ValueError(\n                            f\"Boolean option {decl!r} cannot use the\"\n                            \" same flag for true/false.\"\n                        )\n                else:\n                    possible_names.append(_split_opt(decl))\n                    opts.append(decl)\n\n        if name is None and possible_names:\n            possible_names.sort(key=lambda x: -len(x[0]))  # group long options first\n            name = possible_names[0][1].replace(\"-\", \"_\").lower()\n            if not name.isidentifier():\n                name = None\n\n        if name is None:\n            if not expose_value:\n                return None, opts, secondary_opts\n            raise TypeError(\n                f\"Could not determine name for option with declarations {decls!r}\"\n            )\n\n        if not opts and not secondary_opts:\n            raise TypeError(\n                f\"No options defined but a name was passed ({name}).\"\n                \" Did you mean to declare an argument instead? Did\"\n                f\" you mean to pass '--{name}'?\"\n            )\n\n        return name, opts, secondary_opts",
        "line_count": 54,
        "needs_llm_summary": true
      },
      {
        "name": "add_to_parser",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "parser",
            "type": "_OptionParser"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "None",
        "lineno": 2949,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.nargs",
          "self",
          "self.opts",
          "parser.add_option",
          "self.name",
          "self.secondary_opts",
          "action",
          "self.flag_value"
        ],
        "docstring": null,
        "code": "def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:\n        if self.multiple:\n            action = \"append\"\n        elif self.count:\n            action = \"count\"\n        else:\n            action = \"store\"\n\n        if self.is_flag:\n            action = f\"{action}_const\"\n\n            if self.is_bool_flag and self.secondary_opts:\n                parser.add_option(\n                    obj=self, opts=self.opts, dest=self.name, action=action, const=True\n                )\n                parser.add_option(\n                    obj=self,\n                    opts=self.secondary_opts,\n                    dest=self.name,\n                    action=action,\n                    const=False,\n                )\n            else:\n                parser.add_option(\n                    obj=self,\n                    opts=self.opts,\n                    dest=self.name,\n                    action=action,\n                    const=self.flag_value,\n                )\n        else:\n            parser.add_option(\n                obj=self,\n                opts=self.opts,\n                dest=self.name,\n                action=action,\n                nargs=self.nargs,\n            )",
        "line_count": 38,
        "needs_llm_summary": true
      },
      {
        "name": "get_help_record",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 2988,
        "decorators": [],
        "is_async": false,
        "calls": [
          "extra_items.append",
          "extra_items",
          "unknown.join",
          "self.get_help_extra",
          "ctx",
          "self.opts",
          "join_options",
          "rv",
          "self.make_metavar",
          "rv.append",
          "opts",
          "_",
          "self.secondary_opts",
          "unknown.format",
          "_write_opts"
        ],
        "docstring": null,
        "code": "def get_help_record(self, ctx: Context) -> tuple[str, str] | None:\n        if self.hidden:\n            return None\n\n        any_prefix_is_slash = False\n\n        def _write_opts(opts: cabc.Sequence[str]) -> str:\n            nonlocal any_prefix_is_slash\n\n            rv, any_slashes = join_options(opts)\n\n            if any_slashes:\n                any_prefix_is_slash = True\n\n            if not self.is_flag and not self.count:\n                rv += f\" {self.make_metavar(ctx=ctx)}\"\n\n            return rv\n\n        rv = [_write_opts(self.opts)]\n\n        if self.secondary_opts:\n            rv.append(_write_opts(self.secondary_opts))\n\n        help = self.help or \"\"\n\n        extra = self.get_help_extra(ctx)\n        extra_items = []\n        if \"envvars\" in extra:\n            extra_items.append(\n                _(\"env var: {var}\").format(var=\", \".join(extra[\"envvars\"]))\n            )\n        if \"default\" in extra:\n            extra_items.append(_(\"default: {default}\").format(default=extra[\"default\"]))\n        if \"range\" in extra:\n            extra_items.append(extra[\"range\"])\n        if \"required\" in extra:\n            extra_items.append(_(extra[\"required\"]))\n\n        if extra_items:\n            extra_str = \"; \".join(extra_items)\n            help = f\"{help}  [{extra_str}]\" if help else f\"[{extra_str}]\"\n\n        return (\"; \" if any_prefix_is_slash else \" / \").join(rv), help",
        "line_count": 44,
        "needs_llm_summary": true
      },
      {
        "name": "get_help_extra",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "types.OptionHelpExtra",
        "lineno": 3033,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.show_default",
          "ctx",
          "self.envvar",
          "envvar",
          "isinstance",
          "default_value.name",
          "tuple",
          "self.show_default",
          "ctx.resilient_parsing",
          "_",
          "self.get_default",
          "_split_opt",
          "enum.Enum",
          "types._NumberRangeBase",
          "resilient",
          "str",
          "default_string",
          "self.type._describe_range",
          "range_str",
          "inspect.isfunction",
          "d",
          "default_value",
          "self.name.upper",
          "unknown.join",
          "self.type"
        ],
        "docstring": null,
        "code": "def get_help_extra(self, ctx: Context) -> types.OptionHelpExtra:\n        extra: types.OptionHelpExtra = {}\n\n        if self.show_envvar:\n            envvar = self.envvar\n\n            if envvar is None:\n                if (\n                    self.allow_from_autoenv\n                    and ctx.auto_envvar_prefix is not None\n                    and self.name is not None\n                ):\n                    envvar = f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"\n\n            if envvar is not None:\n                if isinstance(envvar, str):\n                    extra[\"envvars\"] = (envvar,)\n                else:\n                    extra[\"envvars\"] = tuple(str(d) for d in envvar)\n\n        # Temporarily enable resilient parsing to avoid type casting\n        # failing for the default. Might be possible to extend this to\n        # help formatting in general.\n        resilient = ctx.resilient_parsing\n        ctx.resilient_parsing = True\n\n        try:\n            default_value = self.get_default(ctx, call=False)\n        finally:\n            ctx.resilient_parsing = resilient\n\n        show_default = False\n        show_default_is_str = False\n\n        if self.show_default is not None:\n            if isinstance(self.show_default, str):\n                show_default_is_str = show_default = True\n            else:\n                show_default = self.show_default\n        elif ctx.show_default is not None:\n            show_default = ctx.show_default\n\n        if show_default_is_str or (\n            show_default and (default_value not in (None, UNSET))\n        ):\n            if show_default_is_str:\n                default_string = f\"({self.show_default})\"\n            elif isinstance(default_value, (list, tuple)):\n                default_string = \", \".join(str(d) for d in default_value)\n            elif isinstance(default_value, enum.Enum):\n                default_string = default_value.name\n            elif inspect.isfunction(default_value):\n                default_string = _(\"(dynamic)\")\n            elif self.is_bool_flag and self.secondary_opts:\n                # For boolean flags that have distinct True/False opts,\n                # use the opt without prefix instead of the value.\n                default_string = _split_opt(\n                    (self.opts if default_value else self.secondary_opts)[0]\n                )[1]\n            elif self.is_bool_flag and not self.secondary_opts and not default_value:\n                default_string = \"\"\n            elif default_value == \"\":\n                default_string = '\"\"'\n            else:\n                default_string = str(default_value)\n\n            if default_string:\n                extra[\"default\"] = default_string\n\n        if (\n            isinstance(self.type, types._NumberRangeBase)\n            # skip count with default range type\n            and not (self.count and self.type.min == 0 and self.type.max is None)\n        ):\n            range_str = self.type._describe_range()\n\n            if range_str:\n                extra[\"range\"] = range_str\n\n        if self.required:\n            extra[\"required\"] = \"required\"\n\n        return extra",
        "line_count": 83,
        "needs_llm_summary": true
      },
      {
        "name": "prompt_for_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "t.Any",
        "lineno": 3117,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.show_default",
          "self.hide_input",
          "confirm",
          "ctx",
          "self.confirmation_prompt",
          "self.process_value",
          "prompt",
          "isinstance",
          "self.type",
          "self.get_default",
          "bool",
          "self.show_choices",
          "default",
          "prompt_kwargs",
          "x",
          "self.prompt"
        ],
        "docstring": "This is an alternative flow that can be activated in the full\nvalue processing if a value does not exist.  It will prompt the\nuser until a valid value exists and then returns the processed\nvalue as result.",
        "code": "def prompt_for_value(self, ctx: Context) -> t.Any:\n        \"\"\"This is an alternative flow that can be activated in the full\n        value processing if a value does not exist.  It will prompt the\n        user until a valid value exists and then returns the processed\n        value as result.\n        \"\"\"\n        assert self.prompt is not None\n\n        # Calculate the default before prompting anything to lock in the value before\n        # attempting any user interaction.\n        default = self.get_default(ctx)\n\n        # A boolean flag can use a simplified [y/n] confirmation prompt.\n        if self.is_bool_flag:\n            # If we have no boolean default, we force the user to explicitly provide\n            # one.\n            if default in (UNSET, None):\n                default = None\n            # Nothing prevent you to declare an option that is simultaneously:\n            # 1) auto-detected as a boolean flag,\n            # 2) allowed to prompt, and\n            # 3) still declare a non-boolean default.\n            # This forced casting into a boolean is necessary to align any non-boolean\n            # default to the prompt, which is going to be a [y/n]-style confirmation\n            # because the option is still a boolean flag. That way, instead of [y/n],\n            # we get [Y/n] or [y/N] depending on the truthy value of the default.\n            # Refs: https://github.com/pallets/click/pull/3030#discussion_r2289180249\n            else:\n                default = bool(default)\n            return confirm(self.prompt, default)\n\n        # If show_default is set to True/False, provide this to `prompt` as well. For\n        # non-bool values of `show_default`, we use `prompt`'s default behavior\n        prompt_kwargs: t.Any = {}\n        if isinstance(self.show_default, bool):\n            prompt_kwargs[\"show_default\"] = self.show_default\n\n        return prompt(\n            self.prompt,\n            # Use ``None`` to inform the prompt() function to reiterate until a valid\n            # value is provided by the user if we have no default.\n            default=None if default is UNSET else default,\n            type=self.type,\n            hide_input=self.hide_input,\n            show_choices=self.show_choices,\n            confirmation_prompt=self.confirmation_prompt,\n            value_proc=lambda x: self.process_value(ctx, x),\n            **prompt_kwargs,\n        )",
        "line_count": 49,
        "needs_llm_summary": true
      },
      {
        "name": "resolve_envvar_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 3167,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.environ.get",
          "ctx",
          "envvar",
          "unknown.resolve_envvar_value",
          "super",
          "self.name.upper"
        ],
        "docstring": ":class:`Option` resolves its environment variable the same way as\n:func:`Parameter.resolve_envvar_value`, but it also supports\n:attr:`Context.auto_envvar_prefix`. If we could not find an environment from\nthe :attr:`envvar` property, we fallback on :attr:`Context.auto_envvar_prefix`\nto build dynamiccaly the environment variable name using the\n:python:`{ctx.auto_envvar_prefix}_{self.name.upper()}` template.\n\n:meta private:",
        "code": "def resolve_envvar_value(self, ctx: Context) -> str | None:\n        \"\"\":class:`Option` resolves its environment variable the same way as\n        :func:`Parameter.resolve_envvar_value`, but it also supports\n        :attr:`Context.auto_envvar_prefix`. If we could not find an environment from\n        the :attr:`envvar` property, we fallback on :attr:`Context.auto_envvar_prefix`\n        to build dynamiccaly the environment variable name using the\n        :python:`{ctx.auto_envvar_prefix}_{self.name.upper()}` template.\n\n        :meta private:\n        \"\"\"\n        rv = super().resolve_envvar_value(ctx)\n\n        if rv is not None:\n            return rv\n\n        if (\n            self.allow_from_autoenv\n            and ctx.auto_envvar_prefix is not None\n            and self.name is not None\n        ):\n            envvar = f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"\n            rv = os.environ.get(envvar)\n\n            if rv:\n                return rv\n\n        return None",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "value_from_envvar",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "t.Any",
        "lineno": 3195,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "types.BoolParamType.str_to_bool",
          "self.resolve_envvar_value",
          "rv",
          "multi_rv",
          "self.multiple",
          "self.type.split_envvar_value",
          "bool",
          "batch",
          "self.nargs"
        ],
        "docstring": "For :class:`Option`, this method processes the raw environment variable\nstring the same way as :func:`Parameter.value_from_envvar` does.\n\nBut in the case of non-boolean flags, the value is analyzed to determine if the\nflag is activated or not, and returns a boolean of its activation, or the\n:attr:`flag_value` if the latter is set.\n\nThis method also takes care of repeated options (i.e. options with\n:attr:`multiple` set to ``True``).\n\n:meta private:",
        "code": "def value_from_envvar(self, ctx: Context) -> t.Any:\n        \"\"\"For :class:`Option`, this method processes the raw environment variable\n        string the same way as :func:`Parameter.value_from_envvar` does.\n\n        But in the case of non-boolean flags, the value is analyzed to determine if the\n        flag is activated or not, and returns a boolean of its activation, or the\n        :attr:`flag_value` if the latter is set.\n\n        This method also takes care of repeated options (i.e. options with\n        :attr:`multiple` set to ``True``).\n\n        :meta private:\n        \"\"\"\n        rv = self.resolve_envvar_value(ctx)\n\n        # Absent environment variable or an empty string is interpreted as unset.\n        if rv is None:\n            return None\n\n        # Non-boolean flags are more liberal in what they accept. But a flag being a\n        # flag, its envvar value still needs to be analyzed to determine if the flag is\n        # activated or not.\n        if self.is_flag and not self.is_bool_flag:\n            # If the flag_value is set and match the envvar value, return it\n            # directly.\n            if self.flag_value is not UNSET and rv == self.flag_value:\n                return self.flag_value\n            # Analyze the envvar value as a boolean to know if the flag is\n            # activated or not.\n            return types.BoolParamType.str_to_bool(rv)\n\n        # Split the envvar value if it is allowed to be repeated.\n        value_depth = (self.nargs != 1) + bool(self.multiple)\n        if value_depth > 0:\n            multi_rv = self.type.split_envvar_value(rv)\n            if self.multiple and self.nargs != 1:\n                multi_rv = batch(multi_rv, self.nargs)  # type: ignore[assignment]\n\n            return multi_rv\n\n        return rv",
        "line_count": 41,
        "needs_llm_summary": true
      },
      {
        "name": "consume_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "opts",
            "type": "cabc.Mapping[str, Parameter]"
          }
        ],
        "return_type": "tuple[t.Any, ParameterSource]",
        "lineno": 3237,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ParameterSource.PROMPT",
          "ctx",
          "any",
          "opts",
          "ParameterSource.COMMANDLINE",
          "self.prompt_for_value",
          "super",
          "unknown.consume_value",
          "self.flag_value"
        ],
        "docstring": "For :class:`Option`, the value can be collected from an interactive prompt\nif the option is a flag that needs a value (and the :attr:`prompt` property is\nset).\n\nAdditionally, this method handles flag option that are activated without a\nvalue, in which case the :attr:`flag_value` is returned.\n\n:meta private:",
        "code": "def consume_value(\n        self, ctx: Context, opts: cabc.Mapping[str, Parameter]\n    ) -> tuple[t.Any, ParameterSource]:\n        \"\"\"For :class:`Option`, the value can be collected from an interactive prompt\n        if the option is a flag that needs a value (and the :attr:`prompt` property is\n        set).\n\n        Additionally, this method handles flag option that are activated without a\n        value, in which case the :attr:`flag_value` is returned.\n\n        :meta private:\n        \"\"\"\n        value, source = super().consume_value(ctx, opts)\n\n        # The parser will emit a sentinel value if the option is allowed to as a flag\n        # without a value.\n        if value is FLAG_NEEDS_VALUE:\n            # If the option allows for a prompt, we start an interaction with the user.\n            if self.prompt is not None and not ctx.resilient_parsing:\n                value = self.prompt_for_value(ctx)\n                source = ParameterSource.PROMPT\n            # Else the flag takes its flag_value as value.\n            else:\n                value = self.flag_value\n                source = ParameterSource.COMMANDLINE\n\n        # A flag which is activated always returns the flag value, unless the value\n        # comes from the explicitly sets default.\n        elif (\n            self.is_flag\n            and value is True\n            and not self.is_bool_flag\n            and source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)\n        ):\n            value = self.flag_value\n\n        # Re-interpret a multiple option which has been sent as-is by the parser.\n        # Here we replace each occurrence of value-less flags (marked by the\n        # FLAG_NEEDS_VALUE sentinel) with the flag_value.\n        elif (\n            self.multiple\n            and value is not UNSET\n            and source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)\n            and any(v is FLAG_NEEDS_VALUE for v in value)\n        ):\n            value = [self.flag_value if v is FLAG_NEEDS_VALUE else v for v in value]\n            source = ParameterSource.COMMANDLINE\n\n        # The value wasn't set, or used the param's default, prompt for one to the user\n        # if prompting is enabled.\n        elif (\n            (\n                value is UNSET\n                or source in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)\n            )\n            and self.prompt is not None\n            and (self.required or self.prompt_required)\n            and not ctx.resilient_parsing\n        ):\n            value = self.prompt_for_value(ctx)\n            source = ParameterSource.PROMPT\n\n        return value, source",
        "line_count": 63,
        "needs_llm_summary": true
      },
      {
        "name": "process_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 3301,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.process_value",
          "self",
          "value",
          "ctx",
          "self.callback",
          "super"
        ],
        "docstring": null,
        "code": "def process_value(self, ctx: Context, value: t.Any) -> t.Any:\n        # process_value has to be overridden on Options in order to capture\n        # `value == UNSET` cases before `type_cast_value()` gets called.\n        #\n        # Refs:\n        # https://github.com/pallets/click/issues/3069\n        if self.is_flag and not self.required and self.is_bool_flag and value is UNSET:\n            value = False\n\n            if self.callback is not None:\n                value = self.callback(ctx, self, value)\n\n            return value\n\n        # in the normal case, rely on Parameter.process_value\n        return super().process_value(ctx, value)",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "param_decls",
            "type": "cabc.Sequence[str]"
          },
          {
            "name": "required",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 3329,
        "decorators": [],
        "is_async": false,
        "calls": [
          "UNSET",
          "unknown.__init__",
          "required",
          "TypeError",
          "attrs.get",
          "attrs",
          "super",
          "param_decls"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        param_decls: cabc.Sequence[str],\n        required: bool | None = None,\n        **attrs: t.Any,\n    ) -> None:\n        # Auto-detect the requirement status of the argument if not explicitly set.\n        if required is None:\n            # The argument gets automatically required if it has no explicit default\n            # value set and is setup to match at least one value.\n            if attrs.get(\"default\", UNSET) is UNSET:\n                required = attrs.get(\"nargs\", 1) > 0\n            # If the argument has a default value, it is not required.\n            else:\n                required = False\n\n        if \"multiple\" in attrs:\n            raise TypeError(\"__init__() got an unexpected keyword argument 'multiple'.\")\n\n        super().__init__(param_decls, required=required, **attrs)",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "human_readable_name",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 3351,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.name.upper"
        ],
        "docstring": null,
        "code": "def human_readable_name(self) -> str:\n        if self.metavar is not None:\n            return self.metavar\n        return self.name.upper()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "make_metavar",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "str",
        "lineno": 3356,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "self.name.upper",
          "self",
          "self.type.get_metavar"
        ],
        "docstring": null,
        "code": "def make_metavar(self, ctx: Context) -> str:\n        if self.metavar is not None:\n            return self.metavar\n        var = self.type.get_metavar(param=self, ctx=ctx)\n        if not var:\n            var = self.name.upper()  # type: ignore\n        if self.deprecated:\n            var += \"!\"\n        if not self.required:\n            var = f\"[{var}]\"\n        if self.nargs != 1:\n            var += \"...\"\n        return var",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "_parse_decls",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "decls",
            "type": "cabc.Sequence[str]"
          },
          {
            "name": "expose_value",
            "type": "bool"
          }
        ],
        "return_type": "tuple[Any, list[str], list[str]]",
        "lineno": 3370,
        "decorators": [],
        "is_async": false,
        "calls": [
          "len",
          "decls",
          "unknown.lower",
          "TypeError",
          "name.replace"
        ],
        "docstring": null,
        "code": "def _parse_decls(\n        self, decls: cabc.Sequence[str], expose_value: bool\n    ) -> tuple[str | None, list[str], list[str]]:\n        if not decls:\n            if not expose_value:\n                return None, [], []\n            raise TypeError(\"Argument is marked as exposed, but does not have a name.\")\n        if len(decls) == 1:\n            name = arg = decls[0]\n            name = name.replace(\"-\", \"_\").lower()\n        else:\n            raise TypeError(\n                \"Arguments take exactly one parameter declaration, got\"\n                f\" {len(decls)}: {decls}.\"\n            )\n        return name, [arg], []",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "get_usage_pieces",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "list[str]",
        "lineno": 3387,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.make_metavar",
          "ctx"
        ],
        "docstring": null,
        "code": "def get_usage_pieces(self, ctx: Context) -> list[str]:\n        return [self.make_metavar(ctx)]",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "get_error_hint",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "str",
        "lineno": 3390,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.make_metavar",
          "ctx"
        ],
        "docstring": null,
        "code": "def get_error_hint(self, ctx: Context) -> str:\n        return f\"'{self.make_metavar(ctx)}'\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "add_to_parser",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "parser",
            "type": "_OptionParser"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "None",
        "lineno": 3393,
        "decorators": [],
        "is_async": false,
        "calls": [
          "parser.add_argument",
          "self.nargs",
          "self.name",
          "self"
        ],
        "docstring": null,
        "code": "def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:\n        parser.add_argument(dest=self.name, nargs=self.nargs, obj=self)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "f",
            "type": "t.Callable[Ellipsis, t.Any]"
          }
        ],
        "return_type": "Command",
        "lineno": 1671,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.add_command",
          "command",
          "f",
          "kwargs",
          "cmd"
        ],
        "docstring": null,
        "code": "def decorator(f: t.Callable[..., t.Any]) -> Command:\n            cmd: Command = command(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return cmd",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "f",
            "type": "t.Callable[Ellipsis, t.Any]"
          }
        ],
        "return_type": "Group",
        "lineno": 1723,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.add_command",
          "group",
          "f",
          "kwargs",
          "cmd"
        ],
        "docstring": null,
        "code": "def decorator(f: t.Callable[..., t.Any]) -> Group:\n            cmd: Group = group(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return cmd",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "f",
            "type": "F"
          }
        ],
        "return_type": "F",
        "lineno": 1762,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value",
          "old_callback",
          "f",
          "t.cast",
          "function",
          "update_wrapper",
          "kwargs",
          "inner",
          "F",
          "self._result_callback"
        ],
        "docstring": null,
        "code": "def decorator(f: F) -> F:\n            old_callback = self._result_callback\n\n            if old_callback is None or replace:\n                self._result_callback = f\n                return f\n\n            def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n                inner = old_callback(value, *args, **kwargs)\n                return f(inner, *args, **kwargs)\n\n            self._result_callback = rv = update_wrapper(t.cast(F, function), f)\n            return rv",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "_process_result",
        "args": [
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 1840,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value",
          "ctx.params",
          "ctx.invoke",
          "self._result_callback"
        ],
        "docstring": null,
        "code": "def _process_result(value: t.Any) -> t.Any:\n            if self._result_callback is not None:\n                value = ctx.invoke(self._result_callback, value, **ctx.params)\n            return value",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "check_iter",
        "args": [
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "cabc.Iterator[t.Any]",
        "lineno": 2347,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self",
          "value",
          "ctx",
          "_check_iter",
          "_",
          "BadParameter"
        ],
        "docstring": null,
        "code": "def check_iter(value: t.Any) -> cabc.Iterator[t.Any]:\n            try:\n                return _check_iter(value)\n            except TypeError:\n                # This should only happen when passing in args manually,\n                # the parser should construct an iterable when parsing\n                # the command line.\n                raise BadParameter(\n                    _(\"Value must be an iterable.\"), ctx=ctx, param=self\n                ) from None",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "_write_opts",
        "args": [
          {
            "name": "opts",
            "type": "cabc.Sequence[str]"
          }
        ],
        "return_type": "str",
        "lineno": 2994,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.make_metavar",
          "join_options",
          "ctx",
          "opts"
        ],
        "docstring": null,
        "code": "def _write_opts(opts: cabc.Sequence[str]) -> str:\n            nonlocal any_prefix_is_slash\n\n            rv, any_slashes = join_options(opts)\n\n            if any_slashes:\n                any_prefix_is_slash = True\n\n            if not self.is_flag and not self.count:\n                rv += f\" {self.make_metavar(ctx=ctx)}\"\n\n            return rv",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "function",
        "args": [],
        "return_type": "t.Any",
        "lineno": 1769,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value",
          "old_callback",
          "f",
          "kwargs",
          "inner"
        ],
        "docstring": null,
        "code": "def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n                inner = old_callback(value, *args, **kwargs)\n                return f(inner, *args, **kwargs)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 2362,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "self.type",
          "self",
          "value"
        ],
        "docstring": null,
        "code": "def convert(value: t.Any) -> t.Any:\n                return self.type(value, param=self, ctx=ctx)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 2367,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "check_iter",
          "self",
          "value",
          "ctx",
          "self.type",
          "x"
        ],
        "docstring": null,
        "code": "def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]\n                return tuple(self.type(x, self, ctx) for x in check_iter(value))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 2372,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "check_iter",
          "self",
          "value",
          "ctx",
          "len",
          "ngettext",
          "self.type",
          "BadParameter",
          "self.nargs",
          "unknown.format",
          "x"
        ],
        "docstring": null,
        "code": "def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]\n                value = tuple(check_iter(value))\n\n                if len(value) != self.nargs:\n                    raise BadParameter(\n                        ngettext(\n                            \"Takes {nargs} values but 1 was given.\",\n                            \"Takes {nargs} values but {len} were given.\",\n                            len(value),\n                        ).format(nargs=self.nargs, len=len(value)),\n                        ctx=ctx,\n                        param=self,\n                    )\n\n                return tuple(self.type(x, self, ctx) for x in value)",
        "line_count": 15,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ParameterSource",
        "methods": [],
        "base_classes": [
          "enum.Enum"
        ],
        "lineno": 143,
        "docstring": "This is an :class:`~enum.Enum` that indicates the source of a\nparameter's value.\n\nUse :meth:`click.Context.get_parameter_source` to get the\nsource for a parameter by name.\n\n.. versionchanged:: 8.0\n    Use :class:`~enum.Enum` and drop the ``validate`` method.\n\n.. versionchanged:: 8.0\n    Added the ``PROMPT`` value."
      },
      {
        "name": "Context",
        "methods": [
          "__init__",
          "protected_args",
          "to_info_dict",
          "__enter__",
          "__exit__",
          "scope",
          "meta",
          "make_formatter",
          "with_resource",
          "call_on_close",
          "close",
          "_close_with_exception_info",
          "command_path",
          "find_root",
          "find_object",
          "ensure_object",
          "lookup_default",
          "lookup_default",
          "lookup_default",
          "fail",
          "abort",
          "exit",
          "get_usage",
          "get_help",
          "_make_sub_context",
          "invoke",
          "invoke",
          "invoke",
          "forward",
          "set_parameter_source",
          "get_parameter_source"
        ],
        "base_classes": [],
        "lineno": 169,
        "docstring": "The context is a special internal object that holds state relevant\nfor the script execution at every single level.  It's normally invisible\nto commands unless they opt-in to getting access to it.\n\nThe context is useful as it can pass internal objects around and can\ncontrol special execution features such as reading data from\nenvironment variables.\n\nA context can be used as context manager in which case it will call\n:meth:`close` on teardown.\n\n:param command: the command class for this context.\n:param parent: the parent context.\n:param info_name: the info name for this invocation.  Generally this\n                  is the most descriptive name for the script or\n                  command.  For the toplevel script it is usually\n                  the name of the script, for commands below it it's\n                  the name of the script.\n:param obj: an arbitrary object of user data.\n:param auto_envvar_prefix: the prefix to use for automatic environment\n                           variables.  If this is `None` then reading\n                           from environment variables is disabled.  This\n                           does not affect manually set environment\n                           variables which are always read.\n:param default_map: a dictionary (like object) with default values\n                    for parameters.\n:param terminal_width: the width of the terminal.  The default is\n                       inherit from parent context.  If no context\n                       defines the terminal width then auto\n                       detection will be applied.\n:param max_content_width: the maximum width for content rendered by\n                          Click (this currently only affects help\n                          pages).  This defaults to 80 characters if\n                          not overridden.  In other words: even if the\n                          terminal is larger than that, Click will not\n                          format things wider than 80 characters by\n                          default.  In addition to that, formatters might\n                          add some safety mapping on the right.\n:param resilient_parsing: if this flag is enabled then Click will\n                          parse without any interactivity or callback\n                          invocation.  Default values will also be\n                          ignored.  This is useful for implementing\n                          things such as completion support.\n:param allow_extra_args: if this is set to `True` then extra arguments\n                         at the end will not raise an error and will be\n                         kept on the context.  The default is to inherit\n                         from the command.\n:param allow_interspersed_args: if this is set to `False` then options\n                                and arguments cannot be mixed.  The\n                                default is to inherit from the command.\n:param ignore_unknown_options: instructs click to ignore options it does\n                               not know and keeps them for later\n                               processing.\n:param help_option_names: optionally a list of strings that define how\n                          the default help parameter is named.  The\n                          default is ``['--help']``.\n:param token_normalize_func: an optional function that is used to\n                             normalize tokens (options, choices,\n                             etc.).  This for instance can be used to\n                             implement case insensitive behavior.\n:param color: controls if the terminal supports ANSI colors or not.  The\n              default is autodetection.  This is only needed if ANSI\n              codes are used in texts that Click prints which is by\n              default not the case.  This for instance would affect\n              help output.\n:param show_default: Show the default value for commands. If this\n    value is not set, it defaults to the value from the parent\n    context. ``Command.show_default`` overrides this default for the\n    specific command.\n\n.. versionchanged:: 8.2\n    The ``protected_args`` attribute is deprecated and will be removed in\n    Click 9.0. ``args`` will contain remaining unparsed tokens.\n\n.. versionchanged:: 8.1\n    The ``show_default`` parameter is overridden by\n    ``Command.show_default``, instead of the other way around.\n\n.. versionchanged:: 8.0\n    The ``show_default`` parameter defaults to the value from the\n    parent context.\n\n.. versionchanged:: 7.1\n   Added the ``show_default`` parameter.\n\n.. versionchanged:: 4.0\n    Added the ``color``, ``ignore_unknown_options``, and\n    ``max_content_width`` parameters.\n\n.. versionchanged:: 3.0\n    Added the ``allow_extra_args`` and ``allow_interspersed_args``\n    parameters.\n\n.. versionchanged:: 2.0\n    Added the ``resilient_parsing``, ``help_option_names``, and\n    ``token_normalize_func`` parameters."
      },
      {
        "name": "Command",
        "methods": [
          "__init__",
          "to_info_dict",
          "__repr__",
          "get_usage",
          "get_params",
          "format_usage",
          "collect_usage_pieces",
          "get_help_option_names",
          "get_help_option",
          "make_parser",
          "get_help",
          "get_short_help_str",
          "format_help",
          "format_help_text",
          "format_options",
          "format_epilog",
          "make_context",
          "parse_args",
          "invoke",
          "shell_complete",
          "main",
          "main",
          "main",
          "_main_shell_completion",
          "__call__"
        ],
        "base_classes": [],
        "lineno": 873,
        "docstring": "Commands are the basic building block of command line interfaces in\nClick.  A basic command handles command line parsing and might dispatch\nmore parsing to commands nested below it.\n\n:param name: the name of the command to use unless a group overrides it.\n:param context_settings: an optional dictionary with defaults that are\n                         passed to the context object.\n:param callback: the callback to invoke.  This is optional.\n:param params: the parameters to register with this command.  This can\n               be either :class:`Option` or :class:`Argument` objects.\n:param help: the help string to use for this command.\n:param epilog: like the help string but it's printed at the end of the\n               help page after everything else.\n:param short_help: the short help to use for this command.  This is\n                   shown on the command listing of the parent command.\n:param add_help_option: by default each command registers a ``--help``\n                        option.  This can be disabled by this parameter.\n:param no_args_is_help: this controls what happens if no arguments are\n                        provided.  This option is disabled by default.\n                        If enabled this will add ``--help`` as argument\n                        if no arguments are passed\n:param hidden: hide this command from help outputs.\n:param deprecated: If ``True`` or non-empty string, issues a message\n                    indicating that the command is deprecated and highlights\n                    its deprecation in --help. The message can be customized\n                    by using a string as the value.\n\n.. versionchanged:: 8.2\n    This is the base class for all commands, not ``BaseCommand``.\n    ``deprecated`` can be set to a string as well to customize the\n    deprecation message.\n\n.. versionchanged:: 8.1\n    ``help``, ``epilog``, and ``short_help`` are stored unprocessed,\n    all formatting is done when outputting help text, not at init,\n    and is done even if not using the ``@command`` decorator.\n\n.. versionchanged:: 8.0\n    Added a ``repr`` showing the command name.\n\n.. versionchanged:: 7.1\n    Added the ``no_args_is_help`` parameter.\n\n.. versionchanged:: 2.0\n    Added the ``context_settings`` parameter."
      },
      {
        "name": "_FakeSubclassCheck",
        "methods": [
          "__subclasscheck__",
          "__instancecheck__"
        ],
        "base_classes": [
          "type"
        ],
        "lineno": 1488,
        "docstring": null
      },
      {
        "name": "_BaseCommand",
        "methods": [],
        "base_classes": [
          "Command"
        ],
        "lineno": 1496,
        "docstring": ".. deprecated:: 8.2\n    Will be removed in Click 9.0. Use ``Command`` instead."
      },
      {
        "name": "Group",
        "methods": [
          "__init__",
          "to_info_dict",
          "add_command",
          "command",
          "command",
          "command",
          "group",
          "group",
          "group",
          "result_callback",
          "get_command",
          "list_commands",
          "collect_usage_pieces",
          "format_options",
          "format_commands",
          "parse_args",
          "invoke",
          "resolve_command",
          "shell_complete"
        ],
        "base_classes": [
          "Command"
        ],
        "lineno": 1503,
        "docstring": "A group is a command that nests other commands (or more groups).\n\n:param name: The name of the group command.\n:param commands: Map names to :class:`Command` objects. Can be a list, which\n    will use :attr:`Command.name` as the keys.\n:param invoke_without_command: Invoke the group's callback even if a\n    subcommand is not given.\n:param no_args_is_help: If no arguments are given, show the group's help and\n    exit. Defaults to the opposite of ``invoke_without_command``.\n:param subcommand_metavar: How to represent the subcommand argument in help.\n    The default will represent whether ``chain`` is set or not.\n:param chain: Allow passing more than one subcommand argument. After parsing\n    a command's arguments, if any arguments remain another command will be\n    matched, and so on.\n:param result_callback: A function to call after the group's and\n    subcommand's callbacks. The value returned by the subcommand is passed.\n    If ``chain`` is enabled, the value will be a list of values returned by\n    all the commands. If ``invoke_without_command`` is enabled, the value\n    will be the value returned by the group's callback, or an empty list if\n    ``chain`` is enabled.\n:param kwargs: Other arguments passed to :class:`Command`.\n\n.. versionchanged:: 8.0\n    The ``commands`` argument can be a list of command objects.\n\n.. versionchanged:: 8.2\n    Merged with and replaces the ``MultiCommand`` base class."
      },
      {
        "name": "_MultiCommand",
        "methods": [],
        "base_classes": [
          "Group"
        ],
        "lineno": 1954,
        "docstring": ".. deprecated:: 8.2\n    Will be removed in Click 9.0. Use ``Group`` instead."
      },
      {
        "name": "CommandCollection",
        "methods": [
          "__init__",
          "add_source",
          "get_command",
          "list_commands"
        ],
        "base_classes": [
          "Group"
        ],
        "lineno": 1961,
        "docstring": "A :class:`Group` that looks up subcommands on other groups. If a command\nis not found on this group, each registered source is checked in order.\nParameters on a source are not added to this group, and a source's callback\nis not invoked when invoking its commands. In other words, this \"flattens\"\ncommands in many groups into this one group.\n\n:param name: The name of the group command.\n:param sources: A list of :class:`Group` objects to look up commands from.\n:param kwargs: Other arguments passed to :class:`Group`.\n\n.. versionchanged:: 8.2\n    This is a subclass of ``Group``. Commands are looked up first on this\n    group, then each of its sources."
      },
      {
        "name": "Parameter",
        "methods": [
          "__init__",
          "to_info_dict",
          "__repr__",
          "_parse_decls",
          "human_readable_name",
          "make_metavar",
          "get_default",
          "get_default",
          "get_default",
          "add_to_parser",
          "consume_value",
          "type_cast_value",
          "value_is_missing",
          "process_value",
          "resolve_envvar_value",
          "value_from_envvar",
          "handle_parse_result",
          "get_help_record",
          "get_usage_pieces",
          "get_error_hint",
          "shell_complete"
        ],
        "base_classes": [],
        "lineno": 2027,
        "docstring": "A parameter to a command comes in two versions: they are either\n:class:`Option`\\s or :class:`Argument`\\s.  Other subclasses are currently\nnot supported by design as some of the internals for parsing are\nintentionally not finalized.\n\nSome settings are supported by both options and arguments.\n\n:param param_decls: the parameter declarations for this option or\n                    argument.  This is a list of flags or argument\n                    names.\n:param type: the type that should be used.  Either a :class:`ParamType`\n             or a Python type.  The latter is converted into the former\n             automatically if supported.\n:param required: controls if this is optional or not.\n:param default: the default value if omitted.  This can also be a callable,\n                in which case it's invoked when the default is needed\n                without any arguments.\n:param callback: A function to further process or validate the value\n    after type conversion. It is called as ``f(ctx, param, value)``\n    and must return the value. It is called for all sources,\n    including prompts.\n:param nargs: the number of arguments to match.  If not ``1`` the return\n              value is a tuple instead of single value.  The default for\n              nargs is ``1`` (except if the type is a tuple, then it's\n              the arity of the tuple). If ``nargs=-1``, all remaining\n              parameters are collected.\n:param metavar: how the value is represented in the help page.\n:param expose_value: if this is `True` then the value is passed onwards\n                     to the command callback and stored on the context,\n                     otherwise it's skipped.\n:param is_eager: eager values are processed before non eager ones.  This\n                 should not be set for arguments or it will inverse the\n                 order of processing.\n:param envvar: environment variable(s) that are used to provide a default value for\n    this parameter. This can be a string or a sequence of strings. If a sequence is\n    given, only the first non-empty environment variable is used for the parameter.\n:param shell_complete: A function that returns custom shell\n    completions. Used instead of the param's type completion if\n    given. Takes ``ctx, param, incomplete`` and must return a list\n    of :class:`~click.shell_completion.CompletionItem` or a list of\n    strings.\n:param deprecated: If ``True`` or non-empty string, issues a message\n                    indicating that the argument is deprecated and highlights\n                    its deprecation in --help. The message can be customized\n                    by using a string as the value. A deprecated parameter\n                    cannot be required, a ValueError will be raised otherwise.\n\n.. versionchanged:: 8.2.0\n    Introduction of ``deprecated``.\n\n.. versionchanged:: 8.2\n    Adding duplicate parameter names to a :class:`~click.core.Command` will\n    result in a ``UserWarning`` being shown.\n\n.. versionchanged:: 8.2\n    Adding duplicate parameter names to a :class:`~click.core.Command` will\n    result in a ``UserWarning`` being shown.\n\n.. versionchanged:: 8.0\n    ``process_value`` validates required parameters and bounded\n    ``nargs``, and invokes the parameter callback before returning\n    the value. This allows the callback to validate prompts.\n    ``full_process_value`` is removed.\n\n.. versionchanged:: 8.0\n    ``autocompletion`` is renamed to ``shell_complete`` and has new\n    semantics described above. The old name is deprecated and will\n    be removed in 8.1, until then it will be wrapped to match the\n    new requirements.\n\n.. versionchanged:: 8.0\n    For ``multiple=True, nargs>1``, the default must be a list of\n    tuples.\n\n.. versionchanged:: 8.0\n    Setting a default is no longer required for ``nargs>1``, it will\n    default to ``None``. ``multiple=True`` or ``nargs=-1`` will\n    default to ``()``.\n\n.. versionchanged:: 7.1\n    Empty environment variables are ignored rather than taking the\n    empty string value. This makes it possible for scripts to clear\n    variables if they can't unset them.\n\n.. versionchanged:: 2.0\n    Changed signature for parameter callback to also be passed the\n    parameter. The old callback format will still work, but it will\n    raise a warning to give you a chance to migrate the code easier."
      },
      {
        "name": "Option",
        "methods": [
          "__init__",
          "to_info_dict",
          "get_error_hint",
          "_parse_decls",
          "add_to_parser",
          "get_help_record",
          "get_help_extra",
          "prompt_for_value",
          "resolve_envvar_value",
          "value_from_envvar",
          "consume_value",
          "process_value"
        ],
        "base_classes": [
          "Parameter"
        ],
        "lineno": 2641,
        "docstring": "Options are usually optional values on the command line and\nhave some extra features that arguments don't have.\n\nAll other parameters are passed onwards to the parameter constructor.\n\n:param show_default: Show the default value for this option in its\n    help text. Values are not shown by default, unless\n    :attr:`Context.show_default` is ``True``. If this value is a\n    string, it shows that string in parentheses instead of the\n    actual value. This is particularly useful for dynamic options.\n    For single option boolean flags, the default remains hidden if\n    its value is ``False``.\n:param show_envvar: Controls if an environment variable should be\n    shown on the help page and error messages.\n    Normally, environment variables are not shown.\n:param prompt: If set to ``True`` or a non empty string then the\n    user will be prompted for input. If set to ``True`` the prompt\n    will be the option name capitalized. A deprecated option cannot be\n    prompted.\n:param confirmation_prompt: Prompt a second time to confirm the\n    value if it was prompted for. Can be set to a string instead of\n    ``True`` to customize the message.\n:param prompt_required: If set to ``False``, the user will be\n    prompted for input only when the option was specified as a flag\n    without a value.\n:param hide_input: If this is ``True`` then the input on the prompt\n    will be hidden from the user. This is useful for password input.\n:param is_flag: forces this option to act as a flag.  The default is\n                auto detection.\n:param flag_value: which value should be used for this flag if it's\n                   enabled.  This is set to a boolean automatically if\n                   the option string contains a slash to mark two options.\n:param multiple: if this is set to `True` then the argument is accepted\n                 multiple times and recorded.  This is similar to ``nargs``\n                 in how it works but supports arbitrary number of\n                 arguments.\n:param count: this flag makes an option increment an integer.\n:param allow_from_autoenv: if this is enabled then the value of this\n                           parameter will be pulled from an environment\n                           variable in case a prefix is defined on the\n                           context.\n:param help: the help string.\n:param hidden: hide this option from help outputs.\n:param attrs: Other command arguments described in :class:`Parameter`.\n\n.. versionchanged:: 8.2\n    ``envvar`` used with ``flag_value`` will always use the ``flag_value``,\n    previously it would use the value of the environment variable.\n\n.. versionchanged:: 8.1\n    Help text indentation is cleaned here instead of only in the\n    ``@option`` decorator.\n\n.. versionchanged:: 8.1\n    The ``show_default`` parameter overrides\n    ``Context.show_default``.\n\n.. versionchanged:: 8.1\n    The default of a single option boolean flag is not shown if the\n    default value is ``False``.\n\n.. versionchanged:: 8.0.1\n    ``type`` is detected from ``flag_value`` if given."
      },
      {
        "name": "Argument",
        "methods": [
          "__init__",
          "human_readable_name",
          "make_metavar",
          "_parse_decls",
          "get_usage_pieces",
          "get_error_hint",
          "add_to_parser"
        ],
        "base_classes": [
          "Parameter"
        ],
        "lineno": 3319,
        "docstring": "Arguments are positional parameters to a command.  They generally\nprovide fewer features than options but can have infinite ``nargs``\nand are required by default.\n\nAll parameters are passed onwards to the constructor of :class:`Parameter`."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "enum",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "errno",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "inspect",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 8,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 9,
        "type": "import"
      },
      {
        "module": "collections",
        "name": "abc",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "collections",
        "name": "Counter",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "contextlib",
        "name": "AbstractContextManager",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "contextlib",
        "name": "contextmanager",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "contextlib",
        "name": "ExitStack",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "functools",
        "name": "update_wrapper",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "ngettext",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "itertools",
        "name": "repeat",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "types",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "_utils",
        "name": "FLAG_NEEDS_VALUE",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "_utils",
        "name": "UNSET",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "Abort",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "BadParameter",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "ClickException",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "Exit",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "MissingParameter",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "NoArgsIsHelpError",
        "alias": null,
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "UsageError",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "formatting",
        "name": "HelpFormatter",
        "alias": null,
        "lineno": 31,
        "type": "from_import"
      },
      {
        "module": "formatting",
        "name": "join_options",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "globals",
        "name": "pop_context",
        "alias": null,
        "lineno": 33,
        "type": "from_import"
      },
      {
        "module": "globals",
        "name": "push_context",
        "alias": null,
        "lineno": 34,
        "type": "from_import"
      },
      {
        "module": "parser",
        "name": "_OptionParser",
        "alias": null,
        "lineno": 35,
        "type": "from_import"
      },
      {
        "module": "parser",
        "name": "_split_opt",
        "alias": null,
        "lineno": 36,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "confirm",
        "alias": null,
        "lineno": 37,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "prompt",
        "alias": null,
        "lineno": 38,
        "type": "from_import"
      },
      {
        "module": "termui",
        "name": "style",
        "alias": null,
        "lineno": 39,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "_detect_program_name",
        "alias": null,
        "lineno": 40,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "_expand_args",
        "alias": null,
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "echo",
        "alias": null,
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "make_default_short_help",
        "alias": null,
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "make_str",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "PacifyFlushWrapper",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 48,
        "type": "from_import"
      },
      {
        "module": "warnings",
        "alias": null,
        "lineno": 3398,
        "type": "import"
      },
      {
        "module": "warnings",
        "alias": null,
        "lineno": 445,
        "type": "import"
      },
      {
        "module": "click.shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 1283,
        "type": "from_import"
      },
      {
        "module": "shell_completion",
        "name": "shell_complete",
        "alias": null,
        "lineno": 1478,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "command",
        "alias": null,
        "lineno": 1657,
        "type": "from_import"
      },
      {
        "module": "decorators",
        "name": "group",
        "alias": null,
        "lineno": 1706,
        "type": "from_import"
      },
      {
        "module": "click.shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 1944,
        "type": "from_import"
      },
      {
        "module": "warnings",
        "alias": null,
        "lineno": 1010,
        "type": "import"
      },
      {
        "module": "decorators",
        "name": "help_option",
        "alias": null,
        "lineno": 1073,
        "type": "from_import"
      },
      {
        "module": "click.shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 2632,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "F",
        "assigned_to": "t.TypeVar",
        "lineno": 50
      },
      {
        "name": "V",
        "assigned_to": "t.TypeVar",
        "lineno": 51
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "t.TypeVar"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "contextlib",
        "sys",
        "functools",
        "typing",
        "os",
        "enum",
        "collections",
        "warnings",
        "itertools"
      ],
      "third_party": {
        "other": [
          "__future__",
          "errno",
          "inspect",
          "gettext",
          "types",
          "_utils",
          "exceptions",
          "formatting",
          "globals",
          "parser",
          "termui",
          "utils",
          "shell_completion",
          "click",
          "decorators"
        ]
      },
      "tech_stack": []
    },
    "line_count": 3419
  },
  "src/click/decorators.py": {
    "filepath": "../click/src/click/decorators.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "pass_context",
        "args": [
          {
            "name": "f",
            "type": "t.Callable[te.Concatenate[Context, P], R]"
          }
        ],
        "return_type": "t.Callable[P, R]",
        "lineno": 28,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f",
          "new_func",
          "get_current_context",
          "update_wrapper",
          "kwargs"
        ],
        "docstring": "Marks a callback as wanting to receive the current context\nobject as first argument.",
        "code": "def pass_context(f: t.Callable[te.Concatenate[Context, P], R]) -> t.Callable[P, R]:\n    \"\"\"Marks a callback as wanting to receive the current context\n    object as first argument.\n    \"\"\"\n\n    def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n        return f(get_current_context(), *args, **kwargs)\n\n    return update_wrapper(new_func, f)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "pass_obj",
        "args": [
          {
            "name": "f",
            "type": "t.Callable[te.Concatenate[T, P], R]"
          }
        ],
        "return_type": "t.Callable[P, R]",
        "lineno": 39,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f",
          "new_func",
          "get_current_context",
          "update_wrapper",
          "kwargs",
          "unknown.obj"
        ],
        "docstring": "Similar to :func:`pass_context`, but only pass the object on the\ncontext onwards (:attr:`Context.obj`).  This is useful if that object\nrepresents the state of a nested system.",
        "code": "def pass_obj(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n    \"\"\"Similar to :func:`pass_context`, but only pass the object on the\n    context onwards (:attr:`Context.obj`).  This is useful if that object\n    represents the state of a nested system.\n    \"\"\"\n\n    def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n        return f(get_current_context().obj, *args, **kwargs)\n\n    return update_wrapper(new_func, f)",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "make_pass_decorator",
        "args": [
          {
            "name": "object_type",
            "type": "type[T]"
          },
          {
            "name": "ensure",
            "type": "bool"
          }
        ],
        "return_type": "t.Callable[Any, t.Callable[P, R]]",
        "lineno": 51,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.ensure_object",
          "f",
          "new_func",
          "get_current_context",
          "ctx.find_object",
          "RuntimeError",
          "update_wrapper",
          "kwargs",
          "obj",
          "ctx.invoke",
          "object_type"
        ],
        "docstring": "Given an object type this creates a decorator that will work\nsimilar to :func:`pass_obj` but instead of passing the object of the\ncurrent context, it will find the innermost context of type\n:func:`object_type`.\n\nThis generates a decorator that works roughly like this::\n\n    from functools import update_wrapper\n\n    def decorator(f):\n        @pass_context\n        def new_func(ctx, *args, **kwargs):\n            obj = ctx.find_object(object_type)\n            return ctx.invoke(f, obj, *args, **kwargs)\n        return update_wrapper(new_func, f)\n    return decorator\n\n:param object_type: the type of the object to pass.\n:param ensure: if set to `True`, a new object will be created and\n               remembered on the context if it's not there yet.",
        "code": "def make_pass_decorator(\n    object_type: type[T], ensure: bool = False\n) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:\n    \"\"\"Given an object type this creates a decorator that will work\n    similar to :func:`pass_obj` but instead of passing the object of the\n    current context, it will find the innermost context of type\n    :func:`object_type`.\n\n    This generates a decorator that works roughly like this::\n\n        from functools import update_wrapper\n\n        def decorator(f):\n            @pass_context\n            def new_func(ctx, *args, **kwargs):\n                obj = ctx.find_object(object_type)\n                return ctx.invoke(f, obj, *args, **kwargs)\n            return update_wrapper(new_func, f)\n        return decorator\n\n    :param object_type: the type of the object to pass.\n    :param ensure: if set to `True`, a new object will be created and\n                   remembered on the context if it's not there yet.\n    \"\"\"\n\n    def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n\n            obj: T | None\n            if ensure:\n                obj = ctx.ensure_object(object_type)\n            else:\n                obj = ctx.find_object(object_type)\n\n            if obj is None:\n                raise RuntimeError(\n                    \"Managed to invoke callback without a context\"\n                    f\" object of type {object_type.__name__!r}\"\n                    \" existing.\"\n                )\n\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)\n\n    return decorator",
        "line_count": 47,
        "needs_llm_summary": true
      },
      {
        "name": "pass_meta_key",
        "args": [
          {
            "name": "key",
            "type": "str"
          }
        ],
        "return_type": "t.Callable[Any, t.Callable[P, R]]",
        "lineno": 100,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f",
          "new_func",
          "get_current_context",
          "update_wrapper",
          "kwargs",
          "obj",
          "ctx.invoke"
        ],
        "docstring": "Create a decorator that passes a key from\n:attr:`click.Context.meta` as the first argument to the decorated\nfunction.\n\n:param key: Key in ``Context.meta`` to pass.\n:param doc_description: Description of the object being passed,\n    inserted into the decorator's docstring. Defaults to \"the 'key'\n    key from Context.meta\".\n\n.. versionadded:: 8.0",
        "code": "def pass_meta_key(\n    key: str, *, doc_description: str | None = None\n) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:\n    \"\"\"Create a decorator that passes a key from\n    :attr:`click.Context.meta` as the first argument to the decorated\n    function.\n\n    :param key: Key in ``Context.meta`` to pass.\n    :param doc_description: Description of the object being passed,\n        inserted into the decorator's docstring. Defaults to \"the 'key'\n        key from Context.meta\".\n\n    .. versionadded:: 8.0\n    \"\"\"\n\n    def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n            obj = ctx.meta[key]\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)\n\n    if doc_description is None:\n        doc_description = f\"the {key!r} key from :attr:`click.Context.meta`\"\n\n    decorator.__doc__ = (\n        f\"Decorator that passes {doc_description} as the first argument\"\n        \" to the decorated function.\"\n    )\n    return decorator",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "command",
        "args": [
          {
            "name": "name",
            "type": "_AnyCallable"
          }
        ],
        "return_type": "Command",
        "lineno": 138,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def command(name: _AnyCallable) -> Command: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "command",
        "args": [
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "cls",
            "type": "type[CmdType]"
          }
        ],
        "return_type": "t.Callable[Any, CmdType]",
        "lineno": 144,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def command(\n    name: str | None,\n    cls: type[CmdType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], CmdType]: ...",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "command",
        "args": [
          {
            "name": "name",
            "type": "None"
          }
        ],
        "return_type": "t.Callable[Any, CmdType]",
        "lineno": 153,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def command(\n    name: None = None,\n    *,\n    cls: type[CmdType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], CmdType]: ...",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "command",
        "args": [
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "cls",
            "type": "None"
          }
        ],
        "return_type": "t.Callable[Any, Command]",
        "lineno": 163,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def command(\n    name: str | None = ..., cls: None = None, **attrs: t.Any\n) -> t.Callable[[_AnyCallable], Command]: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "command",
        "args": [
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "cls",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 168,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cls",
          "params.extend",
          "f",
          "TypeError",
          "isinstance",
          "attrs",
          "params",
          "Command",
          "f.__click_params__",
          "attrs.pop",
          "name",
          "func",
          "attrs.get",
          "unknown.replace",
          "f.__name__.lower",
          "cmd_name",
          "reversed",
          "cmd_left",
          "callable",
          "cmd_name.rpartition",
          "decorator",
          "f.__doc__",
          "decorator_params",
          "t.cast"
        ],
        "docstring": "Creates a new :class:`Command` and uses the decorated function as\ncallback.  This will also automatically attach all decorated\n:func:`option`\\s and :func:`argument`\\s as parameters to the command.\n\nThe name of the command defaults to the name of the function, converted to\nlowercase, with underscores ``_`` replaced by dashes ``-``, and the suffixes\n``_command``, ``_cmd``, ``_group``, and ``_grp`` are removed. For example,\n``init_data_command`` becomes ``init-data``.\n\nAll keyword arguments are forwarded to the underlying command class.\nFor the ``params`` argument, any decorated params are appended to\nthe end of the list.\n\nOnce decorated the function turns into a :class:`Command` instance\nthat can be invoked as a command line utility or be attached to a\ncommand :class:`Group`.\n\n:param name: The name of the command. Defaults to modifying the function's\n    name as described above.\n:param cls: The command class to create. Defaults to :class:`Command`.\n\n.. versionchanged:: 8.2\n    The suffixes ``_command``, ``_cmd``, ``_group``, and ``_grp`` are\n    removed when generating the name.\n\n.. versionchanged:: 8.1\n    This decorator can be applied without parentheses.\n\n.. versionchanged:: 8.1\n    The ``params`` argument can be used. Decorated params are\n    appended to the end of the list.",
        "code": "def command(\n    name: str | _AnyCallable | None = None,\n    cls: type[CmdType] | None = None,\n    **attrs: t.Any,\n) -> Command | t.Callable[[_AnyCallable], Command | CmdType]:\n    r\"\"\"Creates a new :class:`Command` and uses the decorated function as\n    callback.  This will also automatically attach all decorated\n    :func:`option`\\s and :func:`argument`\\s as parameters to the command.\n\n    The name of the command defaults to the name of the function, converted to\n    lowercase, with underscores ``_`` replaced by dashes ``-``, and the suffixes\n    ``_command``, ``_cmd``, ``_group``, and ``_grp`` are removed. For example,\n    ``init_data_command`` becomes ``init-data``.\n\n    All keyword arguments are forwarded to the underlying command class.\n    For the ``params`` argument, any decorated params are appended to\n    the end of the list.\n\n    Once decorated the function turns into a :class:`Command` instance\n    that can be invoked as a command line utility or be attached to a\n    command :class:`Group`.\n\n    :param name: The name of the command. Defaults to modifying the function's\n        name as described above.\n    :param cls: The command class to create. Defaults to :class:`Command`.\n\n    .. versionchanged:: 8.2\n        The suffixes ``_command``, ``_cmd``, ``_group``, and ``_grp`` are\n        removed when generating the name.\n\n    .. versionchanged:: 8.1\n        This decorator can be applied without parentheses.\n\n    .. versionchanged:: 8.1\n        The ``params`` argument can be used. Decorated params are\n        appended to the end of the list.\n    \"\"\"\n\n    func: t.Callable[[_AnyCallable], t.Any] | None = None\n\n    if callable(name):\n        func = name\n        name = None\n        assert cls is None, \"Use 'command(cls=cls)(callable)' to specify a class.\"\n        assert not attrs, \"Use 'command(**kwargs)(callable)' to provide arguments.\"\n\n    if cls is None:\n        cls = t.cast(\"type[CmdType]\", Command)\n\n    def decorator(f: _AnyCallable) -> CmdType:\n        if isinstance(f, Command):\n            raise TypeError(\"Attempted to convert a callback into a command twice.\")\n\n        attr_params = attrs.pop(\"params\", None)\n        params = attr_params if attr_params is not None else []\n\n        try:\n            decorator_params = f.__click_params__  # type: ignore\n        except AttributeError:\n            pass\n        else:\n            del f.__click_params__  # type: ignore\n            params.extend(reversed(decorator_params))\n\n        if attrs.get(\"help\") is None:\n            attrs[\"help\"] = f.__doc__\n\n        if t.TYPE_CHECKING:\n            assert cls is not None\n            assert not callable(name)\n\n        if name is not None:\n            cmd_name = name\n        else:\n            cmd_name = f.__name__.lower().replace(\"_\", \"-\")\n            cmd_left, sep, suffix = cmd_name.rpartition(\"-\")\n\n            if sep and suffix in {\"command\", \"cmd\", \"group\", \"grp\"}:\n                cmd_name = cmd_left\n\n        cmd = cls(name=cmd_name, callback=f, params=params, **attrs)\n        cmd.__doc__ = f.__doc__\n        return cmd\n\n    if func is not None:\n        return decorator(func)\n\n    return decorator",
        "line_count": 88,
        "needs_llm_summary": true
      },
      {
        "name": "group",
        "args": [
          {
            "name": "name",
            "type": "_AnyCallable"
          }
        ],
        "return_type": "Group",
        "lineno": 263,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def group(name: _AnyCallable) -> Group: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "group",
        "args": [
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "cls",
            "type": "type[GrpType]"
          }
        ],
        "return_type": "t.Callable[Any, GrpType]",
        "lineno": 269,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def group(\n    name: str | None,\n    cls: type[GrpType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], GrpType]: ...",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "group",
        "args": [
          {
            "name": "name",
            "type": "None"
          }
        ],
        "return_type": "t.Callable[Any, GrpType]",
        "lineno": 278,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def group(\n    name: None = None,\n    *,\n    cls: type[GrpType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], GrpType]: ...",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "group",
        "args": [
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "cls",
            "type": "None"
          }
        ],
        "return_type": "t.Callable[Any, Group]",
        "lineno": 288,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def group(\n    name: str | None = ..., cls: None = None, **attrs: t.Any\n) -> t.Callable[[_AnyCallable], Group]: ...",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "group",
        "args": [
          {
            "name": "name",
            "type": "Any"
          },
          {
            "name": "cls",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 293,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cls",
          "name",
          "command",
          "t.cast",
          "attrs",
          "callable",
          "Group"
        ],
        "docstring": "Creates a new :class:`Group` with a function as callback.  This\nworks otherwise the same as :func:`command` just that the `cls`\nparameter is set to :class:`Group`.\n\n.. versionchanged:: 8.1\n    This decorator can be applied without parentheses.",
        "code": "def group(\n    name: str | _AnyCallable | None = None,\n    cls: type[GrpType] | None = None,\n    **attrs: t.Any,\n) -> Group | t.Callable[[_AnyCallable], Group | GrpType]:\n    \"\"\"Creates a new :class:`Group` with a function as callback.  This\n    works otherwise the same as :func:`command` just that the `cls`\n    parameter is set to :class:`Group`.\n\n    .. versionchanged:: 8.1\n        This decorator can be applied without parentheses.\n    \"\"\"\n    if cls is None:\n        cls = t.cast(\"type[GrpType]\", Group)\n\n    if callable(name):\n        return command(cls=cls, **attrs)(name)\n\n    return command(name, cls, **attrs)",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "_param_memo",
        "args": [
          {
            "name": "f",
            "type": "t.Callable[Ellipsis, t.Any]"
          },
          {
            "name": "param",
            "type": "Parameter"
          }
        ],
        "return_type": "None",
        "lineno": 314,
        "decorators": [],
        "is_async": false,
        "calls": [
          "param",
          "hasattr",
          "f.__click_params__.append",
          "f",
          "isinstance",
          "f.params.append",
          "Command"
        ],
        "docstring": null,
        "code": "def _param_memo(f: t.Callable[..., t.Any], param: Parameter) -> None:\n    if isinstance(f, Command):\n        f.params.append(param)\n    else:\n        if not hasattr(f, \"__click_params__\"):\n            f.__click_params__ = []  # type: ignore\n\n        f.__click_params__.append(param)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "argument",
        "args": [],
        "return_type": "t.Callable[Any, FC]",
        "lineno": 324,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Argument",
          "cls",
          "f",
          "_param_memo",
          "attrs",
          "param_decls"
        ],
        "docstring": "Attaches an argument to the command.  All positional arguments are\npassed as parameter declarations to :class:`Argument`; all keyword\narguments are forwarded unchanged (except ``cls``).\nThis is equivalent to creating an :class:`Argument` instance manually\nand attaching it to the :attr:`Command.params` list.\n\nFor the default argument class, refer to :class:`Argument` and\n:class:`Parameter` for descriptions of parameters.\n\n:param cls: the argument class to instantiate.  This defaults to\n            :class:`Argument`.\n:param param_decls: Passed as positional arguments to the constructor of\n    ``cls``.\n:param attrs: Passed as keyword arguments to the constructor of ``cls``.",
        "code": "def argument(\n    *param_decls: str, cls: type[Argument] | None = None, **attrs: t.Any\n) -> t.Callable[[FC], FC]:\n    \"\"\"Attaches an argument to the command.  All positional arguments are\n    passed as parameter declarations to :class:`Argument`; all keyword\n    arguments are forwarded unchanged (except ``cls``).\n    This is equivalent to creating an :class:`Argument` instance manually\n    and attaching it to the :attr:`Command.params` list.\n\n    For the default argument class, refer to :class:`Argument` and\n    :class:`Parameter` for descriptions of parameters.\n\n    :param cls: the argument class to instantiate.  This defaults to\n                :class:`Argument`.\n    :param param_decls: Passed as positional arguments to the constructor of\n        ``cls``.\n    :param attrs: Passed as keyword arguments to the constructor of ``cls``.\n    \"\"\"\n    if cls is None:\n        cls = Argument\n\n    def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n        return f\n\n    return decorator",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "option",
        "args": [],
        "return_type": "t.Callable[Any, FC]",
        "lineno": 352,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cls",
          "f",
          "_param_memo",
          "attrs",
          "Option",
          "param_decls"
        ],
        "docstring": "Attaches an option to the command.  All positional arguments are\npassed as parameter declarations to :class:`Option`; all keyword\narguments are forwarded unchanged (except ``cls``).\nThis is equivalent to creating an :class:`Option` instance manually\nand attaching it to the :attr:`Command.params` list.\n\nFor the default option class, refer to :class:`Option` and\n:class:`Parameter` for descriptions of parameters.\n\n:param cls: the option class to instantiate.  This defaults to\n            :class:`Option`.\n:param param_decls: Passed as positional arguments to the constructor of\n    ``cls``.\n:param attrs: Passed as keyword arguments to the constructor of ``cls``.",
        "code": "def option(\n    *param_decls: str, cls: type[Option] | None = None, **attrs: t.Any\n) -> t.Callable[[FC], FC]:\n    \"\"\"Attaches an option to the command.  All positional arguments are\n    passed as parameter declarations to :class:`Option`; all keyword\n    arguments are forwarded unchanged (except ``cls``).\n    This is equivalent to creating an :class:`Option` instance manually\n    and attaching it to the :attr:`Command.params` list.\n\n    For the default option class, refer to :class:`Option` and\n    :class:`Parameter` for descriptions of parameters.\n\n    :param cls: the option class to instantiate.  This defaults to\n                :class:`Option`.\n    :param param_decls: Passed as positional arguments to the constructor of\n        ``cls``.\n    :param attrs: Passed as keyword arguments to the constructor of ``cls``.\n    \"\"\"\n    if cls is None:\n        cls = Option\n\n    def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n        return f\n\n    return decorator",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "confirmation_option",
        "args": [],
        "return_type": "t.Callable[Any, FC]",
        "lineno": 380,
        "decorators": [],
        "is_async": false,
        "calls": [
          "kwargs.setdefault",
          "callback",
          "option",
          "ctx.abort",
          "kwargs"
        ],
        "docstring": "Add a ``--yes`` option which shows a prompt before continuing if\nnot passed. If the prompt is declined, the program will exit.\n\n:param param_decls: One or more option names. Defaults to the single\n    value ``\"--yes\"``.\n:param kwargs: Extra arguments are passed to :func:`option`.",
        "code": "def confirmation_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:\n    \"\"\"Add a ``--yes`` option which shows a prompt before continuing if\n    not passed. If the prompt is declined, the program will exit.\n\n    :param param_decls: One or more option names. Defaults to the single\n        value ``\"--yes\"``.\n    :param kwargs: Extra arguments are passed to :func:`option`.\n    \"\"\"\n\n    def callback(ctx: Context, param: Parameter, value: bool) -> None:\n        if not value:\n            ctx.abort()\n\n    if not param_decls:\n        param_decls = (\"--yes\",)\n\n    kwargs.setdefault(\"is_flag\", True)\n    kwargs.setdefault(\"callback\", callback)\n    kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"prompt\", \"Do you want to continue?\")\n    kwargs.setdefault(\"help\", \"Confirm the action without prompting.\")\n    return option(*param_decls, **kwargs)",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "password_option",
        "args": [],
        "return_type": "t.Callable[Any, FC]",
        "lineno": 404,
        "decorators": [],
        "is_async": false,
        "calls": [
          "option",
          "kwargs.setdefault",
          "kwargs"
        ],
        "docstring": "Add a ``--password`` option which prompts for a password, hiding\ninput and asking to enter the value again for confirmation.\n\n:param param_decls: One or more option names. Defaults to the single\n    value ``\"--password\"``.\n:param kwargs: Extra arguments are passed to :func:`option`.",
        "code": "def password_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:\n    \"\"\"Add a ``--password`` option which prompts for a password, hiding\n    input and asking to enter the value again for confirmation.\n\n    :param param_decls: One or more option names. Defaults to the single\n        value ``\"--password\"``.\n    :param kwargs: Extra arguments are passed to :func:`option`.\n    \"\"\"\n    if not param_decls:\n        param_decls = (\"--password\",)\n\n    kwargs.setdefault(\"prompt\", True)\n    kwargs.setdefault(\"confirmation_prompt\", True)\n    kwargs.setdefault(\"hide_input\", True)\n    return option(*param_decls, **kwargs)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "version_option",
        "args": [
          {
            "name": "version",
            "type": "Any"
          }
        ],
        "return_type": "t.Callable[Any, FC]",
        "lineno": 421,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "importlib.metadata.version",
          "package_name.partition",
          "ctx.exit",
          "kwargs.setdefault",
          "ctx.find_root",
          "RuntimeError",
          "_",
          "callback",
          "option",
          "f_globals.get",
          "ctx.color",
          "kwargs",
          "inspect.currentframe",
          "unknown.info_name",
          "package_name"
        ],
        "docstring": "Add a ``--version`` option which immediately prints the version\nnumber and exits the program.\n\nIf ``version`` is not provided, Click will try to detect it using\n:func:`importlib.metadata.version` to get the version for the\n``package_name``.\n\nIf ``package_name`` is not provided, Click will try to detect it by\ninspecting the stack frames. This will be used to detect the\nversion, so it must match the name of the installed package.\n\n:param version: The version number to show. If not provided, Click\n    will try to detect it.\n:param param_decls: One or more option names. Defaults to the single\n    value ``\"--version\"``.\n:param package_name: The package name to detect the version from. If\n    not provided, Click will try to detect it.\n:param prog_name: The name of the CLI to show in the message. If not\n    provided, it will be detected from the command.\n:param message: The message to show. The values ``%(prog)s``,\n    ``%(package)s``, and ``%(version)s`` are available. Defaults to\n    ``\"%(prog)s, version %(version)s\"``.\n:param kwargs: Extra arguments are passed to :func:`option`.\n:raise RuntimeError: ``version`` could not be detected.\n\n.. versionchanged:: 8.0\n    Add the ``package_name`` parameter, and the ``%(package)s``\n    value for messages.\n\n.. versionchanged:: 8.0\n    Use :mod:`importlib.metadata` instead of ``pkg_resources``. The\n    version is detected based on the package name, not the entry\n    point name. The Python package name must match the installed\n    package name, or be passed with ``package_name=``.",
        "code": "def version_option(\n    version: str | None = None,\n    *param_decls: str,\n    package_name: str | None = None,\n    prog_name: str | None = None,\n    message: str | None = None,\n    **kwargs: t.Any,\n) -> t.Callable[[FC], FC]:\n    \"\"\"Add a ``--version`` option which immediately prints the version\n    number and exits the program.\n\n    If ``version`` is not provided, Click will try to detect it using\n    :func:`importlib.metadata.version` to get the version for the\n    ``package_name``.\n\n    If ``package_name`` is not provided, Click will try to detect it by\n    inspecting the stack frames. This will be used to detect the\n    version, so it must match the name of the installed package.\n\n    :param version: The version number to show. If not provided, Click\n        will try to detect it.\n    :param param_decls: One or more option names. Defaults to the single\n        value ``\"--version\"``.\n    :param package_name: The package name to detect the version from. If\n        not provided, Click will try to detect it.\n    :param prog_name: The name of the CLI to show in the message. If not\n        provided, it will be detected from the command.\n    :param message: The message to show. The values ``%(prog)s``,\n        ``%(package)s``, and ``%(version)s`` are available. Defaults to\n        ``\"%(prog)s, version %(version)s\"``.\n    :param kwargs: Extra arguments are passed to :func:`option`.\n    :raise RuntimeError: ``version`` could not be detected.\n\n    .. versionchanged:: 8.0\n        Add the ``package_name`` parameter, and the ``%(package)s``\n        value for messages.\n\n    .. versionchanged:: 8.0\n        Use :mod:`importlib.metadata` instead of ``pkg_resources``. The\n        version is detected based on the package name, not the entry\n        point name. The Python package name must match the installed\n        package name, or be passed with ``package_name=``.\n    \"\"\"\n    if message is None:\n        message = _(\"%(prog)s, version %(version)s\")\n\n    if version is None and package_name is None:\n        frame = inspect.currentframe()\n        f_back = frame.f_back if frame is not None else None\n        f_globals = f_back.f_globals if f_back is not None else None\n        # break reference cycle\n        # https://docs.python.org/3/library/inspect.html#the-interpreter-stack\n        del frame\n\n        if f_globals is not None:\n            package_name = f_globals.get(\"__name__\")\n\n            if package_name == \"__main__\":\n                package_name = f_globals.get(\"__package__\")\n\n            if package_name:\n                package_name = package_name.partition(\".\")[0]\n\n    def callback(ctx: Context, param: Parameter, value: bool) -> None:\n        if not value or ctx.resilient_parsing:\n            return\n\n        nonlocal prog_name\n        nonlocal version\n\n        if prog_name is None:\n            prog_name = ctx.find_root().info_name\n\n        if version is None and package_name is not None:\n            import importlib.metadata\n\n            try:\n                version = importlib.metadata.version(package_name)\n            except importlib.metadata.PackageNotFoundError:\n                raise RuntimeError(\n                    f\"{package_name!r} is not installed. Try passing\"\n                    \" 'package_name' instead.\"\n                ) from None\n\n        if version is None:\n            raise RuntimeError(\n                f\"Could not determine the version for {package_name!r} automatically.\"\n            )\n\n        echo(\n            message % {\"prog\": prog_name, \"package\": package_name, \"version\": version},\n            color=ctx.color,\n        )\n        ctx.exit()\n\n    if not param_decls:\n        param_decls = (\"--version\",)\n\n    kwargs.setdefault(\"is_flag\", True)\n    kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"is_eager\", True)\n    kwargs.setdefault(\"help\", _(\"Show the version and exit.\"))\n    kwargs[\"callback\"] = callback\n    return option(*param_decls, **kwargs)",
        "line_count": 104,
        "needs_llm_summary": true
      },
      {
        "name": "help_option",
        "args": [],
        "return_type": "t.Callable[Any, FC]",
        "lineno": 527,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "ctx.get_help",
          "ctx.exit",
          "kwargs.setdefault",
          "show_help",
          "_",
          "option",
          "kwargs",
          "ctx.color"
        ],
        "docstring": "Pre-configured ``--help`` option which immediately prints the help page\nand exits the program.\n\n:param param_decls: One or more option names. Defaults to the single\n    value ``\"--help\"``.\n:param kwargs: Extra arguments are passed to :func:`option`.",
        "code": "def help_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:\n    \"\"\"Pre-configured ``--help`` option which immediately prints the help page\n    and exits the program.\n\n    :param param_decls: One or more option names. Defaults to the single\n        value ``\"--help\"``.\n    :param kwargs: Extra arguments are passed to :func:`option`.\n    \"\"\"\n\n    def show_help(ctx: Context, param: Parameter, value: bool) -> None:\n        \"\"\"Callback that print the help page on ``<stdout>`` and exits.\"\"\"\n        if value and not ctx.resilient_parsing:\n            echo(ctx.get_help(), color=ctx.color)\n            ctx.exit()\n\n    if not param_decls:\n        param_decls = (\"--help\",)\n\n    kwargs.setdefault(\"is_flag\", True)\n    kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"is_eager\", True)\n    kwargs.setdefault(\"help\", _(\"Show this message and exit.\"))\n    kwargs.setdefault(\"callback\", show_help)\n\n    return option(*param_decls, **kwargs)",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "new_func",
        "args": [],
        "return_type": "R",
        "lineno": 33,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f",
          "kwargs",
          "get_current_context"
        ],
        "docstring": null,
        "code": "def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n        return f(get_current_context(), *args, **kwargs)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "new_func",
        "args": [],
        "return_type": "R",
        "lineno": 45,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.obj",
          "f",
          "kwargs",
          "get_current_context"
        ],
        "docstring": null,
        "code": "def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n        return f(get_current_context().obj, *args, **kwargs)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "f",
            "type": "t.Callable[te.Concatenate[T, P], R]"
          }
        ],
        "return_type": "t.Callable[P, R]",
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.ensure_object",
          "f",
          "new_func",
          "get_current_context",
          "ctx.find_object",
          "RuntimeError",
          "update_wrapper",
          "kwargs",
          "obj",
          "ctx.invoke",
          "object_type"
        ],
        "docstring": null,
        "code": "def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n\n            obj: T | None\n            if ensure:\n                obj = ctx.ensure_object(object_type)\n            else:\n                obj = ctx.find_object(object_type)\n\n            if obj is None:\n                raise RuntimeError(\n                    \"Managed to invoke callback without a context\"\n                    f\" object of type {object_type.__name__!r}\"\n                    \" existing.\"\n                )\n\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "f",
            "type": "t.Callable[te.Concatenate[T, P], R]"
          }
        ],
        "return_type": "t.Callable[P, R]",
        "lineno": 115,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f",
          "new_func",
          "get_current_context",
          "update_wrapper",
          "kwargs",
          "obj",
          "ctx.invoke"
        ],
        "docstring": null,
        "code": "def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n            obj = ctx.meta[key]\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "f",
            "type": "_AnyCallable"
          }
        ],
        "return_type": "CmdType",
        "lineno": 217,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cls",
          "params.extend",
          "f",
          "TypeError",
          "isinstance",
          "attrs",
          "params",
          "Command",
          "f.__click_params__",
          "attrs.pop",
          "name",
          "attrs.get",
          "unknown.replace",
          "f.__name__.lower",
          "cmd_name",
          "reversed",
          "cmd_left",
          "callable",
          "cmd_name.rpartition",
          "f.__doc__",
          "decorator_params"
        ],
        "docstring": null,
        "code": "def decorator(f: _AnyCallable) -> CmdType:\n        if isinstance(f, Command):\n            raise TypeError(\"Attempted to convert a callback into a command twice.\")\n\n        attr_params = attrs.pop(\"params\", None)\n        params = attr_params if attr_params is not None else []\n\n        try:\n            decorator_params = f.__click_params__  # type: ignore\n        except AttributeError:\n            pass\n        else:\n            del f.__click_params__  # type: ignore\n            params.extend(reversed(decorator_params))\n\n        if attrs.get(\"help\") is None:\n            attrs[\"help\"] = f.__doc__\n\n        if t.TYPE_CHECKING:\n            assert cls is not None\n            assert not callable(name)\n\n        if name is not None:\n            cmd_name = name\n        else:\n            cmd_name = f.__name__.lower().replace(\"_\", \"-\")\n            cmd_left, sep, suffix = cmd_name.rpartition(\"-\")\n\n            if sep and suffix in {\"command\", \"cmd\", \"group\", \"grp\"}:\n                cmd_name = cmd_left\n\n        cmd = cls(name=cmd_name, callback=f, params=params, **attrs)\n        cmd.__doc__ = f.__doc__\n        return cmd",
        "line_count": 34,
        "needs_llm_summary": true
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "f",
            "type": "FC"
          }
        ],
        "return_type": "FC",
        "lineno": 345,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cls",
          "f",
          "_param_memo",
          "attrs",
          "param_decls"
        ],
        "docstring": null,
        "code": "def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n        return f",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "f",
            "type": "FC"
          }
        ],
        "return_type": "FC",
        "lineno": 373,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cls",
          "f",
          "_param_memo",
          "attrs",
          "param_decls"
        ],
        "docstring": null,
        "code": "def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n        return f",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "callback",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "value",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 389,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.abort"
        ],
        "docstring": null,
        "code": "def callback(ctx: Context, param: Parameter, value: bool) -> None:\n        if not value:\n            ctx.abort()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "callback",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "value",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 484,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "importlib.metadata.version",
          "ctx.exit",
          "ctx.find_root",
          "RuntimeError",
          "ctx.color",
          "unknown.info_name",
          "package_name"
        ],
        "docstring": null,
        "code": "def callback(ctx: Context, param: Parameter, value: bool) -> None:\n        if not value or ctx.resilient_parsing:\n            return\n\n        nonlocal prog_name\n        nonlocal version\n\n        if prog_name is None:\n            prog_name = ctx.find_root().info_name\n\n        if version is None and package_name is not None:\n            import importlib.metadata\n\n            try:\n                version = importlib.metadata.version(package_name)\n            except importlib.metadata.PackageNotFoundError:\n                raise RuntimeError(\n                    f\"{package_name!r} is not installed. Try passing\"\n                    \" 'package_name' instead.\"\n                ) from None\n\n        if version is None:\n            raise RuntimeError(\n                f\"Could not determine the version for {package_name!r} automatically.\"\n            )\n\n        echo(\n            message % {\"prog\": prog_name, \"package\": package_name, \"version\": version},\n            color=ctx.color,\n        )\n        ctx.exit()",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "show_help",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "value",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 536,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.color",
          "echo",
          "ctx.get_help",
          "ctx.exit"
        ],
        "docstring": "Callback that print the help page on ``<stdout>`` and exits.",
        "code": "def show_help(ctx: Context, param: Parameter, value: bool) -> None:\n        \"\"\"Callback that print the help page on ``<stdout>`` and exits.\"\"\"\n        if value and not ctx.resilient_parsing:\n            echo(ctx.get_help(), color=ctx.color)\n            ctx.exit()",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "new_func",
        "args": [],
        "return_type": "R",
        "lineno": 77,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.ensure_object",
          "f",
          "RuntimeError",
          "get_current_context",
          "ctx.find_object",
          "kwargs",
          "obj",
          "ctx.invoke",
          "object_type"
        ],
        "docstring": null,
        "code": "def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n\n            obj: T | None\n            if ensure:\n                obj = ctx.ensure_object(object_type)\n            else:\n                obj = ctx.find_object(object_type)\n\n            if obj is None:\n                raise RuntimeError(\n                    \"Managed to invoke callback without a context\"\n                    f\" object of type {object_type.__name__!r}\"\n                    \" existing.\"\n                )\n\n            return ctx.invoke(f, obj, *args, **kwargs)",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "new_func",
        "args": [],
        "return_type": "R",
        "lineno": 116,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f",
          "get_current_context",
          "kwargs",
          "obj",
          "ctx.invoke"
        ],
        "docstring": null,
        "code": "def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n            obj = ctx.meta[key]\n            return ctx.invoke(f, obj, *args, **kwargs)",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "functools",
        "name": "update_wrapper",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Argument",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Command",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Context",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Group",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Option",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Parameter",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "globals",
        "name": "get_current_context",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "echo",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "typing_extensions",
        "alias": "te",
        "lineno": 18,
        "type": "import"
      },
      {
        "module": "importlib.metadata",
        "alias": null,
        "lineno": 495,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "R",
        "assigned_to": "t.TypeVar",
        "lineno": 22
      },
      {
        "name": "T",
        "assigned_to": "t.TypeVar",
        "lineno": 23
      },
      {
        "name": "_AnyCallable",
        "assigned_to": null,
        "lineno": 24
      },
      {
        "name": "FC",
        "assigned_to": "t.TypeVar",
        "lineno": 25
      },
      {
        "name": "CmdType",
        "assigned_to": "t.TypeVar",
        "lineno": 133
      },
      {
        "name": "GrpType",
        "assigned_to": "t.TypeVar",
        "lineno": 258
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "t.TypeVar",
        "Command",
        "Group",
        "te.ParamSpec"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "functools",
        "typing"
      ],
      "third_party": {
        "other": [
          "__future__",
          "inspect",
          "gettext",
          "core",
          "globals",
          "utils",
          "typing_extensions",
          "importlib"
        ]
      },
      "tech_stack": []
    },
    "line_count": 552
  },
  "src/click/exceptions.py": {
    "filepath": "../click/src/click/exceptions.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_join_param_hints",
        "args": [
          {
            "name": "param_hint",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 19,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "unknown.join",
          "str",
          "isinstance",
          "param_hint",
          "x"
        ],
        "docstring": null,
        "code": "def _join_param_hints(param_hint: cabc.Sequence[str] | str | None) -> str | None:\n    if param_hint is not None and not isinstance(param_hint, str):\n        return \" / \".join(repr(x) for x in param_hint)\n\n    return param_hint",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "message",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 32,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.__init__",
          "super",
          "resolve_color_default",
          "message"
        ],
        "docstring": null,
        "code": "def __init__(self, message: str) -> None:\n        super().__init__(message)\n        # The context will be removed by the time we print the message, so cache\n        # the color settings here to be used later on (in `show`)\n        self.show_color: bool | None = resolve_color_default()\n        self.message = message",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "format_message",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 39,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def format_message(self) -> str:\n        return self.message",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 42,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        return self.message",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "show",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 45,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "self.show_color",
          "get_text_stderr",
          "file",
          "_",
          "self.format_message",
          "unknown.format"
        ],
        "docstring": null,
        "code": "def show(self, file: t.IO[t.Any] | None = None) -> None:\n        if file is None:\n            file = get_text_stderr()\n\n        echo(\n            _(\"Error: {message}\").format(message=self.format_message()),\n            file=file,\n            color=self.show_color,\n        )",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "message",
            "type": "str"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 67,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "unknown.__init__",
          "super",
          "message"
        ],
        "docstring": null,
        "code": "def __init__(self, message: str, ctx: Context | None = None) -> None:\n        super().__init__(message)\n        self.ctx = ctx\n        self.cmd: Command | None = self.ctx.command if self.ctx else None",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "show",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 72,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.ctx.color",
          "echo",
          "self.ctx.command_path",
          "get_text_stderr",
          "file",
          "self.ctx.command.get_help_option",
          "_",
          "self.ctx",
          "self.format_message",
          "color",
          "self.ctx.get_usage",
          "unknown.format"
        ],
        "docstring": null,
        "code": "def show(self, file: t.IO[t.Any] | None = None) -> None:\n        if file is None:\n            file = get_text_stderr()\n        color = None\n        hint = \"\"\n        if (\n            self.ctx is not None\n            and self.ctx.command.get_help_option(self.ctx) is not None\n        ):\n            hint = _(\"Try '{command} {option}' for help.\").format(\n                command=self.ctx.command_path, option=self.ctx.help_option_names[0]\n            )\n            hint = f\"{hint}\\n\"\n        if self.ctx is not None:\n            color = self.ctx.color\n            echo(f\"{self.ctx.get_usage()}\\n{hint}\", file=file, color=color)\n        echo(\n            _(\"Error: {message}\").format(message=self.format_message()),\n            file=file,\n            color=color,\n        )",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "message",
            "type": "str"
          },
          {
            "name": "ctx",
            "type": "Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "param_hint",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 113,
        "decorators": [],
        "is_async": false,
        "calls": [
          "message",
          "param",
          "unknown.__init__",
          "ctx",
          "super",
          "param_hint"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        message: str,\n        ctx: Context | None = None,\n        param: Parameter | None = None,\n        param_hint: cabc.Sequence[str] | str | None = None,\n    ) -> None:\n        super().__init__(message, ctx)\n        self.param = param\n        self.param_hint = param_hint",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "format_message",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 124,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.param.get_error_hint",
          "_",
          "self.param_hint",
          "self.ctx",
          "self.message",
          "param_hint",
          "unknown.format",
          "_join_param_hints"
        ],
        "docstring": null,
        "code": "def format_message(self) -> str:\n        if self.param_hint is not None:\n            param_hint = self.param_hint\n        elif self.param is not None:\n            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore\n        else:\n            return _(\"Invalid value: {message}\").format(message=self.message)\n\n        return _(\"Invalid value for {param_hint}: {message}\").format(\n            param_hint=_join_param_hints(param_hint), message=self.message\n        )",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "message",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "param_hint",
            "type": "Any"
          },
          {
            "name": "param_type",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 149,
        "decorators": [],
        "is_async": false,
        "calls": [
          "param",
          "unknown.__init__",
          "ctx",
          "param_type",
          "super",
          "param_hint"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        message: str | None = None,\n        ctx: Context | None = None,\n        param: Parameter | None = None,\n        param_hint: cabc.Sequence[str] | str | None = None,\n        param_type: str | None = None,\n    ) -> None:\n        super().__init__(message or \"\", ctx, param, param_hint)\n        self.param_type = param_type",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "format_message",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 160,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.param.get_error_hint",
          "self.param.param_type_name",
          "_",
          "self.param.type.get_missing_message",
          "self.param_type",
          "self.ctx",
          "param_type",
          "self.message",
          "self.param",
          "param_hint",
          "unknown.format",
          "_join_param_hints",
          "msg_extra"
        ],
        "docstring": null,
        "code": "def format_message(self) -> str:\n        if self.param_hint is not None:\n            param_hint: cabc.Sequence[str] | str | None = self.param_hint\n        elif self.param is not None:\n            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore\n        else:\n            param_hint = None\n\n        param_hint = _join_param_hints(param_hint)\n        param_hint = f\" {param_hint}\" if param_hint else \"\"\n\n        param_type = self.param_type\n        if param_type is None and self.param is not None:\n            param_type = self.param.param_type_name\n\n        msg = self.message\n        if self.param is not None:\n            msg_extra = self.param.type.get_missing_message(\n                param=self.param, ctx=self.ctx\n            )\n            if msg_extra:\n                if msg:\n                    msg += f\". {msg_extra}\"\n                else:\n                    msg = msg_extra\n\n        msg = f\" {msg}\" if msg else \"\"\n\n        # Translate param_type for known types.\n        if param_type == \"argument\":\n            missing = _(\"Missing argument\")\n        elif param_type == \"option\":\n            missing = _(\"Missing option\")\n        elif param_type == \"parameter\":\n            missing = _(\"Missing parameter\")\n        else:\n            missing = _(\"Missing {param_type}\").format(param_type=param_type)\n\n        return f\"{missing}{param_hint}.{msg}\"",
        "line_count": 39,
        "needs_llm_summary": true
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 200,
        "decorators": [],
        "is_async": false,
        "calls": [
          "param_name",
          "unknown.format",
          "_"
        ],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        if not self.message:\n            param_name = self.param.name if self.param else None\n            return _(\"Missing parameter: {param_name}\").format(param_name=param_name)\n        else:\n            return self.message",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "option_name",
            "type": "str"
          },
          {
            "name": "message",
            "type": "Any"
          },
          {
            "name": "possibilities",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 215,
        "decorators": [],
        "is_async": false,
        "calls": [
          "message",
          "unknown.__init__",
          "ctx",
          "_",
          "possibilities",
          "option_name",
          "super",
          "unknown.format"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        option_name: str,\n        message: str | None = None,\n        possibilities: cabc.Sequence[str] | None = None,\n        ctx: Context | None = None,\n    ) -> None:\n        if message is None:\n            message = _(\"No such option: {name}\").format(name=option_name)\n\n        super().__init__(message, ctx)\n        self.option_name = option_name\n        self.possibilities = possibilities",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "format_message",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 229,
        "decorators": [],
        "is_async": false,
        "calls": [
          "possibility_str",
          "unknown.join",
          "len",
          "sorted",
          "ngettext",
          "self.possibilities",
          "unknown.format"
        ],
        "docstring": null,
        "code": "def format_message(self) -> str:\n        if not self.possibilities:\n            return self.message\n\n        possibility_str = \", \".join(sorted(self.possibilities))\n        suggest = ngettext(\n            \"Did you mean {possibility}?\",\n            \"(Possible options: {possibilities})\",\n            len(self.possibilities),\n        ).format(possibility=possibility_str, possibilities=possibility_str)\n        return f\"{self.message} {suggest}\"",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "option_name",
            "type": "str"
          },
          {
            "name": "message",
            "type": "str"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 252,
        "decorators": [],
        "is_async": false,
        "calls": [
          "message",
          "unknown.__init__",
          "ctx",
          "option_name",
          "super"
        ],
        "docstring": null,
        "code": "def __init__(\n        self, option_name: str, message: str, ctx: Context | None = None\n    ) -> None:\n        super().__init__(message, ctx)\n        self.option_name = option_name",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "None",
        "lineno": 269,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.__init__",
          "ctx.get_help",
          "ctx",
          "super"
        ],
        "docstring": null,
        "code": "def __init__(self, ctx: Context) -> None:\n        self.ctx: Context\n        super().__init__(ctx.get_help(), ctx=ctx)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "show",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 273,
        "decorators": [],
        "is_async": false,
        "calls": [
          "file",
          "echo",
          "self.ctx.color",
          "self.format_message"
        ],
        "docstring": null,
        "code": "def show(self, file: t.IO[t.Any] | None = None) -> None:\n        echo(self.format_message(), file=file, err=True, color=self.ctx.color)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "filename",
            "type": "str"
          },
          {
            "name": "hint",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 280,
        "decorators": [],
        "is_async": false,
        "calls": [
          "filename",
          "hint",
          "unknown.__init__",
          "_",
          "super",
          "format_filename"
        ],
        "docstring": null,
        "code": "def __init__(self, filename: str, hint: str | None = None) -> None:\n        if hint is None:\n            hint = _(\"unknown error\")\n\n        super().__init__(hint)\n        self.ui_filename: str = format_filename(filename)\n        self.filename = filename",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "format_message",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 288,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.message",
          "self.ui_filename",
          "unknown.format",
          "_"
        ],
        "docstring": null,
        "code": "def format_message(self) -> str:\n        return _(\"Could not open file {filename!r}: {message}\").format(\n            filename=self.ui_filename, message=self.message\n        )",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "code",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 307,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self, code: int = 0) -> None:\n        self.exit_code: int = code",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "ClickException",
        "methods": [
          "__init__",
          "format_message",
          "__str__",
          "show"
        ],
        "base_classes": [
          "Exception"
        ],
        "lineno": 26,
        "docstring": "An exception that Click can handle and show to the user."
      },
      {
        "name": "UsageError",
        "methods": [
          "__init__",
          "show"
        ],
        "base_classes": [
          "ClickException"
        ],
        "lineno": 56,
        "docstring": "An internal exception that signals a usage error.  This typically\naborts any further handling.\n\n:param message: the error message to display.\n:param ctx: optionally the context that caused this error.  Click will\n            fill in the context automatically in some situations."
      },
      {
        "name": "BadParameter",
        "methods": [
          "__init__",
          "format_message"
        ],
        "base_classes": [
          "UsageError"
        ],
        "lineno": 95,
        "docstring": "An exception that formats out a standardized error message for a\nbad parameter.  This is useful when thrown from a callback or type as\nClick will attach contextual information to it (for instance, which\nparameter it is).\n\n.. versionadded:: 2.0\n\n:param param: the parameter object that caused this error.  This can\n              be left out, and Click will attach this info itself\n              if possible.\n:param param_hint: a string that shows up as parameter name.  This\n                   can be used as alternative to `param` in cases\n                   where custom validation should happen.  If it is\n                   a string it's used as such, if it's a list then\n                   each item is quoted and separated."
      },
      {
        "name": "MissingParameter",
        "methods": [
          "__init__",
          "format_message",
          "__str__"
        ],
        "base_classes": [
          "BadParameter"
        ],
        "lineno": 137,
        "docstring": "Raised if click required an option or argument but it was not\nprovided when invoking the script.\n\n.. versionadded:: 4.0\n\n:param param_type: a string that indicates the type of the parameter.\n                   The default is to inherit the parameter type from\n                   the given `param`.  Valid values are ``'parameter'``,\n                   ``'option'`` or ``'argument'``."
      },
      {
        "name": "NoSuchOption",
        "methods": [
          "__init__",
          "format_message"
        ],
        "base_classes": [
          "UsageError"
        ],
        "lineno": 208,
        "docstring": "Raised if click attempted to handle an option that does not\nexist.\n\n.. versionadded:: 4.0"
      },
      {
        "name": "BadOptionUsage",
        "methods": [
          "__init__"
        ],
        "base_classes": [
          "UsageError"
        ],
        "lineno": 242,
        "docstring": "Raised if an option is generally supplied but the use of the option\nwas incorrect.  This is for instance raised if the number of arguments\nfor an option is not correct.\n\n.. versionadded:: 4.0\n\n:param option_name: the name of the option being used incorrectly."
      },
      {
        "name": "BadArgumentUsage",
        "methods": [],
        "base_classes": [
          "UsageError"
        ],
        "lineno": 259,
        "docstring": "Raised if an argument is generally supplied but the use of the argument\nwas incorrect.  This is for instance raised if the number of values\nfor an argument is not correct.\n\n.. versionadded:: 6.0"
      },
      {
        "name": "NoArgsIsHelpError",
        "methods": [
          "__init__",
          "show"
        ],
        "base_classes": [
          "UsageError"
        ],
        "lineno": 268,
        "docstring": null
      },
      {
        "name": "FileError",
        "methods": [
          "__init__",
          "format_message"
        ],
        "base_classes": [
          "ClickException"
        ],
        "lineno": 277,
        "docstring": "Raised if a file cannot be opened."
      },
      {
        "name": "Abort",
        "methods": [],
        "base_classes": [
          "RuntimeError"
        ],
        "lineno": 294,
        "docstring": "An internal signalling exception that signals Click to abort."
      },
      {
        "name": "Exit",
        "methods": [
          "__init__"
        ],
        "base_classes": [
          "RuntimeError"
        ],
        "lineno": 298,
        "docstring": "An exception that indicates that the application should exit with some\nstatus code.\n\n:param code: the status code to exit with."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "ngettext",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "get_text_stderr",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "globals",
        "name": "resolve_color_default",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "echo",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "format_filename",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Command",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Context",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Parameter",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "collections",
        "typing"
      ],
      "third_party": {
        "other": [
          "__future__",
          "gettext",
          "_compat",
          "globals",
          "utils",
          "core"
        ]
      },
      "tech_stack": []
    },
    "line_count": 309
  },
  "src/click/formatting.py": {
    "filepath": "../click/src/click/formatting.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "measure_table",
        "args": [
          {
            "name": "rows",
            "type": "cabc.Iterable[tuple[str, str]]"
          }
        ],
        "return_type": "tuple[int, Ellipsis]",
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "tuple",
          "term_len",
          "max",
          "row",
          "col",
          "widths.get",
          "idx",
          "widths.items",
          "sorted"
        ],
        "docstring": null,
        "code": "def measure_table(rows: cabc.Iterable[tuple[str, str]]) -> tuple[int, ...]:\n    widths: dict[int, int] = {}\n\n    for row in rows:\n        for idx, col in enumerate(row):\n            widths[idx] = max(widths.get(idx, 0), term_len(col))\n\n    return tuple(y for x, y in sorted(widths.items()))",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "iter_rows",
        "args": [
          {
            "name": "rows",
            "type": "cabc.Iterable[tuple[str, str]]"
          },
          {
            "name": "col_count",
            "type": "int"
          }
        ],
        "return_type": "cabc.Iterator[tuple[str, Ellipsis]]",
        "lineno": 24,
        "decorators": [],
        "is_async": false,
        "calls": [
          "len",
          "row"
        ],
        "docstring": null,
        "code": "def iter_rows(\n    rows: cabc.Iterable[tuple[str, str]], col_count: int\n) -> cabc.Iterator[tuple[str, ...]]:\n    for row in rows:\n        yield row + (\"\",) * (col_count - len(row))",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "wrap_text",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "initial_indent",
            "type": "str"
          },
          {
            "name": "subsequent_indent",
            "type": "str"
          },
          {
            "name": "preserve_paragraphs",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 31,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "initial_indent",
          "text.splitlines",
          "rv.append",
          "TextWrapper",
          "wrapper.indent_only",
          "term_len",
          "rv",
          "wrapper.fill",
          "width",
          "text.expandtabs",
          "subsequent_indent",
          "unknown.strip",
          "line.lstrip",
          "line",
          "buf",
          "unknown.join",
          "buf.append",
          "p.append",
          "_flush_par",
          "wrapper.extra_indent"
        ],
        "docstring": "A helper function that intelligently wraps text.  By default, it\nassumes that it operates on a single paragraph of text but if the\n`preserve_paragraphs` parameter is provided it will intelligently\nhandle paragraphs (defined by two empty lines).\n\nIf paragraphs are handled, a paragraph can be prefixed with an empty\nline containing the ``\\b`` character (``\\x08``) to indicate that\nno rewrapping should happen in that block.\n\n:param text: the text that should be rewrapped.\n:param width: the maximum width for the text.\n:param initial_indent: the initial indent that should be placed on the\n                       first line as a string.\n:param subsequent_indent: the indent string that should be placed on\n                          each consecutive line.\n:param preserve_paragraphs: if this flag is set then the wrapping will\n                            intelligently handle paragraphs.",
        "code": "def wrap_text(\n    text: str,\n    width: int = 78,\n    initial_indent: str = \"\",\n    subsequent_indent: str = \"\",\n    preserve_paragraphs: bool = False,\n) -> str:\n    \"\"\"A helper function that intelligently wraps text.  By default, it\n    assumes that it operates on a single paragraph of text but if the\n    `preserve_paragraphs` parameter is provided it will intelligently\n    handle paragraphs (defined by two empty lines).\n\n    If paragraphs are handled, a paragraph can be prefixed with an empty\n    line containing the ``\\\\b`` character (``\\\\x08``) to indicate that\n    no rewrapping should happen in that block.\n\n    :param text: the text that should be rewrapped.\n    :param width: the maximum width for the text.\n    :param initial_indent: the initial indent that should be placed on the\n                           first line as a string.\n    :param subsequent_indent: the indent string that should be placed on\n                              each consecutive line.\n    :param preserve_paragraphs: if this flag is set then the wrapping will\n                                intelligently handle paragraphs.\n    \"\"\"\n    from ._textwrap import TextWrapper\n\n    text = text.expandtabs()\n    wrapper = TextWrapper(\n        width,\n        initial_indent=initial_indent,\n        subsequent_indent=subsequent_indent,\n        replace_whitespace=False,\n    )\n    if not preserve_paragraphs:\n        return wrapper.fill(text)\n\n    p: list[tuple[int, bool, str]] = []\n    buf: list[str] = []\n    indent = None\n\n    def _flush_par() -> None:\n        if not buf:\n            return\n        if buf[0].strip() == \"\\b\":\n            p.append((indent or 0, True, \"\\n\".join(buf[1:])))\n        else:\n            p.append((indent or 0, False, \" \".join(buf)))\n        del buf[:]\n\n    for line in text.splitlines():\n        if not line:\n            _flush_par()\n            indent = None\n        else:\n            if indent is None:\n                orig_len = term_len(line)\n                line = line.lstrip()\n                indent = orig_len - term_len(line)\n            buf.append(line)\n    _flush_par()\n\n    rv = []\n    for indent, raw, text in p:\n        with wrapper.extra_indent(\" \" * indent):\n            if raw:\n                rv.append(wrapper.indent_only(text))\n            else:\n                rv.append(wrapper.fill(text))\n\n    return \"\\n\\n\".join(rv)",
        "line_count": 71,
        "needs_llm_summary": true
      },
      {
        "name": "join_options",
        "args": [
          {
            "name": "options",
            "type": "cabc.Sequence[str]"
          }
        ],
        "return_type": "tuple[str, bool]",
        "lineno": 283,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "len",
          "opt",
          "rv.append",
          "prefix",
          "rv.sort",
          "_split_opt"
        ],
        "docstring": "Given a list of option strings this joins them in the most appropriate\nway and returns them in the form ``(formatted_string,\nany_prefix_is_slash)`` where the second item in the tuple is a flag that\nindicates if any of the option prefixes was a slash.",
        "code": "def join_options(options: cabc.Sequence[str]) -> tuple[str, bool]:\n    \"\"\"Given a list of option strings this joins them in the most appropriate\n    way and returns them in the form ``(formatted_string,\n    any_prefix_is_slash)`` where the second item in the tuple is a flag that\n    indicates if any of the option prefixes was a slash.\n    \"\"\"\n    rv = []\n    any_prefix_is_slash = False\n\n    for opt in options:\n        prefix = _split_opt(opt)[0]\n\n        if prefix == \"/\":\n            any_prefix_is_slash = True\n\n        rv.append((len(prefix), opt))\n\n    rv.sort(key=lambda x: x[0])\n    return \", \".join(x[1] for x in rv), any_prefix_is_slash",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "_flush_par",
        "args": [],
        "return_type": "None",
        "lineno": 72,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.strip",
          "unknown.join",
          "buf",
          "p.append"
        ],
        "docstring": null,
        "code": "def _flush_par() -> None:\n        if not buf:\n            return\n        if buf[0].strip() == \"\\b\":\n            p.append((indent or 0, True, \"\\n\".join(buf[1:])))\n        else:\n            p.append((indent or 0, False, \" \".join(buf)))\n        del buf[:]",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "indent_increment",
            "type": "int"
          },
          {
            "name": "width",
            "type": "Any"
          },
          {
            "name": "max_width",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 116,
        "decorators": [],
        "is_async": false,
        "calls": [
          "shutil.get_terminal_size",
          "unknown.columns",
          "max_width",
          "FORCED_WIDTH",
          "max",
          "indent_increment",
          "min",
          "width"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        indent_increment: int = 2,\n        width: int | None = None,\n        max_width: int | None = None,\n    ) -> None:\n        self.indent_increment = indent_increment\n        if max_width is None:\n            max_width = 80\n        if width is None:\n            import shutil\n\n            width = FORCED_WIDTH\n            if width is None:\n                width = max(min(shutil.get_terminal_size().columns, max_width) - 2, 50)\n        self.width = width\n        self.current_indent: int = 0\n        self.buffer: list[str] = []",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "write",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "string",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 135,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.buffer.append",
          "string"
        ],
        "docstring": "Writes a unicode string into the internal buffer.",
        "code": "def write(self, string: str) -> None:\n        \"\"\"Writes a unicode string into the internal buffer.\"\"\"\n        self.buffer.append(string)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "indent",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 139,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Increases the indentation.",
        "code": "def indent(self) -> None:\n        \"\"\"Increases the indentation.\"\"\"\n        self.current_indent += self.indent_increment",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "dedent",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 143,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Decreases the indentation.",
        "code": "def dedent(self) -> None:\n        \"\"\"Decreases the indentation.\"\"\"\n        self.current_indent -= self.indent_increment",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "write_usage",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "prog",
            "type": "str"
          },
          {
            "name": "args",
            "type": "str"
          },
          {
            "name": "prefix",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 147,
        "decorators": [],
        "is_async": false,
        "calls": [
          "wrap_text",
          "term_len",
          "usage_prefix",
          "self.current_indent",
          "max",
          "_",
          "self.write",
          "text_width",
          "args",
          "indent",
          "prefix"
        ],
        "docstring": "Writes a usage line into the buffer.\n\n:param prog: the program name.\n:param args: whitespace separated list of arguments.\n:param prefix: The prefix for the first line. Defaults to\n    ``\"Usage: \"``.",
        "code": "def write_usage(self, prog: str, args: str = \"\", prefix: str | None = None) -> None:\n        \"\"\"Writes a usage line into the buffer.\n\n        :param prog: the program name.\n        :param args: whitespace separated list of arguments.\n        :param prefix: The prefix for the first line. Defaults to\n            ``\"Usage: \"``.\n        \"\"\"\n        if prefix is None:\n            prefix = f\"{_('Usage:')} \"\n\n        usage_prefix = f\"{prefix:>{self.current_indent}}{prog} \"\n        text_width = self.width - self.current_indent\n\n        if text_width >= (term_len(usage_prefix) + 20):\n            # The arguments will fit to the right of the prefix.\n            indent = \" \" * term_len(usage_prefix)\n            self.write(\n                wrap_text(\n                    args,\n                    text_width,\n                    initial_indent=usage_prefix,\n                    subsequent_indent=indent,\n                )\n            )\n        else:\n            # The prefix is too long, put the arguments on the next line.\n            self.write(usage_prefix)\n            self.write(\"\\n\")\n            indent = \" \" * (max(self.current_indent, term_len(prefix)) + 4)\n            self.write(\n                wrap_text(\n                    args, text_width, initial_indent=indent, subsequent_indent=indent\n                )\n            )\n\n        self.write(\"\\n\")",
        "line_count": 37,
        "needs_llm_summary": true
      },
      {
        "name": "write_heading",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "heading",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 185,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.write"
        ],
        "docstring": "Writes a heading into the buffer.",
        "code": "def write_heading(self, heading: str) -> None:\n        \"\"\"Writes a heading into the buffer.\"\"\"\n        self.write(f\"{'':>{self.current_indent}}{heading}:\\n\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "write_paragraph",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 189,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.write"
        ],
        "docstring": "Writes a paragraph into the buffer.",
        "code": "def write_paragraph(self) -> None:\n        \"\"\"Writes a paragraph into the buffer.\"\"\"\n        if self.buffer:\n            self.write(\"\\n\")",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "write_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 194,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "wrap_text",
          "self.write",
          "self.width",
          "indent"
        ],
        "docstring": "Writes re-indented text into the buffer.  This rewraps and\npreserves paragraphs.",
        "code": "def write_text(self, text: str) -> None:\n        \"\"\"Writes re-indented text into the buffer.  This rewraps and\n        preserves paragraphs.\n        \"\"\"\n        indent = \" \" * self.current_indent\n        self.write(\n            wrap_text(\n                text,\n                self.width,\n                initial_indent=indent,\n                subsequent_indent=indent,\n                preserve_paragraphs=True,\n            )\n        )\n        self.write(\"\\n\")",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "write_dl",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "rows",
            "type": "cabc.Sequence[tuple[str, str]]"
          },
          {
            "name": "col_max",
            "type": "int"
          },
          {
            "name": "col_spacing",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 210,
        "decorators": [],
        "is_async": false,
        "calls": [
          "iter_rows",
          "wrap_text",
          "col_max",
          "term_len",
          "widths",
          "max",
          "len",
          "second",
          "list",
          "measure_table",
          "wrapped_text.splitlines",
          "TypeError",
          "min",
          "self.write",
          "text_width",
          "rows",
          "first"
        ],
        "docstring": "Writes a definition list into the buffer.  This is how options\nand commands are usually formatted.\n\n:param rows: a list of two item tuples for the terms and values.\n:param col_max: the maximum width of the first column.\n:param col_spacing: the number of spaces between the first and\n                    second column.",
        "code": "def write_dl(\n        self,\n        rows: cabc.Sequence[tuple[str, str]],\n        col_max: int = 30,\n        col_spacing: int = 2,\n    ) -> None:\n        \"\"\"Writes a definition list into the buffer.  This is how options\n        and commands are usually formatted.\n\n        :param rows: a list of two item tuples for the terms and values.\n        :param col_max: the maximum width of the first column.\n        :param col_spacing: the number of spaces between the first and\n                            second column.\n        \"\"\"\n        rows = list(rows)\n        widths = measure_table(rows)\n        if len(widths) != 2:\n            raise TypeError(\"Expected two columns for definition list\")\n\n        first_col = min(widths[0], col_max) + col_spacing\n\n        for first, second in iter_rows(rows, len(widths)):\n            self.write(f\"{'':>{self.current_indent}}{first}\")\n            if not second:\n                self.write(\"\\n\")\n                continue\n            if term_len(first) <= first_col - col_spacing:\n                self.write(\" \" * (first_col - term_len(first)))\n            else:\n                self.write(\"\\n\")\n                self.write(\" \" * (first_col + self.current_indent))\n\n            text_width = max(self.width - first_col - 2, 10)\n            wrapped_text = wrap_text(second, text_width, preserve_paragraphs=True)\n            lines = wrapped_text.splitlines()\n\n            if lines:\n                self.write(f\"{lines[0]}\\n\")\n\n                for line in lines[1:]:\n                    self.write(f\"{'':>{first_col + self.current_indent}}{line}\\n\")\n            else:\n                self.write(\"\\n\")",
        "line_count": 43,
        "needs_llm_summary": true
      },
      {
        "name": "section",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "cabc.Iterator[None]",
        "lineno": 255,
        "decorators": [
          {
            "name": "contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.write_paragraph",
          "name",
          "self.write_heading",
          "self.dedent",
          "self.indent"
        ],
        "docstring": "Helpful context manager that writes a paragraph, a heading,\nand the indents.\n\n:param name: the section name that is written as heading.",
        "code": "def section(self, name: str) -> cabc.Iterator[None]:\n        \"\"\"Helpful context manager that writes a paragraph, a heading,\n        and the indents.\n\n        :param name: the section name that is written as heading.\n        \"\"\"\n        self.write_paragraph()\n        self.write_heading(name)\n        self.indent()\n        try:\n            yield\n        finally:\n            self.dedent()",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "indentation",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "cabc.Iterator[None]",
        "lineno": 270,
        "decorators": [
          {
            "name": "contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.dedent",
          "self.indent"
        ],
        "docstring": "A context manager that increases the indentation.",
        "code": "def indentation(self) -> cabc.Iterator[None]:\n        \"\"\"A context manager that increases the indentation.\"\"\"\n        self.indent()\n        try:\n            yield\n        finally:\n            self.dedent()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "getvalue",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 278,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "self.buffer"
        ],
        "docstring": "Returns the buffer contents.",
        "code": "def getvalue(self) -> str:\n        \"\"\"Returns the buffer contents.\"\"\"\n        return \"\".join(self.buffer)",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "HelpFormatter",
        "methods": [
          "__init__",
          "write",
          "indent",
          "dedent",
          "write_usage",
          "write_heading",
          "write_paragraph",
          "write_text",
          "write_dl",
          "section",
          "indentation",
          "getvalue"
        ],
        "base_classes": [],
        "lineno": 104,
        "docstring": "This class helps with formatting text-based help pages.  It's\nusually just needed for very special internal cases, but it's also\nexposed so that developers can write their own fancy outputs.\n\nAt present, it always writes into memory.\n\n:param indent_increment: the additional increment for each level.\n:param width: the width for the text.  This defaults to the terminal\n              width clamped to a maximum of 78."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "contextlib",
        "name": "contextmanager",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "term_len",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "parser",
        "name": "_split_opt",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "_textwrap",
        "name": "TextWrapper",
        "alias": null,
        "lineno": 56,
        "type": "from_import"
      },
      {
        "module": "shutil",
        "alias": null,
        "lineno": 126,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "collections",
        "contextlib",
        "shutil"
      ],
      "third_party": {
        "other": [
          "__future__",
          "gettext",
          "_compat",
          "parser",
          "_textwrap"
        ]
      },
      "tech_stack": []
    },
    "line_count": 302
  },
  "src/click/globals.py": {
    "filepath": "../click/src/click/globals.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "get_current_context",
        "args": [
          {
            "name": "silent",
            "type": "t.Literal[False]"
          }
        ],
        "return_type": "Context",
        "lineno": 13,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_current_context(silent: t.Literal[False] = False) -> Context: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "get_current_context",
        "args": [
          {
            "name": "silent",
            "type": "bool"
          }
        ],
        "return_type": "Any",
        "lineno": 17,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_current_context(silent: bool = ...) -> Context | None: ...",
        "line_count": 1,
        "needs_llm_summary": false
      },
      {
        "name": "get_current_context",
        "args": [
          {
            "name": "silent",
            "type": "bool"
          }
        ],
        "return_type": "Any",
        "lineno": 20,
        "decorators": [],
        "is_async": false,
        "calls": [
          "RuntimeError",
          "t.cast"
        ],
        "docstring": "Returns the current click context.  This can be used as a way to\naccess the current context object from anywhere.  This is a more implicit\nalternative to the :func:`pass_context` decorator.  This function is\nprimarily useful for helpers such as :func:`echo` which might be\ninterested in changing its behavior based on the current context.\n\nTo push the current context, :meth:`Context.scope` can be used.\n\n.. versionadded:: 5.0\n\n:param silent: if set to `True` the return value is `None` if no context\n               is available.  The default behavior is to raise a\n               :exc:`RuntimeError`.",
        "code": "def get_current_context(silent: bool = False) -> Context | None:\n    \"\"\"Returns the current click context.  This can be used as a way to\n    access the current context object from anywhere.  This is a more implicit\n    alternative to the :func:`pass_context` decorator.  This function is\n    primarily useful for helpers such as :func:`echo` which might be\n    interested in changing its behavior based on the current context.\n\n    To push the current context, :meth:`Context.scope` can be used.\n\n    .. versionadded:: 5.0\n\n    :param silent: if set to `True` the return value is `None` if no context\n                   is available.  The default behavior is to raise a\n                   :exc:`RuntimeError`.\n    \"\"\"\n    try:\n        return t.cast(\"Context\", _local.stack[-1])\n    except (AttributeError, IndexError) as e:\n        if not silent:\n            raise RuntimeError(\"There is no active click context.\") from e\n\n    return None",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "push_context",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "None",
        "lineno": 44,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.append",
          "ctx",
          "_local.__dict__.setdefault"
        ],
        "docstring": "Pushes a new context to the current stack.",
        "code": "def push_context(ctx: Context) -> None:\n    \"\"\"Pushes a new context to the current stack.\"\"\"\n    _local.__dict__.setdefault(\"stack\", []).append(ctx)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "pop_context",
        "args": [],
        "return_type": "None",
        "lineno": 49,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_local.stack.pop"
        ],
        "docstring": "Removes the top level from the stack.",
        "code": "def pop_context() -> None:\n    \"\"\"Removes the top level from the stack.\"\"\"\n    _local.stack.pop()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "resolve_color_default",
        "args": [
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 54,
        "decorators": [],
        "is_async": false,
        "calls": [
          "get_current_context"
        ],
        "docstring": "Internal helper to get the default value of the color flag.  If a\nvalue is passed it's returned unchanged, otherwise it's looked up from\nthe current context.",
        "code": "def resolve_color_default(color: bool | None = None) -> bool | None:\n    \"\"\"Internal helper to get the default value of the color flag.  If a\n    value is passed it's returned unchanged, otherwise it's looked up from\n    the current context.\n    \"\"\"\n    if color is not None:\n        return color\n\n    ctx = get_current_context(silent=True)\n\n    if ctx is not None:\n        return ctx.color\n\n    return None",
        "line_count": 14,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "threading",
        "name": "local",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Context",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "_local",
        "assigned_to": "local",
        "lineno": 9
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "local"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "threading",
        "typing"
      ],
      "third_party": {
        "other": [
          "__future__",
          "core"
        ]
      },
      "tech_stack": []
    },
    "line_count": 68
  },
  "src/click/parser.py": {
    "filepath": "../click/src/click/parser.py",
    "module_docstring": "This module started out as largely a copy paste from the stdlib's\noptparse module with the features removed that we do not need from\noptparse because we implement them in Click on a higher level (for\ninstance type handling, help formatting and a lot more).\n\nThe plan is to remove more and more from here over time.\n\nThe reason this is a different module and not optparse from the stdlib\nis that there are differences in 2.x and 3.x about the error messages\ngenerated and optparse in the stdlib uses gettext for no good reason\nand might cause us issues.\n\nClick uses parts of optparse written by Gregory P. Ward and maintained\nby the Python Software Foundation. This is limited to code in parser.py.\n\nCopyright 2001-2006 Gregory P. Ward. All rights reserved.\nCopyright 2002-2006 Python Software Foundation. All rights reserved.",
    "functions": [
      {
        "name": "_unpack_args",
        "args": [
          {
            "name": "args",
            "type": "cabc.Sequence[str]"
          },
          {
            "name": "nargs_spec",
            "type": "cabc.Sequence[int]"
          }
        ],
        "return_type": "tuple[cabc.Sequence[Any], list[str]]",
        "lineno": 51,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "UNSET",
          "c.pop",
          "rv",
          "list",
          "rv.append",
          "deque",
          "len",
          "nargs",
          "TypeError",
          "reversed",
          "nargs_spec",
          "args",
          "c.popleft",
          "_fetch",
          "x.reverse",
          "range",
          "x"
        ],
        "docstring": "Given an iterable of arguments and an iterable of nargs specifications,\nit returns a tuple with all the unpacked arguments at the first index\nand all remaining arguments as the second.\n\nThe nargs specification is the number of arguments that should be consumed\nor `-1` to indicate that this position should eat up all the remainders.\n\nMissing items are filled with ``UNSET``.",
        "code": "def _unpack_args(\n    args: cabc.Sequence[str], nargs_spec: cabc.Sequence[int]\n) -> tuple[cabc.Sequence[str | cabc.Sequence[str | None] | None], list[str]]:\n    \"\"\"Given an iterable of arguments and an iterable of nargs specifications,\n    it returns a tuple with all the unpacked arguments at the first index\n    and all remaining arguments as the second.\n\n    The nargs specification is the number of arguments that should be consumed\n    or `-1` to indicate that this position should eat up all the remainders.\n\n    Missing items are filled with ``UNSET``.\n    \"\"\"\n    args = deque(args)\n    nargs_spec = deque(nargs_spec)\n    rv: list[str | tuple[str | T_UNSET, ...] | T_UNSET] = []\n    spos: int | None = None\n\n    def _fetch(c: deque[V]) -> V | T_UNSET:\n        try:\n            if spos is None:\n                return c.popleft()\n            else:\n                return c.pop()\n        except IndexError:\n            return UNSET\n\n    while nargs_spec:\n        nargs = _fetch(nargs_spec)\n\n        if nargs is None:\n            continue\n\n        if nargs == 1:\n            rv.append(_fetch(args))  # type: ignore[arg-type]\n        elif nargs > 1:\n            x = [_fetch(args) for _ in range(nargs)]\n\n            # If we're reversed, we're pulling in the arguments in reverse,\n            # so we need to turn them around.\n            if spos is not None:\n                x.reverse()\n\n            rv.append(tuple(x))\n        elif nargs < 0:\n            if spos is not None:\n                raise TypeError(\"Cannot have two nargs < 0\")\n\n            spos = len(rv)\n            rv.append(UNSET)\n\n    # spos is the position of the wildcard (star).  If it's not `None`,\n    # we fill it with the remainder.\n    if spos is not None:\n        rv[spos] = tuple(args)\n        args = []\n        rv[spos + 1 :] = reversed(rv[spos + 1 :])\n\n    return tuple(rv), list(args)",
        "line_count": 58,
        "needs_llm_summary": true
      },
      {
        "name": "_split_opt",
        "args": [
          {
            "name": "opt",
            "type": "str"
          }
        ],
        "return_type": "tuple[str, str]",
        "lineno": 111,
        "decorators": [],
        "is_async": false,
        "calls": [
          "first.isalnum"
        ],
        "docstring": null,
        "code": "def _split_opt(opt: str) -> tuple[str, str]:\n    first = opt[:1]\n    if first.isalnum():\n        return \"\", opt\n    if opt[1:2] == first:\n        return opt[:2], opt[2:]\n    return first, opt[1:]",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_normalize_opt",
        "args": [
          {
            "name": "opt",
            "type": "str"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 120,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_split_opt",
          "opt",
          "ctx.token_normalize_func"
        ],
        "docstring": null,
        "code": "def _normalize_opt(opt: str, ctx: Context | None) -> str:\n    if ctx is None or ctx.token_normalize_func is None:\n        return opt\n    prefix, opt = _split_opt(opt)\n    return f\"{prefix}{ctx.token_normalize_func(opt)}\"",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "object",
        "lineno": 502,
        "decorators": [],
        "is_async": false,
        "calls": [
          "AttributeError",
          "warnings.warn",
          "name",
          "globals",
          "DeprecationWarning"
        ],
        "docstring": null,
        "code": "def __getattr__(name: str) -> object:\n    import warnings\n\n    if name in {\n        \"OptionParser\",\n        \"Argument\",\n        \"Option\",\n        \"split_opt\",\n        \"normalize_opt\",\n        \"ParsingState\",\n    }:\n        warnings.warn(\n            f\"'parser.{name}' is deprecated and will be removed in Click 9.0.\"\n            \" The old parser is available in 'optparse'.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return globals()[f\"_{name}\"]\n\n    if name == \"split_arg_string\":\n        from .shell_completion import split_arg_string\n\n        warnings.warn(\n            \"Importing 'parser.split_arg_string' is deprecated, it will only be\"\n            \" available in 'shell_completion' in Click 9.0.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return split_arg_string\n\n    raise AttributeError(name)",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "_fetch",
        "args": [
          {
            "name": "c",
            "type": "deque[V]"
          }
        ],
        "return_type": "Any",
        "lineno": 68,
        "decorators": [],
        "is_async": false,
        "calls": [
          "c.pop",
          "c.popleft"
        ],
        "docstring": null,
        "code": "def _fetch(c: deque[V]) -> V | T_UNSET:\n        try:\n            if spos is None:\n                return c.popleft()\n            else:\n                return c.pop()\n        except IndexError:\n            return UNSET",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "CoreOption"
          },
          {
            "name": "opts",
            "type": "cabc.Sequence[str]"
          },
          {
            "name": "dest",
            "type": "Any"
          },
          {
            "name": "action",
            "type": "Any"
          },
          {
            "name": "nargs",
            "type": "int"
          },
          {
            "name": "const",
            "type": "Any"
          }
        ],
        "return_type": null,
        "lineno": 128,
        "decorators": [],
        "is_async": false,
        "calls": [
          "dest",
          "self._short_opts.append",
          "set",
          "value",
          "len",
          "opt",
          "self.prefixes.add",
          "nargs",
          "prefix",
          "ValueError",
          "_split_opt",
          "obj",
          "action",
          "self._long_opts.append",
          "const"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        obj: CoreOption,\n        opts: cabc.Sequence[str],\n        dest: str | None,\n        action: str | None = None,\n        nargs: int = 1,\n        const: t.Any | None = None,\n    ):\n        self._short_opts = []\n        self._long_opts = []\n        self.prefixes: set[str] = set()\n\n        for opt in opts:\n            prefix, value = _split_opt(opt)\n            if not prefix:\n                raise ValueError(f\"Invalid start character for option ({opt})\")\n            self.prefixes.add(prefix[0])\n            if len(prefix) == 1 and len(value) == 1:\n                self._short_opts.append(opt)\n            else:\n                self._long_opts.append(opt)\n                self.prefixes.add(prefix)\n\n        if action is None:\n            action = \"store\"\n\n        self.dest = dest\n        self.action = action\n        self.nargs = nargs\n        self.const = const\n        self.obj = obj",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "takes_value",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 162,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def takes_value(self) -> bool:\n        return self.action in (\"store\", \"append\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "process",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "state",
            "type": "_ParsingState"
          }
        ],
        "return_type": "None",
        "lineno": 165,
        "decorators": [],
        "is_async": false,
        "calls": [
          "state.opts.setdefault",
          "value",
          "self.const",
          "ValueError",
          "self.dest",
          "state.opts.get",
          "unknown.append",
          "self.obj",
          "state.order.append"
        ],
        "docstring": null,
        "code": "def process(self, value: t.Any, state: _ParsingState) -> None:\n        if self.action == \"store\":\n            state.opts[self.dest] = value  # type: ignore\n        elif self.action == \"store_const\":\n            state.opts[self.dest] = self.const  # type: ignore\n        elif self.action == \"append\":\n            state.opts.setdefault(self.dest, []).append(value)  # type: ignore\n        elif self.action == \"append_const\":\n            state.opts.setdefault(self.dest, []).append(self.const)  # type: ignore\n        elif self.action == \"count\":\n            state.opts[self.dest] = state.opts.get(self.dest, 0) + 1  # type: ignore\n        else:\n            raise ValueError(f\"unknown action '{self.action}'\")\n        state.order.append(self.obj)",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "CoreArgument"
          },
          {
            "name": "dest",
            "type": "Any"
          },
          {
            "name": "nargs",
            "type": "int"
          }
        ],
        "return_type": null,
        "lineno": 182,
        "decorators": [],
        "is_async": false,
        "calls": [
          "nargs",
          "obj",
          "dest"
        ],
        "docstring": null,
        "code": "def __init__(self, obj: CoreArgument, dest: str | None, nargs: int = 1):\n        self.dest = dest\n        self.nargs = nargs\n        self.obj = obj",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "process",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "Any"
          },
          {
            "name": "state",
            "type": "_ParsingState"
          }
        ],
        "return_type": "None",
        "lineno": 187,
        "decorators": [],
        "is_async": false,
        "calls": [
          "UNSET",
          "unknown.format",
          "value",
          "len",
          "_",
          "isinstance",
          "cabc.Sequence",
          "BadArgumentUsage",
          "self.dest",
          "sum",
          "self.nargs",
          "self.obj",
          "state.order.append"
        ],
        "docstring": null,
        "code": "def process(\n        self,\n        value: str | cabc.Sequence[str | None] | None | T_UNSET,\n        state: _ParsingState,\n    ) -> None:\n        if self.nargs > 1:\n            assert isinstance(value, cabc.Sequence)\n            holes = sum(1 for x in value if x is UNSET)\n            if holes == len(value):\n                value = UNSET\n            elif holes != 0:\n                raise BadArgumentUsage(\n                    _(\"Argument {name!r} takes {nargs} values.\").format(\n                        name=self.dest, nargs=self.nargs\n                    )\n                )\n\n        # We failed to collect any argument value so we consider the argument as unset.\n        if value == ():\n            value = UNSET\n\n        state.opts[self.dest] = value  # type: ignore\n        state.order.append(self.obj)",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "rargs",
            "type": "list[str]"
          }
        ],
        "return_type": "None",
        "lineno": 213,
        "decorators": [],
        "is_async": false,
        "calls": [
          "rargs"
        ],
        "docstring": null,
        "code": "def __init__(self, rargs: list[str]) -> None:\n        self.opts: dict[str, t.Any] = {}\n        self.largs: list[str] = []\n        self.rargs = rargs\n        self.order: list[CoreParameter] = []",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 237,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "ctx.ignore_unknown_options",
          "ctx.allow_interspersed_args"
        ],
        "docstring": null,
        "code": "def __init__(self, ctx: Context | None = None) -> None:\n        #: The :class:`~click.Context` for this parser.  This might be\n        #: `None` for some advanced use cases.\n        self.ctx = ctx\n        #: This controls how the parser deals with interspersed arguments.\n        #: If this is set to `False`, the parser will stop on the first\n        #: non-option.  Click uses this to implement nested subcommands\n        #: safely.\n        self.allow_interspersed_args: bool = True\n        #: This tells the parser how to deal with unknown options.  By\n        #: default it will error out (which is sensible), but there is a\n        #: second mode where it will ignore it and continue processing\n        #: after shifting all the unknown options into the resulting args.\n        self.ignore_unknown_options: bool = False\n\n        if ctx is not None:\n            self.allow_interspersed_args = ctx.allow_interspersed_args\n            self.ignore_unknown_options = ctx.ignore_unknown_options\n\n        self._short_opt: dict[str, _Option] = {}\n        self._long_opt: dict[str, _Option] = {}\n        self._opt_prefixes = {\"-\", \"--\"}\n        self._args: list[_Argument] = []",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "add_option",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "CoreOption"
          },
          {
            "name": "opts",
            "type": "cabc.Sequence[str]"
          },
          {
            "name": "dest",
            "type": "Any"
          },
          {
            "name": "action",
            "type": "Any"
          },
          {
            "name": "nargs",
            "type": "int"
          },
          {
            "name": "const",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 261,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._opt_prefixes.update",
          "dest",
          "_normalize_opt",
          "opt",
          "opts",
          "option.prefixes",
          "nargs",
          "option",
          "self.ctx",
          "_Option",
          "obj",
          "action",
          "const"
        ],
        "docstring": "Adds a new option named `dest` to the parser.  The destination\nis not inferred (unlike with optparse) and needs to be explicitly\nprovided.  Action can be any of ``store``, ``store_const``,\n``append``, ``append_const`` or ``count``.\n\nThe `obj` can be used to identify the option in the order list\nthat is returned from the parser.",
        "code": "def add_option(\n        self,\n        obj: CoreOption,\n        opts: cabc.Sequence[str],\n        dest: str | None,\n        action: str | None = None,\n        nargs: int = 1,\n        const: t.Any | None = None,\n    ) -> None:\n        \"\"\"Adds a new option named `dest` to the parser.  The destination\n        is not inferred (unlike with optparse) and needs to be explicitly\n        provided.  Action can be any of ``store``, ``store_const``,\n        ``append``, ``append_const`` or ``count``.\n\n        The `obj` can be used to identify the option in the order list\n        that is returned from the parser.\n        \"\"\"\n        opts = [_normalize_opt(opt, self.ctx) for opt in opts]\n        option = _Option(obj, opts, dest, action=action, nargs=nargs, const=const)\n        self._opt_prefixes.update(option.prefixes)\n        for opt in option._short_opts:\n            self._short_opt[opt] = option\n        for opt in option._long_opts:\n            self._long_opt[opt] = option",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "add_argument",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "CoreArgument"
          },
          {
            "name": "dest",
            "type": "Any"
          },
          {
            "name": "nargs",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 286,
        "decorators": [],
        "is_async": false,
        "calls": [
          "dest",
          "nargs",
          "_Argument",
          "obj",
          "self._args.append"
        ],
        "docstring": "Adds a positional argument named `dest` to the parser.\n\nThe `obj` can be used to identify the option in the order list\nthat is returned from the parser.",
        "code": "def add_argument(self, obj: CoreArgument, dest: str | None, nargs: int = 1) -> None:\n        \"\"\"Adds a positional argument named `dest` to the parser.\n\n        The `obj` can be used to identify the option in the order list\n        that is returned from the parser.\n        \"\"\"\n        self._args.append(_Argument(obj, dest=dest, nargs=nargs))",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "parse_args",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "args",
            "type": "list[str]"
          }
        ],
        "return_type": "tuple[dict[str, t.Any], list[str], list[CoreParameter]]",
        "lineno": 294,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._process_args_for_options",
          "state",
          "args",
          "_ParsingState",
          "self._process_args_for_args"
        ],
        "docstring": "Parses positional arguments and returns ``(values, args, order)``\nfor the parsed options and arguments as well as the leftover\narguments if there are any.  The order is a list of objects as they\nappear on the command line.  If arguments appear multiple times they\nwill be memorized multiple times as well.",
        "code": "def parse_args(\n        self, args: list[str]\n    ) -> tuple[dict[str, t.Any], list[str], list[CoreParameter]]:\n        \"\"\"Parses positional arguments and returns ``(values, args, order)``\n        for the parsed options and arguments as well as the leftover\n        arguments if there are any.  The order is a list of objects as they\n        appear on the command line.  If arguments appear multiple times they\n        will be memorized multiple times as well.\n        \"\"\"\n        state = _ParsingState(args)\n        try:\n            self._process_args_for_options(state)\n            self._process_args_for_args(state)\n        except UsageError:\n            if self.ctx is None or not self.ctx.resilient_parsing:\n                raise\n        return state.opts, state.largs, state.order",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "_process_args_for_args",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "state",
            "type": "_ParsingState"
          }
        ],
        "return_type": "None",
        "lineno": 312,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "_unpack_args",
          "self._args",
          "arg.process",
          "state",
          "args"
        ],
        "docstring": null,
        "code": "def _process_args_for_args(self, state: _ParsingState) -> None:\n        pargs, args = _unpack_args(\n            state.largs + state.rargs, [x.nargs for x in self._args]\n        )\n\n        for idx, arg in enumerate(self._args):\n            arg.process(pargs[idx], state)\n\n        state.largs = args\n        state.rargs = []",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "_process_args_for_options",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "state",
            "type": "_ParsingState"
          }
        ],
        "return_type": "None",
        "lineno": 323,
        "decorators": [],
        "is_async": false,
        "calls": [
          "arg",
          "len",
          "self._process_opts",
          "state.rargs.pop",
          "state",
          "state.largs.append",
          "state.rargs.insert"
        ],
        "docstring": null,
        "code": "def _process_args_for_options(self, state: _ParsingState) -> None:\n        while state.rargs:\n            arg = state.rargs.pop(0)\n            arglen = len(arg)\n            # Double dashes always handled explicitly regardless of what\n            # prefixes are valid.\n            if arg == \"--\":\n                return\n            elif arg[:1] in self._opt_prefixes and arglen > 1:\n                self._process_opts(arg, state)\n            elif self.allow_interspersed_args:\n                state.largs.append(arg)\n            else:\n                state.rargs.insert(0, arg)\n                return",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "_match_long_opt",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "opt",
            "type": "str"
          },
          {
            "name": "explicit_value",
            "type": "Any"
          },
          {
            "name": "state",
            "type": "_ParsingState"
          }
        ],
        "return_type": "None",
        "lineno": 359,
        "decorators": [],
        "is_async": false,
        "calls": [
          "state.rargs.insert",
          "UNSET",
          "explicit_value",
          "value",
          "option.process",
          "get_close_matches",
          "opt",
          "NoSuchOption",
          "_",
          "self._long_opt",
          "possibilities",
          "self.ctx",
          "option",
          "state",
          "self._get_value_from_state",
          "unknown.format",
          "BadOptionUsage"
        ],
        "docstring": null,
        "code": "def _match_long_opt(\n        self, opt: str, explicit_value: str | None, state: _ParsingState\n    ) -> None:\n        if opt not in self._long_opt:\n            from difflib import get_close_matches\n\n            possibilities = get_close_matches(opt, self._long_opt)\n            raise NoSuchOption(opt, possibilities=possibilities, ctx=self.ctx)\n\n        option = self._long_opt[opt]\n        if option.takes_value:\n            # At this point it's safe to modify rargs by injecting the\n            # explicit value, because no exception is raised in this\n            # branch.  This means that the inserted value will be fully\n            # consumed.\n            if explicit_value is not None:\n                state.rargs.insert(0, explicit_value)\n\n            value = self._get_value_from_state(opt, option, state)\n\n        elif explicit_value is not None:\n            raise BadOptionUsage(\n                opt, _(\"Option {name!r} does not take a value.\").format(name=opt)\n            )\n\n        else:\n            value = UNSET\n\n        option.process(value, state)",
        "line_count": 29,
        "needs_llm_summary": true
      },
      {
        "name": "_match_short_opt",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "arg",
            "type": "str"
          },
          {
            "name": "state",
            "type": "_ParsingState"
          }
        ],
        "return_type": "None",
        "lineno": 389,
        "decorators": [],
        "is_async": false,
        "calls": [
          "arg",
          "self._short_opt.get",
          "_normalize_opt",
          "ch",
          "len",
          "opt",
          "state.rargs.insert",
          "unknown_options",
          "NoSuchOption",
          "state.largs.append",
          "UNSET",
          "option.process",
          "self.ctx",
          "state",
          "self._get_value_from_state",
          "unknown.join",
          "value",
          "option",
          "unknown_options.append"
        ],
        "docstring": null,
        "code": "def _match_short_opt(self, arg: str, state: _ParsingState) -> None:\n        stop = False\n        i = 1\n        prefix = arg[0]\n        unknown_options = []\n\n        for ch in arg[1:]:\n            opt = _normalize_opt(f\"{prefix}{ch}\", self.ctx)\n            option = self._short_opt.get(opt)\n            i += 1\n\n            if not option:\n                if self.ignore_unknown_options:\n                    unknown_options.append(ch)\n                    continue\n                raise NoSuchOption(opt, ctx=self.ctx)\n            if option.takes_value:\n                # Any characters left in arg?  Pretend they're the\n                # next arg, and stop consuming characters of arg.\n                if i < len(arg):\n                    state.rargs.insert(0, arg[i:])\n                    stop = True\n\n                value = self._get_value_from_state(opt, option, state)\n\n            else:\n                value = UNSET\n\n            option.process(value, state)\n\n            if stop:\n                break\n\n        # If we got any unknown options we recombine the string of the\n        # remaining options and re-attach the prefix, then report that\n        # to the state as new larg.  This way there is basic combinatorics\n        # that can be achieved while still ignoring unknown arguments.\n        if self.ignore_unknown_options and unknown_options:\n            state.largs.append(f\"{prefix}{''.join(unknown_options)}\")",
        "line_count": 39,
        "needs_llm_summary": true
      },
      {
        "name": "_get_value_from_state",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "option_name",
            "type": "str"
          },
          {
            "name": "option",
            "type": "_Option"
          },
          {
            "name": "state",
            "type": "_ParsingState"
          }
        ],
        "return_type": "Any",
        "lineno": 429,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "state.rargs",
          "str",
          "len",
          "state.rargs.pop",
          "option.nargs",
          "nargs",
          "next_rarg",
          "option_name",
          "isinstance",
          "ngettext",
          "FLAG_NEEDS_VALUE",
          "unknown.format",
          "BadOptionUsage"
        ],
        "docstring": null,
        "code": "def _get_value_from_state(\n        self, option_name: str, option: _Option, state: _ParsingState\n    ) -> str | cabc.Sequence[str] | T_FLAG_NEEDS_VALUE:\n        nargs = option.nargs\n\n        value: str | cabc.Sequence[str] | T_FLAG_NEEDS_VALUE\n\n        if len(state.rargs) < nargs:\n            if option.obj._flag_needs_value:\n                # Option allows omitting the value.\n                value = FLAG_NEEDS_VALUE\n            else:\n                raise BadOptionUsage(\n                    option_name,\n                    ngettext(\n                        \"Option {name!r} requires an argument.\",\n                        \"Option {name!r} requires {nargs} arguments.\",\n                        nargs,\n                    ).format(name=option_name, nargs=nargs),\n                )\n        elif nargs == 1:\n            next_rarg = state.rargs[0]\n\n            if (\n                option.obj._flag_needs_value\n                and isinstance(next_rarg, str)\n                and next_rarg[:1] in self._opt_prefixes\n                and len(next_rarg) > 1\n            ):\n                # The next arg looks like the start of an option, don't\n                # use it as the value if omitting the value is allowed.\n                value = FLAG_NEEDS_VALUE\n            else:\n                value = state.rargs.pop(0)\n        else:\n            value = tuple(state.rargs[:nargs])\n            del state.rargs[:nargs]\n\n        return value",
        "line_count": 39,
        "needs_llm_summary": true
      },
      {
        "name": "_process_opts",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "arg",
            "type": "str"
          },
          {
            "name": "state",
            "type": "_ParsingState"
          }
        ],
        "return_type": "None",
        "lineno": 469,
        "decorators": [],
        "is_async": false,
        "calls": [
          "arg",
          "explicit_value",
          "_normalize_opt",
          "arg.split",
          "self._match_long_opt",
          "self._match_short_opt",
          "long_opt",
          "self.ctx",
          "state",
          "state.largs.append",
          "norm_long_opt"
        ],
        "docstring": null,
        "code": "def _process_opts(self, arg: str, state: _ParsingState) -> None:\n        explicit_value = None\n        # Long option handling happens in two parts.  The first part is\n        # supporting explicitly attached values.  In any case, we will try\n        # to long match the option first.\n        if \"=\" in arg:\n            long_opt, explicit_value = arg.split(\"=\", 1)\n        else:\n            long_opt = arg\n        norm_long_opt = _normalize_opt(long_opt, self.ctx)\n\n        # At this point we will match the (assumed) long option through\n        # the long option matching code.  Note that this allows options\n        # like \"-foo\" to be matched as long options.\n        try:\n            self._match_long_opt(norm_long_opt, explicit_value, state)\n        except NoSuchOption:\n            # At this point the long option matching failed, and we need\n            # to try with short options.  However there is a special rule\n            # which says, that if we have a two character options prefix\n            # (applies to \"--foo\" for instance), we do not dispatch to the\n            # short option code and will instead raise the no option\n            # error.\n            if arg[:2] not in self._opt_prefixes:\n                self._match_short_opt(arg, state)\n                return\n\n            if not self.ignore_unknown_options:\n                raise\n\n            state.largs.append(arg)",
        "line_count": 31,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "_Option",
        "methods": [
          "__init__",
          "takes_value",
          "process"
        ],
        "base_classes": [],
        "lineno": 127,
        "docstring": null
      },
      {
        "name": "_Argument",
        "methods": [
          "__init__",
          "process"
        ],
        "base_classes": [],
        "lineno": 181,
        "docstring": null
      },
      {
        "name": "_ParsingState",
        "methods": [
          "__init__"
        ],
        "base_classes": [],
        "lineno": 212,
        "docstring": null
      },
      {
        "name": "_OptionParser",
        "methods": [
          "__init__",
          "add_option",
          "add_argument",
          "parse_args",
          "_process_args_for_args",
          "_process_args_for_options",
          "_match_long_opt",
          "_match_short_opt",
          "_get_value_from_state",
          "_process_opts"
        ],
        "base_classes": [],
        "lineno": 220,
        "docstring": "The option parser is an internal class that is ultimately used to\nparse options and arguments.  It's modelled after optparse and brings\na similar but vastly simplified API.  It should generally not be used\ndirectly as the high level Click classes wrap it for you.\n\nIt's not nearly as extensible as optparse or argparse as it does not\nimplement features that are implemented on a higher level (such as\ntypes or defaults).\n\n:param ctx: optionally the :class:`~click.Context` where this parser\n            should go with.\n\n.. deprecated:: 8.2\n    Will be removed in Click 9.0."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 27,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 28,
        "type": "import"
      },
      {
        "module": "collections",
        "name": "deque",
        "alias": null,
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "ngettext",
        "alias": null,
        "lineno": 31,
        "type": "from_import"
      },
      {
        "module": "_utils",
        "name": "FLAG_NEEDS_VALUE",
        "alias": null,
        "lineno": 33,
        "type": "from_import"
      },
      {
        "module": "_utils",
        "name": "UNSET",
        "alias": null,
        "lineno": 34,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "BadArgumentUsage",
        "alias": null,
        "lineno": 35,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "BadOptionUsage",
        "alias": null,
        "lineno": 36,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "NoSuchOption",
        "alias": null,
        "lineno": 37,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "UsageError",
        "alias": null,
        "lineno": 38,
        "type": "from_import"
      },
      {
        "module": "_utils",
        "name": "T_FLAG_NEEDS_VALUE",
        "alias": null,
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "_utils",
        "name": "T_UNSET",
        "alias": null,
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Argument",
        "alias": "CoreArgument",
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Context",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Option",
        "alias": "CoreOption",
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Parameter",
        "alias": "CoreParameter",
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "warnings",
        "alias": null,
        "lineno": 503,
        "type": "import"
      },
      {
        "module": "shell_completion",
        "name": "split_arg_string",
        "alias": null,
        "lineno": 522,
        "type": "from_import"
      },
      {
        "module": "difflib",
        "name": "get_close_matches",
        "alias": null,
        "lineno": 363,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "V",
        "assigned_to": "t.TypeVar",
        "lineno": 48
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "t.TypeVar"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "collections",
        "warnings",
        "typing"
      ],
      "third_party": {
        "other": [
          "__future__",
          "gettext",
          "_utils",
          "exceptions",
          "core",
          "shell_completion",
          "difflib"
        ]
      },
      "tech_stack": []
    },
    "line_count": 533
  },
  "src/click/shell_completion.py": {
    "filepath": "../click/src/click/shell_completion.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "shell_complete",
        "args": [
          {
            "name": "cli",
            "type": "Command"
          },
          {
            "name": "ctx_args",
            "type": "cabc.MutableMapping[str, t.Any]"
          },
          {
            "name": "prog_name",
            "type": "str"
          },
          {
            "name": "complete_var",
            "type": "str"
          },
          {
            "name": "instruction",
            "type": "str"
          }
        ],
        "return_type": "int",
        "lineno": 19,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "comp.complete",
          "shell",
          "cli",
          "prog_name",
          "ctx_args",
          "get_completion_class",
          "instruction.partition",
          "comp.source",
          "comp_cls",
          "complete_var"
        ],
        "docstring": "Perform shell completion for the given CLI program.\n\n:param cli: Command being called.\n:param ctx_args: Extra arguments to pass to\n    ``cli.make_context``.\n:param prog_name: Name of the executable in the shell.\n:param complete_var: Name of the environment variable that holds\n    the completion instruction.\n:param instruction: Value of ``complete_var`` with the completion\n    instruction and shell, in the form ``instruction_shell``.\n:return: Status code to exit with.",
        "code": "def shell_complete(\n    cli: Command,\n    ctx_args: cabc.MutableMapping[str, t.Any],\n    prog_name: str,\n    complete_var: str,\n    instruction: str,\n) -> int:\n    \"\"\"Perform shell completion for the given CLI program.\n\n    :param cli: Command being called.\n    :param ctx_args: Extra arguments to pass to\n        ``cli.make_context``.\n    :param prog_name: Name of the executable in the shell.\n    :param complete_var: Name of the environment variable that holds\n        the completion instruction.\n    :param instruction: Value of ``complete_var`` with the completion\n        instruction and shell, in the form ``instruction_shell``.\n    :return: Status code to exit with.\n    \"\"\"\n    shell, _, instruction = instruction.partition(\"_\")\n    comp_cls = get_completion_class(shell)\n\n    if comp_cls is None:\n        return 1\n\n    comp = comp_cls(cli, ctx_args, prog_name, complete_var)\n\n    if instruction == \"source\":\n        echo(comp.source())\n        return 0\n\n    if instruction == \"complete\":\n        echo(comp.complete())\n        return 0\n\n    return 1",
        "line_count": 36,
        "needs_llm_summary": true
      },
      {
        "name": "add_completion_class",
        "args": [
          {
            "name": "cls",
            "type": "ShellCompleteType"
          },
          {
            "name": "name",
            "type": "Any"
          }
        ],
        "return_type": "ShellCompleteType",
        "lineno": 436,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cls",
          "cls.name"
        ],
        "docstring": "Register a :class:`ShellComplete` subclass under the given name.\nThe name will be provided by the completion instruction environment\nvariable during completion.\n\n:param cls: The completion class that will handle completion for the\n    shell.\n:param name: Name to register the class under. Defaults to the\n    class's ``name`` attribute.",
        "code": "def add_completion_class(\n    cls: ShellCompleteType, name: str | None = None\n) -> ShellCompleteType:\n    \"\"\"Register a :class:`ShellComplete` subclass under the given name.\n    The name will be provided by the completion instruction environment\n    variable during completion.\n\n    :param cls: The completion class that will handle completion for the\n        shell.\n    :param name: Name to register the class under. Defaults to the\n        class's ``name`` attribute.\n    \"\"\"\n    if name is None:\n        name = cls.name\n\n    _available_shells[name] = cls\n\n    return cls",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "get_completion_class",
        "args": [
          {
            "name": "shell",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 456,
        "decorators": [],
        "is_async": false,
        "calls": [
          "shell",
          "_available_shells.get"
        ],
        "docstring": "Look up a registered :class:`ShellComplete` subclass by the name\nprovided by the completion instruction environment variable. If the\nname isn't registered, returns ``None``.\n\n:param shell: Name the class is registered under.",
        "code": "def get_completion_class(shell: str) -> type[ShellComplete] | None:\n    \"\"\"Look up a registered :class:`ShellComplete` subclass by the name\n    provided by the completion instruction environment variable. If the\n    name isn't registered, returns ``None``.\n\n    :param shell: Name the class is registered under.\n    \"\"\"\n    return _available_shells.get(shell)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "split_arg_string",
        "args": [
          {
            "name": "string",
            "type": "str"
          }
        ],
        "return_type": "list[str]",
        "lineno": 466,
        "decorators": [],
        "is_async": false,
        "calls": [
          "shlex.shlex",
          "lex.token",
          "token",
          "string",
          "out.append"
        ],
        "docstring": "Split an argument string as with :func:`shlex.split`, but don't\nfail if the string is incomplete. Ignores a missing closing quote or\nincomplete escape sequence and uses the partial token as-is.\n\n.. code-block:: python\n\n    split_arg_string(\"example 'my file\")\n    [\"example\", \"my file\"]\n\n    split_arg_string(\"example my\\\")\n    [\"example\", \"my\"]\n\n:param string: String to split.\n\n.. versionchanged:: 8.2\n    Moved to ``shell_completion`` from ``parser``.",
        "code": "def split_arg_string(string: str) -> list[str]:\n    \"\"\"Split an argument string as with :func:`shlex.split`, but don't\n    fail if the string is incomplete. Ignores a missing closing quote or\n    incomplete escape sequence and uses the partial token as-is.\n\n    .. code-block:: python\n\n        split_arg_string(\"example 'my file\")\n        [\"example\", \"my file\"]\n\n        split_arg_string(\"example my\\\\\")\n        [\"example\", \"my\"]\n\n    :param string: String to split.\n\n    .. versionchanged:: 8.2\n        Moved to ``shell_completion`` from ``parser``.\n    \"\"\"\n    import shlex\n\n    lex = shlex.shlex(string, posix=True)\n    lex.whitespace_split = True\n    lex.commenters = \"\"\n    out = []\n\n    try:\n        for token in lex:\n            out.append(token)\n    except ValueError:\n        # Raised when end-of-string is reached in an invalid state. Use\n        # the partial token as-is. The quote or escape character is in\n        # lex.state, not lex.token.\n        out.append(lex.token)\n\n    return out",
        "line_count": 35,
        "needs_llm_summary": true
      },
      {
        "name": "_is_incomplete_argument",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Parameter"
          }
        ],
        "return_type": "bool",
        "lineno": 503,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Argument",
          "param",
          "param.name",
          "ctx.params.get",
          "ctx.get_parameter_source",
          "value",
          "len",
          "isinstance"
        ],
        "docstring": "Determine if the given parameter is an argument that can still\naccept values.\n\n:param ctx: Invocation context for the command represented by the\n    parsed complete args.\n:param param: Argument object being checked.",
        "code": "def _is_incomplete_argument(ctx: Context, param: Parameter) -> bool:\n    \"\"\"Determine if the given parameter is an argument that can still\n    accept values.\n\n    :param ctx: Invocation context for the command represented by the\n        parsed complete args.\n    :param param: Argument object being checked.\n    \"\"\"\n    if not isinstance(param, Argument):\n        return False\n\n    assert param.name is not None\n    # Will be None if expose_value is False.\n    value = ctx.params.get(param.name)\n    return (\n        param.nargs == -1\n        or ctx.get_parameter_source(param.name) is not ParameterSource.COMMANDLINE\n        or (\n            param.nargs > 1\n            and isinstance(value, (tuple, list))\n            and len(value) < param.nargs\n        )\n    )",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "_start_of_option",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "value",
            "type": "str"
          }
        ],
        "return_type": "bool",
        "lineno": 528,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Check if the value looks like the start of an option.",
        "code": "def _start_of_option(ctx: Context, value: str) -> bool:\n    \"\"\"Check if the value looks like the start of an option.\"\"\"\n    if not value:\n        return False\n\n    c = value[0]\n    return c in ctx._opt_prefixes",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_is_incomplete_option",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "args",
            "type": "list[str]"
          },
          {
            "name": "param",
            "type": "Parameter"
          }
        ],
        "return_type": "bool",
        "lineno": 537,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "arg",
          "param",
          "ctx",
          "isinstance",
          "reversed",
          "args",
          "Option",
          "_start_of_option"
        ],
        "docstring": "Determine if the given parameter is an option that needs a value.\n\n:param args: List of complete args before the incomplete value.\n:param param: Option object being checked.",
        "code": "def _is_incomplete_option(ctx: Context, args: list[str], param: Parameter) -> bool:\n    \"\"\"Determine if the given parameter is an option that needs a value.\n\n    :param args: List of complete args before the incomplete value.\n    :param param: Option object being checked.\n    \"\"\"\n    if not isinstance(param, Option):\n        return False\n\n    if param.is_flag or param.count:\n        return False\n\n    last_option = None\n\n    for index, arg in enumerate(reversed(args)):\n        if index + 1 > param.nargs:\n            break\n\n        if _start_of_option(ctx, arg):\n            last_option = arg\n            break\n\n    return last_option is not None and last_option in param.opts",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "_resolve_context",
        "args": [
          {
            "name": "cli",
            "type": "Command"
          },
          {
            "name": "ctx_args",
            "type": "cabc.MutableMapping[str, t.Any]"
          },
          {
            "name": "prog_name",
            "type": "str"
          },
          {
            "name": "args",
            "type": "list[str]"
          }
        ],
        "return_type": "Context",
        "lineno": 562,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cli.make_context",
          "cmd.make_context",
          "sub_sub_ctx",
          "ctx",
          "name",
          "command",
          "args.copy",
          "prog_name",
          "isinstance",
          "ctx_args",
          "command.resolve_command",
          "args",
          "sub_ctx.args",
          "ctx.command",
          "Group",
          "sub_ctx"
        ],
        "docstring": "Produce the context hierarchy starting with the command and\ntraversing the complete arguments. This only follows the commands,\nit doesn't trigger input prompts or callbacks.\n\n:param cli: Command being called.\n:param prog_name: Name of the executable in the shell.\n:param args: List of complete args before the incomplete value.",
        "code": "def _resolve_context(\n    cli: Command,\n    ctx_args: cabc.MutableMapping[str, t.Any],\n    prog_name: str,\n    args: list[str],\n) -> Context:\n    \"\"\"Produce the context hierarchy starting with the command and\n    traversing the complete arguments. This only follows the commands,\n    it doesn't trigger input prompts or callbacks.\n\n    :param cli: Command being called.\n    :param prog_name: Name of the executable in the shell.\n    :param args: List of complete args before the incomplete value.\n    \"\"\"\n    ctx_args[\"resilient_parsing\"] = True\n    with cli.make_context(prog_name, args.copy(), **ctx_args) as ctx:\n        args = ctx._protected_args + ctx.args\n\n        while args:\n            command = ctx.command\n\n            if isinstance(command, Group):\n                if not command.chain:\n                    name, cmd, args = command.resolve_command(ctx, args)\n\n                    if cmd is None:\n                        return ctx\n\n                    with cmd.make_context(\n                        name, args, parent=ctx, resilient_parsing=True\n                    ) as sub_ctx:\n                        ctx = sub_ctx\n                        args = ctx._protected_args + ctx.args\n                else:\n                    sub_ctx = ctx\n\n                    while args:\n                        name, cmd, args = command.resolve_command(ctx, args)\n\n                        if cmd is None:\n                            return ctx\n\n                        with cmd.make_context(\n                            name,\n                            args,\n                            parent=ctx,\n                            allow_extra_args=True,\n                            allow_interspersed_args=False,\n                            resilient_parsing=True,\n                        ) as sub_sub_ctx:\n                            sub_ctx = sub_sub_ctx\n                            args = sub_ctx.args\n\n                    ctx = sub_ctx\n                    args = [*sub_ctx._protected_args, *sub_ctx.args]\n            else:\n                break\n\n    return ctx",
        "line_count": 59,
        "needs_llm_summary": true
      },
      {
        "name": "_resolve_incomplete",
        "args": [
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "args",
            "type": "list[str]"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "tuple[Any, str]",
        "lineno": 623,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx.command.get_params",
          "incomplete",
          "param",
          "ctx",
          "_is_incomplete_argument",
          "args.append",
          "name",
          "_is_incomplete_option",
          "incomplete.partition",
          "args",
          "_start_of_option"
        ],
        "docstring": "Find the Click object that will handle the completion of the\nincomplete value. Return the object and the incomplete value.\n\n:param ctx: Invocation context for the command represented by\n    the parsed complete args.\n:param args: List of complete args before the incomplete value.\n:param incomplete: Value being completed. May be empty.",
        "code": "def _resolve_incomplete(\n    ctx: Context, args: list[str], incomplete: str\n) -> tuple[Command | Parameter, str]:\n    \"\"\"Find the Click object that will handle the completion of the\n    incomplete value. Return the object and the incomplete value.\n\n    :param ctx: Invocation context for the command represented by\n        the parsed complete args.\n    :param args: List of complete args before the incomplete value.\n    :param incomplete: Value being completed. May be empty.\n    \"\"\"\n    # Different shells treat an \"=\" between a long option name and\n    # value differently. Might keep the value joined, return the \"=\"\n    # as a separate item, or return the split name and value. Always\n    # split and discard the \"=\" to make completion easier.\n    if incomplete == \"=\":\n        incomplete = \"\"\n    elif \"=\" in incomplete and _start_of_option(ctx, incomplete):\n        name, _, incomplete = incomplete.partition(\"=\")\n        args.append(name)\n\n    # The \"--\" marker tells Click to stop treating values as options\n    # even if they start with the option character. If it hasn't been\n    # given and the incomplete arg looks like an option, the current\n    # command will provide option name completions.\n    if \"--\" not in args and _start_of_option(ctx, incomplete):\n        return ctx.command, incomplete\n\n    params = ctx.command.get_params(ctx)\n\n    # If the last complete arg is an option name with an incomplete\n    # value, the option will provide value completions.\n    for param in params:\n        if _is_incomplete_option(ctx, args, param):\n            return param, incomplete\n\n    # It's not an option name or value. The first argument without a\n    # parsed value will provide value completions.\n    for param in params:\n        if _is_incomplete_argument(ctx, param):\n            return param, incomplete\n\n    # There were no unparsed arguments, the command may be a group that\n    # will provide command name completions.\n    return ctx.command, incomplete",
        "line_count": 45,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "type",
            "type": "str"
          },
          {
            "name": "help",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 78,
        "decorators": [],
        "is_async": false,
        "calls": [
          "kwargs"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        value: t.Any,\n        type: str = \"plain\",\n        help: str | None = None,\n        **kwargs: t.Any,\n    ) -> None:\n        self.value: t.Any = value\n        self.type: str = type\n        self.help: str | None = help\n        self._info = kwargs",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "t.Any",
        "lineno": 90,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "self._info.get"
        ],
        "docstring": null,
        "code": "def __getattr__(self, name: str) -> t.Any:\n        return self._info.get(name)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "cli",
            "type": "Command"
          },
          {
            "name": "ctx_args",
            "type": "cabc.MutableMapping[str, t.Any]"
          },
          {
            "name": "prog_name",
            "type": "str"
          },
          {
            "name": "complete_var",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 224,
        "decorators": [],
        "is_async": false,
        "calls": [
          "prog_name",
          "ctx_args",
          "complete_var",
          "cli"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        cli: Command,\n        ctx_args: cabc.MutableMapping[str, t.Any],\n        prog_name: str,\n        complete_var: str,\n    ) -> None:\n        self.cli = cli\n        self.ctx_args = ctx_args\n        self.prog_name = prog_name\n        self.complete_var = complete_var",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "func_name",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 237,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "re.ASCII",
          "self.prog_name.replace",
          "re.sub"
        ],
        "docstring": "The name of the shell function defined by the completion\nscript.",
        "code": "def func_name(self) -> str:\n        \"\"\"The name of the shell function defined by the completion\n        script.\n        \"\"\"\n        safe_name = re.sub(r\"\\W*\", \"\", self.prog_name.replace(\"-\", \"_\"), flags=re.ASCII)\n        return f\"_{safe_name}_completion\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "source_vars",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 244,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Vars for formatting :attr:`source_template`.\n\nBy default this provides ``complete_func``, ``complete_var``,\nand ``prog_name``.",
        "code": "def source_vars(self) -> dict[str, t.Any]:\n        \"\"\"Vars for formatting :attr:`source_template`.\n\n        By default this provides ``complete_func``, ``complete_var``,\n        and ``prog_name``.\n        \"\"\"\n        return {\n            \"complete_func\": self.func_name,\n            \"complete_var\": self.complete_var,\n            \"prog_name\": self.prog_name,\n        }",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "source",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 256,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.source_vars"
        ],
        "docstring": "Produce the shell script that defines the completion\nfunction. By default this ``%``-style formats\n:attr:`source_template` with the dict returned by\n:meth:`source_vars`.",
        "code": "def source(self) -> str:\n        \"\"\"Produce the shell script that defines the completion\n        function. By default this ``%``-style formats\n        :attr:`source_template` with the dict returned by\n        :meth:`source_vars`.\n        \"\"\"\n        return self.source_template % self.source_vars()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "get_completion_args",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "tuple[list[str], str]",
        "lineno": 264,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Use the env vars defined by the shell script to return a\ntuple of ``args, incomplete``. This must be implemented by\nsubclasses.",
        "code": "def get_completion_args(self) -> tuple[list[str], str]:\n        \"\"\"Use the env vars defined by the shell script to return a\n        tuple of ``args, incomplete``. This must be implemented by\n        subclasses.\n        \"\"\"\n        raise NotImplementedError",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "get_completions",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "args",
            "type": "list[str]"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "list[CompletionItem]",
        "lineno": 271,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.cli",
          "_resolve_incomplete",
          "incomplete",
          "_resolve_context",
          "ctx",
          "obj.shell_complete",
          "self.prog_name",
          "self.ctx_args",
          "args"
        ],
        "docstring": "Determine the context and last complete command or parameter\nfrom the complete args. Call that object's ``shell_complete``\nmethod to get the completions for the incomplete value.\n\n:param args: List of complete args before the incomplete value.\n:param incomplete: Value being completed. May be empty.",
        "code": "def get_completions(self, args: list[str], incomplete: str) -> list[CompletionItem]:\n        \"\"\"Determine the context and last complete command or parameter\n        from the complete args. Call that object's ``shell_complete``\n        method to get the completions for the incomplete value.\n\n        :param args: List of complete args before the incomplete value.\n        :param incomplete: Value being completed. May be empty.\n        \"\"\"\n        ctx = _resolve_context(self.cli, self.ctx_args, self.prog_name, args)\n        obj, incomplete = _resolve_incomplete(ctx, args, incomplete)\n        return obj.shell_complete(ctx, incomplete)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "format_completion",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "item",
            "type": "CompletionItem"
          }
        ],
        "return_type": "str",
        "lineno": 283,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Format a completion item into the form recognized by the\nshell script. This must be implemented by subclasses.\n\n:param item: Completion item to format.",
        "code": "def format_completion(self, item: CompletionItem) -> str:\n        \"\"\"Format a completion item into the form recognized by the\n        shell script. This must be implemented by subclasses.\n\n        :param item: Completion item to format.\n        \"\"\"\n        raise NotImplementedError",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "complete",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 291,
        "decorators": [],
        "is_async": false,
        "calls": [
          "out",
          "unknown.join",
          "incomplete",
          "self.get_completion_args",
          "self.format_completion",
          "args",
          "self.get_completions",
          "item"
        ],
        "docstring": "Produce the completion data to send back to the shell.\n\nBy default this calls :meth:`get_completion_args`, gets the\ncompletions, then calls :meth:`format_completion` for each\ncompletion.",
        "code": "def complete(self) -> str:\n        \"\"\"Produce the completion data to send back to the shell.\n\n        By default this calls :meth:`get_completion_args`, gets the\n        completions, then calls :meth:`format_completion` for each\n        completion.\n        \"\"\"\n        args, incomplete = self.get_completion_args()\n        completions = self.get_completions(args, incomplete)\n        out = [self.format_completion(item) for item in completions]\n        return \"\\n\".join(out)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "_check_version",
        "args": [],
        "return_type": "None",
        "lineno": 311,
        "decorators": [
          {
            "name": "staticmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "echo",
          "re.search",
          "shutil.which",
          "_",
          "subprocess.PIPE",
          "output.stdout.decode",
          "subprocess.run",
          "match.groups"
        ],
        "docstring": null,
        "code": "def _check_version() -> None:\n        import shutil\n        import subprocess\n\n        bash_exe = shutil.which(\"bash\")\n\n        if bash_exe is None:\n            match = None\n        else:\n            output = subprocess.run(\n                [bash_exe, \"--norc\", \"-c\", 'echo \"${BASH_VERSION}\"'],\n                stdout=subprocess.PIPE,\n            )\n            match = re.search(r\"^(\\d+)\\.(\\d+)\\.\\d+\", output.stdout.decode())\n\n        if match is not None:\n            major, minor = match.groups()\n\n            if major < \"4\" or major == \"4\" and minor < \"4\":\n                echo(\n                    _(\n                        \"Shell completion is not supported for Bash\"\n                        \" versions older than 4.4.\"\n                    ),\n                    err=True,\n                )\n        else:\n            echo(\n                _(\"Couldn't detect Bash version, shell completion is not supported.\"),\n                err=True,\n            )",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "source",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 343,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "self._check_version",
          "unknown.source"
        ],
        "docstring": null,
        "code": "def source(self) -> str:\n        self._check_version()\n        return super().source()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get_completion_args",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "tuple[list[str], str]",
        "lineno": 347,
        "decorators": [],
        "is_async": false,
        "calls": [
          "split_arg_string",
          "int"
        ],
        "docstring": null,
        "code": "def get_completion_args(self) -> tuple[list[str], str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n        cword = int(os.environ[\"COMP_CWORD\"])\n        args = cwords[1:cword]\n\n        try:\n            incomplete = cwords[cword]\n        except IndexError:\n            incomplete = \"\"\n\n        return args, incomplete",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "format_completion",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "item",
            "type": "CompletionItem"
          }
        ],
        "return_type": "str",
        "lineno": 359,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def format_completion(self, item: CompletionItem) -> str:\n        return f\"{item.type},{item.value}\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "get_completion_args",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "tuple[list[str], str]",
        "lineno": 369,
        "decorators": [],
        "is_async": false,
        "calls": [
          "split_arg_string",
          "int"
        ],
        "docstring": null,
        "code": "def get_completion_args(self) -> tuple[list[str], str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n        cword = int(os.environ[\"COMP_CWORD\"])\n        args = cwords[1:cword]\n\n        try:\n            incomplete = cwords[cword]\n        except IndexError:\n            incomplete = \"\"\n\n        return args, incomplete",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "format_completion",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "item",
            "type": "CompletionItem"
          }
        ],
        "return_type": "str",
        "lineno": 381,
        "decorators": [],
        "is_async": false,
        "calls": [
          "item.value.replace"
        ],
        "docstring": null,
        "code": "def format_completion(self, item: CompletionItem) -> str:\n        help_ = item.help or \"_\"\n        # The zsh completion script uses `_describe` on items with help\n        # texts (which splits the item help from the item value at the\n        # first unescaped colon) and `compadd` on items without help\n        # text (which uses the item value as-is and does not support\n        # colon escaping).  So escape colons in the item value if and\n        # only if the item help is not the sentinel \"_\" value, as used\n        # by the completion script.\n        #\n        # (The zsh completion script is potentially widely deployed, and\n        # thus harder to fix than this method.)\n        #\n        # See issue #1812 and issue #2703 for further context.\n        value = item.value.replace(\":\", r\"\\:\") if help_ != \"_\" else item.value\n        return f\"{item.type}\\n{value}\\n{help_}\"",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "get_completion_args",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "tuple[list[str], str]",
        "lineno": 405,
        "decorators": [],
        "is_async": false,
        "calls": [
          "split_arg_string",
          "incomplete",
          "args.pop"
        ],
        "docstring": null,
        "code": "def get_completion_args(self) -> tuple[list[str], str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n        incomplete = os.environ[\"COMP_CWORD\"]\n        if incomplete:\n            incomplete = split_arg_string(incomplete)[0]\n        args = cwords[1:]\n\n        # Fish stores the partial word in both COMP_WORDS and\n        # COMP_CWORD, remove it from complete args.\n        if incomplete and args and args[-1] == incomplete:\n            args.pop()\n\n        return args, incomplete",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "format_completion",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "item",
            "type": "CompletionItem"
          }
        ],
        "return_type": "str",
        "lineno": 419,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def format_completion(self, item: CompletionItem) -> str:\n        if item.help:\n            return f\"{item.type},{item.value}\\t{item.help}\"\n\n        return f\"{item.type},{item.value}\"",
        "line_count": 5,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "CompletionItem",
        "methods": [
          "__init__",
          "__getattr__"
        ],
        "base_classes": [],
        "lineno": 57,
        "docstring": "Represents a completion value and metadata about the value. The\ndefault metadata is ``type`` to indicate special shell handling,\nand ``help`` if a shell supports showing a help string next to the\nvalue.\n\nArbitrary parameters can be passed when creating the object, and\naccessed using ``item.attr``. If an attribute wasn't passed,\naccessing it returns ``None``.\n\n:param value: The completion suggestion.\n:param type: Tells the shell script to provide special completion\n    support for the type. Click uses ``\"dir\"`` and ``\"file\"``.\n:param help: String shown next to the value if supported.\n:param kwargs: Arbitrary metadata. The built-in implementations\n    don't use this, but custom type completions paired with custom\n    shell support could use it."
      },
      {
        "name": "ShellComplete",
        "methods": [
          "__init__",
          "func_name",
          "source_vars",
          "source",
          "get_completion_args",
          "get_completions",
          "format_completion",
          "complete"
        ],
        "base_classes": [],
        "lineno": 200,
        "docstring": "Base class for providing shell completion support. A subclass for\na given shell will override attributes and methods to implement the\ncompletion instructions (``source`` and ``complete``).\n\n:param cli: Command being called.\n:param prog_name: Name of the executable in the shell.\n:param complete_var: Name of the environment variable that holds\n    the completion instruction.\n\n.. versionadded:: 8.0"
      },
      {
        "name": "BashComplete",
        "methods": [
          "_check_version",
          "source",
          "get_completion_args",
          "format_completion"
        ],
        "base_classes": [
          "ShellComplete"
        ],
        "lineno": 304,
        "docstring": "Shell completion for Bash."
      },
      {
        "name": "ZshComplete",
        "methods": [
          "get_completion_args",
          "format_completion"
        ],
        "base_classes": [
          "ShellComplete"
        ],
        "lineno": 363,
        "docstring": "Shell completion for Zsh."
      },
      {
        "name": "FishComplete",
        "methods": [
          "get_completion_args",
          "format_completion"
        ],
        "base_classes": [
          "ShellComplete"
        ],
        "lineno": 399,
        "docstring": "Shell completion for Fish."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "re",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Argument",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Command",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Context",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Group",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Option",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Parameter",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "ParameterSource",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "echo",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "shlex",
        "alias": null,
        "lineno": 484,
        "type": "import"
      },
      {
        "module": "shutil",
        "alias": null,
        "lineno": 312,
        "type": "import"
      },
      {
        "module": "subprocess",
        "alias": null,
        "lineno": 313,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "_SOURCE_BASH",
        "assigned_to": "str",
        "lineno": 95
      },
      {
        "name": "_SOURCE_ZSH",
        "assigned_to": "str",
        "lineno": 133
      },
      {
        "name": "_SOURCE_FISH",
        "assigned_to": "str",
        "lineno": 177
      },
      {
        "name": "ShellCompleteType",
        "assigned_to": "t.TypeVar",
        "lineno": 426
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "t.TypeVar"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "re",
        "shutil",
        "typing",
        "os",
        "subprocess",
        "collections"
      ],
      "third_party": {
        "other": [
          "__future__",
          "gettext",
          "core",
          "utils",
          "shlex"
        ]
      },
      "tech_stack": []
    },
    "line_count": 668
  },
  "src/click/termui.py": {
    "filepath": "../click/src/click/termui.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "hidden_prompt_func",
        "args": [
          {
            "name": "prompt",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 54,
        "decorators": [],
        "is_async": false,
        "calls": [
          "prompt",
          "getpass.getpass"
        ],
        "docstring": null,
        "code": "def hidden_prompt_func(prompt: str) -> str:\n    import getpass\n\n    return getpass.getpass(prompt)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "_build_prompt",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "suffix",
            "type": "str"
          },
          {
            "name": "show_default",
            "type": "bool"
          },
          {
            "name": "default",
            "type": "Any"
          },
          {
            "name": "show_choices",
            "type": "bool"
          },
          {
            "name": "type",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 60,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "type.choices",
          "_format_default",
          "type",
          "unknown.join",
          "str",
          "isinstance",
          "Choice",
          "default",
          "map"
        ],
        "docstring": null,
        "code": "def _build_prompt(\n    text: str,\n    suffix: str,\n    show_default: bool = False,\n    default: t.Any | None = None,\n    show_choices: bool = True,\n    type: ParamType | None = None,\n) -> str:\n    prompt = text\n    if type is not None and show_choices and isinstance(type, Choice):\n        prompt += f\" ({', '.join(map(str, type.choices))})\"\n    if default is not None and show_default:\n        prompt = f\"{prompt} [{_format_default(default)}]\"\n    return f\"{prompt}{suffix}\"",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "_format_default",
        "args": [
          {
            "name": "default",
            "type": "t.Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "hasattr",
          "default"
        ],
        "docstring": null,
        "code": "def _format_default(default: t.Any) -> t.Any:\n    if isinstance(default, (io.IOBase, LazyFile)) and hasattr(default, \"name\"):\n        return default.name\n\n    return default",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "prompt",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "default",
            "type": "Any"
          },
          {
            "name": "hide_input",
            "type": "bool"
          },
          {
            "name": "confirmation_prompt",
            "type": "Any"
          },
          {
            "name": "type",
            "type": "Any"
          },
          {
            "name": "value_proc",
            "type": "Any"
          },
          {
            "name": "prompt_suffix",
            "type": "str"
          },
          {
            "name": "show_default",
            "type": "bool"
          },
          {
            "name": "err",
            "type": "bool"
          },
          {
            "name": "show_choices",
            "type": "bool"
          }
        ],
        "return_type": "t.Any",
        "lineno": 83,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "echo",
          "type",
          "confirmation_prompt",
          "f",
          "default",
          "unknown.format",
          "prompt_func",
          "_",
          "show_choices",
          "Abort",
          "_build_prompt",
          "prompt_suffix",
          "e",
          "show_default",
          "convert_type",
          "value",
          "err",
          "prompt",
          "value_proc"
        ],
        "docstring": "Prompts a user for input.  This is a convenience function that can\nbe used to prompt a user for input later.\n\nIf the user aborts the input by sending an interrupt signal, this\nfunction will catch it and raise a :exc:`Abort` exception.\n\n:param text: the text to show for the prompt.\n:param default: the default value to use if no input happens.  If this\n                is not given it will prompt until it's aborted.\n:param hide_input: if this is set to true then the input value will\n                   be hidden.\n:param confirmation_prompt: Prompt a second time to confirm the\n    value. Can be set to a string instead of ``True`` to customize\n    the message.\n:param type: the type to use to check the value against.\n:param value_proc: if this parameter is provided it's a function that\n                   is invoked instead of the type conversion to\n                   convert a value.\n:param prompt_suffix: a suffix that should be added to the prompt.\n:param show_default: shows or hides the default value in the prompt.\n:param err: if set to true the file defaults to ``stderr`` instead of\n            ``stdout``, the same as with echo.\n:param show_choices: Show or hide choices if the passed type is a Choice.\n                     For example if type is a Choice of either day or week,\n                     show_choices is true and text is \"Group by\" then the\n                     prompt will be \"Group by (day, week): \".\n\n.. versionchanged:: 8.3.1\n    A space is no longer appended to the prompt.\n\n.. versionadded:: 8.0\n    ``confirmation_prompt`` can be a custom string.\n\n.. versionadded:: 7.0\n    Added the ``show_choices`` parameter.\n\n.. versionadded:: 6.0\n    Added unicode support for cmd.exe on Windows.\n\n.. versionadded:: 4.0\n    Added the `err` parameter.",
        "code": "def prompt(\n    text: str,\n    default: t.Any | None = None,\n    hide_input: bool = False,\n    confirmation_prompt: bool | str = False,\n    type: ParamType | t.Any | None = None,\n    value_proc: t.Callable[[str], t.Any] | None = None,\n    prompt_suffix: str = \": \",\n    show_default: bool = True,\n    err: bool = False,\n    show_choices: bool = True,\n) -> t.Any:\n    \"\"\"Prompts a user for input.  This is a convenience function that can\n    be used to prompt a user for input later.\n\n    If the user aborts the input by sending an interrupt signal, this\n    function will catch it and raise a :exc:`Abort` exception.\n\n    :param text: the text to show for the prompt.\n    :param default: the default value to use if no input happens.  If this\n                    is not given it will prompt until it's aborted.\n    :param hide_input: if this is set to true then the input value will\n                       be hidden.\n    :param confirmation_prompt: Prompt a second time to confirm the\n        value. Can be set to a string instead of ``True`` to customize\n        the message.\n    :param type: the type to use to check the value against.\n    :param value_proc: if this parameter is provided it's a function that\n                       is invoked instead of the type conversion to\n                       convert a value.\n    :param prompt_suffix: a suffix that should be added to the prompt.\n    :param show_default: shows or hides the default value in the prompt.\n    :param err: if set to true the file defaults to ``stderr`` instead of\n                ``stdout``, the same as with echo.\n    :param show_choices: Show or hide choices if the passed type is a Choice.\n                         For example if type is a Choice of either day or week,\n                         show_choices is true and text is \"Group by\" then the\n                         prompt will be \"Group by (day, week): \".\n\n    .. versionchanged:: 8.3.1\n        A space is no longer appended to the prompt.\n\n    .. versionadded:: 8.0\n        ``confirmation_prompt`` can be a custom string.\n\n    .. versionadded:: 7.0\n        Added the ``show_choices`` parameter.\n\n    .. versionadded:: 6.0\n        Added unicode support for cmd.exe on Windows.\n\n    .. versionadded:: 4.0\n        Added the `err` parameter.\n\n    \"\"\"\n\n    def prompt_func(text: str) -> str:\n        f = hidden_prompt_func if hide_input else visible_prompt_func\n        try:\n            # Write the prompt separately so that we get nice\n            # coloring through colorama on Windows\n            echo(text[:-1], nl=False, err=err)\n            # Echo the last character to stdout to work around an issue where\n            # readline causes backspace to clear the whole line.\n            return f(text[-1:])\n        except (KeyboardInterrupt, EOFError):\n            # getpass doesn't print a newline if the user aborts input with ^C.\n            # Allegedly this behavior is inherited from getpass(3).\n            # A doc bug has been filed at https://bugs.python.org/issue24711\n            if hide_input:\n                echo(None, err=err)\n            raise Abort() from None\n\n    if value_proc is None:\n        value_proc = convert_type(type, default)\n\n    prompt = _build_prompt(\n        text, prompt_suffix, show_default, default, show_choices, type\n    )\n\n    if confirmation_prompt:\n        if confirmation_prompt is True:\n            confirmation_prompt = _(\"Repeat for confirmation\")\n\n        confirmation_prompt = _build_prompt(confirmation_prompt, prompt_suffix)\n\n    while True:\n        while True:\n            value = prompt_func(prompt)\n            if value:\n                break\n            elif default is not None:\n                value = default\n                break\n        try:\n            result = value_proc(value)\n        except UsageError as e:\n            if hide_input:\n                echo(_(\"Error: The value you entered was invalid.\"), err=err)\n            else:\n                echo(_(\"Error: {e.message}\").format(e=e), err=err)\n            continue\n        if not confirmation_prompt:\n            return result\n        while True:\n            value2 = prompt_func(confirmation_prompt)\n            is_empty = not value and not value2\n            if value2 or is_empty:\n                break\n        if value == value2:\n            return result\n        echo(_(\"Error: The two entered values do not match.\"), err=err)",
        "line_count": 112,
        "needs_llm_summary": true
      },
      {
        "name": "confirm",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "default",
            "type": "Any"
          },
          {
            "name": "abort",
            "type": "bool"
          },
          {
            "name": "prompt_suffix",
            "type": "str"
          },
          {
            "name": "show_default",
            "type": "bool"
          },
          {
            "name": "err",
            "type": "bool"
          }
        ],
        "return_type": "bool",
        "lineno": 197,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "echo",
          "unknown.lower",
          "_",
          "err",
          "show_default",
          "Abort",
          "_build_prompt",
          "prompt_suffix",
          "default",
          "unknown.strip",
          "visible_prompt_func"
        ],
        "docstring": "Prompts for confirmation (yes/no question).\n\nIf the user aborts the input by sending a interrupt signal this\nfunction will catch it and raise a :exc:`Abort` exception.\n\n:param text: the question to ask.\n:param default: The default value to use when no input is given. If\n    ``None``, repeat until input is given.\n:param abort: if this is set to `True` a negative answer aborts the\n              exception by raising :exc:`Abort`.\n:param prompt_suffix: a suffix that should be added to the prompt.\n:param show_default: shows or hides the default value in the prompt.\n:param err: if set to true the file defaults to ``stderr`` instead of\n            ``stdout``, the same as with echo.\n\n.. versionchanged:: 8.3.1\n    A space is no longer appended to the prompt.\n\n.. versionchanged:: 8.0\n    Repeat until input is given if ``default`` is ``None``.\n\n.. versionadded:: 4.0\n    Added the ``err`` parameter.",
        "code": "def confirm(\n    text: str,\n    default: bool | None = False,\n    abort: bool = False,\n    prompt_suffix: str = \": \",\n    show_default: bool = True,\n    err: bool = False,\n) -> bool:\n    \"\"\"Prompts for confirmation (yes/no question).\n\n    If the user aborts the input by sending a interrupt signal this\n    function will catch it and raise a :exc:`Abort` exception.\n\n    :param text: the question to ask.\n    :param default: The default value to use when no input is given. If\n        ``None``, repeat until input is given.\n    :param abort: if this is set to `True` a negative answer aborts the\n                  exception by raising :exc:`Abort`.\n    :param prompt_suffix: a suffix that should be added to the prompt.\n    :param show_default: shows or hides the default value in the prompt.\n    :param err: if set to true the file defaults to ``stderr`` instead of\n                ``stdout``, the same as with echo.\n\n    .. versionchanged:: 8.3.1\n        A space is no longer appended to the prompt.\n\n    .. versionchanged:: 8.0\n        Repeat until input is given if ``default`` is ``None``.\n\n    .. versionadded:: 4.0\n        Added the ``err`` parameter.\n    \"\"\"\n    prompt = _build_prompt(\n        text,\n        prompt_suffix,\n        show_default,\n        \"y/n\" if default is None else (\"Y/n\" if default else \"y/N\"),\n    )\n\n    while True:\n        try:\n            # Write the prompt separately so that we get nice\n            # coloring through colorama on Windows\n            echo(prompt[:-1], nl=False, err=err)\n            # Echo the last character to stdout to work around an issue where\n            # readline causes backspace to clear the whole line.\n            value = visible_prompt_func(prompt[-1:]).lower().strip()\n        except (KeyboardInterrupt, EOFError):\n            raise Abort() from None\n        if value in (\"y\", \"yes\"):\n            rv = True\n        elif value in (\"n\", \"no\"):\n            rv = False\n        elif default is not None and value == \"\":\n            rv = default\n        else:\n            echo(_(\"Error: invalid input\"), err=err)\n            continue\n        break\n    if abort and not rv:\n        raise Abort()\n    return rv",
        "line_count": 62,
        "needs_llm_summary": true
      },
      {
        "name": "echo_via_pager",
        "args": [
          {
            "name": "text_or_generator",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 261,
        "decorators": [],
        "is_async": false,
        "calls": [
          "el",
          "pager",
          "iter",
          "str",
          "resolve_color_default",
          "t.cast",
          "isinstance",
          "inspect.isgeneratorfunction",
          "color",
          "itertools.chain",
          "text_or_generator",
          "text_generator"
        ],
        "docstring": "This function takes a text and shows it via an environment specific\npager on stdout.\n\n.. versionchanged:: 3.0\n   Added the `color` flag.\n\n:param text_or_generator: the text to page, or alternatively, a\n                          generator emitting the text to page.\n:param color: controls if the pager supports ANSI colors or not.  The\n              default is autodetection.",
        "code": "def echo_via_pager(\n    text_or_generator: cabc.Iterable[str] | t.Callable[[], cabc.Iterable[str]] | str,\n    color: bool | None = None,\n) -> None:\n    \"\"\"This function takes a text and shows it via an environment specific\n    pager on stdout.\n\n    .. versionchanged:: 3.0\n       Added the `color` flag.\n\n    :param text_or_generator: the text to page, or alternatively, a\n                              generator emitting the text to page.\n    :param color: controls if the pager supports ANSI colors or not.  The\n                  default is autodetection.\n    \"\"\"\n    color = resolve_color_default(color)\n\n    if inspect.isgeneratorfunction(text_or_generator):\n        i = t.cast(\"t.Callable[[], cabc.Iterable[str]]\", text_or_generator)()\n    elif isinstance(text_or_generator, str):\n        i = [text_or_generator]\n    else:\n        i = iter(t.cast(\"cabc.Iterable[str]\", text_or_generator))\n\n    # convert every element of i to a text type if necessary\n    text_generator = (el if isinstance(el, str) else str(el) for el in i)\n\n    from ._termui_impl import pager\n\n    return pager(itertools.chain(text_generator, \"\\n\"), color)",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "progressbar",
        "args": [],
        "return_type": "ProgressBar[int]",
        "lineno": 294,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def progressbar(\n    *,\n    length: int,\n    label: str | None = None,\n    hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool | None = None,\n    show_pos: bool = False,\n    fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n    width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n    update_min_steps: int = 1,\n) -> ProgressBar[int]: ...",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "progressbar",
        "args": [
          {
            "name": "iterable",
            "type": "Any"
          },
          {
            "name": "length",
            "type": "Any"
          },
          {
            "name": "label",
            "type": "Any"
          },
          {
            "name": "hidden",
            "type": "bool"
          },
          {
            "name": "show_eta",
            "type": "bool"
          },
          {
            "name": "show_percent",
            "type": "Any"
          },
          {
            "name": "show_pos",
            "type": "bool"
          },
          {
            "name": "item_show_func",
            "type": "Any"
          },
          {
            "name": "fill_char",
            "type": "str"
          },
          {
            "name": "empty_char",
            "type": "str"
          },
          {
            "name": "bar_template",
            "type": "str"
          },
          {
            "name": "info_sep",
            "type": "str"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "file",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "Any"
          },
          {
            "name": "update_min_steps",
            "type": "int"
          }
        ],
        "return_type": "ProgressBar[V]",
        "lineno": 314,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def progressbar(\n    iterable: cabc.Iterable[V] | None = None,\n    length: int | None = None,\n    label: str | None = None,\n    hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool | None = None,\n    show_pos: bool = False,\n    item_show_func: t.Callable[[V | None], str | None] | None = None,\n    fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n    width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n    update_min_steps: int = 1,\n) -> ProgressBar[V]: ...",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "progressbar",
        "args": [
          {
            "name": "iterable",
            "type": "Any"
          },
          {
            "name": "length",
            "type": "Any"
          },
          {
            "name": "label",
            "type": "Any"
          },
          {
            "name": "hidden",
            "type": "bool"
          },
          {
            "name": "show_eta",
            "type": "bool"
          },
          {
            "name": "show_percent",
            "type": "Any"
          },
          {
            "name": "show_pos",
            "type": "bool"
          },
          {
            "name": "item_show_func",
            "type": "Any"
          },
          {
            "name": "fill_char",
            "type": "str"
          },
          {
            "name": "empty_char",
            "type": "str"
          },
          {
            "name": "bar_template",
            "type": "str"
          },
          {
            "name": "info_sep",
            "type": "str"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "file",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "Any"
          },
          {
            "name": "update_min_steps",
            "type": "int"
          }
        ],
        "return_type": "ProgressBar[V]",
        "lineno": 334,
        "decorators": [],
        "is_async": false,
        "calls": [
          "iterable",
          "info_sep",
          "ProgressBar",
          "show_pos",
          "update_min_steps",
          "empty_char",
          "file",
          "length",
          "resolve_color_default",
          "show_eta",
          "label",
          "bar_template",
          "width",
          "color",
          "hidden",
          "item_show_func",
          "fill_char",
          "show_percent"
        ],
        "docstring": "This function creates an iterable context manager that can be used\nto iterate over something while showing a progress bar.  It will\neither iterate over the `iterable` or `length` items (that are counted\nup).  While iteration happens, this function will print a rendered\nprogress bar to the given `file` (defaults to stdout) and will attempt\nto calculate remaining time and more.  By default, this progress bar\nwill not be rendered if the file is not a terminal.\n\nThe context manager creates the progress bar.  When the context\nmanager is entered the progress bar is already created.  With every\niteration over the progress bar, the iterable passed to the bar is\nadvanced and the bar is updated.  When the context manager exits,\na newline is printed and the progress bar is finalized on screen.\n\nNote: The progress bar is currently designed for use cases where the\ntotal progress can be expected to take at least several seconds.\nBecause of this, the ProgressBar class object won't display\nprogress that is considered too fast, and progress where the time\nbetween steps is less than a second.\n\nNo printing must happen or the progress bar will be unintentionally\ndestroyed.\n\nExample usage::\n\n    with progressbar(items) as bar:\n        for item in bar:\n            do_something_with(item)\n\nAlternatively, if no iterable is specified, one can manually update the\nprogress bar through the `update()` method instead of directly\niterating over the progress bar.  The update method accepts the number\nof steps to increment the bar with::\n\n    with progressbar(length=chunks.total_bytes) as bar:\n        for chunk in chunks:\n            process_chunk(chunk)\n            bar.update(chunks.bytes)\n\nThe ``update()`` method also takes an optional value specifying the\n``current_item`` at the new position. This is useful when used\ntogether with ``item_show_func`` to customize the output for each\nmanual step::\n\n    with click.progressbar(\n        length=total_size,\n        label='Unzipping archive',\n        item_show_func=lambda a: a.filename\n    ) as bar:\n        for archive in zip_file:\n            archive.extract()\n            bar.update(archive.size, archive)\n\n:param iterable: an iterable to iterate over.  If not provided the length\n                 is required.\n:param length: the number of items to iterate over.  By default the\n               progressbar will attempt to ask the iterator about its\n               length, which might or might not work.  If an iterable is\n               also provided this parameter can be used to override the\n               length.  If an iterable is not provided the progress bar\n               will iterate over a range of that length.\n:param label: the label to show next to the progress bar.\n:param hidden: hide the progressbar. Defaults to ``False``. When no tty is\n    detected, it will only print the progressbar label. Setting this to\n    ``False`` also disables that.\n:param show_eta: enables or disables the estimated time display.  This is\n                 automatically disabled if the length cannot be\n                 determined.\n:param show_percent: enables or disables the percentage display.  The\n                     default is `True` if the iterable has a length or\n                     `False` if not.\n:param show_pos: enables or disables the absolute position display.  The\n                 default is `False`.\n:param item_show_func: A function called with the current item which\n    can return a string to show next to the progress bar. If the\n    function returns ``None`` nothing is shown. The current item can\n    be ``None``, such as when entering and exiting the bar.\n:param fill_char: the character to use to show the filled part of the\n                  progress bar.\n:param empty_char: the character to use to show the non-filled part of\n                   the progress bar.\n:param bar_template: the format string to use as template for the bar.\n                     The parameters in it are ``label`` for the label,\n                     ``bar`` for the progress bar and ``info`` for the\n                     info section.\n:param info_sep: the separator between multiple info items (eta etc.)\n:param width: the width of the progress bar in characters, 0 means full\n              terminal width\n:param file: The file to write to. If this is not a terminal then\n    only the label is printed.\n:param color: controls if the terminal supports ANSI colors or not.  The\n              default is autodetection.  This is only needed if ANSI\n              codes are included anywhere in the progress bar output\n              which is not the case by default.\n:param update_min_steps: Render only when this many updates have\n    completed. This allows tuning for very fast iterators.\n\n.. versionadded:: 8.2\n    The ``hidden`` argument.\n\n.. versionchanged:: 8.0\n    Output is shown even if execution time is less than 0.5 seconds.\n\n.. versionchanged:: 8.0\n    ``item_show_func`` shows the current item, not the previous one.\n\n.. versionchanged:: 8.0\n    Labels are echoed if the output is not a TTY. Reverts a change\n    in 7.0 that removed all output.\n\n.. versionadded:: 8.0\n   The ``update_min_steps`` parameter.\n\n.. versionadded:: 4.0\n    The ``color`` parameter and ``update`` method.\n\n.. versionadded:: 2.0",
        "code": "def progressbar(\n    iterable: cabc.Iterable[V] | None = None,\n    length: int | None = None,\n    label: str | None = None,\n    hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool | None = None,\n    show_pos: bool = False,\n    item_show_func: t.Callable[[V | None], str | None] | None = None,\n    fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n    width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n    update_min_steps: int = 1,\n) -> ProgressBar[V]:\n    \"\"\"This function creates an iterable context manager that can be used\n    to iterate over something while showing a progress bar.  It will\n    either iterate over the `iterable` or `length` items (that are counted\n    up).  While iteration happens, this function will print a rendered\n    progress bar to the given `file` (defaults to stdout) and will attempt\n    to calculate remaining time and more.  By default, this progress bar\n    will not be rendered if the file is not a terminal.\n\n    The context manager creates the progress bar.  When the context\n    manager is entered the progress bar is already created.  With every\n    iteration over the progress bar, the iterable passed to the bar is\n    advanced and the bar is updated.  When the context manager exits,\n    a newline is printed and the progress bar is finalized on screen.\n\n    Note: The progress bar is currently designed for use cases where the\n    total progress can be expected to take at least several seconds.\n    Because of this, the ProgressBar class object won't display\n    progress that is considered too fast, and progress where the time\n    between steps is less than a second.\n\n    No printing must happen or the progress bar will be unintentionally\n    destroyed.\n\n    Example usage::\n\n        with progressbar(items) as bar:\n            for item in bar:\n                do_something_with(item)\n\n    Alternatively, if no iterable is specified, one can manually update the\n    progress bar through the `update()` method instead of directly\n    iterating over the progress bar.  The update method accepts the number\n    of steps to increment the bar with::\n\n        with progressbar(length=chunks.total_bytes) as bar:\n            for chunk in chunks:\n                process_chunk(chunk)\n                bar.update(chunks.bytes)\n\n    The ``update()`` method also takes an optional value specifying the\n    ``current_item`` at the new position. This is useful when used\n    together with ``item_show_func`` to customize the output for each\n    manual step::\n\n        with click.progressbar(\n            length=total_size,\n            label='Unzipping archive',\n            item_show_func=lambda a: a.filename\n        ) as bar:\n            for archive in zip_file:\n                archive.extract()\n                bar.update(archive.size, archive)\n\n    :param iterable: an iterable to iterate over.  If not provided the length\n                     is required.\n    :param length: the number of items to iterate over.  By default the\n                   progressbar will attempt to ask the iterator about its\n                   length, which might or might not work.  If an iterable is\n                   also provided this parameter can be used to override the\n                   length.  If an iterable is not provided the progress bar\n                   will iterate over a range of that length.\n    :param label: the label to show next to the progress bar.\n    :param hidden: hide the progressbar. Defaults to ``False``. When no tty is\n        detected, it will only print the progressbar label. Setting this to\n        ``False`` also disables that.\n    :param show_eta: enables or disables the estimated time display.  This is\n                     automatically disabled if the length cannot be\n                     determined.\n    :param show_percent: enables or disables the percentage display.  The\n                         default is `True` if the iterable has a length or\n                         `False` if not.\n    :param show_pos: enables or disables the absolute position display.  The\n                     default is `False`.\n    :param item_show_func: A function called with the current item which\n        can return a string to show next to the progress bar. If the\n        function returns ``None`` nothing is shown. The current item can\n        be ``None``, such as when entering and exiting the bar.\n    :param fill_char: the character to use to show the filled part of the\n                      progress bar.\n    :param empty_char: the character to use to show the non-filled part of\n                       the progress bar.\n    :param bar_template: the format string to use as template for the bar.\n                         The parameters in it are ``label`` for the label,\n                         ``bar`` for the progress bar and ``info`` for the\n                         info section.\n    :param info_sep: the separator between multiple info items (eta etc.)\n    :param width: the width of the progress bar in characters, 0 means full\n                  terminal width\n    :param file: The file to write to. If this is not a terminal then\n        only the label is printed.\n    :param color: controls if the terminal supports ANSI colors or not.  The\n                  default is autodetection.  This is only needed if ANSI\n                  codes are included anywhere in the progress bar output\n                  which is not the case by default.\n    :param update_min_steps: Render only when this many updates have\n        completed. This allows tuning for very fast iterators.\n\n    .. versionadded:: 8.2\n        The ``hidden`` argument.\n\n    .. versionchanged:: 8.0\n        Output is shown even if execution time is less than 0.5 seconds.\n\n    .. versionchanged:: 8.0\n        ``item_show_func`` shows the current item, not the previous one.\n\n    .. versionchanged:: 8.0\n        Labels are echoed if the output is not a TTY. Reverts a change\n        in 7.0 that removed all output.\n\n    .. versionadded:: 8.0\n       The ``update_min_steps`` parameter.\n\n    .. versionadded:: 4.0\n        The ``color`` parameter and ``update`` method.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    from ._termui_impl import ProgressBar\n\n    color = resolve_color_default(color)\n    return ProgressBar(\n        iterable=iterable,\n        length=length,\n        hidden=hidden,\n        show_eta=show_eta,\n        show_percent=show_percent,\n        show_pos=show_pos,\n        item_show_func=item_show_func,\n        fill_char=fill_char,\n        empty_char=empty_char,\n        bar_template=bar_template,\n        info_sep=info_sep,\n        file=file,\n        label=label,\n        width=width,\n        color=color,\n        update_min_steps=update_min_steps,\n    )",
        "line_count": 157,
        "needs_llm_summary": true
      },
      {
        "name": "clear",
        "args": [],
        "return_type": "None",
        "lineno": 493,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "isatty",
          "sys.stdout"
        ],
        "docstring": "Clears the terminal screen.  This will have the effect of clearing\nthe whole visible space of the terminal and moving the cursor to the\ntop left.  This does not do anything if not connected to a terminal.\n\n.. versionadded:: 2.0",
        "code": "def clear() -> None:\n    \"\"\"Clears the terminal screen.  This will have the effect of clearing\n    the whole visible space of the terminal and moving the cursor to the\n    top left.  This does not do anything if not connected to a terminal.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    if not isatty(sys.stdout):\n        return\n\n    # ANSI escape \\033[2J clears the screen, \\033[1;1H moves the cursor\n    echo(\"\\033[2J\\033[1;1H\", nl=False)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "_interpret_color",
        "args": [
          {
            "name": "color",
            "type": "Any"
          },
          {
            "name": "offset",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 507,
        "decorators": [],
        "is_async": false,
        "calls": [
          "str",
          "isinstance",
          "int",
          "color"
        ],
        "docstring": null,
        "code": "def _interpret_color(color: int | tuple[int, int, int] | str, offset: int = 0) -> str:\n    if isinstance(color, int):\n        return f\"{38 + offset};5;{color:d}\"\n\n    if isinstance(color, (tuple, list)):\n        r, g, b = color\n        return f\"{38 + offset};2;{r:d};{g:d};{b:d}\"\n\n    return str(_ansi_colors[color] + offset)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "style",
        "args": [
          {
            "name": "text",
            "type": "t.Any"
          },
          {
            "name": "fg",
            "type": "Any"
          },
          {
            "name": "bg",
            "type": "Any"
          },
          {
            "name": "bold",
            "type": "Any"
          },
          {
            "name": "dim",
            "type": "Any"
          },
          {
            "name": "underline",
            "type": "Any"
          },
          {
            "name": "overline",
            "type": "Any"
          },
          {
            "name": "italic",
            "type": "Any"
          },
          {
            "name": "blink",
            "type": "Any"
          },
          {
            "name": "reverse",
            "type": "Any"
          },
          {
            "name": "strikethrough",
            "type": "Any"
          },
          {
            "name": "reset",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 518,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "unknown.join",
          "_interpret_color",
          "str",
          "_ansi_reset_all",
          "bg",
          "fg",
          "bits.append",
          "bits",
          "isinstance",
          "TypeError"
        ],
        "docstring": "Styles a text with ANSI styles and returns the new string.  By\ndefault the styling is self contained which means that at the end\nof the string a reset code is issued.  This can be prevented by\npassing ``reset=False``.\n\nExamples::\n\n    click.echo(click.style('Hello World!', fg='green'))\n    click.echo(click.style('ATTENTION!', blink=True))\n    click.echo(click.style('Some things', reverse=True, fg='cyan'))\n    click.echo(click.style('More colors', fg=(255, 12, 128), bg=117))\n\nSupported color names:\n\n* ``black`` (might be a gray)\n* ``red``\n* ``green``\n* ``yellow`` (might be an orange)\n* ``blue``\n* ``magenta``\n* ``cyan``\n* ``white`` (might be light gray)\n* ``bright_black``\n* ``bright_red``\n* ``bright_green``\n* ``bright_yellow``\n* ``bright_blue``\n* ``bright_magenta``\n* ``bright_cyan``\n* ``bright_white``\n* ``reset`` (reset the color code only)\n\nIf the terminal supports it, color may also be specified as:\n\n-   An integer in the interval [0, 255]. The terminal must support\n    8-bit/256-color mode.\n-   An RGB tuple of three integers in [0, 255]. The terminal must\n    support 24-bit/true-color mode.\n\nSee https://en.wikipedia.org/wiki/ANSI_color and\nhttps://gist.github.com/XVilka/8346728 for more information.\n\n:param text: the string to style with ansi codes.\n:param fg: if provided this will become the foreground color.\n:param bg: if provided this will become the background color.\n:param bold: if provided this will enable or disable bold mode.\n:param dim: if provided this will enable or disable dim mode.  This is\n            badly supported.\n:param underline: if provided this will enable or disable underline.\n:param overline: if provided this will enable or disable overline.\n:param italic: if provided this will enable or disable italic.\n:param blink: if provided this will enable or disable blinking.\n:param reverse: if provided this will enable or disable inverse\n                rendering (foreground becomes background and the\n                other way round).\n:param strikethrough: if provided this will enable or disable\n    striking through text.\n:param reset: by default a reset-all code is added at the end of the\n              string which means that styles do not carry over.  This\n              can be disabled to compose styles.\n\n.. versionchanged:: 8.0\n    A non-string ``message`` is converted to a string.\n\n.. versionchanged:: 8.0\n   Added support for 256 and RGB color codes.\n\n.. versionchanged:: 8.0\n    Added the ``strikethrough``, ``italic``, and ``overline``\n    parameters.\n\n.. versionchanged:: 7.0\n    Added support for bright colors.\n\n.. versionadded:: 2.0",
        "code": "def style(\n    text: t.Any,\n    fg: int | tuple[int, int, int] | str | None = None,\n    bg: int | tuple[int, int, int] | str | None = None,\n    bold: bool | None = None,\n    dim: bool | None = None,\n    underline: bool | None = None,\n    overline: bool | None = None,\n    italic: bool | None = None,\n    blink: bool | None = None,\n    reverse: bool | None = None,\n    strikethrough: bool | None = None,\n    reset: bool = True,\n) -> str:\n    \"\"\"Styles a text with ANSI styles and returns the new string.  By\n    default the styling is self contained which means that at the end\n    of the string a reset code is issued.  This can be prevented by\n    passing ``reset=False``.\n\n    Examples::\n\n        click.echo(click.style('Hello World!', fg='green'))\n        click.echo(click.style('ATTENTION!', blink=True))\n        click.echo(click.style('Some things', reverse=True, fg='cyan'))\n        click.echo(click.style('More colors', fg=(255, 12, 128), bg=117))\n\n    Supported color names:\n\n    * ``black`` (might be a gray)\n    * ``red``\n    * ``green``\n    * ``yellow`` (might be an orange)\n    * ``blue``\n    * ``magenta``\n    * ``cyan``\n    * ``white`` (might be light gray)\n    * ``bright_black``\n    * ``bright_red``\n    * ``bright_green``\n    * ``bright_yellow``\n    * ``bright_blue``\n    * ``bright_magenta``\n    * ``bright_cyan``\n    * ``bright_white``\n    * ``reset`` (reset the color code only)\n\n    If the terminal supports it, color may also be specified as:\n\n    -   An integer in the interval [0, 255]. The terminal must support\n        8-bit/256-color mode.\n    -   An RGB tuple of three integers in [0, 255]. The terminal must\n        support 24-bit/true-color mode.\n\n    See https://en.wikipedia.org/wiki/ANSI_color and\n    https://gist.github.com/XVilka/8346728 for more information.\n\n    :param text: the string to style with ansi codes.\n    :param fg: if provided this will become the foreground color.\n    :param bg: if provided this will become the background color.\n    :param bold: if provided this will enable or disable bold mode.\n    :param dim: if provided this will enable or disable dim mode.  This is\n                badly supported.\n    :param underline: if provided this will enable or disable underline.\n    :param overline: if provided this will enable or disable overline.\n    :param italic: if provided this will enable or disable italic.\n    :param blink: if provided this will enable or disable blinking.\n    :param reverse: if provided this will enable or disable inverse\n                    rendering (foreground becomes background and the\n                    other way round).\n    :param strikethrough: if provided this will enable or disable\n        striking through text.\n    :param reset: by default a reset-all code is added at the end of the\n                  string which means that styles do not carry over.  This\n                  can be disabled to compose styles.\n\n    .. versionchanged:: 8.0\n        A non-string ``message`` is converted to a string.\n\n    .. versionchanged:: 8.0\n       Added support for 256 and RGB color codes.\n\n    .. versionchanged:: 8.0\n        Added the ``strikethrough``, ``italic``, and ``overline``\n        parameters.\n\n    .. versionchanged:: 7.0\n        Added support for bright colors.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    if not isinstance(text, str):\n        text = str(text)\n\n    bits = []\n\n    if fg:\n        try:\n            bits.append(f\"\\033[{_interpret_color(fg)}m\")\n        except KeyError:\n            raise TypeError(f\"Unknown color {fg!r}\") from None\n\n    if bg:\n        try:\n            bits.append(f\"\\033[{_interpret_color(bg, 10)}m\")\n        except KeyError:\n            raise TypeError(f\"Unknown color {bg!r}\") from None\n\n    if bold is not None:\n        bits.append(f\"\\033[{1 if bold else 22}m\")\n    if dim is not None:\n        bits.append(f\"\\033[{2 if dim else 22}m\")\n    if underline is not None:\n        bits.append(f\"\\033[{4 if underline else 24}m\")\n    if overline is not None:\n        bits.append(f\"\\033[{53 if overline else 55}m\")\n    if italic is not None:\n        bits.append(f\"\\033[{3 if italic else 23}m\")\n    if blink is not None:\n        bits.append(f\"\\033[{5 if blink else 25}m\")\n    if reverse is not None:\n        bits.append(f\"\\033[{7 if reverse else 27}m\")\n    if strikethrough is not None:\n        bits.append(f\"\\033[{9 if strikethrough else 29}m\")\n    bits.append(text)\n    if reset:\n        bits.append(_ansi_reset_all)\n    return \"\".join(bits)",
        "line_count": 127,
        "needs_llm_summary": true
      },
      {
        "name": "unstyle",
        "args": [
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 647,
        "decorators": [],
        "is_async": false,
        "calls": [
          "strip_ansi",
          "text"
        ],
        "docstring": "Removes ANSI styling information from a string.  Usually it's not\nnecessary to use this function as Click's echo function will\nautomatically remove styling if necessary.\n\n.. versionadded:: 2.0\n\n:param text: the text to remove style information from.",
        "code": "def unstyle(text: str) -> str:\n    \"\"\"Removes ANSI styling information from a string.  Usually it's not\n    necessary to use this function as Click's echo function will\n    automatically remove styling if necessary.\n\n    .. versionadded:: 2.0\n\n    :param text: the text to remove style information from.\n    \"\"\"\n    return strip_ansi(text)",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "secho",
        "args": [
          {
            "name": "message",
            "type": "Any"
          },
          {
            "name": "file",
            "type": "Any"
          },
          {
            "name": "nl",
            "type": "bool"
          },
          {
            "name": "err",
            "type": "bool"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 659,
        "decorators": [],
        "is_async": false,
        "calls": [
          "nl",
          "echo",
          "message",
          "file",
          "err",
          "isinstance",
          "color",
          "style",
          "styles"
        ],
        "docstring": "This function combines :func:`echo` and :func:`style` into one\ncall.  As such the following two calls are the same::\n\n    click.secho('Hello World!', fg='green')\n    click.echo(click.style('Hello World!', fg='green'))\n\nAll keyword arguments are forwarded to the underlying functions\ndepending on which one they go with.\n\nNon-string types will be converted to :class:`str`. However,\n:class:`bytes` are passed directly to :meth:`echo` without applying\nstyle. If you want to style bytes that represent text, call\n:meth:`bytes.decode` first.\n\n.. versionchanged:: 8.0\n    A non-string ``message`` is converted to a string. Bytes are\n    passed through without style applied.\n\n.. versionadded:: 2.0",
        "code": "def secho(\n    message: t.Any | None = None,\n    file: t.IO[t.AnyStr] | None = None,\n    nl: bool = True,\n    err: bool = False,\n    color: bool | None = None,\n    **styles: t.Any,\n) -> None:\n    \"\"\"This function combines :func:`echo` and :func:`style` into one\n    call.  As such the following two calls are the same::\n\n        click.secho('Hello World!', fg='green')\n        click.echo(click.style('Hello World!', fg='green'))\n\n    All keyword arguments are forwarded to the underlying functions\n    depending on which one they go with.\n\n    Non-string types will be converted to :class:`str`. However,\n    :class:`bytes` are passed directly to :meth:`echo` without applying\n    style. If you want to style bytes that represent text, call\n    :meth:`bytes.decode` first.\n\n    .. versionchanged:: 8.0\n        A non-string ``message`` is converted to a string. Bytes are\n        passed through without style applied.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    if message is not None and not isinstance(message, (bytes, bytearray)):\n        message = style(message, **styles)\n\n    return echo(message, file=file, nl=nl, err=err, color=color)",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "edit",
        "args": [
          {
            "name": "text",
            "type": "Any"
          },
          {
            "name": "editor",
            "type": "Any"
          },
          {
            "name": "env",
            "type": "Any"
          },
          {
            "name": "require_save",
            "type": "bool"
          },
          {
            "name": "extension",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 694,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def edit(\n    text: bytes | bytearray,\n    editor: str | None = None,\n    env: cabc.Mapping[str, str] | None = None,\n    require_save: bool = False,\n    extension: str = \".txt\",\n) -> bytes | None: ...",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "edit",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "editor",
            "type": "Any"
          },
          {
            "name": "env",
            "type": "Any"
          },
          {
            "name": "require_save",
            "type": "bool"
          },
          {
            "name": "extension",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 704,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def edit(\n    text: str,\n    editor: str | None = None,\n    env: cabc.Mapping[str, str] | None = None,\n    require_save: bool = True,\n    extension: str = \".txt\",\n) -> str | None: ...",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "edit",
        "args": [
          {
            "name": "text",
            "type": "None"
          },
          {
            "name": "editor",
            "type": "Any"
          },
          {
            "name": "env",
            "type": "Any"
          },
          {
            "name": "require_save",
            "type": "bool"
          },
          {
            "name": "extension",
            "type": "str"
          },
          {
            "name": "filename",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 714,
        "decorators": [
          {
            "name": "t.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def edit(\n    text: None = None,\n    editor: str | None = None,\n    env: cabc.Mapping[str, str] | None = None,\n    require_save: bool = True,\n    extension: str = \".txt\",\n    filename: str | cabc.Iterable[str] | None = None,\n) -> None: ...",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "edit",
        "args": [
          {
            "name": "text",
            "type": "Any"
          },
          {
            "name": "editor",
            "type": "Any"
          },
          {
            "name": "env",
            "type": "Any"
          },
          {
            "name": "require_save",
            "type": "bool"
          },
          {
            "name": "extension",
            "type": "str"
          },
          {
            "name": "filename",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 724,
        "decorators": [],
        "is_async": false,
        "calls": [
          "require_save",
          "filename",
          "text",
          "str",
          "ed.edit",
          "ed.edit_files",
          "extension",
          "editor",
          "isinstance",
          "Editor",
          "env"
        ],
        "docstring": "Edits the given text in the defined editor.  If an editor is given\n(should be the full path to the executable but the regular operating\nsystem search path is used for finding the executable) it overrides\nthe detected editor.  Optionally, some environment variables can be\nused.  If the editor is closed without changes, `None` is returned.  In\ncase a file is edited directly the return value is always `None` and\n`require_save` and `extension` are ignored.\n\nIf the editor cannot be opened a :exc:`UsageError` is raised.\n\nNote for Windows: to simplify cross-platform usage, the newlines are\nautomatically converted from POSIX to Windows and vice versa.  As such,\nthe message here will have ``\\n`` as newline markers.\n\n:param text: the text to edit.\n:param editor: optionally the editor to use.  Defaults to automatic\n               detection.\n:param env: environment variables to forward to the editor.\n:param require_save: if this is true, then not saving in the editor\n                     will make the return value become `None`.\n:param extension: the extension to tell the editor about.  This defaults\n                  to `.txt` but changing this might change syntax\n                  highlighting.\n:param filename: if provided it will edit this file instead of the\n                 provided text contents.  It will not use a temporary\n                 file as an indirection in that case. If the editor supports\n                 editing multiple files at once, a sequence of files may be\n                 passed as well. Invoke `click.file` once per file instead\n                 if multiple files cannot be managed at once or editing the\n                 files serially is desired.\n\n.. versionchanged:: 8.2.0\n    ``filename`` now accepts any ``Iterable[str]`` in addition to a ``str``\n    if the ``editor`` supports editing multiple files at once.",
        "code": "def edit(\n    text: str | bytes | bytearray | None = None,\n    editor: str | None = None,\n    env: cabc.Mapping[str, str] | None = None,\n    require_save: bool = True,\n    extension: str = \".txt\",\n    filename: str | cabc.Iterable[str] | None = None,\n) -> str | bytes | bytearray | None:\n    r\"\"\"Edits the given text in the defined editor.  If an editor is given\n    (should be the full path to the executable but the regular operating\n    system search path is used for finding the executable) it overrides\n    the detected editor.  Optionally, some environment variables can be\n    used.  If the editor is closed without changes, `None` is returned.  In\n    case a file is edited directly the return value is always `None` and\n    `require_save` and `extension` are ignored.\n\n    If the editor cannot be opened a :exc:`UsageError` is raised.\n\n    Note for Windows: to simplify cross-platform usage, the newlines are\n    automatically converted from POSIX to Windows and vice versa.  As such,\n    the message here will have ``\\n`` as newline markers.\n\n    :param text: the text to edit.\n    :param editor: optionally the editor to use.  Defaults to automatic\n                   detection.\n    :param env: environment variables to forward to the editor.\n    :param require_save: if this is true, then not saving in the editor\n                         will make the return value become `None`.\n    :param extension: the extension to tell the editor about.  This defaults\n                      to `.txt` but changing this might change syntax\n                      highlighting.\n    :param filename: if provided it will edit this file instead of the\n                     provided text contents.  It will not use a temporary\n                     file as an indirection in that case. If the editor supports\n                     editing multiple files at once, a sequence of files may be\n                     passed as well. Invoke `click.file` once per file instead\n                     if multiple files cannot be managed at once or editing the\n                     files serially is desired.\n\n    .. versionchanged:: 8.2.0\n        ``filename`` now accepts any ``Iterable[str]`` in addition to a ``str``\n        if the ``editor`` supports editing multiple files at once.\n\n    \"\"\"\n    from ._termui_impl import Editor\n\n    ed = Editor(editor=editor, env=env, require_save=require_save, extension=extension)\n\n    if filename is None:\n        return ed.edit(text)\n\n    if isinstance(filename, str):\n        filename = (filename,)\n\n    ed.edit_files(filenames=filename)\n    return None",
        "line_count": 56,
        "needs_llm_summary": true
      },
      {
        "name": "launch",
        "args": [
          {
            "name": "url",
            "type": "str"
          },
          {
            "name": "wait",
            "type": "bool"
          },
          {
            "name": "locate",
            "type": "bool"
          }
        ],
        "return_type": "int",
        "lineno": 782,
        "decorators": [],
        "is_async": false,
        "calls": [
          "url",
          "open_url",
          "wait",
          "locate"
        ],
        "docstring": "This function launches the given URL (or filename) in the default\nviewer application for this file type.  If this is an executable, it\nmight launch the executable in a new session.  The return value is\nthe exit code of the launched application.  Usually, ``0`` indicates\nsuccess.\n\nExamples::\n\n    click.launch('https://click.palletsprojects.com/')\n    click.launch('/my/downloaded/file', locate=True)\n\n.. versionadded:: 2.0\n\n:param url: URL or filename of the thing to launch.\n:param wait: Wait for the program to exit before returning. This\n    only works if the launched program blocks. In particular,\n    ``xdg-open`` on Linux does not block.\n:param locate: if this is set to `True` then instead of launching the\n               application associated with the URL it will attempt to\n               launch a file manager with the file located.  This\n               might have weird effects if the URL does not point to\n               the filesystem.",
        "code": "def launch(url: str, wait: bool = False, locate: bool = False) -> int:\n    \"\"\"This function launches the given URL (or filename) in the default\n    viewer application for this file type.  If this is an executable, it\n    might launch the executable in a new session.  The return value is\n    the exit code of the launched application.  Usually, ``0`` indicates\n    success.\n\n    Examples::\n\n        click.launch('https://click.palletsprojects.com/')\n        click.launch('/my/downloaded/file', locate=True)\n\n    .. versionadded:: 2.0\n\n    :param url: URL or filename of the thing to launch.\n    :param wait: Wait for the program to exit before returning. This\n        only works if the launched program blocks. In particular,\n        ``xdg-open`` on Linux does not block.\n    :param locate: if this is set to `True` then instead of launching the\n                   application associated with the URL it will attempt to\n                   launch a file manager with the file located.  This\n                   might have weird effects if the URL does not point to\n                   the filesystem.\n    \"\"\"\n    from ._termui_impl import open_url\n\n    return open_url(url, wait=wait, locate=locate)",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "getchar",
        "args": [
          {
            "name": "echo",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 816,
        "decorators": [],
        "is_async": false,
        "calls": [
          "echo",
          "f",
          "_getchar"
        ],
        "docstring": "Fetches a single character from the terminal and returns it.  This\nwill always return a unicode character and under certain rare\ncircumstances this might return more than one character.  The\nsituations which more than one character is returned is when for\nwhatever reason multiple characters end up in the terminal buffer or\nstandard input was not actually a terminal.\n\nNote that this will always read from the terminal, even if something\nis piped into the standard input.\n\nNote for Windows: in rare cases when typing non-ASCII characters, this\nfunction might wait for a second character and then return both at once.\nThis is because certain Unicode characters look like special-key markers.\n\n.. versionadded:: 2.0\n\n:param echo: if set to `True`, the character read will also show up on\n             the terminal.  The default is to not show it.",
        "code": "def getchar(echo: bool = False) -> str:\n    \"\"\"Fetches a single character from the terminal and returns it.  This\n    will always return a unicode character and under certain rare\n    circumstances this might return more than one character.  The\n    situations which more than one character is returned is when for\n    whatever reason multiple characters end up in the terminal buffer or\n    standard input was not actually a terminal.\n\n    Note that this will always read from the terminal, even if something\n    is piped into the standard input.\n\n    Note for Windows: in rare cases when typing non-ASCII characters, this\n    function might wait for a second character and then return both at once.\n    This is because certain Unicode characters look like special-key markers.\n\n    .. versionadded:: 2.0\n\n    :param echo: if set to `True`, the character read will also show up on\n                 the terminal.  The default is to not show it.\n    \"\"\"\n    global _getchar\n\n    if _getchar is None:\n        from ._termui_impl import getchar as f\n\n        _getchar = f\n\n    return _getchar(echo)",
        "line_count": 28,
        "needs_llm_summary": true
      },
      {
        "name": "raw_terminal",
        "args": [],
        "return_type": "AbstractContextManager[int]",
        "lineno": 846,
        "decorators": [],
        "is_async": false,
        "calls": [
          "f"
        ],
        "docstring": null,
        "code": "def raw_terminal() -> AbstractContextManager[int]:\n    from ._termui_impl import raw_terminal as f\n\n    return f()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "pause",
        "args": [
          {
            "name": "info",
            "type": "Any"
          },
          {
            "name": "err",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 852,
        "decorators": [],
        "is_async": false,
        "calls": [
          "getchar",
          "echo",
          "sys.stdout",
          "isatty",
          "_",
          "err",
          "info",
          "sys.stdin"
        ],
        "docstring": "This command stops execution and waits for the user to press any\nkey to continue.  This is similar to the Windows batch \"pause\"\ncommand.  If the program is not run through a terminal, this command\nwill instead do nothing.\n\n.. versionadded:: 2.0\n\n.. versionadded:: 4.0\n   Added the `err` parameter.\n\n:param info: The message to print before pausing. Defaults to\n    ``\"Press any key to continue...\"``.\n:param err: if set to message goes to ``stderr`` instead of\n            ``stdout``, the same as with echo.",
        "code": "def pause(info: str | None = None, err: bool = False) -> None:\n    \"\"\"This command stops execution and waits for the user to press any\n    key to continue.  This is similar to the Windows batch \"pause\"\n    command.  If the program is not run through a terminal, this command\n    will instead do nothing.\n\n    .. versionadded:: 2.0\n\n    .. versionadded:: 4.0\n       Added the `err` parameter.\n\n    :param info: The message to print before pausing. Defaults to\n        ``\"Press any key to continue...\"``.\n    :param err: if set to message goes to ``stderr`` instead of\n                ``stdout``, the same as with echo.\n    \"\"\"\n    if not isatty(sys.stdin) or not isatty(sys.stdout):\n        return\n\n    if info is None:\n        info = _(\"Press any key to continue...\")\n\n    try:\n        if info:\n            echo(info, nl=False, err=err)\n        try:\n            getchar()\n        except (KeyboardInterrupt, EOFError):\n            pass\n    finally:\n        if info:\n            echo(err=err)",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "prompt_func",
        "args": [
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 139,
        "decorators": [],
        "is_async": false,
        "calls": [
          "err",
          "echo",
          "Abort",
          "f"
        ],
        "docstring": null,
        "code": "def prompt_func(text: str) -> str:\n        f = hidden_prompt_func if hide_input else visible_prompt_func\n        try:\n            # Write the prompt separately so that we get nice\n            # coloring through colorama on Windows\n            echo(text[:-1], nl=False, err=err)\n            # Echo the last character to stdout to work around an issue where\n            # readline causes backspace to clear the whole line.\n            return f(text[-1:])\n        except (KeyboardInterrupt, EOFError):\n            # getpass doesn't print a newline if the user aborts input with ^C.\n            # Allegedly this behavior is inherited from getpass(3).\n            # A doc bug has been filed at https://bugs.python.org/issue24711\n            if hide_input:\n                echo(None, err=err)\n            raise Abort() from None",
        "line_count": 16,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "inspect",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "itertools",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 8,
        "type": "import"
      },
      {
        "module": "contextlib",
        "name": "AbstractContextManager",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "isatty",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "strip_ansi",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "Abort",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "UsageError",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "globals",
        "name": "resolve_color_default",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "Choice",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "convert_type",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "ParamType",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "echo",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "LazyFile",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "_termui_impl",
        "name": "ProgressBar",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "getpass",
        "alias": null,
        "lineno": 55,
        "type": "import"
      },
      {
        "module": "_termui_impl",
        "name": "pager",
        "alias": null,
        "lineno": 288,
        "type": "from_import"
      },
      {
        "module": "_termui_impl",
        "name": "ProgressBar",
        "alias": null,
        "lineno": 470,
        "type": "from_import"
      },
      {
        "module": "_termui_impl",
        "name": "Editor",
        "alias": null,
        "lineno": 768,
        "type": "from_import"
      },
      {
        "module": "_termui_impl",
        "name": "open_url",
        "alias": null,
        "lineno": 806,
        "type": "from_import"
      },
      {
        "module": "_termui_impl",
        "name": "raw_terminal",
        "alias": "f",
        "lineno": 847,
        "type": "from_import"
      },
      {
        "module": "_termui_impl",
        "name": "getchar",
        "alias": "f",
        "lineno": 839,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "V",
        "assigned_to": "t.TypeVar",
        "lineno": 26
      },
      {
        "name": "_ansi_colors",
        "assigned_to": null,
        "lineno": 32
      },
      {
        "name": "_ansi_reset_all",
        "assigned_to": "str",
        "lineno": 51
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "t.TypeVar"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "contextlib",
        "sys",
        "typing",
        "collections",
        "itertools",
        "io"
      ],
      "third_party": {
        "other": [
          "__future__",
          "inspect",
          "gettext",
          "_compat",
          "exceptions",
          "globals",
          "types",
          "utils",
          "_termui_impl",
          "getpass"
        ]
      },
      "tech_stack": []
    },
    "line_count": 884
  },
  "src/click/testing.py": {
    "filepath": "../click/src/click/testing.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_pause_echo",
        "args": [
          {
            "name": "stream",
            "type": "Any"
          }
        ],
        "return_type": "cabc.Iterator[None]",
        "lineno": 60,
        "decorators": [
          {
            "name": "contextlib.contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def _pause_echo(stream: EchoingStdin | None) -> cabc.Iterator[None]:\n    if stream is None:\n        yield\n    else:\n        stream._paused = True\n        yield\n        stream._paused = False",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "make_input_stream",
        "args": [
          {
            "name": "input",
            "type": "Any"
          },
          {
            "name": "charset",
            "type": "str"
          }
        ],
        "return_type": "t.BinaryIO",
        "lineno": 131,
        "decorators": [],
        "is_async": false,
        "calls": [
          "charset",
          "str",
          "_find_binary_reader",
          "hasattr",
          "io.BytesIO",
          "t.cast",
          "TypeError",
          "isinstance",
          "input",
          "input.encode"
        ],
        "docstring": null,
        "code": "def make_input_stream(\n    input: str | bytes | t.IO[t.Any] | None, charset: str\n) -> t.BinaryIO:\n    # Is already an input stream.\n    if hasattr(input, \"read\"):\n        rv = _find_binary_reader(t.cast(\"t.IO[t.Any]\", input))\n\n        if rv is not None:\n            return rv\n\n        raise TypeError(\"Could not find binary reader for input stream.\")\n\n    if input is None:\n        input = b\"\"\n    elif isinstance(input, str):\n        input = input.encode(charset)\n\n    return io.BytesIO(input)",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "input",
            "type": "t.BinaryIO"
          },
          {
            "name": "output",
            "type": "t.BinaryIO"
          }
        ],
        "return_type": "None",
        "lineno": 26,
        "decorators": [],
        "is_async": false,
        "calls": [
          "output",
          "input"
        ],
        "docstring": null,
        "code": "def __init__(self, input: t.BinaryIO, output: t.BinaryIO) -> None:\n        self._input = input\n        self._output = output\n        self._paused = False",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "x",
            "type": "str"
          }
        ],
        "return_type": "t.Any",
        "lineno": 31,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._input",
          "x",
          "getattr"
        ],
        "docstring": null,
        "code": "def __getattr__(self, x: str) -> t.Any:\n        return getattr(self._input, x)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_echo",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "rv",
            "type": "bytes"
          }
        ],
        "return_type": "bytes",
        "lineno": 34,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._output.write",
          "rv"
        ],
        "docstring": null,
        "code": "def _echo(self, rv: bytes) -> bytes:\n        if not self._paused:\n            self._output.write(rv)\n\n        return rv",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "read",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "n",
            "type": "int"
          }
        ],
        "return_type": "bytes",
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._echo",
          "n",
          "self._input.read"
        ],
        "docstring": null,
        "code": "def read(self, n: int = -1) -> bytes:\n        return self._echo(self._input.read(n))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "read1",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "n",
            "type": "int"
          }
        ],
        "return_type": "bytes",
        "lineno": 43,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._echo",
          "n",
          "self._input.read1"
        ],
        "docstring": null,
        "code": "def read1(self, n: int = -1) -> bytes:\n        return self._echo(self._input.read1(n))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "readline",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "n",
            "type": "int"
          }
        ],
        "return_type": "bytes",
        "lineno": 46,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._echo",
          "n",
          "self._input.readline"
        ],
        "docstring": null,
        "code": "def readline(self, n: int = -1) -> bytes:\n        return self._echo(self._input.readline(n))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "readlines",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "list[bytes]",
        "lineno": 49,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._echo",
          "x",
          "self._input.readlines"
        ],
        "docstring": null,
        "code": "def readlines(self) -> list[bytes]:\n        return [self._echo(x) for x in self._input.readlines()]",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__iter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "cabc.Iterator[bytes]",
        "lineno": 52,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._echo",
          "iter",
          "x"
        ],
        "docstring": null,
        "code": "def __iter__(self) -> cabc.Iterator[bytes]:\n        return iter(self._echo(x) for x in self._input)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 55,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "self._input"
        ],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return repr(self._input)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "copy_to",
            "type": "io.BytesIO"
          }
        ],
        "return_type": "None",
        "lineno": 75,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.__init__",
          "super",
          "copy_to"
        ],
        "docstring": null,
        "code": "def __init__(self, copy_to: io.BytesIO) -> None:\n        super().__init__()\n        self.copy_to = copy_to",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "flush",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 79,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "unknown.flush",
          "self.copy_to.flush"
        ],
        "docstring": null,
        "code": "def flush(self) -> None:\n        super().flush()\n        self.copy_to.flush()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "write",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "b",
            "type": "ReadableBuffer"
          }
        ],
        "return_type": "int",
        "lineno": 83,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "b",
          "self.copy_to.write",
          "unknown.write"
        ],
        "docstring": null,
        "code": "def write(self, b: ReadableBuffer) -> int:\n        self.copy_to.write(b)\n        return super().write(b)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 96,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.output",
          "io.BytesIO",
          "BytesIOCopy"
        ],
        "docstring": null,
        "code": "def __init__(self) -> None:\n        self.output: io.BytesIO = io.BytesIO()\n        self.stdout: io.BytesIO = BytesIOCopy(copy_to=self.output)\n        self.stderr: io.BytesIO = BytesIOCopy(copy_to=self.output)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__del__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 101,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.output.close",
          "self.stdout.close",
          "self.stderr.close"
        ],
        "docstring": "Guarantee that embedded file-like objects are closed in a\npredictable order, protecting against races between\nself.output being closed and other streams being flushed on close\n\n.. versionadded:: 8.2.2",
        "code": "def __del__(self) -> None:\n        \"\"\"\n        Guarantee that embedded file-like objects are closed in a\n        predictable order, protecting against races between\n        self.output being closed and other streams being flushed on close\n\n        .. versionadded:: 8.2.2\n        \"\"\"\n        self.stderr.close()\n        self.stdout.close()\n        self.output.close()",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "buffer",
            "type": "t.BinaryIO"
          },
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "mode",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 115,
        "decorators": [],
        "is_async": false,
        "calls": [
          "mode",
          "unknown.__init__",
          "name",
          "buffer",
          "kwargs",
          "super"
        ],
        "docstring": null,
        "code": "def __init__(\n        self, buffer: t.BinaryIO, name: str, mode: str, **kwargs: t.Any\n    ) -> None:\n        super().__init__(buffer, **kwargs)\n        self._name = name\n        self._mode = mode",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "name",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 123,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def name(self) -> str:\n        return self._name",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "mode",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 127,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def mode(self) -> str:\n        return self._mode",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "runner",
            "type": "CliRunner"
          },
          {
            "name": "stdout_bytes",
            "type": "bytes"
          },
          {
            "name": "stderr_bytes",
            "type": "bytes"
          },
          {
            "name": "output_bytes",
            "type": "bytes"
          },
          {
            "name": "return_value",
            "type": "t.Any"
          },
          {
            "name": "exit_code",
            "type": "int"
          },
          {
            "name": "exception",
            "type": "Any"
          },
          {
            "name": "exc_info",
            "type": "Any"
          }
        ],
        "return_type": null,
        "lineno": 173,
        "decorators": [],
        "is_async": false,
        "calls": [
          "exception",
          "output_bytes",
          "stderr_bytes",
          "exit_code",
          "stdout_bytes",
          "runner",
          "return_value",
          "exc_info"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        runner: CliRunner,\n        stdout_bytes: bytes,\n        stderr_bytes: bytes,\n        output_bytes: bytes,\n        return_value: t.Any,\n        exit_code: int,\n        exception: BaseException | None,\n        exc_info: tuple[type[BaseException], BaseException, TracebackType]\n        | None = None,\n    ):\n        self.runner = runner\n        self.stdout_bytes = stdout_bytes\n        self.stderr_bytes = stderr_bytes\n        self.output_bytes = output_bytes\n        self.return_value = return_value\n        self.exit_code = exit_code\n        self.exception = exception\n        self.exc_info = exc_info",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "output",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 195,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.runner.charset",
          "self.output_bytes.decode",
          "unknown.replace"
        ],
        "docstring": "The terminal output as unicode string, as the user would see it.\n\n.. versionchanged:: 8.2\n    No longer a proxy for ``self.stdout``. Now has its own independent stream\n    that is mixing `<stdout>` and `<stderr>`, in the order they were written.",
        "code": "def output(self) -> str:\n        \"\"\"The terminal output as unicode string, as the user would see it.\n\n        .. versionchanged:: 8.2\n            No longer a proxy for ``self.stdout``. Now has its own independent stream\n            that is mixing `<stdout>` and `<stderr>`, in the order they were written.\n        \"\"\"\n        return self.output_bytes.decode(self.runner.charset, \"replace\").replace(\n            \"\\r\\n\", \"\\n\"\n        )",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "stdout",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 207,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.stdout_bytes.decode",
          "self.runner.charset",
          "unknown.replace"
        ],
        "docstring": "The standard output as unicode string.",
        "code": "def stdout(self) -> str:\n        \"\"\"The standard output as unicode string.\"\"\"\n        return self.stdout_bytes.decode(self.runner.charset, \"replace\").replace(\n            \"\\r\\n\", \"\\n\"\n        )",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "stderr",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 214,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.runner.charset",
          "self.stderr_bytes.decode",
          "unknown.replace"
        ],
        "docstring": "The standard error as unicode string.\n\n.. versionchanged:: 8.2\n    No longer raise an exception, always returns the `<stderr>` string.",
        "code": "def stderr(self) -> str:\n        \"\"\"The standard error as unicode string.\n\n        .. versionchanged:: 8.2\n            No longer raise an exception, always returns the `<stderr>` string.\n        \"\"\"\n        return self.stderr_bytes.decode(self.runner.charset, \"replace\").replace(\n            \"\\r\\n\", \"\\n\"\n        )",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 224,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "type",
          "self",
          "self.exception"
        ],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        exc_str = repr(self.exception) if self.exception else \"okay\"\n        return f\"<{type(self).__name__} {exc_str}>\"",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "charset",
            "type": "str"
          },
          {
            "name": "env",
            "type": "Any"
          },
          {
            "name": "echo_stdin",
            "type": "bool"
          },
          {
            "name": "catch_exceptions",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 251,
        "decorators": [],
        "is_async": false,
        "calls": [
          "catch_exceptions",
          "echo_stdin",
          "charset"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        charset: str = \"utf-8\",\n        env: cabc.Mapping[str, str | None] | None = None,\n        echo_stdin: bool = False,\n        catch_exceptions: bool = True,\n    ) -> None:\n        self.charset = charset\n        self.env: cabc.Mapping[str, str | None] = env or {}\n        self.echo_stdin = echo_stdin\n        self.catch_exceptions = catch_exceptions",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "get_default_prog_name",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "cli",
            "type": "Command"
          }
        ],
        "return_type": "str",
        "lineno": 263,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Given a command object it will return the default program name\nfor it.  The default is the `name` attribute or ``\"root\"`` if not\nset.",
        "code": "def get_default_prog_name(self, cli: Command) -> str:\n        \"\"\"Given a command object it will return the default program name\n        for it.  The default is the `name` attribute or ``\"root\"`` if not\n        set.\n        \"\"\"\n        return cli.name or \"root\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "make_env",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "overrides",
            "type": "Any"
          }
        ],
        "return_type": "cabc.Mapping[str, Any]",
        "lineno": 270,
        "decorators": [],
        "is_async": false,
        "calls": [
          "rv.update",
          "overrides",
          "dict",
          "self.env"
        ],
        "docstring": "Returns the environment overrides for invoking a script.",
        "code": "def make_env(\n        self, overrides: cabc.Mapping[str, str | None] | None = None\n    ) -> cabc.Mapping[str, str | None]:\n        \"\"\"Returns the environment overrides for invoking a script.\"\"\"\n        rv = dict(self.env)\n        if overrides:\n            rv.update(overrides)\n        return rv",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "isolation",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "input",
            "type": "Any"
          },
          {
            "name": "env",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "bool"
          }
        ],
        "return_type": "cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]",
        "lineno": 280,
        "decorators": [
          {
            "name": "contextlib.contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "old_env.items",
          "_NamedTextIOWrapper",
          "old_stderr",
          "_compat.should_strip_ansi",
          "_pause_echo",
          "sys.stdin.read",
          "StreamMixer",
          "old_stdout",
          "sys.stdout.write",
          "old_hidden_prompt_func",
          "sys.stdin",
          "sys.stdout.flush",
          "stream_mixer.stdout",
          "old_visible_prompt_func",
          "echo_input",
          "env.items",
          "bytes_input",
          "self.make_env",
          "should_strip_ansi",
          "termui.visible_prompt_func",
          "input",
          "old_should_strip_ansi",
          "EOFError",
          "old_stdin",
          "_getchar",
          "visible_input",
          "old_forced_width",
          "sys.stderr",
          "key",
          "os.environ.get",
          "next",
          "text_input",
          "utils.should_strip_ansi",
          "old__getchar_func",
          "color",
          "old__compat_should_strip_ansi",
          "termui.hidden_prompt_func",
          "char",
          "t.BinaryIO",
          "formatting.FORCED_WIDTH",
          "self.charset",
          "termui._getchar",
          "sys.stdout",
          "value",
          "stream_mixer.stderr",
          "t.cast",
          "EchoingStdin",
          "hidden_input",
          "env",
          "make_input_stream",
          "unknown.rstrip"
        ],
        "docstring": "A context manager that sets up the isolation for invoking of a\ncommand line tool.  This sets up `<stdin>` with the given input data\nand `os.environ` with the overrides from the given dictionary.\nThis also rebinds some internals in Click to be mocked (like the\nprompt functionality).\n\nThis is automatically done in the :meth:`invoke` method.\n\n:param input: the input stream to put into `sys.stdin`.\n:param env: the environment overrides as dictionary.\n:param color: whether the output should contain color codes. The\n              application can still override this explicitly.\n\n.. versionadded:: 8.2\n    An additional output stream is returned, which is a mix of\n    `<stdout>` and `<stderr>` streams.\n\n.. versionchanged:: 8.2\n    Always returns the `<stderr>` stream.\n\n.. versionchanged:: 8.0\n    `<stderr>` is opened with ``errors=\"backslashreplace\"``\n    instead of the default ``\"strict\"``.\n\n.. versionchanged:: 4.0\n    Added the ``color`` parameter.",
        "code": "def isolation(\n        self,\n        input: str | bytes | t.IO[t.Any] | None = None,\n        env: cabc.Mapping[str, str | None] | None = None,\n        color: bool = False,\n    ) -> cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]:\n        \"\"\"A context manager that sets up the isolation for invoking of a\n        command line tool.  This sets up `<stdin>` with the given input data\n        and `os.environ` with the overrides from the given dictionary.\n        This also rebinds some internals in Click to be mocked (like the\n        prompt functionality).\n\n        This is automatically done in the :meth:`invoke` method.\n\n        :param input: the input stream to put into `sys.stdin`.\n        :param env: the environment overrides as dictionary.\n        :param color: whether the output should contain color codes. The\n                      application can still override this explicitly.\n\n        .. versionadded:: 8.2\n            An additional output stream is returned, which is a mix of\n            `<stdout>` and `<stderr>` streams.\n\n        .. versionchanged:: 8.2\n            Always returns the `<stderr>` stream.\n\n        .. versionchanged:: 8.0\n            `<stderr>` is opened with ``errors=\"backslashreplace\"``\n            instead of the default ``\"strict\"``.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` parameter.\n        \"\"\"\n        bytes_input = make_input_stream(input, self.charset)\n        echo_input = None\n\n        old_stdin = sys.stdin\n        old_stdout = sys.stdout\n        old_stderr = sys.stderr\n        old_forced_width = formatting.FORCED_WIDTH\n        formatting.FORCED_WIDTH = 80\n\n        env = self.make_env(env)\n\n        stream_mixer = StreamMixer()\n\n        if self.echo_stdin:\n            bytes_input = echo_input = t.cast(\n                t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n            )\n\n        sys.stdin = text_input = _NamedTextIOWrapper(\n            bytes_input, encoding=self.charset, name=\"<stdin>\", mode=\"r\"\n        )\n\n        if self.echo_stdin:\n            # Force unbuffered reads, otherwise TextIOWrapper reads a\n            # large chunk which is echoed early.\n            text_input._CHUNK_SIZE = 1  # type: ignore\n\n        sys.stdout = _NamedTextIOWrapper(\n            stream_mixer.stdout, encoding=self.charset, name=\"<stdout>\", mode=\"w\"\n        )\n\n        sys.stderr = _NamedTextIOWrapper(\n            stream_mixer.stderr,\n            encoding=self.charset,\n            name=\"<stderr>\",\n            mode=\"w\",\n            errors=\"backslashreplace\",\n        )\n\n        @_pause_echo(echo_input)  # type: ignore\n        def visible_input(prompt: str | None = None) -> str:\n            sys.stdout.write(prompt or \"\")\n            try:\n                val = next(text_input).rstrip(\"\\r\\n\")\n            except StopIteration as e:\n                raise EOFError() from e\n            sys.stdout.write(f\"{val}\\n\")\n            sys.stdout.flush()\n            return val\n\n        @_pause_echo(echo_input)  # type: ignore\n        def hidden_input(prompt: str | None = None) -> str:\n            sys.stdout.write(f\"{prompt or ''}\\n\")\n            sys.stdout.flush()\n            try:\n                return next(text_input).rstrip(\"\\r\\n\")\n            except StopIteration as e:\n                raise EOFError() from e\n\n        @_pause_echo(echo_input)  # type: ignore\n        def _getchar(echo: bool) -> str:\n            char = sys.stdin.read(1)\n\n            if echo:\n                sys.stdout.write(char)\n\n            sys.stdout.flush()\n            return char\n\n        default_color = color\n\n        def should_strip_ansi(\n            stream: t.IO[t.Any] | None = None, color: bool | None = None\n        ) -> bool:\n            if color is None:\n                return not default_color\n            return not color\n\n        old_visible_prompt_func = termui.visible_prompt_func\n        old_hidden_prompt_func = termui.hidden_prompt_func\n        old__getchar_func = termui._getchar\n        old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n        old__compat_should_strip_ansi = _compat.should_strip_ansi\n        termui.visible_prompt_func = visible_input\n        termui.hidden_prompt_func = hidden_input\n        termui._getchar = _getchar\n        utils.should_strip_ansi = should_strip_ansi  # type: ignore\n        _compat.should_strip_ansi = should_strip_ansi\n\n        old_env = {}\n        try:\n            for key, value in env.items():\n                old_env[key] = os.environ.get(key)\n                if value is None:\n                    try:\n                        del os.environ[key]\n                    except Exception:\n                        pass\n                else:\n                    os.environ[key] = value\n            yield (stream_mixer.stdout, stream_mixer.stderr, stream_mixer.output)\n        finally:\n            for key, value in old_env.items():\n                if value is None:\n                    try:\n                        del os.environ[key]\n                    except Exception:\n                        pass\n                else:\n                    os.environ[key] = value\n            sys.stdout = old_stdout\n            sys.stderr = old_stderr\n            sys.stdin = old_stdin\n            termui.visible_prompt_func = old_visible_prompt_func\n            termui.hidden_prompt_func = old_hidden_prompt_func\n            termui._getchar = old__getchar_func\n            utils.should_strip_ansi = old_should_strip_ansi  # type: ignore\n            _compat.should_strip_ansi = old__compat_should_strip_ansi\n            formatting.FORCED_WIDTH = old_forced_width",
        "line_count": 152,
        "needs_llm_summary": true
      },
      {
        "name": "invoke",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "cli",
            "type": "Command"
          },
          {
            "name": "args",
            "type": "Any"
          },
          {
            "name": "input",
            "type": "Any"
          },
          {
            "name": "env",
            "type": "Any"
          },
          {
            "name": "catch_exceptions",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "bool"
          }
        ],
        "return_type": "Result",
        "lineno": 433,
        "decorators": [],
        "is_async": false,
        "calls": [
          "int",
          "sys.exc_info",
          "Result",
          "cli",
          "isinstance",
          "sys.stdout.write",
          "extra",
          "sys.stdout.flush",
          "stderr",
          "exception",
          "sys.stderr.flush",
          "self",
          "e_code",
          "extra.pop",
          "input",
          "exit_code",
          "return_value",
          "exc_info",
          "e",
          "str",
          "stdout",
          "output",
          "cli.main",
          "args",
          "color",
          "unknown.getvalue",
          "self.isolation",
          "shlex.split",
          "t.cast",
          "prog_name",
          "e.code",
          "env",
          "self.catch_exceptions",
          "self.get_default_prog_name"
        ],
        "docstring": "Invokes a command in an isolated environment.  The arguments are\nforwarded directly to the command line script, the `extra` keyword\narguments are passed to the :meth:`~clickpkg.Command.main` function of\nthe command.\n\nThis returns a :class:`Result` object.\n\n:param cli: the command to invoke\n:param args: the arguments to invoke. It may be given as an iterable\n             or a string. When given as string it will be interpreted\n             as a Unix shell command. More details at\n             :func:`shlex.split`.\n:param input: the input data for `sys.stdin`.\n:param env: the environment overrides.\n:param catch_exceptions: Whether to catch any other exceptions than\n                         ``SystemExit``. If :data:`None`, the value\n                         from :class:`CliRunner` is used.\n:param extra: the keyword arguments to pass to :meth:`main`.\n:param color: whether the output should contain color codes. The\n              application can still override this explicitly.\n\n.. versionadded:: 8.2\n    The result object has the ``output_bytes`` attribute with\n    the mix of ``stdout_bytes`` and ``stderr_bytes``, as the user would\n    see it in its terminal.\n\n.. versionchanged:: 8.2\n    The result object always returns the ``stderr_bytes`` stream.\n\n.. versionchanged:: 8.0\n    The result object has the ``return_value`` attribute with\n    the value returned from the invoked command.\n\n.. versionchanged:: 4.0\n    Added the ``color`` parameter.\n\n.. versionchanged:: 3.0\n    Added the ``catch_exceptions`` parameter.\n\n.. versionchanged:: 3.0\n    The result object has the ``exc_info`` attribute with the\n    traceback if available.",
        "code": "def invoke(\n        self,\n        cli: Command,\n        args: str | cabc.Sequence[str] | None = None,\n        input: str | bytes | t.IO[t.Any] | None = None,\n        env: cabc.Mapping[str, str | None] | None = None,\n        catch_exceptions: bool | None = None,\n        color: bool = False,\n        **extra: t.Any,\n    ) -> Result:\n        \"\"\"Invokes a command in an isolated environment.  The arguments are\n        forwarded directly to the command line script, the `extra` keyword\n        arguments are passed to the :meth:`~clickpkg.Command.main` function of\n        the command.\n\n        This returns a :class:`Result` object.\n\n        :param cli: the command to invoke\n        :param args: the arguments to invoke. It may be given as an iterable\n                     or a string. When given as string it will be interpreted\n                     as a Unix shell command. More details at\n                     :func:`shlex.split`.\n        :param input: the input data for `sys.stdin`.\n        :param env: the environment overrides.\n        :param catch_exceptions: Whether to catch any other exceptions than\n                                 ``SystemExit``. If :data:`None`, the value\n                                 from :class:`CliRunner` is used.\n        :param extra: the keyword arguments to pass to :meth:`main`.\n        :param color: whether the output should contain color codes. The\n                      application can still override this explicitly.\n\n        .. versionadded:: 8.2\n            The result object has the ``output_bytes`` attribute with\n            the mix of ``stdout_bytes`` and ``stderr_bytes``, as the user would\n            see it in its terminal.\n\n        .. versionchanged:: 8.2\n            The result object always returns the ``stderr_bytes`` stream.\n\n        .. versionchanged:: 8.0\n            The result object has the ``return_value`` attribute with\n            the value returned from the invoked command.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` parameter.\n\n        .. versionchanged:: 3.0\n            Added the ``catch_exceptions`` parameter.\n\n        .. versionchanged:: 3.0\n            The result object has the ``exc_info`` attribute with the\n            traceback if available.\n        \"\"\"\n        exc_info = None\n        if catch_exceptions is None:\n            catch_exceptions = self.catch_exceptions\n\n        with self.isolation(input=input, env=env, color=color) as outstreams:\n            return_value = None\n            exception: BaseException | None = None\n            exit_code = 0\n\n            if isinstance(args, str):\n                args = shlex.split(args)\n\n            try:\n                prog_name = extra.pop(\"prog_name\")\n            except KeyError:\n                prog_name = self.get_default_prog_name(cli)\n\n            try:\n                return_value = cli.main(args=args or (), prog_name=prog_name, **extra)\n            except SystemExit as e:\n                exc_info = sys.exc_info()\n                e_code = t.cast(\"int | t.Any | None\", e.code)\n\n                if e_code is None:\n                    e_code = 0\n\n                if e_code != 0:\n                    exception = e\n\n                if not isinstance(e_code, int):\n                    sys.stdout.write(str(e_code))\n                    sys.stdout.write(\"\\n\")\n                    e_code = 1\n\n                exit_code = e_code\n\n            except Exception as e:\n                if not catch_exceptions:\n                    raise\n                exception = e\n                exit_code = 1\n                exc_info = sys.exc_info()\n            finally:\n                sys.stdout.flush()\n                sys.stderr.flush()\n                stdout = outstreams[0].getvalue()\n                stderr = outstreams[1].getvalue()\n                output = outstreams[2].getvalue()\n\n        return Result(\n            runner=self,\n            stdout_bytes=stdout,\n            stderr_bytes=stderr,\n            output_bytes=output,\n            return_value=return_value,\n            exit_code=exit_code,\n            exception=exception,\n            exc_info=exc_info,  # type: ignore\n        )",
        "line_count": 112,
        "needs_llm_summary": true
      },
      {
        "name": "isolated_filesystem",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "temp_dir",
            "type": "Any"
          }
        ],
        "return_type": "cabc.Iterator[str]",
        "lineno": 547,
        "decorators": [
          {
            "name": "contextlib.contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "temp_dir",
          "shutil.rmtree",
          "os.chdir",
          "tempfile.mkdtemp",
          "dt",
          "os.getcwd",
          "cwd"
        ],
        "docstring": "A context manager that creates a temporary directory and\nchanges the current working directory to it. This isolates tests\nthat affect the contents of the CWD to prevent them from\ninterfering with each other.\n\n:param temp_dir: Create the temporary directory under this\n    directory. If given, the created directory is not removed\n    when exiting.\n\n.. versionchanged:: 8.0\n    Added the ``temp_dir`` parameter.",
        "code": "def isolated_filesystem(\n        self, temp_dir: str | os.PathLike[str] | None = None\n    ) -> cabc.Iterator[str]:\n        \"\"\"A context manager that creates a temporary directory and\n        changes the current working directory to it. This isolates tests\n        that affect the contents of the CWD to prevent them from\n        interfering with each other.\n\n        :param temp_dir: Create the temporary directory under this\n            directory. If given, the created directory is not removed\n            when exiting.\n\n        .. versionchanged:: 8.0\n            Added the ``temp_dir`` parameter.\n        \"\"\"\n        cwd = os.getcwd()\n        dt = tempfile.mkdtemp(dir=temp_dir)\n        os.chdir(dt)\n\n        try:\n            yield dt\n        finally:\n            os.chdir(cwd)\n\n            if temp_dir is None:\n                import shutil\n\n                try:\n                    shutil.rmtree(dt)\n                except OSError:\n                    pass",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "visible_input",
        "args": [
          {
            "name": "prompt",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 353,
        "decorators": [
          {
            "name": "_pause_echo",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "echo_input",
          "next",
          "_pause_echo",
          "text_input",
          "sys.stdout.write",
          "EOFError",
          "sys.stdout.flush",
          "unknown.rstrip"
        ],
        "docstring": null,
        "code": "def visible_input(prompt: str | None = None) -> str:\n            sys.stdout.write(prompt or \"\")\n            try:\n                val = next(text_input).rstrip(\"\\r\\n\")\n            except StopIteration as e:\n                raise EOFError() from e\n            sys.stdout.write(f\"{val}\\n\")\n            sys.stdout.flush()\n            return val",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "hidden_input",
        "args": [
          {
            "name": "prompt",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 364,
        "decorators": [
          {
            "name": "_pause_echo",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "echo_input",
          "next",
          "_pause_echo",
          "text_input",
          "sys.stdout.write",
          "EOFError",
          "sys.stdout.flush",
          "unknown.rstrip"
        ],
        "docstring": null,
        "code": "def hidden_input(prompt: str | None = None) -> str:\n            sys.stdout.write(f\"{prompt or ''}\\n\")\n            sys.stdout.flush()\n            try:\n                return next(text_input).rstrip(\"\\r\\n\")\n            except StopIteration as e:\n                raise EOFError() from e",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_getchar",
        "args": [
          {
            "name": "echo",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 373,
        "decorators": [
          {
            "name": "_pause_echo",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "echo_input",
          "_pause_echo",
          "sys.stdin.read",
          "sys.stdout.write",
          "char",
          "sys.stdout.flush"
        ],
        "docstring": null,
        "code": "def _getchar(echo: bool) -> str:\n            char = sys.stdin.read(1)\n\n            if echo:\n                sys.stdout.write(char)\n\n            sys.stdout.flush()\n            return char",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "should_strip_ansi",
        "args": [
          {
            "name": "stream",
            "type": "Any"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 384,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def should_strip_ansi(\n            stream: t.IO[t.Any] | None = None, color: bool | None = None\n        ) -> bool:\n            if color is None:\n                return not default_color\n            return not color",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "EchoingStdin",
        "methods": [
          "__init__",
          "__getattr__",
          "_echo",
          "read",
          "read1",
          "readline",
          "readlines",
          "__iter__",
          "__repr__"
        ],
        "base_classes": [],
        "lineno": 25,
        "docstring": null
      },
      {
        "name": "BytesIOCopy",
        "methods": [
          "__init__",
          "flush",
          "write"
        ],
        "base_classes": [
          "io.BytesIO"
        ],
        "lineno": 69,
        "docstring": "Patch ``io.BytesIO`` to let the written stream be copied to another.\n\n.. versionadded:: 8.2"
      },
      {
        "name": "StreamMixer",
        "methods": [
          "__init__",
          "__del__"
        ],
        "base_classes": [],
        "lineno": 88,
        "docstring": "Mixes `<stdout>` and `<stderr>` streams.\n\nThe result is available in the ``output`` attribute.\n\n.. versionadded:: 8.2"
      },
      {
        "name": "_NamedTextIOWrapper",
        "methods": [
          "__init__",
          "name",
          "mode"
        ],
        "base_classes": [
          "io.TextIOWrapper"
        ],
        "lineno": 114,
        "docstring": null
      },
      {
        "name": "Result",
        "methods": [
          "__init__",
          "output",
          "stdout",
          "stderr",
          "__repr__"
        ],
        "base_classes": [],
        "lineno": 151,
        "docstring": "Holds the captured result of an invoked CLI script.\n\n:param runner: The runner that created the result\n:param stdout_bytes: The standard output as bytes.\n:param stderr_bytes: The standard error as bytes.\n:param output_bytes: A mix of ``stdout_bytes`` and ``stderr_bytes``, as the\n    user would see  it in its terminal.\n:param return_value: The value returned from the invoked command.\n:param exit_code: The exit code as integer.\n:param exception: The exception that happened if one did.\n:param exc_info: Exception information (exception type, exception instance,\n    traceback type).\n\n.. versionchanged:: 8.2\n    ``stderr_bytes`` no longer optional, ``output_bytes`` introduced and\n    ``mix_stderr`` has been removed.\n\n.. versionadded:: 8.0\n    Added ``return_value``."
      },
      {
        "name": "CliRunner",
        "methods": [
          "__init__",
          "get_default_prog_name",
          "make_env",
          "isolation",
          "invoke",
          "isolated_filesystem"
        ],
        "base_classes": [],
        "lineno": 229,
        "docstring": "The CLI runner provides functionality to invoke a Click command line\nscript for unittesting purposes in a isolated environment.  This only\nworks in single-threaded systems without any concurrency as it changes the\nglobal interpreter state.\n\n:param charset: the character set for the input and output data.\n:param env: a dictionary with environment variables for overriding.\n:param echo_stdin: if this is set to `True`, then reading from `<stdin>` writes\n                   to `<stdout>`.  This is useful for showing examples in\n                   some circumstances.  Note that regular prompts\n                   will automatically echo the input.\n:param catch_exceptions: Whether to catch any exceptions other than\n                         ``SystemExit`` when running :meth:`~CliRunner.invoke`.\n\n.. versionchanged:: 8.2\n    Added the ``catch_exceptions`` parameter.\n\n.. versionchanged:: 8.2\n    ``mix_stderr`` parameter has been removed."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "contextlib",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "shlex",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 8,
        "type": "import"
      },
      {
        "module": "tempfile",
        "alias": null,
        "lineno": 9,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 10,
        "type": "import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "_compat",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "formatting",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "termui",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "utils",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "_find_binary_reader",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "_typeshed",
        "name": "ReadableBuffer",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Command",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "shutil",
        "alias": null,
        "lineno": 572,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "contextlib",
        "sys",
        "shutil",
        "typing",
        "os",
        "tempfile",
        "collections",
        "io"
      ],
      "third_party": {
        "other": [
          "__future__",
          "shlex",
          "types",
          "_compat",
          "formatting",
          "termui",
          "utils",
          "_typeshed",
          "core"
        ]
      },
      "tech_stack": []
    },
    "line_count": 578
  },
  "src/click/types.py": {
    "filepath": "../click/src/click/types.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_is_file_like",
        "args": [
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "te.TypeGuard[t.IO[t.Any]]",
        "lineno": 875,
        "decorators": [],
        "is_async": false,
        "calls": [
          "hasattr",
          "value"
        ],
        "docstring": null,
        "code": "def _is_file_like(value: t.Any) -> te.TypeGuard[t.IO[t.Any]]:\n    return hasattr(value, \"read\") or hasattr(value, \"write\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "convert_type",
        "args": [
          {
            "name": "ty",
            "type": "Any"
          },
          {
            "name": "default",
            "type": "Any"
          }
        ],
        "return_type": "ParamType",
        "lineno": 1112,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "AssertionError",
          "item",
          "type",
          "isinstance",
          "issubclass",
          "ParamType",
          "default",
          "ty",
          "Tuple",
          "FuncParamType",
          "map"
        ],
        "docstring": "Find the most appropriate :class:`ParamType` for the given Python\ntype. If the type isn't provided, it can be inferred from a default\nvalue.",
        "code": "def convert_type(ty: t.Any | None, default: t.Any | None = None) -> ParamType:\n    \"\"\"Find the most appropriate :class:`ParamType` for the given Python\n    type. If the type isn't provided, it can be inferred from a default\n    value.\n    \"\"\"\n    guessed_type = False\n\n    if ty is None and default is not None:\n        if isinstance(default, (tuple, list)):\n            # If the default is empty, ty will remain None and will\n            # return STRING.\n            if default:\n                item = default[0]\n\n                # A tuple of tuples needs to detect the inner types.\n                # Can't call convert recursively because that would\n                # incorrectly unwind the tuple to a single type.\n                if isinstance(item, (tuple, list)):\n                    ty = tuple(map(type, item))\n                else:\n                    ty = type(item)\n        else:\n            ty = type(default)\n\n        guessed_type = True\n\n    if isinstance(ty, tuple):\n        return Tuple(ty)\n\n    if isinstance(ty, ParamType):\n        return ty\n\n    if ty is str or ty is None:\n        return STRING\n\n    if ty is int:\n        return INT\n\n    if ty is float:\n        return FLOAT\n\n    if ty is bool:\n        return BOOL\n\n    if guessed_type:\n        return STRING\n\n    if __debug__:\n        try:\n            if issubclass(ty, ParamType):\n                raise AssertionError(\n                    f\"Attempted to use an uninstantiated parameter type ({ty}).\"\n                )\n        except TypeError:\n            # ty is an instance (correct), so issubclass fails.\n            pass\n\n    return FuncParamType(ty)",
        "line_count": 58,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 62,
        "decorators": [],
        "is_async": false,
        "calls": [
          "type",
          "self",
          "hasattr",
          "self.name",
          "param_type",
          "unknown.__name__.partition",
          "param_type.partition"
        ],
        "docstring": "Gather information that could be useful for a tool generating\nuser-facing documentation.\n\nUse :meth:`click.Context.to_info_dict` to traverse the entire\nCLI structure.\n\n.. versionadded:: 8.0",
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        \"\"\"Gather information that could be useful for a tool generating\n        user-facing documentation.\n\n        Use :meth:`click.Context.to_info_dict` to traverse the entire\n        CLI structure.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        # The class name without the \"ParamType\" suffix.\n        param_type = type(self).__name__.partition(\"ParamType\")[0]\n        param_type = param_type.partition(\"ParameterType\")[0]\n\n        # Custom subclasses might not remember to set a name.\n        if hasattr(self, \"name\"):\n            name = self.name\n        else:\n            name = param_type\n\n        return {\"param_type\": param_type, \"name\": name}",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 83,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "param",
          "self.convert",
          "value"
        ],
        "docstring": null,
        "code": "def __call__(\n        self,\n        value: t.Any,\n        param: Parameter | None = None,\n        ctx: Context | None = None,\n    ) -> t.Any:\n        if value is not None:\n            return self.convert(value, param, ctx)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "get_metavar",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 92,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Returns the metavar default for this param if it provides one.",
        "code": "def get_metavar(self, param: Parameter, ctx: Context) -> str | None:\n        \"\"\"Returns the metavar default for this param if it provides one.\"\"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "get_missing_message",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 95,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Optionally might return extra information about a missing\nparameter.\n\n.. versionadded:: 2.0",
        "code": "def get_missing_message(self, param: Parameter, ctx: Context | None) -> str | None:\n        \"\"\"Optionally might return extra information about a missing\n        parameter.\n\n        .. versionadded:: 2.0\n        \"\"\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 102,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Convert the value to the correct type. This is not called if\nthe value is ``None`` (the missing value).\n\nThis must accept string values from the command line, as well as\nvalues that are already the correct type. It may also convert\nother compatible types.\n\nThe ``param`` and ``ctx`` arguments may be ``None`` in certain\nsituations, such as when converting prompt input.\n\nIf the value cannot be converted, call :meth:`fail` with a\ndescriptive message.\n\n:param value: The value to convert.\n:param param: The parameter that is using this type to convert\n    its value. May be ``None``.\n:param ctx: The current context that arrived at this value. May\n    be ``None``.",
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        \"\"\"Convert the value to the correct type. This is not called if\n        the value is ``None`` (the missing value).\n\n        This must accept string values from the command line, as well as\n        values that are already the correct type. It may also convert\n        other compatible types.\n\n        The ``param`` and ``ctx`` arguments may be ``None`` in certain\n        situations, such as when converting prompt input.\n\n        If the value cannot be converted, call :meth:`fail` with a\n        descriptive message.\n\n        :param value: The value to convert.\n        :param param: The parameter that is using this type to convert\n            its value. May be ``None``.\n        :param ctx: The current context that arrived at this value. May\n            be ``None``.\n        \"\"\"\n        return value",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "split_envvar_value",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "rv",
            "type": "str"
          }
        ],
        "return_type": "cabc.Sequence[str]",
        "lineno": 126,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.envvar_list_splitter",
          "unknown.split"
        ],
        "docstring": "Given a value from an environment variable this splits it up\ninto small chunks depending on the defined envvar list splitter.\n\nIf the splitter is set to `None`, which means that whitespace splits,\nthen leading and trailing whitespace is ignored.  Otherwise, leading\nand trailing splitters usually lead to empty items being included.",
        "code": "def split_envvar_value(self, rv: str) -> cabc.Sequence[str]:\n        \"\"\"Given a value from an environment variable this splits it up\n        into small chunks depending on the defined envvar list splitter.\n\n        If the splitter is set to `None`, which means that whitespace splits,\n        then leading and trailing whitespace is ignored.  Otherwise, leading\n        and trailing splitters usually lead to empty items being included.\n        \"\"\"\n        return (rv or \"\").split(self.envvar_list_splitter)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "fail",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "message",
            "type": "str"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.NoReturn",
        "lineno": 136,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "BadParameter",
          "message",
          "param"
        ],
        "docstring": "Helper method to fail with an invalid value message.",
        "code": "def fail(\n        self,\n        message: str,\n        param: Parameter | None = None,\n        ctx: Context | None = None,\n    ) -> t.NoReturn:\n        \"\"\"Helper method to fail with an invalid value message.\"\"\"\n        raise BadParameter(message, ctx=ctx, param=param)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "shell_complete",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "list[CompletionItem]",
        "lineno": 145,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Return a list of\n:class:`~click.shell_completion.CompletionItem` objects for the\nincomplete value. Most types do not provide completions, but\nsome do, and this allows custom types to provide custom\ncompletions as well.\n\n:param ctx: Invocation context for this command.\n:param param: The parameter that is requesting completion.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
        "code": "def shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Return a list of\n        :class:`~click.shell_completion.CompletionItem` objects for the\n        incomplete value. Most types do not provide completions, but\n        some do, and this allows custom types to provide custom\n        completions as well.\n\n        :param ctx: Invocation context for this command.\n        :param param: The parameter that is requesting completion.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return []",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "arity",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 167,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "NotImplementedError"
        ],
        "docstring": null,
        "code": "def arity(self) -> int:  # type: ignore\n        raise NotImplementedError()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "func",
            "type": "t.Callable[Any, t.Any]"
          }
        ],
        "return_type": "None",
        "lineno": 172,
        "decorators": [],
        "is_async": false,
        "calls": [
          "func"
        ],
        "docstring": null,
        "code": "def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:\n        self.name: str = func.__name__\n        self.func = func",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 176,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.func",
          "unknown.to_info_dict",
          "super"
        ],
        "docstring": null,
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict[\"func\"] = self.func\n        return info_dict",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 181,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.func",
          "value.decode",
          "param",
          "ctx",
          "value",
          "str",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        try:\n            return self.func(value)\n        except ValueError:\n            try:\n                value = str(value)\n            except UnicodeError:\n                value = value.decode(\"utf-8\", \"replace\")\n\n            self.fail(value, param, ctx)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 198,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        return value",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 203,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return \"UNPROCESSED\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 210,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enc",
          "_get_argv_encoding",
          "value.decode",
          "value",
          "str",
          "bytes",
          "isinstance",
          "sys.getfilesystemencoding",
          "fs_enc"
        ],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        if isinstance(value, bytes):\n            enc = _get_argv_encoding()\n            try:\n                value = value.decode(enc)\n            except UnicodeError:\n                fs_enc = sys.getfilesystemencoding()\n                if fs_enc != enc:\n                    try:\n                        value = value.decode(fs_enc)\n                    except UnicodeError:\n                        value = value.decode(\"utf-8\", \"replace\")\n                else:\n                    value = value.decode(\"utf-8\", \"replace\")\n            return value\n        return str(value)",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 229,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return \"STRING\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "choices",
            "type": "cabc.Iterable[ParamTypeValue]"
          },
          {
            "name": "case_sensitive",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 258,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "choices",
          "case_sensitive"
        ],
        "docstring": null,
        "code": "def __init__(\n        self, choices: cabc.Iterable[ParamTypeValue], case_sensitive: bool = True\n    ) -> None:\n        self.choices: cabc.Sequence[ParamTypeValue] = tuple(choices)\n        self.case_sensitive = case_sensitive",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 264,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "unknown.to_info_dict",
          "self.choices",
          "self.case_sensitive"
        ],
        "docstring": null,
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict[\"choices\"] = self.choices\n        info_dict[\"case_sensitive\"] = self.case_sensitive\n        return info_dict",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "_normalized_mapping",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "cabc.Mapping[ParamTypeValue, str]",
        "lineno": 270,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "choice",
          "self.normalize_choice"
        ],
        "docstring": "Returns mapping where keys are the original choices and the values are\nthe normalized values that are accepted via the command line.\n\nThis is a simple wrapper around :meth:`normalize_choice`, use that\ninstead which is supported.",
        "code": "def _normalized_mapping(\n        self, ctx: Context | None = None\n    ) -> cabc.Mapping[ParamTypeValue, str]:\n        \"\"\"\n        Returns mapping where keys are the original choices and the values are\n        the normalized values that are accepted via the command line.\n\n        This is a simple wrapper around :meth:`normalize_choice`, use that\n        instead which is supported.\n        \"\"\"\n        return {\n            choice: self.normalize_choice(\n                choice=choice,\n                ctx=ctx,\n            )\n            for choice in self.choices\n        }",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "normalize_choice",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "choice",
            "type": "ParamTypeValue"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 288,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enum.Enum",
          "choice",
          "ctx.token_normalize_func",
          "normed_value.casefold",
          "str",
          "isinstance",
          "normed_value"
        ],
        "docstring": "Normalize a choice value, used to map a passed string to a choice.\nEach choice must have a unique normalized value.\n\nBy default uses :meth:`Context.token_normalize_func` and if not case\nsensitive, convert it to a casefolded value.\n\n.. versionadded:: 8.2.0",
        "code": "def normalize_choice(self, choice: ParamTypeValue, ctx: Context | None) -> str:\n        \"\"\"\n        Normalize a choice value, used to map a passed string to a choice.\n        Each choice must have a unique normalized value.\n\n        By default uses :meth:`Context.token_normalize_func` and if not case\n        sensitive, convert it to a casefolded value.\n\n        .. versionadded:: 8.2.0\n        \"\"\"\n        normed_value = choice.name if isinstance(choice, enum.Enum) else str(choice)\n\n        if ctx is not None and ctx.token_normalize_func is not None:\n            normed_value = ctx.token_normalize_func(normed_value)\n\n        if not self.case_sensitive:\n            normed_value = normed_value.casefold()\n\n        return normed_value",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "get_metavar",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 308,
        "decorators": [],
        "is_async": false,
        "calls": [
          "choice",
          "unknown.join",
          "type",
          "str",
          "ctx",
          "dict.fromkeys",
          "choice_metavars",
          "unknown.name.upper",
          "unknown.values",
          "self._normalized_mapping",
          "convert_type",
          "i"
        ],
        "docstring": null,
        "code": "def get_metavar(self, param: Parameter, ctx: Context) -> str | None:\n        if param.param_type_name == \"option\" and not param.show_choices:  # type: ignore\n            choice_metavars = [\n                convert_type(type(choice)).name.upper() for choice in self.choices\n            ]\n            choices_str = \"|\".join([*dict.fromkeys(choice_metavars)])\n        else:\n            choices_str = \"|\".join(\n                [str(i) for i in self._normalized_mapping(ctx=ctx).values()]\n            )\n\n        # Use curly braces to indicate a required argument.\n        if param.required and param.param_type_name == \"argument\":\n            return f\"{{{choices_str}}}\"\n\n        # Use square braces to indicate an option or optional argument.\n        return f\"[{choices_str}]\"",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "get_missing_message",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 326,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "ctx",
          "_",
          "unknown.values",
          "self._normalized_mapping",
          "unknown.format"
        ],
        "docstring": "Message shown when no choice is passed.\n\n.. versionchanged:: 8.2.0 Added ``ctx`` argument.",
        "code": "def get_missing_message(self, param: Parameter, ctx: Context | None) -> str:\n        \"\"\"\n        Message shown when no choice is passed.\n\n        .. versionchanged:: 8.2.0 Added ``ctx`` argument.\n        \"\"\"\n        return _(\"Choose from:\\n\\t{choices}\").format(\n            choices=\",\\n\\t\".join(self._normalized_mapping(ctx=ctx).values())\n        )",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "ParamTypeValue",
        "lineno": 336,
        "decorators": [],
        "is_async": false,
        "calls": [
          "normalized_mapping.items",
          "self.normalize_choice",
          "self.get_invalid_choice_message",
          "value",
          "ctx",
          "next",
          "param",
          "self._normalized_mapping",
          "self.fail"
        ],
        "docstring": "For a given value from the parser, normalize it and find its\nmatching normalized value in the list of choices. Then return the\nmatched \"original\" choice.",
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> ParamTypeValue:\n        \"\"\"\n        For a given value from the parser, normalize it and find its\n        matching normalized value in the list of choices. Then return the\n        matched \"original\" choice.\n        \"\"\"\n        normed_value = self.normalize_choice(choice=value, ctx=ctx)\n        normalized_mapping = self._normalized_mapping(ctx=ctx)\n\n        try:\n            return next(\n                original\n                for original, normalized in normalized_mapping.items()\n                if normalized == normed_value\n            )\n        except StopIteration:\n            self.fail(\n                self.get_invalid_choice_message(value=value, ctx=ctx),\n                param=param,\n                ctx=ctx,\n            )",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "get_invalid_choice_message",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 360,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "unknown.join",
          "unknown.format",
          "self.choices",
          "value",
          "ctx",
          "len",
          "ngettext",
          "unknown.values",
          "self._normalized_mapping",
          "choices_str",
          "map"
        ],
        "docstring": "Get the error message when the given choice is invalid.\n\n:param value: The invalid value.\n\n.. versionadded:: 8.2",
        "code": "def get_invalid_choice_message(self, value: t.Any, ctx: Context | None) -> str:\n        \"\"\"Get the error message when the given choice is invalid.\n\n        :param value: The invalid value.\n\n        .. versionadded:: 8.2\n        \"\"\"\n        choices_str = \", \".join(map(repr, self._normalized_mapping(ctx=ctx).values()))\n        return ngettext(\n            \"{value!r} is not {choice}.\",\n            \"{value!r} is not one of {choices}.\",\n            len(self.choices),\n        ).format(value=value, choice=choices_str, choices=choices_str)",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 374,
        "decorators": [],
        "is_async": false,
        "calls": [
          "list",
          "self.choices"
        ],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"Choice({list(self.choices)})\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "shell_complete",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "list[CompletionItem]",
        "lineno": 377,
        "decorators": [],
        "is_async": false,
        "calls": [
          "c",
          "self.choices",
          "incomplete",
          "str",
          "incomplete.lower",
          "CompletionItem",
          "c.startswith",
          "c.lower",
          "unknown.startswith",
          "map"
        ],
        "docstring": "Complete choices that start with the incomplete value.\n\n:param ctx: Invocation context for this command.\n:param param: The parameter that is requesting completion.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
        "code": "def shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Complete choices that start with the incomplete value.\n\n        :param ctx: Invocation context for this command.\n        :param param: The parameter that is requesting completion.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        str_choices = map(str, self.choices)\n\n        if self.case_sensitive:\n            matched = (c for c in str_choices if c.startswith(incomplete))\n        else:\n            incomplete = incomplete.lower()\n            matched = (c for c in str_choices if c.lower().startswith(incomplete))\n\n        return [CompletionItem(c) for c in matched]",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "formats",
            "type": "Any"
          }
        ],
        "return_type": null,
        "lineno": 424,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self, formats: cabc.Sequence[str] | None = None):\n        self.formats: cabc.Sequence[str] = formats or [\n            \"%Y-%m-%d\",\n            \"%Y-%m-%dT%H:%M:%S\",\n            \"%Y-%m-%d %H:%M:%S\",\n        ]",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 431,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "unknown.to_info_dict",
          "self.formats"
        ],
        "docstring": null,
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict[\"formats\"] = self.formats\n        return info_dict",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "get_metavar",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "ctx",
            "type": "Context"
          }
        ],
        "return_type": "Any",
        "lineno": 436,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.formats",
          "unknown.join"
        ],
        "docstring": null,
        "code": "def get_metavar(self, param: Parameter, ctx: Context) -> str | None:\n        return f\"[{'|'.join(self.formats)}]\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_try_to_convert_date",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "format",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 439,
        "decorators": [],
        "is_async": false,
        "calls": [
          "format",
          "datetime.strptime",
          "value"
        ],
        "docstring": null,
        "code": "def _try_to_convert_date(self, value: t.Any, format: str) -> datetime | None:\n        try:\n            return datetime.strptime(value, format)\n        except ValueError:\n            return None",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 445,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "datetime",
          "unknown.join",
          "unknown.format",
          "value",
          "param",
          "ctx",
          "len",
          "ngettext",
          "isinstance",
          "format",
          "self.formats",
          "formats_str",
          "map",
          "self.fail",
          "self._try_to_convert_date"
        ],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        if isinstance(value, datetime):\n            return value\n\n        for format in self.formats:\n            converted = self._try_to_convert_date(value, format)\n\n            if converted is not None:\n                return converted\n\n        formats_str = \", \".join(map(repr, self.formats))\n        self.fail(\n            ngettext(\n                \"{value!r} does not match the format {format}.\",\n                \"{value!r} does not match the formats {formats}.\",\n                len(self.formats),\n            ).format(value=value, format=formats_str, formats=formats_str),\n            param,\n            ctx,\n        )",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 468,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return \"DateTime\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 475,
        "decorators": [],
        "is_async": false,
        "calls": [
          "param",
          "ctx",
          "self._number_class",
          "value",
          "self.name",
          "_",
          "unknown.format",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        try:\n            return self._number_class(value)\n        except ValueError:\n            self.fail(\n                _(\"{value!r} is not a valid {number_type}.\").format(\n                    value=value, number_type=self.name\n                ),\n                param,\n                ctx,\n            )",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "min",
            "type": "Any"
          },
          {
            "name": "max",
            "type": "Any"
          },
          {
            "name": "min_open",
            "type": "bool"
          },
          {
            "name": "max_open",
            "type": "bool"
          },
          {
            "name": "clamp",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 491,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min_open",
          "max",
          "min",
          "max_open",
          "clamp"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        min: float | None = None,\n        max: float | None = None,\n        min_open: bool = False,\n        max_open: bool = False,\n        clamp: bool = False,\n    ) -> None:\n        self.min = min\n        self.max = max\n        self.min_open = min_open\n        self.max_open = max_open\n        self.clamp = clamp",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 505,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.min",
          "unknown.to_info_dict",
          "self.max_open",
          "super",
          "self.min_open",
          "info_dict.update",
          "self.max",
          "self.clamp"
        ],
        "docstring": null,
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict.update(\n            min=self.min,\n            max=self.max,\n            min_open=self.min_open,\n            max_open=self.max_open,\n            clamp=self.clamp,\n        )\n        return info_dict",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 516,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.min",
          "unknown.format",
          "param",
          "ctx",
          "value",
          "unknown.convert",
          "rv",
          "self._describe_range",
          "_",
          "self._clamp",
          "self.max_open",
          "super",
          "self.min_open",
          "self.max",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        import operator\n\n        rv = super().convert(value, param, ctx)\n        lt_min: bool = self.min is not None and (\n            operator.le if self.min_open else operator.lt\n        )(rv, self.min)\n        gt_max: bool = self.max is not None and (\n            operator.ge if self.max_open else operator.gt\n        )(rv, self.max)\n\n        if self.clamp:\n            if lt_min:\n                return self._clamp(self.min, 1, self.min_open)  # type: ignore\n\n            if gt_max:\n                return self._clamp(self.max, -1, self.max_open)  # type: ignore\n\n        if lt_min or gt_max:\n            self.fail(\n                _(\"{value} is not in the range {range}.\").format(\n                    value=rv, range=self._describe_range()\n                ),\n                param,\n                ctx,\n            )\n\n        return rv",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "_clamp",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "bound",
            "type": "float"
          },
          {
            "name": "dir",
            "type": "t.Literal[1, Any]"
          },
          {
            "name": "open",
            "type": "bool"
          }
        ],
        "return_type": "float",
        "lineno": 547,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Find the valid value to clamp to bound in the given\ndirection.\n\n:param bound: The boundary value.\n:param dir: 1 or -1 indicating the direction to move.\n:param open: If true, the range does not include the bound.",
        "code": "def _clamp(self, bound: float, dir: t.Literal[1, -1], open: bool) -> float:\n        \"\"\"Find the valid value to clamp to bound in the given\n        direction.\n\n        :param bound: The boundary value.\n        :param dir: 1 or -1 indicating the direction to move.\n        :param open: If true, the range does not include the bound.\n        \"\"\"\n        raise NotImplementedError",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "_describe_range",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 557,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Describe the range for use in help text.",
        "code": "def _describe_range(self) -> str:\n        \"\"\"Describe the range for use in help text.\"\"\"\n        if self.min is None:\n            op = \"<\" if self.max_open else \"<=\"\n            return f\"x{op}{self.max}\"\n\n        if self.max is None:\n            op = \">\" if self.min_open else \">=\"\n            return f\"x{op}{self.min}\"\n\n        lop = \"<\" if self.min_open else \"<=\"\n        rop = \"<\" if self.max_open else \"<=\"\n        return f\"{self.min}{lop}x{rop}{self.max}\"",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 571,
        "decorators": [],
        "is_async": false,
        "calls": [
          "type",
          "self._describe_range",
          "self"
        ],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        clamp = \" clamped\" if self.clamp else \"\"\n        return f\"<{type(self).__name__} {self._describe_range()}{clamp}>\"",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 580,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return \"INT\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_clamp",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "bound",
            "type": "int"
          },
          {
            "name": "dir",
            "type": "t.Literal[1, Any]"
          },
          {
            "name": "open",
            "type": "bool"
          }
        ],
        "return_type": "int",
        "lineno": 601,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def _clamp(  # type: ignore\n        self, bound: int, dir: t.Literal[1, -1], open: bool\n    ) -> int:\n        if not open:\n            return bound\n\n        return bound + dir",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 614,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return \"FLOAT\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "min",
            "type": "Any"
          },
          {
            "name": "max",
            "type": "Any"
          },
          {
            "name": "min_open",
            "type": "bool"
          },
          {
            "name": "max_open",
            "type": "bool"
          },
          {
            "name": "clamp",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 636,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "min_open",
          "unknown.__init__",
          "max",
          "min",
          "TypeError",
          "max_open",
          "clamp"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        min: float | None = None,\n        max: float | None = None,\n        min_open: bool = False,\n        max_open: bool = False,\n        clamp: bool = False,\n    ) -> None:\n        super().__init__(\n            min=min, max=max, min_open=min_open, max_open=max_open, clamp=clamp\n        )\n\n        if (min_open or max_open) and clamp:\n            raise TypeError(\"Clamping is not supported for open bounds.\")",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "_clamp",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "bound",
            "type": "float"
          },
          {
            "name": "dir",
            "type": "t.Literal[1, Any]"
          },
          {
            "name": "open",
            "type": "bool"
          }
        ],
        "return_type": "float",
        "lineno": 651,
        "decorators": [],
        "is_async": false,
        "calls": [
          "RuntimeError"
        ],
        "docstring": null,
        "code": "def _clamp(self, bound: float, dir: t.Literal[1, -1], open: bool) -> float:\n        if not open:\n            return bound\n\n        # Could use math.nextafter here, but clamping an\n        # open float range doesn't seem to be particularly useful. It's\n        # left up to the user to write a callback to do it if needed.\n        raise RuntimeError(\"Clamping is not supported for open bounds.\")",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "str_to_bool",
        "args": [
          {
            "name": "value",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 698,
        "decorators": [
          {
            "name": "staticmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "value",
          "value.strip",
          "unknown.lower",
          "isinstance",
          "bool",
          "BoolParamType.bool_states.get"
        ],
        "docstring": "Convert a string to a boolean value.\n\nIf the value is already a boolean, it is returned as-is. If the value is a\nstring, it is stripped of whitespaces and lower-cased, then checked against\nthe known boolean states pre-defined in the `BoolParamType.bool_states` mapping\nabove.\n\nReturns `None` if the value does not match any known boolean state.",
        "code": "def str_to_bool(value: str | bool) -> bool | None:\n        \"\"\"Convert a string to a boolean value.\n\n        If the value is already a boolean, it is returned as-is. If the value is a\n        string, it is stripped of whitespaces and lower-cased, then checked against\n        the known boolean states pre-defined in the `BoolParamType.bool_states` mapping\n        above.\n\n        Returns `None` if the value does not match any known boolean state.\n        \"\"\"\n        if isinstance(value, bool):\n            return value\n        return BoolParamType.bool_states.get(value.strip().lower())",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 712,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.str_to_bool",
          "unknown.join",
          "self.bool_states",
          "param",
          "ctx",
          "value",
          "sorted",
          "_",
          "unknown.format",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> bool:\n        normalized = self.str_to_bool(value)\n        if normalized is None:\n            self.fail(\n                _(\n                    \"{value!r} is not a valid boolean. Recognized values: {states}\"\n                ).format(value=value, states=\", \".join(sorted(self.bool_states))),\n                param,\n                ctx,\n            )\n        return normalized",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 726,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return \"BOOL\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 733,
        "decorators": [],
        "is_async": false,
        "calls": [
          "uuid.UUID",
          "value",
          "param",
          "value.strip",
          "ctx",
          "_",
          "isinstance",
          "unknown.format",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        import uuid\n\n        if isinstance(value, uuid.UUID):\n            return value\n\n        value = value.strip()\n\n        try:\n            return uuid.UUID(value)\n        except ValueError:\n            self.fail(\n                _(\"{value!r} is not a valid UUID.\").format(value=value), param, ctx\n            )",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 750,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return \"UUID\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "mode",
            "type": "str"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "lazy",
            "type": "Any"
          },
          {
            "name": "atomic",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 787,
        "decorators": [],
        "is_async": false,
        "calls": [
          "mode",
          "encoding",
          "lazy",
          "errors",
          "atomic"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        mode: str = \"r\",\n        encoding: str | None = None,\n        errors: str | None = \"strict\",\n        lazy: bool | None = None,\n        atomic: bool = False,\n    ) -> None:\n        self.mode = mode\n        self.encoding = encoding\n        self.errors = errors\n        self.lazy = lazy\n        self.atomic = atomic",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 801,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.encoding",
          "unknown.to_info_dict",
          "self.mode",
          "super",
          "info_dict.update"
        ],
        "docstring": null,
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict.update(mode=self.mode, encoding=self.encoding)\n        return info_dict",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "resolve_lazy_flag",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 806,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.fspath",
          "value"
        ],
        "docstring": null,
        "code": "def resolve_lazy_flag(self, value: str | os.PathLike[str]) -> bool:\n        if self.lazy is not None:\n            return self.lazy\n        if os.fspath(value) == \"-\":\n            return False\n        elif \"w\" in self.mode:\n            return True\n        return False",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.IO[t.Any]",
        "lineno": 815,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ctx",
          "f.close",
          "_is_file_like",
          "lf.close_intelligently",
          "ctx.call_on_close",
          "open_stream",
          "lf",
          "param",
          "self.resolve_lazy_flag",
          "self.mode",
          "self.errors",
          "f.flush",
          "self.atomic",
          "format_filename",
          "self.encoding",
          "LazyFile",
          "value",
          "safecall",
          "t.cast",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(\n        self,\n        value: str | os.PathLike[str] | t.IO[t.Any],\n        param: Parameter | None,\n        ctx: Context | None,\n    ) -> t.IO[t.Any]:\n        if _is_file_like(value):\n            return value\n\n        value = t.cast(\"str | os.PathLike[str]\", value)\n\n        try:\n            lazy = self.resolve_lazy_flag(value)\n\n            if lazy:\n                lf = LazyFile(\n                    value, self.mode, self.encoding, self.errors, atomic=self.atomic\n                )\n\n                if ctx is not None:\n                    ctx.call_on_close(lf.close_intelligently)\n\n                return t.cast(\"t.IO[t.Any]\", lf)\n\n            f, should_close = open_stream(\n                value, self.mode, self.encoding, self.errors, atomic=self.atomic\n            )\n\n            # If a context is provided, we automatically close the file\n            # at the end of the context execution (or flush out).  If a\n            # context does not exist, it's the caller's responsibility to\n            # properly close the file.  This for instance happens when the\n            # type is used with prompts.\n            if ctx is not None:\n                if should_close:\n                    ctx.call_on_close(safecall(f.close))\n                else:\n                    ctx.call_on_close(safecall(f.flush))\n\n            return f\n        except OSError as e:\n            self.fail(f\"'{format_filename(value)}': {e.strerror}\", param, ctx)",
        "line_count": 42,
        "needs_llm_summary": true
      },
      {
        "name": "shell_complete",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "list[CompletionItem]",
        "lineno": 858,
        "decorators": [],
        "is_async": false,
        "calls": [
          "CompletionItem",
          "incomplete"
        ],
        "docstring": "Return a special completion marker that tells the completion\nsystem to use the shell to provide file path completions.\n\n:param ctx: Invocation context for this command.\n:param param: The parameter that is requesting completion.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
        "code": "def shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Return a special completion marker that tells the completion\n        system to use the shell to provide file path completions.\n\n        :param ctx: Invocation context for this command.\n        :param param: The parameter that is requesting completion.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        return [CompletionItem(incomplete, type=\"file\")]",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exists",
            "type": "bool"
          },
          {
            "name": "file_okay",
            "type": "bool"
          },
          {
            "name": "dir_okay",
            "type": "bool"
          },
          {
            "name": "writable",
            "type": "bool"
          },
          {
            "name": "readable",
            "type": "bool"
          },
          {
            "name": "resolve_path",
            "type": "bool"
          },
          {
            "name": "allow_dash",
            "type": "bool"
          },
          {
            "name": "path_type",
            "type": "Any"
          },
          {
            "name": "executable",
            "type": "bool"
          }
        ],
        "return_type": null,
        "lineno": 914,
        "decorators": [],
        "is_async": false,
        "calls": [
          "readable",
          "dir_okay",
          "file_okay",
          "resolve_path",
          "allow_dash",
          "_",
          "writable",
          "path_type",
          "exists",
          "executable"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        exists: bool = False,\n        file_okay: bool = True,\n        dir_okay: bool = True,\n        writable: bool = False,\n        readable: bool = True,\n        resolve_path: bool = False,\n        allow_dash: bool = False,\n        path_type: type[t.Any] | None = None,\n        executable: bool = False,\n    ):\n        self.exists = exists\n        self.file_okay = file_okay\n        self.dir_okay = dir_okay\n        self.readable = readable\n        self.writable = writable\n        self.executable = executable\n        self.resolve_path = resolve_path\n        self.allow_dash = allow_dash\n        self.type = path_type\n\n        if self.file_okay and not self.dir_okay:\n            self.name: str = _(\"file\")\n        elif self.dir_okay and not self.file_okay:\n            self.name = _(\"directory\")\n        else:\n            self.name = _(\"path\")",
        "line_count": 28,
        "needs_llm_summary": true
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 943,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.writable",
          "self.dir_okay",
          "self.file_okay",
          "unknown.to_info_dict",
          "self.allow_dash",
          "self.readable",
          "self.exists",
          "super",
          "info_dict.update"
        ],
        "docstring": null,
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict.update(\n            exists=self.exists,\n            file_okay=self.file_okay,\n            dir_okay=self.dir_okay,\n            writable=self.writable,\n            readable=self.readable,\n            allow_dash=self.allow_dash,\n        )\n        return info_dict",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "coerce_path_result",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 955,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.fsdecode",
          "value",
          "t.cast",
          "isinstance",
          "os.fsencode",
          "self.type"
        ],
        "docstring": null,
        "code": "def coerce_path_result(\n        self, value: str | os.PathLike[str]\n    ) -> str | bytes | os.PathLike[str]:\n        if self.type is not None and not isinstance(value, self.type):\n            if self.type is str:\n                return os.fsdecode(value)\n            elif self.type is bytes:\n                return os.fsencode(value)\n            else:\n                return t.cast(\"os.PathLike[str]\", self.type(value))\n\n        return value",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 968,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.stat",
          "ctx",
          "os.path.realpath",
          "unknown.format",
          "os.access",
          "self.coerce_path_result",
          "rv",
          "_",
          "stat.S_ISDIR",
          "param",
          "os.R_OK",
          "self.name.title",
          "format_filename",
          "value",
          "stat.S_ISREG",
          "os.X_OK",
          "os.W_OK",
          "st.st_mode",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(\n        self,\n        value: str | os.PathLike[str],\n        param: Parameter | None,\n        ctx: Context | None,\n    ) -> str | bytes | os.PathLike[str]:\n        rv = value\n\n        is_dash = self.file_okay and self.allow_dash and rv in (b\"-\", \"-\")\n\n        if not is_dash:\n            if self.resolve_path:\n                rv = os.path.realpath(rv)\n\n            try:\n                st = os.stat(rv)\n            except OSError:\n                if not self.exists:\n                    return self.coerce_path_result(rv)\n                self.fail(\n                    _(\"{name} {filename!r} does not exist.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n            if not self.file_okay and stat.S_ISREG(st.st_mode):\n                self.fail(\n                    _(\"{name} {filename!r} is a file.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n            if not self.dir_okay and stat.S_ISDIR(st.st_mode):\n                self.fail(\n                    _(\"{name} {filename!r} is a directory.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n            if self.readable and not os.access(rv, os.R_OK):\n                self.fail(\n                    _(\"{name} {filename!r} is not readable.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n            if self.writable and not os.access(rv, os.W_OK):\n                self.fail(\n                    _(\"{name} {filename!r} is not writable.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n            if self.executable and not os.access(value, os.X_OK):\n                self.fail(\n                    _(\"{name} {filename!r} is not executable.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n        return self.coerce_path_result(rv)",
        "line_count": 72,
        "needs_llm_summary": true
      },
      {
        "name": "shell_complete",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "ctx",
            "type": "Context"
          },
          {
            "name": "param",
            "type": "Parameter"
          },
          {
            "name": "incomplete",
            "type": "str"
          }
        ],
        "return_type": "list[CompletionItem]",
        "lineno": 1041,
        "decorators": [],
        "is_async": false,
        "calls": [
          "CompletionItem",
          "type",
          "incomplete"
        ],
        "docstring": "Return a special completion marker that tells the completion\nsystem to use the shell to provide path completions for only\ndirectories or any paths.\n\n:param ctx: Invocation context for this command.\n:param param: The parameter that is requesting completion.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
        "code": "def shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Return a special completion marker that tells the completion\n        system to use the shell to provide path completions for only\n        directories or any paths.\n\n        :param ctx: Invocation context for this command.\n        :param param: The parameter that is requesting completion.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        type = \"dir\" if self.dir_okay and not self.file_okay else \"file\"\n        return [CompletionItem(incomplete, type=type)]",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "types",
            "type": "cabc.Sequence[Any]"
          }
        ],
        "return_type": "None",
        "lineno": 1074,
        "decorators": [],
        "is_async": false,
        "calls": [
          "convert_type",
          "ty"
        ],
        "docstring": null,
        "code": "def __init__(self, types: cabc.Sequence[type[t.Any] | ParamType]) -> None:\n        self.types: cabc.Sequence[ParamType] = [convert_type(ty) for ty in types]",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "to_info_dict",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "dict[str, t.Any]",
        "lineno": 1077,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "unknown.to_info_dict",
          "t.to_info_dict"
        ],
        "docstring": null,
        "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict[\"types\"] = [t.to_info_dict() for t in self.types]\n        return info_dict",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "name",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 1083,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "unknown.join"
        ],
        "docstring": null,
        "code": "def name(self) -> str:  # type: ignore\n        return f\"<{' '.join(ty.name for ty in self.types)}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "arity",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 1087,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "len",
          "self.types"
        ],
        "docstring": null,
        "code": "def arity(self) -> int:  # type: ignore\n        return len(self.types)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "convert",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "t.Any"
          },
          {
            "name": "param",
            "type": "Any"
          },
          {
            "name": "ctx",
            "type": "Any"
          }
        ],
        "return_type": "t.Any",
        "lineno": 1090,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tuple",
          "value",
          "param",
          "ctx",
          "len",
          "self.types",
          "ngettext",
          "len_type",
          "ty",
          "len_value",
          "x",
          "zip",
          "unknown.format",
          "self.fail"
        ],
        "docstring": null,
        "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        len_type = len(self.types)\n        len_value = len(value)\n\n        if len_value != len_type:\n            self.fail(\n                ngettext(\n                    \"{len_type} values are required, but {len_value} was given.\",\n                    \"{len_type} values are required, but {len_value} were given.\",\n                    len_value,\n                ).format(len_type=len_type, len_value=len_value),\n                param=param,\n                ctx=ctx,\n            )\n\n        return tuple(\n            ty(x, param, ctx) for ty, x in zip(self.types, value, strict=False)\n        )",
        "line_count": 20,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ParamType",
        "methods": [
          "to_info_dict",
          "__call__",
          "get_metavar",
          "get_missing_message",
          "convert",
          "split_envvar_value",
          "fail",
          "shell_complete"
        ],
        "base_classes": [],
        "lineno": 30,
        "docstring": "Represents the type of a parameter. Validates and converts values\nfrom the command line or Python into the correct type.\n\nTo implement a custom type, subclass and implement at least the\nfollowing:\n\n-   The :attr:`name` class attribute must be set.\n-   Calling an instance of the type with ``None`` must return\n    ``None``. This is already implemented by default.\n-   :meth:`convert` must convert string values to the correct type.\n-   :meth:`convert` must accept values that are already the correct\n    type.\n-   It must be able to convert a value if the ``ctx`` and ``param``\n    arguments are ``None``. This can occur when converting prompt\n    input."
      },
      {
        "name": "CompositeParamType",
        "methods": [
          "arity"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 163,
        "docstring": null
      },
      {
        "name": "FuncParamType",
        "methods": [
          "__init__",
          "to_info_dict",
          "convert"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 171,
        "docstring": null
      },
      {
        "name": "UnprocessedParamType",
        "methods": [
          "convert",
          "__repr__"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 195,
        "docstring": null
      },
      {
        "name": "StringParamType",
        "methods": [
          "convert",
          "__repr__"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 207,
        "docstring": null
      },
      {
        "name": "Choice",
        "methods": [
          "__init__",
          "to_info_dict",
          "_normalized_mapping",
          "normalize_choice",
          "get_metavar",
          "get_missing_message",
          "convert",
          "get_invalid_choice_message",
          "__repr__",
          "shell_complete"
        ],
        "base_classes": [
          "ParamType",
          "unknown"
        ],
        "lineno": 233,
        "docstring": "The choice type allows a value to be checked against a fixed set\nof supported values.\n\nYou may pass any iterable value which will be converted to a tuple\nand thus will only be iterated once.\n\nThe resulting value will always be one of the originally passed choices.\nSee :meth:`normalize_choice` for more info on the mapping of strings\nto choices. See :ref:`choice-opts` for an example.\n\n:param case_sensitive: Set to false to make choices case\n    insensitive. Defaults to true.\n\n.. versionchanged:: 8.2.0\n    Non-``str`` ``choices`` are now supported. It can additionally be any\n    iterable. Before you were not recommended to pass anything but a list or\n    tuple.\n\n.. versionadded:: 8.2.0\n    Choice normalization can be overridden via :meth:`normalize_choice`."
      },
      {
        "name": "DateTime",
        "methods": [
          "__init__",
          "to_info_dict",
          "get_metavar",
          "_try_to_convert_date",
          "convert",
          "__repr__"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 401,
        "docstring": "The DateTime type converts date strings into `datetime` objects.\n\nThe format strings which are checked are configurable, but default to some\ncommon (non-timezone aware) ISO 8601 formats.\n\nWhen specifying *DateTime* formats, you should only pass a list or a tuple.\nOther iterables, like generators, may lead to surprising results.\n\nThe format strings are processed using ``datetime.strptime``, and this\nconsequently defines the format strings which are allowed.\n\nParsing is tried using each format, in order, and the first format which\nparses successfully is used.\n\n:param formats: A list or tuple of date format strings, in the order in\n                which they should be tried. Defaults to\n                ``'%Y-%m-%d'``, ``'%Y-%m-%dT%H:%M:%S'``,\n                ``'%Y-%m-%d %H:%M:%S'``."
      },
      {
        "name": "_NumberParamTypeBase",
        "methods": [
          "convert"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 472,
        "docstring": null
      },
      {
        "name": "_NumberRangeBase",
        "methods": [
          "__init__",
          "to_info_dict",
          "convert",
          "_clamp",
          "_describe_range",
          "__repr__"
        ],
        "base_classes": [
          "_NumberParamTypeBase"
        ],
        "lineno": 490,
        "docstring": null
      },
      {
        "name": "IntParamType",
        "methods": [
          "__repr__"
        ],
        "base_classes": [
          "_NumberParamTypeBase"
        ],
        "lineno": 576,
        "docstring": null
      },
      {
        "name": "IntRange",
        "methods": [
          "_clamp"
        ],
        "base_classes": [
          "_NumberRangeBase",
          "IntParamType"
        ],
        "lineno": 584,
        "docstring": "Restrict an :data:`click.INT` value to a range of accepted\nvalues. See :ref:`ranges`.\n\nIf ``min`` or ``max`` are not passed, any value is accepted in that\ndirection. If ``min_open`` or ``max_open`` are enabled, the\ncorresponding boundary is not included in the range.\n\nIf ``clamp`` is enabled, a value outside the range is clamped to the\nboundary instead of failing.\n\n.. versionchanged:: 8.0\n    Added the ``min_open`` and ``max_open`` parameters."
      },
      {
        "name": "FloatParamType",
        "methods": [
          "__repr__"
        ],
        "base_classes": [
          "_NumberParamTypeBase"
        ],
        "lineno": 610,
        "docstring": null
      },
      {
        "name": "FloatRange",
        "methods": [
          "__init__",
          "_clamp"
        ],
        "base_classes": [
          "_NumberRangeBase",
          "FloatParamType"
        ],
        "lineno": 618,
        "docstring": "Restrict a :data:`click.FLOAT` value to a range of accepted\nvalues. See :ref:`ranges`.\n\nIf ``min`` or ``max`` are not passed, any value is accepted in that\ndirection. If ``min_open`` or ``max_open`` are enabled, the\ncorresponding boundary is not included in the range.\n\nIf ``clamp`` is enabled, a value outside the range is clamped to the\nboundary instead of failing. This is not supported if either\nboundary is marked ``open``.\n\n.. versionchanged:: 8.0\n    Added the ``min_open`` and ``max_open`` parameters."
      },
      {
        "name": "BoolParamType",
        "methods": [
          "str_to_bool",
          "convert",
          "__repr__"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 661,
        "docstring": null
      },
      {
        "name": "UUIDParameterType",
        "methods": [
          "convert",
          "__repr__"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 730,
        "docstring": null
      },
      {
        "name": "File",
        "methods": [
          "__init__",
          "to_info_dict",
          "resolve_lazy_flag",
          "convert",
          "shell_complete"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 754,
        "docstring": "Declares a parameter to be a file for reading or writing.  The file\nis automatically closed once the context tears down (after the command\nfinished working).\n\nFiles can be opened for reading or writing.  The special value ``-``\nindicates stdin or stdout depending on the mode.\n\nBy default, the file is opened for reading text data, but it can also be\nopened in binary mode or for writing.  The encoding parameter can be used\nto force a specific encoding.\n\nThe `lazy` flag controls if the file should be opened immediately or upon\nfirst IO. The default is to be non-lazy for standard input and output\nstreams as well as files opened for reading, `lazy` otherwise. When opening a\nfile lazily for reading, it is still opened temporarily for validation, but\nwill not be held open until first IO. lazy is mainly useful when opening\nfor writing to avoid creating the file until it is needed.\n\nFiles can also be opened atomically in which case all writes go into a\nseparate file in the same folder and upon completion the file will\nbe moved over to the original location.  This is useful if a file\nregularly read by other users is modified.\n\nSee :ref:`file-args` for more information.\n\n.. versionchanged:: 2.0\n    Added the ``atomic`` parameter."
      },
      {
        "name": "Path",
        "methods": [
          "__init__",
          "to_info_dict",
          "coerce_path_result",
          "convert",
          "shell_complete"
        ],
        "base_classes": [
          "ParamType"
        ],
        "lineno": 879,
        "docstring": "The ``Path`` type is similar to the :class:`File` type, but\nreturns the filename instead of an open file. Various checks can be\nenabled to validate the type of file and permissions.\n\n:param exists: The file or directory needs to exist for the value to\n    be valid. If this is not set to ``True``, and the file does not\n    exist, then all further checks are silently skipped.\n:param file_okay: Allow a file as a value.\n:param dir_okay: Allow a directory as a value.\n:param readable: if true, a readable check is performed.\n:param writable: if true, a writable check is performed.\n:param executable: if true, an executable check is performed.\n:param resolve_path: Make the value absolute and resolve any\n    symlinks. A ``~`` is not expanded, as this is supposed to be\n    done by the shell only.\n:param allow_dash: Allow a single dash as a value, which indicates\n    a standard stream (but does not open it). Use\n    :func:`~click.open_file` to handle opening this value.\n:param path_type: Convert the incoming path value to this type. If\n    ``None``, keep Python's default, which is ``str``. Useful to\n    convert to :class:`pathlib.Path`.\n\n.. versionchanged:: 8.1\n    Added the ``executable`` parameter.\n\n.. versionchanged:: 8.0\n    Allow passing ``path_type=pathlib.Path``.\n\n.. versionchanged:: 6.0\n    Added the ``allow_dash`` parameter."
      },
      {
        "name": "Tuple",
        "methods": [
          "__init__",
          "to_info_dict",
          "name",
          "arity",
          "convert"
        ],
        "base_classes": [
          "CompositeParamType"
        ],
        "lineno": 1060,
        "docstring": "The default behavior of Click is to apply a type on a value directly.\nThis works well in most cases, except for when `nargs` is set to a fixed\ncount and different types should be used for different items.  In this\ncase the :class:`Tuple` type can be used.  This type can only be used\nif `nargs` is set to a fixed number.\n\nFor more information see :ref:`tuple-type`.\n\nThis can be selected by using a Python tuple literal as a type.\n\n:param types: a list of types that should be used for the tuple items."
      },
      {
        "name": "OptionHelpExtra",
        "methods": [],
        "base_classes": [
          "t.TypedDict"
        ],
        "lineno": 1205,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "enum",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "stat",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 8,
        "type": "import"
      },
      {
        "module": "datetime",
        "name": "datetime",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "gettext",
        "alias": "_",
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "gettext",
        "name": "ngettext",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "_get_argv_encoding",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "open_stream",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "BadParameter",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "format_filename",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "LazyFile",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "utils",
        "name": "safecall",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "typing_extensions",
        "alias": "te",
        "lineno": 21,
        "type": "import"
      },
      {
        "module": "core",
        "name": "Context",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "core",
        "name": "Parameter",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "click.shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 388,
        "type": "from_import"
      },
      {
        "module": "operator",
        "alias": null,
        "lineno": 519,
        "type": "import"
      },
      {
        "module": "uuid",
        "alias": null,
        "lineno": 736,
        "type": "import"
      },
      {
        "module": "click.shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 870,
        "type": "from_import"
      },
      {
        "module": "click.shell_completion",
        "name": "CompletionItem",
        "alias": null,
        "lineno": 1054,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "ParamTypeValue",
        "assigned_to": "t.TypeVar",
        "lineno": 27
      },
      {
        "name": "UNPROCESSED",
        "assigned_to": "UnprocessedParamType",
        "lineno": 1183
      },
      {
        "name": "STRING",
        "assigned_to": "StringParamType",
        "lineno": 1187
      },
      {
        "name": "INT",
        "assigned_to": "IntParamType",
        "lineno": 1191
      },
      {
        "name": "FLOAT",
        "assigned_to": "FloatParamType",
        "lineno": 1195
      },
      {
        "name": "BOOL",
        "assigned_to": "BoolParamType",
        "lineno": 1199
      },
      {
        "name": "UUID",
        "assigned_to": "UUIDParameterType",
        "lineno": 1202
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "FloatParamType",
        "IntParamType",
        "BoolParamType",
        "StringParamType",
        "t.TypeVar",
        "UUIDParameterType",
        "UnprocessedParamType"
      ],
      "class_instantiations": [
        "FloatParamType",
        "IntParamType",
        "BoolParamType",
        "StringParamType",
        "UUIDParameterType",
        "UnprocessedParamType"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "datetime",
        "typing",
        "os",
        "enum",
        "collections"
      ],
      "third_party": {
        "other": [
          "__future__",
          "stat",
          "gettext",
          "_compat",
          "exceptions",
          "utils",
          "typing_extensions",
          "core",
          "shell_completion",
          "click",
          "operator",
          "uuid"
        ]
      },
      "tech_stack": []
    },
    "line_count": 1210
  },
  "src/click/utils.py": {
    "filepath": "../click/src/click/utils.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_posixify",
        "args": [
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 32,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.lower",
          "unknown.join",
          "name.split"
        ],
        "docstring": null,
        "code": "def _posixify(name: str) -> str:\n    return \"-\".join(name.split()).lower()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "safecall",
        "args": [
          {
            "name": "func",
            "type": "t.Callable[P, R]"
          }
        ],
        "return_type": "t.Callable[P, Any]",
        "lineno": 36,
        "decorators": [],
        "is_async": false,
        "calls": [
          "wrapper",
          "update_wrapper",
          "kwargs",
          "func"
        ],
        "docstring": "Wraps a function so that it swallows exceptions.",
        "code": "def safecall(func: t.Callable[P, R]) -> t.Callable[P, R | None]:\n    \"\"\"Wraps a function so that it swallows exceptions.\"\"\"\n\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R | None:\n        try:\n            return func(*args, **kwargs)\n        except Exception:\n            pass\n        return None\n\n    return update_wrapper(wrapper, func)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "make_str",
        "args": [
          {
            "name": "value",
            "type": "t.Any"
          }
        ],
        "return_type": "str",
        "lineno": 49,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value.decode",
          "value",
          "str",
          "bytes",
          "isinstance",
          "sys.getfilesystemencoding"
        ],
        "docstring": "Converts a value into a valid string.",
        "code": "def make_str(value: t.Any) -> str:\n    \"\"\"Converts a value into a valid string.\"\"\"\n    if isinstance(value, bytes):\n        try:\n            return value.decode(sys.getfilesystemencoding())\n        except UnicodeError:\n            return value.decode(\"utf-8\", \"replace\")\n    return str(value)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "make_default_short_help",
        "args": [
          {
            "name": "help",
            "type": "str"
          },
          {
            "name": "max_length",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 59,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "help.find",
          "unknown.join",
          "words",
          "word",
          "len",
          "help.split"
        ],
        "docstring": "Returns a condensed version of help string.",
        "code": "def make_default_short_help(help: str, max_length: int = 45) -> str:\n    \"\"\"Returns a condensed version of help string.\"\"\"\n    # Consider only the first paragraph.\n    paragraph_end = help.find(\"\\n\\n\")\n\n    if paragraph_end != -1:\n        help = help[:paragraph_end]\n\n    # Collapse newlines, tabs, and spaces.\n    words = help.split()\n\n    if not words:\n        return \"\"\n\n    # The first paragraph started with a \"no rewrap\" marker, ignore it.\n    if words[0] == \"\\b\":\n        words = words[1:]\n\n    total_length = 0\n    last_index = len(words) - 1\n\n    for i, word in enumerate(words):\n        total_length += len(word) + (i > 0)\n\n        if total_length > max_length:  # too long, truncate\n            break\n\n        if word[-1] == \".\":  # sentence end, truncate without \"...\"\n            return \" \".join(words[: i + 1])\n\n        if total_length == max_length and i != last_index:\n            break  # not at sentence end, truncate with \"...\"\n    else:\n        return \" \".join(words)  # no truncation needed\n\n    # Account for the length of the suffix.\n    total_length += len(\"...\")\n\n    # remove words until the length is short enough\n    while i > 0:\n        total_length -= len(words[i]) + (i > 0)\n\n        if total_length <= max_length:\n            break\n\n        i -= 1\n\n    return \" \".join(words[:i]) + \"...\"",
        "line_count": 48,
        "needs_llm_summary": true
      },
      {
        "name": "echo",
        "args": [
          {
            "name": "message",
            "type": "Any"
          },
          {
            "name": "file",
            "type": "Any"
          },
          {
            "name": "nl",
            "type": "bool"
          },
          {
            "name": "err",
            "type": "bool"
          },
          {
            "name": "color",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 222,
        "decorators": [],
        "is_async": false,
        "calls": [
          "out",
          "strip_ansi",
          "message",
          "binary_file.write",
          "str",
          "file",
          "_default_text_stderr",
          "file.write",
          "file.flush",
          "resolve_color_default",
          "should_strip_ansi",
          "isinstance",
          "_default_text_stdout",
          "color",
          "binary_file.flush",
          "auto_wrap_for_ansi",
          "_find_binary_writer"
        ],
        "docstring": "Print a message and newline to stdout or a file. This should be\nused instead of :func:`print` because it provides better support\nfor different data, files, and environments.\n\nCompared to :func:`print`, this does the following:\n\n-   Ensures that the output encoding is not misconfigured on Linux.\n-   Supports Unicode in the Windows console.\n-   Supports writing to binary outputs, and supports writing bytes\n    to text outputs.\n-   Supports colors and styles on Windows.\n-   Removes ANSI color and style codes if the output does not look\n    like an interactive terminal.\n-   Always flushes the output.\n\n:param message: The string or bytes to output. Other objects are\n    converted to strings.\n:param file: The file to write to. Defaults to ``stdout``.\n:param err: Write to ``stderr`` instead of ``stdout``.\n:param nl: Print a newline after the message. Enabled by default.\n:param color: Force showing or hiding colors and other styles. By\n    default Click will remove color if the output does not look like\n    an interactive terminal.\n\n.. versionchanged:: 6.0\n    Support Unicode output on the Windows console. Click does not\n    modify ``sys.stdout``, so ``sys.stdout.write()`` and ``print()``\n    will still not support Unicode.\n\n.. versionchanged:: 4.0\n    Added the ``color`` parameter.\n\n.. versionadded:: 3.0\n    Added the ``err`` parameter.\n\n.. versionchanged:: 2.0\n    Support colors on Windows if colorama is installed.",
        "code": "def echo(\n    message: t.Any | None = None,\n    file: t.IO[t.Any] | None = None,\n    nl: bool = True,\n    err: bool = False,\n    color: bool | None = None,\n) -> None:\n    \"\"\"Print a message and newline to stdout or a file. This should be\n    used instead of :func:`print` because it provides better support\n    for different data, files, and environments.\n\n    Compared to :func:`print`, this does the following:\n\n    -   Ensures that the output encoding is not misconfigured on Linux.\n    -   Supports Unicode in the Windows console.\n    -   Supports writing to binary outputs, and supports writing bytes\n        to text outputs.\n    -   Supports colors and styles on Windows.\n    -   Removes ANSI color and style codes if the output does not look\n        like an interactive terminal.\n    -   Always flushes the output.\n\n    :param message: The string or bytes to output. Other objects are\n        converted to strings.\n    :param file: The file to write to. Defaults to ``stdout``.\n    :param err: Write to ``stderr`` instead of ``stdout``.\n    :param nl: Print a newline after the message. Enabled by default.\n    :param color: Force showing or hiding colors and other styles. By\n        default Click will remove color if the output does not look like\n        an interactive terminal.\n\n    .. versionchanged:: 6.0\n        Support Unicode output on the Windows console. Click does not\n        modify ``sys.stdout``, so ``sys.stdout.write()`` and ``print()``\n        will still not support Unicode.\n\n    .. versionchanged:: 4.0\n        Added the ``color`` parameter.\n\n    .. versionadded:: 3.0\n        Added the ``err`` parameter.\n\n    .. versionchanged:: 2.0\n        Support colors on Windows if colorama is installed.\n    \"\"\"\n    if file is None:\n        if err:\n            file = _default_text_stderr()\n        else:\n            file = _default_text_stdout()\n\n        # There are no standard streams attached to write to. For example,\n        # pythonw on Windows.\n        if file is None:\n            return\n\n    # Convert non bytes/text into the native string type.\n    if message is not None and not isinstance(message, (str, bytes, bytearray)):\n        out: str | bytes | bytearray | None = str(message)\n    else:\n        out = message\n\n    if nl:\n        out = out or \"\"\n        if isinstance(out, str):\n            out += \"\\n\"\n        else:\n            out += b\"\\n\"\n\n    if not out:\n        file.flush()\n        return\n\n    # If there is a message and the value looks like bytes, we manually\n    # need to find the binary stream and write the message in there.\n    # This is done separately so that most stream types will work as you\n    # would expect. Eg: you can write to StringIO for other cases.\n    if isinstance(out, (bytes, bytearray)):\n        binary_file = _find_binary_writer(file)\n\n        if binary_file is not None:\n            file.flush()\n            binary_file.write(out)\n            binary_file.flush()\n            return\n\n    # ANSI style code support. For no message or bytes, nothing happens.\n    # When outputting to a file instead of a terminal, strip codes.\n    else:\n        color = resolve_color_default(color)\n\n        if should_strip_ansi(file, color):\n            out = strip_ansi(out)\n        elif WIN:\n            if auto_wrap_for_ansi is not None:\n                file = auto_wrap_for_ansi(file, color)  # type: ignore\n            elif not color:\n                out = strip_ansi(out)\n\n    file.write(out)  # type: ignore\n    file.flush()",
        "line_count": 101,
        "needs_llm_summary": true
      },
      {
        "name": "get_binary_stream",
        "args": [
          {
            "name": "name",
            "type": "t.Literal[stdin, stdout, stderr]"
          }
        ],
        "return_type": "t.BinaryIO",
        "lineno": 325,
        "decorators": [],
        "is_async": false,
        "calls": [
          "TypeError",
          "name",
          "opener",
          "binary_streams.get"
        ],
        "docstring": "Returns a system stream for byte processing.\n\n:param name: the name of the stream to open.  Valid names are ``'stdin'``,\n             ``'stdout'`` and ``'stderr'``",
        "code": "def get_binary_stream(name: t.Literal[\"stdin\", \"stdout\", \"stderr\"]) -> t.BinaryIO:\n    \"\"\"Returns a system stream for byte processing.\n\n    :param name: the name of the stream to open.  Valid names are ``'stdin'``,\n                 ``'stdout'`` and ``'stderr'``\n    \"\"\"\n    opener = binary_streams.get(name)\n    if opener is None:\n        raise TypeError(f\"Unknown standard stream '{name}'\")\n    return opener()",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "get_text_stream",
        "args": [
          {
            "name": "name",
            "type": "t.Literal[stdin, stdout, stderr]"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          }
        ],
        "return_type": "t.TextIO",
        "lineno": 337,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "text_streams.get",
          "TypeError",
          "errors",
          "opener",
          "encoding"
        ],
        "docstring": "Returns a system stream for text processing.  This usually returns\na wrapped stream around a binary stream returned from\n:func:`get_binary_stream` but it also can take shortcuts for already\ncorrectly configured streams.\n\n:param name: the name of the stream to open.  Valid names are ``'stdin'``,\n             ``'stdout'`` and ``'stderr'``\n:param encoding: overrides the detected default encoding.\n:param errors: overrides the default error mode.",
        "code": "def get_text_stream(\n    name: t.Literal[\"stdin\", \"stdout\", \"stderr\"],\n    encoding: str | None = None,\n    errors: str | None = \"strict\",\n) -> t.TextIO:\n    \"\"\"Returns a system stream for text processing.  This usually returns\n    a wrapped stream around a binary stream returned from\n    :func:`get_binary_stream` but it also can take shortcuts for already\n    correctly configured streams.\n\n    :param name: the name of the stream to open.  Valid names are ``'stdin'``,\n                 ``'stdout'`` and ``'stderr'``\n    :param encoding: overrides the detected default encoding.\n    :param errors: overrides the default error mode.\n    \"\"\"\n    opener = text_streams.get(name)\n    if opener is None:\n        raise TypeError(f\"Unknown standard stream '{name}'\")\n    return opener(encoding, errors)",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "open_file",
        "args": [
          {
            "name": "filename",
            "type": "Any"
          },
          {
            "name": "mode",
            "type": "str"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "lazy",
            "type": "bool"
          },
          {
            "name": "atomic",
            "type": "bool"
          }
        ],
        "return_type": "t.IO[t.Any]",
        "lineno": 358,
        "decorators": [],
        "is_async": false,
        "calls": [
          "filename",
          "open_stream",
          "mode",
          "LazyFile",
          "atomic",
          "t.cast",
          "f",
          "errors",
          "KeepOpenFile",
          "encoding"
        ],
        "docstring": "Open a file, with extra behavior to handle ``'-'`` to indicate\na standard stream, lazy open on write, and atomic write. Similar to\nthe behavior of the :class:`~click.File` param type.\n\nIf ``'-'`` is given to open ``stdout`` or ``stdin``, the stream is\nwrapped so that using it in a context manager will not close it.\nThis makes it possible to use the function without accidentally\nclosing a standard stream:\n\n.. code-block:: python\n\n    with open_file(filename) as f:\n        ...\n\n:param filename: The name or Path of the file to open, or ``'-'`` for\n    ``stdin``/``stdout``.\n:param mode: The mode in which to open the file.\n:param encoding: The encoding to decode or encode a file opened in\n    text mode.\n:param errors: The error handling mode.\n:param lazy: Wait to open the file until it is accessed. For read\n    mode, the file is temporarily opened to raise access errors\n    early, then closed until it is read again.\n:param atomic: Write to a temporary file and replace the given file\n    on close.\n\n.. versionadded:: 3.0",
        "code": "def open_file(\n    filename: str | os.PathLike[str],\n    mode: str = \"r\",\n    encoding: str | None = None,\n    errors: str | None = \"strict\",\n    lazy: bool = False,\n    atomic: bool = False,\n) -> t.IO[t.Any]:\n    \"\"\"Open a file, with extra behavior to handle ``'-'`` to indicate\n    a standard stream, lazy open on write, and atomic write. Similar to\n    the behavior of the :class:`~click.File` param type.\n\n    If ``'-'`` is given to open ``stdout`` or ``stdin``, the stream is\n    wrapped so that using it in a context manager will not close it.\n    This makes it possible to use the function without accidentally\n    closing a standard stream:\n\n    .. code-block:: python\n\n        with open_file(filename) as f:\n            ...\n\n    :param filename: The name or Path of the file to open, or ``'-'`` for\n        ``stdin``/``stdout``.\n    :param mode: The mode in which to open the file.\n    :param encoding: The encoding to decode or encode a file opened in\n        text mode.\n    :param errors: The error handling mode.\n    :param lazy: Wait to open the file until it is accessed. For read\n        mode, the file is temporarily opened to raise access errors\n        early, then closed until it is read again.\n    :param atomic: Write to a temporary file and replace the given file\n        on close.\n\n    .. versionadded:: 3.0\n    \"\"\"\n    if lazy:\n        return t.cast(\n            \"t.IO[t.Any]\", LazyFile(filename, mode, encoding, errors, atomic=atomic)\n        )\n\n    f, should_close = open_stream(filename, mode, encoding, errors, atomic=atomic)\n\n    if not should_close:\n        f = t.cast(\"t.IO[t.Any]\", KeepOpenFile(f))\n\n    return f",
        "line_count": 47,
        "needs_llm_summary": true
      },
      {
        "name": "format_filename",
        "args": [
          {
            "name": "filename",
            "type": "Any"
          },
          {
            "name": "shorten",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 407,
        "decorators": [],
        "is_async": false,
        "calls": [
          "filename",
          "bytes",
          "filename.encode",
          "filename.decode",
          "isinstance",
          "sys.getfilesystemencoding",
          "os.path.basename",
          "unknown.decode",
          "os.fspath"
        ],
        "docstring": "Format a filename as a string for display. Ensures the filename can be\ndisplayed by replacing any invalid bytes or surrogate escapes in the name\nwith the replacement character ``\ufffd``.\n\nInvalid bytes or surrogate escapes will raise an error when written to a\nstream with ``errors=\"strict\"``. This will typically happen with ``stdout``\nwhen the locale is something like ``en_GB.UTF-8``.\n\nMany scenarios *are* safe to write surrogates though, due to PEP 538 and\nPEP 540, including:\n\n-   Writing to ``stderr``, which uses ``errors=\"backslashreplace\"``.\n-   The system has ``LANG=C.UTF-8``, ``C``, or ``POSIX``. Python opens\n    stdout and stderr with ``errors=\"surrogateescape\"``.\n-   None of ``LANG/LC_*`` are set. Python assumes ``LANG=C.UTF-8``.\n-   Python is started in UTF-8 mode  with  ``PYTHONUTF8=1`` or ``-X utf8``.\n    Python opens stdout and stderr with ``errors=\"surrogateescape\"``.\n\n:param filename: formats a filename for UI display.  This will also convert\n                 the filename into unicode without failing.\n:param shorten: this optionally shortens the filename to strip of the\n                path that leads up to it.",
        "code": "def format_filename(\n    filename: str | bytes | os.PathLike[str] | os.PathLike[bytes],\n    shorten: bool = False,\n) -> str:\n    \"\"\"Format a filename as a string for display. Ensures the filename can be\n    displayed by replacing any invalid bytes or surrogate escapes in the name\n    with the replacement character ``\ufffd``.\n\n    Invalid bytes or surrogate escapes will raise an error when written to a\n    stream with ``errors=\"strict\"``. This will typically happen with ``stdout``\n    when the locale is something like ``en_GB.UTF-8``.\n\n    Many scenarios *are* safe to write surrogates though, due to PEP 538 and\n    PEP 540, including:\n\n    -   Writing to ``stderr``, which uses ``errors=\"backslashreplace\"``.\n    -   The system has ``LANG=C.UTF-8``, ``C``, or ``POSIX``. Python opens\n        stdout and stderr with ``errors=\"surrogateescape\"``.\n    -   None of ``LANG/LC_*`` are set. Python assumes ``LANG=C.UTF-8``.\n    -   Python is started in UTF-8 mode  with  ``PYTHONUTF8=1`` or ``-X utf8``.\n        Python opens stdout and stderr with ``errors=\"surrogateescape\"``.\n\n    :param filename: formats a filename for UI display.  This will also convert\n                     the filename into unicode without failing.\n    :param shorten: this optionally shortens the filename to strip of the\n                    path that leads up to it.\n    \"\"\"\n    if shorten:\n        filename = os.path.basename(filename)\n    else:\n        filename = os.fspath(filename)\n\n    if isinstance(filename, bytes):\n        filename = filename.decode(sys.getfilesystemencoding(), \"replace\")\n    else:\n        filename = filename.encode(\"utf-8\", \"surrogateescape\").decode(\n            \"utf-8\", \"replace\"\n        )\n\n    return filename",
        "line_count": 40,
        "needs_llm_summary": true
      },
      {
        "name": "get_app_dir",
        "args": [
          {
            "name": "app_name",
            "type": "str"
          },
          {
            "name": "roaming",
            "type": "bool"
          },
          {
            "name": "force_posix",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 449,
        "decorators": [],
        "is_async": false,
        "calls": [
          "key",
          "os.path.join",
          "os.environ.get",
          "app_name",
          "os.path.expanduser",
          "_posixify",
          "folder"
        ],
        "docstring": "Returns the config folder for the application.  The default behavior\nis to return whatever is most appropriate for the operating system.\n\nTo give you an idea, for an app called ``\"Foo Bar\"``, something like\nthe following folders could be returned:\n\nMac OS X:\n  ``~/Library/Application Support/Foo Bar``\nMac OS X (POSIX):\n  ``~/.foo-bar``\nUnix:\n  ``~/.config/foo-bar``\nUnix (POSIX):\n  ``~/.foo-bar``\nWindows (roaming):\n  ``C:\\Users\\<user>\\AppData\\Roaming\\Foo Bar``\nWindows (not roaming):\n  ``C:\\Users\\<user>\\AppData\\Local\\Foo Bar``\n\n.. versionadded:: 2.0\n\n:param app_name: the application name.  This should be properly capitalized\n                 and can contain whitespace.\n:param roaming: controls if the folder should be roaming or not on Windows.\n                Has no effect otherwise.\n:param force_posix: if this is set to `True` then on any POSIX system the\n                    folder will be stored in the home folder with a leading\n                    dot instead of the XDG config home or darwin's\n                    application support folder.",
        "code": "def get_app_dir(app_name: str, roaming: bool = True, force_posix: bool = False) -> str:\n    r\"\"\"Returns the config folder for the application.  The default behavior\n    is to return whatever is most appropriate for the operating system.\n\n    To give you an idea, for an app called ``\"Foo Bar\"``, something like\n    the following folders could be returned:\n\n    Mac OS X:\n      ``~/Library/Application Support/Foo Bar``\n    Mac OS X (POSIX):\n      ``~/.foo-bar``\n    Unix:\n      ``~/.config/foo-bar``\n    Unix (POSIX):\n      ``~/.foo-bar``\n    Windows (roaming):\n      ``C:\\Users\\<user>\\AppData\\Roaming\\Foo Bar``\n    Windows (not roaming):\n      ``C:\\Users\\<user>\\AppData\\Local\\Foo Bar``\n\n    .. versionadded:: 2.0\n\n    :param app_name: the application name.  This should be properly capitalized\n                     and can contain whitespace.\n    :param roaming: controls if the folder should be roaming or not on Windows.\n                    Has no effect otherwise.\n    :param force_posix: if this is set to `True` then on any POSIX system the\n                        folder will be stored in the home folder with a leading\n                        dot instead of the XDG config home or darwin's\n                        application support folder.\n    \"\"\"\n    if WIN:\n        key = \"APPDATA\" if roaming else \"LOCALAPPDATA\"\n        folder = os.environ.get(key)\n        if folder is None:\n            folder = os.path.expanduser(\"~\")\n        return os.path.join(folder, app_name)\n    if force_posix:\n        return os.path.join(os.path.expanduser(f\"~/.{_posixify(app_name)}\"))\n    if sys.platform == \"darwin\":\n        return os.path.join(\n            os.path.expanduser(\"~/Library/Application Support\"), app_name\n        )\n    return os.path.join(\n        os.environ.get(\"XDG_CONFIG_HOME\", os.path.expanduser(\"~/.config\")),\n        _posixify(app_name),\n    )",
        "line_count": 47,
        "needs_llm_summary": true
      },
      {
        "name": "_detect_program_name",
        "args": [
          {
            "name": "path",
            "type": "Any"
          },
          {
            "name": "_main",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 523,
        "decorators": [],
        "is_async": false,
        "calls": [
          "path",
          "_main",
          "str",
          "os.path.exists",
          "py_module.lstrip",
          "os.path.splitext",
          "t.cast",
          "os.path.basename",
          "_main.__package__",
          "getattr"
        ],
        "docstring": "Determine the command used to run the program, for use in help\ntext. If a file or entry point was executed, the file name is\nreturned. If ``python -m`` was used to execute a module or package,\n``python -m name`` is returned.\n\nThis doesn't try to be too precise, the goal is to give a concise\nname for help text. Files are only shown as their name without the\npath. ``python`` is only shown for modules, and the full path to\n``sys.executable`` is not shown.\n\n:param path: The Python file being executed. Python puts this in\n    ``sys.argv[0]``, which is used by default.\n:param _main: The ``__main__`` module. This should only be passed\n    during internal testing.\n\n.. versionadded:: 8.0\n    Based on command args detection in the Werkzeug reloader.\n\n:meta private:",
        "code": "def _detect_program_name(\n    path: str | None = None, _main: ModuleType | None = None\n) -> str:\n    \"\"\"Determine the command used to run the program, for use in help\n    text. If a file or entry point was executed, the file name is\n    returned. If ``python -m`` was used to execute a module or package,\n    ``python -m name`` is returned.\n\n    This doesn't try to be too precise, the goal is to give a concise\n    name for help text. Files are only shown as their name without the\n    path. ``python`` is only shown for modules, and the full path to\n    ``sys.executable`` is not shown.\n\n    :param path: The Python file being executed. Python puts this in\n        ``sys.argv[0]``, which is used by default.\n    :param _main: The ``__main__`` module. This should only be passed\n        during internal testing.\n\n    .. versionadded:: 8.0\n        Based on command args detection in the Werkzeug reloader.\n\n    :meta private:\n    \"\"\"\n    if _main is None:\n        _main = sys.modules[\"__main__\"]\n\n    if not path:\n        path = sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    # It is set to \"\" inside a Shiv or PEX zipapp.\n    if getattr(_main, \"__package__\", None) in {None, \"\"} or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):\n        # Executed a file, like \"python app.py\".\n        return os.path.basename(path)\n\n    # Executed a module, like \"python -m example\".\n    # Rewritten by Python from \"-m script\" to \"/path/to/script.py\".\n    # Need to look at main module to determine how it was executed.\n    py_module = t.cast(str, _main.__package__)\n    name = os.path.splitext(os.path.basename(path))[0]\n\n    # A submodule like \"example.cli\".\n    if name != \"__main__\":\n        py_module = f\"{py_module}.{name}\"\n\n    return f\"python -m {py_module.lstrip('.')}\"",
        "line_count": 53,
        "needs_llm_summary": true
      },
      {
        "name": "_expand_args",
        "args": [
          {
            "name": "args",
            "type": "cabc.Iterable[str]"
          }
        ],
        "return_type": "list[str]",
        "lineno": 578,
        "decorators": [],
        "is_async": false,
        "calls": [
          "arg",
          "os.path.expanduser",
          "glob_recursive",
          "os.path.expandvars",
          "glob",
          "matches",
          "out.append",
          "out.extend"
        ],
        "docstring": "Simulate Unix shell expansion with Python functions.\n\nSee :func:`glob.glob`, :func:`os.path.expanduser`, and\n:func:`os.path.expandvars`.\n\nThis is intended for use on Windows, where the shell does not do any\nexpansion. It may not exactly match what a Unix shell would do.\n\n:param args: List of command line arguments to expand.\n:param user: Expand user home directory.\n:param env: Expand environment variables.\n:param glob_recursive: ``**`` matches directories recursively.\n\n.. versionchanged:: 8.1\n    Invalid glob patterns are treated as empty expansions rather\n    than raising an error.\n\n.. versionadded:: 8.0\n\n:meta private:",
        "code": "def _expand_args(\n    args: cabc.Iterable[str],\n    *,\n    user: bool = True,\n    env: bool = True,\n    glob_recursive: bool = True,\n) -> list[str]:\n    \"\"\"Simulate Unix shell expansion with Python functions.\n\n    See :func:`glob.glob`, :func:`os.path.expanduser`, and\n    :func:`os.path.expandvars`.\n\n    This is intended for use on Windows, where the shell does not do any\n    expansion. It may not exactly match what a Unix shell would do.\n\n    :param args: List of command line arguments to expand.\n    :param user: Expand user home directory.\n    :param env: Expand environment variables.\n    :param glob_recursive: ``**`` matches directories recursively.\n\n    .. versionchanged:: 8.1\n        Invalid glob patterns are treated as empty expansions rather\n        than raising an error.\n\n    .. versionadded:: 8.0\n\n    :meta private:\n    \"\"\"\n    from glob import glob\n\n    out = []\n\n    for arg in args:\n        if user:\n            arg = os.path.expanduser(arg)\n\n        if env:\n            arg = os.path.expandvars(arg)\n\n        try:\n            matches = glob(arg, recursive=glob_recursive)\n        except re.error:\n            matches = []\n\n        if not matches:\n            out.append(arg)\n        else:\n            out.extend(matches)\n\n    return out",
        "line_count": 50,
        "needs_llm_summary": true
      },
      {
        "name": "wrapper",
        "args": [],
        "return_type": "Any",
        "lineno": 39,
        "decorators": [],
        "is_async": false,
        "calls": [
          "kwargs",
          "func"
        ],
        "docstring": null,
        "code": "def wrapper(*args: P.args, **kwargs: P.kwargs) -> R | None:\n        try:\n            return func(*args, **kwargs)\n        except Exception:\n            pass\n        return None",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "filename",
            "type": "Any"
          },
          {
            "name": "mode",
            "type": "str"
          },
          {
            "name": "encoding",
            "type": "Any"
          },
          {
            "name": "errors",
            "type": "Any"
          },
          {
            "name": "atomic",
            "type": "bool"
          }
        ],
        "return_type": null,
        "lineno": 116,
        "decorators": [],
        "is_async": false,
        "calls": [
          "filename",
          "open_stream",
          "mode",
          "encoding",
          "os.fspath",
          "errors",
          "open",
          "atomic",
          "unknown.close"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        filename: str | os.PathLike[str],\n        mode: str = \"r\",\n        encoding: str | None = None,\n        errors: str | None = \"strict\",\n        atomic: bool = False,\n    ):\n        self.name: str = os.fspath(filename)\n        self.mode = mode\n        self.encoding = encoding\n        self.errors = errors\n        self.atomic = atomic\n        self._f: t.IO[t.Any] | None\n        self.should_close: bool\n\n        if self.name == \"-\":\n            self._f, self.should_close = open_stream(filename, mode, encoding, errors)\n        else:\n            if \"r\" in mode:\n                # Open and close the file in case we're opening it for\n                # reading so that we can catch at least some errors in\n                # some cases early.\n                open(filename, mode).close()\n            self._f = None\n            self.should_close = True",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "t.Any",
        "lineno": 143,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "self.open",
          "getattr"
        ],
        "docstring": null,
        "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self.open(), name)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 146,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "self._f",
          "self.name",
          "format_filename"
        ],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        if self._f is not None:\n            return repr(self._f)\n        return f\"<unopened file '{format_filename(self.name)}' {self.mode}>\"",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "open",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "t.IO[t.Any]",
        "lineno": 151,
        "decorators": [],
        "is_async": false,
        "calls": [
          "open_stream",
          "self.encoding",
          "rv",
          "self.name",
          "self.mode",
          "self.errors",
          "FileError",
          "self.atomic",
          "e.strerror"
        ],
        "docstring": "Opens the file if it's not yet open.  This call might fail with\na :exc:`FileError`.  Not handling this error will produce an error\nthat Click shows.",
        "code": "def open(self) -> t.IO[t.Any]:\n        \"\"\"Opens the file if it's not yet open.  This call might fail with\n        a :exc:`FileError`.  Not handling this error will produce an error\n        that Click shows.\n        \"\"\"\n        if self._f is not None:\n            return self._f\n        try:\n            rv, self.should_close = open_stream(\n                self.name, self.mode, self.encoding, self.errors, atomic=self.atomic\n            )\n        except OSError as e:\n            from .exceptions import FileError\n\n            raise FileError(self.name, hint=e.strerror) from e\n        self._f = rv\n        return rv",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "close",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 169,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._f.close"
        ],
        "docstring": "Closes the underlying file, no matter what.",
        "code": "def close(self) -> None:\n        \"\"\"Closes the underlying file, no matter what.\"\"\"\n        if self._f is not None:\n            self._f.close()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "close_intelligently",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 174,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.close"
        ],
        "docstring": "This function only closes the file if it was opened by the lazy\nfile wrapper.  For instance this will never close stdin.",
        "code": "def close_intelligently(self) -> None:\n        \"\"\"This function only closes the file if it was opened by the lazy\n        file wrapper.  For instance this will never close stdin.\n        \"\"\"\n        if self.should_close:\n            self.close()",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "LazyFile",
        "lineno": 181,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __enter__(self) -> LazyFile:\n        return self",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Any"
          },
          {
            "name": "exc_value",
            "type": "Any"
          },
          {
            "name": "tb",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 184,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.close_intelligently"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.close_intelligently()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__iter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "cabc.Iterator[t.AnyStr]",
        "lineno": 192,
        "decorators": [],
        "is_async": false,
        "calls": [
          "iter",
          "self.open",
          "self._f"
        ],
        "docstring": null,
        "code": "def __iter__(self) -> cabc.Iterator[t.AnyStr]:\n        self.open()\n        return iter(self._f)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "t.IO[t.Any]"
          }
        ],
        "return_type": "None",
        "lineno": 198,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self, file: t.IO[t.Any]) -> None:\n        self._file: t.IO[t.Any] = file",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "t.Any",
        "lineno": 201,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "self._file",
          "getattr"
        ],
        "docstring": null,
        "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._file, name)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "KeepOpenFile",
        "lineno": 204,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __enter__(self) -> KeepOpenFile:\n        return self",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Any"
          },
          {
            "name": "exc_value",
            "type": "Any"
          },
          {
            "name": "tb",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 207,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        pass",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 215,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "self._file"
        ],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return repr(self._file)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__iter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "cabc.Iterator[t.AnyStr]",
        "lineno": 218,
        "decorators": [],
        "is_async": false,
        "calls": [
          "iter",
          "self._file"
        ],
        "docstring": null,
        "code": "def __iter__(self) -> cabc.Iterator[t.AnyStr]:\n        return iter(self._file)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "wrapped",
            "type": "t.IO[t.Any]"
          }
        ],
        "return_type": "None",
        "lineno": 507,
        "decorators": [],
        "is_async": false,
        "calls": [
          "wrapped"
        ],
        "docstring": null,
        "code": "def __init__(self, wrapped: t.IO[t.Any]) -> None:\n        self.wrapped = wrapped",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "flush",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 510,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.wrapped.flush"
        ],
        "docstring": null,
        "code": "def flush(self) -> None:\n        try:\n            self.wrapped.flush()\n        except OSError as e:\n            import errno\n\n            if e.errno != errno.EPIPE:\n                raise",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "attr",
            "type": "str"
          }
        ],
        "return_type": "t.Any",
        "lineno": 519,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.wrapped",
          "attr",
          "getattr"
        ],
        "docstring": null,
        "code": "def __getattr__(self, attr: str) -> t.Any:\n        return getattr(self.wrapped, attr)",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "LazyFile",
        "methods": [
          "__init__",
          "__getattr__",
          "__repr__",
          "open",
          "close",
          "close_intelligently",
          "__enter__",
          "__exit__",
          "__iter__"
        ],
        "base_classes": [],
        "lineno": 109,
        "docstring": "A lazy file works like a regular file but it does not fully open\nthe file but it does perform some basic checks early to see if the\nfilename parameter does make sense.  This is useful for safely opening\nfiles for writing."
      },
      {
        "name": "KeepOpenFile",
        "methods": [
          "__init__",
          "__getattr__",
          "__enter__",
          "__exit__",
          "__repr__",
          "__iter__"
        ],
        "base_classes": [],
        "lineno": 197,
        "docstring": null
      },
      {
        "name": "PacifyFlushWrapper",
        "methods": [
          "__init__",
          "flush",
          "__getattr__"
        ],
        "base_classes": [],
        "lineno": 498,
        "docstring": "This wrapper is used to catch and suppress BrokenPipeErrors resulting\nfrom ``.flush()`` being called on broken pipe during the shutdown/final-GC\nof the Python interpreter. Notably ``.flush()`` is always called on\n``sys.stdout`` and ``sys.stderr``. So as to have minimal impact on any\nother cleanup code, and the case where the underlying file is not a broken\npipe, all calls and attributes are proxied."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "collections.abc",
        "alias": "cabc",
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "re",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": "t",
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "functools",
        "name": "update_wrapper",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "ModuleType",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "_default_text_stderr",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "_default_text_stdout",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "_find_binary_writer",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "auto_wrap_for_ansi",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "binary_streams",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "open_stream",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "should_strip_ansi",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "strip_ansi",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "text_streams",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "_compat",
        "name": "WIN",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "globals",
        "name": "resolve_color_default",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "typing_extensions",
        "alias": "te",
        "lineno": 25,
        "type": "import"
      },
      {
        "module": "glob",
        "name": "glob",
        "alias": null,
        "lineno": 606,
        "type": "from_import"
      },
      {
        "module": "exceptions",
        "name": "FileError",
        "alias": null,
        "lineno": 163,
        "type": "from_import"
      },
      {
        "module": "errno",
        "alias": null,
        "lineno": 514,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "R",
        "assigned_to": "t.TypeVar",
        "lineno": 29
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "t.TypeVar",
        "te.ParamSpec"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "re",
        "sys",
        "functools",
        "typing",
        "os",
        "glob",
        "collections"
      ],
      "third_party": {
        "other": [
          "__future__",
          "types",
          "_compat",
          "globals",
          "typing_extensions",
          "exceptions",
          "errno"
        ]
      },
      "tech_stack": []
    },
    "line_count": 628
  },
  "__analysis_summary__": {
    "total_modules": 31,
    "total_functions": 347,
    "total_classes": 78,
    "dead_code_candidates": {
      "unreferenced_functions": [
        {
          "name": "push",
          "module": "examples/aliases/aliases.py",
          "lineno": 102
        },
        {
          "name": "pull",
          "module": "examples/aliases/aliases.py",
          "lineno": 108
        },
        {
          "name": "clone",
          "module": "examples/aliases/aliases.py",
          "lineno": 114
        },
        {
          "name": "commit",
          "module": "examples/aliases/aliases.py",
          "lineno": 120
        },
        {
          "name": "status",
          "module": "examples/aliases/aliases.py",
          "lineno": 127
        },
        {
          "name": "alias",
          "module": "examples/aliases/aliases.py",
          "lineno": 139
        },
        {
          "name": "ls",
          "module": "examples/completion/completion.py",
          "lineno": 14
        },
        {
          "name": "show_env",
          "module": "examples/completion/completion.py",
          "lineno": 26
        },
        {
          "name": "select_user",
          "module": "examples/completion/completion.py",
          "lineno": 52
        },
        {
          "name": "process_commands",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 24
        },
        {
          "name": "open_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 84
        },
        {
          "name": "save_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 110
        },
        {
          "name": "display_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 123
        },
        {
          "name": "resize_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 135
        },
        {
          "name": "crop_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 151
        },
        {
          "name": "transpose_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 195
        },
        {
          "name": "blur_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 212
        },
        {
          "name": "smoothen_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 229
        },
        {
          "name": "emboss_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 243
        },
        {
          "name": "sharpen_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 255
        },
        {
          "name": "paste_cmd",
          "module": "examples/imagepipe/imagepipe.py",
          "lineno": 267
        },
        {
          "name": "ship",
          "module": "examples/naval/naval.py",
          "lineno": 16
        },
        {
          "name": "ship_new",
          "module": "examples/naval/naval.py",
          "lineno": 22
        },
        {
          "name": "ship_move",
          "module": "examples/naval/naval.py",
          "lineno": 32
        },
        {
          "name": "ship_shoot",
          "module": "examples/naval/naval.py",
          "lineno": 41
        },
        {
          "name": "mine",
          "module": "examples/naval/naval.py",
          "lineno": 47
        },
        {
          "name": "mine_set",
          "module": "examples/naval/naval.py",
          "lineno": 62
        },
        {
          "name": "mine_remove",
          "module": "examples/naval/naval.py",
          "lineno": 70
        },
        {
          "name": "clone",
          "module": "examples/repo/repo.py",
          "lineno": 72
        },
        {
          "name": "delete",
          "module": "examples/repo/repo.py",
          "lineno": 91
        },
        {
          "name": "setuser",
          "module": "examples/repo/repo.py",
          "lineno": 105
        },
        {
          "name": "commit",
          "module": "examples/repo/repo.py",
          "lineno": 126
        },
        {
          "name": "colordemo",
          "module": "examples/termui/termui.py",
          "lineno": 15
        },
        {
          "name": "progress",
          "module": "examples/termui/termui.py",
          "lineno": 38
        },
        {
          "name": "menu",
          "module": "examples/termui/termui.py",
          "lineno": 145
        },
        {
          "name": "get_binary_stderr",
          "module": "src/click/_compat.py",
          "lineno": 330
        },
        {
          "name": "seekable",
          "module": "src/click/_compat.py",
          "lineno": 140
        },
        {
          "name": "_handle_long_word",
          "module": "src/click/_textwrap.py",
          "lineno": 9
        },
        {
          "name": "_get_text_stdin",
          "module": "src/click/_winconsole.py",
          "lineno": 226
        },
        {
          "name": "_get_text_stdout",
          "module": "src/click/_winconsole.py",
          "lineno": 236
        },
        {
          "name": "_get_text_stderr",
          "module": "src/click/_winconsole.py",
          "lineno": 246
        },
        {
          "name": "readinto",
          "module": "src/click/_winconsole.py",
          "lineno": 131
        },
        {
          "name": "writelines",
          "module": "src/click/_winconsole.py",
          "lineno": 212
        },
        {
          "name": "with_resource",
          "module": "src/click/core.py",
          "lineno": 575
        },
        {
          "name": "add_source",
          "module": "src/click/core.py",
          "lineno": 1987
        },
        {
          "name": "pass_meta_key",
          "module": "src/click/decorators.py",
          "lineno": 100
        },
        {
          "name": "add_completion_class",
          "module": "src/click/shell_completion.py",
          "lineno": 436
        },
        {
          "name": "isolated_filesystem",
          "module": "src/click/testing.py",
          "lineno": 547
        }
      ],
      "unused_classes": [
        {
          "name": "Sentinel",
          "module": "src/click/_utils.py",
          "lineno": 7
        },
        {
          "name": "_WindowsConsoleRawIOBase",
          "module": "src/click/_winconsole.py",
          "lineno": 118
        },
        {
          "name": "ParameterSource",
          "module": "src/click/core.py",
          "lineno": 143
        },
        {
          "name": "_FakeSubclassCheck",
          "module": "src/click/core.py",
          "lineno": 1488
        },
        {
          "name": "ShellComplete",
          "module": "src/click/shell_completion.py",
          "lineno": 200
        },
        {
          "name": "BashComplete",
          "module": "src/click/shell_completion.py",
          "lineno": 304
        },
        {
          "name": "ZshComplete",
          "module": "src/click/shell_completion.py",
          "lineno": 363
        },
        {
          "name": "FishComplete",
          "module": "src/click/shell_completion.py",
          "lineno": 399
        },
        {
          "name": "CliRunner",
          "module": "src/click/testing.py",
          "lineno": 229
        },
        {
          "name": "CompositeParamType",
          "module": "src/click/types.py",
          "lineno": 163
        },
        {
          "name": "_NumberParamTypeBase",
          "module": "src/click/types.py",
          "lineno": 472
        },
        {
          "name": "_NumberRangeBase",
          "module": "src/click/types.py",
          "lineno": 490
        },
        {
          "name": "OptionHelpExtra",
          "module": "src/click/types.py",
          "lineno": 1205
        }
      ],
      "unused_imports": [
        {
          "module": "examples/complex/complex/commands/cmd_init.py",
          "import_statement": "import complex.cli",
          "lineno": 1,
          "imported_module": "complex.cli",
          "symbols": [
            "pass_environment"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/complex/complex/commands/cmd_status.py",
          "import_statement": "import complex.cli",
          "lineno": 1,
          "imported_module": "complex.cli",
          "symbols": [
            "pass_environment"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_compat.py",
          "import_statement": "import collections.abc",
          "lineno": 4,
          "imported_module": "collections.abc",
          "symbols": [
            "cabc"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_compat.py",
          "import_statement": "import types",
          "lineno": 10,
          "imported_module": "types",
          "symbols": [
            "TracebackType"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_compat.py",
          "import_statement": "import errno",
          "lineno": 413,
          "imported_module": "errno",
          "symbols": [
            "errno"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_termui_impl.py",
          "import_statement": "import contextlib",
          "lineno": 10,
          "imported_module": "contextlib",
          "symbols": [
            "contextlib"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_termui_impl.py",
          "import_statement": "import types",
          "lineno": 20,
          "imported_module": "types",
          "symbols": [
            "TracebackType"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_termui_impl.py",
          "import_statement": "import _compat",
          "lineno": 23,
          "imported_module": "_compat",
          "symbols": [
            "CYGWIN"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_termui_impl.py",
          "import_statement": "import _compat",
          "lineno": 29,
          "imported_module": "_compat",
          "symbols": [
            "WIN"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_textwrap.py",
          "import_statement": "import contextlib",
          "lineno": 5,
          "imported_module": "contextlib",
          "symbols": [
            "contextmanager"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_winconsole.py",
          "import_statement": "import sys",
          "lineno": 13,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/_winconsole.py",
          "import_statement": "import ctypes",
          "lineno": 19,
          "imported_module": "ctypes",
          "symbols": [
            "c_char_p"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/core.py",
          "import_statement": "import errno",
          "lineno": 5,
          "imported_module": "errno",
          "symbols": [
            "errno"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/core.py",
          "import_statement": "import contextlib",
          "lineno": 13,
          "imported_module": "contextlib",
          "symbols": [
            "contextmanager"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/core.py",
          "import_statement": "import types",
          "lineno": 19,
          "imported_module": "types",
          "symbols": [
            "TracebackType"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/core.py",
          "import_statement": "import _utils",
          "lineno": 22,
          "imported_module": "_utils",
          "symbols": [
            "FLAG_NEEDS_VALUE"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/exceptions.py",
          "import_statement": "import collections.abc",
          "lineno": 3,
          "imported_module": "collections.abc",
          "symbols": [
            "cabc"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/formatting.py",
          "import_statement": "import contextlib",
          "lineno": 4,
          "imported_module": "contextlib",
          "symbols": [
            "contextmanager"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/parser.py",
          "import_statement": "import _utils",
          "lineno": 41,
          "imported_module": "_utils",
          "symbols": [
            "T_FLAG_NEEDS_VALUE"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/parser.py",
          "import_statement": "import _utils",
          "lineno": 42,
          "imported_module": "_utils",
          "symbols": [
            "T_UNSET"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/parser.py",
          "import_statement": "import shell_completion",
          "lineno": 522,
          "imported_module": "shell_completion",
          "symbols": [
            "split_arg_string"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/shell_completion.py",
          "import_statement": "import os",
          "lineno": 4,
          "imported_module": "os",
          "symbols": [
            "os"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/shell_completion.py",
          "import_statement": "import core",
          "lineno": 15,
          "imported_module": "core",
          "symbols": [
            "ParameterSource"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/termui.py",
          "import_statement": "import collections.abc",
          "lineno": 3,
          "imported_module": "collections.abc",
          "symbols": [
            "cabc"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/termui.py",
          "import_statement": "import utils",
          "lineno": 21,
          "imported_module": "utils",
          "symbols": [
            "LazyFile"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/testing.py",
          "import_statement": "import contextlib",
          "lineno": 4,
          "imported_module": "contextlib",
          "symbols": [
            "contextlib"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/testing.py",
          "import_statement": "import types",
          "lineno": 11,
          "imported_module": "types",
          "symbols": [
            "TracebackType"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/types.py",
          "import_statement": "import operator",
          "lineno": 519,
          "imported_module": "operator",
          "symbols": [
            "operator"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/utils.py",
          "import_statement": "import types",
          "lineno": 9,
          "imported_module": "types",
          "symbols": [
            "ModuleType"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/utils.py",
          "import_statement": "import types",
          "lineno": 10,
          "imported_module": "types",
          "symbols": [
            "TracebackType"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/utils.py",
          "import_statement": "import _compat",
          "lineno": 21,
          "imported_module": "_compat",
          "symbols": [
            "WIN"
          ],
          "needs_llm": false
        },
        {
          "module": "src/click/utils.py",
          "import_statement": "import errno",
          "lineno": 514,
          "imported_module": "errno",
          "symbols": [
            "errno"
          ],
          "needs_llm": false
        }
      ],
      "unused_global_variables": [
        {
          "module": "src/click/_compat.py",
          "name": "CYGWIN",
          "lineno": 13,
          "assigned_to": "sys.platform.startswith",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "_default_text_stdin",
          "lineno": 607,
          "assigned_to": "_make_cached_stream_func",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "_default_text_stdout",
          "lineno": 608,
          "assigned_to": "_make_cached_stream_func",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "_default_text_stderr",
          "lineno": 609,
          "assigned_to": "_make_cached_stream_func",
          "needs_llm": true
        },
        {
          "module": "src/click/_utils.py",
          "name": "T_UNSET",
          "lineno": 32,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "src/click/_utils.py",
          "name": "T_FLAG_NEEDS_VALUE",
          "lineno": 35,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "GetCommandLineW",
          "lineno": 47,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "CommandLineToArgvW",
          "lineno": 48,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "LocalFree",
          "lineno": 51,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "STDIN_FILENO",
          "lineno": 64,
          "assigned_to": "int",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "STDOUT_FILENO",
          "lineno": 65,
          "assigned_to": "int",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "STDERR_FILENO",
          "lineno": 66,
          "assigned_to": "int",
          "needs_llm": true
        }
      ],
      "unreachable_code": [],
      "suspicious_patterns": [
        {
          "module": "examples/completion/completion.py",
          "name": "cli",
          "lineno": 8,
          "pattern_type": "empty_function",
          "details": "Function is empty or only contains pass/return None",
          "needs_llm": true
        },
        {
          "module": "examples/completion/completion.py",
          "name": "group",
          "lineno": 32,
          "pattern_type": "empty_function",
          "details": "Function is empty or only contains pass/return None",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "_force_correct_text_stream",
          "lineno": 238,
          "pattern_type": "too_many_parameters",
          "details": "Function has 7 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "main",
          "lineno": 1338,
          "pattern_type": "long_function",
          "details": "Function is very long (112 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help_record",
          "lineno": 2604,
          "pattern_type": "empty_function",
          "details": "Function is empty or only contains pass/return None",
          "needs_llm": true
        },
        {
          "module": "src/click/decorators.py",
          "name": "version_option",
          "lineno": 421,
          "pattern_type": "long_function",
          "details": "Function is very long (104 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "src/click/parser.py",
          "name": "add_option",
          "lineno": 261,
          "pattern_type": "too_many_parameters",
          "details": "Function has 7 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "prompt",
          "lineno": 83,
          "pattern_type": "long_function",
          "details": "Function is very long (112 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "prompt",
          "lineno": 83,
          "pattern_type": "too_many_parameters",
          "details": "Function has 10 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "progressbar",
          "lineno": 314,
          "pattern_type": "too_many_parameters",
          "details": "Function has 16 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "progressbar",
          "lineno": 334,
          "pattern_type": "long_function",
          "details": "Function is very long (157 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "progressbar",
          "lineno": 334,
          "pattern_type": "too_many_parameters",
          "details": "Function has 16 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "style",
          "lineno": 518,
          "pattern_type": "long_function",
          "details": "Function is very long (127 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "style",
          "lineno": 518,
          "pattern_type": "too_many_parameters",
          "details": "Function has 12 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "src/click/testing.py",
          "name": "isolation",
          "lineno": 280,
          "pattern_type": "long_function",
          "details": "Function is very long (152 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "src/click/testing.py",
          "name": "invoke",
          "lineno": 433,
          "pattern_type": "long_function",
          "details": "Function is very long (112 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "src/click/testing.py",
          "name": "invoke",
          "lineno": 433,
          "pattern_type": "too_many_parameters",
          "details": "Function has 7 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "src/click/utils.py",
          "name": "echo",
          "lineno": 222,
          "pattern_type": "long_function",
          "details": "Function is very long (101 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "examples/aliases/aliases.py",
          "name": "read_config",
          "lineno": 76,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/aliases/aliases.py",
          "name": "push",
          "lineno": 102,
          "pattern_type": "similar_function_names",
          "details": "Similar to push_context in src/click/globals.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/aliases/aliases.py",
          "name": "read_config",
          "lineno": 17,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/aliases/aliases.py",
          "name": "write_config",
          "lineno": 25,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/_winconsole.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/aliases/aliases.py",
          "name": "write_config",
          "lineno": 25,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/_winconsole.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/aliases/aliases.py",
          "name": "write_config",
          "lineno": 25,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/aliases/aliases.py",
          "name": "write_config",
          "lineno": 25,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/completion/completion.py",
          "name": "show_env",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/completion/completion.py",
          "name": "show_env",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/completion/completion.py",
          "name": "show_env",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "process_commands",
          "lineno": 24,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "process_commands",
          "lineno": 24,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "processor",
          "lineno": 42,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "processor",
          "lineno": 42,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "copy_filename",
          "lineno": 69,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy in examples/repo/repo.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "open_cmd",
          "lineno": 84,
          "pattern_type": "similar_function_names",
          "details": "Similar to open in examples/termui/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "open_cmd",
          "lineno": 84,
          "pattern_type": "similar_function_names",
          "details": "Similar to open in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in examples/validation/validation.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_rotation",
          "lineno": 165,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in examples/validation/validation.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "convert_flip",
          "lineno": 178,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "processor",
          "lineno": 48,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/imagepipe/imagepipe.py",
          "name": "processor",
          "lineno": 48,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/naval/naval.py",
          "name": "ship",
          "lineno": 16,
          "pattern_type": "similar_function_names",
          "details": "Similar to ship_new in examples/naval/naval.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/naval/naval.py",
          "name": "ship",
          "lineno": 16,
          "pattern_type": "similar_function_names",
          "details": "Similar to ship_move in examples/naval/naval.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/naval/naval.py",
          "name": "ship",
          "lineno": 16,
          "pattern_type": "similar_function_names",
          "details": "Similar to ship_shoot in examples/naval/naval.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/naval/naval.py",
          "name": "mine",
          "lineno": 47,
          "pattern_type": "similar_function_names",
          "details": "Similar to mine_set in examples/naval/naval.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/naval/naval.py",
          "name": "mine",
          "lineno": 47,
          "pattern_type": "similar_function_names",
          "details": "Similar to mine_remove in examples/naval/naval.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "progress",
          "lineno": 38,
          "pattern_type": "similar_function_names",
          "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "progress",
          "lineno": 38,
          "pattern_type": "similar_function_names",
          "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "progress",
          "lineno": 38,
          "pattern_type": "similar_function_names",
          "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "open",
          "lineno": 105,
          "pattern_type": "similar_function_names",
          "details": "Similar to open_stream in src/click/_compat.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "open",
          "lineno": 105,
          "pattern_type": "similar_function_names",
          "details": "Similar to open_url in src/click/_termui_impl.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "open",
          "lineno": 105,
          "pattern_type": "similar_function_names",
          "details": "Similar to open_file in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "edit",
          "lineno": 118,
          "pattern_type": "similar_function_names",
          "details": "Similar to edit_files in src/click/_termui_impl.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "process_slowly",
          "lineno": 42,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "process_slowly",
          "lineno": 42,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "show_item",
          "lineno": 56,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "show_item",
          "lineno": 56,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/termui/termui.py",
          "name": "show_item",
          "lineno": 56,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/validation/validation.py",
          "name": "convert",
          "lineno": 15,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "get_text_stdin",
          "lineno": 337,
          "pattern_type": "similar_function_names",
          "details": "Similar to _get_text_stdin in src/click/_winconsole.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "get_text_stdout",
          "lineno": 344,
          "pattern_type": "similar_function_names",
          "details": "Similar to _get_text_stdout in src/click/_winconsole.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "get_text_stderr",
          "lineno": 351,
          "pattern_type": "similar_function_names",
          "details": "Similar to _get_text_stderr in src/click/_winconsole.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "open_stream",
          "lineno": 371,
          "pattern_type": "similar_function_names",
          "details": "Similar to open in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "read1",
          "lineno": 105,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "readable",
          "lineno": 113,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "close",
          "lineno": 463,
          "pattern_type": "similar_function_names",
          "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "__exit__",
          "lineno": 476,
          "pattern_type": "similar_function_names",
          "details": "Similar to exit in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "func",
          "lineno": 585,
          "pattern_type": "similar_function_names",
          "details": "Similar to function in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_compat.py",
          "name": "func",
          "lineno": 585,
          "pattern_type": "similar_function_names",
          "details": "Similar to func_name in src/click/shell_completion.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "open_url",
          "lineno": 676,
          "pattern_type": "similar_function_names",
          "details": "Similar to open in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "__exit__",
          "lineno": 120,
          "pattern_type": "similar_function_names",
          "details": "Similar to exit in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "edit_files",
          "lineno": 594,
          "pattern_type": "similar_function_names",
          "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "edit_files",
          "lineno": 594,
          "pattern_type": "similar_function_names",
          "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "edit_files",
          "lineno": 594,
          "pattern_type": "similar_function_names",
          "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "edit_files",
          "lineno": 594,
          "pattern_type": "similar_function_names",
          "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "edit_files",
          "lineno": 594,
          "pattern_type": "similar_function_names",
          "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "edit_files",
          "lineno": 594,
          "pattern_type": "similar_function_names",
          "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "edit_files",
          "lineno": 594,
          "pattern_type": "similar_function_names",
          "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "getchar",
          "lineno": 767,
          "pattern_type": "similar_function_names",
          "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_termui_impl.py",
          "name": "getchar",
          "lineno": 844,
          "pattern_type": "similar_function_names",
          "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_textwrap.py",
          "name": "indent_only",
          "lineno": 40,
          "pattern_type": "similar_function_names",
          "details": "Similar to indent in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "readable",
          "lineno": 128,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "readinto",
          "lineno": 131,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 174,
          "pattern_type": "similar_function_names",
          "details": "Similar to writelines in src/click/_winconsole.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 174,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 174,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 174,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 174,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 174,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 203,
          "pattern_type": "similar_function_names",
          "details": "Similar to writelines in src/click/_winconsole.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 203,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 203,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 203,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 203,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "write",
          "lineno": 203,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "writelines",
          "lineno": 212,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/_winconsole.py",
          "name": "writelines",
          "lineno": 212,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "_check_iter",
          "lineno": 2017,
          "pattern_type": "similar_function_names",
          "details": "Similar to check_iter in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "__exit__",
          "lineno": 481,
          "pattern_type": "similar_function_names",
          "details": "Similar to exit in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "close",
          "lineno": 616,
          "pattern_type": "similar_function_names",
          "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "command_path",
          "lineno": 642,
          "pattern_type": "similar_function_names",
          "details": "Similar to command in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "command_path",
          "lineno": 642,
          "pattern_type": "similar_function_names",
          "details": "Similar to command in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "command_path",
          "lineno": 642,
          "pattern_type": "similar_function_names",
          "details": "Similar to command in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "command_path",
          "lineno": 642,
          "pattern_type": "similar_function_names",
          "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "command_path",
          "lineno": 642,
          "pattern_type": "similar_function_names",
          "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "command_path",
          "lineno": 642,
          "pattern_type": "similar_function_names",
          "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "command_path",
          "lineno": 642,
          "pattern_type": "similar_function_names",
          "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "command_path",
          "lineno": 642,
          "pattern_type": "similar_function_names",
          "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "exit",
          "lineno": 730,
          "pattern_type": "similar_function_names",
          "details": "Similar to __exit__ in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "exit",
          "lineno": 730,
          "pattern_type": "similar_function_names",
          "details": "Similar to __exit__ in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_usage",
          "lineno": 740,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_usage",
          "lineno": 740,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help",
          "lineno": 746,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_option_names in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help",
          "lineno": 746,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_option in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help",
          "lineno": 746,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help",
          "lineno": 746,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help",
          "lineno": 746,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_extra in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_usage",
          "lineno": 993,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_usage",
          "lineno": 993,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help_option_names",
          "lineno": 1046,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_option in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help_option_names",
          "lineno": 1046,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help_option",
          "lineno": 1054,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help",
          "lineno": 1088,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help",
          "lineno": 1088,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_help",
          "lineno": 1088,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_help_extra in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "format_help",
          "lineno": 1120,
          "pattern_type": "similar_function_names",
          "details": "Similar to format_help_text in src/click/core.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_default",
          "lineno": 2249,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_default",
          "lineno": 2254,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "get_default",
          "lineno": 2258,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "process_value",
          "lineno": 2411,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "process_value",
          "lineno": 2411,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "prompt_for_value",
          "lineno": 3117,
          "pattern_type": "similar_function_names",
          "details": "Similar to prompt in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "process_value",
          "lineno": 3301,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "process_value",
          "lineno": 3301,
          "pattern_type": "similar_function_names",
          "details": "Similar to process in src/click/parser.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "convert",
          "lineno": 2362,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "convert",
          "lineno": 2367,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/core.py",
          "name": "convert",
          "lineno": 2372,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/decorators.py",
          "name": "confirmation_option",
          "lineno": 380,
          "pattern_type": "similar_function_names",
          "details": "Similar to confirm in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/decorators.py",
          "name": "show_help",
          "lineno": 536,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/decorators.py",
          "name": "show_help",
          "lineno": 536,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/decorators.py",
          "name": "show_help",
          "lineno": 536,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write",
          "lineno": 135,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write",
          "lineno": 135,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write",
          "lineno": 135,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write",
          "lineno": 135,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write",
          "lineno": 135,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "indent",
          "lineno": 139,
          "pattern_type": "similar_function_names",
          "details": "Similar to indentation in src/click/formatting.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write_usage",
          "lineno": 147,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write_heading",
          "lineno": 185,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write_paragraph",
          "lineno": 189,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write_text",
          "lineno": 194,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/formatting.py",
          "name": "write_dl",
          "lineno": 210,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/shell_completion.py",
          "name": "source_vars",
          "lineno": 244,
          "pattern_type": "similar_function_names",
          "details": "Similar to source in src/click/shell_completion.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/shell_completion.py",
          "name": "source_vars",
          "lineno": 244,
          "pattern_type": "similar_function_names",
          "details": "Similar to source in src/click/shell_completion.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "prompt",
          "lineno": 83,
          "pattern_type": "similar_function_names",
          "details": "Similar to prompt_func in src/click/termui.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "echo_via_pager",
          "lineno": 261,
          "pattern_type": "similar_function_names",
          "details": "Similar to echo in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/termui.py",
          "name": "getchar",
          "lineno": 816,
          "pattern_type": "similar_function_names",
          "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/testing.py",
          "name": "_echo",
          "lineno": 34,
          "pattern_type": "similar_function_names",
          "details": "Similar to echo in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/testing.py",
          "name": "read",
          "lineno": 40,
          "pattern_type": "similar_function_names",
          "details": "Similar to read1 in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/testing.py",
          "name": "read",
          "lineno": 40,
          "pattern_type": "similar_function_names",
          "details": "Similar to readline in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/testing.py",
          "name": "read",
          "lineno": 40,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/testing.py",
          "name": "readline",
          "lineno": 46,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in src/click/testing.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/types.py",
          "name": "convert_type",
          "lineno": 1112,
          "pattern_type": "similar_function_names",
          "details": "Similar to convert in src/click/types.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/utils.py",
          "name": "open_file",
          "lineno": 358,
          "pattern_type": "similar_function_names",
          "details": "Similar to open in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "src/click/utils.py",
          "name": "close",
          "lineno": 169,
          "pattern_type": "similar_function_names",
          "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
          "needs_llm": true
        }
      ]
    }
  }
}