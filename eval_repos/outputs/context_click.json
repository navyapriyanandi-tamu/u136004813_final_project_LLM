{
  "repo_name": "click",
  "ast_results": {
    "docs/conf.py": {
      "filepath": "../click/docs/conf.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "pallets_sphinx_themes",
          "name": "get_version",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "pallets_sphinx_themes",
          "name": "ProjectLink",
          "alias": null,
          "lineno": 2,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "project",
          "assigned_to": "str",
          "lineno": 6
        },
        {
          "name": "copyright",
          "assigned_to": "str",
          "lineno": 7
        },
        {
          "name": "author",
          "assigned_to": "str",
          "lineno": 8
        },
        {
          "name": "master_doc",
          "assigned_to": "str",
          "lineno": 13
        },
        {
          "name": "default_role",
          "assigned_to": "str",
          "lineno": 14
        },
        {
          "name": "extensions",
          "assigned_to": null,
          "lineno": 15
        },
        {
          "name": "autodoc_member_order",
          "assigned_to": "str",
          "lineno": 24
        },
        {
          "name": "autodoc_typehints",
          "assigned_to": "str",
          "lineno": 25
        },
        {
          "name": "autodoc_preserve_defaults",
          "assigned_to": "bool",
          "lineno": 26
        },
        {
          "name": "extlinks",
          "assigned_to": null,
          "lineno": 27
        },
        {
          "name": "intersphinx_mapping",
          "assigned_to": null,
          "lineno": 31
        },
        {
          "name": "html_theme",
          "assigned_to": "str",
          "lineno": 37
        },
        {
          "name": "html_theme_options",
          "assigned_to": null,
          "lineno": 38
        },
        {
          "name": "html_context",
          "assigned_to": null,
          "lineno": 39
        },
        {
          "name": "html_sidebars",
          "assigned_to": null,
          "lineno": 48
        },
        {
          "name": "singlehtml_sidebars",
          "assigned_to": null,
          "lineno": 52
        },
        {
          "name": "html_static_path",
          "assigned_to": null,
          "lineno": 53
        },
        {
          "name": "html_favicon",
          "assigned_to": "str",
          "lineno": 54
        },
        {
          "name": "html_logo",
          "assigned_to": "str",
          "lineno": 55
        },
        {
          "name": "html_title",
          "assigned_to": null,
          "lineno": 56
        },
        {
          "name": "html_show_sourcelink",
          "assigned_to": "bool",
          "lineno": 57
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "get_version",
          "ProjectLink"
        ],
        "class_instantiations": [
          "ProjectLink"
        ]
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "pallets_sphinx_themes"
          ]
        },
        "tech_stack": []
      },
      "line_count": 58
    },
    "examples/aliases/aliases.py": {
      "filepath": "../click/examples/aliases/aliases.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "read_config",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "param"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 76,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Config",
            "value",
            "__file__",
            "os.path.dirname",
            "cfg.read_config",
            "ctx.ensure_object",
            "os.path.join"
          ],
          "docstring": "Callback that is used whenever --config is passed.  We use this to\nalways load the correct config.  This means that the config is loaded\neven if the group itself never executes so our aliases stay always\navailable.",
          "code": "def read_config(ctx, param, value):\n    \"\"\"Callback that is used whenever --config is passed.  We use this to\n    always load the correct config.  This means that the config is loaded\n    even if the group itself never executes so our aliases stay always\n    available.\n    \"\"\"\n    cfg = ctx.ensure_object(Config)\n    if value is None:\n        value = os.path.join(os.path.dirname(__file__), \"aliases.ini\")\n    cfg.read_config(value)\n    return value",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "cli",
          "args": [],
          "return_type": null,
          "lineno": 97,
          "decorators": [
            {
              "name": "click.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--config"
              ],
              "kwargs": {
                "expose_value": false,
                "help": "The config file to use instead of the default."
              }
            }
          ],
          "is_async": false,
          "calls": [
            "click.command",
            "AliasedGroup",
            "read_config",
            "click.option",
            "click.Path"
          ],
          "docstring": "An example application that supports aliases.",
          "code": "def cli():\n    \"\"\"An example application that supports aliases.\"\"\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "push",
          "args": [],
          "return_type": null,
          "lineno": 102,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.echo"
          ],
          "docstring": "Pushes changes.",
          "code": "def push():\n    \"\"\"Pushes changes.\"\"\"\n    click.echo(\"Push\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "pull",
          "args": [],
          "return_type": null,
          "lineno": 108,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.echo"
          ],
          "docstring": "Pulls changes.",
          "code": "def pull():\n    \"\"\"Pulls changes.\"\"\"\n    click.echo(\"Pull\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "clone",
          "args": [],
          "return_type": null,
          "lineno": 114,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.echo"
          ],
          "docstring": "Clones a repository.",
          "code": "def clone():\n    \"\"\"Clones a repository.\"\"\"\n    click.echo(\"Clone\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "commit",
          "args": [],
          "return_type": null,
          "lineno": 120,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.echo"
          ],
          "docstring": "Commits pending changes.",
          "code": "def commit():\n    \"\"\"Commits pending changes.\"\"\"\n    click.echo(\"Commit\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "status",
          "args": [
            {
              "name": "config"
            }
          ],
          "return_type": null,
          "lineno": 127,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "pass_config",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.echo"
          ],
          "docstring": "Shows the status.",
          "code": "def status(config):\n    \"\"\"Shows the status.\"\"\"\n    click.echo(f\"Status for {config.path}\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "alias",
          "args": [
            {
              "name": "config"
            },
            {
              "name": "alias_"
            },
            {
              "name": "cmd"
            },
            {
              "name": "config_file"
            }
          ],
          "return_type": null,
          "lineno": 139,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "pass_config",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "alias_"
              ],
              "kwargs": {
                "metavar": "ALIAS"
              }
            },
            {
              "name": "click.argument",
              "args": [
                "cmd"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--config_file"
              ],
              "kwargs": {
                "default": "aliases.ini"
              }
            }
          ],
          "is_async": false,
          "calls": [
            "alias_",
            "click.echo",
            "click.argument",
            "config.write_config",
            "click.option",
            "cli.command",
            "config_file",
            "click.STRING",
            "config.add_alias",
            "cmd",
            "click.Path"
          ],
          "docstring": "Adds an alias to the specified configuration file.",
          "code": "def alias(config, alias_, cmd, config_file):\n    \"\"\"Adds an alias to the specified configuration file.\"\"\"\n    config.add_alias(alias_, cmd)\n    config.write_config(config_file)\n    click.echo(f\"Added '{alias_}' as alias for '{cmd}'\")",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 10,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.getcwd"
          ],
          "docstring": null,
          "code": "def __init__(self):\n        self.path = os.getcwd()\n        self.aliases = {}",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "add_alias",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "alias"
            },
            {
              "name": "cmd"
            }
          ],
          "return_type": null,
          "lineno": 14,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.aliases.update"
          ],
          "docstring": null,
          "code": "def add_alias(self, alias, cmd):\n        self.aliases.update({alias: cmd})",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "read_config",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename"
            }
          ],
          "return_type": null,
          "lineno": 17,
          "decorators": [],
          "is_async": false,
          "calls": [
            "configparser.RawConfigParser",
            "parser.read",
            "self.aliases.update",
            "parser.items"
          ],
          "docstring": null,
          "code": "def read_config(self, filename):\n        parser = configparser.RawConfigParser()\n        parser.read([filename])\n        try:\n            self.aliases.update(parser.items(\"aliases\"))\n        except configparser.NoSectionError:\n            pass",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "write_config",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename"
            }
          ],
          "return_type": null,
          "lineno": 25,
          "decorators": [],
          "is_async": false,
          "calls": [
            "filename",
            "key",
            "configparser.RawConfigParser",
            "open",
            "parser.write",
            "parser.set",
            "value",
            "file",
            "self.aliases.items",
            "parser.add_section"
          ],
          "docstring": null,
          "code": "def write_config(self, filename):\n        parser = configparser.RawConfigParser()\n        parser.add_section(\"aliases\")\n        for key, value in self.aliases.items():\n            parser.set(\"aliases\", key, value)\n        with open(filename, \"wb\") as file:\n            parser.write(file)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "get_command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx"
            },
            {
              "name": "cmd_name"
            }
          ],
          "return_type": null,
          "lineno": 42,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Config",
            "click.Group.get_command",
            "unknown.join",
            "self",
            "ctx",
            "actual_cmd",
            "len",
            "sorted",
            "cmd_name",
            "ctx.fail",
            "cmd_name.lower",
            "matches",
            "x.lower",
            "unknown.startswith",
            "ctx.ensure_object",
            "self.list_commands"
          ],
          "docstring": null,
          "code": "def get_command(self, ctx, cmd_name):\n        # Step one: bulitin commands as normal\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n\n        # Step two: find the config object and ensure it's there.  This\n        # will create the config object is missing.\n        cfg = ctx.ensure_object(Config)\n\n        # Step three: look up an explicit command alias in the config\n        if cmd_name in cfg.aliases:\n            actual_cmd = cfg.aliases[cmd_name]\n            return click.Group.get_command(self, ctx, actual_cmd)\n\n        # Alternative option: if we did not find an explicit alias we\n        # allow automatic abbreviation of the command.  \"status\" for\n        # instance will match \"st\".  We only allow that however if\n        # there is only one command.\n        matches = [\n            x for x in self.list_commands(ctx) if x.lower().startswith(cmd_name.lower())\n        ]\n        if not matches:\n            return None\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail(f\"Too many matches: {', '.join(sorted(matches))}\")",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "resolve_command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx"
            },
            {
              "name": "args"
            }
          ],
          "return_type": null,
          "lineno": 70,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "super",
            "args",
            "unknown.resolve_command"
          ],
          "docstring": null,
          "code": "def resolve_command(self, ctx, args):\n        # always return the command's name, not the alias\n        _, cmd, args = super().resolve_command(ctx, args)\n        return cmd.name, cmd, args",
          "line_count": 4,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "Config",
          "methods": [
            "__init__",
            "add_alias",
            "read_config",
            "write_config"
          ],
          "base_classes": [],
          "lineno": 7,
          "docstring": "The config in this example only holds aliases."
        },
        {
          "name": "AliasedGroup",
          "methods": [
            "get_command",
            "resolve_command"
          ],
          "base_classes": [
            "click.Group"
          ],
          "lineno": 37,
          "docstring": "This subclass of a group supports looking up aliases in a config\nfile and with a bit of magic."
        }
      ],
      "imports": [
        {
          "module": "configparser",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 2,
          "type": "import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 4,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "pass_config",
          "assigned_to": "click.make_pass_decorator",
          "lineno": 34
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "Config",
          "click.make_pass_decorator"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os"
        ],
        "third_party": {
          "other": [
            "configparser",
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 144
    },
    "examples/colors/colors.py": {
      "filepath": "../click/examples/colors/colors.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [],
          "return_type": null,
          "lineno": 25,
          "decorators": [
            {
              "name": "click.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.style",
            "click.command",
            "click.echo",
            "color"
          ],
          "docstring": "This script prints some colors. It will also automatically remove\nall ANSI styles if data is piped into a file.\n\nGive it a try!",
          "code": "def cli():\n    \"\"\"This script prints some colors. It will also automatically remove\n    all ANSI styles if data is piped into a file.\n\n    Give it a try!\n    \"\"\"\n    for color in all_colors:\n        click.echo(click.style(f\"I am colored {color}\", fg=color))\n    for color in all_colors:\n        click.echo(click.style(f\"I am colored {color} and bold\", fg=color, bold=True))\n    for color in all_colors:\n        click.echo(click.style(f\"I am reverse colored {color}\", fg=color, reverse=True))\n\n    click.echo(click.style(\"I am blinking\", blink=True))\n    click.echo(click.style(\"I am underlined\", underline=True))",
          "line_count": 15,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "click",
          "alias": null,
          "lineno": 1,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "all_colors",
          "assigned_to": null,
          "lineno": 4
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 40
    },
    "examples/completion/completion.py": {
      "filepath": "../click/examples/completion/completion.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [],
          "return_type": null,
          "lineno": 8,
          "decorators": [
            {
              "name": "click.group",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.group"
          ],
          "docstring": null,
          "code": "def cli():\n    pass",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "ls",
          "args": [
            {
              "name": "dir"
            }
          ],
          "return_type": null,
          "lineno": 14,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--dir"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "unknown.join",
            "os.listdir",
            "click.echo",
            "dir",
            "click.option",
            "cli.command",
            "click.Path"
          ],
          "docstring": null,
          "code": "def ls(dir):\n    click.echo(\"\\n\".join(os.listdir(dir)))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_env_vars",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "param"
            },
            {
              "name": "incomplete"
            }
          ],
          "return_type": null,
          "lineno": 18,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_env_vars(ctx, param, incomplete):\n    # Returning a list of values is a shortcut to returning a list of\n    # CompletionItem(value).\n    return [k for k in os.environ if incomplete in k]",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "show_env",
          "args": [
            {
              "name": "envvar"
            }
          ],
          "return_type": null,
          "lineno": 26,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {
                "help": "A command to print environment variables"
              }
            },
            {
              "name": "click.argument",
              "args": [
                "envvar"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "get_env_vars",
            "cli.command",
            "click.echo",
            "click.argument"
          ],
          "docstring": null,
          "code": "def show_env(envvar):\n    click.echo(f\"Environment variable: {envvar}\")\n    click.echo(f\"Value: {os.environ[envvar]}\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "group",
          "args": [],
          "return_type": null,
          "lineno": 32,
          "decorators": [
            {
              "name": "cli.group",
              "args": [],
              "kwargs": {
                "help": "A group that holds a subcommand"
              }
            }
          ],
          "is_async": false,
          "calls": [
            "cli.group"
          ],
          "docstring": null,
          "code": "def group():\n    pass",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "list_users",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "param"
            },
            {
              "name": "incomplete"
            }
          ],
          "return_type": null,
          "lineno": 36,
          "decorators": [],
          "is_async": false,
          "calls": [
            "help",
            "out.append",
            "CompletionItem",
            "value"
          ],
          "docstring": null,
          "code": "def list_users(ctx, param, incomplete):\n    # You can generate completions with help strings by returning a list\n    # of CompletionItem. You can match on whatever you want, including\n    # the help.\n    items = [(\"bob\", \"butcher\"), (\"alice\", \"baker\"), (\"jerry\", \"candlestick maker\")]\n    out = []\n\n    for value, help in items:\n        if incomplete in value or incomplete in help:\n            out.append(CompletionItem(value, help=help))\n\n    return out",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "select_user",
          "args": [
            {
              "name": "user"
            }
          ],
          "return_type": null,
          "lineno": 52,
          "decorators": [
            {
              "name": "group.command",
              "args": [],
              "kwargs": {
                "help": "Choose a user"
              }
            },
            {
              "name": "click.argument",
              "args": [
                "user"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "group.command",
            "list_users",
            "click.echo",
            "click.argument"
          ],
          "docstring": null,
          "code": "def select_user(user):\n    click.echo(f\"Chosen user is {user}\")",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "os",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "click.shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "group",
          "cli.add_command"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os"
        ],
        "third_party": {
          "other": [
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 57
    },
    "examples/complex/complex/__init__.py": {
      "filepath": "../click/examples/complex/complex/__init__.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {},
        "tech_stack": []
      },
      "line_count": 1
    },
    "examples/complex/complex/cli.py": {
      "filepath": "../click/examples/complex/complex/cli.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "verbose"
            },
            {
              "name": "home"
            }
          ],
          "return_type": null,
          "lineno": 56,
          "decorators": [
            {
              "name": "click.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--home"
              ],
              "kwargs": {
                "help": "Changes the folder to operate on."
              }
            },
            {
              "name": "click.option",
              "args": [
                "-v",
                "--verbose"
              ],
              "kwargs": {
                "is_flag": true,
                "help": "Enables verbose mode."
              }
            },
            {
              "name": "pass_environment",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "home",
            "click.command",
            "verbose",
            "click.option",
            "CONTEXT_SETTINGS",
            "ComplexCLI",
            "click.Path"
          ],
          "docstring": "A complex command line interface.",
          "code": "def cli(ctx, verbose, home):\n    \"\"\"A complex command line interface.\"\"\"\n    ctx.verbose = verbose\n    if home is not None:\n        ctx.home = home",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 11,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.getcwd"
          ],
          "docstring": null,
          "code": "def __init__(self):\n        self.verbose = False\n        self.home = os.getcwd()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "log",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "msg"
            }
          ],
          "return_type": null,
          "lineno": 15,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sys.stderr",
            "msg",
            "click.echo"
          ],
          "docstring": "Logs a message to stderr.",
          "code": "def log(self, msg, *args):\n        \"\"\"Logs a message to stderr.\"\"\"\n        if args:\n            msg %= args\n        click.echo(msg, file=sys.stderr)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "vlog",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "msg"
            }
          ],
          "return_type": null,
          "lineno": 21,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.log",
            "msg"
          ],
          "docstring": "Logs a message to stderr only if verbose is enabled.",
          "code": "def vlog(self, msg, *args):\n        \"\"\"Logs a message to stderr only if verbose is enabled.\"\"\"\n        if self.verbose:\n            self.log(msg, *args)",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "list_commands",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx"
            }
          ],
          "return_type": null,
          "lineno": 32,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.listdir",
            "filename.startswith",
            "rv.append",
            "cmd_folder",
            "filename.endswith",
            "rv.sort"
          ],
          "docstring": null,
          "code": "def list_commands(self, ctx):\n        rv = []\n        for filename in os.listdir(cmd_folder):\n            if filename.endswith(\".py\") and filename.startswith(\"cmd_\"):\n                rv.append(filename[4:-3])\n        rv.sort()\n        return rv",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "get_command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx"
            },
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 40,
          "decorators": [],
          "is_async": false,
          "calls": [
            "__import__"
          ],
          "docstring": null,
          "code": "def get_command(self, ctx, name):\n        try:\n            mod = __import__(f\"complex.commands.cmd_{name}\", None, None, [\"cli\"])\n        except ImportError:\n            return\n        return mod.cli",
          "line_count": 6,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "Environment",
          "methods": [
            "__init__",
            "log",
            "vlog"
          ],
          "base_classes": [],
          "lineno": 10,
          "docstring": null
        },
        {
          "name": "ComplexCLI",
          "methods": [
            "list_commands",
            "get_command"
          ],
          "base_classes": [
            "click.Group"
          ],
          "lineno": 31,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "os",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 2,
          "type": "import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 4,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "CONTEXT_SETTINGS",
          "assigned_to": "dict",
          "lineno": 7
        },
        {
          "name": "pass_environment",
          "assigned_to": "click.make_pass_decorator",
          "lineno": 27
        },
        {
          "name": "cmd_folder",
          "assigned_to": "os.path.abspath",
          "lineno": 28
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "dict",
          "__file__",
          "os.path.dirname",
          "click.make_pass_decorator",
          "os.path.abspath",
          "Environment",
          "os.path.join"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os",
          "sys"
        ],
        "third_party": {
          "other": [
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 61
    },
    "examples/complex/complex/commands/__init__.py": {
      "filepath": "../click/examples/complex/complex/commands/__init__.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {},
        "tech_stack": []
      },
      "line_count": 1
    },
    "examples/complex/complex/commands/cmd_init.py": {
      "filepath": "../click/examples/complex/complex/commands/cmd_init.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "path"
            }
          ],
          "return_type": null,
          "lineno": 9,
          "decorators": [
            {
              "name": "click.command",
              "args": [
                "init"
              ],
              "kwargs": {
                "short_help": "Initializes a repo."
              }
            },
            {
              "name": "click.argument",
              "args": [
                "path"
              ],
              "kwargs": {
                "required": false
              }
            },
            {
              "name": "pass_environment",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.command",
            "path",
            "click.argument",
            "ctx.log",
            "click.format_filename",
            "ctx.home",
            "click.Path"
          ],
          "docstring": "Initializes a repository.",
          "code": "def cli(ctx, path):\n    \"\"\"Initializes a repository.\"\"\"\n    if path is None:\n        path = ctx.home\n    ctx.log(f\"Initialized the repository in {click.format_filename(path)}\")",
          "line_count": 5,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "complex.cli",
          "name": "pass_environment",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 3,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "complex",
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 14
    },
    "examples/complex/complex/commands/cmd_status.py": {
      "filepath": "../click/examples/complex/complex/commands/cmd_status.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [
            {
              "name": "ctx"
            }
          ],
          "return_type": null,
          "lineno": 8,
          "decorators": [
            {
              "name": "click.command",
              "args": [
                "status"
              ],
              "kwargs": {
                "short_help": "Shows file changes."
              }
            },
            {
              "name": "pass_environment",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "ctx.log",
            "click.command",
            "ctx.vlog"
          ],
          "docstring": "Shows file changes in the current working directory.",
          "code": "def cli(ctx):\n    \"\"\"Shows file changes in the current working directory.\"\"\"\n    ctx.log(\"Changed files: none\")\n    ctx.vlog(\"bla bla bla, debug info\")",
          "line_count": 4,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "complex.cli",
          "name": "pass_environment",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 3,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "complex",
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 12
    },
    "examples/imagepipe/imagepipe.py": {
      "filepath": "../click/examples/imagepipe/imagepipe.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [],
          "return_type": null,
          "lineno": 11,
          "decorators": [
            {
              "name": "click.group",
              "args": [],
              "kwargs": {
                "chain": true
              }
            }
          ],
          "is_async": false,
          "calls": [
            "click.group"
          ],
          "docstring": "This script processes a bunch of images through pillow in a unix\npipe.  One commands feeds into the next.\n\nExample:\n\n\b\n    imagepipe open -i example01.jpg resize -w 128 display\n    imagepipe open -i example02.jpg blur save",
          "code": "def cli():\n    \"\"\"This script processes a bunch of images through pillow in a unix\n    pipe.  One commands feeds into the next.\n\n    Example:\n\n    \\b\n        imagepipe open -i example01.jpg resize -w 128 display\n        imagepipe open -i example02.jpg blur save\n    \"\"\"",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "process_commands",
          "args": [
            {
              "name": "processors"
            }
          ],
          "return_type": null,
          "lineno": 24,
          "decorators": [
            {
              "name": "cli.result_callback",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.result_callback",
            "stream",
            "processor"
          ],
          "docstring": "This result callback is invoked with an iterable of all the chained\nsubcommands.  As in this example each subcommand returns a function\nwe can chain them together to feed one into the other, similar to how\na pipe on unix works.",
          "code": "def process_commands(processors):\n    \"\"\"This result callback is invoked with an iterable of all the chained\n    subcommands.  As in this example each subcommand returns a function\n    we can chain them together to feed one into the other, similar to how\n    a pipe on unix works.\n    \"\"\"\n    # Start with an empty iterable.\n    stream = ()\n\n    # Pipe it through all stream processors.\n    for processor in processors:\n        stream = processor(stream)\n\n    # Evaluate the stream and throw away the items.\n    for _ in stream:\n        pass",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "processor",
          "args": [
            {
              "name": "f"
            }
          ],
          "return_type": null,
          "lineno": 42,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "new_func",
            "update_wrapper",
            "kwargs",
            "stream"
          ],
          "docstring": "Helper decorator to rewrite a function so that it returns another\nfunction from it.",
          "code": "def processor(f):\n    \"\"\"Helper decorator to rewrite a function so that it returns another\n    function from it.\n    \"\"\"\n\n    def new_func(*args, **kwargs):\n        def processor(stream):\n            return f(stream, *args, **kwargs)\n\n        return processor\n\n    return update_wrapper(new_func, f)",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "generator",
          "args": [
            {
              "name": "f"
            }
          ],
          "return_type": null,
          "lineno": 56,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "update_wrapper",
            "new_func",
            "kwargs"
          ],
          "docstring": "Similar to the :func:`processor` but passes through old values\nunchanged and does not pass through the values as parameter.",
          "code": "def generator(f):\n    \"\"\"Similar to the :func:`processor` but passes through old values\n    unchanged and does not pass through the values as parameter.\n    \"\"\"\n\n    @processor\n    def new_func(stream, *args, **kwargs):\n        yield from stream\n        yield from f(*args, **kwargs)\n\n    return update_wrapper(new_func, f)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "copy_filename",
          "args": [
            {
              "name": "new"
            },
            {
              "name": "old"
            }
          ],
          "return_type": null,
          "lineno": 69,
          "decorators": [],
          "is_async": false,
          "calls": [
            "old.filename"
          ],
          "docstring": null,
          "code": "def copy_filename(new, old):\n    new.filename = old.filename\n    return new",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "open_cmd",
          "args": [
            {
              "name": "images"
            }
          ],
          "return_type": null,
          "lineno": 84,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "open"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "-i",
                "--image",
                "images"
              ],
              "kwargs": {
                "multiple": true,
                "help": "The image file to open."
              }
            },
            {
              "name": "generator",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.echo",
            "image",
            "Image.open",
            "click.get_binary_stdin",
            "click.option",
            "cli.command",
            "click.Path"
          ],
          "docstring": "Loads one or multiple images for processing.  The input parameter\ncan be specified multiple times to load more than one image.",
          "code": "def open_cmd(images):\n    \"\"\"Loads one or multiple images for processing.  The input parameter\n    can be specified multiple times to load more than one image.\n    \"\"\"\n    for image in images:\n        try:\n            click.echo(f\"Opening '{image}'\")\n            if image == \"-\":\n                img = Image.open(click.get_binary_stdin())\n                img.filename = \"-\"\n            else:\n                img = Image.open(image)\n            yield img\n        except Exception as e:\n            click.echo(f\"Could not open image '{image}': {e}\", err=True)",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "save_cmd",
          "args": [
            {
              "name": "images"
            },
            {
              "name": "filename"
            }
          ],
          "return_type": null,
          "lineno": 110,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "save"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--filename"
              ],
              "kwargs": {
                "default": "processed-{:04}.png",
                "help": "The format for the filename.",
                "show_default": true
              }
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "enumerate",
            "fn",
            "click.echo",
            "images",
            "click.option",
            "cli.command",
            "filename.format",
            "image.save",
            "click.Path"
          ],
          "docstring": "Saves all processed images to a series of files.",
          "code": "def save_cmd(images, filename):\n    \"\"\"Saves all processed images to a series of files.\"\"\"\n    for idx, image in enumerate(images):\n        try:\n            fn = filename.format(idx + 1)\n            click.echo(f\"Saving '{image.filename}' as '{fn}'\")\n            yield image.save(fn)\n        except Exception as e:\n            click.echo(f\"Could not save image '{image.filename}': {e}\", err=True)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "display_cmd",
          "args": [
            {
              "name": "images"
            }
          ],
          "return_type": null,
          "lineno": 123,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "display"
              ],
              "kwargs": {}
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "image.show",
            "cli.command",
            "click.echo"
          ],
          "docstring": "Opens all images in an image viewer.",
          "code": "def display_cmd(images):\n    \"\"\"Opens all images in an image viewer.\"\"\"\n    for image in images:\n        click.echo(f\"Displaying '{image.filename}'\")\n        image.show()\n        yield image",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "resize_cmd",
          "args": [
            {
              "name": "images"
            },
            {
              "name": "width"
            },
            {
              "name": "height"
            }
          ],
          "return_type": null,
          "lineno": 135,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "resize"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "-w",
                "--width"
              ],
              "kwargs": {
                "help": "The new width of the image."
              }
            },
            {
              "name": "click.option",
              "args": [
                "-h",
                "--height"
              ],
              "kwargs": {
                "help": "The new height of the image."
              }
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "image.thumbnail",
            "click.echo",
            "int",
            "click.option",
            "cli.command"
          ],
          "docstring": "Resizes an image by fitting it into the box without changing\nthe aspect ratio.",
          "code": "def resize_cmd(images, width, height):\n    \"\"\"Resizes an image by fitting it into the box without changing\n    the aspect ratio.\n    \"\"\"\n    for image in images:\n        w, h = (width or image.size[0], height or image.size[1])\n        click.echo(f\"Resizing '{image.filename}' to {w}x{h}\")\n        image.thumbnail((w, h))\n        yield image",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "crop_cmd",
          "args": [
            {
              "name": "images"
            },
            {
              "name": "border"
            }
          ],
          "return_type": null,
          "lineno": 151,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "crop"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "-b",
                "--border"
              ],
              "kwargs": {
                "help": "Crop the image from all sides by this amount."
              }
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "enumerate",
            "click.echo",
            "image",
            "max",
            "int",
            "copy_filename",
            "box",
            "click.option",
            "cli.command",
            "image.crop"
          ],
          "docstring": "Crops an image from all edges.",
          "code": "def crop_cmd(images, border):\n    \"\"\"Crops an image from all edges.\"\"\"\n    for image in images:\n        box = [0, 0, image.size[0], image.size[1]]\n\n        if border is not None:\n            for idx, val in enumerate(box):\n                box[idx] = max(0, val - border)\n            click.echo(f\"Cropping '{image.filename}' by {border}px\")\n            yield copy_filename(image.crop(box), image)\n        else:\n            yield image",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "convert_rotation",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "param"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 165,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value.lower",
            "click.BadParameter"
          ],
          "docstring": null,
          "code": "def convert_rotation(ctx, param, value):\n    if value is None:\n        return\n    value = value.lower()\n    if value in (\"90\", \"r\", \"right\"):\n        return (Image.ROTATE_90, 90)\n    if value in (\"180\", \"-180\"):\n        return (Image.ROTATE_180, 180)\n    if value in (\"-90\", \"270\", \"l\", \"left\"):\n        return (Image.ROTATE_270, 270)\n    raise click.BadParameter(f\"invalid rotation '{value}'\")",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "convert_flip",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "param"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 178,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value.lower",
            "click.BadParameter"
          ],
          "docstring": null,
          "code": "def convert_flip(ctx, param, value):\n    if value is None:\n        return\n    value = value.lower()\n    if value in (\"lr\", \"leftright\"):\n        return (Image.FLIP_LEFT_RIGHT, \"left to right\")\n    if value in (\"tb\", \"topbottom\", \"upsidedown\", \"ud\"):\n        return (Image.FLIP_LEFT_RIGHT, \"top to bottom\")\n    raise click.BadParameter(f\"invalid flip '{value}'\")",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "transpose_cmd",
          "args": [
            {
              "name": "images"
            },
            {
              "name": "rotate"
            },
            {
              "name": "flip"
            }
          ],
          "return_type": null,
          "lineno": 195,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "transpose"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "-r",
                "--rotate"
              ],
              "kwargs": {
                "help": "Rotates the image (in degrees)"
              }
            },
            {
              "name": "click.option",
              "args": [
                "-f",
                "--flip"
              ],
              "kwargs": {
                "help": "Flips the image  [LR / TB]"
              }
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "mode",
            "click.echo",
            "image",
            "rotate",
            "convert_rotation",
            "copy_filename",
            "click.option",
            "cli.command",
            "flip",
            "convert_flip",
            "image.transpose"
          ],
          "docstring": "Transposes an image by either rotating or flipping it.",
          "code": "def transpose_cmd(images, rotate, flip):\n    \"\"\"Transposes an image by either rotating or flipping it.\"\"\"\n    for image in images:\n        if rotate is not None:\n            mode, degrees = rotate\n            click.echo(f\"Rotate '{image.filename}' by {degrees}deg\")\n            image = copy_filename(image.transpose(mode), image)\n        if flip is not None:\n            mode, direction = flip\n            click.echo(f\"Flip '{image.filename}' {direction}\")\n            image = copy_filename(image.transpose(mode), image)\n        yield image",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "blur_cmd",
          "args": [
            {
              "name": "images"
            },
            {
              "name": "radius"
            }
          ],
          "return_type": null,
          "lineno": 212,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "blur"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "-r",
                "--radius"
              ],
              "kwargs": {
                "default": 2,
                "show_default": true,
                "help": "The blur radius."
              }
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.echo",
            "ImageFilter.GaussianBlur",
            "image",
            "image.filter",
            "blur",
            "copy_filename",
            "click.option",
            "cli.command",
            "radius"
          ],
          "docstring": "Applies gaussian blur.",
          "code": "def blur_cmd(images, radius):\n    \"\"\"Applies gaussian blur.\"\"\"\n    blur = ImageFilter.GaussianBlur(radius)\n    for image in images:\n        click.echo(f\"Blurring '{image.filename}' by {radius}px\")\n        yield copy_filename(image.filter(blur), image)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "smoothen_cmd",
          "args": [
            {
              "name": "images"
            },
            {
              "name": "iterations"
            }
          ],
          "return_type": null,
          "lineno": 229,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "smoothen"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "-i",
                "--iterations"
              ],
              "kwargs": {
                "default": 1,
                "show_default": true,
                "help": "How many iterations of the smoothen filter to run."
              }
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "iterations",
            "click.echo",
            "image",
            "image.filter",
            "copy_filename",
            "click.option",
            "cli.command",
            "ImageFilter.BLUR",
            "range"
          ],
          "docstring": "Applies a smoothening filter.",
          "code": "def smoothen_cmd(images, iterations):\n    \"\"\"Applies a smoothening filter.\"\"\"\n    for image in images:\n        click.echo(\n            f\"Smoothening {image.filename!r} {iterations}\"\n            f\" time{'s' if iterations != 1 else ''}\"\n        )\n        for _ in range(iterations):\n            image = copy_filename(image.filter(ImageFilter.BLUR), image)\n        yield image",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "emboss_cmd",
          "args": [
            {
              "name": "images"
            }
          ],
          "return_type": null,
          "lineno": 243,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "emboss"
              ],
              "kwargs": {}
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "image",
            "click.echo",
            "image.filter",
            "copy_filename",
            "cli.command",
            "ImageFilter.EMBOSS"
          ],
          "docstring": "Embosses an image.",
          "code": "def emboss_cmd(images):\n    \"\"\"Embosses an image.\"\"\"\n    for image in images:\n        click.echo(f\"Embossing '{image.filename}'\")\n        yield copy_filename(image.filter(ImageFilter.EMBOSS), image)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "sharpen_cmd",
          "args": [
            {
              "name": "images"
            },
            {
              "name": "factor"
            }
          ],
          "return_type": null,
          "lineno": 255,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "sharpen"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "-f",
                "--factor"
              ],
              "kwargs": {
                "default": 2.0,
                "help": "Sharpens the image.",
                "show_default": true
              }
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "ImageEnhance.Sharpness",
            "image",
            "click.echo",
            "max",
            "copy_filename",
            "click.option",
            "cli.command",
            "enhancer.enhance",
            "factor"
          ],
          "docstring": "Sharpens an image.",
          "code": "def sharpen_cmd(images, factor):\n    \"\"\"Sharpens an image.\"\"\"\n    for image in images:\n        click.echo(f\"Sharpen '{image.filename}' by {factor}\")\n        enhancer = ImageEnhance.Sharpness(image)\n        yield copy_filename(enhancer.enhance(max(1.0, factor)), image)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "paste_cmd",
          "args": [
            {
              "name": "images"
            },
            {
              "name": "left"
            },
            {
              "name": "right"
            }
          ],
          "return_type": null,
          "lineno": 267,
          "decorators": [
            {
              "name": "cli.command",
              "args": [
                "paste"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "-l",
                "--left"
              ],
              "kwargs": {
                "default": 0,
                "help": "Offset from left."
              }
            },
            {
              "name": "click.option",
              "args": [
                "-r",
                "--right"
              ],
              "kwargs": {
                "default": 0,
                "help": "Offset from right."
              }
            },
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.echo",
            "next",
            "images",
            "click.option",
            "cli.command",
            "imageiter",
            "to_paste",
            "image.paste",
            "iter",
            "mask"
          ],
          "docstring": "Pastes the second image on the first image and leaves the rest\nunchanged.",
          "code": "def paste_cmd(images, left, right):\n    \"\"\"Pastes the second image on the first image and leaves the rest\n    unchanged.\n    \"\"\"\n    imageiter = iter(images)\n    image = next(imageiter, None)\n    to_paste = next(imageiter, None)\n\n    if to_paste is None:\n        if image is not None:\n            yield image\n        return\n\n    click.echo(f\"Paste '{to_paste.filename}' on '{image.filename}'\")\n    mask = None\n    if to_paste.mode == \"RGBA\" or \"transparency\" in to_paste.info:\n        mask = to_paste\n    image.paste(to_paste, (left, right), mask)\n    image.filename += f\"+{to_paste.filename}\"\n    yield image\n\n    yield from imageiter",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "new_func",
          "args": [],
          "return_type": null,
          "lineno": 47,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "f",
            "kwargs"
          ],
          "docstring": null,
          "code": "def new_func(*args, **kwargs):\n        def processor(stream):\n            return f(stream, *args, **kwargs)\n\n        return processor",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "new_func",
          "args": [
            {
              "name": "stream"
            }
          ],
          "return_type": null,
          "lineno": 62,
          "decorators": [
            {
              "name": "processor",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "kwargs"
          ],
          "docstring": null,
          "code": "def new_func(stream, *args, **kwargs):\n        yield from stream\n        yield from f(*args, **kwargs)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "processor",
          "args": [
            {
              "name": "stream"
            }
          ],
          "return_type": null,
          "lineno": 48,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "f",
            "kwargs"
          ],
          "docstring": null,
          "code": "def processor(stream):\n            return f(stream, *args, **kwargs)",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "PIL",
          "name": "Image",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "PIL",
          "name": "ImageEnhance",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "PIL",
          "name": "ImageFilter",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 7,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "functools"
        ],
        "third_party": {
          "other": [
            "PIL",
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 289
    },
    "examples/inout/inout.py": {
      "filepath": "../click/examples/inout/inout.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [
            {
              "name": "input"
            },
            {
              "name": "output"
            }
          ],
          "return_type": null,
          "lineno": 7,
          "decorators": [
            {
              "name": "click.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "input"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "output"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.command",
            "output.write",
            "output.flush",
            "click.argument",
            "chunk",
            "click.File",
            "f.read"
          ],
          "docstring": "This script works similar to the Unix `cat` command but it writes\ninto a specific file (which could be the standard output as denoted by\nthe ``-`` sign).\n\n\b\nCopy stdin to stdout:\n    inout - -\n\n\b\nCopy foo.txt and bar.txt to stdout:\n    inout foo.txt bar.txt -\n\n\b\nWrite stdin into the file foo.txt\n    inout - foo.txt",
          "code": "def cli(input, output):\n    \"\"\"This script works similar to the Unix `cat` command but it writes\n    into a specific file (which could be the standard output as denoted by\n    the ``-`` sign).\n\n    \\b\n    Copy stdin to stdout:\n        inout - -\n\n    \\b\n    Copy foo.txt and bar.txt to stdout:\n        inout foo.txt bar.txt -\n\n    \\b\n    Write stdin into the file foo.txt\n        inout - foo.txt\n    \"\"\"\n    for f in input:\n        while True:\n            chunk = f.read(1024)\n            if not chunk:\n                break\n            output.write(chunk)\n            output.flush()",
          "line_count": 24,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "click",
          "alias": null,
          "lineno": 1,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 31
    },
    "examples/naval/naval.py": {
      "filepath": "../click/examples/naval/naval.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [],
          "return_type": null,
          "lineno": 6,
          "decorators": [
            {
              "name": "click.group",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.version_option",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.version_option",
            "click.group"
          ],
          "docstring": "Naval Fate.\n\nThis is the docopt example adopted to Click but with some actual\ncommands implemented and not just the empty parsing which really\nis not all that interesting.",
          "code": "def cli():\n    \"\"\"Naval Fate.\n\n    This is the docopt example adopted to Click but with some actual\n    commands implemented and not just the empty parsing which really\n    is not all that interesting.\n    \"\"\"",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "ship",
          "args": [],
          "return_type": null,
          "lineno": 16,
          "decorators": [
            {
              "name": "cli.group",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.group"
          ],
          "docstring": "Manages ships.",
          "code": "def ship():\n    \"\"\"Manages ships.\"\"\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "ship_new",
          "args": [
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 22,
          "decorators": [
            {
              "name": "ship.command",
              "args": [
                "new"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "name"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "ship.command",
            "click.echo",
            "click.argument"
          ],
          "docstring": "Creates a new ship.",
          "code": "def ship_new(name):\n    \"\"\"Creates a new ship.\"\"\"\n    click.echo(f\"Created ship {name}\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "ship_move",
          "args": [
            {
              "name": "ship"
            },
            {
              "name": "x"
            },
            {
              "name": "y"
            },
            {
              "name": "speed"
            }
          ],
          "return_type": null,
          "lineno": 32,
          "decorators": [
            {
              "name": "ship.command",
              "args": [
                "move"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "ship"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "x"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "y"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--speed"
              ],
              "kwargs": {
                "metavar": "KN",
                "default": 10,
                "help": "Speed in knots."
              }
            }
          ],
          "is_async": false,
          "calls": [
            "click.echo",
            "click.argument",
            "click.option",
            "float",
            "ship.command"
          ],
          "docstring": "Moves SHIP to the new location X,Y.",
          "code": "def ship_move(ship, x, y, speed):\n    \"\"\"Moves SHIP to the new location X,Y.\"\"\"\n    click.echo(f\"Moving ship {ship} to {x},{y} with speed {speed}\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "ship_shoot",
          "args": [
            {
              "name": "ship"
            },
            {
              "name": "x"
            },
            {
              "name": "y"
            }
          ],
          "return_type": null,
          "lineno": 41,
          "decorators": [
            {
              "name": "ship.command",
              "args": [
                "shoot"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "ship"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "x"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "y"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "float",
            "ship.command",
            "click.echo",
            "click.argument"
          ],
          "docstring": "Makes SHIP fire to X,Y.",
          "code": "def ship_shoot(ship, x, y):\n    \"\"\"Makes SHIP fire to X,Y.\"\"\"\n    click.echo(f\"Ship {ship} fires to {x},{y}\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "mine",
          "args": [],
          "return_type": null,
          "lineno": 47,
          "decorators": [
            {
              "name": "cli.group",
              "args": [
                "mine"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.group"
          ],
          "docstring": "Manages mines.",
          "code": "def mine():\n    \"\"\"Manages mines.\"\"\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "mine_set",
          "args": [
            {
              "name": "x"
            },
            {
              "name": "y"
            },
            {
              "name": "ty"
            }
          ],
          "return_type": null,
          "lineno": 62,
          "decorators": [
            {
              "name": "mine.command",
              "args": [
                "set"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "x"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "y"
              ],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "ty",
                "--moored"
              ],
              "kwargs": {
                "flag_value": "moored",
                "default": true,
                "help": "Moored (anchored) mine. Default."
              }
            },
            {
              "name": "click.option",
              "args": [
                "ty",
                "--drifting"
              ],
              "kwargs": {
                "flag_value": "drifting",
                "help": "Drifting mine."
              }
            }
          ],
          "is_async": false,
          "calls": [
            "click.echo",
            "click.argument",
            "click.option",
            "float",
            "mine.command"
          ],
          "docstring": "Sets a mine at a specific coordinate.",
          "code": "def mine_set(x, y, ty):\n    \"\"\"Sets a mine at a specific coordinate.\"\"\"\n    click.echo(f\"Set {ty} mine at {x},{y}\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "mine_remove",
          "args": [
            {
              "name": "x"
            },
            {
              "name": "y"
            }
          ],
          "return_type": null,
          "lineno": 70,
          "decorators": [
            {
              "name": "mine.command",
              "args": [
                "remove"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "x"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "y"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "mine.command",
            "float",
            "click.echo",
            "click.argument"
          ],
          "docstring": "Removes a mine at a specific coordinate.",
          "code": "def mine_remove(x, y):\n    \"\"\"Removes a mine at a specific coordinate.\"\"\"\n    click.echo(f\"Removed mine at {x},{y}\")",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "click",
          "alias": null,
          "lineno": 1,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 73
    },
    "examples/repo/repo.py": {
      "filepath": "../click/examples/repo/repo.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "repo_home"
            },
            {
              "name": "config"
            },
            {
              "name": "verbose"
            }
          ],
          "return_type": null,
          "lineno": 44,
          "decorators": [
            {
              "name": "click.group",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--repo-home"
              ],
              "kwargs": {
                "envvar": "REPO_HOME",
                "default": ".repo",
                "metavar": "PATH",
                "help": "Changes the repository folder location."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--config"
              ],
              "kwargs": {
                "nargs": 2,
                "multiple": true,
                "metavar": "KEY VALUE",
                "help": "Overrides a config key/value pair."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--verbose",
                "-v"
              ],
              "kwargs": {
                "is_flag": true,
                "help": "Enables verbose mode."
              }
            },
            {
              "name": "click.version_option",
              "args": [
                "1.0"
              ],
              "kwargs": {}
            },
            {
              "name": "click.pass_context",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "os.path.abspath",
            "Repo",
            "key",
            "verbose",
            "ctx.obj.set_config",
            "value",
            "click.option",
            "click.group",
            "click.version_option",
            "repo_home"
          ],
          "docstring": "Repo is a command line tool that showcases how to build complex\ncommand line interfaces with Click.\n\nThis tool is supposed to look like a distributed version control\nsystem to show how something like this can be structured.",
          "code": "def cli(ctx, repo_home, config, verbose):\n    \"\"\"Repo is a command line tool that showcases how to build complex\n    command line interfaces with Click.\n\n    This tool is supposed to look like a distributed version control\n    system to show how something like this can be structured.\n    \"\"\"\n    # Create a repo object and remember it as as the context object.  From\n    # this point onwards other commands can refer to it by using the\n    # @pass_repo decorator.\n    ctx.obj = Repo(os.path.abspath(repo_home))\n    ctx.obj.verbose = verbose\n    for key, value in config:\n        ctx.obj.set_config(key, value)",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "clone",
          "args": [
            {
              "name": "repo"
            },
            {
              "name": "src"
            },
            {
              "name": "dest"
            },
            {
              "name": "shallow"
            },
            {
              "name": "rev"
            }
          ],
          "return_type": null,
          "lineno": 72,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "src"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "dest"
              ],
              "kwargs": {
                "required": false
              }
            },
            {
              "name": "click.option",
              "args": [
                "--shallow/--deep"
              ],
              "kwargs": {
                "default": false,
                "help": "Makes a checkout shallow or deep.  Deep by default."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--rev",
                "-r"
              ],
              "kwargs": {
                "default": "HEAD",
                "help": "Clone a specific revision instead of HEAD."
              }
            },
            {
              "name": "pass_repo",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "src",
            "dest",
            "click.echo",
            "click.argument",
            "posixpath.split",
            "click.option",
            "cli.command",
            "os.path.basename"
          ],
          "docstring": "Clones a repository.\n\nThis will clone the repository at SRC into the folder DEST.  If DEST\nis not provided this will automatically use the last path component\nof SRC and create that folder.",
          "code": "def clone(repo, src, dest, shallow, rev):\n    \"\"\"Clones a repository.\n\n    This will clone the repository at SRC into the folder DEST.  If DEST\n    is not provided this will automatically use the last path component\n    of SRC and create that folder.\n    \"\"\"\n    if dest is None:\n        dest = posixpath.split(src)[-1] or \".\"\n    click.echo(f\"Cloning repo {src} to {os.path.basename(dest)}\")\n    repo.home = dest\n    if shallow:\n        click.echo(\"Making shallow checkout\")\n    click.echo(f\"Checking out revision {rev}\")",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "delete",
          "args": [
            {
              "name": "repo"
            }
          ],
          "return_type": null,
          "lineno": 91,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.confirmation_option",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "pass_repo",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.echo",
            "click.confirmation_option"
          ],
          "docstring": "Deletes a repository.\n\nThis will throw away the current repository.",
          "code": "def delete(repo):\n    \"\"\"Deletes a repository.\n\n    This will throw away the current repository.\n    \"\"\"\n    click.echo(f\"Destroying repo {repo.home}\")\n    click.echo(\"Deleted!\")",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "setuser",
          "args": [
            {
              "name": "repo"
            },
            {
              "name": "username"
            },
            {
              "name": "email"
            },
            {
              "name": "password"
            }
          ],
          "return_type": null,
          "lineno": 105,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--username"
              ],
              "kwargs": {
                "prompt": true,
                "help": "The developer's shown username."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--email"
              ],
              "kwargs": {
                "prompt": "E-Mail",
                "help": "The developer's email address"
              }
            },
            {
              "name": "click.password_option",
              "args": [],
              "kwargs": {
                "help": "The login password."
              }
            },
            {
              "name": "pass_repo",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.echo",
            "click.password_option",
            "len",
            "password",
            "click.option",
            "cli.command",
            "username",
            "repo.set_config",
            "email"
          ],
          "docstring": "Sets the user credentials.\n\nThis will override the current user config.",
          "code": "def setuser(repo, username, email, password):\n    \"\"\"Sets the user credentials.\n\n    This will override the current user config.\n    \"\"\"\n    repo.set_config(\"username\", username)\n    repo.set_config(\"email\", email)\n    repo.set_config(\"password\", \"*\" * len(password))\n    click.echo(\"Changed credentials.\")",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "commit",
          "args": [
            {
              "name": "repo"
            },
            {
              "name": "files"
            },
            {
              "name": "message"
            }
          ],
          "return_type": null,
          "lineno": 126,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--message",
                "-m"
              ],
              "kwargs": {
                "multiple": true,
                "help": "The commit message.  If provided multiple times each argument gets converted into a new line."
              }
            },
            {
              "name": "click.argument",
              "args": [
                "files"
              ],
              "kwargs": {}
            },
            {
              "name": "pass_repo",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "unknown.join",
            "click.echo",
            "click.argument",
            "message",
            "hint",
            "click.edit",
            "message.split",
            "marker",
            "click.option",
            "cli.command",
            "hint.append",
            "click.Path",
            "unknown.rstrip"
          ],
          "docstring": "Commits outstanding changes.\n\nCommit changes to the given files into the repository.  You will need to\n\"repo push\" to push up your changes to other repositories.\n\nIf a list of files is omitted, all changes reported by \"repo status\"\nwill be committed.",
          "code": "def commit(repo, files, message):\n    \"\"\"Commits outstanding changes.\n\n    Commit changes to the given files into the repository.  You will need to\n    \"repo push\" to push up your changes to other repositories.\n\n    If a list of files is omitted, all changes reported by \"repo status\"\n    will be committed.\n    \"\"\"\n    if not message:\n        marker = \"# Files to be committed:\"\n        hint = [\"\", \"\", marker, \"#\"]\n        for file in files:\n            hint.append(f\"#   U {file}\")\n        message = click.edit(\"\\n\".join(hint))\n        if message is None:\n            click.echo(\"Aborted!\")\n            return\n        msg = message.split(marker)[0].rstrip()\n        if not msg:\n            click.echo(\"Aborted! Empty commit message\")\n            return\n    else:\n        msg = \"\\n\".join(message)\n    click.echo(f\"Files to be committed: {files}\")\n    click.echo(f\"Commit message:\\n{msg}\")",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "copy",
          "args": [
            {
              "name": "repo"
            },
            {
              "name": "src"
            },
            {
              "name": "dst"
            },
            {
              "name": "force"
            }
          ],
          "return_type": null,
          "lineno": 161,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {
                "short_help": "Copies files."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--force"
              ],
              "kwargs": {
                "is_flag": true,
                "help": "forcibly copy over an existing managed file"
              }
            },
            {
              "name": "click.argument",
              "args": [
                "src"
              ],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "dst"
              ],
              "kwargs": {}
            },
            {
              "name": "pass_repo",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.echo",
            "click.argument",
            "click.option",
            "cli.command",
            "click.Path"
          ],
          "docstring": "Copies one or multiple files to a new location.  This copies all\nfiles from SRC to DST.",
          "code": "def copy(repo, src, dst, force):\n    \"\"\"Copies one or multiple files to a new location.  This copies all\n    files from SRC to DST.\n    \"\"\"\n    for fn in src:\n        click.echo(f\"Copy from {fn} -> {dst}\")",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "home"
            }
          ],
          "return_type": null,
          "lineno": 9,
          "decorators": [],
          "is_async": false,
          "calls": [
            "home"
          ],
          "docstring": null,
          "code": "def __init__(self, home):\n        self.home = home\n        self.config = {}\n        self.verbose = False",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "set_config",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 14,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sys.stderr",
            "click.echo",
            "value"
          ],
          "docstring": null,
          "code": "def set_config(self, key, value):\n        self.config[key] = value\n        if self.verbose:\n            click.echo(f\"  config[{key}] = {value}\", file=sys.stderr)",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 19,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self):\n        return f\"<Repo {self.home}>\"",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "Repo",
          "methods": [
            "__init__",
            "set_config",
            "__repr__"
          ],
          "base_classes": [],
          "lineno": 8,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "os",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "posixpath",
          "alias": null,
          "lineno": 2,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 5,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "pass_repo",
          "assigned_to": "click.make_pass_decorator",
          "lineno": 23
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "Repo",
          "click.make_pass_decorator"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os",
          "sys"
        ],
        "third_party": {
          "other": [
            "posixpath",
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 167
    },
    "examples/termui/termui.py": {
      "filepath": "../click/examples/termui/termui.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "cli",
          "args": [],
          "return_type": null,
          "lineno": 9,
          "decorators": [
            {
              "name": "click.group",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.group"
          ],
          "docstring": "This script showcases different terminal UI helpers in Click.",
          "code": "def cli():\n    \"\"\"This script showcases different terminal UI helpers in Click.\"\"\"\n    pass",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "colordemo",
          "args": [],
          "return_type": null,
          "lineno": 15,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.style",
            "cli.command",
            "click.echo",
            "color"
          ],
          "docstring": "Demonstrates ANSI color support.",
          "code": "def colordemo():\n    \"\"\"Demonstrates ANSI color support.\"\"\"\n    for color in \"red\", \"green\", \"blue\":\n        click.echo(click.style(f\"I am colored {color}\", fg=color))\n        click.echo(click.style(f\"I am background colored {color}\", bg=color))",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "pager",
          "args": [],
          "return_type": null,
          "lineno": 23,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "unknown.join",
            "lines.append",
            "str",
            "lines",
            "click.style",
            "cli.command",
            "range",
            "click.echo_via_pager",
            "x"
          ],
          "docstring": "Demonstrates using the pager.",
          "code": "def pager():\n    \"\"\"Demonstrates using the pager.\"\"\"\n    lines = []\n    for x in range(200):\n        lines.append(f\"{click.style(str(x), fg='green')}. Hello World!\")\n    click.echo_via_pager(\"\\n\".join(lines))",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "progress",
          "args": [
            {
              "name": "count"
            }
          ],
          "return_type": null,
          "lineno": 38,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--count"
              ],
              "kwargs": {
                "default": 8000,
                "help": "The number of items to process."
              }
            }
          ],
          "is_async": false,
          "calls": [
            "show_item",
            "int",
            "math.exp",
            "random.random",
            "count",
            "item",
            "bar.update",
            "items",
            "click.IntRange",
            "sum",
            "filter",
            "time.sleep",
            "click.option",
            "process_slowly",
            "steps",
            "range",
            "click.progressbar",
            "click.style",
            "cli.command"
          ],
          "docstring": "Demonstrates the progress bar.",
          "code": "def progress(count):\n    \"\"\"Demonstrates the progress bar.\"\"\"\n    items = range(count)\n\n    def process_slowly(item):\n        time.sleep(0.002 * random.random())\n\n    def filter(items):\n        for item in items:\n            if random.random() > 0.3:\n                yield item\n\n    with click.progressbar(\n        items, label=\"Processing accounts\", fill_char=click.style(\"#\", fg=\"green\")\n    ) as bar:\n        for item in bar:\n            process_slowly(item)\n\n    def show_item(item):\n        if item is not None:\n            return f\"Item #{item}\"\n\n    with click.progressbar(\n        filter(items),\n        label=\"Committing transaction\",\n        fill_char=click.style(\"#\", fg=\"yellow\"),\n        item_show_func=show_item,\n    ) as bar:\n        for item in bar:\n            process_slowly(item)\n\n    with click.progressbar(\n        length=count,\n        label=\"Counting\",\n        bar_template=\"%(label)s  %(bar)s | %(info)s\",\n        fill_char=click.style(\"\u2588\", fg=\"cyan\"),\n        empty_char=\" \",\n    ) as bar:\n        for item in bar:\n            process_slowly(item)\n\n    with click.progressbar(\n        length=count,\n        width=0,\n        show_percent=False,\n        show_eta=False,\n        fill_char=click.style(\"#\", fg=\"magenta\"),\n    ) as bar:\n        for item in bar:\n            process_slowly(item)\n\n    # 'Non-linear progress bar'\n    steps = [math.exp(x * 1.0 / 20) - 1 for x in range(20)]\n    count = int(sum(steps))\n    with click.progressbar(\n        length=count,\n        show_percent=False,\n        label=\"Slowing progress bar\",\n        fill_char=click.style(\"\u2588\", fg=\"green\"),\n    ) as bar:\n        for item in steps:\n            time.sleep(item)\n            bar.update(item)",
          "line_count": 63,
          "needs_llm_summary": true
        },
        {
          "name": "open",
          "args": [
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 105,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "url"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "url",
            "click.launch",
            "cli.command",
            "click.argument"
          ],
          "docstring": "Opens a file or URL In the default application.",
          "code": "def open(url):\n    \"\"\"Opens a file or URL In the default application.\"\"\"\n    click.launch(url)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "locate",
          "args": [
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 112,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.argument",
              "args": [
                "url"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "url",
            "click.launch",
            "cli.command",
            "click.argument"
          ],
          "docstring": "Opens a file or URL In the default application.",
          "code": "def locate(url):\n    \"\"\"Opens a file or URL In the default application.\"\"\"\n    click.launch(url, locate=True)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "edit",
          "args": [],
          "return_type": null,
          "lineno": 118,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "MARKER",
            "click.echo",
            "click.edit",
            "message.split",
            "cli.command",
            "unknown.rstrip"
          ],
          "docstring": "Opens an editor with some text in it.",
          "code": "def edit():\n    \"\"\"Opens an editor with some text in it.\"\"\"\n    MARKER = \"# Everything below is ignored\\n\"\n    message = click.edit(f\"\\n\\n{MARKER}\")\n    if message is not None:\n        msg = message.split(MARKER, 1)[0].rstrip(\"\\n\")\n        if not msg:\n            click.echo(\"Empty message!\")\n        else:\n            click.echo(f\"Message:\\n{msg}\")\n    else:\n        click.echo(\"You did not enter anything!\")",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "clear",
          "args": [],
          "return_type": null,
          "lineno": 133,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.clear"
          ],
          "docstring": "Clears the entire screen.",
          "code": "def clear():\n    \"\"\"Clears the entire screen.\"\"\"\n    click.clear()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "pause",
          "args": [],
          "return_type": null,
          "lineno": 139,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.pause"
          ],
          "docstring": "Waits for the user to press a button.",
          "code": "def pause():\n    \"\"\"Waits for the user to press a button.\"\"\"\n    click.pause()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "menu",
          "args": [],
          "return_type": null,
          "lineno": 145,
          "decorators": [
            {
              "name": "cli.command",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "cli.command",
            "click.getchar",
            "click.echo"
          ],
          "docstring": "Shows a simple menu.",
          "code": "def menu():\n    \"\"\"Shows a simple menu.\"\"\"\n    menu = \"main\"\n    while True:\n        if menu == \"main\":\n            click.echo(\"Main menu:\")\n            click.echo(\"  d: debug menu\")\n            click.echo(\"  q: quit\")\n            char = click.getchar()\n            if char == \"d\":\n                menu = \"debug\"\n            elif char == \"q\":\n                menu = \"quit\"\n            else:\n                click.echo(\"Invalid input\")\n        elif menu == \"debug\":\n            click.echo(\"Debug menu\")\n            click.echo(\"  b: back\")\n            char = click.getchar()\n            if char == \"b\":\n                menu = \"main\"\n            else:\n                click.echo(\"Invalid input\")\n        elif menu == \"quit\":\n            return",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "process_slowly",
          "args": [
            {
              "name": "item"
            }
          ],
          "return_type": null,
          "lineno": 42,
          "decorators": [],
          "is_async": false,
          "calls": [
            "random.random",
            "time.sleep"
          ],
          "docstring": null,
          "code": "def process_slowly(item):\n        time.sleep(0.002 * random.random())",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "filter",
          "args": [
            {
              "name": "items"
            }
          ],
          "return_type": null,
          "lineno": 45,
          "decorators": [],
          "is_async": false,
          "calls": [
            "random.random"
          ],
          "docstring": null,
          "code": "def filter(items):\n        for item in items:\n            if random.random() > 0.3:\n                yield item",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "show_item",
          "args": [
            {
              "name": "item"
            }
          ],
          "return_type": null,
          "lineno": 56,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def show_item(item):\n        if item is not None:\n            return f\"Item #{item}\"",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "math",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "random",
          "alias": null,
          "lineno": 2,
          "type": "import"
        },
        {
          "module": "time",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 5,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "math",
          "random",
          "time"
        ],
        "third_party": {
          "other": [
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 170
    },
    "examples/validation/validation.py": {
      "filepath": "../click/examples/validation/validation.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "validate_count",
          "args": [
            {
              "name": "ctx"
            },
            {
              "name": "param"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 6,
          "decorators": [],
          "is_async": false,
          "calls": [
            "click.BadParameter"
          ],
          "docstring": null,
          "code": "def validate_count(ctx, param, value):\n    if value < 0 or value % 2 != 0:\n        raise click.BadParameter(\"Should be a positive, even integer.\")\n    return value",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "cli",
          "args": [
            {
              "name": "count"
            },
            {
              "name": "foo"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 34,
          "decorators": [
            {
              "name": "click.command",
              "args": [],
              "kwargs": {}
            },
            {
              "name": "click.option",
              "args": [
                "--count"
              ],
              "kwargs": {
                "default": 2,
                "help": "A positive even number."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--foo"
              ],
              "kwargs": {
                "help": "A mysterious parameter."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--url"
              ],
              "kwargs": {
                "help": "A URL"
              }
            },
            {
              "name": "click.version_option",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "URL",
            "click.command",
            "click.echo",
            "validate_count",
            "click.option",
            "click.version_option",
            "click.BadParameter"
          ],
          "docstring": "Validation.\n\nThis example validates parameters in different ways.  It does it\nthrough callbacks, through a custom type as well as by validating\nmanually in the function.",
          "code": "def cli(count, foo, url):\n    \"\"\"Validation.\n\n    This example validates parameters in different ways.  It does it\n    through callbacks, through a custom type as well as by validating\n    manually in the function.\n    \"\"\"\n    if foo is not None and foo != \"wat\":\n        raise click.BadParameter(\n            'If a value is provided it needs to be the value \"wat\".',\n            param_hint=[\"--foo\"],\n        )\n    click.echo(f\"count: {count}\")\n    click.echo(f\"foo: {foo}\")\n    click.echo(f\"url: {url!r}\")",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value"
            },
            {
              "name": "param"
            },
            {
              "name": "ctx"
            }
          ],
          "return_type": null,
          "lineno": 15,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "urlparse.urlparse",
            "value",
            "param",
            "ctx",
            "isinstance",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(self, value, param, ctx):\n        if not isinstance(value, tuple):\n            value = urlparse.urlparse(value)\n            if value.scheme not in (\"http\", \"https\"):\n                self.fail(\n                    f\"invalid URL scheme ({value.scheme}). Only HTTP URLs are allowed\",\n                    param,\n                    ctx,\n                )\n        return value",
          "line_count": 10,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "URL",
          "methods": [
            "convert"
          ],
          "base_classes": [
            "click.ParamType"
          ],
          "lineno": 12,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "urllib",
          "name": "parse",
          "alias": "urlparse",
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 3,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "urllib",
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 49
    },
    "src/click/__init__.py": {
      "filepath": "../click/src/click/__init__.py",
      "module_docstring": "Click is a simple Python module inspired by the stdlib optparse to make\nwriting command line scripts fun. Unlike other modules, it's based\naround a simple API that does not come with too much magic and is\ncomposable.",
      "functions": [
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "object",
          "lineno": 74,
          "decorators": [],
          "is_async": false,
          "calls": [
            "AttributeError",
            "importlib.metadata.version",
            "warnings.warn",
            "name",
            "DeprecationWarning"
          ],
          "docstring": null,
          "code": "def __getattr__(name: str) -> object:\n    import warnings\n\n    if name == \"BaseCommand\":\n        from .core import _BaseCommand\n\n        warnings.warn(\n            \"'BaseCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 'Command' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _BaseCommand\n\n    if name == \"MultiCommand\":\n        from .core import _MultiCommand\n\n        warnings.warn(\n            \"'MultiCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 'Group' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _MultiCommand\n\n    if name == \"OptionParser\":\n        from .parser import _OptionParser\n\n        warnings.warn(\n            \"'OptionParser' is deprecated and will be removed in Click 9.0. The\"\n            \" old parser is available in 'optparse'.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _OptionParser\n\n    if name == \"__version__\":\n        import importlib.metadata\n        import warnings\n\n        warnings.warn(\n            \"The '__version__' attribute is deprecated and will be removed in\"\n            \" Click 9.1. Use feature detection or\"\n            \" 'importlib.metadata.version(\\\"click\\\")' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return importlib.metadata.version(\"click\")\n\n    raise AttributeError(name)",
          "line_count": 50,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Argument",
          "alias": "Argument",
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Command",
          "alias": "Command",
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "CommandCollection",
          "alias": "CommandCollection",
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Context",
          "alias": "Context",
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Group",
          "alias": "Group",
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Option",
          "alias": "Option",
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Parameter",
          "alias": "Parameter",
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "argument",
          "alias": "argument",
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "command",
          "alias": "command",
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "confirmation_option",
          "alias": "confirmation_option",
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "group",
          "alias": "group",
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "help_option",
          "alias": "help_option",
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "make_pass_decorator",
          "alias": "make_pass_decorator",
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "option",
          "alias": "option",
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "pass_context",
          "alias": "pass_context",
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "pass_obj",
          "alias": "pass_obj",
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "password_option",
          "alias": "password_option",
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "version_option",
          "alias": "version_option",
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "Abort",
          "alias": "Abort",
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "BadArgumentUsage",
          "alias": "BadArgumentUsage",
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "BadOptionUsage",
          "alias": "BadOptionUsage",
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "BadParameter",
          "alias": "BadParameter",
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ClickException",
          "alias": "ClickException",
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "FileError",
          "alias": "FileError",
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "MissingParameter",
          "alias": "MissingParameter",
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "NoSuchOption",
          "alias": "NoSuchOption",
          "lineno": 35,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "UsageError",
          "alias": "UsageError",
          "lineno": 36,
          "type": "from_import"
        },
        {
          "module": "formatting",
          "name": "HelpFormatter",
          "alias": "HelpFormatter",
          "lineno": 37,
          "type": "from_import"
        },
        {
          "module": "formatting",
          "name": "wrap_text",
          "alias": "wrap_text",
          "lineno": 38,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "get_current_context",
          "alias": "get_current_context",
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "clear",
          "alias": "clear",
          "lineno": 40,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "confirm",
          "alias": "confirm",
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "echo_via_pager",
          "alias": "echo_via_pager",
          "lineno": 42,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "edit",
          "alias": "edit",
          "lineno": 43,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "getchar",
          "alias": "getchar",
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "launch",
          "alias": "launch",
          "lineno": 45,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "pause",
          "alias": "pause",
          "lineno": 46,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "progressbar",
          "alias": "progressbar",
          "lineno": 47,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "prompt",
          "alias": "prompt",
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "secho",
          "alias": "secho",
          "lineno": 49,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "style",
          "alias": "style",
          "lineno": 50,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "unstyle",
          "alias": "unstyle",
          "lineno": 51,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "BOOL",
          "alias": "BOOL",
          "lineno": 52,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "Choice",
          "alias": "Choice",
          "lineno": 53,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "DateTime",
          "alias": "DateTime",
          "lineno": 54,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "File",
          "alias": "File",
          "lineno": 55,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "FLOAT",
          "alias": "FLOAT",
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "FloatRange",
          "alias": "FloatRange",
          "lineno": 57,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "INT",
          "alias": "INT",
          "lineno": 58,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "IntRange",
          "alias": "IntRange",
          "lineno": 59,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "ParamType",
          "alias": "ParamType",
          "lineno": 60,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "Path",
          "alias": "Path",
          "lineno": 61,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "STRING",
          "alias": "STRING",
          "lineno": 62,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "Tuple",
          "alias": "Tuple",
          "lineno": 63,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "UNPROCESSED",
          "alias": "UNPROCESSED",
          "lineno": 64,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "UUID",
          "alias": "UUID",
          "lineno": 65,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "echo",
          "alias": "echo",
          "lineno": 66,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "format_filename",
          "alias": "format_filename",
          "lineno": 67,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_app_dir",
          "alias": "get_app_dir",
          "lineno": 68,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_binary_stream",
          "alias": "get_binary_stream",
          "lineno": 69,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_text_stream",
          "alias": "get_text_stream",
          "lineno": 70,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "open_file",
          "alias": "open_file",
          "lineno": 71,
          "type": "from_import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 75,
          "type": "import"
        },
        {
          "module": "core",
          "name": "_BaseCommand",
          "alias": null,
          "lineno": 78,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "_MultiCommand",
          "alias": null,
          "lineno": 89,
          "type": "from_import"
        },
        {
          "module": "parser",
          "name": "_OptionParser",
          "alias": null,
          "lineno": 100,
          "type": "from_import"
        },
        {
          "module": "importlib.metadata",
          "alias": null,
          "lineno": 111,
          "type": "import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 112,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "warnings"
        ],
        "third_party": {
          "other": [
            "__future__",
            "core",
            "decorators",
            "exceptions",
            "formatting",
            "globals",
            "termui",
            "types",
            "utils",
            "parser",
            "importlib"
          ]
        },
        "tech_stack": []
      },
      "line_count": 124
    },
    "src/click/_compat.py": {
      "filepath": "../click/src/click/_compat.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_make_text_stream",
          "args": [
            {
              "name": "stream",
              "type": "t.BinaryIO"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "force_readable",
              "type": "bool"
            },
            {
              "name": "force_writable",
              "type": "bool"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 19,
          "decorators": [],
          "is_async": false,
          "calls": [
            "force_writable",
            "_NonClosingTextIOWrapper",
            "errors",
            "force_readable",
            "get_best_encoding",
            "stream",
            "encoding"
          ],
          "docstring": null,
          "code": "def _make_text_stream(\n    stream: t.BinaryIO,\n    encoding: str | None,\n    errors: str | None,\n    force_readable: bool = False,\n    force_writable: bool = False,\n) -> t.TextIO:\n    if encoding is None:\n        encoding = get_best_encoding(stream)\n    if errors is None:\n        errors = \"replace\"\n    return _NonClosingTextIOWrapper(\n        stream,\n        encoding,\n        errors,\n        line_buffering=True,\n        force_readable=force_readable,\n        force_writable=force_writable,\n    )",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "is_ascii_encoding",
          "args": [
            {
              "name": "encoding",
              "type": "str"
            }
          ],
          "return_type": "bool",
          "lineno": 40,
          "decorators": [],
          "is_async": false,
          "calls": [
            "codecs.lookup",
            "encoding"
          ],
          "docstring": "Checks if a given encoding is ascii.",
          "code": "def is_ascii_encoding(encoding: str) -> bool:\n    \"\"\"Checks if a given encoding is ascii.\"\"\"\n    try:\n        return codecs.lookup(encoding).name == \"ascii\"\n    except LookupError:\n        return False",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "get_best_encoding",
          "args": [
            {
              "name": "stream",
              "type": "t.IO[t.Any]"
            }
          ],
          "return_type": "str",
          "lineno": 48,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sys.getdefaultencoding",
            "rv",
            "stream",
            "is_ascii_encoding",
            "getattr"
          ],
          "docstring": "Returns the default stream encoding if not found.",
          "code": "def get_best_encoding(stream: t.IO[t.Any]) -> str:\n    \"\"\"Returns the default stream encoding if not found.\"\"\"\n    rv = getattr(stream, \"encoding\", None) or sys.getdefaultencoding()\n    if is_ascii_encoding(rv):\n        return \"utf-8\"\n    return rv",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "_is_binary_reader",
          "args": [
            {
              "name": "stream",
              "type": "t.IO[t.Any]"
            },
            {
              "name": "default",
              "type": "bool"
            }
          ],
          "return_type": "bool",
          "lineno": 151,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream.read",
            "bytes",
            "isinstance"
          ],
          "docstring": null,
          "code": "def _is_binary_reader(stream: t.IO[t.Any], default: bool = False) -> bool:\n    try:\n        return isinstance(stream.read(0), bytes)\n    except Exception:\n        return default",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "_is_binary_writer",
          "args": [
            {
              "name": "stream",
              "type": "t.IO[t.Any]"
            },
            {
              "name": "default",
              "type": "bool"
            }
          ],
          "return_type": "bool",
          "lineno": 160,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream.write"
          ],
          "docstring": null,
          "code": "def _is_binary_writer(stream: t.IO[t.Any], default: bool = False) -> bool:\n    try:\n        stream.write(b\"\")\n    except Exception:\n        try:\n            stream.write(\"\")\n            return False\n        except Exception:\n            pass\n        return default\n    return True",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "_find_binary_reader",
          "args": [
            {
              "name": "stream",
              "type": "t.IO[t.Any]"
            }
          ],
          "return_type": "Any",
          "lineno": 173,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_is_binary_reader",
            "t.cast",
            "buf",
            "stream",
            "getattr",
            "t.BinaryIO"
          ],
          "docstring": null,
          "code": "def _find_binary_reader(stream: t.IO[t.Any]) -> t.BinaryIO | None:\n    # We need to figure out if the given stream is already binary.\n    # This can happen because the official docs recommend detaching\n    # the streams to get binary streams.  Some code might do this, so\n    # we need to deal with this case explicitly.\n    if _is_binary_reader(stream, False):\n        return t.cast(t.BinaryIO, stream)\n\n    buf = getattr(stream, \"buffer\", None)\n\n    # Same situation here; this time we assume that the buffer is\n    # actually binary in case it's closed.\n    if buf is not None and _is_binary_reader(buf, True):\n        return t.cast(t.BinaryIO, buf)\n\n    return None",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "_find_binary_writer",
          "args": [
            {
              "name": "stream",
              "type": "t.IO[t.Any]"
            }
          ],
          "return_type": "Any",
          "lineno": 191,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_is_binary_writer",
            "t.cast",
            "buf",
            "stream",
            "getattr",
            "t.BinaryIO"
          ],
          "docstring": null,
          "code": "def _find_binary_writer(stream: t.IO[t.Any]) -> t.BinaryIO | None:\n    # We need to figure out if the given stream is already binary.\n    # This can happen because the official docs recommend detaching\n    # the streams to get binary streams.  Some code might do this, so\n    # we need to deal with this case explicitly.\n    if _is_binary_writer(stream, False):\n        return t.cast(t.BinaryIO, stream)\n\n    buf = getattr(stream, \"buffer\", None)\n\n    # Same situation here; this time we assume that the buffer is\n    # actually binary in case it's closed.\n    if buf is not None and _is_binary_writer(buf, True):\n        return t.cast(t.BinaryIO, buf)\n\n    return None",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "_stream_is_misconfigured",
          "args": [
            {
              "name": "stream",
              "type": "t.TextIO"
            }
          ],
          "return_type": "bool",
          "lineno": 209,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "is_ascii_encoding",
            "getattr"
          ],
          "docstring": "A stream is misconfigured if its encoding is ASCII.",
          "code": "def _stream_is_misconfigured(stream: t.TextIO) -> bool:\n    \"\"\"A stream is misconfigured if its encoding is ASCII.\"\"\"\n    # If the stream does not have an encoding set, we assume it's set\n    # to ASCII.  This appears to happen in certain unittest\n    # environments.  It's not quite clear what the correct behavior is\n    # but this at least will force Click to recover somehow.\n    return is_ascii_encoding(getattr(stream, \"encoding\", None) or \"ascii\")",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_is_compat_stream_attr",
          "args": [
            {
              "name": "stream",
              "type": "t.TextIO"
            },
            {
              "name": "attr",
              "type": "str"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 218,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "attr",
            "getattr"
          ],
          "docstring": "A stream attribute is compatible if it is equal to the\ndesired value or the desired value is unset and the attribute\nhas a value.",
          "code": "def _is_compat_stream_attr(stream: t.TextIO, attr: str, value: str | None) -> bool:\n    \"\"\"A stream attribute is compatible if it is equal to the\n    desired value or the desired value is unset and the attribute\n    has a value.\n    \"\"\"\n    stream_value = getattr(stream, attr, None)\n    return stream_value == value or (value is None and stream_value is not None)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_is_compatible_text_stream",
          "args": [
            {
              "name": "stream",
              "type": "t.TextIO"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 227,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "errors",
            "_is_compat_stream_attr",
            "encoding"
          ],
          "docstring": "Check if a stream's encoding and errors attributes are\ncompatible with the desired values.",
          "code": "def _is_compatible_text_stream(\n    stream: t.TextIO, encoding: str | None, errors: str | None\n) -> bool:\n    \"\"\"Check if a stream's encoding and errors attributes are\n    compatible with the desired values.\n    \"\"\"\n    return _is_compat_stream_attr(\n        stream, \"encoding\", encoding\n    ) and _is_compat_stream_attr(stream, \"errors\", errors)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "_force_correct_text_stream",
          "args": [
            {
              "name": "text_stream",
              "type": "t.IO[t.Any]"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "is_binary",
              "type": "t.Callable[Any, bool]"
            },
            {
              "name": "find_binary",
              "type": "t.Callable[Any, Any]"
            },
            {
              "name": "force_readable",
              "type": "bool"
            },
            {
              "name": "force_writable",
              "type": "bool"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 238,
          "decorators": [],
          "is_async": false,
          "calls": [
            "binary_reader",
            "t.TextIO",
            "_make_text_stream",
            "force_writable",
            "find_binary",
            "_stream_is_misconfigured",
            "text_stream",
            "t.cast",
            "errors",
            "force_readable",
            "possible_binary_reader",
            "_is_compatible_text_stream",
            "encoding",
            "t.BinaryIO",
            "is_binary"
          ],
          "docstring": null,
          "code": "def _force_correct_text_stream(\n    text_stream: t.IO[t.Any],\n    encoding: str | None,\n    errors: str | None,\n    is_binary: t.Callable[[t.IO[t.Any], bool], bool],\n    find_binary: t.Callable[[t.IO[t.Any]], t.BinaryIO | None],\n    force_readable: bool = False,\n    force_writable: bool = False,\n) -> t.TextIO:\n    if is_binary(text_stream, False):\n        binary_reader = t.cast(t.BinaryIO, text_stream)\n    else:\n        text_stream = t.cast(t.TextIO, text_stream)\n        # If the stream looks compatible, and won't default to a\n        # misconfigured ascii encoding, return it as-is.\n        if _is_compatible_text_stream(text_stream, encoding, errors) and not (\n            encoding is None and _stream_is_misconfigured(text_stream)\n        ):\n            return text_stream\n\n        # Otherwise, get the underlying binary reader.\n        possible_binary_reader = find_binary(text_stream)\n\n        # If that's not possible, silently use the original reader\n        # and get mojibake instead of exceptions.\n        if possible_binary_reader is None:\n            return text_stream\n\n        binary_reader = possible_binary_reader\n\n    # Default errors to replace instead of strict in order to get\n    # something that works.\n    if errors is None:\n        errors = \"replace\"\n\n    # Wrap the binary stream in a text stream with the correct\n    # encoding parameters.\n    return _make_text_stream(\n        binary_reader,\n        encoding,\n        errors,\n        force_readable=force_readable,\n        force_writable=force_writable,\n    )",
          "line_count": 44,
          "needs_llm_summary": true
        },
        {
          "name": "_force_correct_text_reader",
          "args": [
            {
              "name": "text_reader",
              "type": "t.IO[t.Any]"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "force_readable",
              "type": "bool"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 284,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text_reader",
            "_is_binary_reader",
            "_force_correct_text_stream",
            "_find_binary_reader",
            "errors",
            "force_readable",
            "encoding"
          ],
          "docstring": null,
          "code": "def _force_correct_text_reader(\n    text_reader: t.IO[t.Any],\n    encoding: str | None,\n    errors: str | None,\n    force_readable: bool = False,\n) -> t.TextIO:\n    return _force_correct_text_stream(\n        text_reader,\n        encoding,\n        errors,\n        _is_binary_reader,\n        _find_binary_reader,\n        force_readable=force_readable,\n    )",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "_force_correct_text_writer",
          "args": [
            {
              "name": "text_writer",
              "type": "t.IO[t.Any]"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "force_writable",
              "type": "bool"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 300,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_is_binary_writer",
            "force_writable",
            "_force_correct_text_stream",
            "text_writer",
            "errors",
            "encoding",
            "_find_binary_writer"
          ],
          "docstring": null,
          "code": "def _force_correct_text_writer(\n    text_writer: t.IO[t.Any],\n    encoding: str | None,\n    errors: str | None,\n    force_writable: bool = False,\n) -> t.TextIO:\n    return _force_correct_text_stream(\n        text_writer,\n        encoding,\n        errors,\n        _is_binary_writer,\n        _find_binary_writer,\n        force_writable=force_writable,\n    )",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "get_binary_stdin",
          "args": [],
          "return_type": "t.BinaryIO",
          "lineno": 316,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_find_binary_reader",
            "RuntimeError",
            "sys.stdin"
          ],
          "docstring": null,
          "code": "def get_binary_stdin() -> t.BinaryIO:\n    reader = _find_binary_reader(sys.stdin)\n    if reader is None:\n        raise RuntimeError(\"Was not able to determine binary stream for sys.stdin.\")\n    return reader",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "get_binary_stdout",
          "args": [],
          "return_type": "t.BinaryIO",
          "lineno": 323,
          "decorators": [],
          "is_async": false,
          "calls": [
            "RuntimeError",
            "sys.stdout",
            "_find_binary_writer"
          ],
          "docstring": null,
          "code": "def get_binary_stdout() -> t.BinaryIO:\n    writer = _find_binary_writer(sys.stdout)\n    if writer is None:\n        raise RuntimeError(\"Was not able to determine binary stream for sys.stdout.\")\n    return writer",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "get_binary_stderr",
          "args": [],
          "return_type": "t.BinaryIO",
          "lineno": 330,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sys.stderr",
            "RuntimeError",
            "_find_binary_writer"
          ],
          "docstring": null,
          "code": "def get_binary_stderr() -> t.BinaryIO:\n    writer = _find_binary_writer(sys.stderr)\n    if writer is None:\n        raise RuntimeError(\"Was not able to determine binary stream for sys.stderr.\")\n    return writer",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "get_text_stdin",
          "args": [
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 337,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_get_windows_console_stream",
            "sys.stdin",
            "_force_correct_text_reader",
            "errors",
            "encoding"
          ],
          "docstring": null,
          "code": "def get_text_stdin(encoding: str | None = None, errors: str | None = None) -> t.TextIO:\n    rv = _get_windows_console_stream(sys.stdin, encoding, errors)\n    if rv is not None:\n        return rv\n    return _force_correct_text_reader(sys.stdin, encoding, errors, force_readable=True)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "get_text_stdout",
          "args": [
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 344,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_get_windows_console_stream",
            "sys.stdout",
            "_force_correct_text_writer",
            "errors",
            "encoding"
          ],
          "docstring": null,
          "code": "def get_text_stdout(encoding: str | None = None, errors: str | None = None) -> t.TextIO:\n    rv = _get_windows_console_stream(sys.stdout, encoding, errors)\n    if rv is not None:\n        return rv\n    return _force_correct_text_writer(sys.stdout, encoding, errors, force_writable=True)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "get_text_stderr",
          "args": [
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 351,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_get_windows_console_stream",
            "sys.stderr",
            "_force_correct_text_writer",
            "errors",
            "encoding"
          ],
          "docstring": null,
          "code": "def get_text_stderr(encoding: str | None = None, errors: str | None = None) -> t.TextIO:\n    rv = _get_windows_console_stream(sys.stderr, encoding, errors)\n    if rv is not None:\n        return rv\n    return _force_correct_text_writer(sys.stderr, encoding, errors, force_writable=True)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "_wrap_io_open",
          "args": [
            {
              "name": "file",
              "type": "Any"
            },
            {
              "name": "mode",
              "type": "str"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            }
          ],
          "return_type": "t.IO[t.Any]",
          "lineno": 358,
          "decorators": [],
          "is_async": false,
          "calls": [
            "mode",
            "file",
            "errors",
            "open",
            "encoding"
          ],
          "docstring": "Handles not passing ``encoding`` and ``errors`` in binary mode.",
          "code": "def _wrap_io_open(\n    file: str | os.PathLike[str] | int,\n    mode: str,\n    encoding: str | None,\n    errors: str | None,\n) -> t.IO[t.Any]:\n    \"\"\"Handles not passing ``encoding`` and ``errors`` in binary mode.\"\"\"\n    if \"b\" in mode:\n        return open(file, mode)\n\n    return open(file, mode, encoding=encoding, errors=errors)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "open_stream",
          "args": [
            {
              "name": "filename",
              "type": "Any"
            },
            {
              "name": "mode",
              "type": "str"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "atomic",
              "type": "bool"
            }
          ],
          "return_type": "tuple[t.IO[t.Any], bool]",
          "lineno": 371,
          "decorators": [],
          "is_async": false,
          "calls": [
            "random.randrange",
            "os.stat",
            "f",
            "os",
            "ValueError",
            "os.path.realpath",
            "encoding",
            "os.fspath",
            "filename",
            "os.fsdecode",
            "os.access",
            "get_binary_stdout",
            "os.chmod",
            "any",
            "os.path.dirname",
            "errors",
            "_wrap_io_open",
            "perm",
            "af",
            "tmp_filename",
            "get_binary_stdin",
            "os.path.isdir",
            "os.path.join",
            "getattr",
            "os.open",
            "_AtomicFile",
            "get_text_stdout",
            "get_text_stdin",
            "e.filename",
            "fd",
            "mode",
            "t.cast",
            "flags",
            "os.W_OK"
          ],
          "docstring": null,
          "code": "def open_stream(\n    filename: str | os.PathLike[str],\n    mode: str = \"r\",\n    encoding: str | None = None,\n    errors: str | None = \"strict\",\n    atomic: bool = False,\n) -> tuple[t.IO[t.Any], bool]:\n    binary = \"b\" in mode\n    filename = os.fspath(filename)\n\n    # Standard streams first. These are simple because they ignore the\n    # atomic flag. Use fsdecode to handle Path(\"-\").\n    if os.fsdecode(filename) == \"-\":\n        if any(m in mode for m in [\"w\", \"a\", \"x\"]):\n            if binary:\n                return get_binary_stdout(), False\n            return get_text_stdout(encoding=encoding, errors=errors), False\n        if binary:\n            return get_binary_stdin(), False\n        return get_text_stdin(encoding=encoding, errors=errors), False\n\n    # Non-atomic writes directly go out through the regular open functions.\n    if not atomic:\n        return _wrap_io_open(filename, mode, encoding, errors), True\n\n    # Some usability stuff for atomic writes\n    if \"a\" in mode:\n        raise ValueError(\n            \"Appending to an existing file is not supported, because that\"\n            \" would involve an expensive `copy`-operation to a temporary\"\n            \" file. Open the file in normal `w`-mode and copy explicitly\"\n            \" if that's what you're after.\"\n        )\n    if \"x\" in mode:\n        raise ValueError(\"Use the `overwrite`-parameter instead.\")\n    if \"w\" not in mode:\n        raise ValueError(\"Atomic writes only make sense with `w`-mode.\")\n\n    # Atomic writes are more complicated.  They work by opening a file\n    # as a proxy in the same folder and then using the fdopen\n    # functionality to wrap it in a Python file.  Then we wrap it in an\n    # atomic file that moves the file over on close.\n    import errno\n    import random\n\n    try:\n        perm: int | None = os.stat(filename).st_mode\n    except OSError:\n        perm = None\n\n    flags = os.O_RDWR | os.O_CREAT | os.O_EXCL\n\n    if binary:\n        flags |= getattr(os, \"O_BINARY\", 0)\n\n    while True:\n        tmp_filename = os.path.join(\n            os.path.dirname(filename),\n            f\".__atomic-write{random.randrange(1 << 32):08x}\",\n        )\n        try:\n            fd = os.open(tmp_filename, flags, 0o666 if perm is None else perm)\n            break\n        except OSError as e:\n            if e.errno == errno.EEXIST or (\n                os.name == \"nt\"\n                and e.errno == errno.EACCES\n                and os.path.isdir(e.filename)\n                and os.access(e.filename, os.W_OK)\n            ):\n                continue\n            raise\n\n    if perm is not None:\n        os.chmod(tmp_filename, perm)  # in case perm includes bits in umask\n\n    f = _wrap_io_open(fd, mode, encoding, errors)\n    af = _AtomicFile(f, tmp_filename, os.path.realpath(filename))\n    return t.cast(t.IO[t.Any], af), True",
          "line_count": 79,
          "needs_llm_summary": true
        },
        {
          "name": "strip_ansi",
          "args": [
            {
              "name": "value",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 488,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_ansi_re.sub",
            "value"
          ],
          "docstring": null,
          "code": "def strip_ansi(value: str) -> str:\n    return _ansi_re.sub(\"\", value)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_is_jupyter_kernel_output",
          "args": [
            {
              "name": "stream",
              "type": "t.IO[t.Any]"
            }
          ],
          "return_type": "bool",
          "lineno": 492,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "isinstance",
            "stream.__class__.__module__.startswith",
            "stream._stream"
          ],
          "docstring": null,
          "code": "def _is_jupyter_kernel_output(stream: t.IO[t.Any]) -> bool:\n    while isinstance(stream, (_FixupStream, _NonClosingTextIOWrapper)):\n        stream = stream._stream\n\n    return stream.__class__.__module__.startswith(\"ipykernel.\")",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "should_strip_ansi",
          "args": [
            {
              "name": "stream",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 499,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "isatty",
            "sys.stdin",
            "_is_jupyter_kernel_output"
          ],
          "docstring": null,
          "code": "def should_strip_ansi(\n    stream: t.IO[t.Any] | None = None, color: bool | None = None\n) -> bool:\n    if color is None:\n        if stream is None:\n            stream = sys.stdin\n        return not isatty(stream) and not _is_jupyter_kernel_output(stream)\n    return not color",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "term_len",
          "args": [
            {
              "name": "x",
              "type": "str"
            }
          ],
          "return_type": "int",
          "lineno": 568,
          "decorators": [],
          "is_async": false,
          "calls": [
            "strip_ansi",
            "len",
            "x"
          ],
          "docstring": null,
          "code": "def term_len(x: str) -> int:\n    return len(strip_ansi(x))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "isatty",
          "args": [
            {
              "name": "stream",
              "type": "t.IO[t.Any]"
            }
          ],
          "return_type": "bool",
          "lineno": 572,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream.isatty"
          ],
          "docstring": null,
          "code": "def isatty(stream: t.IO[t.Any]) -> bool:\n    try:\n        return stream.isatty()\n    except Exception:\n        return False",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "_make_cached_stream_func",
          "args": [
            {
              "name": "src_func",
              "type": "t.Callable[Any, Any]"
            },
            {
              "name": "wrapper_func",
              "type": "t.Callable[Any, t.TextIO]"
            }
          ],
          "return_type": "t.Callable[Any, Any]",
          "lineno": 579,
          "decorators": [],
          "is_async": false,
          "calls": [
            "WeakKeyDictionary",
            "cache.get",
            "rv",
            "src_func",
            "wrapper_func",
            "stream"
          ],
          "docstring": null,
          "code": "def _make_cached_stream_func(\n    src_func: t.Callable[[], t.TextIO | None],\n    wrapper_func: t.Callable[[], t.TextIO],\n) -> t.Callable[[], t.TextIO | None]:\n    cache: cabc.MutableMapping[t.TextIO, t.TextIO] = WeakKeyDictionary()\n\n    def func() -> t.TextIO | None:\n        stream = src_func()\n\n        if stream is None:\n            return None\n\n        try:\n            rv = cache.get(stream)\n        except Exception:\n            rv = None\n        if rv is not None:\n            return rv\n        rv = wrapper_func()\n        try:\n            cache[stream] = rv\n        except Exception:\n            pass\n        return rv\n\n    return func",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "stream",
              "type": "t.BinaryIO"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "force_readable",
              "type": "bool"
            },
            {
              "name": "force_writable",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 57,
          "decorators": [],
          "is_async": false,
          "calls": [
            "force_writable",
            "super",
            "unknown.__init__",
            "t.cast",
            "errors",
            "force_readable",
            "stream",
            "extra",
            "_FixupStream",
            "encoding",
            "t.BinaryIO"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        stream: t.BinaryIO,\n        encoding: str | None,\n        errors: str | None,\n        force_readable: bool = False,\n        force_writable: bool = False,\n        **extra: t.Any,\n    ) -> None:\n        self._stream = stream = t.cast(\n            t.BinaryIO, _FixupStream(stream, force_readable, force_writable)\n        )\n        super().__init__(stream, encoding, errors, **extra)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "__del__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 71,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.detach"
          ],
          "docstring": null,
          "code": "def __del__(self) -> None:\n        try:\n            self.detach()\n        except Exception:\n            pass",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "isatty",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 77,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._stream.isatty"
          ],
          "docstring": null,
          "code": "def isatty(self) -> bool:\n        # https://bitbucket.org/pypy/pypy/issue/1803\n        return self._stream.isatty()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "stream",
              "type": "t.BinaryIO"
            },
            {
              "name": "force_readable",
              "type": "bool"
            },
            {
              "name": "force_writable",
              "type": "bool"
            }
          ],
          "return_type": null,
          "lineno": 92,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "force_readable",
            "force_writable"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        stream: t.BinaryIO,\n        force_readable: bool = False,\n        force_writable: bool = False,\n    ):\n        self._stream = stream\n        self._force_readable = force_readable\n        self._force_writable = force_writable",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 102,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._stream",
            "name",
            "getattr"
          ],
          "docstring": null,
          "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._stream, name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "read1",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "size",
              "type": "int"
            }
          ],
          "return_type": "bytes",
          "lineno": 105,
          "decorators": [],
          "is_async": false,
          "calls": [
            "size",
            "bytes",
            "f",
            "t.cast",
            "self._stream",
            "self._stream.read",
            "getattr"
          ],
          "docstring": null,
          "code": "def read1(self, size: int) -> bytes:\n        f = getattr(self._stream, \"read1\", None)\n\n        if f is not None:\n            return t.cast(bytes, f(size))\n\n        return self._stream.read(size)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "readable",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 113,
          "decorators": [],
          "is_async": false,
          "calls": [
            "t.cast",
            "self._stream",
            "self._stream.read",
            "bool",
            "x",
            "getattr"
          ],
          "docstring": null,
          "code": "def readable(self) -> bool:\n        if self._force_readable:\n            return True\n        x = getattr(self._stream, \"readable\", None)\n        if x is not None:\n            return t.cast(bool, x())\n        try:\n            self._stream.read(0)\n        except Exception:\n            return False\n        return True",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "writable",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 125,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._stream.write",
            "t.cast",
            "self._stream",
            "bool",
            "x",
            "getattr"
          ],
          "docstring": null,
          "code": "def writable(self) -> bool:\n        if self._force_writable:\n            return True\n        x = getattr(self._stream, \"writable\", None)\n        if x is not None:\n            return t.cast(bool, x())\n        try:\n            self._stream.write(b\"\")\n        except Exception:\n            try:\n                self._stream.write(b\"\")\n            except Exception:\n                return False\n        return True",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "seekable",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 140,
          "decorators": [],
          "is_async": false,
          "calls": [
            "t.cast",
            "self._stream.tell",
            "self._stream",
            "bool",
            "self._stream.seek",
            "x",
            "getattr"
          ],
          "docstring": null,
          "code": "def seekable(self) -> bool:\n        x = getattr(self._stream, \"seekable\", None)\n        if x is not None:\n            return t.cast(bool, x())\n        try:\n            self._stream.seek(self._stream.tell())\n        except Exception:\n            return False\n        return True",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "t.IO[t.Any]"
            },
            {
              "name": "tmp_filename",
              "type": "str"
            },
            {
              "name": "real_filename",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 453,
          "decorators": [],
          "is_async": false,
          "calls": [
            "real_filename",
            "f",
            "tmp_filename"
          ],
          "docstring": null,
          "code": "def __init__(self, f: t.IO[t.Any], tmp_filename: str, real_filename: str) -> None:\n        self._f = f\n        self._tmp_filename = tmp_filename\n        self._real_filename = real_filename\n        self.closed = False",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "name",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 460,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def name(self) -> str:\n        return self._real_filename",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "close",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "delete",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 463,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.replace",
            "self._real_filename",
            "self._f.close",
            "self._tmp_filename"
          ],
          "docstring": null,
          "code": "def close(self, delete: bool = False) -> None:\n        if self.closed:\n            return\n        self._f.close()\n        os.replace(self._tmp_filename, self._real_filename)\n        self.closed = True",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 470,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "self._f",
            "getattr"
          ],
          "docstring": null,
          "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._f, name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "_AtomicFile",
          "lineno": 473,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __enter__(self) -> _AtomicFile:\n        return self",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc_type",
              "type": "Any"
            },
            {
              "name": "exc_value",
              "type": "Any"
            },
            {
              "name": "tb",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 476,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.close"
          ],
          "docstring": null,
          "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.close(delete=exc_type is not None)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 484,
          "decorators": [],
          "is_async": false,
          "calls": [
            "repr",
            "self._f"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return repr(self._f)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_get_argv_encoding",
          "args": [],
          "return_type": "str",
          "lineno": 515,
          "decorators": [],
          "is_async": false,
          "calls": [
            "locale.getpreferredencoding"
          ],
          "docstring": null,
          "code": "def _get_argv_encoding() -> str:\n        import locale\n\n        return locale.getpreferredencoding()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "auto_wrap_for_ansi",
          "args": [
            {
              "name": "stream",
              "type": "t.TextIO"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 522,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ansi_wrapper.stream",
            "colorama.AnsiToWin32",
            "t.TextIO",
            "s",
            "ansi_wrapper.reset_all",
            "strip",
            "rv",
            "t.cast",
            "_write",
            "should_strip_ansi",
            "_safe_write",
            "color",
            "rv.write",
            "_ansi_stream_wrappers.get",
            "stream"
          ],
          "docstring": "Support ANSI color and style codes on Windows by wrapping a\nstream with colorama.",
          "code": "def auto_wrap_for_ansi(stream: t.TextIO, color: bool | None = None) -> t.TextIO:\n        \"\"\"Support ANSI color and style codes on Windows by wrapping a\n        stream with colorama.\n        \"\"\"\n        try:\n            cached = _ansi_stream_wrappers.get(stream)\n        except Exception:\n            cached = None\n\n        if cached is not None:\n            return cached\n\n        import colorama\n\n        strip = should_strip_ansi(stream, color)\n        ansi_wrapper = colorama.AnsiToWin32(stream, strip=strip)\n        rv = t.cast(t.TextIO, ansi_wrapper.stream)\n        _write = rv.write\n\n        def _safe_write(s: str) -> int:\n            try:\n                return _write(s)\n            except BaseException:\n                ansi_wrapper.reset_all()\n                raise\n\n        rv.write = _safe_write  # type: ignore[method-assign]\n\n        try:\n            _ansi_stream_wrappers[stream] = rv\n        except Exception:\n            pass\n\n        return rv",
          "line_count": 34,
          "needs_llm_summary": true
        },
        {
          "name": "_get_argv_encoding",
          "args": [],
          "return_type": "str",
          "lineno": 559,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sys.getfilesystemencoding",
            "sys.stdin",
            "getattr"
          ],
          "docstring": null,
          "code": "def _get_argv_encoding() -> str:\n        return getattr(sys.stdin, \"encoding\", None) or sys.getfilesystemencoding()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_get_windows_console_stream",
          "args": [
            {
              "name": "f",
              "type": "t.TextIO"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 562,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def _get_windows_console_stream(\n        f: t.TextIO, encoding: str | None, errors: str | None\n    ) -> t.TextIO | None:\n        return None",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "func",
          "args": [],
          "return_type": "Any",
          "lineno": 585,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cache.get",
            "rv",
            "src_func",
            "wrapper_func",
            "stream"
          ],
          "docstring": null,
          "code": "def func() -> t.TextIO | None:\n        stream = src_func()\n\n        if stream is None:\n            return None\n\n        try:\n            rv = cache.get(stream)\n        except Exception:\n            rv = None\n        if rv is not None:\n            return rv\n        rv = wrapper_func()\n        try:\n            cache[stream] = rv\n        except Exception:\n            pass\n        return rv",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "_safe_write",
          "args": [
            {
              "name": "s",
              "type": "str"
            }
          ],
          "return_type": "int",
          "lineno": 541,
          "decorators": [],
          "is_async": false,
          "calls": [
            "s",
            "ansi_wrapper.reset_all",
            "_write"
          ],
          "docstring": null,
          "code": "def _safe_write(s: str) -> int:\n            try:\n                return _write(s)\n            except BaseException:\n                ansi_wrapper.reset_all()\n                raise",
          "line_count": 6,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "_NonClosingTextIOWrapper",
          "methods": [
            "__init__",
            "__del__",
            "isatty"
          ],
          "base_classes": [
            "io.TextIOWrapper"
          ],
          "lineno": 56,
          "docstring": null
        },
        {
          "name": "_FixupStream",
          "methods": [
            "__init__",
            "__getattr__",
            "read1",
            "readable",
            "writable",
            "seekable"
          ],
          "base_classes": [],
          "lineno": 82,
          "docstring": "The new io interface needs more from streams than streams\ntraditionally implement.  As such, this fix-up code is necessary in\nsome circumstances.\n\nThe forcing of readable and writable flags are there because some tools\nput badly patched objects on sys (one such offender are certain version\nof jupyter notebook)."
        },
        {
          "name": "_AtomicFile",
          "methods": [
            "__init__",
            "name",
            "close",
            "__getattr__",
            "__enter__",
            "__exit__",
            "__repr__"
          ],
          "base_classes": [],
          "lineno": 452,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "codecs",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "io",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "re",
          "alias": null,
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "types",
          "name": "TracebackType",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "weakref",
          "name": "WeakKeyDictionary",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "errno",
          "alias": null,
          "lineno": 413,
          "type": "import"
        },
        {
          "module": "random",
          "alias": null,
          "lineno": 414,
          "type": "import"
        },
        {
          "module": "_winconsole",
          "name": "_get_windows_console_stream",
          "alias": null,
          "lineno": 513,
          "type": "from_import"
        },
        {
          "module": "locale",
          "alias": null,
          "lineno": 516,
          "type": "import"
        },
        {
          "module": "colorama",
          "alias": null,
          "lineno": 534,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "CYGWIN",
          "assigned_to": "sys.platform.startswith",
          "lineno": 13
        },
        {
          "name": "WIN",
          "assigned_to": "sys.platform.startswith",
          "lineno": 14
        },
        {
          "name": "_ansi_re",
          "assigned_to": "re.compile",
          "lineno": 16
        },
        {
          "name": "_default_text_stdin",
          "assigned_to": "_make_cached_stream_func",
          "lineno": 607
        },
        {
          "name": "_default_text_stdout",
          "assigned_to": "_make_cached_stream_func",
          "lineno": 608
        },
        {
          "name": "_default_text_stderr",
          "assigned_to": "_make_cached_stream_func",
          "lineno": 609
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "colorama.AnsiToWin32",
          "t.TextIO",
          "strip",
          "get_text_stderr",
          "sys.getfilesystemencoding",
          "_make_cached_stream_func",
          "sys.stdin",
          "s",
          "ansi_wrapper.reset_all",
          "WeakKeyDictionary",
          "rv",
          "should_strip_ansi",
          "_safe_write",
          "_ansi_stream_wrappers.get",
          "stream",
          "_write",
          "getattr",
          "locale.getpreferredencoding",
          "color",
          "re.compile",
          "rv.write",
          "sys.platform.startswith",
          "get_text_stdout",
          "get_text_stdin",
          "t.cast",
          "ansi_wrapper.stream"
        ],
        "class_instantiations": [
          "WeakKeyDictionary"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "sys",
          "re",
          "typing",
          "random",
          "os",
          "collections",
          "io"
        ],
        "third_party": {
          "other": [
            "__future__",
            "codecs",
            "types",
            "weakref",
            "errno",
            "_winconsole",
            "locale",
            "colorama"
          ]
        },
        "tech_stack": []
      },
      "line_count": 623
    },
    "src/click/_termui_impl.py": {
      "filepath": "../click/src/click/_termui_impl.py",
      "module_docstring": "This module contains implementations for the termui module. To keep the\nimport time of Click down, some infrequently used functionality is\nplaced in this module and only imported as needed.",
      "functions": [
        {
          "name": "pager",
          "args": [
            {
              "name": "generator",
              "type": "cabc.Iterable[str]"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 369,
          "decorators": [],
          "is_async": false,
          "calls": [
            "pager_cmd_parts",
            "sys.stdin",
            "filename",
            "tempfile.mkstemp",
            "_tempfilepager",
            "_default_text_stdout",
            "_nullpager",
            "StringIO",
            "os.environ.get",
            "_pipepager",
            "os.unlink",
            "stdout",
            "os.close",
            "color",
            "sys.platform.startswith",
            "fd",
            "generator",
            "isatty",
            "shlex.split"
          ],
          "docstring": "Decide what method to use for paging through text.",
          "code": "def pager(generator: cabc.Iterable[str], color: bool | None = None) -> None:\n    \"\"\"Decide what method to use for paging through text.\"\"\"\n    stdout = _default_text_stdout()\n\n    # There are no standard streams attached to write to. For example,\n    # pythonw on Windows.\n    if stdout is None:\n        stdout = StringIO()\n\n    if not isatty(sys.stdin) or not isatty(stdout):\n        return _nullpager(stdout, generator, color)\n\n    # Split and normalize the pager command into parts.\n    pager_cmd_parts = shlex.split(os.environ.get(\"PAGER\", \"\"), posix=False)\n    if pager_cmd_parts:\n        if WIN:\n            if _tempfilepager(generator, pager_cmd_parts, color):\n                return\n        elif _pipepager(generator, pager_cmd_parts, color):\n            return\n\n    if os.environ.get(\"TERM\") in (\"dumb\", \"emacs\"):\n        return _nullpager(stdout, generator, color)\n    if (WIN or sys.platform.startswith(\"os2\")) and _tempfilepager(\n        generator, [\"more\"], color\n    ):\n        return\n    if _pipepager(generator, [\"less\"], color):\n        return\n\n    import tempfile\n\n    fd, filename = tempfile.mkstemp()\n    os.close(fd)\n    try:\n        if _pipepager(generator, [\"more\"], color):\n            return\n        return _nullpager(stdout, generator, color)\n    finally:\n        os.unlink(filename)",
          "line_count": 40,
          "needs_llm_summary": true
        },
        {
          "name": "_pipepager",
          "args": [
            {
              "name": "generator",
              "type": "cabc.Iterable[str]"
            },
            {
              "name": "cmd_parts",
              "type": "list[str]"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 411,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cmd_path.name",
            "cmd_filepath",
            "text",
            "Path",
            "cmd",
            "strip_ansi",
            "dict",
            "c.stdin.write",
            "c.terminate",
            "cmd_params",
            "os.environ.get",
            "str",
            "c.stdin.close",
            "shutil.which",
            "subprocess.PIPE",
            "unknown.join",
            "unknown.absolute",
            "c.wait",
            "os.environ",
            "subprocess.Popen",
            "env",
            "cmd_path"
          ],
          "docstring": "Page through text by feeding it to another program. Invoking a\npager through this might support colors.\n\nReturns `True` if the command was found, `False` otherwise and thus another\npager should be attempted.",
          "code": "def _pipepager(\n    generator: cabc.Iterable[str], cmd_parts: list[str], color: bool | None\n) -> bool:\n    \"\"\"Page through text by feeding it to another program. Invoking a\n    pager through this might support colors.\n\n    Returns `True` if the command was found, `False` otherwise and thus another\n    pager should be attempted.\n    \"\"\"\n    # Split the command into the invoked CLI and its parameters.\n    if not cmd_parts:\n        return False\n\n    import shutil\n\n    cmd = cmd_parts[0]\n    cmd_params = cmd_parts[1:]\n\n    cmd_filepath = shutil.which(cmd)\n    if not cmd_filepath:\n        return False\n\n    # Produces a normalized absolute path string.\n    # multi-call binaries such as busybox derive their identity from the symlink\n    # less -> busybox. resolve() causes them to misbehave. (eg. less becomes busybox)\n    cmd_path = Path(cmd_filepath).absolute()\n    cmd_name = cmd_path.name\n\n    import subprocess\n\n    # Make a local copy of the environment to not affect the global one.\n    env = dict(os.environ)\n\n    # If we're piping to less and the user hasn't decided on colors, we enable\n    # them by default we find the -R flag in the command line arguments.\n    if color is None and cmd_name == \"less\":\n        less_flags = f\"{os.environ.get('LESS', '')}{' '.join(cmd_params)}\"\n        if not less_flags:\n            env[\"LESS\"] = \"-R\"\n            color = True\n        elif \"r\" in less_flags or \"R\" in less_flags:\n            color = True\n\n    c = subprocess.Popen(\n        [str(cmd_path)] + cmd_params,\n        shell=False,\n        stdin=subprocess.PIPE,\n        env=env,\n        errors=\"replace\",\n        text=True,\n    )\n    assert c.stdin is not None\n    try:\n        for text in generator:\n            if not color:\n                text = strip_ansi(text)\n\n            c.stdin.write(text)\n    except BrokenPipeError:\n        # In case the pager exited unexpectedly, ignore the broken pipe error.\n        pass\n    except Exception as e:\n        # In case there is an exception we want to close the pager immediately\n        # and let the caller handle it.\n        # Otherwise the pager will keep running, and the user may not notice\n        # the error message, or worse yet it may leave the terminal in a broken state.\n        c.terminate()\n        raise e\n    finally:\n        # We must close stdin and wait for the pager to exit before we continue\n        try:\n            c.stdin.close()\n        # Close implies flush, so it might throw a BrokenPipeError if the pager\n        # process exited already.\n        except BrokenPipeError:\n            pass\n\n        # Less doesn't respect ^C, but catches it for its own UI purposes (aborting\n        # search or other commands inside less).\n        #\n        # That means when the user hits ^C, the parent process (click) terminates,\n        # but less is still alive, paging the output and messing up the terminal.\n        #\n        # If the user wants to make the pager exit on ^C, they should set\n        # `LESS='-K'`. It's not our decision to make.\n        while True:\n            try:\n                c.wait()\n            except KeyboardInterrupt:\n                pass\n            else:\n                break\n\n    return True",
          "line_count": 94,
          "needs_llm_summary": true
        },
        {
          "name": "_tempfilepager",
          "args": [
            {
              "name": "generator",
              "type": "cabc.Iterable[str]"
            },
            {
              "name": "cmd_parts",
              "type": "list[str]"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 507,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "cmd_filepath",
            "Path",
            "f.write",
            "get_best_encoding",
            "cmd",
            "encoding",
            "strip_ansi",
            "filename",
            "tempfile.mkstemp",
            "open_stream",
            "str",
            "os.unlink",
            "shutil.which",
            "os.close",
            "fd",
            "unknown.join",
            "generator",
            "sys.stdout",
            "text.encode",
            "unknown.absolute",
            "subprocess.call",
            "cmd_path"
          ],
          "docstring": "Page through text by invoking a program on a temporary file.\n\nReturns `True` if the command was found, `False` otherwise and thus another\npager should be attempted.",
          "code": "def _tempfilepager(\n    generator: cabc.Iterable[str], cmd_parts: list[str], color: bool | None\n) -> bool:\n    \"\"\"Page through text by invoking a program on a temporary file.\n\n    Returns `True` if the command was found, `False` otherwise and thus another\n    pager should be attempted.\n    \"\"\"\n    # Split the command into the invoked CLI and its parameters.\n    if not cmd_parts:\n        return False\n\n    import shutil\n\n    cmd = cmd_parts[0]\n\n    cmd_filepath = shutil.which(cmd)\n    if not cmd_filepath:\n        return False\n    # Produces a normalized absolute path string.\n    # multi-call binaries such as busybox derive their identity from the symlink\n    # less -> busybox. resolve() causes them to misbehave. (eg. less becomes busybox)\n    cmd_path = Path(cmd_filepath).absolute()\n\n    import subprocess\n    import tempfile\n\n    fd, filename = tempfile.mkstemp()\n    # TODO: This never terminates if the passed generator never terminates.\n    text = \"\".join(generator)\n    if not color:\n        text = strip_ansi(text)\n    encoding = get_best_encoding(sys.stdout)\n    with open_stream(filename, \"wb\")[0] as f:\n        f.write(text.encode(encoding))\n    try:\n        subprocess.call([str(cmd_path), filename])\n    except OSError:\n        # Command not found\n        pass\n    finally:\n        os.close(fd)\n        os.unlink(filename)\n\n    return True",
          "line_count": 45,
          "needs_llm_summary": true
        },
        {
          "name": "_nullpager",
          "args": [
            {
              "name": "stream",
              "type": "t.TextIO"
            },
            {
              "name": "generator",
              "type": "cabc.Iterable[str]"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 554,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "strip_ansi",
            "stream.write"
          ],
          "docstring": "Simply print unformatted text.  This is the ultimate fallback.",
          "code": "def _nullpager(\n    stream: t.TextIO, generator: cabc.Iterable[str], color: bool | None\n) -> None:\n    \"\"\"Simply print unformatted text.  This is the ultimate fallback.\"\"\"\n    for text in generator:\n        if not color:\n            text = strip_ansi(text)\n        stream.write(text)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "open_url",
          "args": [
            {
              "name": "url",
              "type": "str"
            },
            {
              "name": "wait",
              "type": "bool"
            },
            {
              "name": "locate",
              "type": "bool"
            }
          ],
          "return_type": "int",
          "lineno": 676,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.wait",
            "null",
            "unquote",
            "args.append",
            "url",
            "c.wait",
            "os.path.dirname",
            "webbrowser.open",
            "subprocess.call",
            "null.close",
            "args",
            "url.startswith",
            "open",
            "subprocess.Popen",
            "_unquote_file"
          ],
          "docstring": null,
          "code": "def open_url(url: str, wait: bool = False, locate: bool = False) -> int:\n    import subprocess\n\n    def _unquote_file(url: str) -> str:\n        from urllib.parse import unquote\n\n        if url.startswith(\"file://\"):\n            url = unquote(url[7:])\n\n        return url\n\n    if sys.platform == \"darwin\":\n        args = [\"open\"]\n        if wait:\n            args.append(\"-W\")\n        if locate:\n            args.append(\"-R\")\n        args.append(_unquote_file(url))\n        null = open(\"/dev/null\", \"w\")\n        try:\n            return subprocess.Popen(args, stderr=null).wait()\n        finally:\n            null.close()\n    elif WIN:\n        if locate:\n            url = _unquote_file(url)\n            args = [\"explorer\", f\"/select,{url}\"]\n        else:\n            args = [\"start\"]\n            if wait:\n                args.append(\"/WAIT\")\n            args.append(\"\")\n            args.append(url)\n        try:\n            return subprocess.call(args)\n        except OSError:\n            # Command not found\n            return 127\n    elif CYGWIN:\n        if locate:\n            url = _unquote_file(url)\n            args = [\"cygstart\", os.path.dirname(url)]\n        else:\n            args = [\"cygstart\"]\n            if wait:\n                args.append(\"-w\")\n            args.append(url)\n        try:\n            return subprocess.call(args)\n        except OSError:\n            # Command not found\n            return 127\n\n    try:\n        if locate:\n            url = os.path.dirname(_unquote_file(url)) or \".\"\n        else:\n            url = _unquote_file(url)\n        c = subprocess.Popen([\"xdg-open\", url])\n        if wait:\n            return c.wait()\n        return 0\n    except OSError:\n        if url.startswith((\"http://\", \"https://\")) and not locate and not wait:\n            import webbrowser\n\n            webbrowser.open(url)\n            return 0\n        return 1",
          "line_count": 69,
          "needs_llm_summary": true
        },
        {
          "name": "_translate_ch_to_exc",
          "args": [
            {
              "name": "ch",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 747,
          "decorators": [],
          "is_async": false,
          "calls": [
            "KeyboardInterrupt",
            "EOFError"
          ],
          "docstring": null,
          "code": "def _translate_ch_to_exc(ch: str) -> None:\n    if ch == \"\\x03\":\n        raise KeyboardInterrupt()\n\n    if ch == \"\\x04\" and not WIN:  # Unix-like, Ctrl+D\n        raise EOFError()\n\n    if ch == \"\\x1a\" and WIN:  # Windows, Ctrl+Z\n        raise EOFError()\n\n    return None",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "iterable",
              "type": "Any"
            },
            {
              "name": "length",
              "type": "Any"
            },
            {
              "name": "fill_char",
              "type": "str"
            },
            {
              "name": "empty_char",
              "type": "str"
            },
            {
              "name": "bar_template",
              "type": "str"
            },
            {
              "name": "info_sep",
              "type": "str"
            },
            {
              "name": "hidden",
              "type": "bool"
            },
            {
              "name": "show_eta",
              "type": "bool"
            },
            {
              "name": "show_percent",
              "type": "Any"
            },
            {
              "name": "show_pos",
              "type": "bool"
            },
            {
              "name": "item_show_func",
              "type": "Any"
            },
            {
              "name": "label",
              "type": "Any"
            },
            {
              "name": "file",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "Any"
            },
            {
              "name": "update_min_steps",
              "type": "int"
            },
            {
              "name": "width",
              "type": "int"
            }
          ],
          "return_type": "None",
          "lineno": 44,
          "decorators": [],
          "is_async": false,
          "calls": [
            "length_hint",
            "TypeError",
            "update_min_steps",
            "iter",
            "info_sep",
            "fill_char",
            "show_percent",
            "show_pos",
            "file",
            "length",
            "show_eta",
            "_default_text_stdout",
            "hidden",
            "item_show_func",
            "bar_template",
            "StringIO",
            "iterable",
            "color",
            "range",
            "time.time",
            "empty_char",
            "isatty",
            "t.cast",
            "self.file"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        iterable: cabc.Iterable[V] | None,\n        length: int | None = None,\n        fill_char: str = \"#\",\n        empty_char: str = \" \",\n        bar_template: str = \"%(bar)s\",\n        info_sep: str = \"  \",\n        hidden: bool = False,\n        show_eta: bool = True,\n        show_percent: bool | None = None,\n        show_pos: bool = False,\n        item_show_func: t.Callable[[V | None], str | None] | None = None,\n        label: str | None = None,\n        file: t.TextIO | None = None,\n        color: bool | None = None,\n        update_min_steps: int = 1,\n        width: int = 30,\n    ) -> None:\n        self.fill_char = fill_char\n        self.empty_char = empty_char\n        self.bar_template = bar_template\n        self.info_sep = info_sep\n        self.hidden = hidden\n        self.show_eta = show_eta\n        self.show_percent = show_percent\n        self.show_pos = show_pos\n        self.item_show_func = item_show_func\n        self.label: str = label or \"\"\n\n        if file is None:\n            file = _default_text_stdout()\n\n            # There are no standard streams attached to write to. For example,\n            # pythonw on Windows.\n            if file is None:\n                file = StringIO()\n\n        self.file = file\n        self.color = color\n        self.update_min_steps = update_min_steps\n        self._completed_intervals = 0\n        self.width: int = width\n        self.autowidth: bool = width == 0\n\n        if length is None:\n            from operator import length_hint\n\n            length = length_hint(iterable, -1)\n\n            if length == -1:\n                length = None\n        if iterable is None:\n            if length is None:\n                raise TypeError(\"iterable or length is required\")\n            iterable = t.cast(\"cabc.Iterable[V]\", range(length))\n        self.iter: cabc.Iterable[V] = iter(iterable)\n        self.length = length\n        self.pos: int = 0\n        self.avg: list[float] = []\n        self.last_eta: float\n        self.start: float\n        self.start = self.last_eta = time.time()\n        self.eta_known: bool = False\n        self.finished: bool = False\n        self.max_width: int | None = None\n        self.entered: bool = False\n        self.current_item: V | None = None\n        self._is_atty = isatty(self.file)\n        self._last_line: str | None = None",
          "line_count": 70,
          "needs_llm_summary": true
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "ProgressBar[V]",
          "lineno": 115,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.render_progress"
          ],
          "docstring": null,
          "code": "def __enter__(self) -> ProgressBar[V]:\n        self.entered = True\n        self.render_progress()\n        return self",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc_type",
              "type": "Any"
            },
            {
              "name": "exc_value",
              "type": "Any"
            },
            {
              "name": "tb",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 120,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.render_finish"
          ],
          "docstring": null,
          "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.render_finish()",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__iter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "cabc.Iterator[V]",
          "lineno": 128,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.generator",
            "RuntimeError",
            "self.render_progress"
          ],
          "docstring": null,
          "code": "def __iter__(self) -> cabc.Iterator[V]:\n        if not self.entered:\n            raise RuntimeError(\"You need to use progress bars in a with block.\")\n        self.render_progress()\n        return self.generator()",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__next__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "V",
          "lineno": 134,
          "decorators": [],
          "is_async": false,
          "calls": [
            "next",
            "iter",
            "self"
          ],
          "docstring": null,
          "code": "def __next__(self) -> V:\n        # Iteration is defined in terms of a generator function,\n        # returned by iter(self); use that to define next(). This works\n        # because `self.iter` is an iterable consumed by that generator,\n        # so it is re-entry safe. Calling `next(self.generator())`\n        # twice works and does \"what you want\".\n        return next(iter(self))",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "render_finish",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 142,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.file.write",
            "AFTER_BAR",
            "self.file.flush"
          ],
          "docstring": null,
          "code": "def render_finish(self) -> None:\n        if self.hidden or not self._is_atty:\n            return\n        self.file.write(AFTER_BAR)\n        self.file.flush()",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "pct",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "float",
          "lineno": 149,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "min",
            "float"
          ],
          "docstring": null,
          "code": "def pct(self) -> float:\n        if self.finished:\n            return 1.0\n        return min(self.pos / (float(self.length or 1) or 1), 1.0)",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "time_per_iteration",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "float",
          "lineno": 155,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.avg",
            "len",
            "float",
            "sum"
          ],
          "docstring": null,
          "code": "def time_per_iteration(self) -> float:\n        if not self.avg:\n            return 0.0\n        return sum(self.avg) / float(len(self.avg))",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "eta",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "float",
          "lineno": 161,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def eta(self) -> float:\n        if self.length is not None and not self.finished:\n            return self.time_per_iteration * (self.length - self.pos)\n        return 0.0",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "format_eta",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 166,
          "decorators": [],
          "is_async": false,
          "calls": [
            "int",
            "self.eta"
          ],
          "docstring": null,
          "code": "def format_eta(self) -> str:\n        if self.eta_known:\n            t = int(self.eta)\n            seconds = t % 60\n            t //= 60\n            minutes = t % 60\n            t //= 60\n            hours = t % 24\n            t //= 24\n            if t > 0:\n                return f\"{t}d {hours:02}:{minutes:02}:{seconds:02}\"\n            else:\n                return f\"{hours:02}:{minutes:02}:{seconds:02}\"\n        return \"\"",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "format_pos",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 181,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "self.pos"
          ],
          "docstring": null,
          "code": "def format_pos(self) -> str:\n        pos = str(self.pos)\n        if self.length is not None:\n            pos += f\"/{self.length}\"\n        return pos",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "format_pct",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 187,
          "decorators": [],
          "is_async": false,
          "calls": [
            "int"
          ],
          "docstring": null,
          "code": "def format_pct(self) -> str:\n        return f\"{int(self.pct * 100): 4}%\"[1:]",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "format_bar",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 190,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.join",
            "int",
            "list",
            "math.cos",
            "self.fill_char",
            "chars"
          ],
          "docstring": null,
          "code": "def format_bar(self) -> str:\n        if self.length is not None:\n            bar_length = int(self.pct * self.width)\n            bar = self.fill_char * bar_length\n            bar += self.empty_char * (self.width - bar_length)\n        elif self.finished:\n            bar = self.fill_char * self.width\n        else:\n            chars = list(self.empty_char * (self.width or 1))\n            if self.time_per_iteration != 0:\n                chars[\n                    int(\n                        (math.cos(self.pos * self.time_per_iteration) / 2.0 + 0.5)\n                        * self.width\n                    )\n                ] = self.fill_char\n            bar = \"\".join(chars)\n        return bar",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "format_progress_line",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 209,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.format_bar",
            "item_info",
            "self.info_sep.join",
            "self.format_eta",
            "self.format_pos",
            "self.item_show_func",
            "self.format_pct",
            "info_bits.append",
            "self.current_item",
            "self.show_percent",
            "info_bits",
            "unknown.rstrip"
          ],
          "docstring": null,
          "code": "def format_progress_line(self) -> str:\n        show_percent = self.show_percent\n\n        info_bits = []\n        if self.length is not None and show_percent is None:\n            show_percent = not self.show_pos\n\n        if self.show_pos:\n            info_bits.append(self.format_pos())\n        if show_percent:\n            info_bits.append(self.format_pct())\n        if self.show_eta and self.eta_known and not self.finished:\n            info_bits.append(self.format_eta())\n        if self.item_show_func is not None:\n            item_info = self.item_show_func(self.current_item)\n            if item_info is not None:\n                info_bits.append(item_info)\n\n        return (\n            self.bar_template\n            % {\n                \"label\": self.label,\n                \"bar\": self.format_bar(),\n                \"info\": self.info_sep.join(info_bits),\n            }\n        ).rstrip()",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "render_progress",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 236,
          "decorators": [],
          "is_async": false,
          "calls": [
            "BEFORE_BAR",
            "echo",
            "buf.append",
            "term_len",
            "self.format_progress_line",
            "unknown.join",
            "shutil.get_terminal_size",
            "max",
            "new_width",
            "line_len",
            "self.max_width",
            "self.file",
            "self.color",
            "self.file.flush",
            "self.width",
            "line",
            "buf",
            "self.label"
          ],
          "docstring": null,
          "code": "def render_progress(self) -> None:\n        if self.hidden:\n            return\n\n        if not self._is_atty:\n            # Only output the label once if the output is not a TTY.\n            if self._last_line != self.label:\n                self._last_line = self.label\n                echo(self.label, file=self.file, color=self.color)\n            return\n\n        buf = []\n        # Update width in case the terminal has been resized\n        if self.autowidth:\n            import shutil\n\n            old_width = self.width\n            self.width = 0\n            clutter_length = term_len(self.format_progress_line())\n            new_width = max(0, shutil.get_terminal_size().columns - clutter_length)\n            if new_width < old_width and self.max_width is not None:\n                buf.append(BEFORE_BAR)\n                buf.append(\" \" * self.max_width)\n                self.max_width = new_width\n            self.width = new_width\n\n        clear_width = self.width\n        if self.max_width is not None:\n            clear_width = self.max_width\n\n        buf.append(BEFORE_BAR)\n        line = self.format_progress_line()\n        line_len = term_len(line)\n        if self.max_width is None or self.max_width < line_len:\n            self.max_width = line_len\n\n        buf.append(line)\n        buf.append(\" \" * (clear_width - line_len))\n        line = \"\".join(buf)\n        # Render the line only if it changed.\n\n        if line != self._last_line:\n            self._last_line = line\n            echo(line, file=self.file, color=self.color, nl=False)\n            self.file.flush()",
          "line_count": 45,
          "needs_llm_summary": true
        },
        {
          "name": "make_step",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "n_steps",
              "type": "int"
            }
          ],
          "return_type": "None",
          "lineno": 282,
          "decorators": [],
          "is_async": false,
          "calls": [
            "time.time"
          ],
          "docstring": null,
          "code": "def make_step(self, n_steps: int) -> None:\n        self.pos += n_steps\n        if self.length is not None and self.pos >= self.length:\n            self.finished = True\n\n        if (time.time() - self.last_eta) < 1.0:\n            return\n\n        self.last_eta = time.time()\n\n        # self.avg is a rolling list of length <= 7 of steps where steps are\n        # defined as time elapsed divided by the total progress through\n        # self.length.\n        if self.pos:\n            step = (time.time() - self.start) / self.pos\n        else:\n            step = time.time() - self.start\n\n        self.avg = self.avg[-6:] + [step]\n\n        self.eta_known = self.length is not None",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "update",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "n_steps",
              "type": "int"
            },
            {
              "name": "current_item",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 304,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._completed_intervals",
            "self.make_step",
            "current_item",
            "self.render_progress"
          ],
          "docstring": "Update the progress bar by advancing a specified number of\nsteps, and optionally set the ``current_item`` for this new\nposition.\n\n:param n_steps: Number of steps to advance.\n:param current_item: Optional item to set as ``current_item``\n    for the updated position.\n\n.. versionchanged:: 8.0\n    Added the ``current_item`` optional parameter.\n\n.. versionchanged:: 8.0\n    Only render when the number of steps meets the\n    ``update_min_steps`` threshold.",
          "code": "def update(self, n_steps: int, current_item: V | None = None) -> None:\n        \"\"\"Update the progress bar by advancing a specified number of\n        steps, and optionally set the ``current_item`` for this new\n        position.\n\n        :param n_steps: Number of steps to advance.\n        :param current_item: Optional item to set as ``current_item``\n            for the updated position.\n\n        .. versionchanged:: 8.0\n            Added the ``current_item`` optional parameter.\n\n        .. versionchanged:: 8.0\n            Only render when the number of steps meets the\n            ``update_min_steps`` threshold.\n        \"\"\"\n        if current_item is not None:\n            self.current_item = current_item\n\n        self._completed_intervals += n_steps\n\n        if self._completed_intervals >= self.update_min_steps:\n            self.make_step(self._completed_intervals)\n            self.render_progress()\n            self._completed_intervals = 0",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "finish",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 330,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def finish(self) -> None:\n        self.eta_known = False\n        self.current_item = None\n        self.finished = True",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "generator",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "cabc.Iterator[V]",
          "lineno": 335,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.update",
            "rv",
            "RuntimeError",
            "self.render_progress",
            "self.finish"
          ],
          "docstring": "Return a generator which yields the items added to the bar\nduring construction, and updates the progress bar *after* the\nyielded block returns.",
          "code": "def generator(self) -> cabc.Iterator[V]:\n        \"\"\"Return a generator which yields the items added to the bar\n        during construction, and updates the progress bar *after* the\n        yielded block returns.\n        \"\"\"\n        # WARNING: the iterator interface for `ProgressBar` relies on\n        # this and only works because this is a simple generator which\n        # doesn't create or manage additional state. If this function\n        # changes, the impact should be evaluated both against\n        # `iter(bar)` and `next(bar)`. `next()` in particular may call\n        # `self.generator()` repeatedly, and this must remain safe in\n        # order for that interface to work.\n        if not self.entered:\n            raise RuntimeError(\"You need to use progress bars in a with block.\")\n\n        if not self._is_atty:\n            yield from self.iter\n        else:\n            for rv in self.iter:\n                self.current_item = rv\n\n                # This allows show_item_func to be updated before the\n                # item is processed. Only trigger at the beginning of\n                # the update interval.\n                if self._completed_intervals == 0:\n                    self.render_progress()\n\n                yield rv\n                self.update(1)\n\n            self.finish()\n            self.render_progress()",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "editor",
              "type": "Any"
            },
            {
              "name": "env",
              "type": "Any"
            },
            {
              "name": "require_save",
              "type": "bool"
            },
            {
              "name": "extension",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 565,
          "decorators": [],
          "is_async": false,
          "calls": [
            "require_save",
            "env",
            "extension",
            "editor"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        editor: str | None = None,\n        env: cabc.Mapping[str, str] | None = None,\n        require_save: bool = True,\n        extension: str = \".txt\",\n    ) -> None:\n        self.editor = editor\n        self.env = env\n        self.require_save = require_save\n        self.extension = extension",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "get_editor",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 577,
          "decorators": [],
          "is_async": false,
          "calls": [
            "editor",
            "key",
            "which",
            "os.environ.get"
          ],
          "docstring": null,
          "code": "def get_editor(self) -> str:\n        if self.editor is not None:\n            return self.editor\n        for key in \"VISUAL\", \"EDITOR\":\n            rv = os.environ.get(key)\n            if rv:\n                return rv\n        if WIN:\n            return \"notepad\"\n\n        from shutil import which\n\n        for editor in \"sensible-editor\", \"vim\", \"nano\":\n            if which(editor) is not None:\n                return editor\n        return \"vi\"",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "edit_files",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filenames",
              "type": "cabc.Iterable[str]"
            }
          ],
          "return_type": "None",
          "lineno": 594,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.get_editor",
            "ClickException",
            "e",
            "unknown.join",
            "c.wait",
            "editor",
            "_",
            "environ.update",
            "os.environ.copy",
            "subprocess.Popen",
            "environ",
            "unknown.format",
            "self.env"
          ],
          "docstring": null,
          "code": "def edit_files(self, filenames: cabc.Iterable[str]) -> None:\n        import subprocess\n\n        editor = self.get_editor()\n        environ: dict[str, str] | None = None\n\n        if self.env:\n            environ = os.environ.copy()\n            environ.update(self.env)\n\n        exc_filename = \" \".join(f'\"{filename}\"' for filename in filenames)\n\n        try:\n            c = subprocess.Popen(\n                args=f\"{editor} {exc_filename}\", env=environ, shell=True\n            )\n            exit_code = c.wait()\n            if exit_code != 0:\n                raise ClickException(\n                    _(\"{editor}: Editing failed\").format(editor=editor)\n                )\n        except OSError as e:\n            raise ClickException(\n                _(\"{editor}: Editing failed: {e}\").format(editor=editor, e=e)\n            ) from e",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "edit",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "text",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 621,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def edit(self, text: bytes | bytearray) -> bytes | None: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "edit",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "text",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 626,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def edit(self, text: str | None) -> str | None: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "edit",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "text",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 628,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "data",
            "f.write",
            "isinstance",
            "f.read",
            "os.path.getmtime",
            "text.endswith",
            "tempfile.mkstemp",
            "self.edit_files",
            "name",
            "rv.decode",
            "unknown.replace",
            "os.path.getatime",
            "text.replace",
            "os.unlink",
            "unknown.encode",
            "os.utime",
            "open",
            "fd",
            "os.fdopen",
            "self.extension",
            "text.encode"
          ],
          "docstring": null,
          "code": "def edit(self, text: str | bytes | bytearray | None) -> str | bytes | None:\n        import tempfile\n\n        if text is None:\n            data: bytes | bytearray = b\"\"\n        elif isinstance(text, (bytes, bytearray)):\n            data = text\n        else:\n            if text and not text.endswith(\"\\n\"):\n                text += \"\\n\"\n\n            if WIN:\n                data = text.replace(\"\\n\", \"\\r\\n\").encode(\"utf-8-sig\")\n            else:\n                data = text.encode(\"utf-8\")\n\n        fd, name = tempfile.mkstemp(prefix=\"editor-\", suffix=self.extension)\n        f: t.BinaryIO\n\n        try:\n            with os.fdopen(fd, \"wb\") as f:\n                f.write(data)\n\n            # If the filesystem resolution is 1 second, like Mac OS\n            # 10.12 Extended, or 2 seconds, like FAT32, and the editor\n            # closes very fast, require_save can fail. Set the modified\n            # time to be 2 seconds in the past to work around this.\n            os.utime(name, (os.path.getatime(name), os.path.getmtime(name) - 2))\n            # Depending on the resolution, the exact value might not be\n            # recorded, so get the new recorded value.\n            timestamp = os.path.getmtime(name)\n\n            self.edit_files((name,))\n\n            if self.require_save and os.path.getmtime(name) == timestamp:\n                return None\n\n            with open(name, \"rb\") as f:\n                rv = f.read()\n\n            if isinstance(text, (bytes, bytearray)):\n                return rv\n\n            return rv.decode(\"utf-8-sig\").replace(\"\\r\\n\", \"\\n\")\n        finally:\n            os.unlink(name)",
          "line_count": 46,
          "needs_llm_summary": true
        },
        {
          "name": "_unquote_file",
          "args": [
            {
              "name": "url",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 679,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unquote",
            "url.startswith"
          ],
          "docstring": null,
          "code": "def _unquote_file(url: str) -> str:\n        from urllib.parse import unquote\n\n        if url.startswith(\"file://\"):\n            url = unquote(url[7:])\n\n        return url",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "raw_terminal",
          "args": [],
          "return_type": "cabc.Iterator[int]",
          "lineno": 764,
          "decorators": [
            {
              "name": "contextlib.contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def raw_terminal() -> cabc.Iterator[int]:\n        yield -1",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "getchar",
          "args": [
            {
              "name": "echo",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "lineno": 767,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_translate_ch_to_exc",
            "msvcrt.getwch",
            "rv",
            "t.cast",
            "func",
            "msvcrt.getwche"
          ],
          "docstring": null,
          "code": "def getchar(echo: bool) -> str:\n        # The function `getch` will return a bytes object corresponding to\n        # the pressed character. Since Windows 10 build 1803, it will also\n        # return \\x00 when called a second time after pressing a regular key.\n        #\n        # `getwch` does not share this probably-bugged behavior. Moreover, it\n        # returns a Unicode object by default, which is what we want.\n        #\n        # Either of these functions will return \\x00 or \\xe0 to indicate\n        # a special key, and you need to call the same function again to get\n        # the \"rest\" of the code. The fun part is that \\u00e0 is\n        # \"latin small letter a with grave\", so if you type that on a French\n        # keyboard, you _also_ get a \\xe0.\n        # E.g., consider the Up arrow. This returns \\xe0 and then \\x48. The\n        # resulting Unicode string reads as \"a with grave\" + \"capital H\".\n        # This is indistinguishable from when the user actually types\n        # \"a with grave\" and then \"capital H\".\n        #\n        # When \\xe0 is returned, we assume it's part of a special-key sequence\n        # and call `getwch` again, but that means that when the user types\n        # the \\u00e0 character, `getchar` doesn't return until a second\n        # character is typed.\n        # The alternative is returning immediately, but that would mess up\n        # cross-platform handling of arrow keys and others that start with\n        # \\xe0. Another option is using `getch`, but then we can't reliably\n        # read non-ASCII characters, because return values of `getch` are\n        # limited to the current 8-bit codepage.\n        #\n        # Anyway, Click doesn't claim to do this Right(tm), and using `getwch`\n        # is doing the right thing in more situations than with `getch`.\n\n        if echo:\n            func = t.cast(t.Callable[[], str], msvcrt.getwche)\n        else:\n            func = t.cast(t.Callable[[], str], msvcrt.getwch)\n\n        rv = func()\n\n        if rv in (\"\\x00\", \"\\xe0\"):\n            # \\x00 and \\xe0 are control characters that indicate special key,\n            # see above.\n            rv += func()\n\n        _translate_ch_to_exc(rv)\n        return rv",
          "line_count": 45,
          "needs_llm_summary": true
        },
        {
          "name": "raw_terminal",
          "args": [],
          "return_type": "cabc.Iterator[int]",
          "lineno": 818,
          "decorators": [
            {
              "name": "contextlib.contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "old_settings",
            "f.fileno",
            "isatty",
            "f.close",
            "tty.setraw",
            "sys.stdout.flush",
            "termios.tcsetattr",
            "open",
            "sys.stdin.fileno",
            "termios.tcgetattr",
            "termios.TCSADRAIN",
            "sys.stdin",
            "fd"
          ],
          "docstring": null,
          "code": "def raw_terminal() -> cabc.Iterator[int]:\n        f: t.TextIO | None\n        fd: int\n\n        if not isatty(sys.stdin):\n            f = open(\"/dev/tty\")\n            fd = f.fileno()\n        else:\n            fd = sys.stdin.fileno()\n            f = None\n\n        try:\n            old_settings = termios.tcgetattr(fd)\n\n            try:\n                tty.setraw(fd)\n                yield fd\n            finally:\n                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n                sys.stdout.flush()\n\n                if f is not None:\n                    f.close()\n        except termios.error:\n            pass",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "getchar",
          "args": [
            {
              "name": "echo",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "lineno": 844,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sys.stdout",
            "os.read",
            "_translate_ch_to_exc",
            "ch",
            "raw_terminal",
            "isatty",
            "get_best_encoding",
            "sys.stdout.write",
            "unknown.decode",
            "sys.stdin",
            "fd"
          ],
          "docstring": null,
          "code": "def getchar(echo: bool) -> str:\n        with raw_terminal() as fd:\n            ch = os.read(fd, 32).decode(get_best_encoding(sys.stdin), \"replace\")\n\n            if echo and isatty(sys.stdout):\n                sys.stdout.write(ch)\n\n            _translate_ch_to_exc(ch)\n            return ch",
          "line_count": 9,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "ProgressBar",
          "methods": [
            "__init__",
            "__enter__",
            "__exit__",
            "__iter__",
            "__next__",
            "render_finish",
            "pct",
            "time_per_iteration",
            "eta",
            "format_eta",
            "format_pos",
            "format_pct",
            "format_bar",
            "format_progress_line",
            "render_progress",
            "make_step",
            "update",
            "finish",
            "generator"
          ],
          "base_classes": [
            "unknown"
          ],
          "lineno": 43,
          "docstring": null
        },
        {
          "name": "Editor",
          "methods": [
            "__init__",
            "get_editor",
            "edit_files",
            "edit",
            "edit",
            "edit"
          ],
          "base_classes": [],
          "lineno": 564,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "contextlib",
          "alias": null,
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "math",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 12,
          "type": "import"
        },
        {
          "module": "shlex",
          "alias": null,
          "lineno": 13,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 14,
          "type": "import"
        },
        {
          "module": "time",
          "alias": null,
          "lineno": 15,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 16,
          "type": "import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "io",
          "name": "StringIO",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "pathlib",
          "name": "Path",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "TracebackType",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "_default_text_stdout",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "CYGWIN",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "get_best_encoding",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "isatty",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "open_stream",
          "alias": null,
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "strip_ansi",
          "alias": null,
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "term_len",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "WIN",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ClickException",
          "alias": null,
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "echo",
          "alias": null,
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "tempfile",
          "alias": null,
          "lineno": 399,
          "type": "import"
        },
        {
          "module": "shutil",
          "alias": null,
          "lineno": 424,
          "type": "import"
        },
        {
          "module": "subprocess",
          "alias": null,
          "lineno": 439,
          "type": "import"
        },
        {
          "module": "shutil",
          "alias": null,
          "lineno": 519,
          "type": "import"
        },
        {
          "module": "subprocess",
          "alias": null,
          "lineno": 531,
          "type": "import"
        },
        {
          "module": "tempfile",
          "alias": null,
          "lineno": 532,
          "type": "import"
        },
        {
          "module": "subprocess",
          "alias": null,
          "lineno": 677,
          "type": "import"
        },
        {
          "module": "msvcrt",
          "alias": null,
          "lineno": 761,
          "type": "import"
        },
        {
          "module": "termios",
          "alias": null,
          "lineno": 814,
          "type": "import"
        },
        {
          "module": "tty",
          "alias": null,
          "lineno": 815,
          "type": "import"
        },
        {
          "module": "shutil",
          "name": "which",
          "alias": null,
          "lineno": 587,
          "type": "from_import"
        },
        {
          "module": "subprocess",
          "alias": null,
          "lineno": 595,
          "type": "import"
        },
        {
          "module": "tempfile",
          "alias": null,
          "lineno": 629,
          "type": "import"
        },
        {
          "module": "urllib.parse",
          "name": "unquote",
          "alias": null,
          "lineno": 680,
          "type": "from_import"
        },
        {
          "module": "operator",
          "name": "length_hint",
          "alias": null,
          "lineno": 90,
          "type": "from_import"
        },
        {
          "module": "shutil",
          "alias": null,
          "lineno": 250,
          "type": "import"
        },
        {
          "module": "webbrowser",
          "alias": null,
          "lineno": 740,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "V",
          "assigned_to": "t.TypeVar",
          "lineno": 33
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "os.read",
          "ch",
          "raw_terminal",
          "f.close",
          "t.TypeVar",
          "get_best_encoding",
          "sys.stdout.write",
          "sys.stdin.fileno",
          "sys.stdin",
          "sys.stdout.flush",
          "rv",
          "func",
          "msvcrt.getwche",
          "termios.TCSADRAIN",
          "f.fileno",
          "_translate_ch_to_exc",
          "msvcrt.getwch",
          "termios.tcsetattr",
          "open",
          "fd",
          "old_settings",
          "sys.stdout",
          "isatty",
          "tty.setraw",
          "t.cast",
          "termios.tcgetattr",
          "unknown.decode"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "contextlib",
          "sys",
          "shutil",
          "typing",
          "pathlib",
          "math",
          "time",
          "os",
          "tempfile",
          "subprocess",
          "collections",
          "io"
        ],
        "third_party": {
          "other": [
            "__future__",
            "shlex",
            "gettext",
            "types",
            "_compat",
            "exceptions",
            "utils",
            "msvcrt",
            "termios",
            "tty",
            "urllib",
            "operator",
            "webbrowser"
          ]
        },
        "tech_stack": []
      },
      "line_count": 853
    },
    "src/click/_textwrap.py": {
      "filepath": "../click/src/click/_textwrap.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_handle_long_word",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "reversed_chunks",
              "type": "list[str]"
            },
            {
              "name": "cur_line",
              "type": "list[str]"
            },
            {
              "name": "cur_len",
              "type": "int"
            },
            {
              "name": "width",
              "type": "int"
            }
          ],
          "return_type": "None",
          "lineno": 9,
          "decorators": [],
          "is_async": false,
          "calls": [
            "max",
            "cut",
            "res",
            "reversed_chunks.pop",
            "cur_line.append"
          ],
          "docstring": null,
          "code": "def _handle_long_word(\n        self,\n        reversed_chunks: list[str],\n        cur_line: list[str],\n        cur_len: int,\n        width: int,\n    ) -> None:\n        space_left = max(width - cur_len, 1)\n\n        if self.break_long_words:\n            last = reversed_chunks[-1]\n            cut = last[:space_left]\n            res = last[space_left:]\n            cur_line.append(cut)\n            reversed_chunks[-1] = res\n        elif not cur_line:\n            cur_line.append(reversed_chunks.pop())",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "extra_indent",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "indent",
              "type": "str"
            }
          ],
          "return_type": "cabc.Iterator[None]",
          "lineno": 28,
          "decorators": [
            {
              "name": "contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "old_subsequent_indent",
            "self.initial_indent",
            "old_initial_indent",
            "self.subsequent_indent"
          ],
          "docstring": null,
          "code": "def extra_indent(self, indent: str) -> cabc.Iterator[None]:\n        old_initial_indent = self.initial_indent\n        old_subsequent_indent = self.subsequent_indent\n        self.initial_indent += indent\n        self.subsequent_indent += indent\n\n        try:\n            yield\n        finally:\n            self.initial_indent = old_initial_indent\n            self.subsequent_indent = old_subsequent_indent",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "indent_only",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "text",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 40,
          "decorators": [],
          "is_async": false,
          "calls": [
            "enumerate",
            "unknown.join",
            "self.subsequent_indent",
            "text.splitlines",
            "rv",
            "self.initial_indent",
            "rv.append"
          ],
          "docstring": null,
          "code": "def indent_only(self, text: str) -> str:\n        rv = []\n\n        for idx, line in enumerate(text.splitlines()):\n            indent = self.initial_indent\n\n            if idx > 0:\n                indent = self.subsequent_indent\n\n            rv.append(f\"{indent}{line}\")\n\n        return \"\\n\".join(rv)",
          "line_count": 12,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "TextWrapper",
          "methods": [
            "_handle_long_word",
            "extra_indent",
            "indent_only"
          ],
          "base_classes": [
            "textwrap.TextWrapper"
          ],
          "lineno": 8,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "textwrap",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "contextlib",
          "name": "contextmanager",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "collections",
          "contextlib"
        ],
        "third_party": {
          "other": [
            "__future__",
            "textwrap"
          ]
        },
        "tech_stack": []
      },
      "line_count": 52
    },
    "src/click/_utils.py": {
      "filepath": "../click/src/click/_utils.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 18,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}.{self.name}\"",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "Sentinel",
          "methods": [
            "__repr__"
          ],
          "base_classes": [
            "enum.Enum"
          ],
          "lineno": 7,
          "docstring": "Enum used to define sentinel values.\n\n.. seealso::\n\n    `PEP 661 - Sentinel Values <https://peps.python.org/pep-0661/>`_."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "enum",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "UNSET",
          "assigned_to": null,
          "lineno": 22
        },
        {
          "name": "FLAG_NEEDS_VALUE",
          "assigned_to": null,
          "lineno": 25
        },
        {
          "name": "T_UNSET",
          "assigned_to": null,
          "lineno": 32
        },
        {
          "name": "T_FLAG_NEEDS_VALUE",
          "assigned_to": null,
          "lineno": 35
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "Sentinel.UNSET",
          "Sentinel.FLAG_NEEDS_VALUE"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "enum",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__"
          ]
        },
        "tech_stack": []
      },
      "line_count": 37
    },
    "src/click/_winconsole.py": {
      "filepath": "../click/src/click/_winconsole.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_get_text_stdin",
          "args": [
            {
              "name": "buffer_stream",
              "type": "t.BinaryIO"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 226,
          "decorators": [],
          "is_async": false,
          "calls": [
            "t.TextIO",
            "STDIN_HANDLE",
            "_NonClosingTextIOWrapper",
            "text_stream",
            "t.cast",
            "buffer_stream",
            "ConsoleStream",
            "_WindowsConsoleReader",
            "io.BufferedReader"
          ],
          "docstring": null,
          "code": "def _get_text_stdin(buffer_stream: t.BinaryIO) -> t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        io.BufferedReader(_WindowsConsoleReader(STDIN_HANDLE)),\n        \"utf-16-le\",\n        \"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "_get_text_stdout",
          "args": [
            {
              "name": "buffer_stream",
              "type": "t.BinaryIO"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 236,
          "decorators": [],
          "is_async": false,
          "calls": [
            "t.TextIO",
            "_NonClosingTextIOWrapper",
            "text_stream",
            "t.cast",
            "buffer_stream",
            "STDOUT_HANDLE",
            "ConsoleStream",
            "_WindowsConsoleWriter",
            "io.BufferedWriter"
          ],
          "docstring": null,
          "code": "def _get_text_stdout(buffer_stream: t.BinaryIO) -> t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        io.BufferedWriter(_WindowsConsoleWriter(STDOUT_HANDLE)),\n        \"utf-16-le\",\n        \"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "_get_text_stderr",
          "args": [
            {
              "name": "buffer_stream",
              "type": "t.BinaryIO"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 246,
          "decorators": [],
          "is_async": false,
          "calls": [
            "t.TextIO",
            "_NonClosingTextIOWrapper",
            "text_stream",
            "t.cast",
            "buffer_stream",
            "ConsoleStream",
            "_WindowsConsoleWriter",
            "io.BufferedWriter",
            "STDERR_HANDLE"
          ],
          "docstring": null,
          "code": "def _get_text_stderr(buffer_stream: t.BinaryIO) -> t.TextIO:\n    text_stream = _NonClosingTextIOWrapper(\n        io.BufferedWriter(_WindowsConsoleWriter(STDERR_HANDLE)),\n        \"utf-16-le\",\n        \"strict\",\n        line_buffering=True,\n    )\n    return t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "_is_console",
          "args": [
            {
              "name": "f",
              "type": "t.TextIO"
            }
          ],
          "return_type": "bool",
          "lineno": 263,
          "decorators": [],
          "is_async": false,
          "calls": [
            "msvcrt.get_osfhandle",
            "f.fileno",
            "hasattr",
            "f",
            "byref",
            "GetConsoleMode",
            "handle",
            "bool",
            "DWORD",
            "fileno"
          ],
          "docstring": null,
          "code": "def _is_console(f: t.TextIO) -> bool:\n    if not hasattr(f, \"fileno\"):\n        return False\n\n    try:\n        fileno = f.fileno()\n    except (OSError, io.UnsupportedOperation):\n        return False\n\n    handle = msvcrt.get_osfhandle(fileno)\n    return bool(GetConsoleMode(handle, byref(DWORD())))",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "_get_windows_console_stream",
          "args": [
            {
              "name": "f",
              "type": "t.TextIO"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 276,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f.fileno",
            "b",
            "f",
            "func",
            "_is_console",
            "_stream_factories.get",
            "getattr"
          ],
          "docstring": null,
          "code": "def _get_windows_console_stream(\n    f: t.TextIO, encoding: str | None, errors: str | None\n) -> t.TextIO | None:\n    if (\n        get_buffer is None\n        or encoding not in {\"utf-16-le\", None}\n        or errors not in {\"strict\", None}\n        or not _is_console(f)\n    ):\n        return None\n\n    func = _stream_factories.get(f.fileno())\n    if func is None:\n        return None\n\n    b = getattr(f, \"buffer\", None)\n\n    if b is None:\n        return None\n\n    return func(b)",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "get_buffer",
          "args": [
            {
              "name": "obj",
              "type": "Buffer"
            },
            {
              "name": "writable",
              "type": "bool"
            }
          ],
          "return_type": "Array[c_char]",
          "lineno": 105,
          "decorators": [],
          "is_async": false,
          "calls": [
            "py_object",
            "PyBuffer_Release",
            "buffer_type.from_address",
            "Py_buffer",
            "byref",
            "PyObject_GetBuffer",
            "flags",
            "buf.buf",
            "obj",
            "buf"
          ],
          "docstring": null,
          "code": "def get_buffer(obj: Buffer, writable: bool = False) -> Array[c_char]:\n        buf = Py_buffer()\n        flags: int = PyBUF_WRITABLE if writable else PyBUF_SIMPLE\n        PyObject_GetBuffer(py_object(obj), byref(buf), flags)\n\n        try:\n            buffer_type = c_char * buf.len\n            out: Array[c_char] = buffer_type.from_address(buf.buf)\n            return out\n        finally:\n            PyBuffer_Release(byref(buf))",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "handle",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 119,
          "decorators": [],
          "is_async": false,
          "calls": [
            "handle"
          ],
          "docstring": null,
          "code": "def __init__(self, handle: int | None) -> None:\n        self.handle = handle",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "isatty",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Literal[True]",
          "lineno": 122,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.isatty",
            "super"
          ],
          "docstring": null,
          "code": "def isatty(self) -> t.Literal[True]:\n        super().isatty()\n        return True",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "readable",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Literal[True]",
          "lineno": 128,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def readable(self) -> t.Literal[True]:\n        return True",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "readinto",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "b",
              "type": "Buffer"
            }
          ],
          "return_type": "int",
          "lineno": 131,
          "decorators": [],
          "is_async": false,
          "calls": [
            "code_units_to_be_read",
            "GetLastError",
            "get_buffer",
            "HANDLE",
            "time.sleep",
            "OSError",
            "b",
            "len",
            "ReadConsoleW",
            "buffer",
            "self.handle",
            "c_ulong",
            "byref",
            "code_units_read",
            "ValueError"
          ],
          "docstring": null,
          "code": "def readinto(self, b: Buffer) -> int:\n        bytes_to_be_read = len(b)\n        if not bytes_to_be_read:\n            return 0\n        elif bytes_to_be_read % 2:\n            raise ValueError(\n                \"cannot read odd number of bytes from UTF-16-LE encoded console\"\n            )\n\n        buffer = get_buffer(b, writable=True)\n        code_units_to_be_read = bytes_to_be_read // 2\n        code_units_read = c_ulong()\n\n        rv = ReadConsoleW(\n            HANDLE(self.handle),\n            buffer,\n            code_units_to_be_read,\n            byref(code_units_read),\n            None,\n        )\n        if GetLastError() == ERROR_OPERATION_ABORTED:\n            # wait for KeyboardInterrupt\n            time.sleep(0.1)\n        if not rv:\n            raise OSError(f\"Windows error: {GetLastError()}\")\n\n        if buffer[0] == EOF:\n            return 0\n        return 2 * code_units_read.value",
          "line_count": 29,
          "needs_llm_summary": true
        },
        {
          "name": "writable",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Literal[True]",
          "lineno": 163,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def writable(self) -> t.Literal[True]:\n        return True",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_get_error_message",
          "args": [
            {
              "name": "errno",
              "type": "int"
            }
          ],
          "return_type": "str",
          "lineno": 167,
          "decorators": [
            {
              "name": "staticmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def _get_error_message(errno: int) -> str:\n        if errno == ERROR_SUCCESS:\n            return \"ERROR_SUCCESS\"\n        elif errno == ERROR_NOT_ENOUGH_MEMORY:\n            return \"ERROR_NOT_ENOUGH_MEMORY\"\n        return f\"Windows error {errno}\"",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "write",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "b",
              "type": "Buffer"
            }
          ],
          "return_type": "int",
          "lineno": 174,
          "decorators": [],
          "is_async": false,
          "calls": [
            "GetLastError",
            "get_buffer",
            "bytes_to_be_written",
            "HANDLE",
            "code_units_written",
            "b",
            "len",
            "OSError",
            "self.handle",
            "WriteConsoleW",
            "c_ulong",
            "code_units_to_be_written",
            "min",
            "byref",
            "MAX_BYTES_WRITTEN",
            "self._get_error_message",
            "buf"
          ],
          "docstring": null,
          "code": "def write(self, b: Buffer) -> int:\n        bytes_to_be_written = len(b)\n        buf = get_buffer(b)\n        code_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2\n        code_units_written = c_ulong()\n\n        WriteConsoleW(\n            HANDLE(self.handle),\n            buf,\n            code_units_to_be_written,\n            byref(code_units_written),\n            None,\n        )\n        bytes_written = 2 * code_units_written.value\n\n        if bytes_written == 0 and bytes_to_be_written > 0:\n            raise OSError(self._get_error_message(GetLastError()))\n        return bytes_written",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "text_stream",
              "type": "t.TextIO"
            },
            {
              "name": "byte_stream",
              "type": "t.BinaryIO"
            }
          ],
          "return_type": "None",
          "lineno": 195,
          "decorators": [],
          "is_async": false,
          "calls": [
            "byte_stream",
            "text_stream"
          ],
          "docstring": null,
          "code": "def __init__(self, text_stream: t.TextIO, byte_stream: t.BinaryIO) -> None:\n        self._text_stream = text_stream\n        self.buffer = byte_stream",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "name",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 200,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def name(self) -> str:\n        return self.buffer.name",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "write",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "x",
              "type": "t.AnyStr"
            }
          ],
          "return_type": "int",
          "lineno": 203,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "self.buffer.write",
            "self._text_stream.write",
            "self.flush",
            "isinstance",
            "x"
          ],
          "docstring": null,
          "code": "def write(self, x: t.AnyStr) -> int:\n        if isinstance(x, str):\n            return self._text_stream.write(x)\n        try:\n            self.flush()\n        except Exception:\n            pass\n        return self.buffer.write(x)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "writelines",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "lines",
              "type": "cabc.Iterable[t.AnyStr]"
            }
          ],
          "return_type": "None",
          "lineno": 212,
          "decorators": [],
          "is_async": false,
          "calls": [
            "line",
            "self.write"
          ],
          "docstring": null,
          "code": "def writelines(self, lines: cabc.Iterable[t.AnyStr]) -> None:\n        for line in lines:\n            self.write(line)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 216,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "self._text_stream",
            "getattr"
          ],
          "docstring": null,
          "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._text_stream, name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "isatty",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 219,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.buffer.isatty"
          ],
          "docstring": null,
          "code": "def isatty(self) -> bool:\n        return self.buffer.isatty()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 222,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return f\"<ConsoleStream name={self.name!r} encoding={self.encoding!r}>\"",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "_WindowsConsoleRawIOBase",
          "methods": [
            "__init__",
            "isatty"
          ],
          "base_classes": [
            "io.RawIOBase"
          ],
          "lineno": 118,
          "docstring": null
        },
        {
          "name": "_WindowsConsoleReader",
          "methods": [
            "readable",
            "readinto"
          ],
          "base_classes": [
            "_WindowsConsoleRawIOBase"
          ],
          "lineno": 127,
          "docstring": null
        },
        {
          "name": "_WindowsConsoleWriter",
          "methods": [
            "writable",
            "_get_error_message",
            "write"
          ],
          "base_classes": [
            "_WindowsConsoleRawIOBase"
          ],
          "lineno": 162,
          "docstring": null
        },
        {
          "name": "ConsoleStream",
          "methods": [
            "__init__",
            "name",
            "write",
            "writelines",
            "__getattr__",
            "isatty",
            "__repr__"
          ],
          "base_classes": [],
          "lineno": 194,
          "docstring": null
        },
        {
          "name": "Py_buffer",
          "methods": [],
          "base_classes": [
            "Structure"
          ],
          "lineno": 87,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "io",
          "alias": null,
          "lineno": 12,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 13,
          "type": "import"
        },
        {
          "module": "time",
          "alias": null,
          "lineno": 14,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 15,
          "type": "import"
        },
        {
          "module": "ctypes",
          "name": "Array",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "byref",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "c_char",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "c_char_p",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "c_int",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "c_ssize_t",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "c_ulong",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "c_void_p",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "POINTER",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "py_object",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "Structure",
          "alias": null,
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "ctypes.wintypes",
          "name": "DWORD",
          "alias": null,
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "ctypes.wintypes",
          "name": "HANDLE",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "ctypes.wintypes",
          "name": "LPCWSTR",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "ctypes.wintypes",
          "name": "LPWSTR",
          "alias": null,
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "_NonClosingTextIOWrapper",
          "alias": null,
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "msvcrt",
          "alias": null,
          "lineno": 35,
          "type": "import"
        },
        {
          "module": "ctypes",
          "name": "windll",
          "alias": null,
          "lineno": 36,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "WINFUNCTYPE",
          "alias": null,
          "lineno": 37,
          "type": "from_import"
        },
        {
          "module": "ctypes",
          "name": "pythonapi",
          "alias": null,
          "lineno": 80,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "name": "Buffer",
          "alias": null,
          "lineno": 75,
          "type": "from_import"
        },
        {
          "module": "typing_extensions",
          "name": "Buffer",
          "alias": null,
          "lineno": 77,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "c_ssize_p",
          "assigned_to": "POINTER",
          "lineno": 39
        },
        {
          "name": "kernel32",
          "assigned_to": null,
          "lineno": 41
        },
        {
          "name": "GetStdHandle",
          "assigned_to": null,
          "lineno": 42
        },
        {
          "name": "ReadConsoleW",
          "assigned_to": null,
          "lineno": 43
        },
        {
          "name": "WriteConsoleW",
          "assigned_to": null,
          "lineno": 44
        },
        {
          "name": "GetConsoleMode",
          "assigned_to": null,
          "lineno": 45
        },
        {
          "name": "GetLastError",
          "assigned_to": null,
          "lineno": 46
        },
        {
          "name": "GetCommandLineW",
          "assigned_to": null,
          "lineno": 47
        },
        {
          "name": "CommandLineToArgvW",
          "assigned_to": null,
          "lineno": 48
        },
        {
          "name": "LocalFree",
          "assigned_to": null,
          "lineno": 51
        },
        {
          "name": "STDIN_HANDLE",
          "assigned_to": "GetStdHandle",
          "lineno": 53
        },
        {
          "name": "STDOUT_HANDLE",
          "assigned_to": "GetStdHandle",
          "lineno": 54
        },
        {
          "name": "STDERR_HANDLE",
          "assigned_to": "GetStdHandle",
          "lineno": 55
        },
        {
          "name": "PyBUF_SIMPLE",
          "assigned_to": "int",
          "lineno": 57
        },
        {
          "name": "PyBUF_WRITABLE",
          "assigned_to": "int",
          "lineno": 58
        },
        {
          "name": "ERROR_SUCCESS",
          "assigned_to": "int",
          "lineno": 60
        },
        {
          "name": "ERROR_NOT_ENOUGH_MEMORY",
          "assigned_to": "int",
          "lineno": 61
        },
        {
          "name": "ERROR_OPERATION_ABORTED",
          "assigned_to": "int",
          "lineno": 62
        },
        {
          "name": "STDIN_FILENO",
          "assigned_to": "int",
          "lineno": 64
        },
        {
          "name": "STDOUT_FILENO",
          "assigned_to": "int",
          "lineno": 65
        },
        {
          "name": "STDERR_FILENO",
          "assigned_to": "int",
          "lineno": 66
        },
        {
          "name": "EOF",
          "assigned_to": "bytes",
          "lineno": 68
        },
        {
          "name": "MAX_BYTES_WRITTEN",
          "assigned_to": "int",
          "lineno": 69
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "pythonapi.PyBuffer_Release",
          "kernel32.WriteConsoleW",
          "py_object",
          "POINTER",
          "GetStdHandle",
          "c_ssize_t",
          "kernel32.GetConsoleMode",
          "Py_buffer",
          "LPCWSTR",
          "byref",
          "PyObject_GetBuffer",
          "buf.buf",
          "obj",
          "kernel32.ReadConsoleW",
          "buf",
          "windll.kernel32",
          "pythonapi.PyObject_GetBuffer",
          "c_int",
          "LPWSTR",
          "buffer_type.from_address",
          "PyBuffer_Release",
          "WINFUNCTYPE",
          "flags",
          "kernel32.GetLastError",
          "c_void_p",
          "kernel32.GetStdHandle"
        ],
        "class_instantiations": [
          "PyBuffer_Release",
          "POINTER",
          "Py_buffer",
          "WINFUNCTYPE",
          "GetStdHandle",
          "PyObject_GetBuffer"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "sys",
          "typing",
          "time",
          "collections",
          "io"
        ],
        "third_party": {
          "other": [
            "__future__",
            "ctypes",
            "_compat",
            "msvcrt",
            "typing_extensions"
          ]
        },
        "tech_stack": []
      },
      "line_count": 297
    },
    "src/click/core.py": {
      "filepath": "../click/src/click/core.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_complete_visible_commands",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "cabc.Iterator[tuple[str, Command]]",
          "lineno": 54,
          "decorators": [],
          "is_async": false,
          "calls": [
            "incomplete",
            "ctx",
            "multi.get_command",
            "name",
            "t.cast",
            "name.startswith",
            "multi.list_commands",
            "ctx.command",
            "Group"
          ],
          "docstring": "List all the subcommands of a group that start with the\nincomplete value and aren't hidden.\n\n:param ctx: Invocation context for the group.\n:param incomplete: Value being completed. May be empty.",
          "code": "def _complete_visible_commands(\n    ctx: Context, incomplete: str\n) -> cabc.Iterator[tuple[str, Command]]:\n    \"\"\"List all the subcommands of a group that start with the\n    incomplete value and aren't hidden.\n\n    :param ctx: Invocation context for the group.\n    :param incomplete: Value being completed. May be empty.\n    \"\"\"\n    multi = t.cast(Group, ctx.command)\n\n    for name in multi.list_commands(ctx):\n        if name.startswith(incomplete):\n            command = multi.get_command(ctx, name)\n\n            if command is not None and not command.hidden:\n                yield name, command",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "_check_nested_chain",
          "args": [
            {
              "name": "base_command",
              "type": "Group"
            },
            {
              "name": "cmd_name",
              "type": "str"
            },
            {
              "name": "cmd",
              "type": "Command"
            },
            {
              "name": "register",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 73,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Group",
            "message",
            "RuntimeError",
            "isinstance",
            "cmd"
          ],
          "docstring": null,
          "code": "def _check_nested_chain(\n    base_command: Group, cmd_name: str, cmd: Command, register: bool = False\n) -> None:\n    if not base_command.chain or not isinstance(cmd, Group):\n        return\n\n    if register:\n        message = (\n            f\"It is not possible to add the group {cmd_name!r} to another\"\n            f\" group {base_command.name!r} that is in chain mode.\"\n        )\n    else:\n        message = (\n            f\"Found the group {cmd_name!r} as subcommand to another group \"\n            f\" {base_command.name!r} that is in chain mode. This is not supported.\"\n        )\n\n    raise RuntimeError(message)",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "batch",
          "args": [
            {
              "name": "iterable",
              "type": "cabc.Iterable[V]"
            },
            {
              "name": "batch_size",
              "type": "int"
            }
          ],
          "return_type": "list[tuple[V, Ellipsis]]",
          "lineno": 93,
          "decorators": [],
          "is_async": false,
          "calls": [
            "iterable",
            "iter",
            "repeat",
            "list",
            "batch_size",
            "zip"
          ],
          "docstring": null,
          "code": "def batch(iterable: cabc.Iterable[V], batch_size: int) -> list[tuple[V, ...]]:\n    return list(zip(*repeat(iter(iterable), batch_size), strict=False))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "augment_usage_errors",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Any"
            }
          ],
          "return_type": "cabc.Iterator[None]",
          "lineno": 98,
          "decorators": [
            {
              "name": "contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "ctx",
            "param"
          ],
          "docstring": "Context manager that attaches extra information to exceptions.",
          "code": "def augment_usage_errors(\n    ctx: Context, param: Parameter | None = None\n) -> cabc.Iterator[None]:\n    \"\"\"Context manager that attaches extra information to exceptions.\"\"\"\n    try:\n        yield\n    except BadParameter as e:\n        if e.ctx is None:\n            e.ctx = ctx\n        if param is not None and e.param is None:\n            e.param = param\n        raise\n    except UsageError as e:\n        if e.ctx is None:\n            e.ctx = ctx\n        raise",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "iter_params_for_processing",
          "args": [
            {
              "name": "invocation_order",
              "type": "cabc.Sequence[Parameter]"
            },
            {
              "name": "declaration_order",
              "type": "cabc.Sequence[Parameter]"
            }
          ],
          "return_type": "list[Parameter]",
          "lineno": 116,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sort_key",
            "float",
            "declaration_order",
            "item",
            "sorted",
            "invocation_order.index"
          ],
          "docstring": "Returns all declared parameters in the order they should be processed.\n\nThe declared parameters are re-shuffled depending on the order in which\nthey were invoked, as well as the eagerness of each parameters.\n\nThe invocation order takes precedence over the declaration order. I.e. the\norder in which the user provided them to the CLI is respected.\n\nThis behavior and its effect on callback evaluation is detailed at:\nhttps://click.palletsprojects.com/en/stable/advanced/#callback-evaluation-order",
          "code": "def iter_params_for_processing(\n    invocation_order: cabc.Sequence[Parameter],\n    declaration_order: cabc.Sequence[Parameter],\n) -> list[Parameter]:\n    \"\"\"Returns all declared parameters in the order they should be processed.\n\n    The declared parameters are re-shuffled depending on the order in which\n    they were invoked, as well as the eagerness of each parameters.\n\n    The invocation order takes precedence over the declaration order. I.e. the\n    order in which the user provided them to the CLI is respected.\n\n    This behavior and its effect on callback evaluation is detailed at:\n    https://click.palletsprojects.com/en/stable/advanced/#callback-evaluation-order\n    \"\"\"\n\n    def sort_key(item: Parameter) -> tuple[bool, float]:\n        try:\n            idx: float = invocation_order.index(item)\n        except ValueError:\n            idx = float(\"inf\")\n\n        return not item.is_eager, idx\n\n    return sorted(declaration_order, key=sort_key)",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "_check_iter",
          "args": [
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "cabc.Iterator[t.Any]",
          "lineno": 2017,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "isinstance",
            "iter",
            "value"
          ],
          "docstring": "Check if the value is iterable but not a string. Raises a type\nerror, or return an iterator over the value.",
          "code": "def _check_iter(value: t.Any) -> cabc.Iterator[t.Any]:\n    \"\"\"Check if the value is iterable but not a string. Raises a type\n    error, or return an iterator over the value.\n    \"\"\"\n    if isinstance(value, str):\n        raise TypeError\n\n    return iter(value)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "object",
          "lineno": 3397,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "AttributeError",
            "DeprecationWarning",
            "warnings.warn"
          ],
          "docstring": null,
          "code": "def __getattr__(name: str) -> object:\n    import warnings\n\n    if name == \"BaseCommand\":\n        warnings.warn(\n            \"'BaseCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 'Command' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _BaseCommand\n\n    if name == \"MultiCommand\":\n        warnings.warn(\n            \"'MultiCommand' is deprecated and will be removed in Click 9.0. Use\"\n            \" 'Group' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _MultiCommand\n\n    raise AttributeError(name)",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "sort_key",
          "args": [
            {
              "name": "item",
              "type": "Parameter"
            }
          ],
          "return_type": "tuple[bool, float]",
          "lineno": 132,
          "decorators": [],
          "is_async": false,
          "calls": [
            "item",
            "float",
            "invocation_order.index"
          ],
          "docstring": null,
          "code": "def sort_key(item: Parameter) -> tuple[bool, float]:\n        try:\n            idx: float = invocation_order.index(item)\n        except ValueError:\n            idx = float(\"inf\")\n\n        return not item.is_eager, idx",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "command",
              "type": "Command"
            },
            {
              "name": "parent",
              "type": "Any"
            },
            {
              "name": "info_name",
              "type": "Any"
            },
            {
              "name": "obj",
              "type": "Any"
            },
            {
              "name": "auto_envvar_prefix",
              "type": "Any"
            },
            {
              "name": "default_map",
              "type": "Any"
            },
            {
              "name": "terminal_width",
              "type": "Any"
            },
            {
              "name": "max_content_width",
              "type": "Any"
            },
            {
              "name": "resilient_parsing",
              "type": "bool"
            },
            {
              "name": "allow_extra_args",
              "type": "Any"
            },
            {
              "name": "allow_interspersed_args",
              "type": "Any"
            },
            {
              "name": "ignore_unknown_options",
              "type": "Any"
            },
            {
              "name": "help_option_names",
              "type": "Any"
            },
            {
              "name": "token_normalize_func",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "Any"
            },
            {
              "name": "show_default",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 273,
          "decorators": [],
          "is_async": false,
          "calls": [
            "set",
            "parent.default_map.get",
            "parent.terminal_width",
            "parent",
            "parent._opt_prefixes",
            "command.allow_extra_args",
            "parent.obj",
            "parent.max_content_width",
            "getattr",
            "ExitStack",
            "command.allow_interspersed_args",
            "auto_envvar_prefix.replace",
            "command.ignore_unknown_options",
            "parent.token_normalize_func",
            "info_name",
            "allow_extra_args",
            "self.info_name.upper",
            "auto_envvar_prefix.upper",
            "command",
            "parent.show_default",
            "parent.color",
            "parent.help_option_names"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        command: Command,\n        parent: Context | None = None,\n        info_name: str | None = None,\n        obj: t.Any | None = None,\n        auto_envvar_prefix: str | None = None,\n        default_map: cabc.MutableMapping[str, t.Any] | None = None,\n        terminal_width: int | None = None,\n        max_content_width: int | None = None,\n        resilient_parsing: bool = False,\n        allow_extra_args: bool | None = None,\n        allow_interspersed_args: bool | None = None,\n        ignore_unknown_options: bool | None = None,\n        help_option_names: list[str] | None = None,\n        token_normalize_func: t.Callable[[str], str] | None = None,\n        color: bool | None = None,\n        show_default: bool | None = None,\n    ) -> None:\n        #: the parent context or `None` if none exists.\n        self.parent = parent\n        #: the :class:`Command` for this context.\n        self.command = command\n        #: the descriptive information name\n        self.info_name = info_name\n        #: Map of parameter names to their parsed values. Parameters\n        #: with ``expose_value=False`` are not stored.\n        self.params: dict[str, t.Any] = {}\n        #: the leftover arguments.\n        self.args: list[str] = []\n        #: protected arguments.  These are arguments that are prepended\n        #: to `args` when certain parsing scenarios are encountered but\n        #: must be never propagated to another arguments.  This is used\n        #: to implement nested parsing.\n        self._protected_args: list[str] = []\n        #: the collected prefixes of the command's options.\n        self._opt_prefixes: set[str] = set(parent._opt_prefixes) if parent else set()\n\n        if obj is None and parent is not None:\n            obj = parent.obj\n\n        #: the user object stored.\n        self.obj: t.Any = obj\n        self._meta: dict[str, t.Any] = getattr(parent, \"meta\", {})\n\n        #: A dictionary (-like object) with defaults for parameters.\n        if (\n            default_map is None\n            and info_name is not None\n            and parent is not None\n            and parent.default_map is not None\n        ):\n            default_map = parent.default_map.get(info_name)\n\n        self.default_map: cabc.MutableMapping[str, t.Any] | None = default_map\n\n        #: This flag indicates if a subcommand is going to be executed. A\n        #: group callback can use this information to figure out if it's\n        #: being executed directly or because the execution flow passes\n        #: onwards to a subcommand. By default it's None, but it can be\n        #: the name of the subcommand to execute.\n        #:\n        #: If chaining is enabled this will be set to ``'*'`` in case\n        #: any commands are executed.  It is however not possible to\n        #: figure out which ones.  If you require this knowledge you\n        #: should use a :func:`result_callback`.\n        self.invoked_subcommand: str | None = None\n\n        if terminal_width is None and parent is not None:\n            terminal_width = parent.terminal_width\n\n        #: The width of the terminal (None is autodetection).\n        self.terminal_width: int | None = terminal_width\n\n        if max_content_width is None and parent is not None:\n            max_content_width = parent.max_content_width\n\n        #: The maximum width of formatted content (None implies a sensible\n        #: default which is 80 for most things).\n        self.max_content_width: int | None = max_content_width\n\n        if allow_extra_args is None:\n            allow_extra_args = command.allow_extra_args\n\n        #: Indicates if the context allows extra args or if it should\n        #: fail on parsing.\n        #:\n        #: .. versionadded:: 3.0\n        self.allow_extra_args = allow_extra_args\n\n        if allow_interspersed_args is None:\n            allow_interspersed_args = command.allow_interspersed_args\n\n        #: Indicates if the context allows mixing of arguments and\n        #: options or not.\n        #:\n        #: .. versionadded:: 3.0\n        self.allow_interspersed_args: bool = allow_interspersed_args\n\n        if ignore_unknown_options is None:\n            ignore_unknown_options = command.ignore_unknown_options\n\n        #: Instructs click to ignore options that a command does not\n        #: understand and will store it on the context for later\n        #: processing.  This is primarily useful for situations where you\n        #: want to call into external programs.  Generally this pattern is\n        #: strongly discouraged because it's not possibly to losslessly\n        #: forward all arguments.\n        #:\n        #: .. versionadded:: 4.0\n        self.ignore_unknown_options: bool = ignore_unknown_options\n\n        if help_option_names is None:\n            if parent is not None:\n                help_option_names = parent.help_option_names\n            else:\n                help_option_names = [\"--help\"]\n\n        #: The names for the help options.\n        self.help_option_names: list[str] = help_option_names\n\n        if token_normalize_func is None and parent is not None:\n            token_normalize_func = parent.token_normalize_func\n\n        #: An optional normalization function for tokens.  This is\n        #: options, choices, commands etc.\n        self.token_normalize_func: t.Callable[[str], str] | None = token_normalize_func\n\n        #: Indicates if resilient parsing is enabled.  In that case Click\n        #: will do its best to not cause any failures and default values\n        #: will be ignored. Useful for completion.\n        self.resilient_parsing: bool = resilient_parsing\n\n        # If there is no envvar prefix yet, but the parent has one and\n        # the command on this level has a name, we can expand the envvar\n        # prefix automatically.\n        if auto_envvar_prefix is None:\n            if (\n                parent is not None\n                and parent.auto_envvar_prefix is not None\n                and self.info_name is not None\n            ):\n                auto_envvar_prefix = (\n                    f\"{parent.auto_envvar_prefix}_{self.info_name.upper()}\"\n                )\n        else:\n            auto_envvar_prefix = auto_envvar_prefix.upper()\n\n        if auto_envvar_prefix is not None:\n            auto_envvar_prefix = auto_envvar_prefix.replace(\"-\", \"_\")\n\n        self.auto_envvar_prefix: str | None = auto_envvar_prefix\n\n        if color is None and parent is not None:\n            color = parent.color\n\n        #: Controls if styling output is wanted or not.\n        self.color: bool | None = color\n\n        if show_default is None and parent is not None:\n            show_default = parent.show_default\n\n        #: Show option default values when formatting help text.\n        self.show_default: bool | None = show_default\n\n        self._close_callbacks: list[t.Callable[[], t.Any]] = []\n        self._depth = 0\n        self._parameter_source: dict[str, ParameterSource] = {}\n        self._exit_stack = ExitStack()",
          "line_count": 169,
          "needs_llm_summary": true
        },
        {
          "name": "protected_args",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "list[str]",
          "lineno": 444,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "DeprecationWarning",
            "warnings.warn"
          ],
          "docstring": null,
          "code": "def protected_args(self) -> list[str]:\n        import warnings\n\n        warnings.warn(\n            \"'protected_args' is deprecated and will be removed in Click 9.0.\"\n            \" 'args' will contain remaining unparsed tokens.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self._protected_args",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 455,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.command.to_info_dict",
            "self"
          ],
          "docstring": "Gather information that could be useful for a tool generating\nuser-facing documentation. This traverses the entire CLI\nstructure.\n\n.. code-block:: python\n\n    with Context(cli) as ctx:\n        info = ctx.to_info_dict()\n\n.. versionadded:: 8.0",
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        \"\"\"Gather information that could be useful for a tool generating\n        user-facing documentation. This traverses the entire CLI\n        structure.\n\n        .. code-block:: python\n\n            with Context(cli) as ctx:\n                info = ctx.to_info_dict()\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return {\n            \"command\": self.command.to_info_dict(self),\n            \"info_name\": self.info_name,\n            \"allow_extra_args\": self.allow_extra_args,\n            \"allow_interspersed_args\": self.allow_interspersed_args,\n            \"ignore_unknown_options\": self.ignore_unknown_options,\n            \"auto_envvar_prefix\": self.auto_envvar_prefix,\n        }",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Context",
          "lineno": 476,
          "decorators": [],
          "is_async": false,
          "calls": [
            "push_context",
            "self"
          ],
          "docstring": null,
          "code": "def __enter__(self) -> Context:\n        self._depth += 1\n        push_context(self)\n        return self",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc_type",
              "type": "Any"
            },
            {
              "name": "exc_value",
              "type": "Any"
            },
            {
              "name": "tb",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 481,
          "decorators": [],
          "is_async": false,
          "calls": [
            "exc_type",
            "pop_context",
            "tb",
            "self._close_with_exception_info",
            "exc_value"
          ],
          "docstring": null,
          "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> bool | None:\n        self._depth -= 1\n        exit_result: bool | None = None\n        if self._depth == 0:\n            exit_result = self._close_with_exception_info(exc_type, exc_value, tb)\n        pop_context()\n\n        return exit_result",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "scope",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "cleanup",
              "type": "bool"
            }
          ],
          "return_type": "cabc.Iterator[Context]",
          "lineno": 496,
          "decorators": [
            {
              "name": "contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "This helper method can be used with the context object to promote\nit to the current thread local (see :func:`get_current_context`).\nThe default behavior of this is to invoke the cleanup functions which\ncan be disabled by setting `cleanup` to `False`.  The cleanup\nfunctions are typically used for things such as closing file handles.\n\nIf the cleanup is intended the context object can also be directly\nused as a context manager.\n\nExample usage::\n\n    with ctx.scope():\n        assert get_current_context() is ctx\n\nThis is equivalent::\n\n    with ctx:\n        assert get_current_context() is ctx\n\n.. versionadded:: 5.0\n\n:param cleanup: controls if the cleanup functions should be run or\n                not.  The default is to run these functions.  In\n                some situations the context only wants to be\n                temporarily pushed in which case this can be disabled.\n                Nested pushes automatically defer the cleanup.",
          "code": "def scope(self, cleanup: bool = True) -> cabc.Iterator[Context]:\n        \"\"\"This helper method can be used with the context object to promote\n        it to the current thread local (see :func:`get_current_context`).\n        The default behavior of this is to invoke the cleanup functions which\n        can be disabled by setting `cleanup` to `False`.  The cleanup\n        functions are typically used for things such as closing file handles.\n\n        If the cleanup is intended the context object can also be directly\n        used as a context manager.\n\n        Example usage::\n\n            with ctx.scope():\n                assert get_current_context() is ctx\n\n        This is equivalent::\n\n            with ctx:\n                assert get_current_context() is ctx\n\n        .. versionadded:: 5.0\n\n        :param cleanup: controls if the cleanup functions should be run or\n                        not.  The default is to run these functions.  In\n                        some situations the context only wants to be\n                        temporarily pushed in which case this can be disabled.\n                        Nested pushes automatically defer the cleanup.\n        \"\"\"\n        if not cleanup:\n            self._depth += 1\n        try:\n            with self as rv:\n                yield rv\n        finally:\n            if not cleanup:\n                self._depth -= 1",
          "line_count": 36,
          "needs_llm_summary": true
        },
        {
          "name": "meta",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 534,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "This is a dictionary which is shared with all the contexts\nthat are nested.  It exists so that click utilities can store some\nstate here if they need to.  It is however the responsibility of\nthat code to manage this dictionary well.\n\nThe keys are supposed to be unique dotted strings.  For instance\nmodule paths are a good choice for it.  What is stored in there is\nirrelevant for the operation of click.  However what is important is\nthat code that places data here adheres to the general semantics of\nthe system.\n\nExample usage::\n\n    LANG_KEY = f'{__name__}.lang'\n\n    def set_language(value):\n        ctx = get_current_context()\n        ctx.meta[LANG_KEY] = value\n\n    def get_language():\n        return get_current_context().meta.get(LANG_KEY, 'en_US')\n\n.. versionadded:: 5.0",
          "code": "def meta(self) -> dict[str, t.Any]:\n        \"\"\"This is a dictionary which is shared with all the contexts\n        that are nested.  It exists so that click utilities can store some\n        state here if they need to.  It is however the responsibility of\n        that code to manage this dictionary well.\n\n        The keys are supposed to be unique dotted strings.  For instance\n        module paths are a good choice for it.  What is stored in there is\n        irrelevant for the operation of click.  However what is important is\n        that code that places data here adheres to the general semantics of\n        the system.\n\n        Example usage::\n\n            LANG_KEY = f'{__name__}.lang'\n\n            def set_language(value):\n                ctx = get_current_context()\n                ctx.meta[LANG_KEY] = value\n\n            def get_language():\n                return get_current_context().meta.get(LANG_KEY, 'en_US')\n\n        .. versionadded:: 5.0\n        \"\"\"\n        return self._meta",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "make_formatter",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "HelpFormatter",
          "lineno": 561,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.max_content_width",
            "self.formatter_class",
            "self.terminal_width"
          ],
          "docstring": "Creates the :class:`~click.HelpFormatter` for the help and\nusage output.\n\nTo quickly customize the formatter class used without overriding\nthis method, set the :attr:`formatter_class` attribute.\n\n.. versionchanged:: 8.0\n    Added the :attr:`formatter_class` attribute.",
          "code": "def make_formatter(self) -> HelpFormatter:\n        \"\"\"Creates the :class:`~click.HelpFormatter` for the help and\n        usage output.\n\n        To quickly customize the formatter class used without overriding\n        this method, set the :attr:`formatter_class` attribute.\n\n        .. versionchanged:: 8.0\n            Added the :attr:`formatter_class` attribute.\n        \"\"\"\n        return self.formatter_class(\n            width=self.terminal_width, max_width=self.max_content_width\n        )",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "with_resource",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "context_manager",
              "type": "AbstractContextManager[V]"
            }
          ],
          "return_type": "V",
          "lineno": 575,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._exit_stack.enter_context",
            "context_manager"
          ],
          "docstring": "Register a resource as if it were used in a ``with``\nstatement. The resource will be cleaned up when the context is\npopped.\n\nUses :meth:`contextlib.ExitStack.enter_context`. It calls the\nresource's ``__enter__()`` method and returns the result. When\nthe context is popped, it closes the stack, which calls the\nresource's ``__exit__()`` method.\n\nTo register a cleanup function for something that isn't a\ncontext manager, use :meth:`call_on_close`. Or use something\nfrom :mod:`contextlib` to turn it into a context manager first.\n\n.. code-block:: python\n\n    @click.group()\n    @click.option(\"--name\")\n    @click.pass_context\n    def cli(ctx):\n        ctx.obj = ctx.with_resource(connect_db(name))\n\n:param context_manager: The context manager to enter.\n:return: Whatever ``context_manager.__enter__()`` returns.\n\n.. versionadded:: 8.0",
          "code": "def with_resource(self, context_manager: AbstractContextManager[V]) -> V:\n        \"\"\"Register a resource as if it were used in a ``with``\n        statement. The resource will be cleaned up when the context is\n        popped.\n\n        Uses :meth:`contextlib.ExitStack.enter_context`. It calls the\n        resource's ``__enter__()`` method and returns the result. When\n        the context is popped, it closes the stack, which calls the\n        resource's ``__exit__()`` method.\n\n        To register a cleanup function for something that isn't a\n        context manager, use :meth:`call_on_close`. Or use something\n        from :mod:`contextlib` to turn it into a context manager first.\n\n        .. code-block:: python\n\n            @click.group()\n            @click.option(\"--name\")\n            @click.pass_context\n            def cli(ctx):\n                ctx.obj = ctx.with_resource(connect_db(name))\n\n        :param context_manager: The context manager to enter.\n        :return: Whatever ``context_manager.__enter__()`` returns.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return self._exit_stack.enter_context(context_manager)",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "call_on_close",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "t.Callable[Ellipsis, t.Any]"
            }
          ],
          "return_type": "t.Callable[Ellipsis, t.Any]",
          "lineno": 604,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._exit_stack.callback",
            "f"
          ],
          "docstring": "Register a function to be called when the context tears down.\n\nThis can be used to close resources opened during the script\nexecution. Resources that support Python's context manager\nprotocol which would be used in a ``with`` statement should be\nregistered with :meth:`with_resource` instead.\n\n:param f: The function to execute on teardown.",
          "code": "def call_on_close(self, f: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:\n        \"\"\"Register a function to be called when the context tears down.\n\n        This can be used to close resources opened during the script\n        execution. Resources that support Python's context manager\n        protocol which would be used in a ``with`` statement should be\n        registered with :meth:`with_resource` instead.\n\n        :param f: The function to execute on teardown.\n        \"\"\"\n        return self._exit_stack.callback(f)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "close",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 616,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._close_with_exception_info"
          ],
          "docstring": "Invoke all close callbacks registered with\n:meth:`call_on_close`, and exit all context managers entered\nwith :meth:`with_resource`.",
          "code": "def close(self) -> None:\n        \"\"\"Invoke all close callbacks registered with\n        :meth:`call_on_close`, and exit all context managers entered\n        with :meth:`with_resource`.\n        \"\"\"\n        self._close_with_exception_info(None, None, None)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "_close_with_exception_info",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc_type",
              "type": "Any"
            },
            {
              "name": "exc_value",
              "type": "Any"
            },
            {
              "name": "tb",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 623,
          "decorators": [],
          "is_async": false,
          "calls": [
            "exc_type",
            "ExitStack",
            "tb",
            "exc_value",
            "self._exit_stack.__exit__"
          ],
          "docstring": "Unwind the exit stack by calling its :meth:`__exit__` providing the exception\ninformation to allow for exception handling by the various resources registered\nusing :meth;`with_resource`\n\n:return: Whatever ``exit_stack.__exit__()`` returns.",
          "code": "def _close_with_exception_info(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> bool | None:\n        \"\"\"Unwind the exit stack by calling its :meth:`__exit__` providing the exception\n        information to allow for exception handling by the various resources registered\n        using :meth;`with_resource`\n\n        :return: Whatever ``exit_stack.__exit__()`` returns.\n        \"\"\"\n        exit_result = self._exit_stack.__exit__(exc_type, exc_value, tb)\n        # In case the context is reused, create a new exit stack.\n        self._exit_stack = ExitStack()\n\n        return exit_result",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "command_path",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 642,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "parent_command_path.extend",
            "self",
            "unknown.join",
            "rv.lstrip",
            "self.parent.command.get_params",
            "self.info_name",
            "isinstance",
            "param.get_usage_pieces",
            "parent_command_path",
            "Command",
            "self.parent.command"
          ],
          "docstring": "The computed command path.  This is used for the ``usage``\ninformation on the help page.  It's automatically created by\ncombining the info names of the chain of contexts to the root.",
          "code": "def command_path(self) -> str:\n        \"\"\"The computed command path.  This is used for the ``usage``\n        information on the help page.  It's automatically created by\n        combining the info names of the chain of contexts to the root.\n        \"\"\"\n        rv = \"\"\n        if self.info_name is not None:\n            rv = self.info_name\n        if self.parent is not None:\n            parent_command_path = [self.parent.command_path]\n\n            if isinstance(self.parent.command, Command):\n                for param in self.parent.command.get_params(self):\n                    parent_command_path.extend(param.get_usage_pieces(self))\n\n            rv = f\"{' '.join(parent_command_path)} {rv}\"\n        return rv.lstrip()",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "find_root",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Context",
          "lineno": 660,
          "decorators": [],
          "is_async": false,
          "calls": [
            "node.parent",
            "self"
          ],
          "docstring": "Finds the outermost context.",
          "code": "def find_root(self) -> Context:\n        \"\"\"Finds the outermost context.\"\"\"\n        node = self\n        while node.parent is not None:\n            node = node.parent\n        return node",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "find_object",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "object_type",
              "type": "type[V]"
            }
          ],
          "return_type": "Any",
          "lineno": 667,
          "decorators": [],
          "is_async": false,
          "calls": [
            "object_type",
            "node.parent",
            "node.obj",
            "isinstance"
          ],
          "docstring": "Finds the closest object of a given type.",
          "code": "def find_object(self, object_type: type[V]) -> V | None:\n        \"\"\"Finds the closest object of a given type.\"\"\"\n        node: Context | None = self\n\n        while node is not None:\n            if isinstance(node.obj, object_type):\n                return node.obj\n\n            node = node.parent\n\n        return None",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "ensure_object",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "object_type",
              "type": "type[V]"
            }
          ],
          "return_type": "V",
          "lineno": 679,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.find_object",
            "object_type"
          ],
          "docstring": "Like :meth:`find_object` but sets the innermost object to a\nnew instance of `object_type` if it does not exist.",
          "code": "def ensure_object(self, object_type: type[V]) -> V:\n        \"\"\"Like :meth:`find_object` but sets the innermost object to a\n        new instance of `object_type` if it does not exist.\n        \"\"\"\n        rv = self.find_object(object_type)\n        if rv is None:\n            self.obj = rv = object_type()\n        return rv",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "lookup_default",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "call",
              "type": "t.Literal[True]"
            }
          ],
          "return_type": "Any",
          "lineno": 689,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def lookup_default(\n        self, name: str, call: t.Literal[True] = True\n    ) -> t.Any | None: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "lookup_default",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "call",
              "type": "t.Literal[False]"
            }
          ],
          "return_type": "Any",
          "lineno": 694,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def lookup_default(\n        self, name: str, call: t.Literal[False] = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "lookup_default",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "call",
              "type": "bool"
            }
          ],
          "return_type": "Any",
          "lineno": 698,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.default_map.get",
            "UNSET",
            "value",
            "name",
            "callable"
          ],
          "docstring": "Get the default for a parameter from :attr:`default_map`.\n\n:param name: Name of the parameter.\n:param call: If the default is a callable, call it. Disable to\n    return the callable instead.\n\n.. versionchanged:: 8.0\n    Added the ``call`` parameter.",
          "code": "def lookup_default(self, name: str, call: bool = True) -> t.Any | None:\n        \"\"\"Get the default for a parameter from :attr:`default_map`.\n\n        :param name: Name of the parameter.\n        :param call: If the default is a callable, call it. Disable to\n            return the callable instead.\n\n        .. versionchanged:: 8.0\n            Added the ``call`` parameter.\n        \"\"\"\n        if self.default_map is not None:\n            value = self.default_map.get(name, UNSET)\n\n            if call and callable(value):\n                return value()\n\n            return value\n\n        return UNSET",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "fail",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "message",
              "type": "str"
            }
          ],
          "return_type": "t.NoReturn",
          "lineno": 718,
          "decorators": [],
          "is_async": false,
          "calls": [
            "UsageError",
            "self",
            "message"
          ],
          "docstring": "Aborts the execution of the program with a specific error\nmessage.\n\n:param message: the error message to fail with.",
          "code": "def fail(self, message: str) -> t.NoReturn:\n        \"\"\"Aborts the execution of the program with a specific error\n        message.\n\n        :param message: the error message to fail with.\n        \"\"\"\n        raise UsageError(message, self)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "abort",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.NoReturn",
          "lineno": 726,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Abort"
          ],
          "docstring": "Aborts the script.",
          "code": "def abort(self) -> t.NoReturn:\n        \"\"\"Aborts the script.\"\"\"\n        raise Abort()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "exit",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "code",
              "type": "int"
            }
          ],
          "return_type": "t.NoReturn",
          "lineno": 730,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.close",
            "code",
            "Exit"
          ],
          "docstring": "Exits the application with a given exit code.\n\n.. versionchanged:: 8.2\n    Callbacks and context managers registered with :meth:`call_on_close`\n    and :meth:`with_resource` are closed before exiting.",
          "code": "def exit(self, code: int = 0) -> t.NoReturn:\n        \"\"\"Exits the application with a given exit code.\n\n        .. versionchanged:: 8.2\n            Callbacks and context managers registered with :meth:`call_on_close`\n            and :meth:`with_resource` are closed before exiting.\n        \"\"\"\n        self.close()\n        raise Exit(code)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "get_usage",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 740,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.command.get_usage",
            "self"
          ],
          "docstring": "Helper method to get formatted usage string for the current\ncontext and command.",
          "code": "def get_usage(self) -> str:\n        \"\"\"Helper method to get formatted usage string for the current\n        context and command.\n        \"\"\"\n        return self.command.get_usage(self)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "get_help",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 746,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.command.get_help",
            "self"
          ],
          "docstring": "Helper method to get formatted help page for the current\ncontext and command.",
          "code": "def get_help(self) -> str:\n        \"\"\"Helper method to get formatted help page for the current\n        context and command.\n        \"\"\"\n        return self.command.get_help(self)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "_make_sub_context",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "command",
              "type": "Command"
            }
          ],
          "return_type": "Context",
          "lineno": 752,
          "decorators": [],
          "is_async": false,
          "calls": [
            "command.name",
            "type",
            "command",
            "self"
          ],
          "docstring": "Create a new context of the same type as this context, but\nfor a new command.\n\n:meta private:",
          "code": "def _make_sub_context(self, command: Command) -> Context:\n        \"\"\"Create a new context of the same type as this context, but\n        for a new command.\n\n        :meta private:\n        \"\"\"\n        return type(self)(command, info_name=command.name, parent=self)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "invoke",
          "args": [],
          "return_type": "V",
          "lineno": 761,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def invoke(\n        self, callback: t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any\n    ) -> V: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "invoke",
          "args": [],
          "return_type": "t.Any",
          "lineno": 766,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def invoke(self, callback: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "invoke",
          "args": [],
          "return_type": "Any",
          "lineno": 768,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.params.update",
            "self",
            "ctx",
            "param.get_default",
            "param.type_cast_value",
            "other_cmd.callback",
            "callback",
            "t.cast",
            "TypeError",
            "isinstance",
            "default_value",
            "kwargs",
            "augment_usage_errors",
            "other_cmd",
            "self._make_sub_context",
            "Command"
          ],
          "docstring": "Invokes a command callback in exactly the way it expects.  There\nare two ways to invoke this method:\n\n1.  the first argument can be a callback and all other arguments and\n    keyword arguments are forwarded directly to the function.\n2.  the first argument is a click command object.  In that case all\n    arguments are forwarded as well but proper click parameters\n    (options and click arguments) must be keyword arguments and Click\n    will fill in defaults.\n\n.. versionchanged:: 8.0\n    All ``kwargs`` are tracked in :attr:`params` so they will be\n    passed if :meth:`forward` is called at multiple levels.\n\n.. versionchanged:: 3.2\n    A new context is created, and missing arguments use default values.",
          "code": "def invoke(\n        self, callback: Command | t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any\n    ) -> t.Any | V:\n        \"\"\"Invokes a command callback in exactly the way it expects.  There\n        are two ways to invoke this method:\n\n        1.  the first argument can be a callback and all other arguments and\n            keyword arguments are forwarded directly to the function.\n        2.  the first argument is a click command object.  In that case all\n            arguments are forwarded as well but proper click parameters\n            (options and click arguments) must be keyword arguments and Click\n            will fill in defaults.\n\n        .. versionchanged:: 8.0\n            All ``kwargs`` are tracked in :attr:`params` so they will be\n            passed if :meth:`forward` is called at multiple levels.\n\n        .. versionchanged:: 3.2\n            A new context is created, and missing arguments use default values.\n        \"\"\"\n        if isinstance(callback, Command):\n            other_cmd = callback\n\n            if other_cmd.callback is None:\n                raise TypeError(\n                    \"The given command does not have a callback that can be invoked.\"\n                )\n            else:\n                callback = t.cast(\"t.Callable[..., V]\", other_cmd.callback)\n\n            ctx = self._make_sub_context(other_cmd)\n\n            for param in other_cmd.params:\n                if param.name not in kwargs and param.expose_value:\n                    default_value = param.get_default(ctx)\n                    # We explicitly hide the :attr:`UNSET` value to the user, as we\n                    # choose to make it an implementation detail. And because ``invoke``\n                    # has been designed as part of Click public API, we return ``None``\n                    # instead. Refs:\n                    # https://github.com/pallets/click/issues/3066\n                    # https://github.com/pallets/click/issues/3065\n                    # https://github.com/pallets/click/pull/3068\n                    if default_value is UNSET:\n                        default_value = None\n                    kwargs[param.name] = param.type_cast_value(  # type: ignore\n                        ctx, default_value\n                    )\n\n            # Track all kwargs as params, so that forward() will pass\n            # them on in subsequent calls.\n            ctx.params.update(kwargs)\n        else:\n            ctx = self\n\n        with augment_usage_errors(self):\n            with ctx:\n                return callback(*args, **kwargs)",
          "line_count": 57,
          "needs_llm_summary": true
        },
        {
          "name": "forward",
          "args": [],
          "return_type": "t.Any",
          "lineno": 826,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.invoke",
            "TypeError",
            "isinstance",
            "kwargs",
            "Command",
            "cmd"
          ],
          "docstring": "Similar to :meth:`invoke` but fills in default keyword\narguments from the current context if the other command expects\nit.  This cannot invoke callbacks directly, only other commands.\n\n.. versionchanged:: 8.0\n    All ``kwargs`` are tracked in :attr:`params` so they will be\n    passed if ``forward`` is called at multiple levels.",
          "code": "def forward(self, cmd: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Similar to :meth:`invoke` but fills in default keyword\n        arguments from the current context if the other command expects\n        it.  This cannot invoke callbacks directly, only other commands.\n\n        .. versionchanged:: 8.0\n            All ``kwargs`` are tracked in :attr:`params` so they will be\n            passed if ``forward`` is called at multiple levels.\n        \"\"\"\n        # Can only forward to other commands, not direct callbacks.\n        if not isinstance(cmd, Command):\n            raise TypeError(\"Callback is not a command.\")\n\n        for param in self.params:\n            if param not in kwargs:\n                kwargs[param] = self.params[param]\n\n        return self.invoke(cmd, *args, **kwargs)",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "set_parameter_source",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "source",
              "type": "ParameterSource"
            }
          ],
          "return_type": "None",
          "lineno": 845,
          "decorators": [],
          "is_async": false,
          "calls": [
            "source"
          ],
          "docstring": "Set the source of a parameter. This indicates the location\nfrom which the value of the parameter was obtained.\n\n:param name: The name of the parameter.\n:param source: A member of :class:`~click.core.ParameterSource`.",
          "code": "def set_parameter_source(self, name: str, source: ParameterSource) -> None:\n        \"\"\"Set the source of a parameter. This indicates the location\n        from which the value of the parameter was obtained.\n\n        :param name: The name of the parameter.\n        :param source: A member of :class:`~click.core.ParameterSource`.\n        \"\"\"\n        self._parameter_source[name] = source",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "get_parameter_source",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "Any",
          "lineno": 854,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "self._parameter_source.get"
          ],
          "docstring": "Get the source of a parameter. This indicates the location\nfrom which the value of the parameter was obtained.\n\nThis can be useful for determining when a user specified a value\non the command line that is the same as the default value. It\nwill be :attr:`~click.core.ParameterSource.DEFAULT` only if the\nvalue was actually taken from the default.\n\n:param name: The name of the parameter.\n:rtype: ParameterSource\n\n.. versionchanged:: 8.0\n    Returns ``None`` if the parameter was not provided from any\n    source.",
          "code": "def get_parameter_source(self, name: str) -> ParameterSource | None:\n        \"\"\"Get the source of a parameter. This indicates the location\n        from which the value of the parameter was obtained.\n\n        This can be useful for determining when a user specified a value\n        on the command line that is the same as the default value. It\n        will be :attr:`~click.core.ParameterSource.DEFAULT` only if the\n        value was actually taken from the default.\n\n        :param name: The name of the parameter.\n        :rtype: ParameterSource\n\n        .. versionchanged:: 8.0\n            Returns ``None`` if the parameter was not provided from any\n            source.\n        \"\"\"\n        return self._parameter_source.get(name)",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "context_settings",
              "type": "Any"
            },
            {
              "name": "callback",
              "type": "Any"
            },
            {
              "name": "params",
              "type": "Any"
            },
            {
              "name": "help",
              "type": "Any"
            },
            {
              "name": "epilog",
              "type": "Any"
            },
            {
              "name": "short_help",
              "type": "Any"
            },
            {
              "name": "options_metavar",
              "type": "Any"
            },
            {
              "name": "add_help_option",
              "type": "bool"
            },
            {
              "name": "no_args_is_help",
              "type": "bool"
            },
            {
              "name": "hidden",
              "type": "bool"
            },
            {
              "name": "deprecated",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 935,
          "decorators": [],
          "is_async": false,
          "calls": [
            "options_metavar",
            "epilog",
            "no_args_is_help",
            "deprecated",
            "name",
            "callback",
            "short_help",
            "help",
            "add_help_option",
            "hidden"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        name: str | None,\n        context_settings: cabc.MutableMapping[str, t.Any] | None = None,\n        callback: t.Callable[..., t.Any] | None = None,\n        params: list[Parameter] | None = None,\n        help: str | None = None,\n        epilog: str | None = None,\n        short_help: str | None = None,\n        options_metavar: str | None = \"[OPTIONS]\",\n        add_help_option: bool = True,\n        no_args_is_help: bool = False,\n        hidden: bool = False,\n        deprecated: bool | str = False,\n    ) -> None:\n        #: the name the command thinks it has.  Upon registering a command\n        #: on a :class:`Group` the group will default the command name\n        #: with this information.  You should instead use the\n        #: :class:`Context`\\'s :attr:`~Context.info_name` attribute.\n        self.name = name\n\n        if context_settings is None:\n            context_settings = {}\n\n        #: an optional dictionary with defaults passed to the context.\n        self.context_settings: cabc.MutableMapping[str, t.Any] = context_settings\n\n        #: the callback to execute when the command fires.  This might be\n        #: `None` in which case nothing happens.\n        self.callback = callback\n        #: the list of parameters for this command in the order they\n        #: should show up in the help page and execute.  Eager parameters\n        #: will automatically be handled before non eager ones.\n        self.params: list[Parameter] = params or []\n        self.help = help\n        self.epilog = epilog\n        self.options_metavar = options_metavar\n        self.short_help = short_help\n        self.add_help_option = add_help_option\n        self._help_option = None\n        self.no_args_is_help = no_args_is_help\n        self.hidden = hidden\n        self.deprecated = deprecated",
          "line_count": 43,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 979,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "param.to_info_dict",
            "self.get_params"
          ],
          "docstring": null,
          "code": "def to_info_dict(self, ctx: Context) -> dict[str, t.Any]:\n        return {\n            \"name\": self.name,\n            \"params\": [param.to_info_dict() for param in self.get_params(ctx)],\n            \"help\": self.help,\n            \"epilog\": self.epilog,\n            \"short_help\": self.short_help,\n            \"hidden\": self.hidden,\n            \"deprecated\": self.deprecated,\n        }",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 990,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} {self.name}>\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_usage",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "str",
          "lineno": 993,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.format_usage",
            "formatter.getvalue",
            "ctx",
            "ctx.make_formatter",
            "formatter",
            "unknown.rstrip"
          ],
          "docstring": "Formats the usage line into a string and returns it.\n\nCalls :meth:`format_usage` internally.",
          "code": "def get_usage(self, ctx: Context) -> str:\n        \"\"\"Formats the usage line into a string and returns it.\n\n        Calls :meth:`format_usage` internally.\n        \"\"\"\n        formatter = ctx.make_formatter()\n        self.format_usage(ctx, formatter)\n        return formatter.getvalue().rstrip(\"\\n\")",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "get_params",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "list[Parameter]",
          "lineno": 1002,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.get_help_option",
            "opts_counter.items",
            "warnings.warn",
            "ctx",
            "opts",
            "Counter",
            "self.params"
          ],
          "docstring": null,
          "code": "def get_params(self, ctx: Context) -> list[Parameter]:\n        params = self.params\n        help_option = self.get_help_option(ctx)\n\n        if help_option is not None:\n            params = [*params, help_option]\n\n        if __debug__:\n            import warnings\n\n            opts = [opt for param in params for opt in param.opts]\n            opts_counter = Counter(opts)\n            duplicate_opts = (opt for opt, count in opts_counter.items() if count > 1)\n\n            for duplicate_opt in duplicate_opts:\n                warnings.warn(\n                    (\n                        f\"The parameter {duplicate_opt} is used more than once. \"\n                        \"Remove its duplicate as parameters should be unique.\"\n                    ),\n                    stacklevel=3,\n                )\n\n        return params",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "format_usage",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "formatter",
              "type": "HelpFormatter"
            }
          ],
          "return_type": "None",
          "lineno": 1027,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.join",
            "ctx.command_path",
            "ctx",
            "formatter.write_usage",
            "self.collect_usage_pieces",
            "pieces"
          ],
          "docstring": "Writes the usage line into the formatter.\n\nThis is a low-level method called by :meth:`get_usage`.",
          "code": "def format_usage(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the usage line into the formatter.\n\n        This is a low-level method called by :meth:`get_usage`.\n        \"\"\"\n        pieces = self.collect_usage_pieces(ctx)\n        formatter.write_usage(ctx.command_path, \" \".join(pieces))",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "collect_usage_pieces",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "list[str]",
          "lineno": 1035,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "param.get_usage_pieces",
            "rv.extend",
            "self.get_params"
          ],
          "docstring": "Returns all the pieces that go into the usage line and returns\nit as a list of strings.",
          "code": "def collect_usage_pieces(self, ctx: Context) -> list[str]:\n        \"\"\"Returns all the pieces that go into the usage line and returns\n        it as a list of strings.\n        \"\"\"\n        rv = [self.options_metavar] if self.options_metavar else []\n\n        for param in self.get_params(ctx):\n            rv.extend(param.get_usage_pieces(ctx))\n\n        return rv",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "get_help_option_names",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "list[str]",
          "lineno": 1046,
          "decorators": [],
          "is_async": false,
          "calls": [
            "param.opts",
            "set",
            "all_names.difference_update",
            "list",
            "param.secondary_opts",
            "ctx.help_option_names",
            "all_names"
          ],
          "docstring": "Returns the names for the help option.",
          "code": "def get_help_option_names(self, ctx: Context) -> list[str]:\n        \"\"\"Returns the names for the help option.\"\"\"\n        all_names = set(ctx.help_option_names)\n        for param in self.params:\n            all_names.difference_update(param.opts)\n            all_names.difference_update(param.secondary_opts)\n        return list(all_names)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "get_help_option",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 1054,
          "decorators": [],
          "is_async": false,
          "calls": [
            "help_option",
            "self",
            "ctx",
            "self.get_help_option_names",
            "self.params.pop"
          ],
          "docstring": "Returns the help option object.\n\nSkipped if :attr:`add_help_option` is ``False``.\n\n.. versionchanged:: 8.1.8\n    The help option is now cached to avoid creating it multiple times.",
          "code": "def get_help_option(self, ctx: Context) -> Option | None:\n        \"\"\"Returns the help option object.\n\n        Skipped if :attr:`add_help_option` is ``False``.\n\n        .. versionchanged:: 8.1.8\n            The help option is now cached to avoid creating it multiple times.\n        \"\"\"\n        help_option_names = self.get_help_option_names(ctx)\n\n        if not help_option_names or not self.add_help_option:\n            return None\n\n        # Cache the help option object in private _help_option attribute to\n        # avoid creating it multiple times. Not doing this will break the\n        # callback odering by iter_params_for_processing(), which relies on\n        # object comparison.\n        if self._help_option is None:\n            # Avoid circular import.\n            from .decorators import help_option\n\n            # Apply help_option decorator and pop resulting option\n            help_option(*help_option_names)(self)\n            self._help_option = self.params.pop()  # type: ignore[assignment]\n\n        return self._help_option",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "make_parser",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "_OptionParser",
          "lineno": 1081,
          "decorators": [],
          "is_async": false,
          "calls": [
            "param.add_to_parser",
            "self.get_params",
            "ctx",
            "parser",
            "_OptionParser"
          ],
          "docstring": "Creates the underlying option parser for this command.",
          "code": "def make_parser(self, ctx: Context) -> _OptionParser:\n        \"\"\"Creates the underlying option parser for this command.\"\"\"\n        parser = _OptionParser(ctx)\n        for param in self.get_params(ctx):\n            param.add_to_parser(parser, ctx)\n        return parser",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "get_help",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "str",
          "lineno": 1088,
          "decorators": [],
          "is_async": false,
          "calls": [
            "formatter.getvalue",
            "ctx",
            "ctx.make_formatter",
            "self.format_help",
            "formatter",
            "unknown.rstrip"
          ],
          "docstring": "Formats the help into a string and returns it.\n\nCalls :meth:`format_help` internally.",
          "code": "def get_help(self, ctx: Context) -> str:\n        \"\"\"Formats the help into a string and returns it.\n\n        Calls :meth:`format_help` internally.\n        \"\"\"\n        formatter = ctx.make_formatter()\n        self.format_help(ctx, formatter)\n        return formatter.getvalue().rstrip(\"\\n\")",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "get_short_help_str",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "limit",
              "type": "int"
            }
          ],
          "return_type": "str",
          "lineno": 1097,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "text.strip",
            "self.help",
            "str",
            "deprecated_message",
            "_",
            "make_default_short_help",
            "isinstance",
            "inspect.cleandoc",
            "limit",
            "self.short_help",
            "unknown.format",
            "self.deprecated"
          ],
          "docstring": "Gets short help for the command or makes it by shortening the\nlong help string.",
          "code": "def get_short_help_str(self, limit: int = 45) -> str:\n        \"\"\"Gets short help for the command or makes it by shortening the\n        long help string.\n        \"\"\"\n        if self.short_help:\n            text = inspect.cleandoc(self.short_help)\n        elif self.help:\n            text = make_default_short_help(self.help, limit)\n        else:\n            text = \"\"\n\n        if self.deprecated:\n            deprecated_message = (\n                f\"(DEPRECATED: {self.deprecated})\"\n                if isinstance(self.deprecated, str)\n                else \"(DEPRECATED)\"\n            )\n            text = _(\"{text} {deprecated_message}\").format(\n                text=text, deprecated_message=deprecated_message\n            )\n\n        return text.strip()",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "format_help",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "formatter",
              "type": "HelpFormatter"
            }
          ],
          "return_type": "None",
          "lineno": 1120,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.format_usage",
            "ctx",
            "self.format_options",
            "formatter",
            "self.format_help_text",
            "self.format_epilog"
          ],
          "docstring": "Writes the help into the formatter if it exists.\n\nThis is a low-level method called by :meth:`get_help`.\n\nThis calls the following methods:\n\n-   :meth:`format_usage`\n-   :meth:`format_help_text`\n-   :meth:`format_options`\n-   :meth:`format_epilog`",
          "code": "def format_help(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the help into the formatter if it exists.\n\n        This is a low-level method called by :meth:`get_help`.\n\n        This calls the following methods:\n\n        -   :meth:`format_usage`\n        -   :meth:`format_help_text`\n        -   :meth:`format_options`\n        -   :meth:`format_epilog`\n        \"\"\"\n        self.format_usage(ctx, formatter)\n        self.format_help_text(ctx, formatter)\n        self.format_options(ctx, formatter)\n        self.format_epilog(ctx, formatter)",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "format_help_text",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "formatter",
              "type": "HelpFormatter"
            }
          ],
          "return_type": "None",
          "lineno": 1137,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "formatter.write_text",
            "self.help",
            "formatter.indentation",
            "str",
            "deprecated_message",
            "_",
            "isinstance",
            "inspect.cleandoc",
            "formatter.write_paragraph",
            "unknown.format",
            "self.deprecated",
            "unknown.partition"
          ],
          "docstring": "Writes the help text to the formatter if it exists.",
          "code": "def format_help_text(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the help text to the formatter if it exists.\"\"\"\n        if self.help is not None:\n            # truncate the help text to the first form feed\n            text = inspect.cleandoc(self.help).partition(\"\\f\")[0]\n        else:\n            text = \"\"\n\n        if self.deprecated:\n            deprecated_message = (\n                f\"(DEPRECATED: {self.deprecated})\"\n                if isinstance(self.deprecated, str)\n                else \"(DEPRECATED)\"\n            )\n            text = _(\"{text} {deprecated_message}\").format(\n                text=text, deprecated_message=deprecated_message\n            )\n\n        if text:\n            formatter.write_paragraph()\n\n            with formatter.indentation():\n                formatter.write_text(text)",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "format_options",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "formatter",
              "type": "HelpFormatter"
            }
          ],
          "return_type": "None",
          "lineno": 1161,
          "decorators": [],
          "is_async": false,
          "calls": [
            "formatter.write_dl",
            "opts.append",
            "ctx",
            "self.get_params",
            "rv",
            "opts",
            "param.get_help_record",
            "_",
            "formatter.section"
          ],
          "docstring": "Writes all the options into the formatter if they exist.",
          "code": "def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes all the options into the formatter if they exist.\"\"\"\n        opts = []\n        for param in self.get_params(ctx):\n            rv = param.get_help_record(ctx)\n            if rv is not None:\n                opts.append(rv)\n\n        if opts:\n            with formatter.section(_(\"Options\")):\n                formatter.write_dl(opts)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "format_epilog",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "formatter",
              "type": "HelpFormatter"
            }
          ],
          "return_type": "None",
          "lineno": 1173,
          "decorators": [],
          "is_async": false,
          "calls": [
            "formatter.write_text",
            "epilog",
            "formatter.indentation",
            "inspect.cleandoc",
            "formatter.write_paragraph",
            "self.epilog"
          ],
          "docstring": "Writes the epilog into the formatter if it exists.",
          "code": "def format_epilog(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Writes the epilog into the formatter if it exists.\"\"\"\n        if self.epilog:\n            epilog = inspect.cleandoc(self.epilog)\n            formatter.write_paragraph()\n\n            with formatter.indentation():\n                formatter.write_text(epilog)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "make_context",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "info_name",
              "type": "Any"
            },
            {
              "name": "args",
              "type": "list[str]"
            },
            {
              "name": "parent",
              "type": "Any"
            }
          ],
          "return_type": "Context",
          "lineno": 1182,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.context_class",
            "self",
            "parent",
            "value",
            "ctx",
            "self.context_settings.items",
            "self.parse_args",
            "args",
            "ctx.scope",
            "extra",
            "info_name"
          ],
          "docstring": "This function when given an info name and arguments will kick\noff the parsing and create a new :class:`Context`.  It does not\ninvoke the actual command callback though.\n\nTo quickly customize the context class used without overriding\nthis method, set the :attr:`context_class` attribute.\n\n:param info_name: the info name for this invocation.  Generally this\n                  is the most descriptive name for the script or\n                  command.  For the toplevel script it's usually\n                  the name of the script, for commands below it's\n                  the name of the command.\n:param args: the arguments to parse as list of strings.\n:param parent: the parent context if available.\n:param extra: extra keyword arguments forwarded to the context\n              constructor.\n\n.. versionchanged:: 8.0\n    Added the :attr:`context_class` attribute.",
          "code": "def make_context(\n        self,\n        info_name: str | None,\n        args: list[str],\n        parent: Context | None = None,\n        **extra: t.Any,\n    ) -> Context:\n        \"\"\"This function when given an info name and arguments will kick\n        off the parsing and create a new :class:`Context`.  It does not\n        invoke the actual command callback though.\n\n        To quickly customize the context class used without overriding\n        this method, set the :attr:`context_class` attribute.\n\n        :param info_name: the info name for this invocation.  Generally this\n                          is the most descriptive name for the script or\n                          command.  For the toplevel script it's usually\n                          the name of the script, for commands below it's\n                          the name of the command.\n        :param args: the arguments to parse as list of strings.\n        :param parent: the parent context if available.\n        :param extra: extra keyword arguments forwarded to the context\n                      constructor.\n\n        .. versionchanged:: 8.0\n            Added the :attr:`context_class` attribute.\n        \"\"\"\n        for key, value in self.context_settings.items():\n            if key not in extra:\n                extra[key] = value\n\n        ctx = self.context_class(self, info_name=info_name, parent=parent, **extra)\n\n        with ctx.scope(cleanup=False):\n            self.parse_args(ctx, args)\n        return ctx",
          "line_count": 36,
          "needs_llm_summary": true
        },
        {
          "name": "parse_args",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "args",
              "type": "list[str]"
            }
          ],
          "return_type": "list[str]",
          "lineno": 1219,
          "decorators": [],
          "is_async": false,
          "calls": [
            "iter_params_for_processing",
            "param_order",
            "ctx",
            "len",
            "ctx._opt_prefixes.update",
            "ctx.params.items",
            "opts",
            "self.make_parser",
            "unknown.format",
            "NoArgsIsHelpError",
            "param.handle_parse_result",
            "parser.parse_args",
            "self.get_params",
            "str",
            "ctx.fail",
            "args",
            "parser._opt_prefixes",
            "unknown.join",
            "ngettext",
            "map"
          ],
          "docstring": null,
          "code": "def parse_args(self, ctx: Context, args: list[str]) -> list[str]:\n        if not args and self.no_args_is_help and not ctx.resilient_parsing:\n            raise NoArgsIsHelpError(ctx)\n\n        parser = self.make_parser(ctx)\n        opts, args, param_order = parser.parse_args(args=args)\n\n        for param in iter_params_for_processing(param_order, self.get_params(ctx)):\n            _, args = param.handle_parse_result(ctx, opts, args)\n\n        # We now have all parameters' values into `ctx.params`, but the data may contain\n        # the `UNSET` sentinel.\n        # Convert `UNSET` to `None` to ensure that the user doesn't see `UNSET`.\n        #\n        # Waiting until after the initial parse to convert allows us to treat `UNSET`\n        # more like a missing value when multiple params use the same name.\n        # Refs:\n        # https://github.com/pallets/click/issues/3071\n        # https://github.com/pallets/click/pull/3079\n        for name, value in ctx.params.items():\n            if value is UNSET:\n                ctx.params[name] = None\n\n        if args and not ctx.allow_extra_args and not ctx.resilient_parsing:\n            ctx.fail(\n                ngettext(\n                    \"Got unexpected extra argument ({args})\",\n                    \"Got unexpected extra arguments ({args})\",\n                    len(args),\n                ).format(args=\" \".join(map(str, args)))\n            )\n\n        ctx.args = args\n        ctx._opt_prefixes.update(parser._opt_prefixes)\n        return args",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "invoke",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "t.Any",
          "lineno": 1255,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "unknown.format",
            "message",
            "str",
            "self.name",
            "_",
            "ctx.params",
            "extra_message",
            "isinstance",
            "self.callback",
            "style",
            "ctx.invoke",
            "self.deprecated"
          ],
          "docstring": "Given a context, this invokes the attached callback (if it exists)\nin the right way.",
          "code": "def invoke(self, ctx: Context) -> t.Any:\n        \"\"\"Given a context, this invokes the attached callback (if it exists)\n        in the right way.\n        \"\"\"\n        if self.deprecated:\n            extra_message = (\n                f\" {self.deprecated}\" if isinstance(self.deprecated, str) else \"\"\n            )\n            message = _(\n                \"DeprecationWarning: The command {name!r} is deprecated.{extra_message}\"\n            ).format(name=self.name, extra_message=extra_message)\n            echo(style(message, fg=\"red\"), err=True)\n\n        if self.callback is not None:\n            return ctx.invoke(self.callback, **ctx.params)",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "shell_complete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "list[CompletionItem]",
          "lineno": 1271,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "param.name",
            "ctx.parent",
            "unknown.isalnum",
            "isinstance",
            "param.help",
            "Group",
            "incomplete",
            "ctx.get_parameter_source",
            "name",
            "results.extend",
            "CompletionItem",
            "self.get_params",
            "param",
            "Option",
            "ctx.command",
            "_complete_visible_commands",
            "name.startswith",
            "command.get_short_help_str"
          ],
          "docstring": "Return a list of completions for the incomplete value. Looks\nat the names of options and chained multi-commands.\n\nAny command could be part of a chained multi-command, so sibling\ncommands are valid at any point during command completion.\n\n:param ctx: Invocation context for this command.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
          "code": "def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of completions for the incomplete value. Looks\n        at the names of options and chained multi-commands.\n\n        Any command could be part of a chained multi-command, so sibling\n        commands are valid at any point during command completion.\n\n        :param ctx: Invocation context for this command.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        results: list[CompletionItem] = []\n\n        if incomplete and not incomplete[0].isalnum():\n            for param in self.get_params(ctx):\n                if (\n                    not isinstance(param, Option)\n                    or param.hidden\n                    or (\n                        not param.multiple\n                        and ctx.get_parameter_source(param.name)  # type: ignore\n                        is ParameterSource.COMMANDLINE\n                    )\n                ):\n                    continue\n\n                results.extend(\n                    CompletionItem(name, help=param.help)\n                    for name in [*param.opts, *param.secondary_opts]\n                    if name.startswith(incomplete)\n                )\n\n        while ctx.parent is not None:\n            ctx = ctx.parent\n\n            if isinstance(ctx.command, Group) and ctx.command.chain:\n                results.extend(\n                    CompletionItem(name, help=command.get_short_help_str())\n                    for name, command in _complete_visible_commands(ctx, incomplete)\n                    if name not in ctx._protected_args\n                )\n\n        return results",
          "line_count": 46,
          "needs_llm_summary": true
        },
        {
          "name": "main",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "args",
              "type": "Any"
            },
            {
              "name": "prog_name",
              "type": "Any"
            },
            {
              "name": "complete_var",
              "type": "Any"
            },
            {
              "name": "standalone_mode",
              "type": "t.Literal[True]"
            }
          ],
          "return_type": "t.NoReturn",
          "lineno": 1319,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def main(\n        self,\n        args: cabc.Sequence[str] | None = None,\n        prog_name: str | None = None,\n        complete_var: str | None = None,\n        standalone_mode: t.Literal[True] = True,\n        **extra: t.Any,\n    ) -> t.NoReturn: ...",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "main",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "args",
              "type": "Any"
            },
            {
              "name": "prog_name",
              "type": "Any"
            },
            {
              "name": "complete_var",
              "type": "Any"
            },
            {
              "name": "standalone_mode",
              "type": "bool"
            }
          ],
          "return_type": "t.Any",
          "lineno": 1329,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def main(\n        self,\n        args: cabc.Sequence[str] | None = None,\n        prog_name: str | None = None,\n        complete_var: str | None = None,\n        standalone_mode: bool = ...,\n        **extra: t.Any,\n    ) -> t.Any: ...",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "main",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "args",
              "type": "Any"
            },
            {
              "name": "prog_name",
              "type": "Any"
            },
            {
              "name": "complete_var",
              "type": "Any"
            },
            {
              "name": "standalone_mode",
              "type": "bool"
            },
            {
              "name": "windows_expand_args",
              "type": "bool"
            }
          ],
          "return_type": "t.Any",
          "lineno": 1338,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "t.TextIO",
            "e.exit_code",
            "ctx",
            "PacifyFlushWrapper",
            "sys.exit",
            "extra",
            "self.make_context",
            "_expand_args",
            "_",
            "self.invoke",
            "Abort",
            "complete_var",
            "sys.stderr",
            "ctx.exit",
            "self._main_shell_completion",
            "args",
            "sys.stdout",
            "list",
            "t.cast",
            "_detect_program_name",
            "prog_name",
            "e.show"
          ],
          "docstring": "This is the way to invoke a script with all the bells and\nwhistles as a command line application.  This will always terminate\nthe application after a call.  If this is not wanted, ``SystemExit``\nneeds to be caught.\n\nThis method is also available by directly calling the instance of\na :class:`Command`.\n\n:param args: the arguments that should be used for parsing.  If not\n             provided, ``sys.argv[1:]`` is used.\n:param prog_name: the program name that should be used.  By default\n                  the program name is constructed by taking the file\n                  name from ``sys.argv[0]``.\n:param complete_var: the environment variable that controls the\n                     bash completion support.  The default is\n                     ``\"_<prog_name>_COMPLETE\"`` with prog_name in\n                     uppercase.\n:param standalone_mode: the default behavior is to invoke the script\n                        in standalone mode.  Click will then\n                        handle exceptions and convert them into\n                        error messages and the function will never\n                        return but shut down the interpreter.  If\n                        this is set to `False` they will be\n                        propagated to the caller and the return\n                        value of this function is the return value\n                        of :meth:`invoke`.\n:param windows_expand_args: Expand glob patterns, user dir, and\n    env vars in command line args on Windows.\n:param extra: extra keyword arguments are forwarded to the context\n              constructor.  See :class:`Context` for more information.\n\n.. versionchanged:: 8.0.1\n    Added the ``windows_expand_args`` parameter to allow\n    disabling command line arg expansion on Windows.\n\n.. versionchanged:: 8.0\n    When taking arguments from ``sys.argv`` on Windows, glob\n    patterns, user dir, and env vars are expanded.\n\n.. versionchanged:: 3.0\n   Added the ``standalone_mode`` parameter.",
          "code": "def main(\n        self,\n        args: cabc.Sequence[str] | None = None,\n        prog_name: str | None = None,\n        complete_var: str | None = None,\n        standalone_mode: bool = True,\n        windows_expand_args: bool = True,\n        **extra: t.Any,\n    ) -> t.Any:\n        \"\"\"This is the way to invoke a script with all the bells and\n        whistles as a command line application.  This will always terminate\n        the application after a call.  If this is not wanted, ``SystemExit``\n        needs to be caught.\n\n        This method is also available by directly calling the instance of\n        a :class:`Command`.\n\n        :param args: the arguments that should be used for parsing.  If not\n                     provided, ``sys.argv[1:]`` is used.\n        :param prog_name: the program name that should be used.  By default\n                          the program name is constructed by taking the file\n                          name from ``sys.argv[0]``.\n        :param complete_var: the environment variable that controls the\n                             bash completion support.  The default is\n                             ``\"_<prog_name>_COMPLETE\"`` with prog_name in\n                             uppercase.\n        :param standalone_mode: the default behavior is to invoke the script\n                                in standalone mode.  Click will then\n                                handle exceptions and convert them into\n                                error messages and the function will never\n                                return but shut down the interpreter.  If\n                                this is set to `False` they will be\n                                propagated to the caller and the return\n                                value of this function is the return value\n                                of :meth:`invoke`.\n        :param windows_expand_args: Expand glob patterns, user dir, and\n            env vars in command line args on Windows.\n        :param extra: extra keyword arguments are forwarded to the context\n                      constructor.  See :class:`Context` for more information.\n\n        .. versionchanged:: 8.0.1\n            Added the ``windows_expand_args`` parameter to allow\n            disabling command line arg expansion on Windows.\n\n        .. versionchanged:: 8.0\n            When taking arguments from ``sys.argv`` on Windows, glob\n            patterns, user dir, and env vars are expanded.\n\n        .. versionchanged:: 3.0\n           Added the ``standalone_mode`` parameter.\n        \"\"\"\n        if args is None:\n            args = sys.argv[1:]\n\n            if os.name == \"nt\" and windows_expand_args:\n                args = _expand_args(args)\n        else:\n            args = list(args)\n\n        if prog_name is None:\n            prog_name = _detect_program_name()\n\n        # Process shell completion requests and exit early.\n        self._main_shell_completion(extra, prog_name, complete_var)\n\n        try:\n            try:\n                with self.make_context(prog_name, args, **extra) as ctx:\n                    rv = self.invoke(ctx)\n                    if not standalone_mode:\n                        return rv\n                    # it's not safe to `ctx.exit(rv)` here!\n                    # note that `rv` may actually contain data like \"1\" which\n                    # has obvious effects\n                    # more subtle case: `rv=[None, None]` can come out of\n                    # chained commands which all returned `None` -- so it's not\n                    # even always obvious that `rv` indicates success/failure\n                    # by its truthiness/falsiness\n                    ctx.exit()\n            except (EOFError, KeyboardInterrupt) as e:\n                echo(file=sys.stderr)\n                raise Abort() from e\n            except ClickException as e:\n                if not standalone_mode:\n                    raise\n                e.show()\n                sys.exit(e.exit_code)\n            except OSError as e:\n                if e.errno == errno.EPIPE:\n                    sys.stdout = t.cast(t.TextIO, PacifyFlushWrapper(sys.stdout))\n                    sys.stderr = t.cast(t.TextIO, PacifyFlushWrapper(sys.stderr))\n                    sys.exit(1)\n                else:\n                    raise\n        except Exit as e:\n            if standalone_mode:\n                sys.exit(e.exit_code)\n            else:\n                # in non-standalone mode, return the exit code\n                # note that this is only reached if `self.invoke` above raises\n                # an Exit explicitly -- thus bypassing the check there which\n                # would return its result\n                # the results of non-standalone execution may therefore be\n                # somewhat ambiguous: if there are codepaths which lead to\n                # `ctx.exit(1)` and to `return 1`, the caller won't be able to\n                # tell the difference between the two\n                return e.exit_code\n        except Abort:\n            if not standalone_mode:\n                raise\n            echo(_(\"Aborted!\"), file=sys.stderr)\n            sys.exit(1)",
          "line_count": 112,
          "needs_llm_summary": true
        },
        {
          "name": "_main_shell_completion",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx_args",
              "type": "cabc.MutableMapping[str, t.Any]"
            },
            {
              "name": "prog_name",
              "type": "str"
            },
            {
              "name": "complete_var",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 1451,
          "decorators": [],
          "is_async": false,
          "calls": [
            "shell_complete",
            "os.environ.get",
            "self",
            "prog_name.replace",
            "rv",
            "prog_name",
            "unknown.upper",
            "ctx_args",
            "instruction",
            "unknown.replace",
            "sys.exit",
            "complete_var"
          ],
          "docstring": "Check if the shell is asking for tab completion, process\nthat, then exit early. Called from :meth:`main` before the\nprogram is invoked.\n\n:param prog_name: Name of the executable in the shell.\n:param complete_var: Name of the environment variable that holds\n    the completion instruction. Defaults to\n    ``_{PROG_NAME}_COMPLETE``.\n\n.. versionchanged:: 8.2.0\n    Dots (``.``) in ``prog_name`` are replaced with underscores (``_``).",
          "code": "def _main_shell_completion(\n        self,\n        ctx_args: cabc.MutableMapping[str, t.Any],\n        prog_name: str,\n        complete_var: str | None = None,\n    ) -> None:\n        \"\"\"Check if the shell is asking for tab completion, process\n        that, then exit early. Called from :meth:`main` before the\n        program is invoked.\n\n        :param prog_name: Name of the executable in the shell.\n        :param complete_var: Name of the environment variable that holds\n            the completion instruction. Defaults to\n            ``_{PROG_NAME}_COMPLETE``.\n\n        .. versionchanged:: 8.2.0\n            Dots (``.``) in ``prog_name`` are replaced with underscores (``_``).\n        \"\"\"\n        if complete_var is None:\n            complete_name = prog_name.replace(\"-\", \"_\").replace(\".\", \"_\")\n            complete_var = f\"_{complete_name}_COMPLETE\".upper()\n\n        instruction = os.environ.get(complete_var)\n\n        if not instruction:\n            return\n\n        from .shell_completion import shell_complete\n\n        rv = shell_complete(self, ctx_args, prog_name, complete_var, instruction)\n        sys.exit(rv)",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "__call__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Any",
          "lineno": 1483,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.main",
            "kwargs"
          ],
          "docstring": "Alias for :meth:`main`.",
          "code": "def __call__(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Alias for :meth:`main`.\"\"\"\n        return self.main(*args, **kwargs)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__subclasscheck__",
          "args": [
            {
              "name": "cls"
            },
            {
              "name": "subclass",
              "type": "type"
            }
          ],
          "return_type": "bool",
          "lineno": 1489,
          "decorators": [],
          "is_async": false,
          "calls": [
            "subclass",
            "issubclass"
          ],
          "docstring": null,
          "code": "def __subclasscheck__(cls, subclass: type) -> bool:\n        return issubclass(subclass, cls.__bases__[0])",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__instancecheck__",
          "args": [
            {
              "name": "cls"
            },
            {
              "name": "instance",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 1492,
          "decorators": [],
          "is_async": false,
          "calls": [
            "instance",
            "isinstance"
          ],
          "docstring": null,
          "code": "def __instancecheck__(cls, instance: t.Any) -> bool:\n        return isinstance(instance, cls.__bases__[0])",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "commands",
              "type": "Any"
            },
            {
              "name": "invoke_without_command",
              "type": "bool"
            },
            {
              "name": "no_args_is_help",
              "type": "Any"
            },
            {
              "name": "subcommand_metavar",
              "type": "Any"
            },
            {
              "name": "chain",
              "type": "bool"
            },
            {
              "name": "result_callback",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 1556,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Argument",
            "subcommand_metavar",
            "no_args_is_help",
            "result_callback",
            "param",
            "unknown.__init__",
            "name",
            "RuntimeError",
            "isinstance",
            "chain",
            "commands",
            "kwargs",
            "abc.Sequence",
            "super",
            "invoke_without_command"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        name: str | None = None,\n        commands: cabc.MutableMapping[str, Command]\n        | cabc.Sequence[Command]\n        | None = None,\n        invoke_without_command: bool = False,\n        no_args_is_help: bool | None = None,\n        subcommand_metavar: str | None = None,\n        chain: bool = False,\n        result_callback: t.Callable[..., t.Any] | None = None,\n        **kwargs: t.Any,\n    ) -> None:\n        super().__init__(name, **kwargs)\n\n        if commands is None:\n            commands = {}\n        elif isinstance(commands, abc.Sequence):\n            commands = {c.name: c for c in commands if c.name is not None}\n\n        #: The registered subcommands by their exported names.\n        self.commands: cabc.MutableMapping[str, Command] = commands\n\n        if no_args_is_help is None:\n            no_args_is_help = not invoke_without_command\n\n        self.no_args_is_help = no_args_is_help\n        self.invoke_without_command = invoke_without_command\n\n        if subcommand_metavar is None:\n            if chain:\n                subcommand_metavar = \"COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]...\"\n            else:\n                subcommand_metavar = \"COMMAND [ARGS]...\"\n\n        self.subcommand_metavar = subcommand_metavar\n        self.chain = chain\n        # The result callback that is stored. This can be set or\n        # overridden with the :func:`result_callback` decorator.\n        self._result_callback = result_callback\n\n        if self.chain:\n            for param in self.params:\n                if isinstance(param, Argument) and not param.required:\n                    raise RuntimeError(\n                        \"A group in chain mode cannot have optional arguments.\"\n                    )",
          "line_count": 47,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 1604,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "self.chain",
            "unknown.to_info_dict",
            "self.get_command",
            "name",
            "command",
            "command.to_info_dict",
            "sub_ctx",
            "commands",
            "super",
            "info_dict.update",
            "ctx._make_sub_context",
            "self.list_commands",
            "sub_ctx.scope"
          ],
          "docstring": null,
          "code": "def to_info_dict(self, ctx: Context) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict(ctx)\n        commands = {}\n\n        for name in self.list_commands(ctx):\n            command = self.get_command(ctx, name)\n\n            if command is None:\n                continue\n\n            sub_ctx = ctx._make_sub_context(command)\n\n            with sub_ctx.scope(cleanup=False):\n                commands[name] = command.to_info_dict(sub_ctx)\n\n        info_dict.update(commands=commands, chain=self.chain)\n        return info_dict",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "add_command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "cmd",
              "type": "Command"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 1622,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "name",
            "_check_nested_chain",
            "TypeError",
            "cmd"
          ],
          "docstring": "Registers another :class:`Command` with this group.  If the name\nis not provided, the name of the command is used.",
          "code": "def add_command(self, cmd: Command, name: str | None = None) -> None:\n        \"\"\"Registers another :class:`Command` with this group.  If the name\n        is not provided, the name of the command is used.\n        \"\"\"\n        name = name or cmd.name\n        if name is None:\n            raise TypeError(\"Command has no name.\")\n        _check_nested_chain(self, name, cmd, register=True)\n        self.commands[name] = cmd",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "__func",
              "type": "t.Callable[Ellipsis, t.Any]"
            }
          ],
          "return_type": "Command",
          "lineno": 1633,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def command(self, __func: t.Callable[..., t.Any]) -> Command: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "command",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Callable[Any, Command]",
          "lineno": 1636,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def command(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Command]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "command",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 1640,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.add_command",
            "decorator",
            "len",
            "f",
            "command",
            "func",
            "self.command_class",
            "args",
            "kwargs",
            "callable",
            "cmd",
            "kwargs.get"
          ],
          "docstring": "A shortcut decorator for declaring and attaching a command to\nthe group. This takes the same arguments as :func:`command` and\nimmediately registers the created command with this group by\ncalling :meth:`add_command`.\n\nTo customize the command class used, set the\n:attr:`command_class` attribute.\n\n.. versionchanged:: 8.1\n    This decorator can be applied without parentheses.\n\n.. versionchanged:: 8.0\n    Added the :attr:`command_class` attribute.",
          "code": "def command(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Command] | Command:\n        \"\"\"A shortcut decorator for declaring and attaching a command to\n        the group. This takes the same arguments as :func:`command` and\n        immediately registers the created command with this group by\n        calling :meth:`add_command`.\n\n        To customize the command class used, set the\n        :attr:`command_class` attribute.\n\n        .. versionchanged:: 8.1\n            This decorator can be applied without parentheses.\n\n        .. versionchanged:: 8.0\n            Added the :attr:`command_class` attribute.\n        \"\"\"\n        from .decorators import command\n\n        func: t.Callable[..., t.Any] | None = None\n\n        if args and callable(args[0]):\n            assert len(args) == 1 and not kwargs, (\n                \"Use 'command(**kwargs)(callable)' to provide arguments.\"\n            )\n            (func,) = args\n            args = ()\n\n        if self.command_class and kwargs.get(\"cls\") is None:\n            kwargs[\"cls\"] = self.command_class\n\n        def decorator(f: t.Callable[..., t.Any]) -> Command:\n            cmd: Command = command(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return cmd\n\n        if func is not None:\n            return decorator(func)\n\n        return decorator",
          "line_count": 40,
          "needs_llm_summary": true
        },
        {
          "name": "group",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "__func",
              "type": "t.Callable[Ellipsis, t.Any]"
            }
          ],
          "return_type": "Group",
          "lineno": 1682,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def group(self, __func: t.Callable[..., t.Any]) -> Group: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "group",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Callable[Any, Group]",
          "lineno": 1685,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def group(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Group]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "group",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 1689,
          "decorators": [],
          "is_async": false,
          "calls": [
            "type",
            "self.add_command",
            "self",
            "decorator",
            "len",
            "f",
            "group",
            "func",
            "args",
            "kwargs",
            "callable",
            "kwargs.get",
            "cmd",
            "self.group_class"
          ],
          "docstring": "A shortcut decorator for declaring and attaching a group to\nthe group. This takes the same arguments as :func:`group` and\nimmediately registers the created group with this group by\ncalling :meth:`add_command`.\n\nTo customize the group class used, set the :attr:`group_class`\nattribute.\n\n.. versionchanged:: 8.1\n    This decorator can be applied without parentheses.\n\n.. versionchanged:: 8.0\n    Added the :attr:`group_class` attribute.",
          "code": "def group(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], Group] | Group:\n        \"\"\"A shortcut decorator for declaring and attaching a group to\n        the group. This takes the same arguments as :func:`group` and\n        immediately registers the created group with this group by\n        calling :meth:`add_command`.\n\n        To customize the group class used, set the :attr:`group_class`\n        attribute.\n\n        .. versionchanged:: 8.1\n            This decorator can be applied without parentheses.\n\n        .. versionchanged:: 8.0\n            Added the :attr:`group_class` attribute.\n        \"\"\"\n        from .decorators import group\n\n        func: t.Callable[..., t.Any] | None = None\n\n        if args and callable(args[0]):\n            assert len(args) == 1 and not kwargs, (\n                \"Use 'group(**kwargs)(callable)' to provide arguments.\"\n            )\n            (func,) = args\n            args = ()\n\n        if self.group_class is not None and kwargs.get(\"cls\") is None:\n            if self.group_class is type:\n                kwargs[\"cls\"] = type(self)\n            else:\n                kwargs[\"cls\"] = self.group_class\n\n        def decorator(f: t.Callable[..., t.Any]) -> Group:\n            cmd: Group = group(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return cmd\n\n        if func is not None:\n            return decorator(func)\n\n        return decorator",
          "line_count": 43,
          "needs_llm_summary": true
        },
        {
          "name": "result_callback",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "replace",
              "type": "bool"
            }
          ],
          "return_type": "t.Callable[Any, F]",
          "lineno": 1733,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "old_callback",
            "f",
            "t.cast",
            "function",
            "update_wrapper",
            "kwargs",
            "inner",
            "F",
            "self._result_callback"
          ],
          "docstring": "Adds a result callback to the command.  By default if a\nresult callback is already registered this will chain them but\nthis can be disabled with the `replace` parameter.  The result\ncallback is invoked with the return value of the subcommand\n(or the list of return values from all subcommands if chaining\nis enabled) as well as the parameters as they would be passed\nto the main callback.\n\nExample::\n\n    @click.group()\n    @click.option('-i', '--input', default=23)\n    def cli(input):\n        return 42\n\n    @cli.result_callback()\n    def process_result(result, input):\n        return result + input\n\n:param replace: if set to `True` an already existing result\n                callback will be removed.\n\n.. versionchanged:: 8.0\n    Renamed from ``resultcallback``.\n\n.. versionadded:: 3.0",
          "code": "def result_callback(self, replace: bool = False) -> t.Callable[[F], F]:\n        \"\"\"Adds a result callback to the command.  By default if a\n        result callback is already registered this will chain them but\n        this can be disabled with the `replace` parameter.  The result\n        callback is invoked with the return value of the subcommand\n        (or the list of return values from all subcommands if chaining\n        is enabled) as well as the parameters as they would be passed\n        to the main callback.\n\n        Example::\n\n            @click.group()\n            @click.option('-i', '--input', default=23)\n            def cli(input):\n                return 42\n\n            @cli.result_callback()\n            def process_result(result, input):\n                return result + input\n\n        :param replace: if set to `True` an already existing result\n                        callback will be removed.\n\n        .. versionchanged:: 8.0\n            Renamed from ``resultcallback``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            old_callback = self._result_callback\n\n            if old_callback is None or replace:\n                self._result_callback = f\n                return f\n\n            def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n                inner = old_callback(value, *args, **kwargs)\n                return f(inner, *args, **kwargs)\n\n            self._result_callback = rv = update_wrapper(t.cast(F, function), f)\n            return rv  # type: ignore[return-value]\n\n        return decorator",
          "line_count": 44,
          "needs_llm_summary": true
        },
        {
          "name": "get_command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "cmd_name",
              "type": "str"
            }
          ],
          "return_type": "Any",
          "lineno": 1778,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cmd_name",
            "self.commands.get"
          ],
          "docstring": "Given a context and a command name, this returns a :class:`Command`\nobject if it exists or returns ``None``.",
          "code": "def get_command(self, ctx: Context, cmd_name: str) -> Command | None:\n        \"\"\"Given a context and a command name, this returns a :class:`Command`\n        object if it exists or returns ``None``.\n        \"\"\"\n        return self.commands.get(cmd_name)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "list_commands",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "list[str]",
          "lineno": 1784,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.commands",
            "sorted"
          ],
          "docstring": "Returns a list of subcommand names in the order they should appear.",
          "code": "def list_commands(self, ctx: Context) -> list[str]:\n        \"\"\"Returns a list of subcommand names in the order they should appear.\"\"\"\n        return sorted(self.commands)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "collect_usage_pieces",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "list[str]",
          "lineno": 1788,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "unknown.collect_usage_pieces",
            "rv.append",
            "super",
            "self.subcommand_metavar"
          ],
          "docstring": null,
          "code": "def collect_usage_pieces(self, ctx: Context) -> list[str]:\n        rv = super().collect_usage_pieces(ctx)\n        rv.append(self.subcommand_metavar)\n        return rv",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "format_options",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "formatter",
              "type": "HelpFormatter"
            }
          ],
          "return_type": "None",
          "lineno": 1793,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.format_options",
            "ctx",
            "self.format_commands",
            "super",
            "formatter"
          ],
          "docstring": null,
          "code": "def format_options(self, ctx: Context, formatter: HelpFormatter) -> None:\n        super().format_options(ctx, formatter)\n        self.format_commands(ctx, formatter)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "format_commands",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "formatter",
              "type": "HelpFormatter"
            }
          ],
          "return_type": "None",
          "lineno": 1797,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cmd.get_short_help_str",
            "commands.append",
            "formatter.write_dl",
            "ctx",
            "max",
            "len",
            "self.get_command",
            "rows",
            "_",
            "limit",
            "commands",
            "formatter.section",
            "subcommand",
            "rows.append",
            "self.list_commands"
          ],
          "docstring": "Extra format methods for multi methods that adds all the commands\nafter the options.",
          "code": "def format_commands(self, ctx: Context, formatter: HelpFormatter) -> None:\n        \"\"\"Extra format methods for multi methods that adds all the commands\n        after the options.\n        \"\"\"\n        commands = []\n        for subcommand in self.list_commands(ctx):\n            cmd = self.get_command(ctx, subcommand)\n            # What is this, the tool lied about a command.  Ignore it\n            if cmd is None:\n                continue\n            if cmd.hidden:\n                continue\n\n            commands.append((subcommand, cmd))\n\n        # allow for 3 times the default spacing\n        if len(commands):\n            limit = formatter.width - 6 - max(len(cmd[0]) for cmd in commands)\n\n            rows = []\n            for subcommand, cmd in commands:\n                help = cmd.get_short_help_str(limit)\n                rows.append((subcommand, help))\n\n            if rows:\n                with formatter.section(_(\"Commands\")):\n                    formatter.write_dl(rows)",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "parse_args",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "args",
              "type": "list[str]"
            }
          ],
          "return_type": "list[str]",
          "lineno": 1825,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.parse_args",
            "rest",
            "ctx",
            "NoArgsIsHelpError",
            "args",
            "super"
          ],
          "docstring": null,
          "code": "def parse_args(self, ctx: Context, args: list[str]) -> list[str]:\n        if not args and self.no_args_is_help and not ctx.resilient_parsing:\n            raise NoArgsIsHelpError(ctx)\n\n        rest = super().parse_args(ctx, args)\n\n        if self.chain:\n            ctx._protected_args = rest\n            ctx.args = []\n        elif rest:\n            ctx._protected_args, ctx.args = rest[:1], rest[1:]\n\n        return ctx.args",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "invoke",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "t.Any",
          "lineno": 1839,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sub_ctx.command.invoke",
            "ctx",
            "rv.append",
            "self._result_callback",
            "self.resolve_command",
            "rv",
            "_",
            "unknown.invoke",
            "ctx.params",
            "ctx.fail",
            "cmd_name",
            "args",
            "contexts.append",
            "cmd.make_context",
            "value",
            "_process_result",
            "super",
            "ctx.invoke",
            "sub_ctx"
          ],
          "docstring": null,
          "code": "def invoke(self, ctx: Context) -> t.Any:\n        def _process_result(value: t.Any) -> t.Any:\n            if self._result_callback is not None:\n                value = ctx.invoke(self._result_callback, value, **ctx.params)\n            return value\n\n        if not ctx._protected_args:\n            if self.invoke_without_command:\n                # No subcommand was invoked, so the result callback is\n                # invoked with the group return value for regular\n                # groups, or an empty list for chained groups.\n                with ctx:\n                    rv = super().invoke(ctx)\n                    return _process_result([] if self.chain else rv)\n            ctx.fail(_(\"Missing command.\"))\n\n        # Fetch args back out\n        args = [*ctx._protected_args, *ctx.args]\n        ctx.args = []\n        ctx._protected_args = []\n\n        # If we're not in chain mode, we only allow the invocation of a\n        # single command but we also inform the current context about the\n        # name of the command to invoke.\n        if not self.chain:\n            # Make sure the context is entered so we do not clean up\n            # resources until the result processor has worked.\n            with ctx:\n                cmd_name, cmd, args = self.resolve_command(ctx, args)\n                assert cmd is not None\n                ctx.invoked_subcommand = cmd_name\n                super().invoke(ctx)\n                sub_ctx = cmd.make_context(cmd_name, args, parent=ctx)\n                with sub_ctx:\n                    return _process_result(sub_ctx.command.invoke(sub_ctx))\n\n        # In chain mode we create the contexts step by step, but after the\n        # base command has been invoked.  Because at that point we do not\n        # know the subcommands yet, the invoked subcommand attribute is\n        # set to ``*`` to inform the command that subcommands are executed\n        # but nothing else.\n        with ctx:\n            ctx.invoked_subcommand = \"*\" if args else None\n            super().invoke(ctx)\n\n            # Otherwise we make every single context and invoke them in a\n            # chain.  In that case the return value to the result processor\n            # is the list of all invoked subcommand's results.\n            contexts = []\n            while args:\n                cmd_name, cmd, args = self.resolve_command(ctx, args)\n                assert cmd is not None\n                sub_ctx = cmd.make_context(\n                    cmd_name,\n                    args,\n                    parent=ctx,\n                    allow_extra_args=True,\n                    allow_interspersed_args=False,\n                )\n                contexts.append(sub_ctx)\n                args, sub_ctx.args = sub_ctx.args, []\n\n            rv = []\n            for sub_ctx in contexts:\n                with sub_ctx:\n                    rv.append(sub_ctx.command.invoke(sub_ctx))\n            return _process_result(rv)",
          "line_count": 67,
          "needs_llm_summary": true
        },
        {
          "name": "resolve_command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "args",
              "type": "list[str]"
            }
          ],
          "return_type": "tuple[Any, Any, list[str]]",
          "lineno": 1907,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.token_normalize_func",
            "original_cmd_name",
            "ctx",
            "self.get_command",
            "make_str",
            "_",
            "cmd_name",
            "ctx.fail",
            "self.parse_args",
            "args",
            "_split_opt",
            "unknown.format"
          ],
          "docstring": null,
          "code": "def resolve_command(\n        self, ctx: Context, args: list[str]\n    ) -> tuple[str | None, Command | None, list[str]]:\n        cmd_name = make_str(args[0])\n        original_cmd_name = cmd_name\n\n        # Get the command\n        cmd = self.get_command(ctx, cmd_name)\n\n        # If we can't find the command but there is a normalization\n        # function available, we try with that one.\n        if cmd is None and ctx.token_normalize_func is not None:\n            cmd_name = ctx.token_normalize_func(cmd_name)\n            cmd = self.get_command(ctx, cmd_name)\n\n        # If we don't find the command we want to show an error message\n        # to the user that it was not provided.  However, there is\n        # something else we should do: if the first argument looks like\n        # an option we want to kick off parsing again for arguments to\n        # resolve things like --help which now should go to the main\n        # place.\n        if cmd is None and not ctx.resilient_parsing:\n            if _split_opt(cmd_name)[0]:\n                self.parse_args(ctx, args)\n            ctx.fail(_(\"No such command {name!r}.\").format(name=original_cmd_name))\n        return cmd_name if cmd else None, cmd, args[1:]",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "shell_complete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "list[CompletionItem]",
          "lineno": 1934,
          "decorators": [],
          "is_async": false,
          "calls": [
            "incomplete",
            "ctx",
            "name",
            "results.extend",
            "CompletionItem",
            "unknown.shell_complete",
            "super",
            "command.get_short_help_str",
            "_complete_visible_commands"
          ],
          "docstring": "Return a list of completions for the incomplete value. Looks\nat the names of options, subcommands, and chained\nmulti-commands.\n\n:param ctx: Invocation context for this command.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
          "code": "def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of completions for the incomplete value. Looks\n        at the names of options, subcommands, and chained\n        multi-commands.\n\n        :param ctx: Invocation context for this command.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        results = [\n            CompletionItem(name, help=command.get_short_help_str())\n            for name, command in _complete_visible_commands(ctx, incomplete)\n        ]\n        results.extend(super().shell_complete(ctx, incomplete))\n        return results",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "sources",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 1977,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "name",
            "super",
            "kwargs"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        name: str | None = None,\n        sources: list[Group] | None = None,\n        **kwargs: t.Any,\n    ) -> None:\n        super().__init__(name, **kwargs)\n        #: The list of registered groups.\n        self.sources: list[Group] = sources or []",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "add_source",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "group",
              "type": "Group"
            }
          ],
          "return_type": "None",
          "lineno": 1987,
          "decorators": [],
          "is_async": false,
          "calls": [
            "group",
            "self.sources.append"
          ],
          "docstring": "Add a group as a source of commands.",
          "code": "def add_source(self, group: Group) -> None:\n        \"\"\"Add a group as a source of commands.\"\"\"\n        self.sources.append(group)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "get_command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "cmd_name",
              "type": "str"
            }
          ],
          "return_type": "Any",
          "lineno": 1991,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.get_command",
            "self",
            "ctx",
            "rv",
            "_check_nested_chain",
            "cmd_name",
            "source.get_command",
            "super"
          ],
          "docstring": null,
          "code": "def get_command(self, ctx: Context, cmd_name: str) -> Command | None:\n        rv = super().get_command(ctx, cmd_name)\n\n        if rv is not None:\n            return rv\n\n        for source in self.sources:\n            rv = source.get_command(ctx, cmd_name)\n\n            if rv is not None:\n                if self.chain:\n                    _check_nested_chain(self, cmd_name, rv)\n\n                return rv\n\n        return None",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "list_commands",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "list[str]",
          "lineno": 2008,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "set",
            "ctx",
            "rv",
            "source.list_commands",
            "rv.update",
            "unknown.list_commands",
            "sorted"
          ],
          "docstring": null,
          "code": "def list_commands(self, ctx: Context) -> list[str]:\n        rv: set[str] = set(super().list_commands(ctx))\n\n        for source in self.sources:\n            rv.update(source.list_commands(ctx))\n\n        return sorted(rv)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "param_decls",
              "type": "Any"
            },
            {
              "name": "type",
              "type": "Any"
            },
            {
              "name": "required",
              "type": "bool"
            },
            {
              "name": "default",
              "type": "Any"
            },
            {
              "name": "callback",
              "type": "Any"
            },
            {
              "name": "nargs",
              "type": "Any"
            },
            {
              "name": "multiple",
              "type": "bool"
            },
            {
              "name": "metavar",
              "type": "Any"
            },
            {
              "name": "expose_value",
              "type": "bool"
            },
            {
              "name": "is_eager",
              "type": "bool"
            },
            {
              "name": "envvar",
              "type": "Any"
            },
            {
              "name": "shell_complete",
              "type": "Any"
            },
            {
              "name": "deprecated",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 2120,
          "decorators": [],
          "is_async": false,
          "calls": [
            "shell_complete",
            "is_eager",
            "self._parse_decls",
            "type",
            "metavar",
            "deprecated",
            "expose_value",
            "callback",
            "required",
            "nargs",
            "envvar",
            "types.convert_type",
            "multiple",
            "self.type.arity",
            "default",
            "ValueError"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        param_decls: cabc.Sequence[str] | None = None,\n        type: types.ParamType | t.Any | None = None,\n        required: bool = False,\n        # XXX The default historically embed two concepts:\n        # - the declaration of a Parameter object carrying the default (handy to\n        #   arbitrage the default value of coupled Parameters sharing the same\n        #   self.name, like flag options),\n        # - and the actual value of the default.\n        # It is confusing and is the source of many issues discussed in:\n        # https://github.com/pallets/click/pull/3030\n        # In the future, we might think of splitting it in two, not unlike\n        # Option.is_flag and Option.flag_value: we could have something like\n        # Parameter.is_default and Parameter.default_value.\n        default: t.Any | t.Callable[[], t.Any] | None = UNSET,\n        callback: t.Callable[[Context, Parameter, t.Any], t.Any] | None = None,\n        nargs: int | None = None,\n        multiple: bool = False,\n        metavar: str | None = None,\n        expose_value: bool = True,\n        is_eager: bool = False,\n        envvar: str | cabc.Sequence[str] | None = None,\n        shell_complete: t.Callable[\n            [Context, Parameter, str], list[CompletionItem] | list[str]\n        ]\n        | None = None,\n        deprecated: bool | str = False,\n    ) -> None:\n        self.name: str | None\n        self.opts: list[str]\n        self.secondary_opts: list[str]\n        self.name, self.opts, self.secondary_opts = self._parse_decls(\n            param_decls or (), expose_value\n        )\n        self.type: types.ParamType = types.convert_type(type, default)\n\n        # Default nargs to what the type tells us if we have that\n        # information available.\n        if nargs is None:\n            if self.type.is_composite:\n                nargs = self.type.arity\n            else:\n                nargs = 1\n\n        self.required = required\n        self.callback = callback\n        self.nargs = nargs\n        self.multiple = multiple\n        self.expose_value = expose_value\n        self.default: t.Any | t.Callable[[], t.Any] | None = default\n        self.is_eager = is_eager\n        self.metavar = metavar\n        self.envvar = envvar\n        self._custom_shell_complete = shell_complete\n        self.deprecated = deprecated\n\n        if __debug__:\n            if self.type.is_composite and nargs != self.type.arity:\n                raise ValueError(\n                    f\"'nargs' must be {self.type.arity} (or None) for\"\n                    f\" type {self.type!r}, but it was {nargs}.\"\n                )\n\n            if required and deprecated:\n                raise ValueError(\n                    f\"The {self.param_type_name} '{self.human_readable_name}' \"\n                    \"is deprecated and still required. A deprecated \"\n                    f\"{self.param_type_name} cannot be required.\"\n                )",
          "line_count": 70,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 2191,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.type.to_info_dict"
          ],
          "docstring": "Gather information that could be useful for a tool generating\nuser-facing documentation.\n\nUse :meth:`click.Context.to_info_dict` to traverse the entire\nCLI structure.\n\n.. versionchanged:: 8.3.0\n    Returns ``None`` for the :attr:`default` if it was not set.\n\n.. versionadded:: 8.0",
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        \"\"\"Gather information that could be useful for a tool generating\n        user-facing documentation.\n\n        Use :meth:`click.Context.to_info_dict` to traverse the entire\n        CLI structure.\n\n        .. versionchanged:: 8.3.0\n            Returns ``None`` for the :attr:`default` if it was not set.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"param_type_name\": self.param_type_name,\n            \"opts\": self.opts,\n            \"secondary_opts\": self.secondary_opts,\n            \"type\": self.type.to_info_dict(),\n            \"required\": self.required,\n            \"nargs\": self.nargs,\n            \"multiple\": self.multiple,\n            # We explicitly hide the :attr:`UNSET` value to the user, as we choose to\n            # make it an implementation detail. And because ``to_info_dict`` has been\n            # designed for documentation purposes, we return ``None`` instead.\n            \"default\": self.default if self.default is not UNSET else None,\n            \"envvar\": self.envvar,\n        }",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 2219,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} {self.name}>\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_parse_decls",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "decls",
              "type": "cabc.Sequence[str]"
            },
            {
              "name": "expose_value",
              "type": "bool"
            }
          ],
          "return_type": "tuple[Any, list[str], list[str]]",
          "lineno": 2222,
          "decorators": [],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": null,
          "code": "def _parse_decls(\n        self, decls: cabc.Sequence[str], expose_value: bool\n    ) -> tuple[str | None, list[str], list[str]]:\n        raise NotImplementedError()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "human_readable_name",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 2228,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "Returns the human readable name of this parameter.  This is the\nsame as the name for options, but the metavar for arguments.",
          "code": "def human_readable_name(self) -> str:\n        \"\"\"Returns the human readable name of this parameter.  This is the\n        same as the name for options, but the metavar for arguments.\n        \"\"\"\n        return self.name",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "make_metavar",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "str",
          "lineno": 2234,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "self.type.name.upper",
            "self",
            "self.type.get_metavar"
          ],
          "docstring": null,
          "code": "def make_metavar(self, ctx: Context) -> str:\n        if self.metavar is not None:\n            return self.metavar\n\n        metavar = self.type.get_metavar(param=self, ctx=ctx)\n\n        if metavar is None:\n            metavar = self.type.name.upper()\n\n        if self.nargs != 1:\n            metavar += \"...\"\n\n        return metavar",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "get_default",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "call",
              "type": "t.Literal[True]"
            }
          ],
          "return_type": "Any",
          "lineno": 2249,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_default(\n        self, ctx: Context, call: t.Literal[True] = True\n    ) -> t.Any | None: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "get_default",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "call",
              "type": "bool"
            }
          ],
          "return_type": "Any",
          "lineno": 2254,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_default(\n        self, ctx: Context, call: bool = ...\n    ) -> t.Any | t.Callable[[], t.Any] | None: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "get_default",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "call",
              "type": "bool"
            }
          ],
          "return_type": "Any",
          "lineno": 2258,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.lookup_default",
            "value",
            "self.name",
            "self.default",
            "callable"
          ],
          "docstring": "Get the default for the parameter. Tries\n:meth:`Context.lookup_default` first, then the local default.\n\n:param ctx: Current context.\n:param call: If the default is a callable, call it. Disable to\n    return the callable instead.\n\n.. versionchanged:: 8.0.2\n    Type casting is no longer performed when getting a default.\n\n.. versionchanged:: 8.0.1\n    Type casting can fail in resilient parsing mode. Invalid\n    defaults will not prevent showing help text.\n\n.. versionchanged:: 8.0\n    Looks at ``ctx.default_map`` first.\n\n.. versionchanged:: 8.0\n    Added the ``call`` parameter.",
          "code": "def get_default(\n        self, ctx: Context, call: bool = True\n    ) -> t.Any | t.Callable[[], t.Any] | None:\n        \"\"\"Get the default for the parameter. Tries\n        :meth:`Context.lookup_default` first, then the local default.\n\n        :param ctx: Current context.\n        :param call: If the default is a callable, call it. Disable to\n            return the callable instead.\n\n        .. versionchanged:: 8.0.2\n            Type casting is no longer performed when getting a default.\n\n        .. versionchanged:: 8.0.1\n            Type casting can fail in resilient parsing mode. Invalid\n            defaults will not prevent showing help text.\n\n        .. versionchanged:: 8.0\n            Looks at ``ctx.default_map`` first.\n\n        .. versionchanged:: 8.0\n            Added the ``call`` parameter.\n        \"\"\"\n        value = ctx.lookup_default(self.name, call=False)  # type: ignore\n\n        if value is UNSET:\n            value = self.default\n\n        if call and callable(value):\n            value = value()\n\n        return value",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "add_to_parser",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "parser",
              "type": "_OptionParser"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "None",
          "lineno": 2291,
          "decorators": [],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": null,
          "code": "def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:\n        raise NotImplementedError()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "consume_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "opts",
              "type": "cabc.Mapping[str, t.Any]"
            }
          ],
          "return_type": "tuple[t.Any, ParameterSource]",
          "lineno": 2294,
          "decorators": [],
          "is_async": false,
          "calls": [
            "opts.get",
            "default_map_value",
            "UNSET",
            "self.value_from_envvar",
            "ParameterSource.ENVIRONMENT",
            "ctx.lookup_default",
            "ctx",
            "ParameterSource.DEFAULT",
            "self.name",
            "default_value",
            "self.get_default",
            "ParameterSource.DEFAULT_MAP",
            "envvar_value"
          ],
          "docstring": "Returns the parameter value produced by the parser.\n\nIf the parser did not produce a value from user input, the value is either\nsourced from the environment variable, the default map, or the parameter's\ndefault value. In that order of precedence.\n\nIf no value is found, an internal sentinel value is returned.\n\n:meta private:",
          "code": "def consume_value(\n        self, ctx: Context, opts: cabc.Mapping[str, t.Any]\n    ) -> tuple[t.Any, ParameterSource]:\n        \"\"\"Returns the parameter value produced by the parser.\n\n        If the parser did not produce a value from user input, the value is either\n        sourced from the environment variable, the default map, or the parameter's\n        default value. In that order of precedence.\n\n        If no value is found, an internal sentinel value is returned.\n\n        :meta private:\n        \"\"\"\n        # Collect from the parse the value passed by the user to the CLI.\n        value = opts.get(self.name, UNSET)  # type: ignore\n        # If the value is set, it means it was sourced from the command line by the\n        # parser, otherwise it left unset by default.\n        source = (\n            ParameterSource.COMMANDLINE\n            if value is not UNSET\n            else ParameterSource.DEFAULT\n        )\n\n        if value is UNSET:\n            envvar_value = self.value_from_envvar(ctx)\n            if envvar_value is not None:\n                value = envvar_value\n                source = ParameterSource.ENVIRONMENT\n\n        if value is UNSET:\n            default_map_value = ctx.lookup_default(self.name)  # type: ignore\n            if default_map_value is not UNSET:\n                value = default_map_value\n                source = ParameterSource.DEFAULT_MAP\n\n        if value is UNSET:\n            default_value = self.get_default(ctx)\n            if default_value is not UNSET:\n                value = default_value\n                source = ParameterSource.DEFAULT\n\n        return value, source",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "type_cast_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 2337,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "check_iter",
            "self",
            "_check_iter",
            "value",
            "ctx",
            "convert",
            "len",
            "_",
            "ngettext",
            "self.type",
            "BadParameter",
            "self.nargs",
            "unknown.format",
            "x"
          ],
          "docstring": "Convert and validate a value against the parameter's\n:attr:`type`, :attr:`multiple`, and :attr:`nargs`.",
          "code": "def type_cast_value(self, ctx: Context, value: t.Any) -> t.Any:\n        \"\"\"Convert and validate a value against the parameter's\n        :attr:`type`, :attr:`multiple`, and :attr:`nargs`.\n        \"\"\"\n        if value is None:\n            if self.multiple or self.nargs == -1:\n                return ()\n            else:\n                return value\n\n        def check_iter(value: t.Any) -> cabc.Iterator[t.Any]:\n            try:\n                return _check_iter(value)\n            except TypeError:\n                # This should only happen when passing in args manually,\n                # the parser should construct an iterable when parsing\n                # the command line.\n                raise BadParameter(\n                    _(\"Value must be an iterable.\"), ctx=ctx, param=self\n                ) from None\n\n        # Define the conversion function based on nargs and type.\n\n        if self.nargs == 1 or self.type.is_composite:\n\n            def convert(value: t.Any) -> t.Any:\n                return self.type(value, param=self, ctx=ctx)\n\n        elif self.nargs == -1:\n\n            def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]\n                return tuple(self.type(x, self, ctx) for x in check_iter(value))\n\n        else:  # nargs > 1\n\n            def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]\n                value = tuple(check_iter(value))\n\n                if len(value) != self.nargs:\n                    raise BadParameter(\n                        ngettext(\n                            \"Takes {nargs} values but 1 was given.\",\n                            \"Takes {nargs} values but {len} were given.\",\n                            len(value),\n                        ).format(nargs=self.nargs, len=len(value)),\n                        ctx=ctx,\n                        param=self,\n                    )\n\n                return tuple(self.type(x, self, ctx) for x in value)\n\n        if self.multiple:\n            return tuple(convert(x) for x in check_iter(value))\n\n        return convert(value)",
          "line_count": 55,
          "needs_llm_summary": true
        },
        {
          "name": "value_is_missing",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 2393,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "A value is considered missing if:\n\n- it is :attr:`UNSET`,\n- or if it is an empty sequence while the parameter is suppose to have\n  non-single value (i.e. :attr:`nargs` is not ``1`` or :attr:`multiple` is\n  set).\n\n:meta private:",
          "code": "def value_is_missing(self, value: t.Any) -> bool:\n        \"\"\"A value is considered missing if:\n\n        - it is :attr:`UNSET`,\n        - or if it is an empty sequence while the parameter is suppose to have\n          non-single value (i.e. :attr:`nargs` is not ``1`` or :attr:`multiple` is\n          set).\n\n        :meta private:\n        \"\"\"\n        if value is UNSET:\n            return True\n\n        if (self.nargs != 1 or self.multiple) and value == ():\n            return True\n\n        return False",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "process_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 2411,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "value",
            "ctx",
            "MissingParameter",
            "ctx.params.items",
            "self.type_cast_value",
            "self.callback",
            "self.value_is_missing",
            "unset_keys",
            "ctx.params.update"
          ],
          "docstring": "Process the value of this parameter:\n\n1. Type cast the value using :meth:`type_cast_value`.\n2. Check if the value is missing (see: :meth:`value_is_missing`), and raise\n   :exc:`MissingParameter` if it is required.\n3. If a :attr:`callback` is set, call it to have the value replaced by the\n   result of the callback. If the value was not set, the callback receive\n   ``None``. This keep the legacy behavior as it was before the introduction of\n   the :attr:`UNSET` sentinel.\n\n:meta private:",
          "code": "def process_value(self, ctx: Context, value: t.Any) -> t.Any:\n        \"\"\"Process the value of this parameter:\n\n        1. Type cast the value using :meth:`type_cast_value`.\n        2. Check if the value is missing (see: :meth:`value_is_missing`), and raise\n           :exc:`MissingParameter` if it is required.\n        3. If a :attr:`callback` is set, call it to have the value replaced by the\n           result of the callback. If the value was not set, the callback receive\n           ``None``. This keep the legacy behavior as it was before the introduction of\n           the :attr:`UNSET` sentinel.\n\n        :meta private:\n        \"\"\"\n        # shelter `type_cast_value` from ever seeing an `UNSET` value by handling the\n        # cases in which `UNSET` gets special treatment explicitly at this layer\n        #\n        # Refs:\n        # https://github.com/pallets/click/issues/3069\n        if value is UNSET:\n            if self.multiple or self.nargs == -1:\n                value = ()\n        else:\n            value = self.type_cast_value(ctx, value)\n\n        if self.required and self.value_is_missing(value):\n            raise MissingParameter(ctx=ctx, param=self)\n\n        if self.callback is not None:\n            # Legacy case: UNSET is not exposed directly to the callback, but converted\n            # to None.\n            if value is UNSET:\n                value = None\n\n            # Search for parameters with UNSET values in the context.\n            unset_keys = {k: None for k, v in ctx.params.items() if v is UNSET}\n            # No UNSET values, call the callback as usual.\n            if not unset_keys:\n                value = self.callback(ctx, self, value)\n\n            # Legacy case: provide a temporarily manipulated context to the callback\n            # to hide UNSET values as None.\n            #\n            # Refs:\n            # https://github.com/pallets/click/issues/3136\n            # https://github.com/pallets/click/pull/3137\n            else:\n                # Add another layer to the context stack to clearly hint that the\n                # context is temporarily modified.\n                with ctx:\n                    # Update the context parameters to replace UNSET with None.\n                    ctx.params.update(unset_keys)\n                    # Feed these fake context parameters to the callback.\n                    value = self.callback(ctx, self, value)\n                    # Restore the UNSET values in the context parameters.\n                    ctx.params.update(\n                        {\n                            k: UNSET\n                            for k in unset_keys\n                            # Only restore keys that are present and still None, in case\n                            # the callback modified other parameters.\n                            if k in ctx.params and ctx.params[k] is None\n                        }\n                    )\n\n        return value",
          "line_count": 65,
          "needs_llm_summary": true
        },
        {
          "name": "resolve_envvar_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 2477,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.environ.get",
            "str",
            "self.envvar",
            "envvar",
            "isinstance"
          ],
          "docstring": "Returns the value found in the environment variable(s) attached to this\nparameter.\n\nEnvironment variables values are `always returned as strings\n<https://docs.python.org/3/library/os.html#os.environ>`_.\n\nThis method returns ``None`` if:\n\n- the :attr:`envvar` property is not set on the :class:`Parameter`,\n- the environment variable is not found in the environment,\n- the variable is found in the environment but its value is empty (i.e. the\n  environment variable is present but has an empty string).\n\nIf :attr:`envvar` is setup with multiple environment variables,\nthen only the first non-empty value is returned.\n\n.. caution::\n\n    The raw value extracted from the environment is not normalized and is\n    returned as-is. Any normalization or reconciliation is performed later by\n    the :class:`Parameter`'s :attr:`type`.\n\n:meta private:",
          "code": "def resolve_envvar_value(self, ctx: Context) -> str | None:\n        \"\"\"Returns the value found in the environment variable(s) attached to this\n        parameter.\n\n        Environment variables values are `always returned as strings\n        <https://docs.python.org/3/library/os.html#os.environ>`_.\n\n        This method returns ``None`` if:\n\n        - the :attr:`envvar` property is not set on the :class:`Parameter`,\n        - the environment variable is not found in the environment,\n        - the variable is found in the environment but its value is empty (i.e. the\n          environment variable is present but has an empty string).\n\n        If :attr:`envvar` is setup with multiple environment variables,\n        then only the first non-empty value is returned.\n\n        .. caution::\n\n            The raw value extracted from the environment is not normalized and is\n            returned as-is. Any normalization or reconciliation is performed later by\n            the :class:`Parameter`'s :attr:`type`.\n\n        :meta private:\n        \"\"\"\n        if not self.envvar:\n            return None\n\n        if isinstance(self.envvar, str):\n            rv = os.environ.get(self.envvar)\n\n            if rv:\n                return rv\n        else:\n            for envvar in self.envvar:\n                rv = os.environ.get(envvar)\n\n                # Return the first non-empty value of the list of environment variables.\n                if rv:\n                    return rv\n                # Else, absence of value is interpreted as an environment variable that\n                # is not set, so proceed to the next one.\n\n        return None",
          "line_count": 44,
          "needs_llm_summary": true
        },
        {
          "name": "value_from_envvar",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 2522,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "self.resolve_envvar_value",
            "rv",
            "self.type.split_envvar_value"
          ],
          "docstring": "Process the raw environment variable string for this parameter.\n\nReturns the string as-is or splits it into a sequence of strings if the\nparameter is expecting multiple values (i.e. its :attr:`nargs` property is set\nto a value other than ``1``).\n\n:meta private:",
          "code": "def value_from_envvar(self, ctx: Context) -> str | cabc.Sequence[str] | None:\n        \"\"\"Process the raw environment variable string for this parameter.\n\n        Returns the string as-is or splits it into a sequence of strings if the\n        parameter is expecting multiple values (i.e. its :attr:`nargs` property is set\n        to a value other than ``1``).\n\n        :meta private:\n        \"\"\"\n        rv = self.resolve_envvar_value(ctx)\n\n        if rv is not None and self.nargs != 1:\n            return self.type.split_envvar_value(rv)\n\n        return rv",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "handle_parse_result",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "opts",
              "type": "cabc.Mapping[str, t.Any]"
            },
            {
              "name": "args",
              "type": "list[str]"
            }
          ],
          "return_type": "tuple[t.Any, list[str]]",
          "lineno": 2538,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "message",
            "ctx",
            "opts",
            "isinstance",
            "style",
            "unknown.format",
            "self.consume_value",
            "self.human_readable_name",
            "self.param_type_name",
            "self",
            "self.process_value",
            "self.name",
            "_",
            "augment_usage_errors",
            "UNSET",
            "source",
            "str",
            "extra_message",
            "value",
            "ctx.set_parameter_source",
            "self.deprecated"
          ],
          "docstring": "Process the value produced by the parser from user input.\n\nAlways process the value through the Parameter's :attr:`type`, wherever it\ncomes from.\n\nIf the parameter is deprecated, this method warn the user about it. But only if\nthe value has been explicitly set by the user (and as such, is not coming from\na default).\n\n:meta private:",
          "code": "def handle_parse_result(\n        self, ctx: Context, opts: cabc.Mapping[str, t.Any], args: list[str]\n    ) -> tuple[t.Any, list[str]]:\n        \"\"\"Process the value produced by the parser from user input.\n\n        Always process the value through the Parameter's :attr:`type`, wherever it\n        comes from.\n\n        If the parameter is deprecated, this method warn the user about it. But only if\n        the value has been explicitly set by the user (and as such, is not coming from\n        a default).\n\n        :meta private:\n        \"\"\"\n        with augment_usage_errors(ctx, param=self):\n            value, source = self.consume_value(ctx, opts)\n\n            ctx.set_parameter_source(self.name, source)  # type: ignore\n\n            # Display a deprecation warning if necessary.\n            if (\n                self.deprecated\n                and value is not UNSET\n                and source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)\n            ):\n                extra_message = (\n                    f\" {self.deprecated}\" if isinstance(self.deprecated, str) else \"\"\n                )\n                message = _(\n                    \"DeprecationWarning: The {param_type} {name!r} is deprecated.\"\n                    \"{extra_message}\"\n                ).format(\n                    param_type=self.param_type_name,\n                    name=self.human_readable_name,\n                    extra_message=extra_message,\n                )\n                echo(style(message, fg=\"red\"), err=True)\n\n            # Process the value through the parameter's type.\n            try:\n                value = self.process_value(ctx, value)\n            except Exception:\n                if not ctx.resilient_parsing:\n                    raise\n                # In resilient parsing mode, we do not want to fail the command if the\n                # value is incompatible with the parameter type, so we reset the value\n                # to UNSET, which will be interpreted as a missing value.\n                value = UNSET\n\n        # Add parameter's value to the context.\n        if (\n            self.expose_value\n            # We skip adding the value if it was previously set by another parameter\n            # targeting the same variable name. This prevents parameters competing for\n            # the same name to override each other.\n            and (self.name not in ctx.params or ctx.params[self.name] is UNSET)\n        ):\n            # Click is logically enforcing that the name is None if the parameter is\n            # not to be exposed. We still assert it here to please the type checker.\n            assert self.name is not None, (\n                f\"{self!r} parameter's name should not be None when exposing value.\"\n            )\n            ctx.params[self.name] = value\n\n        return value, args",
          "line_count": 65,
          "needs_llm_summary": true
        },
        {
          "name": "get_help_record",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 2604,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_help_record(self, ctx: Context) -> tuple[str, str] | None:\n        pass",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_usage_pieces",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "list[str]",
          "lineno": 2607,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_usage_pieces(self, ctx: Context) -> list[str]:\n        return []",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_error_hint",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "str",
          "lineno": 2610,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.join"
          ],
          "docstring": "Get a stringified version of the param for use in error messages to\nindicate which param caused the error.",
          "code": "def get_error_hint(self, ctx: Context) -> str:\n        \"\"\"Get a stringified version of the param for use in error messages to\n        indicate which param caused the error.\n        \"\"\"\n        hint_list = self.opts or [self.human_readable_name]\n        return \" / \".join(f\"'{x}'\" for x in hint_list)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "shell_complete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "list[CompletionItem]",
          "lineno": 2617,
          "decorators": [],
          "is_async": false,
          "calls": [
            "c",
            "incomplete",
            "self",
            "ctx",
            "str",
            "t.cast",
            "self.type.shell_complete",
            "self._custom_shell_complete",
            "isinstance",
            "CompletionItem",
            "results"
          ],
          "docstring": "Return a list of completions for the incomplete value. If a\n``shell_complete`` function was given during init, it is used.\nOtherwise, the :attr:`type`\n:meth:`~click.types.ParamType.shell_complete` function is used.\n\n:param ctx: Invocation context for this command.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
          "code": "def shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:\n        \"\"\"Return a list of completions for the incomplete value. If a\n        ``shell_complete`` function was given during init, it is used.\n        Otherwise, the :attr:`type`\n        :meth:`~click.types.ParamType.shell_complete` function is used.\n\n        :param ctx: Invocation context for this command.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        if self._custom_shell_complete is not None:\n            results = self._custom_shell_complete(ctx, self, incomplete)\n\n            if results and isinstance(results[0], str):\n                from click.shell_completion import CompletionItem\n\n                results = [CompletionItem(c) for c in results]\n\n            return t.cast(\"list[CompletionItem]\", results)\n\n        return self.type.shell_complete(ctx, self, incomplete)",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "param_decls",
              "type": "Any"
            },
            {
              "name": "show_default",
              "type": "Any"
            },
            {
              "name": "prompt",
              "type": "Any"
            },
            {
              "name": "confirmation_prompt",
              "type": "Any"
            },
            {
              "name": "prompt_required",
              "type": "bool"
            },
            {
              "name": "hide_input",
              "type": "bool"
            },
            {
              "name": "is_flag",
              "type": "Any"
            },
            {
              "name": "flag_value",
              "type": "t.Any"
            },
            {
              "name": "multiple",
              "type": "bool"
            },
            {
              "name": "count",
              "type": "bool"
            },
            {
              "name": "allow_from_autoenv",
              "type": "bool"
            },
            {
              "name": "type",
              "type": "Any"
            },
            {
              "name": "help",
              "type": "Any"
            },
            {
              "name": "hidden",
              "type": "bool"
            },
            {
              "name": "show_choices",
              "type": "bool"
            },
            {
              "name": "show_envvar",
              "type": "bool"
            },
            {
              "name": "deprecated",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 2709,
          "decorators": [],
          "is_async": false,
          "calls": [
            "confirmation_prompt",
            "prompt_required",
            "type",
            "unknown.__init__",
            "hide_input",
            "self.name.replace",
            "count",
            "TypeError",
            "isinstance",
            "attrs",
            "show_envvar",
            "allow_from_autoenv",
            "ValueError",
            "types.IntRange",
            "deprecated",
            "flag_value",
            "prompt_text",
            "show_choices",
            "inspect.cleandoc",
            "hidden",
            "types.BoolParamType",
            "str",
            "unknown.capitalize",
            "help",
            "show_default",
            "multiple",
            "bool",
            "self.flag_value",
            "is_flag",
            "prompt",
            "types.convert_type",
            "self.type",
            "super",
            "param_decls"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        param_decls: cabc.Sequence[str] | None = None,\n        show_default: bool | str | None = None,\n        prompt: bool | str = False,\n        confirmation_prompt: bool | str = False,\n        prompt_required: bool = True,\n        hide_input: bool = False,\n        is_flag: bool | None = None,\n        flag_value: t.Any = UNSET,\n        multiple: bool = False,\n        count: bool = False,\n        allow_from_autoenv: bool = True,\n        type: types.ParamType | t.Any | None = None,\n        help: str | None = None,\n        hidden: bool = False,\n        show_choices: bool = True,\n        show_envvar: bool = False,\n        deprecated: bool | str = False,\n        **attrs: t.Any,\n    ) -> None:\n        if help:\n            help = inspect.cleandoc(help)\n\n        super().__init__(\n            param_decls, type=type, multiple=multiple, deprecated=deprecated, **attrs\n        )\n\n        if prompt is True:\n            if self.name is None:\n                raise TypeError(\"'name' is required with 'prompt=True'.\")\n\n            prompt_text: str | None = self.name.replace(\"_\", \" \").capitalize()\n        elif prompt is False:\n            prompt_text = None\n        else:\n            prompt_text = prompt\n\n        if deprecated:\n            deprecated_message = (\n                f\"(DEPRECATED: {deprecated})\"\n                if isinstance(deprecated, str)\n                else \"(DEPRECATED)\"\n            )\n            help = help + deprecated_message if help is not None else deprecated_message\n\n        self.prompt = prompt_text\n        self.confirmation_prompt = confirmation_prompt\n        self.prompt_required = prompt_required\n        self.hide_input = hide_input\n        self.hidden = hidden\n\n        # The _flag_needs_value property tells the parser that this option is a flag\n        # that cannot be used standalone and needs a value. With this information, the\n        # parser can determine whether to consider the next user-provided argument in\n        # the CLI as a value for this flag or as a new option.\n        # If prompt is enabled but not required, then it opens the possibility for the\n        # option to gets its value from the user.\n        self._flag_needs_value = self.prompt is not None and not self.prompt_required\n\n        # Auto-detect if this is a flag or not.\n        if is_flag is None:\n            # Implicitly a flag because flag_value was set.\n            if flag_value is not UNSET:\n                is_flag = True\n            # Not a flag, but when used as a flag it shows a prompt.\n            elif self._flag_needs_value:\n                is_flag = False\n            # Implicitly a flag because secondary options names were given.\n            elif self.secondary_opts:\n                is_flag = True\n\n        # The option is explicitly not a flag, but to determine whether or not it needs\n        # value, we need to check if `flag_value` or `default` was set. Either one is\n        # sufficient.\n        # Ref: https://github.com/pallets/click/issues/3084\n        elif is_flag is False and not self._flag_needs_value:\n            self._flag_needs_value = flag_value is not UNSET or self.default is UNSET\n\n        if is_flag:\n            # Set missing default for flags if not explicitly required or prompted.\n            if self.default is UNSET and not self.required and not self.prompt:\n                if multiple:\n                    self.default = ()\n\n            # Auto-detect the type of the flag based on the flag_value.\n            if type is None:\n                # A flag without a flag_value is a boolean flag.\n                if flag_value is UNSET:\n                    self.type: types.ParamType = types.BoolParamType()\n                # If the flag value is a boolean, use BoolParamType.\n                elif isinstance(flag_value, bool):\n                    self.type = types.BoolParamType()\n                # Otherwise, guess the type from the flag value.\n                else:\n                    self.type = types.convert_type(None, flag_value)\n\n        self.is_flag: bool = bool(is_flag)\n        self.is_bool_flag: bool = bool(\n            is_flag and isinstance(self.type, types.BoolParamType)\n        )\n        self.flag_value: t.Any = flag_value\n\n        # Set boolean flag default to False if unset and not required.\n        if self.is_bool_flag:\n            if self.default is UNSET and not self.required:\n                self.default = False\n\n        # Support the special case of aligning the default value with the flag_value\n        # for flags whose default is explicitly set to True. Note that as long as we\n        # have this condition, there is no way a flag can have a default set to True,\n        # and a flag_value set to something else. Refs:\n        # https://github.com/pallets/click/issues/3024#issuecomment-3146199461\n        # https://github.com/pallets/click/pull/3030/commits/06847da\n        if self.default is True and self.flag_value is not UNSET:\n            self.default = self.flag_value\n\n        # Set the default flag_value if it is not set.\n        if self.flag_value is UNSET:\n            if self.is_flag:\n                self.flag_value = True\n            else:\n                self.flag_value = None\n\n        # Counting.\n        self.count = count\n        if count:\n            if type is None:\n                self.type = types.IntRange(min=0)\n            if self.default is UNSET:\n                self.default = 0\n\n        self.allow_from_autoenv = allow_from_autoenv\n        self.help = help\n        self.show_default = show_default\n        self.show_choices = show_choices\n        self.show_envvar = show_envvar\n\n        if __debug__:\n            if deprecated and prompt:\n                raise ValueError(\"`deprecated` options cannot use `prompt`.\")\n\n            if self.nargs == -1:\n                raise TypeError(\"nargs=-1 is not supported for options.\")\n\n            if not self.is_bool_flag and self.secondary_opts:\n                raise TypeError(\"Secondary flag is not valid for non-boolean flag.\")\n\n            if self.is_bool_flag and self.hide_input and self.prompt is not None:\n                raise TypeError(\n                    \"'prompt' with 'hide_input' is not valid for boolean flag.\"\n                )\n\n            if self.count:\n                if self.multiple:\n                    raise TypeError(\"'count' is not valid with 'multiple'.\")\n\n                if self.is_flag:\n                    raise TypeError(\"'count' is not valid with 'is_flag'.\")",
          "line_count": 159,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 2869,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.is_flag",
            "self.help",
            "unknown.to_info_dict",
            "self.count",
            "self.hidden",
            "super",
            "info_dict.update",
            "self.prompt"
          ],
          "docstring": ".. versionchanged:: 8.3.0\n    Returns ``None`` for the :attr:`flag_value` if it was not set.",
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        \"\"\"\n        .. versionchanged:: 8.3.0\n            Returns ``None`` for the :attr:`flag_value` if it was not set.\n        \"\"\"\n        info_dict = super().to_info_dict()\n        info_dict.update(\n            help=self.help,\n            prompt=self.prompt,\n            is_flag=self.is_flag,\n            # We explicitly hide the :attr:`UNSET` value to the user, as we choose to\n            # make it an implementation detail. And because ``to_info_dict`` has been\n            # designed for documentation purposes, we return ``None`` instead.\n            flag_value=self.flag_value if self.flag_value is not UNSET else None,\n            count=self.count,\n            hidden=self.hidden,\n        )\n        return info_dict",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "get_error_hint",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "str",
          "lineno": 2888,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "super",
            "unknown.get_error_hint"
          ],
          "docstring": null,
          "code": "def get_error_hint(self, ctx: Context) -> str:\n        result = super().get_error_hint(ctx)\n        if self.show_envvar and self.envvar is not None:\n            result += f\" (env var: '{self.envvar}')\"\n        return result",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "_parse_decls",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "decls",
              "type": "cabc.Sequence[str]"
            },
            {
              "name": "expose_value",
              "type": "bool"
            }
          ],
          "return_type": "tuple[Any, list[str], list[str]]",
          "lineno": 2894,
          "decorators": [],
          "is_async": false,
          "calls": [
            "possible_names.sort",
            "name.isidentifier",
            "opts.append",
            "possible_names.append",
            "decl.split",
            "unknown.lower",
            "len",
            "second.lstrip",
            "decl.isidentifier",
            "decl",
            "TypeError",
            "first.rstrip",
            "unknown.replace",
            "secondary_opts.append",
            "_split_opt",
            "split_char",
            "ValueError",
            "first"
          ],
          "docstring": null,
          "code": "def _parse_decls(\n        self, decls: cabc.Sequence[str], expose_value: bool\n    ) -> tuple[str | None, list[str], list[str]]:\n        opts = []\n        secondary_opts = []\n        name = None\n        possible_names = []\n\n        for decl in decls:\n            if decl.isidentifier():\n                if name is not None:\n                    raise TypeError(f\"Name '{name}' defined twice\")\n                name = decl\n            else:\n                split_char = \";\" if decl[:1] == \"/\" else \"/\"\n                if split_char in decl:\n                    first, second = decl.split(split_char, 1)\n                    first = first.rstrip()\n                    if first:\n                        possible_names.append(_split_opt(first))\n                        opts.append(first)\n                    second = second.lstrip()\n                    if second:\n                        secondary_opts.append(second.lstrip())\n                    if first == second:\n                        raise ValueError(\n                            f\"Boolean option {decl!r} cannot use the\"\n                            \" same flag for true/false.\"\n                        )\n                else:\n                    possible_names.append(_split_opt(decl))\n                    opts.append(decl)\n\n        if name is None and possible_names:\n            possible_names.sort(key=lambda x: -len(x[0]))  # group long options first\n            name = possible_names[0][1].replace(\"-\", \"_\").lower()\n            if not name.isidentifier():\n                name = None\n\n        if name is None:\n            if not expose_value:\n                return None, opts, secondary_opts\n            raise TypeError(\n                f\"Could not determine name for option with declarations {decls!r}\"\n            )\n\n        if not opts and not secondary_opts:\n            raise TypeError(\n                f\"No options defined but a name was passed ({name}).\"\n                \" Did you mean to declare an argument instead? Did\"\n                f\" you mean to pass '--{name}'?\"\n            )\n\n        return name, opts, secondary_opts",
          "line_count": 54,
          "needs_llm_summary": true
        },
        {
          "name": "add_to_parser",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "parser",
              "type": "_OptionParser"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "None",
          "lineno": 2949,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.nargs",
            "self",
            "self.opts",
            "parser.add_option",
            "self.name",
            "self.secondary_opts",
            "action",
            "self.flag_value"
          ],
          "docstring": null,
          "code": "def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:\n        if self.multiple:\n            action = \"append\"\n        elif self.count:\n            action = \"count\"\n        else:\n            action = \"store\"\n\n        if self.is_flag:\n            action = f\"{action}_const\"\n\n            if self.is_bool_flag and self.secondary_opts:\n                parser.add_option(\n                    obj=self, opts=self.opts, dest=self.name, action=action, const=True\n                )\n                parser.add_option(\n                    obj=self,\n                    opts=self.secondary_opts,\n                    dest=self.name,\n                    action=action,\n                    const=False,\n                )\n            else:\n                parser.add_option(\n                    obj=self,\n                    opts=self.opts,\n                    dest=self.name,\n                    action=action,\n                    const=self.flag_value,\n                )\n        else:\n            parser.add_option(\n                obj=self,\n                opts=self.opts,\n                dest=self.name,\n                action=action,\n                nargs=self.nargs,\n            )",
          "line_count": 38,
          "needs_llm_summary": true
        },
        {
          "name": "get_help_record",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 2988,
          "decorators": [],
          "is_async": false,
          "calls": [
            "extra_items.append",
            "extra_items",
            "unknown.join",
            "self.get_help_extra",
            "ctx",
            "self.opts",
            "join_options",
            "rv",
            "self.make_metavar",
            "rv.append",
            "opts",
            "_",
            "self.secondary_opts",
            "unknown.format",
            "_write_opts"
          ],
          "docstring": null,
          "code": "def get_help_record(self, ctx: Context) -> tuple[str, str] | None:\n        if self.hidden:\n            return None\n\n        any_prefix_is_slash = False\n\n        def _write_opts(opts: cabc.Sequence[str]) -> str:\n            nonlocal any_prefix_is_slash\n\n            rv, any_slashes = join_options(opts)\n\n            if any_slashes:\n                any_prefix_is_slash = True\n\n            if not self.is_flag and not self.count:\n                rv += f\" {self.make_metavar(ctx=ctx)}\"\n\n            return rv\n\n        rv = [_write_opts(self.opts)]\n\n        if self.secondary_opts:\n            rv.append(_write_opts(self.secondary_opts))\n\n        help = self.help or \"\"\n\n        extra = self.get_help_extra(ctx)\n        extra_items = []\n        if \"envvars\" in extra:\n            extra_items.append(\n                _(\"env var: {var}\").format(var=\", \".join(extra[\"envvars\"]))\n            )\n        if \"default\" in extra:\n            extra_items.append(_(\"default: {default}\").format(default=extra[\"default\"]))\n        if \"range\" in extra:\n            extra_items.append(extra[\"range\"])\n        if \"required\" in extra:\n            extra_items.append(_(extra[\"required\"]))\n\n        if extra_items:\n            extra_str = \"; \".join(extra_items)\n            help = f\"{help}  [{extra_str}]\" if help else f\"[{extra_str}]\"\n\n        return (\"; \" if any_prefix_is_slash else \" / \").join(rv), help",
          "line_count": 44,
          "needs_llm_summary": true
        },
        {
          "name": "get_help_extra",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "types.OptionHelpExtra",
          "lineno": 3033,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.show_default",
            "ctx",
            "self.envvar",
            "envvar",
            "isinstance",
            "default_value.name",
            "tuple",
            "self.show_default",
            "ctx.resilient_parsing",
            "_",
            "self.get_default",
            "_split_opt",
            "enum.Enum",
            "types._NumberRangeBase",
            "resilient",
            "str",
            "default_string",
            "self.type._describe_range",
            "range_str",
            "inspect.isfunction",
            "d",
            "default_value",
            "self.name.upper",
            "unknown.join",
            "self.type"
          ],
          "docstring": null,
          "code": "def get_help_extra(self, ctx: Context) -> types.OptionHelpExtra:\n        extra: types.OptionHelpExtra = {}\n\n        if self.show_envvar:\n            envvar = self.envvar\n\n            if envvar is None:\n                if (\n                    self.allow_from_autoenv\n                    and ctx.auto_envvar_prefix is not None\n                    and self.name is not None\n                ):\n                    envvar = f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"\n\n            if envvar is not None:\n                if isinstance(envvar, str):\n                    extra[\"envvars\"] = (envvar,)\n                else:\n                    extra[\"envvars\"] = tuple(str(d) for d in envvar)\n\n        # Temporarily enable resilient parsing to avoid type casting\n        # failing for the default. Might be possible to extend this to\n        # help formatting in general.\n        resilient = ctx.resilient_parsing\n        ctx.resilient_parsing = True\n\n        try:\n            default_value = self.get_default(ctx, call=False)\n        finally:\n            ctx.resilient_parsing = resilient\n\n        show_default = False\n        show_default_is_str = False\n\n        if self.show_default is not None:\n            if isinstance(self.show_default, str):\n                show_default_is_str = show_default = True\n            else:\n                show_default = self.show_default\n        elif ctx.show_default is not None:\n            show_default = ctx.show_default\n\n        if show_default_is_str or (\n            show_default and (default_value not in (None, UNSET))\n        ):\n            if show_default_is_str:\n                default_string = f\"({self.show_default})\"\n            elif isinstance(default_value, (list, tuple)):\n                default_string = \", \".join(str(d) for d in default_value)\n            elif isinstance(default_value, enum.Enum):\n                default_string = default_value.name\n            elif inspect.isfunction(default_value):\n                default_string = _(\"(dynamic)\")\n            elif self.is_bool_flag and self.secondary_opts:\n                # For boolean flags that have distinct True/False opts,\n                # use the opt without prefix instead of the value.\n                default_string = _split_opt(\n                    (self.opts if default_value else self.secondary_opts)[0]\n                )[1]\n            elif self.is_bool_flag and not self.secondary_opts and not default_value:\n                default_string = \"\"\n            elif default_value == \"\":\n                default_string = '\"\"'\n            else:\n                default_string = str(default_value)\n\n            if default_string:\n                extra[\"default\"] = default_string\n\n        if (\n            isinstance(self.type, types._NumberRangeBase)\n            # skip count with default range type\n            and not (self.count and self.type.min == 0 and self.type.max is None)\n        ):\n            range_str = self.type._describe_range()\n\n            if range_str:\n                extra[\"range\"] = range_str\n\n        if self.required:\n            extra[\"required\"] = \"required\"\n\n        return extra",
          "line_count": 83,
          "needs_llm_summary": true
        },
        {
          "name": "prompt_for_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "t.Any",
          "lineno": 3117,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.show_default",
            "self.hide_input",
            "confirm",
            "ctx",
            "self.confirmation_prompt",
            "self.process_value",
            "prompt",
            "isinstance",
            "self.type",
            "self.get_default",
            "bool",
            "self.show_choices",
            "default",
            "prompt_kwargs",
            "x",
            "self.prompt"
          ],
          "docstring": "This is an alternative flow that can be activated in the full\nvalue processing if a value does not exist.  It will prompt the\nuser until a valid value exists and then returns the processed\nvalue as result.",
          "code": "def prompt_for_value(self, ctx: Context) -> t.Any:\n        \"\"\"This is an alternative flow that can be activated in the full\n        value processing if a value does not exist.  It will prompt the\n        user until a valid value exists and then returns the processed\n        value as result.\n        \"\"\"\n        assert self.prompt is not None\n\n        # Calculate the default before prompting anything to lock in the value before\n        # attempting any user interaction.\n        default = self.get_default(ctx)\n\n        # A boolean flag can use a simplified [y/n] confirmation prompt.\n        if self.is_bool_flag:\n            # If we have no boolean default, we force the user to explicitly provide\n            # one.\n            if default in (UNSET, None):\n                default = None\n            # Nothing prevent you to declare an option that is simultaneously:\n            # 1) auto-detected as a boolean flag,\n            # 2) allowed to prompt, and\n            # 3) still declare a non-boolean default.\n            # This forced casting into a boolean is necessary to align any non-boolean\n            # default to the prompt, which is going to be a [y/n]-style confirmation\n            # because the option is still a boolean flag. That way, instead of [y/n],\n            # we get [Y/n] or [y/N] depending on the truthy value of the default.\n            # Refs: https://github.com/pallets/click/pull/3030#discussion_r2289180249\n            else:\n                default = bool(default)\n            return confirm(self.prompt, default)\n\n        # If show_default is set to True/False, provide this to `prompt` as well. For\n        # non-bool values of `show_default`, we use `prompt`'s default behavior\n        prompt_kwargs: t.Any = {}\n        if isinstance(self.show_default, bool):\n            prompt_kwargs[\"show_default\"] = self.show_default\n\n        return prompt(\n            self.prompt,\n            # Use ``None`` to inform the prompt() function to reiterate until a valid\n            # value is provided by the user if we have no default.\n            default=None if default is UNSET else default,\n            type=self.type,\n            hide_input=self.hide_input,\n            show_choices=self.show_choices,\n            confirmation_prompt=self.confirmation_prompt,\n            value_proc=lambda x: self.process_value(ctx, x),\n            **prompt_kwargs,\n        )",
          "line_count": 49,
          "needs_llm_summary": true
        },
        {
          "name": "resolve_envvar_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 3167,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.environ.get",
            "ctx",
            "envvar",
            "unknown.resolve_envvar_value",
            "super",
            "self.name.upper"
          ],
          "docstring": ":class:`Option` resolves its environment variable the same way as\n:func:`Parameter.resolve_envvar_value`, but it also supports\n:attr:`Context.auto_envvar_prefix`. If we could not find an environment from\nthe :attr:`envvar` property, we fallback on :attr:`Context.auto_envvar_prefix`\nto build dynamiccaly the environment variable name using the\n:python:`{ctx.auto_envvar_prefix}_{self.name.upper()}` template.\n\n:meta private:",
          "code": "def resolve_envvar_value(self, ctx: Context) -> str | None:\n        \"\"\":class:`Option` resolves its environment variable the same way as\n        :func:`Parameter.resolve_envvar_value`, but it also supports\n        :attr:`Context.auto_envvar_prefix`. If we could not find an environment from\n        the :attr:`envvar` property, we fallback on :attr:`Context.auto_envvar_prefix`\n        to build dynamiccaly the environment variable name using the\n        :python:`{ctx.auto_envvar_prefix}_{self.name.upper()}` template.\n\n        :meta private:\n        \"\"\"\n        rv = super().resolve_envvar_value(ctx)\n\n        if rv is not None:\n            return rv\n\n        if (\n            self.allow_from_autoenv\n            and ctx.auto_envvar_prefix is not None\n            and self.name is not None\n        ):\n            envvar = f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"\n            rv = os.environ.get(envvar)\n\n            if rv:\n                return rv\n\n        return None",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "value_from_envvar",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "t.Any",
          "lineno": 3195,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "types.BoolParamType.str_to_bool",
            "self.resolve_envvar_value",
            "rv",
            "multi_rv",
            "self.multiple",
            "self.type.split_envvar_value",
            "bool",
            "batch",
            "self.nargs"
          ],
          "docstring": "For :class:`Option`, this method processes the raw environment variable\nstring the same way as :func:`Parameter.value_from_envvar` does.\n\nBut in the case of non-boolean flags, the value is analyzed to determine if the\nflag is activated or not, and returns a boolean of its activation, or the\n:attr:`flag_value` if the latter is set.\n\nThis method also takes care of repeated options (i.e. options with\n:attr:`multiple` set to ``True``).\n\n:meta private:",
          "code": "def value_from_envvar(self, ctx: Context) -> t.Any:\n        \"\"\"For :class:`Option`, this method processes the raw environment variable\n        string the same way as :func:`Parameter.value_from_envvar` does.\n\n        But in the case of non-boolean flags, the value is analyzed to determine if the\n        flag is activated or not, and returns a boolean of its activation, or the\n        :attr:`flag_value` if the latter is set.\n\n        This method also takes care of repeated options (i.e. options with\n        :attr:`multiple` set to ``True``).\n\n        :meta private:\n        \"\"\"\n        rv = self.resolve_envvar_value(ctx)\n\n        # Absent environment variable or an empty string is interpreted as unset.\n        if rv is None:\n            return None\n\n        # Non-boolean flags are more liberal in what they accept. But a flag being a\n        # flag, its envvar value still needs to be analyzed to determine if the flag is\n        # activated or not.\n        if self.is_flag and not self.is_bool_flag:\n            # If the flag_value is set and match the envvar value, return it\n            # directly.\n            if self.flag_value is not UNSET and rv == self.flag_value:\n                return self.flag_value\n            # Analyze the envvar value as a boolean to know if the flag is\n            # activated or not.\n            return types.BoolParamType.str_to_bool(rv)\n\n        # Split the envvar value if it is allowed to be repeated.\n        value_depth = (self.nargs != 1) + bool(self.multiple)\n        if value_depth > 0:\n            multi_rv = self.type.split_envvar_value(rv)\n            if self.multiple and self.nargs != 1:\n                multi_rv = batch(multi_rv, self.nargs)  # type: ignore[assignment]\n\n            return multi_rv\n\n        return rv",
          "line_count": 41,
          "needs_llm_summary": true
        },
        {
          "name": "consume_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "opts",
              "type": "cabc.Mapping[str, Parameter]"
            }
          ],
          "return_type": "tuple[t.Any, ParameterSource]",
          "lineno": 3237,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ParameterSource.PROMPT",
            "ctx",
            "any",
            "opts",
            "ParameterSource.COMMANDLINE",
            "self.prompt_for_value",
            "super",
            "unknown.consume_value",
            "self.flag_value"
          ],
          "docstring": "For :class:`Option`, the value can be collected from an interactive prompt\nif the option is a flag that needs a value (and the :attr:`prompt` property is\nset).\n\nAdditionally, this method handles flag option that are activated without a\nvalue, in which case the :attr:`flag_value` is returned.\n\n:meta private:",
          "code": "def consume_value(\n        self, ctx: Context, opts: cabc.Mapping[str, Parameter]\n    ) -> tuple[t.Any, ParameterSource]:\n        \"\"\"For :class:`Option`, the value can be collected from an interactive prompt\n        if the option is a flag that needs a value (and the :attr:`prompt` property is\n        set).\n\n        Additionally, this method handles flag option that are activated without a\n        value, in which case the :attr:`flag_value` is returned.\n\n        :meta private:\n        \"\"\"\n        value, source = super().consume_value(ctx, opts)\n\n        # The parser will emit a sentinel value if the option is allowed to as a flag\n        # without a value.\n        if value is FLAG_NEEDS_VALUE:\n            # If the option allows for a prompt, we start an interaction with the user.\n            if self.prompt is not None and not ctx.resilient_parsing:\n                value = self.prompt_for_value(ctx)\n                source = ParameterSource.PROMPT\n            # Else the flag takes its flag_value as value.\n            else:\n                value = self.flag_value\n                source = ParameterSource.COMMANDLINE\n\n        # A flag which is activated always returns the flag value, unless the value\n        # comes from the explicitly sets default.\n        elif (\n            self.is_flag\n            and value is True\n            and not self.is_bool_flag\n            and source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)\n        ):\n            value = self.flag_value\n\n        # Re-interpret a multiple option which has been sent as-is by the parser.\n        # Here we replace each occurrence of value-less flags (marked by the\n        # FLAG_NEEDS_VALUE sentinel) with the flag_value.\n        elif (\n            self.multiple\n            and value is not UNSET\n            and source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)\n            and any(v is FLAG_NEEDS_VALUE for v in value)\n        ):\n            value = [self.flag_value if v is FLAG_NEEDS_VALUE else v for v in value]\n            source = ParameterSource.COMMANDLINE\n\n        # The value wasn't set, or used the param's default, prompt for one to the user\n        # if prompting is enabled.\n        elif (\n            (\n                value is UNSET\n                or source in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)\n            )\n            and self.prompt is not None\n            and (self.required or self.prompt_required)\n            and not ctx.resilient_parsing\n        ):\n            value = self.prompt_for_value(ctx)\n            source = ParameterSource.PROMPT\n\n        return value, source",
          "line_count": 63,
          "needs_llm_summary": true
        },
        {
          "name": "process_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 3301,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.process_value",
            "self",
            "value",
            "ctx",
            "self.callback",
            "super"
          ],
          "docstring": null,
          "code": "def process_value(self, ctx: Context, value: t.Any) -> t.Any:\n        # process_value has to be overridden on Options in order to capture\n        # `value == UNSET` cases before `type_cast_value()` gets called.\n        #\n        # Refs:\n        # https://github.com/pallets/click/issues/3069\n        if self.is_flag and not self.required and self.is_bool_flag and value is UNSET:\n            value = False\n\n            if self.callback is not None:\n                value = self.callback(ctx, self, value)\n\n            return value\n\n        # in the normal case, rely on Parameter.process_value\n        return super().process_value(ctx, value)",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "param_decls",
              "type": "cabc.Sequence[str]"
            },
            {
              "name": "required",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 3329,
          "decorators": [],
          "is_async": false,
          "calls": [
            "UNSET",
            "unknown.__init__",
            "required",
            "TypeError",
            "attrs.get",
            "attrs",
            "super",
            "param_decls"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        param_decls: cabc.Sequence[str],\n        required: bool | None = None,\n        **attrs: t.Any,\n    ) -> None:\n        # Auto-detect the requirement status of the argument if not explicitly set.\n        if required is None:\n            # The argument gets automatically required if it has no explicit default\n            # value set and is setup to match at least one value.\n            if attrs.get(\"default\", UNSET) is UNSET:\n                required = attrs.get(\"nargs\", 1) > 0\n            # If the argument has a default value, it is not required.\n            else:\n                required = False\n\n        if \"multiple\" in attrs:\n            raise TypeError(\"__init__() got an unexpected keyword argument 'multiple'.\")\n\n        super().__init__(param_decls, required=required, **attrs)",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "human_readable_name",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 3351,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.name.upper"
          ],
          "docstring": null,
          "code": "def human_readable_name(self) -> str:\n        if self.metavar is not None:\n            return self.metavar\n        return self.name.upper()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "make_metavar",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "str",
          "lineno": 3356,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "self.name.upper",
            "self",
            "self.type.get_metavar"
          ],
          "docstring": null,
          "code": "def make_metavar(self, ctx: Context) -> str:\n        if self.metavar is not None:\n            return self.metavar\n        var = self.type.get_metavar(param=self, ctx=ctx)\n        if not var:\n            var = self.name.upper()  # type: ignore\n        if self.deprecated:\n            var += \"!\"\n        if not self.required:\n            var = f\"[{var}]\"\n        if self.nargs != 1:\n            var += \"...\"\n        return var",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "_parse_decls",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "decls",
              "type": "cabc.Sequence[str]"
            },
            {
              "name": "expose_value",
              "type": "bool"
            }
          ],
          "return_type": "tuple[Any, list[str], list[str]]",
          "lineno": 3370,
          "decorators": [],
          "is_async": false,
          "calls": [
            "len",
            "decls",
            "unknown.lower",
            "TypeError",
            "name.replace"
          ],
          "docstring": null,
          "code": "def _parse_decls(\n        self, decls: cabc.Sequence[str], expose_value: bool\n    ) -> tuple[str | None, list[str], list[str]]:\n        if not decls:\n            if not expose_value:\n                return None, [], []\n            raise TypeError(\"Argument is marked as exposed, but does not have a name.\")\n        if len(decls) == 1:\n            name = arg = decls[0]\n            name = name.replace(\"-\", \"_\").lower()\n        else:\n            raise TypeError(\n                \"Arguments take exactly one parameter declaration, got\"\n                f\" {len(decls)}: {decls}.\"\n            )\n        return name, [arg], []",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "get_usage_pieces",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "list[str]",
          "lineno": 3387,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.make_metavar",
            "ctx"
          ],
          "docstring": null,
          "code": "def get_usage_pieces(self, ctx: Context) -> list[str]:\n        return [self.make_metavar(ctx)]",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_error_hint",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "str",
          "lineno": 3390,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.make_metavar",
            "ctx"
          ],
          "docstring": null,
          "code": "def get_error_hint(self, ctx: Context) -> str:\n        return f\"'{self.make_metavar(ctx)}'\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "add_to_parser",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "parser",
              "type": "_OptionParser"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "None",
          "lineno": 3393,
          "decorators": [],
          "is_async": false,
          "calls": [
            "parser.add_argument",
            "self.nargs",
            "self.name",
            "self"
          ],
          "docstring": null,
          "code": "def add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:\n        parser.add_argument(dest=self.name, nargs=self.nargs, obj=self)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[Ellipsis, t.Any]"
            }
          ],
          "return_type": "Command",
          "lineno": 1671,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.add_command",
            "command",
            "f",
            "kwargs",
            "cmd"
          ],
          "docstring": null,
          "code": "def decorator(f: t.Callable[..., t.Any]) -> Command:\n            cmd: Command = command(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return cmd",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[Ellipsis, t.Any]"
            }
          ],
          "return_type": "Group",
          "lineno": 1723,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.add_command",
            "group",
            "f",
            "kwargs",
            "cmd"
          ],
          "docstring": null,
          "code": "def decorator(f: t.Callable[..., t.Any]) -> Group:\n            cmd: Group = group(*args, **kwargs)(f)\n            self.add_command(cmd)\n            return cmd",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "F"
            }
          ],
          "return_type": "F",
          "lineno": 1762,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "old_callback",
            "f",
            "t.cast",
            "function",
            "update_wrapper",
            "kwargs",
            "inner",
            "F",
            "self._result_callback"
          ],
          "docstring": null,
          "code": "def decorator(f: F) -> F:\n            old_callback = self._result_callback\n\n            if old_callback is None or replace:\n                self._result_callback = f\n                return f\n\n            def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n                inner = old_callback(value, *args, **kwargs)\n                return f(inner, *args, **kwargs)\n\n            self._result_callback = rv = update_wrapper(t.cast(F, function), f)\n            return rv",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "_process_result",
          "args": [
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 1840,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "ctx.params",
            "ctx.invoke",
            "self._result_callback"
          ],
          "docstring": null,
          "code": "def _process_result(value: t.Any) -> t.Any:\n            if self._result_callback is not None:\n                value = ctx.invoke(self._result_callback, value, **ctx.params)\n            return value",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "check_iter",
          "args": [
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "cabc.Iterator[t.Any]",
          "lineno": 2347,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "value",
            "ctx",
            "_check_iter",
            "_",
            "BadParameter"
          ],
          "docstring": null,
          "code": "def check_iter(value: t.Any) -> cabc.Iterator[t.Any]:\n            try:\n                return _check_iter(value)\n            except TypeError:\n                # This should only happen when passing in args manually,\n                # the parser should construct an iterable when parsing\n                # the command line.\n                raise BadParameter(\n                    _(\"Value must be an iterable.\"), ctx=ctx, param=self\n                ) from None",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "_write_opts",
          "args": [
            {
              "name": "opts",
              "type": "cabc.Sequence[str]"
            }
          ],
          "return_type": "str",
          "lineno": 2994,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.make_metavar",
            "join_options",
            "ctx",
            "opts"
          ],
          "docstring": null,
          "code": "def _write_opts(opts: cabc.Sequence[str]) -> str:\n            nonlocal any_prefix_is_slash\n\n            rv, any_slashes = join_options(opts)\n\n            if any_slashes:\n                any_prefix_is_slash = True\n\n            if not self.is_flag and not self.count:\n                rv += f\" {self.make_metavar(ctx=ctx)}\"\n\n            return rv",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "function",
          "args": [],
          "return_type": "t.Any",
          "lineno": 1769,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "old_callback",
            "f",
            "kwargs",
            "inner"
          ],
          "docstring": null,
          "code": "def function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n                inner = old_callback(value, *args, **kwargs)\n                return f(inner, *args, **kwargs)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 2362,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "self.type",
            "self",
            "value"
          ],
          "docstring": null,
          "code": "def convert(value: t.Any) -> t.Any:\n                return self.type(value, param=self, ctx=ctx)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 2367,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "check_iter",
            "self",
            "value",
            "ctx",
            "self.type",
            "x"
          ],
          "docstring": null,
          "code": "def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]\n                return tuple(self.type(x, self, ctx) for x in check_iter(value))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 2372,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "check_iter",
            "self",
            "value",
            "ctx",
            "len",
            "ngettext",
            "self.type",
            "BadParameter",
            "self.nargs",
            "unknown.format",
            "x"
          ],
          "docstring": null,
          "code": "def convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]\n                value = tuple(check_iter(value))\n\n                if len(value) != self.nargs:\n                    raise BadParameter(\n                        ngettext(\n                            \"Takes {nargs} values but 1 was given.\",\n                            \"Takes {nargs} values but {len} were given.\",\n                            len(value),\n                        ).format(nargs=self.nargs, len=len(value)),\n                        ctx=ctx,\n                        param=self,\n                    )\n\n                return tuple(self.type(x, self, ctx) for x in value)",
          "line_count": 15,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "ParameterSource",
          "methods": [],
          "base_classes": [
            "enum.Enum"
          ],
          "lineno": 143,
          "docstring": "This is an :class:`~enum.Enum` that indicates the source of a\nparameter's value.\n\nUse :meth:`click.Context.get_parameter_source` to get the\nsource for a parameter by name.\n\n.. versionchanged:: 8.0\n    Use :class:`~enum.Enum` and drop the ``validate`` method.\n\n.. versionchanged:: 8.0\n    Added the ``PROMPT`` value."
        },
        {
          "name": "Context",
          "methods": [
            "__init__",
            "protected_args",
            "to_info_dict",
            "__enter__",
            "__exit__",
            "scope",
            "meta",
            "make_formatter",
            "with_resource",
            "call_on_close",
            "close",
            "_close_with_exception_info",
            "command_path",
            "find_root",
            "find_object",
            "ensure_object",
            "lookup_default",
            "lookup_default",
            "lookup_default",
            "fail",
            "abort",
            "exit",
            "get_usage",
            "get_help",
            "_make_sub_context",
            "invoke",
            "invoke",
            "invoke",
            "forward",
            "set_parameter_source",
            "get_parameter_source"
          ],
          "base_classes": [],
          "lineno": 169,
          "docstring": "The context is a special internal object that holds state relevant\nfor the script execution at every single level.  It's normally invisible\nto commands unless they opt-in to getting access to it.\n\nThe context is useful as it can pass internal objects around and can\ncontrol special execution features such as reading data from\nenvironment variables.\n\nA context can be used as context manager in which case it will call\n:meth:`close` on teardown.\n\n:param command: the command class for this context.\n:param parent: the parent context.\n:param info_name: the info name for this invocation.  Generally this\n                  is the most descriptive name for the script or\n                  command.  For the toplevel script it is usually\n                  the name of the script, for commands below it it's\n                  the name of the script.\n:param obj: an arbitrary object of user data.\n:param auto_envvar_prefix: the prefix to use for automatic environment\n                           variables.  If this is `None` then reading\n                           from environment variables is disabled.  This\n                           does not affect manually set environment\n                           variables which are always read.\n:param default_map: a dictionary (like object) with default values\n                    for parameters.\n:param terminal_width: the width of the terminal.  The default is\n                       inherit from parent context.  If no context\n                       defines the terminal width then auto\n                       detection will be applied.\n:param max_content_width: the maximum width for content rendered by\n                          Click (this currently only affects help\n                          pages).  This defaults to 80 characters if\n                          not overridden.  In other words: even if the\n                          terminal is larger than that, Click will not\n                          format things wider than 80 characters by\n                          default.  In addition to that, formatters might\n                          add some safety mapping on the right.\n:param resilient_parsing: if this flag is enabled then Click will\n                          parse without any interactivity or callback\n                          invocation.  Default values will also be\n                          ignored.  This is useful for implementing\n                          things such as completion support.\n:param allow_extra_args: if this is set to `True` then extra arguments\n                         at the end will not raise an error and will be\n                         kept on the context.  The default is to inherit\n                         from the command.\n:param allow_interspersed_args: if this is set to `False` then options\n                                and arguments cannot be mixed.  The\n                                default is to inherit from the command.\n:param ignore_unknown_options: instructs click to ignore options it does\n                               not know and keeps them for later\n                               processing.\n:param help_option_names: optionally a list of strings that define how\n                          the default help parameter is named.  The\n                          default is ``['--help']``.\n:param token_normalize_func: an optional function that is used to\n                             normalize tokens (options, choices,\n                             etc.).  This for instance can be used to\n                             implement case insensitive behavior.\n:param color: controls if the terminal supports ANSI colors or not.  The\n              default is autodetection.  This is only needed if ANSI\n              codes are used in texts that Click prints which is by\n              default not the case.  This for instance would affect\n              help output.\n:param show_default: Show the default value for commands. If this\n    value is not set, it defaults to the value from the parent\n    context. ``Command.show_default`` overrides this default for the\n    specific command.\n\n.. versionchanged:: 8.2\n    The ``protected_args`` attribute is deprecated and will be removed in\n    Click 9.0. ``args`` will contain remaining unparsed tokens.\n\n.. versionchanged:: 8.1\n    The ``show_default`` parameter is overridden by\n    ``Command.show_default``, instead of the other way around.\n\n.. versionchanged:: 8.0\n    The ``show_default`` parameter defaults to the value from the\n    parent context.\n\n.. versionchanged:: 7.1\n   Added the ``show_default`` parameter.\n\n.. versionchanged:: 4.0\n    Added the ``color``, ``ignore_unknown_options``, and\n    ``max_content_width`` parameters.\n\n.. versionchanged:: 3.0\n    Added the ``allow_extra_args`` and ``allow_interspersed_args``\n    parameters.\n\n.. versionchanged:: 2.0\n    Added the ``resilient_parsing``, ``help_option_names``, and\n    ``token_normalize_func`` parameters."
        },
        {
          "name": "Command",
          "methods": [
            "__init__",
            "to_info_dict",
            "__repr__",
            "get_usage",
            "get_params",
            "format_usage",
            "collect_usage_pieces",
            "get_help_option_names",
            "get_help_option",
            "make_parser",
            "get_help",
            "get_short_help_str",
            "format_help",
            "format_help_text",
            "format_options",
            "format_epilog",
            "make_context",
            "parse_args",
            "invoke",
            "shell_complete",
            "main",
            "main",
            "main",
            "_main_shell_completion",
            "__call__"
          ],
          "base_classes": [],
          "lineno": 873,
          "docstring": "Commands are the basic building block of command line interfaces in\nClick.  A basic command handles command line parsing and might dispatch\nmore parsing to commands nested below it.\n\n:param name: the name of the command to use unless a group overrides it.\n:param context_settings: an optional dictionary with defaults that are\n                         passed to the context object.\n:param callback: the callback to invoke.  This is optional.\n:param params: the parameters to register with this command.  This can\n               be either :class:`Option` or :class:`Argument` objects.\n:param help: the help string to use for this command.\n:param epilog: like the help string but it's printed at the end of the\n               help page after everything else.\n:param short_help: the short help to use for this command.  This is\n                   shown on the command listing of the parent command.\n:param add_help_option: by default each command registers a ``--help``\n                        option.  This can be disabled by this parameter.\n:param no_args_is_help: this controls what happens if no arguments are\n                        provided.  This option is disabled by default.\n                        If enabled this will add ``--help`` as argument\n                        if no arguments are passed\n:param hidden: hide this command from help outputs.\n:param deprecated: If ``True`` or non-empty string, issues a message\n                    indicating that the command is deprecated and highlights\n                    its deprecation in --help. The message can be customized\n                    by using a string as the value.\n\n.. versionchanged:: 8.2\n    This is the base class for all commands, not ``BaseCommand``.\n    ``deprecated`` can be set to a string as well to customize the\n    deprecation message.\n\n.. versionchanged:: 8.1\n    ``help``, ``epilog``, and ``short_help`` are stored unprocessed,\n    all formatting is done when outputting help text, not at init,\n    and is done even if not using the ``@command`` decorator.\n\n.. versionchanged:: 8.0\n    Added a ``repr`` showing the command name.\n\n.. versionchanged:: 7.1\n    Added the ``no_args_is_help`` parameter.\n\n.. versionchanged:: 2.0\n    Added the ``context_settings`` parameter."
        },
        {
          "name": "_FakeSubclassCheck",
          "methods": [
            "__subclasscheck__",
            "__instancecheck__"
          ],
          "base_classes": [
            "type"
          ],
          "lineno": 1488,
          "docstring": null
        },
        {
          "name": "_BaseCommand",
          "methods": [],
          "base_classes": [
            "Command"
          ],
          "lineno": 1496,
          "docstring": ".. deprecated:: 8.2\n    Will be removed in Click 9.0. Use ``Command`` instead."
        },
        {
          "name": "Group",
          "methods": [
            "__init__",
            "to_info_dict",
            "add_command",
            "command",
            "command",
            "command",
            "group",
            "group",
            "group",
            "result_callback",
            "get_command",
            "list_commands",
            "collect_usage_pieces",
            "format_options",
            "format_commands",
            "parse_args",
            "invoke",
            "resolve_command",
            "shell_complete"
          ],
          "base_classes": [
            "Command"
          ],
          "lineno": 1503,
          "docstring": "A group is a command that nests other commands (or more groups).\n\n:param name: The name of the group command.\n:param commands: Map names to :class:`Command` objects. Can be a list, which\n    will use :attr:`Command.name` as the keys.\n:param invoke_without_command: Invoke the group's callback even if a\n    subcommand is not given.\n:param no_args_is_help: If no arguments are given, show the group's help and\n    exit. Defaults to the opposite of ``invoke_without_command``.\n:param subcommand_metavar: How to represent the subcommand argument in help.\n    The default will represent whether ``chain`` is set or not.\n:param chain: Allow passing more than one subcommand argument. After parsing\n    a command's arguments, if any arguments remain another command will be\n    matched, and so on.\n:param result_callback: A function to call after the group's and\n    subcommand's callbacks. The value returned by the subcommand is passed.\n    If ``chain`` is enabled, the value will be a list of values returned by\n    all the commands. If ``invoke_without_command`` is enabled, the value\n    will be the value returned by the group's callback, or an empty list if\n    ``chain`` is enabled.\n:param kwargs: Other arguments passed to :class:`Command`.\n\n.. versionchanged:: 8.0\n    The ``commands`` argument can be a list of command objects.\n\n.. versionchanged:: 8.2\n    Merged with and replaces the ``MultiCommand`` base class."
        },
        {
          "name": "_MultiCommand",
          "methods": [],
          "base_classes": [
            "Group"
          ],
          "lineno": 1954,
          "docstring": ".. deprecated:: 8.2\n    Will be removed in Click 9.0. Use ``Group`` instead."
        },
        {
          "name": "CommandCollection",
          "methods": [
            "__init__",
            "add_source",
            "get_command",
            "list_commands"
          ],
          "base_classes": [
            "Group"
          ],
          "lineno": 1961,
          "docstring": "A :class:`Group` that looks up subcommands on other groups. If a command\nis not found on this group, each registered source is checked in order.\nParameters on a source are not added to this group, and a source's callback\nis not invoked when invoking its commands. In other words, this \"flattens\"\ncommands in many groups into this one group.\n\n:param name: The name of the group command.\n:param sources: A list of :class:`Group` objects to look up commands from.\n:param kwargs: Other arguments passed to :class:`Group`.\n\n.. versionchanged:: 8.2\n    This is a subclass of ``Group``. Commands are looked up first on this\n    group, then each of its sources."
        },
        {
          "name": "Parameter",
          "methods": [
            "__init__",
            "to_info_dict",
            "__repr__",
            "_parse_decls",
            "human_readable_name",
            "make_metavar",
            "get_default",
            "get_default",
            "get_default",
            "add_to_parser",
            "consume_value",
            "type_cast_value",
            "value_is_missing",
            "process_value",
            "resolve_envvar_value",
            "value_from_envvar",
            "handle_parse_result",
            "get_help_record",
            "get_usage_pieces",
            "get_error_hint",
            "shell_complete"
          ],
          "base_classes": [],
          "lineno": 2027,
          "docstring": "A parameter to a command comes in two versions: they are either\n:class:`Option`\\s or :class:`Argument`\\s.  Other subclasses are currently\nnot supported by design as some of the internals for parsing are\nintentionally not finalized.\n\nSome settings are supported by both options and arguments.\n\n:param param_decls: the parameter declarations for this option or\n                    argument.  This is a list of flags or argument\n                    names.\n:param type: the type that should be used.  Either a :class:`ParamType`\n             or a Python type.  The latter is converted into the former\n             automatically if supported.\n:param required: controls if this is optional or not.\n:param default: the default value if omitted.  This can also be a callable,\n                in which case it's invoked when the default is needed\n                without any arguments.\n:param callback: A function to further process or validate the value\n    after type conversion. It is called as ``f(ctx, param, value)``\n    and must return the value. It is called for all sources,\n    including prompts.\n:param nargs: the number of arguments to match.  If not ``1`` the return\n              value is a tuple instead of single value.  The default for\n              nargs is ``1`` (except if the type is a tuple, then it's\n              the arity of the tuple). If ``nargs=-1``, all remaining\n              parameters are collected.\n:param metavar: how the value is represented in the help page.\n:param expose_value: if this is `True` then the value is passed onwards\n                     to the command callback and stored on the context,\n                     otherwise it's skipped.\n:param is_eager: eager values are processed before non eager ones.  This\n                 should not be set for arguments or it will inverse the\n                 order of processing.\n:param envvar: environment variable(s) that are used to provide a default value for\n    this parameter. This can be a string or a sequence of strings. If a sequence is\n    given, only the first non-empty environment variable is used for the parameter.\n:param shell_complete: A function that returns custom shell\n    completions. Used instead of the param's type completion if\n    given. Takes ``ctx, param, incomplete`` and must return a list\n    of :class:`~click.shell_completion.CompletionItem` or a list of\n    strings.\n:param deprecated: If ``True`` or non-empty string, issues a message\n                    indicating that the argument is deprecated and highlights\n                    its deprecation in --help. The message can be customized\n                    by using a string as the value. A deprecated parameter\n                    cannot be required, a ValueError will be raised otherwise.\n\n.. versionchanged:: 8.2.0\n    Introduction of ``deprecated``.\n\n.. versionchanged:: 8.2\n    Adding duplicate parameter names to a :class:`~click.core.Command` will\n    result in a ``UserWarning`` being shown.\n\n.. versionchanged:: 8.2\n    Adding duplicate parameter names to a :class:`~click.core.Command` will\n    result in a ``UserWarning`` being shown.\n\n.. versionchanged:: 8.0\n    ``process_value`` validates required parameters and bounded\n    ``nargs``, and invokes the parameter callback before returning\n    the value. This allows the callback to validate prompts.\n    ``full_process_value`` is removed.\n\n.. versionchanged:: 8.0\n    ``autocompletion`` is renamed to ``shell_complete`` and has new\n    semantics described above. The old name is deprecated and will\n    be removed in 8.1, until then it will be wrapped to match the\n    new requirements.\n\n.. versionchanged:: 8.0\n    For ``multiple=True, nargs>1``, the default must be a list of\n    tuples.\n\n.. versionchanged:: 8.0\n    Setting a default is no longer required for ``nargs>1``, it will\n    default to ``None``. ``multiple=True`` or ``nargs=-1`` will\n    default to ``()``.\n\n.. versionchanged:: 7.1\n    Empty environment variables are ignored rather than taking the\n    empty string value. This makes it possible for scripts to clear\n    variables if they can't unset them.\n\n.. versionchanged:: 2.0\n    Changed signature for parameter callback to also be passed the\n    parameter. The old callback format will still work, but it will\n    raise a warning to give you a chance to migrate the code easier."
        },
        {
          "name": "Option",
          "methods": [
            "__init__",
            "to_info_dict",
            "get_error_hint",
            "_parse_decls",
            "add_to_parser",
            "get_help_record",
            "get_help_extra",
            "prompt_for_value",
            "resolve_envvar_value",
            "value_from_envvar",
            "consume_value",
            "process_value"
          ],
          "base_classes": [
            "Parameter"
          ],
          "lineno": 2641,
          "docstring": "Options are usually optional values on the command line and\nhave some extra features that arguments don't have.\n\nAll other parameters are passed onwards to the parameter constructor.\n\n:param show_default: Show the default value for this option in its\n    help text. Values are not shown by default, unless\n    :attr:`Context.show_default` is ``True``. If this value is a\n    string, it shows that string in parentheses instead of the\n    actual value. This is particularly useful for dynamic options.\n    For single option boolean flags, the default remains hidden if\n    its value is ``False``.\n:param show_envvar: Controls if an environment variable should be\n    shown on the help page and error messages.\n    Normally, environment variables are not shown.\n:param prompt: If set to ``True`` or a non empty string then the\n    user will be prompted for input. If set to ``True`` the prompt\n    will be the option name capitalized. A deprecated option cannot be\n    prompted.\n:param confirmation_prompt: Prompt a second time to confirm the\n    value if it was prompted for. Can be set to a string instead of\n    ``True`` to customize the message.\n:param prompt_required: If set to ``False``, the user will be\n    prompted for input only when the option was specified as a flag\n    without a value.\n:param hide_input: If this is ``True`` then the input on the prompt\n    will be hidden from the user. This is useful for password input.\n:param is_flag: forces this option to act as a flag.  The default is\n                auto detection.\n:param flag_value: which value should be used for this flag if it's\n                   enabled.  This is set to a boolean automatically if\n                   the option string contains a slash to mark two options.\n:param multiple: if this is set to `True` then the argument is accepted\n                 multiple times and recorded.  This is similar to ``nargs``\n                 in how it works but supports arbitrary number of\n                 arguments.\n:param count: this flag makes an option increment an integer.\n:param allow_from_autoenv: if this is enabled then the value of this\n                           parameter will be pulled from an environment\n                           variable in case a prefix is defined on the\n                           context.\n:param help: the help string.\n:param hidden: hide this option from help outputs.\n:param attrs: Other command arguments described in :class:`Parameter`.\n\n.. versionchanged:: 8.2\n    ``envvar`` used with ``flag_value`` will always use the ``flag_value``,\n    previously it would use the value of the environment variable.\n\n.. versionchanged:: 8.1\n    Help text indentation is cleaned here instead of only in the\n    ``@option`` decorator.\n\n.. versionchanged:: 8.1\n    The ``show_default`` parameter overrides\n    ``Context.show_default``.\n\n.. versionchanged:: 8.1\n    The default of a single option boolean flag is not shown if the\n    default value is ``False``.\n\n.. versionchanged:: 8.0.1\n    ``type`` is detected from ``flag_value`` if given."
        },
        {
          "name": "Argument",
          "methods": [
            "__init__",
            "human_readable_name",
            "make_metavar",
            "_parse_decls",
            "get_usage_pieces",
            "get_error_hint",
            "add_to_parser"
          ],
          "base_classes": [
            "Parameter"
          ],
          "lineno": 3319,
          "docstring": "Arguments are positional parameters to a command.  They generally\nprovide fewer features than options but can have infinite ``nargs``\nand are required by default.\n\nAll parameters are passed onwards to the constructor of :class:`Parameter`."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "enum",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "errno",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "inspect",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "collections",
          "name": "abc",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "collections",
          "name": "Counter",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "contextlib",
          "name": "AbstractContextManager",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "contextlib",
          "name": "contextmanager",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "contextlib",
          "name": "ExitStack",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "ngettext",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "itertools",
          "name": "repeat",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "TracebackType",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "types",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "_utils",
          "name": "FLAG_NEEDS_VALUE",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "_utils",
          "name": "UNSET",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "Abort",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "BadParameter",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ClickException",
          "alias": null,
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "Exit",
          "alias": null,
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "MissingParameter",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "NoArgsIsHelpError",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "UsageError",
          "alias": null,
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "formatting",
          "name": "HelpFormatter",
          "alias": null,
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "formatting",
          "name": "join_options",
          "alias": null,
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "pop_context",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "push_context",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "parser",
          "name": "_OptionParser",
          "alias": null,
          "lineno": 35,
          "type": "from_import"
        },
        {
          "module": "parser",
          "name": "_split_opt",
          "alias": null,
          "lineno": 36,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "confirm",
          "alias": null,
          "lineno": 37,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "prompt",
          "alias": null,
          "lineno": 38,
          "type": "from_import"
        },
        {
          "module": "termui",
          "name": "style",
          "alias": null,
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "_detect_program_name",
          "alias": null,
          "lineno": 40,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "_expand_args",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "echo",
          "alias": null,
          "lineno": 42,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "make_default_short_help",
          "alias": null,
          "lineno": 43,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "make_str",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "PacifyFlushWrapper",
          "alias": null,
          "lineno": 45,
          "type": "from_import"
        },
        {
          "module": "shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 3398,
          "type": "import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 445,
          "type": "import"
        },
        {
          "module": "click.shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 1283,
          "type": "from_import"
        },
        {
          "module": "shell_completion",
          "name": "shell_complete",
          "alias": null,
          "lineno": 1478,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "command",
          "alias": null,
          "lineno": 1657,
          "type": "from_import"
        },
        {
          "module": "decorators",
          "name": "group",
          "alias": null,
          "lineno": 1706,
          "type": "from_import"
        },
        {
          "module": "click.shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 1944,
          "type": "from_import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 1010,
          "type": "import"
        },
        {
          "module": "decorators",
          "name": "help_option",
          "alias": null,
          "lineno": 1073,
          "type": "from_import"
        },
        {
          "module": "click.shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 2632,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "F",
          "assigned_to": "t.TypeVar",
          "lineno": 50
        },
        {
          "name": "V",
          "assigned_to": "t.TypeVar",
          "lineno": 51
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "contextlib",
          "sys",
          "functools",
          "typing",
          "os",
          "enum",
          "collections",
          "warnings",
          "itertools"
        ],
        "third_party": {
          "other": [
            "__future__",
            "errno",
            "inspect",
            "gettext",
            "types",
            "_utils",
            "exceptions",
            "formatting",
            "globals",
            "parser",
            "termui",
            "utils",
            "shell_completion",
            "click",
            "decorators"
          ]
        },
        "tech_stack": []
      },
      "line_count": 3419
    },
    "src/click/decorators.py": {
      "filepath": "../click/src/click/decorators.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "pass_context",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[te.Concatenate[Context, P], R]"
            }
          ],
          "return_type": "t.Callable[P, R]",
          "lineno": 28,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "new_func",
            "get_current_context",
            "update_wrapper",
            "kwargs"
          ],
          "docstring": "Marks a callback as wanting to receive the current context\nobject as first argument.",
          "code": "def pass_context(f: t.Callable[te.Concatenate[Context, P], R]) -> t.Callable[P, R]:\n    \"\"\"Marks a callback as wanting to receive the current context\n    object as first argument.\n    \"\"\"\n\n    def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n        return f(get_current_context(), *args, **kwargs)\n\n    return update_wrapper(new_func, f)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "pass_obj",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[te.Concatenate[T, P], R]"
            }
          ],
          "return_type": "t.Callable[P, R]",
          "lineno": 39,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "new_func",
            "get_current_context",
            "update_wrapper",
            "kwargs",
            "unknown.obj"
          ],
          "docstring": "Similar to :func:`pass_context`, but only pass the object on the\ncontext onwards (:attr:`Context.obj`).  This is useful if that object\nrepresents the state of a nested system.",
          "code": "def pass_obj(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n    \"\"\"Similar to :func:`pass_context`, but only pass the object on the\n    context onwards (:attr:`Context.obj`).  This is useful if that object\n    represents the state of a nested system.\n    \"\"\"\n\n    def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n        return f(get_current_context().obj, *args, **kwargs)\n\n    return update_wrapper(new_func, f)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "make_pass_decorator",
          "args": [
            {
              "name": "object_type",
              "type": "type[T]"
            },
            {
              "name": "ensure",
              "type": "bool"
            }
          ],
          "return_type": "t.Callable[Any, t.Callable[P, R]]",
          "lineno": 51,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.ensure_object",
            "f",
            "new_func",
            "get_current_context",
            "ctx.find_object",
            "RuntimeError",
            "update_wrapper",
            "kwargs",
            "obj",
            "ctx.invoke",
            "object_type"
          ],
          "docstring": "Given an object type this creates a decorator that will work\nsimilar to :func:`pass_obj` but instead of passing the object of the\ncurrent context, it will find the innermost context of type\n:func:`object_type`.\n\nThis generates a decorator that works roughly like this::\n\n    from functools import update_wrapper\n\n    def decorator(f):\n        @pass_context\n        def new_func(ctx, *args, **kwargs):\n            obj = ctx.find_object(object_type)\n            return ctx.invoke(f, obj, *args, **kwargs)\n        return update_wrapper(new_func, f)\n    return decorator\n\n:param object_type: the type of the object to pass.\n:param ensure: if set to `True`, a new object will be created and\n               remembered on the context if it's not there yet.",
          "code": "def make_pass_decorator(\n    object_type: type[T], ensure: bool = False\n) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:\n    \"\"\"Given an object type this creates a decorator that will work\n    similar to :func:`pass_obj` but instead of passing the object of the\n    current context, it will find the innermost context of type\n    :func:`object_type`.\n\n    This generates a decorator that works roughly like this::\n\n        from functools import update_wrapper\n\n        def decorator(f):\n            @pass_context\n            def new_func(ctx, *args, **kwargs):\n                obj = ctx.find_object(object_type)\n                return ctx.invoke(f, obj, *args, **kwargs)\n            return update_wrapper(new_func, f)\n        return decorator\n\n    :param object_type: the type of the object to pass.\n    :param ensure: if set to `True`, a new object will be created and\n                   remembered on the context if it's not there yet.\n    \"\"\"\n\n    def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n\n            obj: T | None\n            if ensure:\n                obj = ctx.ensure_object(object_type)\n            else:\n                obj = ctx.find_object(object_type)\n\n            if obj is None:\n                raise RuntimeError(\n                    \"Managed to invoke callback without a context\"\n                    f\" object of type {object_type.__name__!r}\"\n                    \" existing.\"\n                )\n\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)\n\n    return decorator",
          "line_count": 47,
          "needs_llm_summary": true
        },
        {
          "name": "pass_meta_key",
          "args": [
            {
              "name": "key",
              "type": "str"
            }
          ],
          "return_type": "t.Callable[Any, t.Callable[P, R]]",
          "lineno": 100,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "new_func",
            "get_current_context",
            "update_wrapper",
            "kwargs",
            "obj",
            "ctx.invoke"
          ],
          "docstring": "Create a decorator that passes a key from\n:attr:`click.Context.meta` as the first argument to the decorated\nfunction.\n\n:param key: Key in ``Context.meta`` to pass.\n:param doc_description: Description of the object being passed,\n    inserted into the decorator's docstring. Defaults to \"the 'key'\n    key from Context.meta\".\n\n.. versionadded:: 8.0",
          "code": "def pass_meta_key(\n    key: str, *, doc_description: str | None = None\n) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:\n    \"\"\"Create a decorator that passes a key from\n    :attr:`click.Context.meta` as the first argument to the decorated\n    function.\n\n    :param key: Key in ``Context.meta`` to pass.\n    :param doc_description: Description of the object being passed,\n        inserted into the decorator's docstring. Defaults to \"the 'key'\n        key from Context.meta\".\n\n    .. versionadded:: 8.0\n    \"\"\"\n\n    def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n            obj = ctx.meta[key]\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)\n\n    if doc_description is None:\n        doc_description = f\"the {key!r} key from :attr:`click.Context.meta`\"\n\n    decorator.__doc__ = (\n        f\"Decorator that passes {doc_description} as the first argument\"\n        \" to the decorated function.\"\n    )\n    return decorator",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "command",
          "args": [
            {
              "name": "name",
              "type": "_AnyCallable"
            }
          ],
          "return_type": "Command",
          "lineno": 138,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def command(name: _AnyCallable) -> Command: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "command",
          "args": [
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "cls",
              "type": "type[CmdType]"
            }
          ],
          "return_type": "t.Callable[Any, CmdType]",
          "lineno": 144,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def command(\n    name: str | None,\n    cls: type[CmdType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], CmdType]: ...",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "command",
          "args": [
            {
              "name": "name",
              "type": "None"
            }
          ],
          "return_type": "t.Callable[Any, CmdType]",
          "lineno": 153,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def command(\n    name: None = None,\n    *,\n    cls: type[CmdType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], CmdType]: ...",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "command",
          "args": [
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "cls",
              "type": "None"
            }
          ],
          "return_type": "t.Callable[Any, Command]",
          "lineno": 163,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def command(\n    name: str | None = ..., cls: None = None, **attrs: t.Any\n) -> t.Callable[[_AnyCallable], Command]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "command",
          "args": [
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "cls",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 168,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cls",
            "params.extend",
            "f",
            "TypeError",
            "isinstance",
            "attrs",
            "params",
            "Command",
            "f.__click_params__",
            "attrs.pop",
            "name",
            "func",
            "attrs.get",
            "unknown.replace",
            "f.__name__.lower",
            "cmd_name",
            "reversed",
            "cmd_left",
            "callable",
            "cmd_name.rpartition",
            "decorator",
            "f.__doc__",
            "decorator_params",
            "t.cast"
          ],
          "docstring": "Creates a new :class:`Command` and uses the decorated function as\ncallback.  This will also automatically attach all decorated\n:func:`option`\\s and :func:`argument`\\s as parameters to the command.\n\nThe name of the command defaults to the name of the function, converted to\nlowercase, with underscores ``_`` replaced by dashes ``-``, and the suffixes\n``_command``, ``_cmd``, ``_group``, and ``_grp`` are removed. For example,\n``init_data_command`` becomes ``init-data``.\n\nAll keyword arguments are forwarded to the underlying command class.\nFor the ``params`` argument, any decorated params are appended to\nthe end of the list.\n\nOnce decorated the function turns into a :class:`Command` instance\nthat can be invoked as a command line utility or be attached to a\ncommand :class:`Group`.\n\n:param name: The name of the command. Defaults to modifying the function's\n    name as described above.\n:param cls: The command class to create. Defaults to :class:`Command`.\n\n.. versionchanged:: 8.2\n    The suffixes ``_command``, ``_cmd``, ``_group``, and ``_grp`` are\n    removed when generating the name.\n\n.. versionchanged:: 8.1\n    This decorator can be applied without parentheses.\n\n.. versionchanged:: 8.1\n    The ``params`` argument can be used. Decorated params are\n    appended to the end of the list.",
          "code": "def command(\n    name: str | _AnyCallable | None = None,\n    cls: type[CmdType] | None = None,\n    **attrs: t.Any,\n) -> Command | t.Callable[[_AnyCallable], Command | CmdType]:\n    r\"\"\"Creates a new :class:`Command` and uses the decorated function as\n    callback.  This will also automatically attach all decorated\n    :func:`option`\\s and :func:`argument`\\s as parameters to the command.\n\n    The name of the command defaults to the name of the function, converted to\n    lowercase, with underscores ``_`` replaced by dashes ``-``, and the suffixes\n    ``_command``, ``_cmd``, ``_group``, and ``_grp`` are removed. For example,\n    ``init_data_command`` becomes ``init-data``.\n\n    All keyword arguments are forwarded to the underlying command class.\n    For the ``params`` argument, any decorated params are appended to\n    the end of the list.\n\n    Once decorated the function turns into a :class:`Command` instance\n    that can be invoked as a command line utility or be attached to a\n    command :class:`Group`.\n\n    :param name: The name of the command. Defaults to modifying the function's\n        name as described above.\n    :param cls: The command class to create. Defaults to :class:`Command`.\n\n    .. versionchanged:: 8.2\n        The suffixes ``_command``, ``_cmd``, ``_group``, and ``_grp`` are\n        removed when generating the name.\n\n    .. versionchanged:: 8.1\n        This decorator can be applied without parentheses.\n\n    .. versionchanged:: 8.1\n        The ``params`` argument can be used. Decorated params are\n        appended to the end of the list.\n    \"\"\"\n\n    func: t.Callable[[_AnyCallable], t.Any] | None = None\n\n    if callable(name):\n        func = name\n        name = None\n        assert cls is None, \"Use 'command(cls=cls)(callable)' to specify a class.\"\n        assert not attrs, \"Use 'command(**kwargs)(callable)' to provide arguments.\"\n\n    if cls is None:\n        cls = t.cast(\"type[CmdType]\", Command)\n\n    def decorator(f: _AnyCallable) -> CmdType:\n        if isinstance(f, Command):\n            raise TypeError(\"Attempted to convert a callback into a command twice.\")\n\n        attr_params = attrs.pop(\"params\", None)\n        params = attr_params if attr_params is not None else []\n\n        try:\n            decorator_params = f.__click_params__  # type: ignore\n        except AttributeError:\n            pass\n        else:\n            del f.__click_params__  # type: ignore\n            params.extend(reversed(decorator_params))\n\n        if attrs.get(\"help\") is None:\n            attrs[\"help\"] = f.__doc__\n\n        if t.TYPE_CHECKING:\n            assert cls is not None\n            assert not callable(name)\n\n        if name is not None:\n            cmd_name = name\n        else:\n            cmd_name = f.__name__.lower().replace(\"_\", \"-\")\n            cmd_left, sep, suffix = cmd_name.rpartition(\"-\")\n\n            if sep and suffix in {\"command\", \"cmd\", \"group\", \"grp\"}:\n                cmd_name = cmd_left\n\n        cmd = cls(name=cmd_name, callback=f, params=params, **attrs)\n        cmd.__doc__ = f.__doc__\n        return cmd\n\n    if func is not None:\n        return decorator(func)\n\n    return decorator",
          "line_count": 88,
          "needs_llm_summary": true
        },
        {
          "name": "group",
          "args": [
            {
              "name": "name",
              "type": "_AnyCallable"
            }
          ],
          "return_type": "Group",
          "lineno": 263,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def group(name: _AnyCallable) -> Group: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "group",
          "args": [
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "cls",
              "type": "type[GrpType]"
            }
          ],
          "return_type": "t.Callable[Any, GrpType]",
          "lineno": 269,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def group(\n    name: str | None,\n    cls: type[GrpType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], GrpType]: ...",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "group",
          "args": [
            {
              "name": "name",
              "type": "None"
            }
          ],
          "return_type": "t.Callable[Any, GrpType]",
          "lineno": 278,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def group(\n    name: None = None,\n    *,\n    cls: type[GrpType],\n    **attrs: t.Any,\n) -> t.Callable[[_AnyCallable], GrpType]: ...",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "group",
          "args": [
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "cls",
              "type": "None"
            }
          ],
          "return_type": "t.Callable[Any, Group]",
          "lineno": 288,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def group(\n    name: str | None = ..., cls: None = None, **attrs: t.Any\n) -> t.Callable[[_AnyCallable], Group]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "group",
          "args": [
            {
              "name": "name",
              "type": "Any"
            },
            {
              "name": "cls",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 293,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cls",
            "name",
            "command",
            "t.cast",
            "attrs",
            "callable",
            "Group"
          ],
          "docstring": "Creates a new :class:`Group` with a function as callback.  This\nworks otherwise the same as :func:`command` just that the `cls`\nparameter is set to :class:`Group`.\n\n.. versionchanged:: 8.1\n    This decorator can be applied without parentheses.",
          "code": "def group(\n    name: str | _AnyCallable | None = None,\n    cls: type[GrpType] | None = None,\n    **attrs: t.Any,\n) -> Group | t.Callable[[_AnyCallable], Group | GrpType]:\n    \"\"\"Creates a new :class:`Group` with a function as callback.  This\n    works otherwise the same as :func:`command` just that the `cls`\n    parameter is set to :class:`Group`.\n\n    .. versionchanged:: 8.1\n        This decorator can be applied without parentheses.\n    \"\"\"\n    if cls is None:\n        cls = t.cast(\"type[GrpType]\", Group)\n\n    if callable(name):\n        return command(cls=cls, **attrs)(name)\n\n    return command(name, cls, **attrs)",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "_param_memo",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[Ellipsis, t.Any]"
            },
            {
              "name": "param",
              "type": "Parameter"
            }
          ],
          "return_type": "None",
          "lineno": 314,
          "decorators": [],
          "is_async": false,
          "calls": [
            "param",
            "hasattr",
            "f.__click_params__.append",
            "f",
            "isinstance",
            "f.params.append",
            "Command"
          ],
          "docstring": null,
          "code": "def _param_memo(f: t.Callable[..., t.Any], param: Parameter) -> None:\n    if isinstance(f, Command):\n        f.params.append(param)\n    else:\n        if not hasattr(f, \"__click_params__\"):\n            f.__click_params__ = []  # type: ignore\n\n        f.__click_params__.append(param)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "argument",
          "args": [],
          "return_type": "t.Callable[Any, FC]",
          "lineno": 324,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Argument",
            "cls",
            "f",
            "_param_memo",
            "attrs",
            "param_decls"
          ],
          "docstring": "Attaches an argument to the command.  All positional arguments are\npassed as parameter declarations to :class:`Argument`; all keyword\narguments are forwarded unchanged (except ``cls``).\nThis is equivalent to creating an :class:`Argument` instance manually\nand attaching it to the :attr:`Command.params` list.\n\nFor the default argument class, refer to :class:`Argument` and\n:class:`Parameter` for descriptions of parameters.\n\n:param cls: the argument class to instantiate.  This defaults to\n            :class:`Argument`.\n:param param_decls: Passed as positional arguments to the constructor of\n    ``cls``.\n:param attrs: Passed as keyword arguments to the constructor of ``cls``.",
          "code": "def argument(\n    *param_decls: str, cls: type[Argument] | None = None, **attrs: t.Any\n) -> t.Callable[[FC], FC]:\n    \"\"\"Attaches an argument to the command.  All positional arguments are\n    passed as parameter declarations to :class:`Argument`; all keyword\n    arguments are forwarded unchanged (except ``cls``).\n    This is equivalent to creating an :class:`Argument` instance manually\n    and attaching it to the :attr:`Command.params` list.\n\n    For the default argument class, refer to :class:`Argument` and\n    :class:`Parameter` for descriptions of parameters.\n\n    :param cls: the argument class to instantiate.  This defaults to\n                :class:`Argument`.\n    :param param_decls: Passed as positional arguments to the constructor of\n        ``cls``.\n    :param attrs: Passed as keyword arguments to the constructor of ``cls``.\n    \"\"\"\n    if cls is None:\n        cls = Argument\n\n    def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n        return f\n\n    return decorator",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "option",
          "args": [],
          "return_type": "t.Callable[Any, FC]",
          "lineno": 352,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cls",
            "f",
            "_param_memo",
            "attrs",
            "Option",
            "param_decls"
          ],
          "docstring": "Attaches an option to the command.  All positional arguments are\npassed as parameter declarations to :class:`Option`; all keyword\narguments are forwarded unchanged (except ``cls``).\nThis is equivalent to creating an :class:`Option` instance manually\nand attaching it to the :attr:`Command.params` list.\n\nFor the default option class, refer to :class:`Option` and\n:class:`Parameter` for descriptions of parameters.\n\n:param cls: the option class to instantiate.  This defaults to\n            :class:`Option`.\n:param param_decls: Passed as positional arguments to the constructor of\n    ``cls``.\n:param attrs: Passed as keyword arguments to the constructor of ``cls``.",
          "code": "def option(\n    *param_decls: str, cls: type[Option] | None = None, **attrs: t.Any\n) -> t.Callable[[FC], FC]:\n    \"\"\"Attaches an option to the command.  All positional arguments are\n    passed as parameter declarations to :class:`Option`; all keyword\n    arguments are forwarded unchanged (except ``cls``).\n    This is equivalent to creating an :class:`Option` instance manually\n    and attaching it to the :attr:`Command.params` list.\n\n    For the default option class, refer to :class:`Option` and\n    :class:`Parameter` for descriptions of parameters.\n\n    :param cls: the option class to instantiate.  This defaults to\n                :class:`Option`.\n    :param param_decls: Passed as positional arguments to the constructor of\n        ``cls``.\n    :param attrs: Passed as keyword arguments to the constructor of ``cls``.\n    \"\"\"\n    if cls is None:\n        cls = Option\n\n    def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n        return f\n\n    return decorator",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "confirmation_option",
          "args": [],
          "return_type": "t.Callable[Any, FC]",
          "lineno": 380,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs.setdefault",
            "callback",
            "option",
            "ctx.abort",
            "kwargs"
          ],
          "docstring": "Add a ``--yes`` option which shows a prompt before continuing if\nnot passed. If the prompt is declined, the program will exit.\n\n:param param_decls: One or more option names. Defaults to the single\n    value ``\"--yes\"``.\n:param kwargs: Extra arguments are passed to :func:`option`.",
          "code": "def confirmation_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:\n    \"\"\"Add a ``--yes`` option which shows a prompt before continuing if\n    not passed. If the prompt is declined, the program will exit.\n\n    :param param_decls: One or more option names. Defaults to the single\n        value ``\"--yes\"``.\n    :param kwargs: Extra arguments are passed to :func:`option`.\n    \"\"\"\n\n    def callback(ctx: Context, param: Parameter, value: bool) -> None:\n        if not value:\n            ctx.abort()\n\n    if not param_decls:\n        param_decls = (\"--yes\",)\n\n    kwargs.setdefault(\"is_flag\", True)\n    kwargs.setdefault(\"callback\", callback)\n    kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"prompt\", \"Do you want to continue?\")\n    kwargs.setdefault(\"help\", \"Confirm the action without prompting.\")\n    return option(*param_decls, **kwargs)",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "password_option",
          "args": [],
          "return_type": "t.Callable[Any, FC]",
          "lineno": 404,
          "decorators": [],
          "is_async": false,
          "calls": [
            "option",
            "kwargs.setdefault",
            "kwargs"
          ],
          "docstring": "Add a ``--password`` option which prompts for a password, hiding\ninput and asking to enter the value again for confirmation.\n\n:param param_decls: One or more option names. Defaults to the single\n    value ``\"--password\"``.\n:param kwargs: Extra arguments are passed to :func:`option`.",
          "code": "def password_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:\n    \"\"\"Add a ``--password`` option which prompts for a password, hiding\n    input and asking to enter the value again for confirmation.\n\n    :param param_decls: One or more option names. Defaults to the single\n        value ``\"--password\"``.\n    :param kwargs: Extra arguments are passed to :func:`option`.\n    \"\"\"\n    if not param_decls:\n        param_decls = (\"--password\",)\n\n    kwargs.setdefault(\"prompt\", True)\n    kwargs.setdefault(\"confirmation_prompt\", True)\n    kwargs.setdefault(\"hide_input\", True)\n    return option(*param_decls, **kwargs)",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "version_option",
          "args": [
            {
              "name": "version",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, FC]",
          "lineno": 421,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "importlib.metadata.version",
            "package_name.partition",
            "ctx.exit",
            "kwargs.setdefault",
            "ctx.find_root",
            "RuntimeError",
            "_",
            "callback",
            "option",
            "f_globals.get",
            "ctx.color",
            "kwargs",
            "inspect.currentframe",
            "unknown.info_name",
            "package_name"
          ],
          "docstring": "Add a ``--version`` option which immediately prints the version\nnumber and exits the program.\n\nIf ``version`` is not provided, Click will try to detect it using\n:func:`importlib.metadata.version` to get the version for the\n``package_name``.\n\nIf ``package_name`` is not provided, Click will try to detect it by\ninspecting the stack frames. This will be used to detect the\nversion, so it must match the name of the installed package.\n\n:param version: The version number to show. If not provided, Click\n    will try to detect it.\n:param param_decls: One or more option names. Defaults to the single\n    value ``\"--version\"``.\n:param package_name: The package name to detect the version from. If\n    not provided, Click will try to detect it.\n:param prog_name: The name of the CLI to show in the message. If not\n    provided, it will be detected from the command.\n:param message: The message to show. The values ``%(prog)s``,\n    ``%(package)s``, and ``%(version)s`` are available. Defaults to\n    ``\"%(prog)s, version %(version)s\"``.\n:param kwargs: Extra arguments are passed to :func:`option`.\n:raise RuntimeError: ``version`` could not be detected.\n\n.. versionchanged:: 8.0\n    Add the ``package_name`` parameter, and the ``%(package)s``\n    value for messages.\n\n.. versionchanged:: 8.0\n    Use :mod:`importlib.metadata` instead of ``pkg_resources``. The\n    version is detected based on the package name, not the entry\n    point name. The Python package name must match the installed\n    package name, or be passed with ``package_name=``.",
          "code": "def version_option(\n    version: str | None = None,\n    *param_decls: str,\n    package_name: str | None = None,\n    prog_name: str | None = None,\n    message: str | None = None,\n    **kwargs: t.Any,\n) -> t.Callable[[FC], FC]:\n    \"\"\"Add a ``--version`` option which immediately prints the version\n    number and exits the program.\n\n    If ``version`` is not provided, Click will try to detect it using\n    :func:`importlib.metadata.version` to get the version for the\n    ``package_name``.\n\n    If ``package_name`` is not provided, Click will try to detect it by\n    inspecting the stack frames. This will be used to detect the\n    version, so it must match the name of the installed package.\n\n    :param version: The version number to show. If not provided, Click\n        will try to detect it.\n    :param param_decls: One or more option names. Defaults to the single\n        value ``\"--version\"``.\n    :param package_name: The package name to detect the version from. If\n        not provided, Click will try to detect it.\n    :param prog_name: The name of the CLI to show in the message. If not\n        provided, it will be detected from the command.\n    :param message: The message to show. The values ``%(prog)s``,\n        ``%(package)s``, and ``%(version)s`` are available. Defaults to\n        ``\"%(prog)s, version %(version)s\"``.\n    :param kwargs: Extra arguments are passed to :func:`option`.\n    :raise RuntimeError: ``version`` could not be detected.\n\n    .. versionchanged:: 8.0\n        Add the ``package_name`` parameter, and the ``%(package)s``\n        value for messages.\n\n    .. versionchanged:: 8.0\n        Use :mod:`importlib.metadata` instead of ``pkg_resources``. The\n        version is detected based on the package name, not the entry\n        point name. The Python package name must match the installed\n        package name, or be passed with ``package_name=``.\n    \"\"\"\n    if message is None:\n        message = _(\"%(prog)s, version %(version)s\")\n\n    if version is None and package_name is None:\n        frame = inspect.currentframe()\n        f_back = frame.f_back if frame is not None else None\n        f_globals = f_back.f_globals if f_back is not None else None\n        # break reference cycle\n        # https://docs.python.org/3/library/inspect.html#the-interpreter-stack\n        del frame\n\n        if f_globals is not None:\n            package_name = f_globals.get(\"__name__\")\n\n            if package_name == \"__main__\":\n                package_name = f_globals.get(\"__package__\")\n\n            if package_name:\n                package_name = package_name.partition(\".\")[0]\n\n    def callback(ctx: Context, param: Parameter, value: bool) -> None:\n        if not value or ctx.resilient_parsing:\n            return\n\n        nonlocal prog_name\n        nonlocal version\n\n        if prog_name is None:\n            prog_name = ctx.find_root().info_name\n\n        if version is None and package_name is not None:\n            import importlib.metadata\n\n            try:\n                version = importlib.metadata.version(package_name)\n            except importlib.metadata.PackageNotFoundError:\n                raise RuntimeError(\n                    f\"{package_name!r} is not installed. Try passing\"\n                    \" 'package_name' instead.\"\n                ) from None\n\n        if version is None:\n            raise RuntimeError(\n                f\"Could not determine the version for {package_name!r} automatically.\"\n            )\n\n        echo(\n            message % {\"prog\": prog_name, \"package\": package_name, \"version\": version},\n            color=ctx.color,\n        )\n        ctx.exit()\n\n    if not param_decls:\n        param_decls = (\"--version\",)\n\n    kwargs.setdefault(\"is_flag\", True)\n    kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"is_eager\", True)\n    kwargs.setdefault(\"help\", _(\"Show the version and exit.\"))\n    kwargs[\"callback\"] = callback\n    return option(*param_decls, **kwargs)",
          "line_count": 104,
          "needs_llm_summary": true
        },
        {
          "name": "help_option",
          "args": [],
          "return_type": "t.Callable[Any, FC]",
          "lineno": 527,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "ctx.get_help",
            "ctx.exit",
            "kwargs.setdefault",
            "show_help",
            "_",
            "option",
            "kwargs",
            "ctx.color"
          ],
          "docstring": "Pre-configured ``--help`` option which immediately prints the help page\nand exits the program.\n\n:param param_decls: One or more option names. Defaults to the single\n    value ``\"--help\"``.\n:param kwargs: Extra arguments are passed to :func:`option`.",
          "code": "def help_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:\n    \"\"\"Pre-configured ``--help`` option which immediately prints the help page\n    and exits the program.\n\n    :param param_decls: One or more option names. Defaults to the single\n        value ``\"--help\"``.\n    :param kwargs: Extra arguments are passed to :func:`option`.\n    \"\"\"\n\n    def show_help(ctx: Context, param: Parameter, value: bool) -> None:\n        \"\"\"Callback that print the help page on ``<stdout>`` and exits.\"\"\"\n        if value and not ctx.resilient_parsing:\n            echo(ctx.get_help(), color=ctx.color)\n            ctx.exit()\n\n    if not param_decls:\n        param_decls = (\"--help\",)\n\n    kwargs.setdefault(\"is_flag\", True)\n    kwargs.setdefault(\"expose_value\", False)\n    kwargs.setdefault(\"is_eager\", True)\n    kwargs.setdefault(\"help\", _(\"Show this message and exit.\"))\n    kwargs.setdefault(\"callback\", show_help)\n\n    return option(*param_decls, **kwargs)",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "new_func",
          "args": [],
          "return_type": "R",
          "lineno": 33,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "kwargs",
            "get_current_context"
          ],
          "docstring": null,
          "code": "def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n        return f(get_current_context(), *args, **kwargs)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "new_func",
          "args": [],
          "return_type": "R",
          "lineno": 45,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.obj",
            "f",
            "kwargs",
            "get_current_context"
          ],
          "docstring": null,
          "code": "def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n        return f(get_current_context().obj, *args, **kwargs)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[te.Concatenate[T, P], R]"
            }
          ],
          "return_type": "t.Callable[P, R]",
          "lineno": 76,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.ensure_object",
            "f",
            "new_func",
            "get_current_context",
            "ctx.find_object",
            "RuntimeError",
            "update_wrapper",
            "kwargs",
            "obj",
            "ctx.invoke",
            "object_type"
          ],
          "docstring": null,
          "code": "def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n\n            obj: T | None\n            if ensure:\n                obj = ctx.ensure_object(object_type)\n            else:\n                obj = ctx.find_object(object_type)\n\n            if obj is None:\n                raise RuntimeError(\n                    \"Managed to invoke callback without a context\"\n                    f\" object of type {object_type.__name__!r}\"\n                    \" existing.\"\n                )\n\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[te.Concatenate[T, P], R]"
            }
          ],
          "return_type": "t.Callable[P, R]",
          "lineno": 115,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "new_func",
            "get_current_context",
            "update_wrapper",
            "kwargs",
            "obj",
            "ctx.invoke"
          ],
          "docstring": null,
          "code": "def decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:\n        def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n            obj = ctx.meta[key]\n            return ctx.invoke(f, obj, *args, **kwargs)\n\n        return update_wrapper(new_func, f)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "_AnyCallable"
            }
          ],
          "return_type": "CmdType",
          "lineno": 217,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cls",
            "params.extend",
            "f",
            "TypeError",
            "isinstance",
            "attrs",
            "params",
            "Command",
            "f.__click_params__",
            "attrs.pop",
            "name",
            "attrs.get",
            "unknown.replace",
            "f.__name__.lower",
            "cmd_name",
            "reversed",
            "cmd_left",
            "callable",
            "cmd_name.rpartition",
            "f.__doc__",
            "decorator_params"
          ],
          "docstring": null,
          "code": "def decorator(f: _AnyCallable) -> CmdType:\n        if isinstance(f, Command):\n            raise TypeError(\"Attempted to convert a callback into a command twice.\")\n\n        attr_params = attrs.pop(\"params\", None)\n        params = attr_params if attr_params is not None else []\n\n        try:\n            decorator_params = f.__click_params__  # type: ignore\n        except AttributeError:\n            pass\n        else:\n            del f.__click_params__  # type: ignore\n            params.extend(reversed(decorator_params))\n\n        if attrs.get(\"help\") is None:\n            attrs[\"help\"] = f.__doc__\n\n        if t.TYPE_CHECKING:\n            assert cls is not None\n            assert not callable(name)\n\n        if name is not None:\n            cmd_name = name\n        else:\n            cmd_name = f.__name__.lower().replace(\"_\", \"-\")\n            cmd_left, sep, suffix = cmd_name.rpartition(\"-\")\n\n            if sep and suffix in {\"command\", \"cmd\", \"group\", \"grp\"}:\n                cmd_name = cmd_left\n\n        cmd = cls(name=cmd_name, callback=f, params=params, **attrs)\n        cmd.__doc__ = f.__doc__\n        return cmd",
          "line_count": 34,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "FC"
            }
          ],
          "return_type": "FC",
          "lineno": 345,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cls",
            "f",
            "_param_memo",
            "attrs",
            "param_decls"
          ],
          "docstring": null,
          "code": "def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n        return f",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "FC"
            }
          ],
          "return_type": "FC",
          "lineno": 373,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cls",
            "f",
            "_param_memo",
            "attrs",
            "param_decls"
          ],
          "docstring": null,
          "code": "def decorator(f: FC) -> FC:\n        _param_memo(f, cls(param_decls, **attrs))\n        return f",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "callback",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "value",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 389,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.abort"
          ],
          "docstring": null,
          "code": "def callback(ctx: Context, param: Parameter, value: bool) -> None:\n        if not value:\n            ctx.abort()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "callback",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "value",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 484,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "importlib.metadata.version",
            "ctx.exit",
            "ctx.find_root",
            "RuntimeError",
            "ctx.color",
            "unknown.info_name",
            "package_name"
          ],
          "docstring": null,
          "code": "def callback(ctx: Context, param: Parameter, value: bool) -> None:\n        if not value or ctx.resilient_parsing:\n            return\n\n        nonlocal prog_name\n        nonlocal version\n\n        if prog_name is None:\n            prog_name = ctx.find_root().info_name\n\n        if version is None and package_name is not None:\n            import importlib.metadata\n\n            try:\n                version = importlib.metadata.version(package_name)\n            except importlib.metadata.PackageNotFoundError:\n                raise RuntimeError(\n                    f\"{package_name!r} is not installed. Try passing\"\n                    \" 'package_name' instead.\"\n                ) from None\n\n        if version is None:\n            raise RuntimeError(\n                f\"Could not determine the version for {package_name!r} automatically.\"\n            )\n\n        echo(\n            message % {\"prog\": prog_name, \"package\": package_name, \"version\": version},\n            color=ctx.color,\n        )\n        ctx.exit()",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "show_help",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "value",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 536,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.color",
            "echo",
            "ctx.get_help",
            "ctx.exit"
          ],
          "docstring": "Callback that print the help page on ``<stdout>`` and exits.",
          "code": "def show_help(ctx: Context, param: Parameter, value: bool) -> None:\n        \"\"\"Callback that print the help page on ``<stdout>`` and exits.\"\"\"\n        if value and not ctx.resilient_parsing:\n            echo(ctx.get_help(), color=ctx.color)\n            ctx.exit()",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "new_func",
          "args": [],
          "return_type": "R",
          "lineno": 77,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.ensure_object",
            "f",
            "RuntimeError",
            "get_current_context",
            "ctx.find_object",
            "kwargs",
            "obj",
            "ctx.invoke",
            "object_type"
          ],
          "docstring": null,
          "code": "def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n\n            obj: T | None\n            if ensure:\n                obj = ctx.ensure_object(object_type)\n            else:\n                obj = ctx.find_object(object_type)\n\n            if obj is None:\n                raise RuntimeError(\n                    \"Managed to invoke callback without a context\"\n                    f\" object of type {object_type.__name__!r}\"\n                    \" existing.\"\n                )\n\n            return ctx.invoke(f, obj, *args, **kwargs)",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "new_func",
          "args": [],
          "return_type": "R",
          "lineno": 116,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "get_current_context",
            "kwargs",
            "obj",
            "ctx.invoke"
          ],
          "docstring": null,
          "code": "def new_func(*args: P.args, **kwargs: P.kwargs) -> R:\n            ctx = get_current_context()\n            obj = ctx.meta[key]\n            return ctx.invoke(f, obj, *args, **kwargs)",
          "line_count": 4,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "inspect",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Argument",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Command",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Context",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Group",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Option",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Parameter",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "get_current_context",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "echo",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "typing_extensions",
          "alias": "te",
          "lineno": 18,
          "type": "import"
        },
        {
          "module": "importlib.metadata",
          "alias": null,
          "lineno": 495,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "R",
          "assigned_to": "t.TypeVar",
          "lineno": 22
        },
        {
          "name": "T",
          "assigned_to": "t.TypeVar",
          "lineno": 23
        },
        {
          "name": "_AnyCallable",
          "assigned_to": null,
          "lineno": 24
        },
        {
          "name": "FC",
          "assigned_to": "t.TypeVar",
          "lineno": 25
        },
        {
          "name": "CmdType",
          "assigned_to": "t.TypeVar",
          "lineno": 133
        },
        {
          "name": "GrpType",
          "assigned_to": "t.TypeVar",
          "lineno": 258
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar",
          "Command",
          "Group",
          "te.ParamSpec"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "functools",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "inspect",
            "gettext",
            "core",
            "globals",
            "utils",
            "typing_extensions",
            "importlib"
          ]
        },
        "tech_stack": []
      },
      "line_count": 552
    },
    "src/click/exceptions.py": {
      "filepath": "../click/src/click/exceptions.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_join_param_hints",
          "args": [
            {
              "name": "param_hint",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 19,
          "decorators": [],
          "is_async": false,
          "calls": [
            "repr",
            "unknown.join",
            "str",
            "isinstance",
            "param_hint",
            "x"
          ],
          "docstring": null,
          "code": "def _join_param_hints(param_hint: cabc.Sequence[str] | str | None) -> str | None:\n    if param_hint is not None and not isinstance(param_hint, str):\n        return \" / \".join(repr(x) for x in param_hint)\n\n    return param_hint",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "message",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 32,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "super",
            "resolve_color_default",
            "message"
          ],
          "docstring": null,
          "code": "def __init__(self, message: str) -> None:\n        super().__init__(message)\n        # The context will be removed by the time we print the message, so cache\n        # the color settings here to be used later on (in `show`)\n        self.show_color: bool | None = resolve_color_default()\n        self.message = message",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "format_message",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 39,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def format_message(self) -> str:\n        return self.message",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__str__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 42,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __str__(self) -> str:\n        return self.message",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "show",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "file",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 45,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "self.show_color",
            "get_text_stderr",
            "file",
            "_",
            "self.format_message",
            "unknown.format"
          ],
          "docstring": null,
          "code": "def show(self, file: t.IO[t.Any] | None = None) -> None:\n        if file is None:\n            file = get_text_stderr()\n\n        echo(\n            _(\"Error: {message}\").format(message=self.format_message()),\n            file=file,\n            color=self.show_color,\n        )",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 67,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "unknown.__init__",
            "super",
            "message"
          ],
          "docstring": null,
          "code": "def __init__(self, message: str, ctx: Context | None = None) -> None:\n        super().__init__(message)\n        self.ctx = ctx\n        self.cmd: Command | None = self.ctx.command if self.ctx else None",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "show",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "file",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 72,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.ctx.color",
            "echo",
            "self.ctx.command_path",
            "get_text_stderr",
            "file",
            "self.ctx.command.get_help_option",
            "_",
            "self.ctx",
            "self.format_message",
            "color",
            "self.ctx.get_usage",
            "unknown.format"
          ],
          "docstring": null,
          "code": "def show(self, file: t.IO[t.Any] | None = None) -> None:\n        if file is None:\n            file = get_text_stderr()\n        color = None\n        hint = \"\"\n        if (\n            self.ctx is not None\n            and self.ctx.command.get_help_option(self.ctx) is not None\n        ):\n            hint = _(\"Try '{command} {option}' for help.\").format(\n                command=self.ctx.command_path, option=self.ctx.help_option_names[0]\n            )\n            hint = f\"{hint}\\n\"\n        if self.ctx is not None:\n            color = self.ctx.color\n            echo(f\"{self.ctx.get_usage()}\\n{hint}\", file=file, color=color)\n        echo(\n            _(\"Error: {message}\").format(message=self.format_message()),\n            file=file,\n            color=color,\n        )",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "ctx",
              "type": "Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "param_hint",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 113,
          "decorators": [],
          "is_async": false,
          "calls": [
            "message",
            "param",
            "unknown.__init__",
            "ctx",
            "super",
            "param_hint"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        message: str,\n        ctx: Context | None = None,\n        param: Parameter | None = None,\n        param_hint: cabc.Sequence[str] | str | None = None,\n    ) -> None:\n        super().__init__(message, ctx)\n        self.param = param\n        self.param_hint = param_hint",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "format_message",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 124,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.param.get_error_hint",
            "_",
            "self.param_hint",
            "self.ctx",
            "self.message",
            "param_hint",
            "unknown.format",
            "_join_param_hints"
          ],
          "docstring": null,
          "code": "def format_message(self) -> str:\n        if self.param_hint is not None:\n            param_hint = self.param_hint\n        elif self.param is not None:\n            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore\n        else:\n            return _(\"Invalid value: {message}\").format(message=self.message)\n\n        return _(\"Invalid value for {param_hint}: {message}\").format(\n            param_hint=_join_param_hints(param_hint), message=self.message\n        )",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "message",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "param_hint",
              "type": "Any"
            },
            {
              "name": "param_type",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 149,
          "decorators": [],
          "is_async": false,
          "calls": [
            "param",
            "unknown.__init__",
            "ctx",
            "param_type",
            "super",
            "param_hint"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        message: str | None = None,\n        ctx: Context | None = None,\n        param: Parameter | None = None,\n        param_hint: cabc.Sequence[str] | str | None = None,\n        param_type: str | None = None,\n    ) -> None:\n        super().__init__(message or \"\", ctx, param, param_hint)\n        self.param_type = param_type",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "format_message",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 160,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.param.get_error_hint",
            "self.param.param_type_name",
            "_",
            "self.param.type.get_missing_message",
            "self.param_type",
            "self.ctx",
            "param_type",
            "self.message",
            "self.param",
            "param_hint",
            "unknown.format",
            "_join_param_hints",
            "msg_extra"
          ],
          "docstring": null,
          "code": "def format_message(self) -> str:\n        if self.param_hint is not None:\n            param_hint: cabc.Sequence[str] | str | None = self.param_hint\n        elif self.param is not None:\n            param_hint = self.param.get_error_hint(self.ctx)  # type: ignore\n        else:\n            param_hint = None\n\n        param_hint = _join_param_hints(param_hint)\n        param_hint = f\" {param_hint}\" if param_hint else \"\"\n\n        param_type = self.param_type\n        if param_type is None and self.param is not None:\n            param_type = self.param.param_type_name\n\n        msg = self.message\n        if self.param is not None:\n            msg_extra = self.param.type.get_missing_message(\n                param=self.param, ctx=self.ctx\n            )\n            if msg_extra:\n                if msg:\n                    msg += f\". {msg_extra}\"\n                else:\n                    msg = msg_extra\n\n        msg = f\" {msg}\" if msg else \"\"\n\n        # Translate param_type for known types.\n        if param_type == \"argument\":\n            missing = _(\"Missing argument\")\n        elif param_type == \"option\":\n            missing = _(\"Missing option\")\n        elif param_type == \"parameter\":\n            missing = _(\"Missing parameter\")\n        else:\n            missing = _(\"Missing {param_type}\").format(param_type=param_type)\n\n        return f\"{missing}{param_hint}.{msg}\"",
          "line_count": 39,
          "needs_llm_summary": true
        },
        {
          "name": "__str__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 200,
          "decorators": [],
          "is_async": false,
          "calls": [
            "param_name",
            "unknown.format",
            "_"
          ],
          "docstring": null,
          "code": "def __str__(self) -> str:\n        if not self.message:\n            param_name = self.param.name if self.param else None\n            return _(\"Missing parameter: {param_name}\").format(param_name=param_name)\n        else:\n            return self.message",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "option_name",
              "type": "str"
            },
            {
              "name": "message",
              "type": "Any"
            },
            {
              "name": "possibilities",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 215,
          "decorators": [],
          "is_async": false,
          "calls": [
            "message",
            "unknown.__init__",
            "ctx",
            "_",
            "possibilities",
            "option_name",
            "super",
            "unknown.format"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        option_name: str,\n        message: str | None = None,\n        possibilities: cabc.Sequence[str] | None = None,\n        ctx: Context | None = None,\n    ) -> None:\n        if message is None:\n            message = _(\"No such option: {name}\").format(name=option_name)\n\n        super().__init__(message, ctx)\n        self.option_name = option_name\n        self.possibilities = possibilities",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "format_message",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 229,
          "decorators": [],
          "is_async": false,
          "calls": [
            "possibility_str",
            "unknown.join",
            "len",
            "sorted",
            "ngettext",
            "self.possibilities",
            "unknown.format"
          ],
          "docstring": null,
          "code": "def format_message(self) -> str:\n        if not self.possibilities:\n            return self.message\n\n        possibility_str = \", \".join(sorted(self.possibilities))\n        suggest = ngettext(\n            \"Did you mean {possibility}?\",\n            \"(Possible options: {possibilities})\",\n            len(self.possibilities),\n        ).format(possibility=possibility_str, possibilities=possibility_str)\n        return f\"{self.message} {suggest}\"",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "option_name",
              "type": "str"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 252,
          "decorators": [],
          "is_async": false,
          "calls": [
            "message",
            "unknown.__init__",
            "ctx",
            "option_name",
            "super"
          ],
          "docstring": null,
          "code": "def __init__(\n        self, option_name: str, message: str, ctx: Context | None = None\n    ) -> None:\n        super().__init__(message, ctx)\n        self.option_name = option_name",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "None",
          "lineno": 269,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "ctx.get_help",
            "ctx",
            "super"
          ],
          "docstring": null,
          "code": "def __init__(self, ctx: Context) -> None:\n        self.ctx: Context\n        super().__init__(ctx.get_help(), ctx=ctx)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "show",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "file",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 273,
          "decorators": [],
          "is_async": false,
          "calls": [
            "file",
            "echo",
            "self.ctx.color",
            "self.format_message"
          ],
          "docstring": null,
          "code": "def show(self, file: t.IO[t.Any] | None = None) -> None:\n        echo(self.format_message(), file=file, err=True, color=self.ctx.color)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "str"
            },
            {
              "name": "hint",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 280,
          "decorators": [],
          "is_async": false,
          "calls": [
            "filename",
            "hint",
            "unknown.__init__",
            "_",
            "super",
            "format_filename"
          ],
          "docstring": null,
          "code": "def __init__(self, filename: str, hint: str | None = None) -> None:\n        if hint is None:\n            hint = _(\"unknown error\")\n\n        super().__init__(hint)\n        self.ui_filename: str = format_filename(filename)\n        self.filename = filename",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "format_message",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 288,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.message",
            "self.ui_filename",
            "unknown.format",
            "_"
          ],
          "docstring": null,
          "code": "def format_message(self) -> str:\n        return _(\"Could not open file {filename!r}: {message}\").format(\n            filename=self.ui_filename, message=self.message\n        )",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "code",
              "type": "int"
            }
          ],
          "return_type": "None",
          "lineno": 307,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __init__(self, code: int = 0) -> None:\n        self.exit_code: int = code",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "ClickException",
          "methods": [
            "__init__",
            "format_message",
            "__str__",
            "show"
          ],
          "base_classes": [
            "Exception"
          ],
          "lineno": 26,
          "docstring": "An exception that Click can handle and show to the user."
        },
        {
          "name": "UsageError",
          "methods": [
            "__init__",
            "show"
          ],
          "base_classes": [
            "ClickException"
          ],
          "lineno": 56,
          "docstring": "An internal exception that signals a usage error.  This typically\naborts any further handling.\n\n:param message: the error message to display.\n:param ctx: optionally the context that caused this error.  Click will\n            fill in the context automatically in some situations."
        },
        {
          "name": "BadParameter",
          "methods": [
            "__init__",
            "format_message"
          ],
          "base_classes": [
            "UsageError"
          ],
          "lineno": 95,
          "docstring": "An exception that formats out a standardized error message for a\nbad parameter.  This is useful when thrown from a callback or type as\nClick will attach contextual information to it (for instance, which\nparameter it is).\n\n.. versionadded:: 2.0\n\n:param param: the parameter object that caused this error.  This can\n              be left out, and Click will attach this info itself\n              if possible.\n:param param_hint: a string that shows up as parameter name.  This\n                   can be used as alternative to `param` in cases\n                   where custom validation should happen.  If it is\n                   a string it's used as such, if it's a list then\n                   each item is quoted and separated."
        },
        {
          "name": "MissingParameter",
          "methods": [
            "__init__",
            "format_message",
            "__str__"
          ],
          "base_classes": [
            "BadParameter"
          ],
          "lineno": 137,
          "docstring": "Raised if click required an option or argument but it was not\nprovided when invoking the script.\n\n.. versionadded:: 4.0\n\n:param param_type: a string that indicates the type of the parameter.\n                   The default is to inherit the parameter type from\n                   the given `param`.  Valid values are ``'parameter'``,\n                   ``'option'`` or ``'argument'``."
        },
        {
          "name": "NoSuchOption",
          "methods": [
            "__init__",
            "format_message"
          ],
          "base_classes": [
            "UsageError"
          ],
          "lineno": 208,
          "docstring": "Raised if click attempted to handle an option that does not\nexist.\n\n.. versionadded:: 4.0"
        },
        {
          "name": "BadOptionUsage",
          "methods": [
            "__init__"
          ],
          "base_classes": [
            "UsageError"
          ],
          "lineno": 242,
          "docstring": "Raised if an option is generally supplied but the use of the option\nwas incorrect.  This is for instance raised if the number of arguments\nfor an option is not correct.\n\n.. versionadded:: 4.0\n\n:param option_name: the name of the option being used incorrectly."
        },
        {
          "name": "BadArgumentUsage",
          "methods": [],
          "base_classes": [
            "UsageError"
          ],
          "lineno": 259,
          "docstring": "Raised if an argument is generally supplied but the use of the argument\nwas incorrect.  This is for instance raised if the number of values\nfor an argument is not correct.\n\n.. versionadded:: 6.0"
        },
        {
          "name": "NoArgsIsHelpError",
          "methods": [
            "__init__",
            "show"
          ],
          "base_classes": [
            "UsageError"
          ],
          "lineno": 268,
          "docstring": null
        },
        {
          "name": "FileError",
          "methods": [
            "__init__",
            "format_message"
          ],
          "base_classes": [
            "ClickException"
          ],
          "lineno": 277,
          "docstring": "Raised if a file cannot be opened."
        },
        {
          "name": "Abort",
          "methods": [],
          "base_classes": [
            "RuntimeError"
          ],
          "lineno": 294,
          "docstring": "An internal signalling exception that signals Click to abort."
        },
        {
          "name": "Exit",
          "methods": [
            "__init__"
          ],
          "base_classes": [
            "RuntimeError"
          ],
          "lineno": 298,
          "docstring": "An exception that indicates that the application should exit with some\nstatus code.\n\n:param code: the status code to exit with."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "ngettext",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "get_text_stderr",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "resolve_color_default",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "echo",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "format_filename",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Command",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Context",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Parameter",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "collections",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "gettext",
            "_compat",
            "globals",
            "utils",
            "core"
          ]
        },
        "tech_stack": []
      },
      "line_count": 309
    },
    "src/click/formatting.py": {
      "filepath": "../click/src/click/formatting.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "measure_table",
          "args": [
            {
              "name": "rows",
              "type": "cabc.Iterable[tuple[str, str]]"
            }
          ],
          "return_type": "tuple[int, Ellipsis]",
          "lineno": 14,
          "decorators": [],
          "is_async": false,
          "calls": [
            "enumerate",
            "tuple",
            "term_len",
            "max",
            "row",
            "col",
            "widths.get",
            "idx",
            "widths.items",
            "sorted"
          ],
          "docstring": null,
          "code": "def measure_table(rows: cabc.Iterable[tuple[str, str]]) -> tuple[int, ...]:\n    widths: dict[int, int] = {}\n\n    for row in rows:\n        for idx, col in enumerate(row):\n            widths[idx] = max(widths.get(idx, 0), term_len(col))\n\n    return tuple(y for x, y in sorted(widths.items()))",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "iter_rows",
          "args": [
            {
              "name": "rows",
              "type": "cabc.Iterable[tuple[str, str]]"
            },
            {
              "name": "col_count",
              "type": "int"
            }
          ],
          "return_type": "cabc.Iterator[tuple[str, Ellipsis]]",
          "lineno": 24,
          "decorators": [],
          "is_async": false,
          "calls": [
            "len",
            "row"
          ],
          "docstring": null,
          "code": "def iter_rows(\n    rows: cabc.Iterable[tuple[str, str]], col_count: int\n) -> cabc.Iterator[tuple[str, ...]]:\n    for row in rows:\n        yield row + (\"\",) * (col_count - len(row))",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "wrap_text",
          "args": [
            {
              "name": "text",
              "type": "str"
            },
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "initial_indent",
              "type": "str"
            },
            {
              "name": "subsequent_indent",
              "type": "str"
            },
            {
              "name": "preserve_paragraphs",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "lineno": 31,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "initial_indent",
            "text.splitlines",
            "rv.append",
            "TextWrapper",
            "wrapper.indent_only",
            "term_len",
            "rv",
            "wrapper.fill",
            "width",
            "text.expandtabs",
            "subsequent_indent",
            "unknown.strip",
            "line.lstrip",
            "line",
            "buf",
            "unknown.join",
            "buf.append",
            "p.append",
            "_flush_par",
            "wrapper.extra_indent"
          ],
          "docstring": "A helper function that intelligently wraps text.  By default, it\nassumes that it operates on a single paragraph of text but if the\n`preserve_paragraphs` parameter is provided it will intelligently\nhandle paragraphs (defined by two empty lines).\n\nIf paragraphs are handled, a paragraph can be prefixed with an empty\nline containing the ``\\b`` character (``\\x08``) to indicate that\nno rewrapping should happen in that block.\n\n:param text: the text that should be rewrapped.\n:param width: the maximum width for the text.\n:param initial_indent: the initial indent that should be placed on the\n                       first line as a string.\n:param subsequent_indent: the indent string that should be placed on\n                          each consecutive line.\n:param preserve_paragraphs: if this flag is set then the wrapping will\n                            intelligently handle paragraphs.",
          "code": "def wrap_text(\n    text: str,\n    width: int = 78,\n    initial_indent: str = \"\",\n    subsequent_indent: str = \"\",\n    preserve_paragraphs: bool = False,\n) -> str:\n    \"\"\"A helper function that intelligently wraps text.  By default, it\n    assumes that it operates on a single paragraph of text but if the\n    `preserve_paragraphs` parameter is provided it will intelligently\n    handle paragraphs (defined by two empty lines).\n\n    If paragraphs are handled, a paragraph can be prefixed with an empty\n    line containing the ``\\\\b`` character (``\\\\x08``) to indicate that\n    no rewrapping should happen in that block.\n\n    :param text: the text that should be rewrapped.\n    :param width: the maximum width for the text.\n    :param initial_indent: the initial indent that should be placed on the\n                           first line as a string.\n    :param subsequent_indent: the indent string that should be placed on\n                              each consecutive line.\n    :param preserve_paragraphs: if this flag is set then the wrapping will\n                                intelligently handle paragraphs.\n    \"\"\"\n    from ._textwrap import TextWrapper\n\n    text = text.expandtabs()\n    wrapper = TextWrapper(\n        width,\n        initial_indent=initial_indent,\n        subsequent_indent=subsequent_indent,\n        replace_whitespace=False,\n    )\n    if not preserve_paragraphs:\n        return wrapper.fill(text)\n\n    p: list[tuple[int, bool, str]] = []\n    buf: list[str] = []\n    indent = None\n\n    def _flush_par() -> None:\n        if not buf:\n            return\n        if buf[0].strip() == \"\\b\":\n            p.append((indent or 0, True, \"\\n\".join(buf[1:])))\n        else:\n            p.append((indent or 0, False, \" \".join(buf)))\n        del buf[:]\n\n    for line in text.splitlines():\n        if not line:\n            _flush_par()\n            indent = None\n        else:\n            if indent is None:\n                orig_len = term_len(line)\n                line = line.lstrip()\n                indent = orig_len - term_len(line)\n            buf.append(line)\n    _flush_par()\n\n    rv = []\n    for indent, raw, text in p:\n        with wrapper.extra_indent(\" \" * indent):\n            if raw:\n                rv.append(wrapper.indent_only(text))\n            else:\n                rv.append(wrapper.fill(text))\n\n    return \"\\n\\n\".join(rv)",
          "line_count": 71,
          "needs_llm_summary": true
        },
        {
          "name": "join_options",
          "args": [
            {
              "name": "options",
              "type": "cabc.Sequence[str]"
            }
          ],
          "return_type": "tuple[str, bool]",
          "lineno": 283,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.join",
            "len",
            "opt",
            "rv.append",
            "prefix",
            "rv.sort",
            "_split_opt"
          ],
          "docstring": "Given a list of option strings this joins them in the most appropriate\nway and returns them in the form ``(formatted_string,\nany_prefix_is_slash)`` where the second item in the tuple is a flag that\nindicates if any of the option prefixes was a slash.",
          "code": "def join_options(options: cabc.Sequence[str]) -> tuple[str, bool]:\n    \"\"\"Given a list of option strings this joins them in the most appropriate\n    way and returns them in the form ``(formatted_string,\n    any_prefix_is_slash)`` where the second item in the tuple is a flag that\n    indicates if any of the option prefixes was a slash.\n    \"\"\"\n    rv = []\n    any_prefix_is_slash = False\n\n    for opt in options:\n        prefix = _split_opt(opt)[0]\n\n        if prefix == \"/\":\n            any_prefix_is_slash = True\n\n        rv.append((len(prefix), opt))\n\n    rv.sort(key=lambda x: x[0])\n    return \", \".join(x[1] for x in rv), any_prefix_is_slash",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "_flush_par",
          "args": [],
          "return_type": "None",
          "lineno": 72,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.strip",
            "unknown.join",
            "buf",
            "p.append"
          ],
          "docstring": null,
          "code": "def _flush_par() -> None:\n        if not buf:\n            return\n        if buf[0].strip() == \"\\b\":\n            p.append((indent or 0, True, \"\\n\".join(buf[1:])))\n        else:\n            p.append((indent or 0, False, \" \".join(buf)))\n        del buf[:]",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "indent_increment",
              "type": "int"
            },
            {
              "name": "width",
              "type": "Any"
            },
            {
              "name": "max_width",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 116,
          "decorators": [],
          "is_async": false,
          "calls": [
            "shutil.get_terminal_size",
            "unknown.columns",
            "max_width",
            "FORCED_WIDTH",
            "max",
            "indent_increment",
            "min",
            "width"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        indent_increment: int = 2,\n        width: int | None = None,\n        max_width: int | None = None,\n    ) -> None:\n        self.indent_increment = indent_increment\n        if max_width is None:\n            max_width = 80\n        if width is None:\n            import shutil\n\n            width = FORCED_WIDTH\n            if width is None:\n                width = max(min(shutil.get_terminal_size().columns, max_width) - 2, 50)\n        self.width = width\n        self.current_indent: int = 0\n        self.buffer: list[str] = []",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "write",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "string",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 135,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.buffer.append",
            "string"
          ],
          "docstring": "Writes a unicode string into the internal buffer.",
          "code": "def write(self, string: str) -> None:\n        \"\"\"Writes a unicode string into the internal buffer.\"\"\"\n        self.buffer.append(string)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "indent",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 139,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Increases the indentation.",
          "code": "def indent(self) -> None:\n        \"\"\"Increases the indentation.\"\"\"\n        self.current_indent += self.indent_increment",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "dedent",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 143,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Decreases the indentation.",
          "code": "def dedent(self) -> None:\n        \"\"\"Decreases the indentation.\"\"\"\n        self.current_indent -= self.indent_increment",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "write_usage",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "prog",
              "type": "str"
            },
            {
              "name": "args",
              "type": "str"
            },
            {
              "name": "prefix",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 147,
          "decorators": [],
          "is_async": false,
          "calls": [
            "wrap_text",
            "term_len",
            "usage_prefix",
            "self.current_indent",
            "max",
            "_",
            "self.write",
            "text_width",
            "args",
            "indent",
            "prefix"
          ],
          "docstring": "Writes a usage line into the buffer.\n\n:param prog: the program name.\n:param args: whitespace separated list of arguments.\n:param prefix: The prefix for the first line. Defaults to\n    ``\"Usage: \"``.",
          "code": "def write_usage(self, prog: str, args: str = \"\", prefix: str | None = None) -> None:\n        \"\"\"Writes a usage line into the buffer.\n\n        :param prog: the program name.\n        :param args: whitespace separated list of arguments.\n        :param prefix: The prefix for the first line. Defaults to\n            ``\"Usage: \"``.\n        \"\"\"\n        if prefix is None:\n            prefix = f\"{_('Usage:')} \"\n\n        usage_prefix = f\"{prefix:>{self.current_indent}}{prog} \"\n        text_width = self.width - self.current_indent\n\n        if text_width >= (term_len(usage_prefix) + 20):\n            # The arguments will fit to the right of the prefix.\n            indent = \" \" * term_len(usage_prefix)\n            self.write(\n                wrap_text(\n                    args,\n                    text_width,\n                    initial_indent=usage_prefix,\n                    subsequent_indent=indent,\n                )\n            )\n        else:\n            # The prefix is too long, put the arguments on the next line.\n            self.write(usage_prefix)\n            self.write(\"\\n\")\n            indent = \" \" * (max(self.current_indent, term_len(prefix)) + 4)\n            self.write(\n                wrap_text(\n                    args, text_width, initial_indent=indent, subsequent_indent=indent\n                )\n            )\n\n        self.write(\"\\n\")",
          "line_count": 37,
          "needs_llm_summary": true
        },
        {
          "name": "write_heading",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "heading",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 185,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.write"
          ],
          "docstring": "Writes a heading into the buffer.",
          "code": "def write_heading(self, heading: str) -> None:\n        \"\"\"Writes a heading into the buffer.\"\"\"\n        self.write(f\"{'':>{self.current_indent}}{heading}:\\n\")",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "write_paragraph",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 189,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.write"
          ],
          "docstring": "Writes a paragraph into the buffer.",
          "code": "def write_paragraph(self) -> None:\n        \"\"\"Writes a paragraph into the buffer.\"\"\"\n        if self.buffer:\n            self.write(\"\\n\")",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "write_text",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "text",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 194,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "wrap_text",
            "self.write",
            "self.width",
            "indent"
          ],
          "docstring": "Writes re-indented text into the buffer.  This rewraps and\npreserves paragraphs.",
          "code": "def write_text(self, text: str) -> None:\n        \"\"\"Writes re-indented text into the buffer.  This rewraps and\n        preserves paragraphs.\n        \"\"\"\n        indent = \" \" * self.current_indent\n        self.write(\n            wrap_text(\n                text,\n                self.width,\n                initial_indent=indent,\n                subsequent_indent=indent,\n                preserve_paragraphs=True,\n            )\n        )\n        self.write(\"\\n\")",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "write_dl",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rows",
              "type": "cabc.Sequence[tuple[str, str]]"
            },
            {
              "name": "col_max",
              "type": "int"
            },
            {
              "name": "col_spacing",
              "type": "int"
            }
          ],
          "return_type": "None",
          "lineno": 210,
          "decorators": [],
          "is_async": false,
          "calls": [
            "iter_rows",
            "wrap_text",
            "col_max",
            "term_len",
            "widths",
            "max",
            "len",
            "second",
            "list",
            "measure_table",
            "wrapped_text.splitlines",
            "TypeError",
            "min",
            "self.write",
            "text_width",
            "rows",
            "first"
          ],
          "docstring": "Writes a definition list into the buffer.  This is how options\nand commands are usually formatted.\n\n:param rows: a list of two item tuples for the terms and values.\n:param col_max: the maximum width of the first column.\n:param col_spacing: the number of spaces between the first and\n                    second column.",
          "code": "def write_dl(\n        self,\n        rows: cabc.Sequence[tuple[str, str]],\n        col_max: int = 30,\n        col_spacing: int = 2,\n    ) -> None:\n        \"\"\"Writes a definition list into the buffer.  This is how options\n        and commands are usually formatted.\n\n        :param rows: a list of two item tuples for the terms and values.\n        :param col_max: the maximum width of the first column.\n        :param col_spacing: the number of spaces between the first and\n                            second column.\n        \"\"\"\n        rows = list(rows)\n        widths = measure_table(rows)\n        if len(widths) != 2:\n            raise TypeError(\"Expected two columns for definition list\")\n\n        first_col = min(widths[0], col_max) + col_spacing\n\n        for first, second in iter_rows(rows, len(widths)):\n            self.write(f\"{'':>{self.current_indent}}{first}\")\n            if not second:\n                self.write(\"\\n\")\n                continue\n            if term_len(first) <= first_col - col_spacing:\n                self.write(\" \" * (first_col - term_len(first)))\n            else:\n                self.write(\"\\n\")\n                self.write(\" \" * (first_col + self.current_indent))\n\n            text_width = max(self.width - first_col - 2, 10)\n            wrapped_text = wrap_text(second, text_width, preserve_paragraphs=True)\n            lines = wrapped_text.splitlines()\n\n            if lines:\n                self.write(f\"{lines[0]}\\n\")\n\n                for line in lines[1:]:\n                    self.write(f\"{'':>{first_col + self.current_indent}}{line}\\n\")\n            else:\n                self.write(\"\\n\")",
          "line_count": 43,
          "needs_llm_summary": true
        },
        {
          "name": "section",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "cabc.Iterator[None]",
          "lineno": 255,
          "decorators": [
            {
              "name": "contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.write_paragraph",
            "name",
            "self.write_heading",
            "self.dedent",
            "self.indent"
          ],
          "docstring": "Helpful context manager that writes a paragraph, a heading,\nand the indents.\n\n:param name: the section name that is written as heading.",
          "code": "def section(self, name: str) -> cabc.Iterator[None]:\n        \"\"\"Helpful context manager that writes a paragraph, a heading,\n        and the indents.\n\n        :param name: the section name that is written as heading.\n        \"\"\"\n        self.write_paragraph()\n        self.write_heading(name)\n        self.indent()\n        try:\n            yield\n        finally:\n            self.dedent()",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "indentation",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "cabc.Iterator[None]",
          "lineno": 270,
          "decorators": [
            {
              "name": "contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.dedent",
            "self.indent"
          ],
          "docstring": "A context manager that increases the indentation.",
          "code": "def indentation(self) -> cabc.Iterator[None]:\n        \"\"\"A context manager that increases the indentation.\"\"\"\n        self.indent()\n        try:\n            yield\n        finally:\n            self.dedent()",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "getvalue",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 278,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.join",
            "self.buffer"
          ],
          "docstring": "Returns the buffer contents.",
          "code": "def getvalue(self) -> str:\n        \"\"\"Returns the buffer contents.\"\"\"\n        return \"\".join(self.buffer)",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "HelpFormatter",
          "methods": [
            "__init__",
            "write",
            "indent",
            "dedent",
            "write_usage",
            "write_heading",
            "write_paragraph",
            "write_text",
            "write_dl",
            "section",
            "indentation",
            "getvalue"
          ],
          "base_classes": [],
          "lineno": 104,
          "docstring": "This class helps with formatting text-based help pages.  It's\nusually just needed for very special internal cases, but it's also\nexposed so that developers can write their own fancy outputs.\n\nAt present, it always writes into memory.\n\n:param indent_increment: the additional increment for each level.\n:param width: the width for the text.  This defaults to the terminal\n              width clamped to a maximum of 78."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "contextlib",
          "name": "contextmanager",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "term_len",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "parser",
          "name": "_split_opt",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "_textwrap",
          "name": "TextWrapper",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "shutil",
          "alias": null,
          "lineno": 126,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "collections",
          "contextlib",
          "shutil"
        ],
        "third_party": {
          "other": [
            "__future__",
            "gettext",
            "_compat",
            "parser",
            "_textwrap"
          ]
        },
        "tech_stack": []
      },
      "line_count": 302
    },
    "src/click/globals.py": {
      "filepath": "../click/src/click/globals.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "get_current_context",
          "args": [
            {
              "name": "silent",
              "type": "t.Literal[False]"
            }
          ],
          "return_type": "Context",
          "lineno": 13,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_current_context(silent: t.Literal[False] = False) -> Context: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "get_current_context",
          "args": [
            {
              "name": "silent",
              "type": "bool"
            }
          ],
          "return_type": "Any",
          "lineno": 17,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_current_context(silent: bool = ...) -> Context | None: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "get_current_context",
          "args": [
            {
              "name": "silent",
              "type": "bool"
            }
          ],
          "return_type": "Any",
          "lineno": 20,
          "decorators": [],
          "is_async": false,
          "calls": [
            "RuntimeError",
            "t.cast"
          ],
          "docstring": "Returns the current click context.  This can be used as a way to\naccess the current context object from anywhere.  This is a more implicit\nalternative to the :func:`pass_context` decorator.  This function is\nprimarily useful for helpers such as :func:`echo` which might be\ninterested in changing its behavior based on the current context.\n\nTo push the current context, :meth:`Context.scope` can be used.\n\n.. versionadded:: 5.0\n\n:param silent: if set to `True` the return value is `None` if no context\n               is available.  The default behavior is to raise a\n               :exc:`RuntimeError`.",
          "code": "def get_current_context(silent: bool = False) -> Context | None:\n    \"\"\"Returns the current click context.  This can be used as a way to\n    access the current context object from anywhere.  This is a more implicit\n    alternative to the :func:`pass_context` decorator.  This function is\n    primarily useful for helpers such as :func:`echo` which might be\n    interested in changing its behavior based on the current context.\n\n    To push the current context, :meth:`Context.scope` can be used.\n\n    .. versionadded:: 5.0\n\n    :param silent: if set to `True` the return value is `None` if no context\n                   is available.  The default behavior is to raise a\n                   :exc:`RuntimeError`.\n    \"\"\"\n    try:\n        return t.cast(\"Context\", _local.stack[-1])\n    except (AttributeError, IndexError) as e:\n        if not silent:\n            raise RuntimeError(\"There is no active click context.\") from e\n\n    return None",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "push_context",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "None",
          "lineno": 44,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.append",
            "ctx",
            "_local.__dict__.setdefault"
          ],
          "docstring": "Pushes a new context to the current stack.",
          "code": "def push_context(ctx: Context) -> None:\n    \"\"\"Pushes a new context to the current stack.\"\"\"\n    _local.__dict__.setdefault(\"stack\", []).append(ctx)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "pop_context",
          "args": [],
          "return_type": "None",
          "lineno": 49,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_local.stack.pop"
          ],
          "docstring": "Removes the top level from the stack.",
          "code": "def pop_context() -> None:\n    \"\"\"Removes the top level from the stack.\"\"\"\n    _local.stack.pop()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "resolve_color_default",
          "args": [
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 54,
          "decorators": [],
          "is_async": false,
          "calls": [
            "get_current_context"
          ],
          "docstring": "Internal helper to get the default value of the color flag.  If a\nvalue is passed it's returned unchanged, otherwise it's looked up from\nthe current context.",
          "code": "def resolve_color_default(color: bool | None = None) -> bool | None:\n    \"\"\"Internal helper to get the default value of the color flag.  If a\n    value is passed it's returned unchanged, otherwise it's looked up from\n    the current context.\n    \"\"\"\n    if color is not None:\n        return color\n\n    ctx = get_current_context(silent=True)\n\n    if ctx is not None:\n        return ctx.color\n\n    return None",
          "line_count": 14,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "threading",
          "name": "local",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Context",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "_local",
          "assigned_to": "local",
          "lineno": 9
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "local"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "threading",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "core"
          ]
        },
        "tech_stack": []
      },
      "line_count": 68
    },
    "src/click/parser.py": {
      "filepath": "../click/src/click/parser.py",
      "module_docstring": "This module started out as largely a copy paste from the stdlib's\noptparse module with the features removed that we do not need from\noptparse because we implement them in Click on a higher level (for\ninstance type handling, help formatting and a lot more).\n\nThe plan is to remove more and more from here over time.\n\nThe reason this is a different module and not optparse from the stdlib\nis that there are differences in 2.x and 3.x about the error messages\ngenerated and optparse in the stdlib uses gettext for no good reason\nand might cause us issues.\n\nClick uses parts of optparse written by Gregory P. Ward and maintained\nby the Python Software Foundation. This is limited to code in parser.py.\n\nCopyright 2001-2006 Gregory P. Ward. All rights reserved.\nCopyright 2002-2006 Python Software Foundation. All rights reserved.",
      "functions": [
        {
          "name": "_unpack_args",
          "args": [
            {
              "name": "args",
              "type": "cabc.Sequence[str]"
            },
            {
              "name": "nargs_spec",
              "type": "cabc.Sequence[int]"
            }
          ],
          "return_type": "tuple[cabc.Sequence[Any], list[str]]",
          "lineno": 51,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "UNSET",
            "c.pop",
            "rv",
            "list",
            "rv.append",
            "deque",
            "len",
            "nargs",
            "TypeError",
            "reversed",
            "nargs_spec",
            "args",
            "c.popleft",
            "_fetch",
            "x.reverse",
            "range",
            "x"
          ],
          "docstring": "Given an iterable of arguments and an iterable of nargs specifications,\nit returns a tuple with all the unpacked arguments at the first index\nand all remaining arguments as the second.\n\nThe nargs specification is the number of arguments that should be consumed\nor `-1` to indicate that this position should eat up all the remainders.\n\nMissing items are filled with ``UNSET``.",
          "code": "def _unpack_args(\n    args: cabc.Sequence[str], nargs_spec: cabc.Sequence[int]\n) -> tuple[cabc.Sequence[str | cabc.Sequence[str | None] | None], list[str]]:\n    \"\"\"Given an iterable of arguments and an iterable of nargs specifications,\n    it returns a tuple with all the unpacked arguments at the first index\n    and all remaining arguments as the second.\n\n    The nargs specification is the number of arguments that should be consumed\n    or `-1` to indicate that this position should eat up all the remainders.\n\n    Missing items are filled with ``UNSET``.\n    \"\"\"\n    args = deque(args)\n    nargs_spec = deque(nargs_spec)\n    rv: list[str | tuple[str | T_UNSET, ...] | T_UNSET] = []\n    spos: int | None = None\n\n    def _fetch(c: deque[V]) -> V | T_UNSET:\n        try:\n            if spos is None:\n                return c.popleft()\n            else:\n                return c.pop()\n        except IndexError:\n            return UNSET\n\n    while nargs_spec:\n        nargs = _fetch(nargs_spec)\n\n        if nargs is None:\n            continue\n\n        if nargs == 1:\n            rv.append(_fetch(args))  # type: ignore[arg-type]\n        elif nargs > 1:\n            x = [_fetch(args) for _ in range(nargs)]\n\n            # If we're reversed, we're pulling in the arguments in reverse,\n            # so we need to turn them around.\n            if spos is not None:\n                x.reverse()\n\n            rv.append(tuple(x))\n        elif nargs < 0:\n            if spos is not None:\n                raise TypeError(\"Cannot have two nargs < 0\")\n\n            spos = len(rv)\n            rv.append(UNSET)\n\n    # spos is the position of the wildcard (star).  If it's not `None`,\n    # we fill it with the remainder.\n    if spos is not None:\n        rv[spos] = tuple(args)\n        args = []\n        rv[spos + 1 :] = reversed(rv[spos + 1 :])\n\n    return tuple(rv), list(args)",
          "line_count": 58,
          "needs_llm_summary": true
        },
        {
          "name": "_split_opt",
          "args": [
            {
              "name": "opt",
              "type": "str"
            }
          ],
          "return_type": "tuple[str, str]",
          "lineno": 111,
          "decorators": [],
          "is_async": false,
          "calls": [
            "first.isalnum"
          ],
          "docstring": null,
          "code": "def _split_opt(opt: str) -> tuple[str, str]:\n    first = opt[:1]\n    if first.isalnum():\n        return \"\", opt\n    if opt[1:2] == first:\n        return opt[:2], opt[2:]\n    return first, opt[1:]",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_normalize_opt",
          "args": [
            {
              "name": "opt",
              "type": "str"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 120,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_split_opt",
            "opt",
            "ctx.token_normalize_func"
          ],
          "docstring": null,
          "code": "def _normalize_opt(opt: str, ctx: Context | None) -> str:\n    if ctx is None or ctx.token_normalize_func is None:\n        return opt\n    prefix, opt = _split_opt(opt)\n    return f\"{prefix}{ctx.token_normalize_func(opt)}\"",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "object",
          "lineno": 502,
          "decorators": [],
          "is_async": false,
          "calls": [
            "AttributeError",
            "warnings.warn",
            "name",
            "globals",
            "DeprecationWarning"
          ],
          "docstring": null,
          "code": "def __getattr__(name: str) -> object:\n    import warnings\n\n    if name in {\n        \"OptionParser\",\n        \"Argument\",\n        \"Option\",\n        \"split_opt\",\n        \"normalize_opt\",\n        \"ParsingState\",\n    }:\n        warnings.warn(\n            f\"'parser.{name}' is deprecated and will be removed in Click 9.0.\"\n            \" The old parser is available in 'optparse'.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return globals()[f\"_{name}\"]\n\n    if name == \"split_arg_string\":\n        from .shell_completion import split_arg_string\n\n        warnings.warn(\n            \"Importing 'parser.split_arg_string' is deprecated, it will only be\"\n            \" available in 'shell_completion' in Click 9.0.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return split_arg_string\n\n    raise AttributeError(name)",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "_fetch",
          "args": [
            {
              "name": "c",
              "type": "deque[V]"
            }
          ],
          "return_type": "Any",
          "lineno": 68,
          "decorators": [],
          "is_async": false,
          "calls": [
            "c.pop",
            "c.popleft"
          ],
          "docstring": null,
          "code": "def _fetch(c: deque[V]) -> V | T_UNSET:\n        try:\n            if spos is None:\n                return c.popleft()\n            else:\n                return c.pop()\n        except IndexError:\n            return UNSET",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "CoreOption"
            },
            {
              "name": "opts",
              "type": "cabc.Sequence[str]"
            },
            {
              "name": "dest",
              "type": "Any"
            },
            {
              "name": "action",
              "type": "Any"
            },
            {
              "name": "nargs",
              "type": "int"
            },
            {
              "name": "const",
              "type": "Any"
            }
          ],
          "return_type": null,
          "lineno": 128,
          "decorators": [],
          "is_async": false,
          "calls": [
            "dest",
            "self._short_opts.append",
            "set",
            "value",
            "len",
            "opt",
            "self.prefixes.add",
            "nargs",
            "prefix",
            "ValueError",
            "_split_opt",
            "obj",
            "action",
            "self._long_opts.append",
            "const"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        obj: CoreOption,\n        opts: cabc.Sequence[str],\n        dest: str | None,\n        action: str | None = None,\n        nargs: int = 1,\n        const: t.Any | None = None,\n    ):\n        self._short_opts = []\n        self._long_opts = []\n        self.prefixes: set[str] = set()\n\n        for opt in opts:\n            prefix, value = _split_opt(opt)\n            if not prefix:\n                raise ValueError(f\"Invalid start character for option ({opt})\")\n            self.prefixes.add(prefix[0])\n            if len(prefix) == 1 and len(value) == 1:\n                self._short_opts.append(opt)\n            else:\n                self._long_opts.append(opt)\n                self.prefixes.add(prefix)\n\n        if action is None:\n            action = \"store\"\n\n        self.dest = dest\n        self.action = action\n        self.nargs = nargs\n        self.const = const\n        self.obj = obj",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "takes_value",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 162,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def takes_value(self) -> bool:\n        return self.action in (\"store\", \"append\")",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "process",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "state",
              "type": "_ParsingState"
            }
          ],
          "return_type": "None",
          "lineno": 165,
          "decorators": [],
          "is_async": false,
          "calls": [
            "state.opts.setdefault",
            "value",
            "self.const",
            "ValueError",
            "self.dest",
            "state.opts.get",
            "unknown.append",
            "self.obj",
            "state.order.append"
          ],
          "docstring": null,
          "code": "def process(self, value: t.Any, state: _ParsingState) -> None:\n        if self.action == \"store\":\n            state.opts[self.dest] = value  # type: ignore\n        elif self.action == \"store_const\":\n            state.opts[self.dest] = self.const  # type: ignore\n        elif self.action == \"append\":\n            state.opts.setdefault(self.dest, []).append(value)  # type: ignore\n        elif self.action == \"append_const\":\n            state.opts.setdefault(self.dest, []).append(self.const)  # type: ignore\n        elif self.action == \"count\":\n            state.opts[self.dest] = state.opts.get(self.dest, 0) + 1  # type: ignore\n        else:\n            raise ValueError(f\"unknown action '{self.action}'\")\n        state.order.append(self.obj)",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "CoreArgument"
            },
            {
              "name": "dest",
              "type": "Any"
            },
            {
              "name": "nargs",
              "type": "int"
            }
          ],
          "return_type": null,
          "lineno": 182,
          "decorators": [],
          "is_async": false,
          "calls": [
            "nargs",
            "obj",
            "dest"
          ],
          "docstring": null,
          "code": "def __init__(self, obj: CoreArgument, dest: str | None, nargs: int = 1):\n        self.dest = dest\n        self.nargs = nargs\n        self.obj = obj",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "process",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            },
            {
              "name": "state",
              "type": "_ParsingState"
            }
          ],
          "return_type": "None",
          "lineno": 187,
          "decorators": [],
          "is_async": false,
          "calls": [
            "UNSET",
            "unknown.format",
            "value",
            "len",
            "_",
            "isinstance",
            "cabc.Sequence",
            "BadArgumentUsage",
            "self.dest",
            "sum",
            "self.nargs",
            "self.obj",
            "state.order.append"
          ],
          "docstring": null,
          "code": "def process(\n        self,\n        value: str | cabc.Sequence[str | None] | None | T_UNSET,\n        state: _ParsingState,\n    ) -> None:\n        if self.nargs > 1:\n            assert isinstance(value, cabc.Sequence)\n            holes = sum(1 for x in value if x is UNSET)\n            if holes == len(value):\n                value = UNSET\n            elif holes != 0:\n                raise BadArgumentUsage(\n                    _(\"Argument {name!r} takes {nargs} values.\").format(\n                        name=self.dest, nargs=self.nargs\n                    )\n                )\n\n        # We failed to collect any argument value so we consider the argument as unset.\n        if value == ():\n            value = UNSET\n\n        state.opts[self.dest] = value  # type: ignore\n        state.order.append(self.obj)",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rargs",
              "type": "list[str]"
            }
          ],
          "return_type": "None",
          "lineno": 213,
          "decorators": [],
          "is_async": false,
          "calls": [
            "rargs"
          ],
          "docstring": null,
          "code": "def __init__(self, rargs: list[str]) -> None:\n        self.opts: dict[str, t.Any] = {}\n        self.largs: list[str] = []\n        self.rargs = rargs\n        self.order: list[CoreParameter] = []",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 237,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "ctx.ignore_unknown_options",
            "ctx.allow_interspersed_args"
          ],
          "docstring": null,
          "code": "def __init__(self, ctx: Context | None = None) -> None:\n        #: The :class:`~click.Context` for this parser.  This might be\n        #: `None` for some advanced use cases.\n        self.ctx = ctx\n        #: This controls how the parser deals with interspersed arguments.\n        #: If this is set to `False`, the parser will stop on the first\n        #: non-option.  Click uses this to implement nested subcommands\n        #: safely.\n        self.allow_interspersed_args: bool = True\n        #: This tells the parser how to deal with unknown options.  By\n        #: default it will error out (which is sensible), but there is a\n        #: second mode where it will ignore it and continue processing\n        #: after shifting all the unknown options into the resulting args.\n        self.ignore_unknown_options: bool = False\n\n        if ctx is not None:\n            self.allow_interspersed_args = ctx.allow_interspersed_args\n            self.ignore_unknown_options = ctx.ignore_unknown_options\n\n        self._short_opt: dict[str, _Option] = {}\n        self._long_opt: dict[str, _Option] = {}\n        self._opt_prefixes = {\"-\", \"--\"}\n        self._args: list[_Argument] = []",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "add_option",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "CoreOption"
            },
            {
              "name": "opts",
              "type": "cabc.Sequence[str]"
            },
            {
              "name": "dest",
              "type": "Any"
            },
            {
              "name": "action",
              "type": "Any"
            },
            {
              "name": "nargs",
              "type": "int"
            },
            {
              "name": "const",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 261,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._opt_prefixes.update",
            "dest",
            "_normalize_opt",
            "opt",
            "opts",
            "option.prefixes",
            "nargs",
            "option",
            "self.ctx",
            "_Option",
            "obj",
            "action",
            "const"
          ],
          "docstring": "Adds a new option named `dest` to the parser.  The destination\nis not inferred (unlike with optparse) and needs to be explicitly\nprovided.  Action can be any of ``store``, ``store_const``,\n``append``, ``append_const`` or ``count``.\n\nThe `obj` can be used to identify the option in the order list\nthat is returned from the parser.",
          "code": "def add_option(\n        self,\n        obj: CoreOption,\n        opts: cabc.Sequence[str],\n        dest: str | None,\n        action: str | None = None,\n        nargs: int = 1,\n        const: t.Any | None = None,\n    ) -> None:\n        \"\"\"Adds a new option named `dest` to the parser.  The destination\n        is not inferred (unlike with optparse) and needs to be explicitly\n        provided.  Action can be any of ``store``, ``store_const``,\n        ``append``, ``append_const`` or ``count``.\n\n        The `obj` can be used to identify the option in the order list\n        that is returned from the parser.\n        \"\"\"\n        opts = [_normalize_opt(opt, self.ctx) for opt in opts]\n        option = _Option(obj, opts, dest, action=action, nargs=nargs, const=const)\n        self._opt_prefixes.update(option.prefixes)\n        for opt in option._short_opts:\n            self._short_opt[opt] = option\n        for opt in option._long_opts:\n            self._long_opt[opt] = option",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "add_argument",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "CoreArgument"
            },
            {
              "name": "dest",
              "type": "Any"
            },
            {
              "name": "nargs",
              "type": "int"
            }
          ],
          "return_type": "None",
          "lineno": 286,
          "decorators": [],
          "is_async": false,
          "calls": [
            "dest",
            "nargs",
            "_Argument",
            "obj",
            "self._args.append"
          ],
          "docstring": "Adds a positional argument named `dest` to the parser.\n\nThe `obj` can be used to identify the option in the order list\nthat is returned from the parser.",
          "code": "def add_argument(self, obj: CoreArgument, dest: str | None, nargs: int = 1) -> None:\n        \"\"\"Adds a positional argument named `dest` to the parser.\n\n        The `obj` can be used to identify the option in the order list\n        that is returned from the parser.\n        \"\"\"\n        self._args.append(_Argument(obj, dest=dest, nargs=nargs))",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "parse_args",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "args",
              "type": "list[str]"
            }
          ],
          "return_type": "tuple[dict[str, t.Any], list[str], list[CoreParameter]]",
          "lineno": 294,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._process_args_for_options",
            "state",
            "args",
            "_ParsingState",
            "self._process_args_for_args"
          ],
          "docstring": "Parses positional arguments and returns ``(values, args, order)``\nfor the parsed options and arguments as well as the leftover\narguments if there are any.  The order is a list of objects as they\nappear on the command line.  If arguments appear multiple times they\nwill be memorized multiple times as well.",
          "code": "def parse_args(\n        self, args: list[str]\n    ) -> tuple[dict[str, t.Any], list[str], list[CoreParameter]]:\n        \"\"\"Parses positional arguments and returns ``(values, args, order)``\n        for the parsed options and arguments as well as the leftover\n        arguments if there are any.  The order is a list of objects as they\n        appear on the command line.  If arguments appear multiple times they\n        will be memorized multiple times as well.\n        \"\"\"\n        state = _ParsingState(args)\n        try:\n            self._process_args_for_options(state)\n            self._process_args_for_args(state)\n        except UsageError:\n            if self.ctx is None or not self.ctx.resilient_parsing:\n                raise\n        return state.opts, state.largs, state.order",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "_process_args_for_args",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "state",
              "type": "_ParsingState"
            }
          ],
          "return_type": "None",
          "lineno": 312,
          "decorators": [],
          "is_async": false,
          "calls": [
            "enumerate",
            "_unpack_args",
            "self._args",
            "arg.process",
            "state",
            "args"
          ],
          "docstring": null,
          "code": "def _process_args_for_args(self, state: _ParsingState) -> None:\n        pargs, args = _unpack_args(\n            state.largs + state.rargs, [x.nargs for x in self._args]\n        )\n\n        for idx, arg in enumerate(self._args):\n            arg.process(pargs[idx], state)\n\n        state.largs = args\n        state.rargs = []",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "_process_args_for_options",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "state",
              "type": "_ParsingState"
            }
          ],
          "return_type": "None",
          "lineno": 323,
          "decorators": [],
          "is_async": false,
          "calls": [
            "arg",
            "len",
            "self._process_opts",
            "state.rargs.pop",
            "state",
            "state.largs.append",
            "state.rargs.insert"
          ],
          "docstring": null,
          "code": "def _process_args_for_options(self, state: _ParsingState) -> None:\n        while state.rargs:\n            arg = state.rargs.pop(0)\n            arglen = len(arg)\n            # Double dashes always handled explicitly regardless of what\n            # prefixes are valid.\n            if arg == \"--\":\n                return\n            elif arg[:1] in self._opt_prefixes and arglen > 1:\n                self._process_opts(arg, state)\n            elif self.allow_interspersed_args:\n                state.largs.append(arg)\n            else:\n                state.rargs.insert(0, arg)\n                return",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "_match_long_opt",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "opt",
              "type": "str"
            },
            {
              "name": "explicit_value",
              "type": "Any"
            },
            {
              "name": "state",
              "type": "_ParsingState"
            }
          ],
          "return_type": "None",
          "lineno": 359,
          "decorators": [],
          "is_async": false,
          "calls": [
            "state.rargs.insert",
            "UNSET",
            "explicit_value",
            "value",
            "option.process",
            "get_close_matches",
            "opt",
            "NoSuchOption",
            "_",
            "self._long_opt",
            "possibilities",
            "self.ctx",
            "option",
            "state",
            "self._get_value_from_state",
            "unknown.format",
            "BadOptionUsage"
          ],
          "docstring": null,
          "code": "def _match_long_opt(\n        self, opt: str, explicit_value: str | None, state: _ParsingState\n    ) -> None:\n        if opt not in self._long_opt:\n            from difflib import get_close_matches\n\n            possibilities = get_close_matches(opt, self._long_opt)\n            raise NoSuchOption(opt, possibilities=possibilities, ctx=self.ctx)\n\n        option = self._long_opt[opt]\n        if option.takes_value:\n            # At this point it's safe to modify rargs by injecting the\n            # explicit value, because no exception is raised in this\n            # branch.  This means that the inserted value will be fully\n            # consumed.\n            if explicit_value is not None:\n                state.rargs.insert(0, explicit_value)\n\n            value = self._get_value_from_state(opt, option, state)\n\n        elif explicit_value is not None:\n            raise BadOptionUsage(\n                opt, _(\"Option {name!r} does not take a value.\").format(name=opt)\n            )\n\n        else:\n            value = UNSET\n\n        option.process(value, state)",
          "line_count": 29,
          "needs_llm_summary": true
        },
        {
          "name": "_match_short_opt",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "arg",
              "type": "str"
            },
            {
              "name": "state",
              "type": "_ParsingState"
            }
          ],
          "return_type": "None",
          "lineno": 389,
          "decorators": [],
          "is_async": false,
          "calls": [
            "arg",
            "self._short_opt.get",
            "_normalize_opt",
            "ch",
            "len",
            "opt",
            "state.rargs.insert",
            "unknown_options",
            "NoSuchOption",
            "state.largs.append",
            "UNSET",
            "option.process",
            "self.ctx",
            "state",
            "self._get_value_from_state",
            "unknown.join",
            "value",
            "option",
            "unknown_options.append"
          ],
          "docstring": null,
          "code": "def _match_short_opt(self, arg: str, state: _ParsingState) -> None:\n        stop = False\n        i = 1\n        prefix = arg[0]\n        unknown_options = []\n\n        for ch in arg[1:]:\n            opt = _normalize_opt(f\"{prefix}{ch}\", self.ctx)\n            option = self._short_opt.get(opt)\n            i += 1\n\n            if not option:\n                if self.ignore_unknown_options:\n                    unknown_options.append(ch)\n                    continue\n                raise NoSuchOption(opt, ctx=self.ctx)\n            if option.takes_value:\n                # Any characters left in arg?  Pretend they're the\n                # next arg, and stop consuming characters of arg.\n                if i < len(arg):\n                    state.rargs.insert(0, arg[i:])\n                    stop = True\n\n                value = self._get_value_from_state(opt, option, state)\n\n            else:\n                value = UNSET\n\n            option.process(value, state)\n\n            if stop:\n                break\n\n        # If we got any unknown options we recombine the string of the\n        # remaining options and re-attach the prefix, then report that\n        # to the state as new larg.  This way there is basic combinatorics\n        # that can be achieved while still ignoring unknown arguments.\n        if self.ignore_unknown_options and unknown_options:\n            state.largs.append(f\"{prefix}{''.join(unknown_options)}\")",
          "line_count": 39,
          "needs_llm_summary": true
        },
        {
          "name": "_get_value_from_state",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "option_name",
              "type": "str"
            },
            {
              "name": "option",
              "type": "_Option"
            },
            {
              "name": "state",
              "type": "_ParsingState"
            }
          ],
          "return_type": "Any",
          "lineno": 429,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "state.rargs",
            "str",
            "len",
            "state.rargs.pop",
            "option.nargs",
            "nargs",
            "next_rarg",
            "option_name",
            "isinstance",
            "ngettext",
            "FLAG_NEEDS_VALUE",
            "unknown.format",
            "BadOptionUsage"
          ],
          "docstring": null,
          "code": "def _get_value_from_state(\n        self, option_name: str, option: _Option, state: _ParsingState\n    ) -> str | cabc.Sequence[str] | T_FLAG_NEEDS_VALUE:\n        nargs = option.nargs\n\n        value: str | cabc.Sequence[str] | T_FLAG_NEEDS_VALUE\n\n        if len(state.rargs) < nargs:\n            if option.obj._flag_needs_value:\n                # Option allows omitting the value.\n                value = FLAG_NEEDS_VALUE\n            else:\n                raise BadOptionUsage(\n                    option_name,\n                    ngettext(\n                        \"Option {name!r} requires an argument.\",\n                        \"Option {name!r} requires {nargs} arguments.\",\n                        nargs,\n                    ).format(name=option_name, nargs=nargs),\n                )\n        elif nargs == 1:\n            next_rarg = state.rargs[0]\n\n            if (\n                option.obj._flag_needs_value\n                and isinstance(next_rarg, str)\n                and next_rarg[:1] in self._opt_prefixes\n                and len(next_rarg) > 1\n            ):\n                # The next arg looks like the start of an option, don't\n                # use it as the value if omitting the value is allowed.\n                value = FLAG_NEEDS_VALUE\n            else:\n                value = state.rargs.pop(0)\n        else:\n            value = tuple(state.rargs[:nargs])\n            del state.rargs[:nargs]\n\n        return value",
          "line_count": 39,
          "needs_llm_summary": true
        },
        {
          "name": "_process_opts",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "arg",
              "type": "str"
            },
            {
              "name": "state",
              "type": "_ParsingState"
            }
          ],
          "return_type": "None",
          "lineno": 469,
          "decorators": [],
          "is_async": false,
          "calls": [
            "arg",
            "explicit_value",
            "_normalize_opt",
            "arg.split",
            "self._match_long_opt",
            "self._match_short_opt",
            "long_opt",
            "self.ctx",
            "state",
            "state.largs.append",
            "norm_long_opt"
          ],
          "docstring": null,
          "code": "def _process_opts(self, arg: str, state: _ParsingState) -> None:\n        explicit_value = None\n        # Long option handling happens in two parts.  The first part is\n        # supporting explicitly attached values.  In any case, we will try\n        # to long match the option first.\n        if \"=\" in arg:\n            long_opt, explicit_value = arg.split(\"=\", 1)\n        else:\n            long_opt = arg\n        norm_long_opt = _normalize_opt(long_opt, self.ctx)\n\n        # At this point we will match the (assumed) long option through\n        # the long option matching code.  Note that this allows options\n        # like \"-foo\" to be matched as long options.\n        try:\n            self._match_long_opt(norm_long_opt, explicit_value, state)\n        except NoSuchOption:\n            # At this point the long option matching failed, and we need\n            # to try with short options.  However there is a special rule\n            # which says, that if we have a two character options prefix\n            # (applies to \"--foo\" for instance), we do not dispatch to the\n            # short option code and will instead raise the no option\n            # error.\n            if arg[:2] not in self._opt_prefixes:\n                self._match_short_opt(arg, state)\n                return\n\n            if not self.ignore_unknown_options:\n                raise\n\n            state.largs.append(arg)",
          "line_count": 31,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "_Option",
          "methods": [
            "__init__",
            "takes_value",
            "process"
          ],
          "base_classes": [],
          "lineno": 127,
          "docstring": null
        },
        {
          "name": "_Argument",
          "methods": [
            "__init__",
            "process"
          ],
          "base_classes": [],
          "lineno": 181,
          "docstring": null
        },
        {
          "name": "_ParsingState",
          "methods": [
            "__init__"
          ],
          "base_classes": [],
          "lineno": 212,
          "docstring": null
        },
        {
          "name": "_OptionParser",
          "methods": [
            "__init__",
            "add_option",
            "add_argument",
            "parse_args",
            "_process_args_for_args",
            "_process_args_for_options",
            "_match_long_opt",
            "_match_short_opt",
            "_get_value_from_state",
            "_process_opts"
          ],
          "base_classes": [],
          "lineno": 220,
          "docstring": "The option parser is an internal class that is ultimately used to\nparse options and arguments.  It's modelled after optparse and brings\na similar but vastly simplified API.  It should generally not be used\ndirectly as the high level Click classes wrap it for you.\n\nIt's not nearly as extensible as optparse or argparse as it does not\nimplement features that are implemented on a higher level (such as\ntypes or defaults).\n\n:param ctx: optionally the :class:`~click.Context` where this parser\n            should go with.\n\n.. deprecated:: 8.2\n    Will be removed in Click 9.0."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 27,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 28,
          "type": "import"
        },
        {
          "module": "collections",
          "name": "deque",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "ngettext",
          "alias": null,
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "_utils",
          "name": "FLAG_NEEDS_VALUE",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "_utils",
          "name": "UNSET",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "BadArgumentUsage",
          "alias": null,
          "lineno": 35,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "BadOptionUsage",
          "alias": null,
          "lineno": 36,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "NoSuchOption",
          "alias": null,
          "lineno": 37,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "UsageError",
          "alias": null,
          "lineno": 38,
          "type": "from_import"
        },
        {
          "module": "_utils",
          "name": "T_FLAG_NEEDS_VALUE",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "_utils",
          "name": "T_UNSET",
          "alias": null,
          "lineno": 42,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Argument",
          "alias": "CoreArgument",
          "lineno": 43,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Context",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Option",
          "alias": "CoreOption",
          "lineno": 45,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Parameter",
          "alias": "CoreParameter",
          "lineno": 46,
          "type": "from_import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 503,
          "type": "import"
        },
        {
          "module": "shell_completion",
          "name": "split_arg_string",
          "alias": null,
          "lineno": 522,
          "type": "from_import"
        },
        {
          "module": "difflib",
          "name": "get_close_matches",
          "alias": null,
          "lineno": 363,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "V",
          "assigned_to": "t.TypeVar",
          "lineno": 48
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "collections",
          "warnings",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "gettext",
            "_utils",
            "exceptions",
            "core",
            "shell_completion",
            "difflib"
          ]
        },
        "tech_stack": []
      },
      "line_count": 533
    },
    "src/click/shell_completion.py": {
      "filepath": "../click/src/click/shell_completion.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "shell_complete",
          "args": [
            {
              "name": "cli",
              "type": "Command"
            },
            {
              "name": "ctx_args",
              "type": "cabc.MutableMapping[str, t.Any]"
            },
            {
              "name": "prog_name",
              "type": "str"
            },
            {
              "name": "complete_var",
              "type": "str"
            },
            {
              "name": "instruction",
              "type": "str"
            }
          ],
          "return_type": "int",
          "lineno": 19,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "comp.complete",
            "shell",
            "cli",
            "prog_name",
            "ctx_args",
            "get_completion_class",
            "instruction.partition",
            "comp.source",
            "comp_cls",
            "complete_var"
          ],
          "docstring": "Perform shell completion for the given CLI program.\n\n:param cli: Command being called.\n:param ctx_args: Extra arguments to pass to\n    ``cli.make_context``.\n:param prog_name: Name of the executable in the shell.\n:param complete_var: Name of the environment variable that holds\n    the completion instruction.\n:param instruction: Value of ``complete_var`` with the completion\n    instruction and shell, in the form ``instruction_shell``.\n:return: Status code to exit with.",
          "code": "def shell_complete(\n    cli: Command,\n    ctx_args: cabc.MutableMapping[str, t.Any],\n    prog_name: str,\n    complete_var: str,\n    instruction: str,\n) -> int:\n    \"\"\"Perform shell completion for the given CLI program.\n\n    :param cli: Command being called.\n    :param ctx_args: Extra arguments to pass to\n        ``cli.make_context``.\n    :param prog_name: Name of the executable in the shell.\n    :param complete_var: Name of the environment variable that holds\n        the completion instruction.\n    :param instruction: Value of ``complete_var`` with the completion\n        instruction and shell, in the form ``instruction_shell``.\n    :return: Status code to exit with.\n    \"\"\"\n    shell, _, instruction = instruction.partition(\"_\")\n    comp_cls = get_completion_class(shell)\n\n    if comp_cls is None:\n        return 1\n\n    comp = comp_cls(cli, ctx_args, prog_name, complete_var)\n\n    if instruction == \"source\":\n        echo(comp.source())\n        return 0\n\n    if instruction == \"complete\":\n        echo(comp.complete())\n        return 0\n\n    return 1",
          "line_count": 36,
          "needs_llm_summary": true
        },
        {
          "name": "add_completion_class",
          "args": [
            {
              "name": "cls",
              "type": "ShellCompleteType"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "ShellCompleteType",
          "lineno": 436,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cls",
            "cls.name"
          ],
          "docstring": "Register a :class:`ShellComplete` subclass under the given name.\nThe name will be provided by the completion instruction environment\nvariable during completion.\n\n:param cls: The completion class that will handle completion for the\n    shell.\n:param name: Name to register the class under. Defaults to the\n    class's ``name`` attribute.",
          "code": "def add_completion_class(\n    cls: ShellCompleteType, name: str | None = None\n) -> ShellCompleteType:\n    \"\"\"Register a :class:`ShellComplete` subclass under the given name.\n    The name will be provided by the completion instruction environment\n    variable during completion.\n\n    :param cls: The completion class that will handle completion for the\n        shell.\n    :param name: Name to register the class under. Defaults to the\n        class's ``name`` attribute.\n    \"\"\"\n    if name is None:\n        name = cls.name\n\n    _available_shells[name] = cls\n\n    return cls",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "get_completion_class",
          "args": [
            {
              "name": "shell",
              "type": "str"
            }
          ],
          "return_type": "Any",
          "lineno": 456,
          "decorators": [],
          "is_async": false,
          "calls": [
            "shell",
            "_available_shells.get"
          ],
          "docstring": "Look up a registered :class:`ShellComplete` subclass by the name\nprovided by the completion instruction environment variable. If the\nname isn't registered, returns ``None``.\n\n:param shell: Name the class is registered under.",
          "code": "def get_completion_class(shell: str) -> type[ShellComplete] | None:\n    \"\"\"Look up a registered :class:`ShellComplete` subclass by the name\n    provided by the completion instruction environment variable. If the\n    name isn't registered, returns ``None``.\n\n    :param shell: Name the class is registered under.\n    \"\"\"\n    return _available_shells.get(shell)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "split_arg_string",
          "args": [
            {
              "name": "string",
              "type": "str"
            }
          ],
          "return_type": "list[str]",
          "lineno": 466,
          "decorators": [],
          "is_async": false,
          "calls": [
            "shlex.shlex",
            "lex.token",
            "token",
            "string",
            "out.append"
          ],
          "docstring": "Split an argument string as with :func:`shlex.split`, but don't\nfail if the string is incomplete. Ignores a missing closing quote or\nincomplete escape sequence and uses the partial token as-is.\n\n.. code-block:: python\n\n    split_arg_string(\"example 'my file\")\n    [\"example\", \"my file\"]\n\n    split_arg_string(\"example my\\\")\n    [\"example\", \"my\"]\n\n:param string: String to split.\n\n.. versionchanged:: 8.2\n    Moved to ``shell_completion`` from ``parser``.",
          "code": "def split_arg_string(string: str) -> list[str]:\n    \"\"\"Split an argument string as with :func:`shlex.split`, but don't\n    fail if the string is incomplete. Ignores a missing closing quote or\n    incomplete escape sequence and uses the partial token as-is.\n\n    .. code-block:: python\n\n        split_arg_string(\"example 'my file\")\n        [\"example\", \"my file\"]\n\n        split_arg_string(\"example my\\\\\")\n        [\"example\", \"my\"]\n\n    :param string: String to split.\n\n    .. versionchanged:: 8.2\n        Moved to ``shell_completion`` from ``parser``.\n    \"\"\"\n    import shlex\n\n    lex = shlex.shlex(string, posix=True)\n    lex.whitespace_split = True\n    lex.commenters = \"\"\n    out = []\n\n    try:\n        for token in lex:\n            out.append(token)\n    except ValueError:\n        # Raised when end-of-string is reached in an invalid state. Use\n        # the partial token as-is. The quote or escape character is in\n        # lex.state, not lex.token.\n        out.append(lex.token)\n\n    return out",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "_is_incomplete_argument",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Parameter"
            }
          ],
          "return_type": "bool",
          "lineno": 503,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Argument",
            "param",
            "param.name",
            "ctx.params.get",
            "ctx.get_parameter_source",
            "value",
            "len",
            "isinstance"
          ],
          "docstring": "Determine if the given parameter is an argument that can still\naccept values.\n\n:param ctx: Invocation context for the command represented by the\n    parsed complete args.\n:param param: Argument object being checked.",
          "code": "def _is_incomplete_argument(ctx: Context, param: Parameter) -> bool:\n    \"\"\"Determine if the given parameter is an argument that can still\n    accept values.\n\n    :param ctx: Invocation context for the command represented by the\n        parsed complete args.\n    :param param: Argument object being checked.\n    \"\"\"\n    if not isinstance(param, Argument):\n        return False\n\n    assert param.name is not None\n    # Will be None if expose_value is False.\n    value = ctx.params.get(param.name)\n    return (\n        param.nargs == -1\n        or ctx.get_parameter_source(param.name) is not ParameterSource.COMMANDLINE\n        or (\n            param.nargs > 1\n            and isinstance(value, (tuple, list))\n            and len(value) < param.nargs\n        )\n    )",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "_start_of_option",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "value",
              "type": "str"
            }
          ],
          "return_type": "bool",
          "lineno": 528,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Check if the value looks like the start of an option.",
          "code": "def _start_of_option(ctx: Context, value: str) -> bool:\n    \"\"\"Check if the value looks like the start of an option.\"\"\"\n    if not value:\n        return False\n\n    c = value[0]\n    return c in ctx._opt_prefixes",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_is_incomplete_option",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "args",
              "type": "list[str]"
            },
            {
              "name": "param",
              "type": "Parameter"
            }
          ],
          "return_type": "bool",
          "lineno": 537,
          "decorators": [],
          "is_async": false,
          "calls": [
            "enumerate",
            "arg",
            "param",
            "ctx",
            "isinstance",
            "reversed",
            "args",
            "Option",
            "_start_of_option"
          ],
          "docstring": "Determine if the given parameter is an option that needs a value.\n\n:param args: List of complete args before the incomplete value.\n:param param: Option object being checked.",
          "code": "def _is_incomplete_option(ctx: Context, args: list[str], param: Parameter) -> bool:\n    \"\"\"Determine if the given parameter is an option that needs a value.\n\n    :param args: List of complete args before the incomplete value.\n    :param param: Option object being checked.\n    \"\"\"\n    if not isinstance(param, Option):\n        return False\n\n    if param.is_flag or param.count:\n        return False\n\n    last_option = None\n\n    for index, arg in enumerate(reversed(args)):\n        if index + 1 > param.nargs:\n            break\n\n        if _start_of_option(ctx, arg):\n            last_option = arg\n            break\n\n    return last_option is not None and last_option in param.opts",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "_resolve_context",
          "args": [
            {
              "name": "cli",
              "type": "Command"
            },
            {
              "name": "ctx_args",
              "type": "cabc.MutableMapping[str, t.Any]"
            },
            {
              "name": "prog_name",
              "type": "str"
            },
            {
              "name": "args",
              "type": "list[str]"
            }
          ],
          "return_type": "Context",
          "lineno": 562,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cli.make_context",
            "cmd.make_context",
            "sub_sub_ctx",
            "ctx",
            "name",
            "command",
            "args.copy",
            "prog_name",
            "isinstance",
            "ctx_args",
            "command.resolve_command",
            "args",
            "sub_ctx.args",
            "ctx.command",
            "Group",
            "sub_ctx"
          ],
          "docstring": "Produce the context hierarchy starting with the command and\ntraversing the complete arguments. This only follows the commands,\nit doesn't trigger input prompts or callbacks.\n\n:param cli: Command being called.\n:param prog_name: Name of the executable in the shell.\n:param args: List of complete args before the incomplete value.",
          "code": "def _resolve_context(\n    cli: Command,\n    ctx_args: cabc.MutableMapping[str, t.Any],\n    prog_name: str,\n    args: list[str],\n) -> Context:\n    \"\"\"Produce the context hierarchy starting with the command and\n    traversing the complete arguments. This only follows the commands,\n    it doesn't trigger input prompts or callbacks.\n\n    :param cli: Command being called.\n    :param prog_name: Name of the executable in the shell.\n    :param args: List of complete args before the incomplete value.\n    \"\"\"\n    ctx_args[\"resilient_parsing\"] = True\n    with cli.make_context(prog_name, args.copy(), **ctx_args) as ctx:\n        args = ctx._protected_args + ctx.args\n\n        while args:\n            command = ctx.command\n\n            if isinstance(command, Group):\n                if not command.chain:\n                    name, cmd, args = command.resolve_command(ctx, args)\n\n                    if cmd is None:\n                        return ctx\n\n                    with cmd.make_context(\n                        name, args, parent=ctx, resilient_parsing=True\n                    ) as sub_ctx:\n                        ctx = sub_ctx\n                        args = ctx._protected_args + ctx.args\n                else:\n                    sub_ctx = ctx\n\n                    while args:\n                        name, cmd, args = command.resolve_command(ctx, args)\n\n                        if cmd is None:\n                            return ctx\n\n                        with cmd.make_context(\n                            name,\n                            args,\n                            parent=ctx,\n                            allow_extra_args=True,\n                            allow_interspersed_args=False,\n                            resilient_parsing=True,\n                        ) as sub_sub_ctx:\n                            sub_ctx = sub_sub_ctx\n                            args = sub_ctx.args\n\n                    ctx = sub_ctx\n                    args = [*sub_ctx._protected_args, *sub_ctx.args]\n            else:\n                break\n\n    return ctx",
          "line_count": 59,
          "needs_llm_summary": true
        },
        {
          "name": "_resolve_incomplete",
          "args": [
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "args",
              "type": "list[str]"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "tuple[Any, str]",
          "lineno": 623,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.command.get_params",
            "incomplete",
            "param",
            "ctx",
            "_is_incomplete_argument",
            "args.append",
            "name",
            "_is_incomplete_option",
            "incomplete.partition",
            "args",
            "_start_of_option"
          ],
          "docstring": "Find the Click object that will handle the completion of the\nincomplete value. Return the object and the incomplete value.\n\n:param ctx: Invocation context for the command represented by\n    the parsed complete args.\n:param args: List of complete args before the incomplete value.\n:param incomplete: Value being completed. May be empty.",
          "code": "def _resolve_incomplete(\n    ctx: Context, args: list[str], incomplete: str\n) -> tuple[Command | Parameter, str]:\n    \"\"\"Find the Click object that will handle the completion of the\n    incomplete value. Return the object and the incomplete value.\n\n    :param ctx: Invocation context for the command represented by\n        the parsed complete args.\n    :param args: List of complete args before the incomplete value.\n    :param incomplete: Value being completed. May be empty.\n    \"\"\"\n    # Different shells treat an \"=\" between a long option name and\n    # value differently. Might keep the value joined, return the \"=\"\n    # as a separate item, or return the split name and value. Always\n    # split and discard the \"=\" to make completion easier.\n    if incomplete == \"=\":\n        incomplete = \"\"\n    elif \"=\" in incomplete and _start_of_option(ctx, incomplete):\n        name, _, incomplete = incomplete.partition(\"=\")\n        args.append(name)\n\n    # The \"--\" marker tells Click to stop treating values as options\n    # even if they start with the option character. If it hasn't been\n    # given and the incomplete arg looks like an option, the current\n    # command will provide option name completions.\n    if \"--\" not in args and _start_of_option(ctx, incomplete):\n        return ctx.command, incomplete\n\n    params = ctx.command.get_params(ctx)\n\n    # If the last complete arg is an option name with an incomplete\n    # value, the option will provide value completions.\n    for param in params:\n        if _is_incomplete_option(ctx, args, param):\n            return param, incomplete\n\n    # It's not an option name or value. The first argument without a\n    # parsed value will provide value completions.\n    for param in params:\n        if _is_incomplete_argument(ctx, param):\n            return param, incomplete\n\n    # There were no unparsed arguments, the command may be a group that\n    # will provide command name completions.\n    return ctx.command, incomplete",
          "line_count": 45,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "type",
              "type": "str"
            },
            {
              "name": "help",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 78,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        value: t.Any,\n        type: str = \"plain\",\n        help: str | None = None,\n        **kwargs: t.Any,\n    ) -> None:\n        self.value: t.Any = value\n        self.type: str = type\n        self.help: str | None = help\n        self._info = kwargs",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 90,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "self._info.get"
          ],
          "docstring": null,
          "code": "def __getattr__(self, name: str) -> t.Any:\n        return self._info.get(name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "cli",
              "type": "Command"
            },
            {
              "name": "ctx_args",
              "type": "cabc.MutableMapping[str, t.Any]"
            },
            {
              "name": "prog_name",
              "type": "str"
            },
            {
              "name": "complete_var",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 224,
          "decorators": [],
          "is_async": false,
          "calls": [
            "prog_name",
            "ctx_args",
            "complete_var",
            "cli"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        cli: Command,\n        ctx_args: cabc.MutableMapping[str, t.Any],\n        prog_name: str,\n        complete_var: str,\n    ) -> None:\n        self.cli = cli\n        self.ctx_args = ctx_args\n        self.prog_name = prog_name\n        self.complete_var = complete_var",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "func_name",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 237,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "re.ASCII",
            "self.prog_name.replace",
            "re.sub"
          ],
          "docstring": "The name of the shell function defined by the completion\nscript.",
          "code": "def func_name(self) -> str:\n        \"\"\"The name of the shell function defined by the completion\n        script.\n        \"\"\"\n        safe_name = re.sub(r\"\\W*\", \"\", self.prog_name.replace(\"-\", \"_\"), flags=re.ASCII)\n        return f\"_{safe_name}_completion\"",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "source_vars",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 244,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Vars for formatting :attr:`source_template`.\n\nBy default this provides ``complete_func``, ``complete_var``,\nand ``prog_name``.",
          "code": "def source_vars(self) -> dict[str, t.Any]:\n        \"\"\"Vars for formatting :attr:`source_template`.\n\n        By default this provides ``complete_func``, ``complete_var``,\n        and ``prog_name``.\n        \"\"\"\n        return {\n            \"complete_func\": self.func_name,\n            \"complete_var\": self.complete_var,\n            \"prog_name\": self.prog_name,\n        }",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "source",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 256,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.source_vars"
          ],
          "docstring": "Produce the shell script that defines the completion\nfunction. By default this ``%``-style formats\n:attr:`source_template` with the dict returned by\n:meth:`source_vars`.",
          "code": "def source(self) -> str:\n        \"\"\"Produce the shell script that defines the completion\n        function. By default this ``%``-style formats\n        :attr:`source_template` with the dict returned by\n        :meth:`source_vars`.\n        \"\"\"\n        return self.source_template % self.source_vars()",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "get_completion_args",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "tuple[list[str], str]",
          "lineno": 264,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Use the env vars defined by the shell script to return a\ntuple of ``args, incomplete``. This must be implemented by\nsubclasses.",
          "code": "def get_completion_args(self) -> tuple[list[str], str]:\n        \"\"\"Use the env vars defined by the shell script to return a\n        tuple of ``args, incomplete``. This must be implemented by\n        subclasses.\n        \"\"\"\n        raise NotImplementedError",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "get_completions",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "args",
              "type": "list[str]"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "list[CompletionItem]",
          "lineno": 271,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.cli",
            "_resolve_incomplete",
            "incomplete",
            "_resolve_context",
            "ctx",
            "obj.shell_complete",
            "self.prog_name",
            "self.ctx_args",
            "args"
          ],
          "docstring": "Determine the context and last complete command or parameter\nfrom the complete args. Call that object's ``shell_complete``\nmethod to get the completions for the incomplete value.\n\n:param args: List of complete args before the incomplete value.\n:param incomplete: Value being completed. May be empty.",
          "code": "def get_completions(self, args: list[str], incomplete: str) -> list[CompletionItem]:\n        \"\"\"Determine the context and last complete command or parameter\n        from the complete args. Call that object's ``shell_complete``\n        method to get the completions for the incomplete value.\n\n        :param args: List of complete args before the incomplete value.\n        :param incomplete: Value being completed. May be empty.\n        \"\"\"\n        ctx = _resolve_context(self.cli, self.ctx_args, self.prog_name, args)\n        obj, incomplete = _resolve_incomplete(ctx, args, incomplete)\n        return obj.shell_complete(ctx, incomplete)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "format_completion",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "item",
              "type": "CompletionItem"
            }
          ],
          "return_type": "str",
          "lineno": 283,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Format a completion item into the form recognized by the\nshell script. This must be implemented by subclasses.\n\n:param item: Completion item to format.",
          "code": "def format_completion(self, item: CompletionItem) -> str:\n        \"\"\"Format a completion item into the form recognized by the\n        shell script. This must be implemented by subclasses.\n\n        :param item: Completion item to format.\n        \"\"\"\n        raise NotImplementedError",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "complete",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 291,
          "decorators": [],
          "is_async": false,
          "calls": [
            "out",
            "unknown.join",
            "incomplete",
            "self.get_completion_args",
            "self.format_completion",
            "args",
            "self.get_completions",
            "item"
          ],
          "docstring": "Produce the completion data to send back to the shell.\n\nBy default this calls :meth:`get_completion_args`, gets the\ncompletions, then calls :meth:`format_completion` for each\ncompletion.",
          "code": "def complete(self) -> str:\n        \"\"\"Produce the completion data to send back to the shell.\n\n        By default this calls :meth:`get_completion_args`, gets the\n        completions, then calls :meth:`format_completion` for each\n        completion.\n        \"\"\"\n        args, incomplete = self.get_completion_args()\n        completions = self.get_completions(args, incomplete)\n        out = [self.format_completion(item) for item in completions]\n        return \"\\n\".join(out)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "_check_version",
          "args": [],
          "return_type": "None",
          "lineno": 311,
          "decorators": [
            {
              "name": "staticmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "echo",
            "re.search",
            "shutil.which",
            "_",
            "subprocess.PIPE",
            "output.stdout.decode",
            "subprocess.run",
            "match.groups"
          ],
          "docstring": null,
          "code": "def _check_version() -> None:\n        import shutil\n        import subprocess\n\n        bash_exe = shutil.which(\"bash\")\n\n        if bash_exe is None:\n            match = None\n        else:\n            output = subprocess.run(\n                [bash_exe, \"--norc\", \"-c\", 'echo \"${BASH_VERSION}\"'],\n                stdout=subprocess.PIPE,\n            )\n            match = re.search(r\"^(\\d+)\\.(\\d+)\\.\\d+\", output.stdout.decode())\n\n        if match is not None:\n            major, minor = match.groups()\n\n            if major < \"4\" or major == \"4\" and minor < \"4\":\n                echo(\n                    _(\n                        \"Shell completion is not supported for Bash\"\n                        \" versions older than 4.4.\"\n                    ),\n                    err=True,\n                )\n        else:\n            echo(\n                _(\"Couldn't detect Bash version, shell completion is not supported.\"),\n                err=True,\n            )",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "source",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 343,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "self._check_version",
            "unknown.source"
          ],
          "docstring": null,
          "code": "def source(self) -> str:\n        self._check_version()\n        return super().source()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "get_completion_args",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "tuple[list[str], str]",
          "lineno": 347,
          "decorators": [],
          "is_async": false,
          "calls": [
            "split_arg_string",
            "int"
          ],
          "docstring": null,
          "code": "def get_completion_args(self) -> tuple[list[str], str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n        cword = int(os.environ[\"COMP_CWORD\"])\n        args = cwords[1:cword]\n\n        try:\n            incomplete = cwords[cword]\n        except IndexError:\n            incomplete = \"\"\n\n        return args, incomplete",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "format_completion",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "item",
              "type": "CompletionItem"
            }
          ],
          "return_type": "str",
          "lineno": 359,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def format_completion(self, item: CompletionItem) -> str:\n        return f\"{item.type},{item.value}\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_completion_args",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "tuple[list[str], str]",
          "lineno": 369,
          "decorators": [],
          "is_async": false,
          "calls": [
            "split_arg_string",
            "int"
          ],
          "docstring": null,
          "code": "def get_completion_args(self) -> tuple[list[str], str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n        cword = int(os.environ[\"COMP_CWORD\"])\n        args = cwords[1:cword]\n\n        try:\n            incomplete = cwords[cword]\n        except IndexError:\n            incomplete = \"\"\n\n        return args, incomplete",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "format_completion",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "item",
              "type": "CompletionItem"
            }
          ],
          "return_type": "str",
          "lineno": 381,
          "decorators": [],
          "is_async": false,
          "calls": [
            "item.value.replace"
          ],
          "docstring": null,
          "code": "def format_completion(self, item: CompletionItem) -> str:\n        help_ = item.help or \"_\"\n        # The zsh completion script uses `_describe` on items with help\n        # texts (which splits the item help from the item value at the\n        # first unescaped colon) and `compadd` on items without help\n        # text (which uses the item value as-is and does not support\n        # colon escaping).  So escape colons in the item value if and\n        # only if the item help is not the sentinel \"_\" value, as used\n        # by the completion script.\n        #\n        # (The zsh completion script is potentially widely deployed, and\n        # thus harder to fix than this method.)\n        #\n        # See issue #1812 and issue #2703 for further context.\n        value = item.value.replace(\":\", r\"\\:\") if help_ != \"_\" else item.value\n        return f\"{item.type}\\n{value}\\n{help_}\"",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "get_completion_args",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "tuple[list[str], str]",
          "lineno": 405,
          "decorators": [],
          "is_async": false,
          "calls": [
            "split_arg_string",
            "incomplete",
            "args.pop"
          ],
          "docstring": null,
          "code": "def get_completion_args(self) -> tuple[list[str], str]:\n        cwords = split_arg_string(os.environ[\"COMP_WORDS\"])\n        incomplete = os.environ[\"COMP_CWORD\"]\n        if incomplete:\n            incomplete = split_arg_string(incomplete)[0]\n        args = cwords[1:]\n\n        # Fish stores the partial word in both COMP_WORDS and\n        # COMP_CWORD, remove it from complete args.\n        if incomplete and args and args[-1] == incomplete:\n            args.pop()\n\n        return args, incomplete",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "format_completion",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "item",
              "type": "CompletionItem"
            }
          ],
          "return_type": "str",
          "lineno": 419,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def format_completion(self, item: CompletionItem) -> str:\n        if item.help:\n            return f\"{item.type},{item.value}\\t{item.help}\"\n\n        return f\"{item.type},{item.value}\"",
          "line_count": 5,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "CompletionItem",
          "methods": [
            "__init__",
            "__getattr__"
          ],
          "base_classes": [],
          "lineno": 57,
          "docstring": "Represents a completion value and metadata about the value. The\ndefault metadata is ``type`` to indicate special shell handling,\nand ``help`` if a shell supports showing a help string next to the\nvalue.\n\nArbitrary parameters can be passed when creating the object, and\naccessed using ``item.attr``. If an attribute wasn't passed,\naccessing it returns ``None``.\n\n:param value: The completion suggestion.\n:param type: Tells the shell script to provide special completion\n    support for the type. Click uses ``\"dir\"`` and ``\"file\"``.\n:param help: String shown next to the value if supported.\n:param kwargs: Arbitrary metadata. The built-in implementations\n    don't use this, but custom type completions paired with custom\n    shell support could use it."
        },
        {
          "name": "ShellComplete",
          "methods": [
            "__init__",
            "func_name",
            "source_vars",
            "source",
            "get_completion_args",
            "get_completions",
            "format_completion",
            "complete"
          ],
          "base_classes": [],
          "lineno": 200,
          "docstring": "Base class for providing shell completion support. A subclass for\na given shell will override attributes and methods to implement the\ncompletion instructions (``source`` and ``complete``).\n\n:param cli: Command being called.\n:param prog_name: Name of the executable in the shell.\n:param complete_var: Name of the environment variable that holds\n    the completion instruction.\n\n.. versionadded:: 8.0"
        },
        {
          "name": "BashComplete",
          "methods": [
            "_check_version",
            "source",
            "get_completion_args",
            "format_completion"
          ],
          "base_classes": [
            "ShellComplete"
          ],
          "lineno": 304,
          "docstring": "Shell completion for Bash."
        },
        {
          "name": "ZshComplete",
          "methods": [
            "get_completion_args",
            "format_completion"
          ],
          "base_classes": [
            "ShellComplete"
          ],
          "lineno": 363,
          "docstring": "Shell completion for Zsh."
        },
        {
          "name": "FishComplete",
          "methods": [
            "get_completion_args",
            "format_completion"
          ],
          "base_classes": [
            "ShellComplete"
          ],
          "lineno": 399,
          "docstring": "Shell completion for Fish."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "re",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Argument",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Command",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Context",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Group",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Option",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Parameter",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "ParameterSource",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "echo",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "shlex",
          "alias": null,
          "lineno": 484,
          "type": "import"
        },
        {
          "module": "shutil",
          "alias": null,
          "lineno": 312,
          "type": "import"
        },
        {
          "module": "subprocess",
          "alias": null,
          "lineno": 313,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "_SOURCE_BASH",
          "assigned_to": "str",
          "lineno": 95
        },
        {
          "name": "_SOURCE_ZSH",
          "assigned_to": "str",
          "lineno": 133
        },
        {
          "name": "_SOURCE_FISH",
          "assigned_to": "str",
          "lineno": 177
        },
        {
          "name": "ShellCompleteType",
          "assigned_to": "t.TypeVar",
          "lineno": 426
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "re",
          "shutil",
          "typing",
          "os",
          "subprocess",
          "collections"
        ],
        "third_party": {
          "other": [
            "__future__",
            "gettext",
            "core",
            "utils",
            "shlex"
          ]
        },
        "tech_stack": []
      },
      "line_count": 668
    },
    "src/click/termui.py": {
      "filepath": "../click/src/click/termui.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "hidden_prompt_func",
          "args": [
            {
              "name": "prompt",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 54,
          "decorators": [],
          "is_async": false,
          "calls": [
            "prompt",
            "getpass.getpass"
          ],
          "docstring": null,
          "code": "def hidden_prompt_func(prompt: str) -> str:\n    import getpass\n\n    return getpass.getpass(prompt)",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "_build_prompt",
          "args": [
            {
              "name": "text",
              "type": "str"
            },
            {
              "name": "suffix",
              "type": "str"
            },
            {
              "name": "show_default",
              "type": "bool"
            },
            {
              "name": "default",
              "type": "Any"
            },
            {
              "name": "show_choices",
              "type": "bool"
            },
            {
              "name": "type",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 60,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "type.choices",
            "_format_default",
            "type",
            "unknown.join",
            "str",
            "isinstance",
            "Choice",
            "default",
            "map"
          ],
          "docstring": null,
          "code": "def _build_prompt(\n    text: str,\n    suffix: str,\n    show_default: bool = False,\n    default: t.Any | None = None,\n    show_choices: bool = True,\n    type: ParamType | None = None,\n) -> str:\n    prompt = text\n    if type is not None and show_choices and isinstance(type, Choice):\n        prompt += f\" ({', '.join(map(str, type.choices))})\"\n    if default is not None and show_default:\n        prompt = f\"{prompt} [{_format_default(default)}]\"\n    return f\"{prompt}{suffix}\"",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "_format_default",
          "args": [
            {
              "name": "default",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 76,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "hasattr",
            "default"
          ],
          "docstring": null,
          "code": "def _format_default(default: t.Any) -> t.Any:\n    if isinstance(default, (io.IOBase, LazyFile)) and hasattr(default, \"name\"):\n        return default.name\n\n    return default",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "prompt",
          "args": [
            {
              "name": "text",
              "type": "str"
            },
            {
              "name": "default",
              "type": "Any"
            },
            {
              "name": "hide_input",
              "type": "bool"
            },
            {
              "name": "confirmation_prompt",
              "type": "Any"
            },
            {
              "name": "type",
              "type": "Any"
            },
            {
              "name": "value_proc",
              "type": "Any"
            },
            {
              "name": "prompt_suffix",
              "type": "str"
            },
            {
              "name": "show_default",
              "type": "bool"
            },
            {
              "name": "err",
              "type": "bool"
            },
            {
              "name": "show_choices",
              "type": "bool"
            }
          ],
          "return_type": "t.Any",
          "lineno": 83,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "echo",
            "type",
            "confirmation_prompt",
            "f",
            "default",
            "unknown.format",
            "prompt_func",
            "_",
            "show_choices",
            "Abort",
            "_build_prompt",
            "prompt_suffix",
            "e",
            "show_default",
            "convert_type",
            "value",
            "err",
            "prompt",
            "value_proc"
          ],
          "docstring": "Prompts a user for input.  This is a convenience function that can\nbe used to prompt a user for input later.\n\nIf the user aborts the input by sending an interrupt signal, this\nfunction will catch it and raise a :exc:`Abort` exception.\n\n:param text: the text to show for the prompt.\n:param default: the default value to use if no input happens.  If this\n                is not given it will prompt until it's aborted.\n:param hide_input: if this is set to true then the input value will\n                   be hidden.\n:param confirmation_prompt: Prompt a second time to confirm the\n    value. Can be set to a string instead of ``True`` to customize\n    the message.\n:param type: the type to use to check the value against.\n:param value_proc: if this parameter is provided it's a function that\n                   is invoked instead of the type conversion to\n                   convert a value.\n:param prompt_suffix: a suffix that should be added to the prompt.\n:param show_default: shows or hides the default value in the prompt.\n:param err: if set to true the file defaults to ``stderr`` instead of\n            ``stdout``, the same as with echo.\n:param show_choices: Show or hide choices if the passed type is a Choice.\n                     For example if type is a Choice of either day or week,\n                     show_choices is true and text is \"Group by\" then the\n                     prompt will be \"Group by (day, week): \".\n\n.. versionchanged:: 8.3.1\n    A space is no longer appended to the prompt.\n\n.. versionadded:: 8.0\n    ``confirmation_prompt`` can be a custom string.\n\n.. versionadded:: 7.0\n    Added the ``show_choices`` parameter.\n\n.. versionadded:: 6.0\n    Added unicode support for cmd.exe on Windows.\n\n.. versionadded:: 4.0\n    Added the `err` parameter.",
          "code": "def prompt(\n    text: str,\n    default: t.Any | None = None,\n    hide_input: bool = False,\n    confirmation_prompt: bool | str = False,\n    type: ParamType | t.Any | None = None,\n    value_proc: t.Callable[[str], t.Any] | None = None,\n    prompt_suffix: str = \": \",\n    show_default: bool = True,\n    err: bool = False,\n    show_choices: bool = True,\n) -> t.Any:\n    \"\"\"Prompts a user for input.  This is a convenience function that can\n    be used to prompt a user for input later.\n\n    If the user aborts the input by sending an interrupt signal, this\n    function will catch it and raise a :exc:`Abort` exception.\n\n    :param text: the text to show for the prompt.\n    :param default: the default value to use if no input happens.  If this\n                    is not given it will prompt until it's aborted.\n    :param hide_input: if this is set to true then the input value will\n                       be hidden.\n    :param confirmation_prompt: Prompt a second time to confirm the\n        value. Can be set to a string instead of ``True`` to customize\n        the message.\n    :param type: the type to use to check the value against.\n    :param value_proc: if this parameter is provided it's a function that\n                       is invoked instead of the type conversion to\n                       convert a value.\n    :param prompt_suffix: a suffix that should be added to the prompt.\n    :param show_default: shows or hides the default value in the prompt.\n    :param err: if set to true the file defaults to ``stderr`` instead of\n                ``stdout``, the same as with echo.\n    :param show_choices: Show or hide choices if the passed type is a Choice.\n                         For example if type is a Choice of either day or week,\n                         show_choices is true and text is \"Group by\" then the\n                         prompt will be \"Group by (day, week): \".\n\n    .. versionchanged:: 8.3.1\n        A space is no longer appended to the prompt.\n\n    .. versionadded:: 8.0\n        ``confirmation_prompt`` can be a custom string.\n\n    .. versionadded:: 7.0\n        Added the ``show_choices`` parameter.\n\n    .. versionadded:: 6.0\n        Added unicode support for cmd.exe on Windows.\n\n    .. versionadded:: 4.0\n        Added the `err` parameter.\n\n    \"\"\"\n\n    def prompt_func(text: str) -> str:\n        f = hidden_prompt_func if hide_input else visible_prompt_func\n        try:\n            # Write the prompt separately so that we get nice\n            # coloring through colorama on Windows\n            echo(text[:-1], nl=False, err=err)\n            # Echo the last character to stdout to work around an issue where\n            # readline causes backspace to clear the whole line.\n            return f(text[-1:])\n        except (KeyboardInterrupt, EOFError):\n            # getpass doesn't print a newline if the user aborts input with ^C.\n            # Allegedly this behavior is inherited from getpass(3).\n            # A doc bug has been filed at https://bugs.python.org/issue24711\n            if hide_input:\n                echo(None, err=err)\n            raise Abort() from None\n\n    if value_proc is None:\n        value_proc = convert_type(type, default)\n\n    prompt = _build_prompt(\n        text, prompt_suffix, show_default, default, show_choices, type\n    )\n\n    if confirmation_prompt:\n        if confirmation_prompt is True:\n            confirmation_prompt = _(\"Repeat for confirmation\")\n\n        confirmation_prompt = _build_prompt(confirmation_prompt, prompt_suffix)\n\n    while True:\n        while True:\n            value = prompt_func(prompt)\n            if value:\n                break\n            elif default is not None:\n                value = default\n                break\n        try:\n            result = value_proc(value)\n        except UsageError as e:\n            if hide_input:\n                echo(_(\"Error: The value you entered was invalid.\"), err=err)\n            else:\n                echo(_(\"Error: {e.message}\").format(e=e), err=err)\n            continue\n        if not confirmation_prompt:\n            return result\n        while True:\n            value2 = prompt_func(confirmation_prompt)\n            is_empty = not value and not value2\n            if value2 or is_empty:\n                break\n        if value == value2:\n            return result\n        echo(_(\"Error: The two entered values do not match.\"), err=err)",
          "line_count": 112,
          "needs_llm_summary": true
        },
        {
          "name": "confirm",
          "args": [
            {
              "name": "text",
              "type": "str"
            },
            {
              "name": "default",
              "type": "Any"
            },
            {
              "name": "abort",
              "type": "bool"
            },
            {
              "name": "prompt_suffix",
              "type": "str"
            },
            {
              "name": "show_default",
              "type": "bool"
            },
            {
              "name": "err",
              "type": "bool"
            }
          ],
          "return_type": "bool",
          "lineno": 197,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "echo",
            "unknown.lower",
            "_",
            "err",
            "show_default",
            "Abort",
            "_build_prompt",
            "prompt_suffix",
            "default",
            "unknown.strip",
            "visible_prompt_func"
          ],
          "docstring": "Prompts for confirmation (yes/no question).\n\nIf the user aborts the input by sending a interrupt signal this\nfunction will catch it and raise a :exc:`Abort` exception.\n\n:param text: the question to ask.\n:param default: The default value to use when no input is given. If\n    ``None``, repeat until input is given.\n:param abort: if this is set to `True` a negative answer aborts the\n              exception by raising :exc:`Abort`.\n:param prompt_suffix: a suffix that should be added to the prompt.\n:param show_default: shows or hides the default value in the prompt.\n:param err: if set to true the file defaults to ``stderr`` instead of\n            ``stdout``, the same as with echo.\n\n.. versionchanged:: 8.3.1\n    A space is no longer appended to the prompt.\n\n.. versionchanged:: 8.0\n    Repeat until input is given if ``default`` is ``None``.\n\n.. versionadded:: 4.0\n    Added the ``err`` parameter.",
          "code": "def confirm(\n    text: str,\n    default: bool | None = False,\n    abort: bool = False,\n    prompt_suffix: str = \": \",\n    show_default: bool = True,\n    err: bool = False,\n) -> bool:\n    \"\"\"Prompts for confirmation (yes/no question).\n\n    If the user aborts the input by sending a interrupt signal this\n    function will catch it and raise a :exc:`Abort` exception.\n\n    :param text: the question to ask.\n    :param default: The default value to use when no input is given. If\n        ``None``, repeat until input is given.\n    :param abort: if this is set to `True` a negative answer aborts the\n                  exception by raising :exc:`Abort`.\n    :param prompt_suffix: a suffix that should be added to the prompt.\n    :param show_default: shows or hides the default value in the prompt.\n    :param err: if set to true the file defaults to ``stderr`` instead of\n                ``stdout``, the same as with echo.\n\n    .. versionchanged:: 8.3.1\n        A space is no longer appended to the prompt.\n\n    .. versionchanged:: 8.0\n        Repeat until input is given if ``default`` is ``None``.\n\n    .. versionadded:: 4.0\n        Added the ``err`` parameter.\n    \"\"\"\n    prompt = _build_prompt(\n        text,\n        prompt_suffix,\n        show_default,\n        \"y/n\" if default is None else (\"Y/n\" if default else \"y/N\"),\n    )\n\n    while True:\n        try:\n            # Write the prompt separately so that we get nice\n            # coloring through colorama on Windows\n            echo(prompt[:-1], nl=False, err=err)\n            # Echo the last character to stdout to work around an issue where\n            # readline causes backspace to clear the whole line.\n            value = visible_prompt_func(prompt[-1:]).lower().strip()\n        except (KeyboardInterrupt, EOFError):\n            raise Abort() from None\n        if value in (\"y\", \"yes\"):\n            rv = True\n        elif value in (\"n\", \"no\"):\n            rv = False\n        elif default is not None and value == \"\":\n            rv = default\n        else:\n            echo(_(\"Error: invalid input\"), err=err)\n            continue\n        break\n    if abort and not rv:\n        raise Abort()\n    return rv",
          "line_count": 62,
          "needs_llm_summary": true
        },
        {
          "name": "echo_via_pager",
          "args": [
            {
              "name": "text_or_generator",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 261,
          "decorators": [],
          "is_async": false,
          "calls": [
            "el",
            "pager",
            "iter",
            "str",
            "resolve_color_default",
            "t.cast",
            "isinstance",
            "inspect.isgeneratorfunction",
            "color",
            "itertools.chain",
            "text_or_generator",
            "text_generator"
          ],
          "docstring": "This function takes a text and shows it via an environment specific\npager on stdout.\n\n.. versionchanged:: 3.0\n   Added the `color` flag.\n\n:param text_or_generator: the text to page, or alternatively, a\n                          generator emitting the text to page.\n:param color: controls if the pager supports ANSI colors or not.  The\n              default is autodetection.",
          "code": "def echo_via_pager(\n    text_or_generator: cabc.Iterable[str] | t.Callable[[], cabc.Iterable[str]] | str,\n    color: bool | None = None,\n) -> None:\n    \"\"\"This function takes a text and shows it via an environment specific\n    pager on stdout.\n\n    .. versionchanged:: 3.0\n       Added the `color` flag.\n\n    :param text_or_generator: the text to page, or alternatively, a\n                              generator emitting the text to page.\n    :param color: controls if the pager supports ANSI colors or not.  The\n                  default is autodetection.\n    \"\"\"\n    color = resolve_color_default(color)\n\n    if inspect.isgeneratorfunction(text_or_generator):\n        i = t.cast(\"t.Callable[[], cabc.Iterable[str]]\", text_or_generator)()\n    elif isinstance(text_or_generator, str):\n        i = [text_or_generator]\n    else:\n        i = iter(t.cast(\"cabc.Iterable[str]\", text_or_generator))\n\n    # convert every element of i to a text type if necessary\n    text_generator = (el if isinstance(el, str) else str(el) for el in i)\n\n    from ._termui_impl import pager\n\n    return pager(itertools.chain(text_generator, \"\\n\"), color)",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "progressbar",
          "args": [],
          "return_type": "ProgressBar[int]",
          "lineno": 294,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def progressbar(\n    *,\n    length: int,\n    label: str | None = None,\n    hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool | None = None,\n    show_pos: bool = False,\n    fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n    width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n    update_min_steps: int = 1,\n) -> ProgressBar[int]: ...",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "progressbar",
          "args": [
            {
              "name": "iterable",
              "type": "Any"
            },
            {
              "name": "length",
              "type": "Any"
            },
            {
              "name": "label",
              "type": "Any"
            },
            {
              "name": "hidden",
              "type": "bool"
            },
            {
              "name": "show_eta",
              "type": "bool"
            },
            {
              "name": "show_percent",
              "type": "Any"
            },
            {
              "name": "show_pos",
              "type": "bool"
            },
            {
              "name": "item_show_func",
              "type": "Any"
            },
            {
              "name": "fill_char",
              "type": "str"
            },
            {
              "name": "empty_char",
              "type": "str"
            },
            {
              "name": "bar_template",
              "type": "str"
            },
            {
              "name": "info_sep",
              "type": "str"
            },
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "file",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "Any"
            },
            {
              "name": "update_min_steps",
              "type": "int"
            }
          ],
          "return_type": "ProgressBar[V]",
          "lineno": 314,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def progressbar(\n    iterable: cabc.Iterable[V] | None = None,\n    length: int | None = None,\n    label: str | None = None,\n    hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool | None = None,\n    show_pos: bool = False,\n    item_show_func: t.Callable[[V | None], str | None] | None = None,\n    fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n    width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n    update_min_steps: int = 1,\n) -> ProgressBar[V]: ...",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "progressbar",
          "args": [
            {
              "name": "iterable",
              "type": "Any"
            },
            {
              "name": "length",
              "type": "Any"
            },
            {
              "name": "label",
              "type": "Any"
            },
            {
              "name": "hidden",
              "type": "bool"
            },
            {
              "name": "show_eta",
              "type": "bool"
            },
            {
              "name": "show_percent",
              "type": "Any"
            },
            {
              "name": "show_pos",
              "type": "bool"
            },
            {
              "name": "item_show_func",
              "type": "Any"
            },
            {
              "name": "fill_char",
              "type": "str"
            },
            {
              "name": "empty_char",
              "type": "str"
            },
            {
              "name": "bar_template",
              "type": "str"
            },
            {
              "name": "info_sep",
              "type": "str"
            },
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "file",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "Any"
            },
            {
              "name": "update_min_steps",
              "type": "int"
            }
          ],
          "return_type": "ProgressBar[V]",
          "lineno": 334,
          "decorators": [],
          "is_async": false,
          "calls": [
            "iterable",
            "info_sep",
            "ProgressBar",
            "show_pos",
            "update_min_steps",
            "empty_char",
            "file",
            "length",
            "resolve_color_default",
            "show_eta",
            "label",
            "bar_template",
            "width",
            "color",
            "hidden",
            "item_show_func",
            "fill_char",
            "show_percent"
          ],
          "docstring": "This function creates an iterable context manager that can be used\nto iterate over something while showing a progress bar.  It will\neither iterate over the `iterable` or `length` items (that are counted\nup).  While iteration happens, this function will print a rendered\nprogress bar to the given `file` (defaults to stdout) and will attempt\nto calculate remaining time and more.  By default, this progress bar\nwill not be rendered if the file is not a terminal.\n\nThe context manager creates the progress bar.  When the context\nmanager is entered the progress bar is already created.  With every\niteration over the progress bar, the iterable passed to the bar is\nadvanced and the bar is updated.  When the context manager exits,\na newline is printed and the progress bar is finalized on screen.\n\nNote: The progress bar is currently designed for use cases where the\ntotal progress can be expected to take at least several seconds.\nBecause of this, the ProgressBar class object won't display\nprogress that is considered too fast, and progress where the time\nbetween steps is less than a second.\n\nNo printing must happen or the progress bar will be unintentionally\ndestroyed.\n\nExample usage::\n\n    with progressbar(items) as bar:\n        for item in bar:\n            do_something_with(item)\n\nAlternatively, if no iterable is specified, one can manually update the\nprogress bar through the `update()` method instead of directly\niterating over the progress bar.  The update method accepts the number\nof steps to increment the bar with::\n\n    with progressbar(length=chunks.total_bytes) as bar:\n        for chunk in chunks:\n            process_chunk(chunk)\n            bar.update(chunks.bytes)\n\nThe ``update()`` method also takes an optional value specifying the\n``current_item`` at the new position. This is useful when used\ntogether with ``item_show_func`` to customize the output for each\nmanual step::\n\n    with click.progressbar(\n        length=total_size,\n        label='Unzipping archive',\n        item_show_func=lambda a: a.filename\n    ) as bar:\n        for archive in zip_file:\n            archive.extract()\n            bar.update(archive.size, archive)\n\n:param iterable: an iterable to iterate over.  If not provided the length\n                 is required.\n:param length: the number of items to iterate over.  By default the\n               progressbar will attempt to ask the iterator about its\n               length, which might or might not work.  If an iterable is\n               also provided this parameter can be used to override the\n               length.  If an iterable is not provided the progress bar\n               will iterate over a range of that length.\n:param label: the label to show next to the progress bar.\n:param hidden: hide the progressbar. Defaults to ``False``. When no tty is\n    detected, it will only print the progressbar label. Setting this to\n    ``False`` also disables that.\n:param show_eta: enables or disables the estimated time display.  This is\n                 automatically disabled if the length cannot be\n                 determined.\n:param show_percent: enables or disables the percentage display.  The\n                     default is `True` if the iterable has a length or\n                     `False` if not.\n:param show_pos: enables or disables the absolute position display.  The\n                 default is `False`.\n:param item_show_func: A function called with the current item which\n    can return a string to show next to the progress bar. If the\n    function returns ``None`` nothing is shown. The current item can\n    be ``None``, such as when entering and exiting the bar.\n:param fill_char: the character to use to show the filled part of the\n                  progress bar.\n:param empty_char: the character to use to show the non-filled part of\n                   the progress bar.\n:param bar_template: the format string to use as template for the bar.\n                     The parameters in it are ``label`` for the label,\n                     ``bar`` for the progress bar and ``info`` for the\n                     info section.\n:param info_sep: the separator between multiple info items (eta etc.)\n:param width: the width of the progress bar in characters, 0 means full\n              terminal width\n:param file: The file to write to. If this is not a terminal then\n    only the label is printed.\n:param color: controls if the terminal supports ANSI colors or not.  The\n              default is autodetection.  This is only needed if ANSI\n              codes are included anywhere in the progress bar output\n              which is not the case by default.\n:param update_min_steps: Render only when this many updates have\n    completed. This allows tuning for very fast iterators.\n\n.. versionadded:: 8.2\n    The ``hidden`` argument.\n\n.. versionchanged:: 8.0\n    Output is shown even if execution time is less than 0.5 seconds.\n\n.. versionchanged:: 8.0\n    ``item_show_func`` shows the current item, not the previous one.\n\n.. versionchanged:: 8.0\n    Labels are echoed if the output is not a TTY. Reverts a change\n    in 7.0 that removed all output.\n\n.. versionadded:: 8.0\n   The ``update_min_steps`` parameter.\n\n.. versionadded:: 4.0\n    The ``color`` parameter and ``update`` method.\n\n.. versionadded:: 2.0",
          "code": "def progressbar(\n    iterable: cabc.Iterable[V] | None = None,\n    length: int | None = None,\n    label: str | None = None,\n    hidden: bool = False,\n    show_eta: bool = True,\n    show_percent: bool | None = None,\n    show_pos: bool = False,\n    item_show_func: t.Callable[[V | None], str | None] | None = None,\n    fill_char: str = \"#\",\n    empty_char: str = \"-\",\n    bar_template: str = \"%(label)s  [%(bar)s]  %(info)s\",\n    info_sep: str = \"  \",\n    width: int = 36,\n    file: t.TextIO | None = None,\n    color: bool | None = None,\n    update_min_steps: int = 1,\n) -> ProgressBar[V]:\n    \"\"\"This function creates an iterable context manager that can be used\n    to iterate over something while showing a progress bar.  It will\n    either iterate over the `iterable` or `length` items (that are counted\n    up).  While iteration happens, this function will print a rendered\n    progress bar to the given `file` (defaults to stdout) and will attempt\n    to calculate remaining time and more.  By default, this progress bar\n    will not be rendered if the file is not a terminal.\n\n    The context manager creates the progress bar.  When the context\n    manager is entered the progress bar is already created.  With every\n    iteration over the progress bar, the iterable passed to the bar is\n    advanced and the bar is updated.  When the context manager exits,\n    a newline is printed and the progress bar is finalized on screen.\n\n    Note: The progress bar is currently designed for use cases where the\n    total progress can be expected to take at least several seconds.\n    Because of this, the ProgressBar class object won't display\n    progress that is considered too fast, and progress where the time\n    between steps is less than a second.\n\n    No printing must happen or the progress bar will be unintentionally\n    destroyed.\n\n    Example usage::\n\n        with progressbar(items) as bar:\n            for item in bar:\n                do_something_with(item)\n\n    Alternatively, if no iterable is specified, one can manually update the\n    progress bar through the `update()` method instead of directly\n    iterating over the progress bar.  The update method accepts the number\n    of steps to increment the bar with::\n\n        with progressbar(length=chunks.total_bytes) as bar:\n            for chunk in chunks:\n                process_chunk(chunk)\n                bar.update(chunks.bytes)\n\n    The ``update()`` method also takes an optional value specifying the\n    ``current_item`` at the new position. This is useful when used\n    together with ``item_show_func`` to customize the output for each\n    manual step::\n\n        with click.progressbar(\n            length=total_size,\n            label='Unzipping archive',\n            item_show_func=lambda a: a.filename\n        ) as bar:\n            for archive in zip_file:\n                archive.extract()\n                bar.update(archive.size, archive)\n\n    :param iterable: an iterable to iterate over.  If not provided the length\n                     is required.\n    :param length: the number of items to iterate over.  By default the\n                   progressbar will attempt to ask the iterator about its\n                   length, which might or might not work.  If an iterable is\n                   also provided this parameter can be used to override the\n                   length.  If an iterable is not provided the progress bar\n                   will iterate over a range of that length.\n    :param label: the label to show next to the progress bar.\n    :param hidden: hide the progressbar. Defaults to ``False``. When no tty is\n        detected, it will only print the progressbar label. Setting this to\n        ``False`` also disables that.\n    :param show_eta: enables or disables the estimated time display.  This is\n                     automatically disabled if the length cannot be\n                     determined.\n    :param show_percent: enables or disables the percentage display.  The\n                         default is `True` if the iterable has a length or\n                         `False` if not.\n    :param show_pos: enables or disables the absolute position display.  The\n                     default is `False`.\n    :param item_show_func: A function called with the current item which\n        can return a string to show next to the progress bar. If the\n        function returns ``None`` nothing is shown. The current item can\n        be ``None``, such as when entering and exiting the bar.\n    :param fill_char: the character to use to show the filled part of the\n                      progress bar.\n    :param empty_char: the character to use to show the non-filled part of\n                       the progress bar.\n    :param bar_template: the format string to use as template for the bar.\n                         The parameters in it are ``label`` for the label,\n                         ``bar`` for the progress bar and ``info`` for the\n                         info section.\n    :param info_sep: the separator between multiple info items (eta etc.)\n    :param width: the width of the progress bar in characters, 0 means full\n                  terminal width\n    :param file: The file to write to. If this is not a terminal then\n        only the label is printed.\n    :param color: controls if the terminal supports ANSI colors or not.  The\n                  default is autodetection.  This is only needed if ANSI\n                  codes are included anywhere in the progress bar output\n                  which is not the case by default.\n    :param update_min_steps: Render only when this many updates have\n        completed. This allows tuning for very fast iterators.\n\n    .. versionadded:: 8.2\n        The ``hidden`` argument.\n\n    .. versionchanged:: 8.0\n        Output is shown even if execution time is less than 0.5 seconds.\n\n    .. versionchanged:: 8.0\n        ``item_show_func`` shows the current item, not the previous one.\n\n    .. versionchanged:: 8.0\n        Labels are echoed if the output is not a TTY. Reverts a change\n        in 7.0 that removed all output.\n\n    .. versionadded:: 8.0\n       The ``update_min_steps`` parameter.\n\n    .. versionadded:: 4.0\n        The ``color`` parameter and ``update`` method.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    from ._termui_impl import ProgressBar\n\n    color = resolve_color_default(color)\n    return ProgressBar(\n        iterable=iterable,\n        length=length,\n        hidden=hidden,\n        show_eta=show_eta,\n        show_percent=show_percent,\n        show_pos=show_pos,\n        item_show_func=item_show_func,\n        fill_char=fill_char,\n        empty_char=empty_char,\n        bar_template=bar_template,\n        info_sep=info_sep,\n        file=file,\n        label=label,\n        width=width,\n        color=color,\n        update_min_steps=update_min_steps,\n    )",
          "line_count": 157,
          "needs_llm_summary": true
        },
        {
          "name": "clear",
          "args": [],
          "return_type": "None",
          "lineno": 493,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "isatty",
            "sys.stdout"
          ],
          "docstring": "Clears the terminal screen.  This will have the effect of clearing\nthe whole visible space of the terminal and moving the cursor to the\ntop left.  This does not do anything if not connected to a terminal.\n\n.. versionadded:: 2.0",
          "code": "def clear() -> None:\n    \"\"\"Clears the terminal screen.  This will have the effect of clearing\n    the whole visible space of the terminal and moving the cursor to the\n    top left.  This does not do anything if not connected to a terminal.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    if not isatty(sys.stdout):\n        return\n\n    # ANSI escape \\033[2J clears the screen, \\033[1;1H moves the cursor\n    echo(\"\\033[2J\\033[1;1H\", nl=False)",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "_interpret_color",
          "args": [
            {
              "name": "color",
              "type": "Any"
            },
            {
              "name": "offset",
              "type": "int"
            }
          ],
          "return_type": "str",
          "lineno": 507,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "isinstance",
            "int",
            "color"
          ],
          "docstring": null,
          "code": "def _interpret_color(color: int | tuple[int, int, int] | str, offset: int = 0) -> str:\n    if isinstance(color, int):\n        return f\"{38 + offset};5;{color:d}\"\n\n    if isinstance(color, (tuple, list)):\n        r, g, b = color\n        return f\"{38 + offset};2;{r:d};{g:d};{b:d}\"\n\n    return str(_ansi_colors[color] + offset)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "style",
          "args": [
            {
              "name": "text",
              "type": "t.Any"
            },
            {
              "name": "fg",
              "type": "Any"
            },
            {
              "name": "bg",
              "type": "Any"
            },
            {
              "name": "bold",
              "type": "Any"
            },
            {
              "name": "dim",
              "type": "Any"
            },
            {
              "name": "underline",
              "type": "Any"
            },
            {
              "name": "overline",
              "type": "Any"
            },
            {
              "name": "italic",
              "type": "Any"
            },
            {
              "name": "blink",
              "type": "Any"
            },
            {
              "name": "reverse",
              "type": "Any"
            },
            {
              "name": "strikethrough",
              "type": "Any"
            },
            {
              "name": "reset",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "lineno": 518,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text",
            "unknown.join",
            "_interpret_color",
            "str",
            "_ansi_reset_all",
            "bg",
            "fg",
            "bits.append",
            "bits",
            "isinstance",
            "TypeError"
          ],
          "docstring": "Styles a text with ANSI styles and returns the new string.  By\ndefault the styling is self contained which means that at the end\nof the string a reset code is issued.  This can be prevented by\npassing ``reset=False``.\n\nExamples::\n\n    click.echo(click.style('Hello World!', fg='green'))\n    click.echo(click.style('ATTENTION!', blink=True))\n    click.echo(click.style('Some things', reverse=True, fg='cyan'))\n    click.echo(click.style('More colors', fg=(255, 12, 128), bg=117))\n\nSupported color names:\n\n* ``black`` (might be a gray)\n* ``red``\n* ``green``\n* ``yellow`` (might be an orange)\n* ``blue``\n* ``magenta``\n* ``cyan``\n* ``white`` (might be light gray)\n* ``bright_black``\n* ``bright_red``\n* ``bright_green``\n* ``bright_yellow``\n* ``bright_blue``\n* ``bright_magenta``\n* ``bright_cyan``\n* ``bright_white``\n* ``reset`` (reset the color code only)\n\nIf the terminal supports it, color may also be specified as:\n\n-   An integer in the interval [0, 255]. The terminal must support\n    8-bit/256-color mode.\n-   An RGB tuple of three integers in [0, 255]. The terminal must\n    support 24-bit/true-color mode.\n\nSee https://en.wikipedia.org/wiki/ANSI_color and\nhttps://gist.github.com/XVilka/8346728 for more information.\n\n:param text: the string to style with ansi codes.\n:param fg: if provided this will become the foreground color.\n:param bg: if provided this will become the background color.\n:param bold: if provided this will enable or disable bold mode.\n:param dim: if provided this will enable or disable dim mode.  This is\n            badly supported.\n:param underline: if provided this will enable or disable underline.\n:param overline: if provided this will enable or disable overline.\n:param italic: if provided this will enable or disable italic.\n:param blink: if provided this will enable or disable blinking.\n:param reverse: if provided this will enable or disable inverse\n                rendering (foreground becomes background and the\n                other way round).\n:param strikethrough: if provided this will enable or disable\n    striking through text.\n:param reset: by default a reset-all code is added at the end of the\n              string which means that styles do not carry over.  This\n              can be disabled to compose styles.\n\n.. versionchanged:: 8.0\n    A non-string ``message`` is converted to a string.\n\n.. versionchanged:: 8.0\n   Added support for 256 and RGB color codes.\n\n.. versionchanged:: 8.0\n    Added the ``strikethrough``, ``italic``, and ``overline``\n    parameters.\n\n.. versionchanged:: 7.0\n    Added support for bright colors.\n\n.. versionadded:: 2.0",
          "code": "def style(\n    text: t.Any,\n    fg: int | tuple[int, int, int] | str | None = None,\n    bg: int | tuple[int, int, int] | str | None = None,\n    bold: bool | None = None,\n    dim: bool | None = None,\n    underline: bool | None = None,\n    overline: bool | None = None,\n    italic: bool | None = None,\n    blink: bool | None = None,\n    reverse: bool | None = None,\n    strikethrough: bool | None = None,\n    reset: bool = True,\n) -> str:\n    \"\"\"Styles a text with ANSI styles and returns the new string.  By\n    default the styling is self contained which means that at the end\n    of the string a reset code is issued.  This can be prevented by\n    passing ``reset=False``.\n\n    Examples::\n\n        click.echo(click.style('Hello World!', fg='green'))\n        click.echo(click.style('ATTENTION!', blink=True))\n        click.echo(click.style('Some things', reverse=True, fg='cyan'))\n        click.echo(click.style('More colors', fg=(255, 12, 128), bg=117))\n\n    Supported color names:\n\n    * ``black`` (might be a gray)\n    * ``red``\n    * ``green``\n    * ``yellow`` (might be an orange)\n    * ``blue``\n    * ``magenta``\n    * ``cyan``\n    * ``white`` (might be light gray)\n    * ``bright_black``\n    * ``bright_red``\n    * ``bright_green``\n    * ``bright_yellow``\n    * ``bright_blue``\n    * ``bright_magenta``\n    * ``bright_cyan``\n    * ``bright_white``\n    * ``reset`` (reset the color code only)\n\n    If the terminal supports it, color may also be specified as:\n\n    -   An integer in the interval [0, 255]. The terminal must support\n        8-bit/256-color mode.\n    -   An RGB tuple of three integers in [0, 255]. The terminal must\n        support 24-bit/true-color mode.\n\n    See https://en.wikipedia.org/wiki/ANSI_color and\n    https://gist.github.com/XVilka/8346728 for more information.\n\n    :param text: the string to style with ansi codes.\n    :param fg: if provided this will become the foreground color.\n    :param bg: if provided this will become the background color.\n    :param bold: if provided this will enable or disable bold mode.\n    :param dim: if provided this will enable or disable dim mode.  This is\n                badly supported.\n    :param underline: if provided this will enable or disable underline.\n    :param overline: if provided this will enable or disable overline.\n    :param italic: if provided this will enable or disable italic.\n    :param blink: if provided this will enable or disable blinking.\n    :param reverse: if provided this will enable or disable inverse\n                    rendering (foreground becomes background and the\n                    other way round).\n    :param strikethrough: if provided this will enable or disable\n        striking through text.\n    :param reset: by default a reset-all code is added at the end of the\n                  string which means that styles do not carry over.  This\n                  can be disabled to compose styles.\n\n    .. versionchanged:: 8.0\n        A non-string ``message`` is converted to a string.\n\n    .. versionchanged:: 8.0\n       Added support for 256 and RGB color codes.\n\n    .. versionchanged:: 8.0\n        Added the ``strikethrough``, ``italic``, and ``overline``\n        parameters.\n\n    .. versionchanged:: 7.0\n        Added support for bright colors.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    if not isinstance(text, str):\n        text = str(text)\n\n    bits = []\n\n    if fg:\n        try:\n            bits.append(f\"\\033[{_interpret_color(fg)}m\")\n        except KeyError:\n            raise TypeError(f\"Unknown color {fg!r}\") from None\n\n    if bg:\n        try:\n            bits.append(f\"\\033[{_interpret_color(bg, 10)}m\")\n        except KeyError:\n            raise TypeError(f\"Unknown color {bg!r}\") from None\n\n    if bold is not None:\n        bits.append(f\"\\033[{1 if bold else 22}m\")\n    if dim is not None:\n        bits.append(f\"\\033[{2 if dim else 22}m\")\n    if underline is not None:\n        bits.append(f\"\\033[{4 if underline else 24}m\")\n    if overline is not None:\n        bits.append(f\"\\033[{53 if overline else 55}m\")\n    if italic is not None:\n        bits.append(f\"\\033[{3 if italic else 23}m\")\n    if blink is not None:\n        bits.append(f\"\\033[{5 if blink else 25}m\")\n    if reverse is not None:\n        bits.append(f\"\\033[{7 if reverse else 27}m\")\n    if strikethrough is not None:\n        bits.append(f\"\\033[{9 if strikethrough else 29}m\")\n    bits.append(text)\n    if reset:\n        bits.append(_ansi_reset_all)\n    return \"\".join(bits)",
          "line_count": 127,
          "needs_llm_summary": true
        },
        {
          "name": "unstyle",
          "args": [
            {
              "name": "text",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 647,
          "decorators": [],
          "is_async": false,
          "calls": [
            "strip_ansi",
            "text"
          ],
          "docstring": "Removes ANSI styling information from a string.  Usually it's not\nnecessary to use this function as Click's echo function will\nautomatically remove styling if necessary.\n\n.. versionadded:: 2.0\n\n:param text: the text to remove style information from.",
          "code": "def unstyle(text: str) -> str:\n    \"\"\"Removes ANSI styling information from a string.  Usually it's not\n    necessary to use this function as Click's echo function will\n    automatically remove styling if necessary.\n\n    .. versionadded:: 2.0\n\n    :param text: the text to remove style information from.\n    \"\"\"\n    return strip_ansi(text)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "secho",
          "args": [
            {
              "name": "message",
              "type": "Any"
            },
            {
              "name": "file",
              "type": "Any"
            },
            {
              "name": "nl",
              "type": "bool"
            },
            {
              "name": "err",
              "type": "bool"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 659,
          "decorators": [],
          "is_async": false,
          "calls": [
            "nl",
            "echo",
            "message",
            "file",
            "err",
            "isinstance",
            "color",
            "style",
            "styles"
          ],
          "docstring": "This function combines :func:`echo` and :func:`style` into one\ncall.  As such the following two calls are the same::\n\n    click.secho('Hello World!', fg='green')\n    click.echo(click.style('Hello World!', fg='green'))\n\nAll keyword arguments are forwarded to the underlying functions\ndepending on which one they go with.\n\nNon-string types will be converted to :class:`str`. However,\n:class:`bytes` are passed directly to :meth:`echo` without applying\nstyle. If you want to style bytes that represent text, call\n:meth:`bytes.decode` first.\n\n.. versionchanged:: 8.0\n    A non-string ``message`` is converted to a string. Bytes are\n    passed through without style applied.\n\n.. versionadded:: 2.0",
          "code": "def secho(\n    message: t.Any | None = None,\n    file: t.IO[t.AnyStr] | None = None,\n    nl: bool = True,\n    err: bool = False,\n    color: bool | None = None,\n    **styles: t.Any,\n) -> None:\n    \"\"\"This function combines :func:`echo` and :func:`style` into one\n    call.  As such the following two calls are the same::\n\n        click.secho('Hello World!', fg='green')\n        click.echo(click.style('Hello World!', fg='green'))\n\n    All keyword arguments are forwarded to the underlying functions\n    depending on which one they go with.\n\n    Non-string types will be converted to :class:`str`. However,\n    :class:`bytes` are passed directly to :meth:`echo` without applying\n    style. If you want to style bytes that represent text, call\n    :meth:`bytes.decode` first.\n\n    .. versionchanged:: 8.0\n        A non-string ``message`` is converted to a string. Bytes are\n        passed through without style applied.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    if message is not None and not isinstance(message, (bytes, bytearray)):\n        message = style(message, **styles)\n\n    return echo(message, file=file, nl=nl, err=err, color=color)",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "edit",
          "args": [
            {
              "name": "text",
              "type": "Any"
            },
            {
              "name": "editor",
              "type": "Any"
            },
            {
              "name": "env",
              "type": "Any"
            },
            {
              "name": "require_save",
              "type": "bool"
            },
            {
              "name": "extension",
              "type": "str"
            }
          ],
          "return_type": "Any",
          "lineno": 694,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def edit(\n    text: bytes | bytearray,\n    editor: str | None = None,\n    env: cabc.Mapping[str, str] | None = None,\n    require_save: bool = False,\n    extension: str = \".txt\",\n) -> bytes | None: ...",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "edit",
          "args": [
            {
              "name": "text",
              "type": "str"
            },
            {
              "name": "editor",
              "type": "Any"
            },
            {
              "name": "env",
              "type": "Any"
            },
            {
              "name": "require_save",
              "type": "bool"
            },
            {
              "name": "extension",
              "type": "str"
            }
          ],
          "return_type": "Any",
          "lineno": 704,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def edit(\n    text: str,\n    editor: str | None = None,\n    env: cabc.Mapping[str, str] | None = None,\n    require_save: bool = True,\n    extension: str = \".txt\",\n) -> str | None: ...",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "edit",
          "args": [
            {
              "name": "text",
              "type": "None"
            },
            {
              "name": "editor",
              "type": "Any"
            },
            {
              "name": "env",
              "type": "Any"
            },
            {
              "name": "require_save",
              "type": "bool"
            },
            {
              "name": "extension",
              "type": "str"
            },
            {
              "name": "filename",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 714,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def edit(\n    text: None = None,\n    editor: str | None = None,\n    env: cabc.Mapping[str, str] | None = None,\n    require_save: bool = True,\n    extension: str = \".txt\",\n    filename: str | cabc.Iterable[str] | None = None,\n) -> None: ...",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "edit",
          "args": [
            {
              "name": "text",
              "type": "Any"
            },
            {
              "name": "editor",
              "type": "Any"
            },
            {
              "name": "env",
              "type": "Any"
            },
            {
              "name": "require_save",
              "type": "bool"
            },
            {
              "name": "extension",
              "type": "str"
            },
            {
              "name": "filename",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 724,
          "decorators": [],
          "is_async": false,
          "calls": [
            "require_save",
            "filename",
            "text",
            "str",
            "ed.edit",
            "ed.edit_files",
            "extension",
            "editor",
            "isinstance",
            "Editor",
            "env"
          ],
          "docstring": "Edits the given text in the defined editor.  If an editor is given\n(should be the full path to the executable but the regular operating\nsystem search path is used for finding the executable) it overrides\nthe detected editor.  Optionally, some environment variables can be\nused.  If the editor is closed without changes, `None` is returned.  In\ncase a file is edited directly the return value is always `None` and\n`require_save` and `extension` are ignored.\n\nIf the editor cannot be opened a :exc:`UsageError` is raised.\n\nNote for Windows: to simplify cross-platform usage, the newlines are\nautomatically converted from POSIX to Windows and vice versa.  As such,\nthe message here will have ``\\n`` as newline markers.\n\n:param text: the text to edit.\n:param editor: optionally the editor to use.  Defaults to automatic\n               detection.\n:param env: environment variables to forward to the editor.\n:param require_save: if this is true, then not saving in the editor\n                     will make the return value become `None`.\n:param extension: the extension to tell the editor about.  This defaults\n                  to `.txt` but changing this might change syntax\n                  highlighting.\n:param filename: if provided it will edit this file instead of the\n                 provided text contents.  It will not use a temporary\n                 file as an indirection in that case. If the editor supports\n                 editing multiple files at once, a sequence of files may be\n                 passed as well. Invoke `click.file` once per file instead\n                 if multiple files cannot be managed at once or editing the\n                 files serially is desired.\n\n.. versionchanged:: 8.2.0\n    ``filename`` now accepts any ``Iterable[str]`` in addition to a ``str``\n    if the ``editor`` supports editing multiple files at once.",
          "code": "def edit(\n    text: str | bytes | bytearray | None = None,\n    editor: str | None = None,\n    env: cabc.Mapping[str, str] | None = None,\n    require_save: bool = True,\n    extension: str = \".txt\",\n    filename: str | cabc.Iterable[str] | None = None,\n) -> str | bytes | bytearray | None:\n    r\"\"\"Edits the given text in the defined editor.  If an editor is given\n    (should be the full path to the executable but the regular operating\n    system search path is used for finding the executable) it overrides\n    the detected editor.  Optionally, some environment variables can be\n    used.  If the editor is closed without changes, `None` is returned.  In\n    case a file is edited directly the return value is always `None` and\n    `require_save` and `extension` are ignored.\n\n    If the editor cannot be opened a :exc:`UsageError` is raised.\n\n    Note for Windows: to simplify cross-platform usage, the newlines are\n    automatically converted from POSIX to Windows and vice versa.  As such,\n    the message here will have ``\\n`` as newline markers.\n\n    :param text: the text to edit.\n    :param editor: optionally the editor to use.  Defaults to automatic\n                   detection.\n    :param env: environment variables to forward to the editor.\n    :param require_save: if this is true, then not saving in the editor\n                         will make the return value become `None`.\n    :param extension: the extension to tell the editor about.  This defaults\n                      to `.txt` but changing this might change syntax\n                      highlighting.\n    :param filename: if provided it will edit this file instead of the\n                     provided text contents.  It will not use a temporary\n                     file as an indirection in that case. If the editor supports\n                     editing multiple files at once, a sequence of files may be\n                     passed as well. Invoke `click.file` once per file instead\n                     if multiple files cannot be managed at once or editing the\n                     files serially is desired.\n\n    .. versionchanged:: 8.2.0\n        ``filename`` now accepts any ``Iterable[str]`` in addition to a ``str``\n        if the ``editor`` supports editing multiple files at once.\n\n    \"\"\"\n    from ._termui_impl import Editor\n\n    ed = Editor(editor=editor, env=env, require_save=require_save, extension=extension)\n\n    if filename is None:\n        return ed.edit(text)\n\n    if isinstance(filename, str):\n        filename = (filename,)\n\n    ed.edit_files(filenames=filename)\n    return None",
          "line_count": 56,
          "needs_llm_summary": true
        },
        {
          "name": "launch",
          "args": [
            {
              "name": "url",
              "type": "str"
            },
            {
              "name": "wait",
              "type": "bool"
            },
            {
              "name": "locate",
              "type": "bool"
            }
          ],
          "return_type": "int",
          "lineno": 782,
          "decorators": [],
          "is_async": false,
          "calls": [
            "url",
            "open_url",
            "wait",
            "locate"
          ],
          "docstring": "This function launches the given URL (or filename) in the default\nviewer application for this file type.  If this is an executable, it\nmight launch the executable in a new session.  The return value is\nthe exit code of the launched application.  Usually, ``0`` indicates\nsuccess.\n\nExamples::\n\n    click.launch('https://click.palletsprojects.com/')\n    click.launch('/my/downloaded/file', locate=True)\n\n.. versionadded:: 2.0\n\n:param url: URL or filename of the thing to launch.\n:param wait: Wait for the program to exit before returning. This\n    only works if the launched program blocks. In particular,\n    ``xdg-open`` on Linux does not block.\n:param locate: if this is set to `True` then instead of launching the\n               application associated with the URL it will attempt to\n               launch a file manager with the file located.  This\n               might have weird effects if the URL does not point to\n               the filesystem.",
          "code": "def launch(url: str, wait: bool = False, locate: bool = False) -> int:\n    \"\"\"This function launches the given URL (or filename) in the default\n    viewer application for this file type.  If this is an executable, it\n    might launch the executable in a new session.  The return value is\n    the exit code of the launched application.  Usually, ``0`` indicates\n    success.\n\n    Examples::\n\n        click.launch('https://click.palletsprojects.com/')\n        click.launch('/my/downloaded/file', locate=True)\n\n    .. versionadded:: 2.0\n\n    :param url: URL or filename of the thing to launch.\n    :param wait: Wait for the program to exit before returning. This\n        only works if the launched program blocks. In particular,\n        ``xdg-open`` on Linux does not block.\n    :param locate: if this is set to `True` then instead of launching the\n                   application associated with the URL it will attempt to\n                   launch a file manager with the file located.  This\n                   might have weird effects if the URL does not point to\n                   the filesystem.\n    \"\"\"\n    from ._termui_impl import open_url\n\n    return open_url(url, wait=wait, locate=locate)",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "getchar",
          "args": [
            {
              "name": "echo",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "lineno": 816,
          "decorators": [],
          "is_async": false,
          "calls": [
            "echo",
            "f",
            "_getchar"
          ],
          "docstring": "Fetches a single character from the terminal and returns it.  This\nwill always return a unicode character and under certain rare\ncircumstances this might return more than one character.  The\nsituations which more than one character is returned is when for\nwhatever reason multiple characters end up in the terminal buffer or\nstandard input was not actually a terminal.\n\nNote that this will always read from the terminal, even if something\nis piped into the standard input.\n\nNote for Windows: in rare cases when typing non-ASCII characters, this\nfunction might wait for a second character and then return both at once.\nThis is because certain Unicode characters look like special-key markers.\n\n.. versionadded:: 2.0\n\n:param echo: if set to `True`, the character read will also show up on\n             the terminal.  The default is to not show it.",
          "code": "def getchar(echo: bool = False) -> str:\n    \"\"\"Fetches a single character from the terminal and returns it.  This\n    will always return a unicode character and under certain rare\n    circumstances this might return more than one character.  The\n    situations which more than one character is returned is when for\n    whatever reason multiple characters end up in the terminal buffer or\n    standard input was not actually a terminal.\n\n    Note that this will always read from the terminal, even if something\n    is piped into the standard input.\n\n    Note for Windows: in rare cases when typing non-ASCII characters, this\n    function might wait for a second character and then return both at once.\n    This is because certain Unicode characters look like special-key markers.\n\n    .. versionadded:: 2.0\n\n    :param echo: if set to `True`, the character read will also show up on\n                 the terminal.  The default is to not show it.\n    \"\"\"\n    global _getchar\n\n    if _getchar is None:\n        from ._termui_impl import getchar as f\n\n        _getchar = f\n\n    return _getchar(echo)",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "raw_terminal",
          "args": [],
          "return_type": "AbstractContextManager[int]",
          "lineno": 846,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f"
          ],
          "docstring": null,
          "code": "def raw_terminal() -> AbstractContextManager[int]:\n    from ._termui_impl import raw_terminal as f\n\n    return f()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "pause",
          "args": [
            {
              "name": "info",
              "type": "Any"
            },
            {
              "name": "err",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 852,
          "decorators": [],
          "is_async": false,
          "calls": [
            "getchar",
            "echo",
            "sys.stdout",
            "isatty",
            "_",
            "err",
            "info",
            "sys.stdin"
          ],
          "docstring": "This command stops execution and waits for the user to press any\nkey to continue.  This is similar to the Windows batch \"pause\"\ncommand.  If the program is not run through a terminal, this command\nwill instead do nothing.\n\n.. versionadded:: 2.0\n\n.. versionadded:: 4.0\n   Added the `err` parameter.\n\n:param info: The message to print before pausing. Defaults to\n    ``\"Press any key to continue...\"``.\n:param err: if set to message goes to ``stderr`` instead of\n            ``stdout``, the same as with echo.",
          "code": "def pause(info: str | None = None, err: bool = False) -> None:\n    \"\"\"This command stops execution and waits for the user to press any\n    key to continue.  This is similar to the Windows batch \"pause\"\n    command.  If the program is not run through a terminal, this command\n    will instead do nothing.\n\n    .. versionadded:: 2.0\n\n    .. versionadded:: 4.0\n       Added the `err` parameter.\n\n    :param info: The message to print before pausing. Defaults to\n        ``\"Press any key to continue...\"``.\n    :param err: if set to message goes to ``stderr`` instead of\n                ``stdout``, the same as with echo.\n    \"\"\"\n    if not isatty(sys.stdin) or not isatty(sys.stdout):\n        return\n\n    if info is None:\n        info = _(\"Press any key to continue...\")\n\n    try:\n        if info:\n            echo(info, nl=False, err=err)\n        try:\n            getchar()\n        except (KeyboardInterrupt, EOFError):\n            pass\n    finally:\n        if info:\n            echo(err=err)",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "prompt_func",
          "args": [
            {
              "name": "text",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 139,
          "decorators": [],
          "is_async": false,
          "calls": [
            "err",
            "echo",
            "Abort",
            "f"
          ],
          "docstring": null,
          "code": "def prompt_func(text: str) -> str:\n        f = hidden_prompt_func if hide_input else visible_prompt_func\n        try:\n            # Write the prompt separately so that we get nice\n            # coloring through colorama on Windows\n            echo(text[:-1], nl=False, err=err)\n            # Echo the last character to stdout to work around an issue where\n            # readline causes backspace to clear the whole line.\n            return f(text[-1:])\n        except (KeyboardInterrupt, EOFError):\n            # getpass doesn't print a newline if the user aborts input with ^C.\n            # Allegedly this behavior is inherited from getpass(3).\n            # A doc bug has been filed at https://bugs.python.org/issue24711\n            if hide_input:\n                echo(None, err=err)\n            raise Abort() from None",
          "line_count": 16,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "inspect",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "io",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "itertools",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "contextlib",
          "name": "AbstractContextManager",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "isatty",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "strip_ansi",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "Abort",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "UsageError",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "resolve_color_default",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "Choice",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "convert_type",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "ParamType",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "echo",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "LazyFile",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "_termui_impl",
          "name": "ProgressBar",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "getpass",
          "alias": null,
          "lineno": 55,
          "type": "import"
        },
        {
          "module": "_termui_impl",
          "name": "pager",
          "alias": null,
          "lineno": 288,
          "type": "from_import"
        },
        {
          "module": "_termui_impl",
          "name": "ProgressBar",
          "alias": null,
          "lineno": 470,
          "type": "from_import"
        },
        {
          "module": "_termui_impl",
          "name": "Editor",
          "alias": null,
          "lineno": 768,
          "type": "from_import"
        },
        {
          "module": "_termui_impl",
          "name": "open_url",
          "alias": null,
          "lineno": 806,
          "type": "from_import"
        },
        {
          "module": "_termui_impl",
          "name": "raw_terminal",
          "alias": "f",
          "lineno": 847,
          "type": "from_import"
        },
        {
          "module": "_termui_impl",
          "name": "getchar",
          "alias": "f",
          "lineno": 839,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "V",
          "assigned_to": "t.TypeVar",
          "lineno": 26
        },
        {
          "name": "_ansi_colors",
          "assigned_to": null,
          "lineno": 32
        },
        {
          "name": "_ansi_reset_all",
          "assigned_to": "str",
          "lineno": 51
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "contextlib",
          "sys",
          "typing",
          "collections",
          "itertools",
          "io"
        ],
        "third_party": {
          "other": [
            "__future__",
            "inspect",
            "gettext",
            "_compat",
            "exceptions",
            "globals",
            "types",
            "utils",
            "_termui_impl",
            "getpass"
          ]
        },
        "tech_stack": []
      },
      "line_count": 884
    },
    "src/click/testing.py": {
      "filepath": "../click/src/click/testing.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_pause_echo",
          "args": [
            {
              "name": "stream",
              "type": "Any"
            }
          ],
          "return_type": "cabc.Iterator[None]",
          "lineno": 60,
          "decorators": [
            {
              "name": "contextlib.contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def _pause_echo(stream: EchoingStdin | None) -> cabc.Iterator[None]:\n    if stream is None:\n        yield\n    else:\n        stream._paused = True\n        yield\n        stream._paused = False",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "make_input_stream",
          "args": [
            {
              "name": "input",
              "type": "Any"
            },
            {
              "name": "charset",
              "type": "str"
            }
          ],
          "return_type": "t.BinaryIO",
          "lineno": 131,
          "decorators": [],
          "is_async": false,
          "calls": [
            "charset",
            "str",
            "_find_binary_reader",
            "hasattr",
            "io.BytesIO",
            "t.cast",
            "TypeError",
            "isinstance",
            "input",
            "input.encode"
          ],
          "docstring": null,
          "code": "def make_input_stream(\n    input: str | bytes | t.IO[t.Any] | None, charset: str\n) -> t.BinaryIO:\n    # Is already an input stream.\n    if hasattr(input, \"read\"):\n        rv = _find_binary_reader(t.cast(\"t.IO[t.Any]\", input))\n\n        if rv is not None:\n            return rv\n\n        raise TypeError(\"Could not find binary reader for input stream.\")\n\n    if input is None:\n        input = b\"\"\n    elif isinstance(input, str):\n        input = input.encode(charset)\n\n    return io.BytesIO(input)",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "input",
              "type": "t.BinaryIO"
            },
            {
              "name": "output",
              "type": "t.BinaryIO"
            }
          ],
          "return_type": "None",
          "lineno": 26,
          "decorators": [],
          "is_async": false,
          "calls": [
            "output",
            "input"
          ],
          "docstring": null,
          "code": "def __init__(self, input: t.BinaryIO, output: t.BinaryIO) -> None:\n        self._input = input\n        self._output = output\n        self._paused = False",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "x",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 31,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._input",
            "x",
            "getattr"
          ],
          "docstring": null,
          "code": "def __getattr__(self, x: str) -> t.Any:\n        return getattr(self._input, x)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_echo",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rv",
              "type": "bytes"
            }
          ],
          "return_type": "bytes",
          "lineno": 34,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._output.write",
            "rv"
          ],
          "docstring": null,
          "code": "def _echo(self, rv: bytes) -> bytes:\n        if not self._paused:\n            self._output.write(rv)\n\n        return rv",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "read",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "n",
              "type": "int"
            }
          ],
          "return_type": "bytes",
          "lineno": 40,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._echo",
            "n",
            "self._input.read"
          ],
          "docstring": null,
          "code": "def read(self, n: int = -1) -> bytes:\n        return self._echo(self._input.read(n))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "read1",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "n",
              "type": "int"
            }
          ],
          "return_type": "bytes",
          "lineno": 43,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._echo",
            "n",
            "self._input.read1"
          ],
          "docstring": null,
          "code": "def read1(self, n: int = -1) -> bytes:\n        return self._echo(self._input.read1(n))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "readline",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "n",
              "type": "int"
            }
          ],
          "return_type": "bytes",
          "lineno": 46,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._echo",
            "n",
            "self._input.readline"
          ],
          "docstring": null,
          "code": "def readline(self, n: int = -1) -> bytes:\n        return self._echo(self._input.readline(n))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "readlines",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "list[bytes]",
          "lineno": 49,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._echo",
            "x",
            "self._input.readlines"
          ],
          "docstring": null,
          "code": "def readlines(self) -> list[bytes]:\n        return [self._echo(x) for x in self._input.readlines()]",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__iter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "cabc.Iterator[bytes]",
          "lineno": 52,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._echo",
            "iter",
            "x"
          ],
          "docstring": null,
          "code": "def __iter__(self) -> cabc.Iterator[bytes]:\n        return iter(self._echo(x) for x in self._input)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 55,
          "decorators": [],
          "is_async": false,
          "calls": [
            "repr",
            "self._input"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return repr(self._input)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "copy_to",
              "type": "io.BytesIO"
            }
          ],
          "return_type": "None",
          "lineno": 75,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "super",
            "copy_to"
          ],
          "docstring": null,
          "code": "def __init__(self, copy_to: io.BytesIO) -> None:\n        super().__init__()\n        self.copy_to = copy_to",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "flush",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 79,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "unknown.flush",
            "self.copy_to.flush"
          ],
          "docstring": null,
          "code": "def flush(self) -> None:\n        super().flush()\n        self.copy_to.flush()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "write",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "b",
              "type": "ReadableBuffer"
            }
          ],
          "return_type": "int",
          "lineno": 83,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "b",
            "self.copy_to.write",
            "unknown.write"
          ],
          "docstring": null,
          "code": "def write(self, b: ReadableBuffer) -> int:\n        self.copy_to.write(b)\n        return super().write(b)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 96,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.output",
            "io.BytesIO",
            "BytesIOCopy"
          ],
          "docstring": null,
          "code": "def __init__(self) -> None:\n        self.output: io.BytesIO = io.BytesIO()\n        self.stdout: io.BytesIO = BytesIOCopy(copy_to=self.output)\n        self.stderr: io.BytesIO = BytesIOCopy(copy_to=self.output)",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "__del__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 101,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.output.close",
            "self.stdout.close",
            "self.stderr.close"
          ],
          "docstring": "Guarantee that embedded file-like objects are closed in a\npredictable order, protecting against races between\nself.output being closed and other streams being flushed on close\n\n.. versionadded:: 8.2.2",
          "code": "def __del__(self) -> None:\n        \"\"\"\n        Guarantee that embedded file-like objects are closed in a\n        predictable order, protecting against races between\n        self.output being closed and other streams being flushed on close\n\n        .. versionadded:: 8.2.2\n        \"\"\"\n        self.stderr.close()\n        self.stdout.close()\n        self.output.close()",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "buffer",
              "type": "t.BinaryIO"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "mode",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 115,
          "decorators": [],
          "is_async": false,
          "calls": [
            "mode",
            "unknown.__init__",
            "name",
            "buffer",
            "kwargs",
            "super"
          ],
          "docstring": null,
          "code": "def __init__(\n        self, buffer: t.BinaryIO, name: str, mode: str, **kwargs: t.Any\n    ) -> None:\n        super().__init__(buffer, **kwargs)\n        self._name = name\n        self._mode = mode",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "name",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 123,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def name(self) -> str:\n        return self._name",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "mode",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 127,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def mode(self) -> str:\n        return self._mode",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "runner",
              "type": "CliRunner"
            },
            {
              "name": "stdout_bytes",
              "type": "bytes"
            },
            {
              "name": "stderr_bytes",
              "type": "bytes"
            },
            {
              "name": "output_bytes",
              "type": "bytes"
            },
            {
              "name": "return_value",
              "type": "t.Any"
            },
            {
              "name": "exit_code",
              "type": "int"
            },
            {
              "name": "exception",
              "type": "Any"
            },
            {
              "name": "exc_info",
              "type": "Any"
            }
          ],
          "return_type": null,
          "lineno": 173,
          "decorators": [],
          "is_async": false,
          "calls": [
            "exception",
            "output_bytes",
            "stderr_bytes",
            "exit_code",
            "stdout_bytes",
            "runner",
            "return_value",
            "exc_info"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        runner: CliRunner,\n        stdout_bytes: bytes,\n        stderr_bytes: bytes,\n        output_bytes: bytes,\n        return_value: t.Any,\n        exit_code: int,\n        exception: BaseException | None,\n        exc_info: tuple[type[BaseException], BaseException, TracebackType]\n        | None = None,\n    ):\n        self.runner = runner\n        self.stdout_bytes = stdout_bytes\n        self.stderr_bytes = stderr_bytes\n        self.output_bytes = output_bytes\n        self.return_value = return_value\n        self.exit_code = exit_code\n        self.exception = exception\n        self.exc_info = exc_info",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "output",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 195,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.runner.charset",
            "self.output_bytes.decode",
            "unknown.replace"
          ],
          "docstring": "The terminal output as unicode string, as the user would see it.\n\n.. versionchanged:: 8.2\n    No longer a proxy for ``self.stdout``. Now has its own independent stream\n    that is mixing `<stdout>` and `<stderr>`, in the order they were written.",
          "code": "def output(self) -> str:\n        \"\"\"The terminal output as unicode string, as the user would see it.\n\n        .. versionchanged:: 8.2\n            No longer a proxy for ``self.stdout``. Now has its own independent stream\n            that is mixing `<stdout>` and `<stderr>`, in the order they were written.\n        \"\"\"\n        return self.output_bytes.decode(self.runner.charset, \"replace\").replace(\n            \"\\r\\n\", \"\\n\"\n        )",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "stdout",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 207,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.stdout_bytes.decode",
            "self.runner.charset",
            "unknown.replace"
          ],
          "docstring": "The standard output as unicode string.",
          "code": "def stdout(self) -> str:\n        \"\"\"The standard output as unicode string.\"\"\"\n        return self.stdout_bytes.decode(self.runner.charset, \"replace\").replace(\n            \"\\r\\n\", \"\\n\"\n        )",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "stderr",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 214,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.runner.charset",
            "self.stderr_bytes.decode",
            "unknown.replace"
          ],
          "docstring": "The standard error as unicode string.\n\n.. versionchanged:: 8.2\n    No longer raise an exception, always returns the `<stderr>` string.",
          "code": "def stderr(self) -> str:\n        \"\"\"The standard error as unicode string.\n\n        .. versionchanged:: 8.2\n            No longer raise an exception, always returns the `<stderr>` string.\n        \"\"\"\n        return self.stderr_bytes.decode(self.runner.charset, \"replace\").replace(\n            \"\\r\\n\", \"\\n\"\n        )",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 224,
          "decorators": [],
          "is_async": false,
          "calls": [
            "repr",
            "type",
            "self",
            "self.exception"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        exc_str = repr(self.exception) if self.exception else \"okay\"\n        return f\"<{type(self).__name__} {exc_str}>\"",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "charset",
              "type": "str"
            },
            {
              "name": "env",
              "type": "Any"
            },
            {
              "name": "echo_stdin",
              "type": "bool"
            },
            {
              "name": "catch_exceptions",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 251,
          "decorators": [],
          "is_async": false,
          "calls": [
            "catch_exceptions",
            "echo_stdin",
            "charset"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        charset: str = \"utf-8\",\n        env: cabc.Mapping[str, str | None] | None = None,\n        echo_stdin: bool = False,\n        catch_exceptions: bool = True,\n    ) -> None:\n        self.charset = charset\n        self.env: cabc.Mapping[str, str | None] = env or {}\n        self.echo_stdin = echo_stdin\n        self.catch_exceptions = catch_exceptions",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "get_default_prog_name",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "cli",
              "type": "Command"
            }
          ],
          "return_type": "str",
          "lineno": 263,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Given a command object it will return the default program name\nfor it.  The default is the `name` attribute or ``\"root\"`` if not\nset.",
          "code": "def get_default_prog_name(self, cli: Command) -> str:\n        \"\"\"Given a command object it will return the default program name\n        for it.  The default is the `name` attribute or ``\"root\"`` if not\n        set.\n        \"\"\"\n        return cli.name or \"root\"",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "make_env",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "overrides",
              "type": "Any"
            }
          ],
          "return_type": "cabc.Mapping[str, Any]",
          "lineno": 270,
          "decorators": [],
          "is_async": false,
          "calls": [
            "rv.update",
            "overrides",
            "dict",
            "self.env"
          ],
          "docstring": "Returns the environment overrides for invoking a script.",
          "code": "def make_env(\n        self, overrides: cabc.Mapping[str, str | None] | None = None\n    ) -> cabc.Mapping[str, str | None]:\n        \"\"\"Returns the environment overrides for invoking a script.\"\"\"\n        rv = dict(self.env)\n        if overrides:\n            rv.update(overrides)\n        return rv",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "isolation",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "input",
              "type": "Any"
            },
            {
              "name": "env",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "bool"
            }
          ],
          "return_type": "cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]",
          "lineno": 280,
          "decorators": [
            {
              "name": "contextlib.contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "old_env.items",
            "_NamedTextIOWrapper",
            "old_stderr",
            "_compat.should_strip_ansi",
            "_pause_echo",
            "sys.stdin.read",
            "StreamMixer",
            "old_stdout",
            "sys.stdout.write",
            "old_hidden_prompt_func",
            "sys.stdin",
            "sys.stdout.flush",
            "stream_mixer.stdout",
            "old_visible_prompt_func",
            "echo_input",
            "env.items",
            "bytes_input",
            "self.make_env",
            "should_strip_ansi",
            "termui.visible_prompt_func",
            "input",
            "old_should_strip_ansi",
            "EOFError",
            "old_stdin",
            "_getchar",
            "visible_input",
            "old_forced_width",
            "sys.stderr",
            "key",
            "os.environ.get",
            "next",
            "text_input",
            "utils.should_strip_ansi",
            "old__getchar_func",
            "color",
            "old__compat_should_strip_ansi",
            "termui.hidden_prompt_func",
            "char",
            "t.BinaryIO",
            "formatting.FORCED_WIDTH",
            "self.charset",
            "termui._getchar",
            "sys.stdout",
            "value",
            "stream_mixer.stderr",
            "t.cast",
            "EchoingStdin",
            "hidden_input",
            "env",
            "make_input_stream",
            "unknown.rstrip"
          ],
          "docstring": "A context manager that sets up the isolation for invoking of a\ncommand line tool.  This sets up `<stdin>` with the given input data\nand `os.environ` with the overrides from the given dictionary.\nThis also rebinds some internals in Click to be mocked (like the\nprompt functionality).\n\nThis is automatically done in the :meth:`invoke` method.\n\n:param input: the input stream to put into `sys.stdin`.\n:param env: the environment overrides as dictionary.\n:param color: whether the output should contain color codes. The\n              application can still override this explicitly.\n\n.. versionadded:: 8.2\n    An additional output stream is returned, which is a mix of\n    `<stdout>` and `<stderr>` streams.\n\n.. versionchanged:: 8.2\n    Always returns the `<stderr>` stream.\n\n.. versionchanged:: 8.0\n    `<stderr>` is opened with ``errors=\"backslashreplace\"``\n    instead of the default ``\"strict\"``.\n\n.. versionchanged:: 4.0\n    Added the ``color`` parameter.",
          "code": "def isolation(\n        self,\n        input: str | bytes | t.IO[t.Any] | None = None,\n        env: cabc.Mapping[str, str | None] | None = None,\n        color: bool = False,\n    ) -> cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]:\n        \"\"\"A context manager that sets up the isolation for invoking of a\n        command line tool.  This sets up `<stdin>` with the given input data\n        and `os.environ` with the overrides from the given dictionary.\n        This also rebinds some internals in Click to be mocked (like the\n        prompt functionality).\n\n        This is automatically done in the :meth:`invoke` method.\n\n        :param input: the input stream to put into `sys.stdin`.\n        :param env: the environment overrides as dictionary.\n        :param color: whether the output should contain color codes. The\n                      application can still override this explicitly.\n\n        .. versionadded:: 8.2\n            An additional output stream is returned, which is a mix of\n            `<stdout>` and `<stderr>` streams.\n\n        .. versionchanged:: 8.2\n            Always returns the `<stderr>` stream.\n\n        .. versionchanged:: 8.0\n            `<stderr>` is opened with ``errors=\"backslashreplace\"``\n            instead of the default ``\"strict\"``.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` parameter.\n        \"\"\"\n        bytes_input = make_input_stream(input, self.charset)\n        echo_input = None\n\n        old_stdin = sys.stdin\n        old_stdout = sys.stdout\n        old_stderr = sys.stderr\n        old_forced_width = formatting.FORCED_WIDTH\n        formatting.FORCED_WIDTH = 80\n\n        env = self.make_env(env)\n\n        stream_mixer = StreamMixer()\n\n        if self.echo_stdin:\n            bytes_input = echo_input = t.cast(\n                t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n            )\n\n        sys.stdin = text_input = _NamedTextIOWrapper(\n            bytes_input, encoding=self.charset, name=\"<stdin>\", mode=\"r\"\n        )\n\n        if self.echo_stdin:\n            # Force unbuffered reads, otherwise TextIOWrapper reads a\n            # large chunk which is echoed early.\n            text_input._CHUNK_SIZE = 1  # type: ignore\n\n        sys.stdout = _NamedTextIOWrapper(\n            stream_mixer.stdout, encoding=self.charset, name=\"<stdout>\", mode=\"w\"\n        )\n\n        sys.stderr = _NamedTextIOWrapper(\n            stream_mixer.stderr,\n            encoding=self.charset,\n            name=\"<stderr>\",\n            mode=\"w\",\n            errors=\"backslashreplace\",\n        )\n\n        @_pause_echo(echo_input)  # type: ignore\n        def visible_input(prompt: str | None = None) -> str:\n            sys.stdout.write(prompt or \"\")\n            try:\n                val = next(text_input).rstrip(\"\\r\\n\")\n            except StopIteration as e:\n                raise EOFError() from e\n            sys.stdout.write(f\"{val}\\n\")\n            sys.stdout.flush()\n            return val\n\n        @_pause_echo(echo_input)  # type: ignore\n        def hidden_input(prompt: str | None = None) -> str:\n            sys.stdout.write(f\"{prompt or ''}\\n\")\n            sys.stdout.flush()\n            try:\n                return next(text_input).rstrip(\"\\r\\n\")\n            except StopIteration as e:\n                raise EOFError() from e\n\n        @_pause_echo(echo_input)  # type: ignore\n        def _getchar(echo: bool) -> str:\n            char = sys.stdin.read(1)\n\n            if echo:\n                sys.stdout.write(char)\n\n            sys.stdout.flush()\n            return char\n\n        default_color = color\n\n        def should_strip_ansi(\n            stream: t.IO[t.Any] | None = None, color: bool | None = None\n        ) -> bool:\n            if color is None:\n                return not default_color\n            return not color\n\n        old_visible_prompt_func = termui.visible_prompt_func\n        old_hidden_prompt_func = termui.hidden_prompt_func\n        old__getchar_func = termui._getchar\n        old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n        old__compat_should_strip_ansi = _compat.should_strip_ansi\n        termui.visible_prompt_func = visible_input\n        termui.hidden_prompt_func = hidden_input\n        termui._getchar = _getchar\n        utils.should_strip_ansi = should_strip_ansi  # type: ignore\n        _compat.should_strip_ansi = should_strip_ansi\n\n        old_env = {}\n        try:\n            for key, value in env.items():\n                old_env[key] = os.environ.get(key)\n                if value is None:\n                    try:\n                        del os.environ[key]\n                    except Exception:\n                        pass\n                else:\n                    os.environ[key] = value\n            yield (stream_mixer.stdout, stream_mixer.stderr, stream_mixer.output)\n        finally:\n            for key, value in old_env.items():\n                if value is None:\n                    try:\n                        del os.environ[key]\n                    except Exception:\n                        pass\n                else:\n                    os.environ[key] = value\n            sys.stdout = old_stdout\n            sys.stderr = old_stderr\n            sys.stdin = old_stdin\n            termui.visible_prompt_func = old_visible_prompt_func\n            termui.hidden_prompt_func = old_hidden_prompt_func\n            termui._getchar = old__getchar_func\n            utils.should_strip_ansi = old_should_strip_ansi  # type: ignore\n            _compat.should_strip_ansi = old__compat_should_strip_ansi\n            formatting.FORCED_WIDTH = old_forced_width",
          "line_count": 152,
          "needs_llm_summary": true
        },
        {
          "name": "invoke",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "cli",
              "type": "Command"
            },
            {
              "name": "args",
              "type": "Any"
            },
            {
              "name": "input",
              "type": "Any"
            },
            {
              "name": "env",
              "type": "Any"
            },
            {
              "name": "catch_exceptions",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "bool"
            }
          ],
          "return_type": "Result",
          "lineno": 433,
          "decorators": [],
          "is_async": false,
          "calls": [
            "int",
            "sys.exc_info",
            "Result",
            "cli",
            "isinstance",
            "sys.stdout.write",
            "extra",
            "sys.stdout.flush",
            "stderr",
            "exception",
            "sys.stderr.flush",
            "self",
            "e_code",
            "extra.pop",
            "input",
            "exit_code",
            "return_value",
            "exc_info",
            "e",
            "str",
            "stdout",
            "output",
            "cli.main",
            "args",
            "color",
            "unknown.getvalue",
            "self.isolation",
            "shlex.split",
            "t.cast",
            "prog_name",
            "e.code",
            "env",
            "self.catch_exceptions",
            "self.get_default_prog_name"
          ],
          "docstring": "Invokes a command in an isolated environment.  The arguments are\nforwarded directly to the command line script, the `extra` keyword\narguments are passed to the :meth:`~clickpkg.Command.main` function of\nthe command.\n\nThis returns a :class:`Result` object.\n\n:param cli: the command to invoke\n:param args: the arguments to invoke. It may be given as an iterable\n             or a string. When given as string it will be interpreted\n             as a Unix shell command. More details at\n             :func:`shlex.split`.\n:param input: the input data for `sys.stdin`.\n:param env: the environment overrides.\n:param catch_exceptions: Whether to catch any other exceptions than\n                         ``SystemExit``. If :data:`None`, the value\n                         from :class:`CliRunner` is used.\n:param extra: the keyword arguments to pass to :meth:`main`.\n:param color: whether the output should contain color codes. The\n              application can still override this explicitly.\n\n.. versionadded:: 8.2\n    The result object has the ``output_bytes`` attribute with\n    the mix of ``stdout_bytes`` and ``stderr_bytes``, as the user would\n    see it in its terminal.\n\n.. versionchanged:: 8.2\n    The result object always returns the ``stderr_bytes`` stream.\n\n.. versionchanged:: 8.0\n    The result object has the ``return_value`` attribute with\n    the value returned from the invoked command.\n\n.. versionchanged:: 4.0\n    Added the ``color`` parameter.\n\n.. versionchanged:: 3.0\n    Added the ``catch_exceptions`` parameter.\n\n.. versionchanged:: 3.0\n    The result object has the ``exc_info`` attribute with the\n    traceback if available.",
          "code": "def invoke(\n        self,\n        cli: Command,\n        args: str | cabc.Sequence[str] | None = None,\n        input: str | bytes | t.IO[t.Any] | None = None,\n        env: cabc.Mapping[str, str | None] | None = None,\n        catch_exceptions: bool | None = None,\n        color: bool = False,\n        **extra: t.Any,\n    ) -> Result:\n        \"\"\"Invokes a command in an isolated environment.  The arguments are\n        forwarded directly to the command line script, the `extra` keyword\n        arguments are passed to the :meth:`~clickpkg.Command.main` function of\n        the command.\n\n        This returns a :class:`Result` object.\n\n        :param cli: the command to invoke\n        :param args: the arguments to invoke. It may be given as an iterable\n                     or a string. When given as string it will be interpreted\n                     as a Unix shell command. More details at\n                     :func:`shlex.split`.\n        :param input: the input data for `sys.stdin`.\n        :param env: the environment overrides.\n        :param catch_exceptions: Whether to catch any other exceptions than\n                                 ``SystemExit``. If :data:`None`, the value\n                                 from :class:`CliRunner` is used.\n        :param extra: the keyword arguments to pass to :meth:`main`.\n        :param color: whether the output should contain color codes. The\n                      application can still override this explicitly.\n\n        .. versionadded:: 8.2\n            The result object has the ``output_bytes`` attribute with\n            the mix of ``stdout_bytes`` and ``stderr_bytes``, as the user would\n            see it in its terminal.\n\n        .. versionchanged:: 8.2\n            The result object always returns the ``stderr_bytes`` stream.\n\n        .. versionchanged:: 8.0\n            The result object has the ``return_value`` attribute with\n            the value returned from the invoked command.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` parameter.\n\n        .. versionchanged:: 3.0\n            Added the ``catch_exceptions`` parameter.\n\n        .. versionchanged:: 3.0\n            The result object has the ``exc_info`` attribute with the\n            traceback if available.\n        \"\"\"\n        exc_info = None\n        if catch_exceptions is None:\n            catch_exceptions = self.catch_exceptions\n\n        with self.isolation(input=input, env=env, color=color) as outstreams:\n            return_value = None\n            exception: BaseException | None = None\n            exit_code = 0\n\n            if isinstance(args, str):\n                args = shlex.split(args)\n\n            try:\n                prog_name = extra.pop(\"prog_name\")\n            except KeyError:\n                prog_name = self.get_default_prog_name(cli)\n\n            try:\n                return_value = cli.main(args=args or (), prog_name=prog_name, **extra)\n            except SystemExit as e:\n                exc_info = sys.exc_info()\n                e_code = t.cast(\"int | t.Any | None\", e.code)\n\n                if e_code is None:\n                    e_code = 0\n\n                if e_code != 0:\n                    exception = e\n\n                if not isinstance(e_code, int):\n                    sys.stdout.write(str(e_code))\n                    sys.stdout.write(\"\\n\")\n                    e_code = 1\n\n                exit_code = e_code\n\n            except Exception as e:\n                if not catch_exceptions:\n                    raise\n                exception = e\n                exit_code = 1\n                exc_info = sys.exc_info()\n            finally:\n                sys.stdout.flush()\n                sys.stderr.flush()\n                stdout = outstreams[0].getvalue()\n                stderr = outstreams[1].getvalue()\n                output = outstreams[2].getvalue()\n\n        return Result(\n            runner=self,\n            stdout_bytes=stdout,\n            stderr_bytes=stderr,\n            output_bytes=output,\n            return_value=return_value,\n            exit_code=exit_code,\n            exception=exception,\n            exc_info=exc_info,  # type: ignore\n        )",
          "line_count": 112,
          "needs_llm_summary": true
        },
        {
          "name": "isolated_filesystem",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "temp_dir",
              "type": "Any"
            }
          ],
          "return_type": "cabc.Iterator[str]",
          "lineno": 547,
          "decorators": [
            {
              "name": "contextlib.contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "temp_dir",
            "shutil.rmtree",
            "os.chdir",
            "tempfile.mkdtemp",
            "dt",
            "os.getcwd",
            "cwd"
          ],
          "docstring": "A context manager that creates a temporary directory and\nchanges the current working directory to it. This isolates tests\nthat affect the contents of the CWD to prevent them from\ninterfering with each other.\n\n:param temp_dir: Create the temporary directory under this\n    directory. If given, the created directory is not removed\n    when exiting.\n\n.. versionchanged:: 8.0\n    Added the ``temp_dir`` parameter.",
          "code": "def isolated_filesystem(\n        self, temp_dir: str | os.PathLike[str] | None = None\n    ) -> cabc.Iterator[str]:\n        \"\"\"A context manager that creates a temporary directory and\n        changes the current working directory to it. This isolates tests\n        that affect the contents of the CWD to prevent them from\n        interfering with each other.\n\n        :param temp_dir: Create the temporary directory under this\n            directory. If given, the created directory is not removed\n            when exiting.\n\n        .. versionchanged:: 8.0\n            Added the ``temp_dir`` parameter.\n        \"\"\"\n        cwd = os.getcwd()\n        dt = tempfile.mkdtemp(dir=temp_dir)\n        os.chdir(dt)\n\n        try:\n            yield dt\n        finally:\n            os.chdir(cwd)\n\n            if temp_dir is None:\n                import shutil\n\n                try:\n                    shutil.rmtree(dt)\n                except OSError:\n                    pass",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "visible_input",
          "args": [
            {
              "name": "prompt",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 353,
          "decorators": [
            {
              "name": "_pause_echo",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "echo_input",
            "next",
            "_pause_echo",
            "text_input",
            "sys.stdout.write",
            "EOFError",
            "sys.stdout.flush",
            "unknown.rstrip"
          ],
          "docstring": null,
          "code": "def visible_input(prompt: str | None = None) -> str:\n            sys.stdout.write(prompt or \"\")\n            try:\n                val = next(text_input).rstrip(\"\\r\\n\")\n            except StopIteration as e:\n                raise EOFError() from e\n            sys.stdout.write(f\"{val}\\n\")\n            sys.stdout.flush()\n            return val",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "hidden_input",
          "args": [
            {
              "name": "prompt",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 364,
          "decorators": [
            {
              "name": "_pause_echo",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "echo_input",
            "next",
            "_pause_echo",
            "text_input",
            "sys.stdout.write",
            "EOFError",
            "sys.stdout.flush",
            "unknown.rstrip"
          ],
          "docstring": null,
          "code": "def hidden_input(prompt: str | None = None) -> str:\n            sys.stdout.write(f\"{prompt or ''}\\n\")\n            sys.stdout.flush()\n            try:\n                return next(text_input).rstrip(\"\\r\\n\")\n            except StopIteration as e:\n                raise EOFError() from e",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_getchar",
          "args": [
            {
              "name": "echo",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "lineno": 373,
          "decorators": [
            {
              "name": "_pause_echo",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "echo_input",
            "_pause_echo",
            "sys.stdin.read",
            "sys.stdout.write",
            "char",
            "sys.stdout.flush"
          ],
          "docstring": null,
          "code": "def _getchar(echo: bool) -> str:\n            char = sys.stdin.read(1)\n\n            if echo:\n                sys.stdout.write(char)\n\n            sys.stdout.flush()\n            return char",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "should_strip_ansi",
          "args": [
            {
              "name": "stream",
              "type": "Any"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 384,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def should_strip_ansi(\n            stream: t.IO[t.Any] | None = None, color: bool | None = None\n        ) -> bool:\n            if color is None:\n                return not default_color\n            return not color",
          "line_count": 6,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "EchoingStdin",
          "methods": [
            "__init__",
            "__getattr__",
            "_echo",
            "read",
            "read1",
            "readline",
            "readlines",
            "__iter__",
            "__repr__"
          ],
          "base_classes": [],
          "lineno": 25,
          "docstring": null
        },
        {
          "name": "BytesIOCopy",
          "methods": [
            "__init__",
            "flush",
            "write"
          ],
          "base_classes": [
            "io.BytesIO"
          ],
          "lineno": 69,
          "docstring": "Patch ``io.BytesIO`` to let the written stream be copied to another.\n\n.. versionadded:: 8.2"
        },
        {
          "name": "StreamMixer",
          "methods": [
            "__init__",
            "__del__"
          ],
          "base_classes": [],
          "lineno": 88,
          "docstring": "Mixes `<stdout>` and `<stderr>` streams.\n\nThe result is available in the ``output`` attribute.\n\n.. versionadded:: 8.2"
        },
        {
          "name": "_NamedTextIOWrapper",
          "methods": [
            "__init__",
            "name",
            "mode"
          ],
          "base_classes": [
            "io.TextIOWrapper"
          ],
          "lineno": 114,
          "docstring": null
        },
        {
          "name": "Result",
          "methods": [
            "__init__",
            "output",
            "stdout",
            "stderr",
            "__repr__"
          ],
          "base_classes": [],
          "lineno": 151,
          "docstring": "Holds the captured result of an invoked CLI script.\n\n:param runner: The runner that created the result\n:param stdout_bytes: The standard output as bytes.\n:param stderr_bytes: The standard error as bytes.\n:param output_bytes: A mix of ``stdout_bytes`` and ``stderr_bytes``, as the\n    user would see  it in its terminal.\n:param return_value: The value returned from the invoked command.\n:param exit_code: The exit code as integer.\n:param exception: The exception that happened if one did.\n:param exc_info: Exception information (exception type, exception instance,\n    traceback type).\n\n.. versionchanged:: 8.2\n    ``stderr_bytes`` no longer optional, ``output_bytes`` introduced and\n    ``mix_stderr`` has been removed.\n\n.. versionadded:: 8.0\n    Added ``return_value``."
        },
        {
          "name": "CliRunner",
          "methods": [
            "__init__",
            "get_default_prog_name",
            "make_env",
            "isolation",
            "invoke",
            "isolated_filesystem"
          ],
          "base_classes": [],
          "lineno": 229,
          "docstring": "The CLI runner provides functionality to invoke a Click command line\nscript for unittesting purposes in a isolated environment.  This only\nworks in single-threaded systems without any concurrency as it changes the\nglobal interpreter state.\n\n:param charset: the character set for the input and output data.\n:param env: a dictionary with environment variables for overriding.\n:param echo_stdin: if this is set to `True`, then reading from `<stdin>` writes\n                   to `<stdout>`.  This is useful for showing examples in\n                   some circumstances.  Note that regular prompts\n                   will automatically echo the input.\n:param catch_exceptions: Whether to catch any exceptions other than\n                         ``SystemExit`` when running :meth:`~CliRunner.invoke`.\n\n.. versionchanged:: 8.2\n    Added the ``catch_exceptions`` parameter.\n\n.. versionchanged:: 8.2\n    ``mix_stderr`` parameter has been removed."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "contextlib",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "io",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "shlex",
          "alias": null,
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "tempfile",
          "alias": null,
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "types",
          "name": "TracebackType",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "_compat",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "formatting",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "termui",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "utils",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "_find_binary_reader",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "_typeshed",
          "name": "ReadableBuffer",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Command",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "shutil",
          "alias": null,
          "lineno": 572,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "contextlib",
          "sys",
          "shutil",
          "typing",
          "os",
          "tempfile",
          "collections",
          "io"
        ],
        "third_party": {
          "other": [
            "__future__",
            "shlex",
            "types",
            "_compat",
            "formatting",
            "termui",
            "utils",
            "_typeshed",
            "core"
          ]
        },
        "tech_stack": []
      },
      "line_count": 578
    },
    "src/click/types.py": {
      "filepath": "../click/src/click/types.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_is_file_like",
          "args": [
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "te.TypeGuard[t.IO[t.Any]]",
          "lineno": 875,
          "decorators": [],
          "is_async": false,
          "calls": [
            "hasattr",
            "value"
          ],
          "docstring": null,
          "code": "def _is_file_like(value: t.Any) -> te.TypeGuard[t.IO[t.Any]]:\n    return hasattr(value, \"read\") or hasattr(value, \"write\")",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "convert_type",
          "args": [
            {
              "name": "ty",
              "type": "Any"
            },
            {
              "name": "default",
              "type": "Any"
            }
          ],
          "return_type": "ParamType",
          "lineno": 1112,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "AssertionError",
            "item",
            "type",
            "isinstance",
            "issubclass",
            "ParamType",
            "default",
            "ty",
            "Tuple",
            "FuncParamType",
            "map"
          ],
          "docstring": "Find the most appropriate :class:`ParamType` for the given Python\ntype. If the type isn't provided, it can be inferred from a default\nvalue.",
          "code": "def convert_type(ty: t.Any | None, default: t.Any | None = None) -> ParamType:\n    \"\"\"Find the most appropriate :class:`ParamType` for the given Python\n    type. If the type isn't provided, it can be inferred from a default\n    value.\n    \"\"\"\n    guessed_type = False\n\n    if ty is None and default is not None:\n        if isinstance(default, (tuple, list)):\n            # If the default is empty, ty will remain None and will\n            # return STRING.\n            if default:\n                item = default[0]\n\n                # A tuple of tuples needs to detect the inner types.\n                # Can't call convert recursively because that would\n                # incorrectly unwind the tuple to a single type.\n                if isinstance(item, (tuple, list)):\n                    ty = tuple(map(type, item))\n                else:\n                    ty = type(item)\n        else:\n            ty = type(default)\n\n        guessed_type = True\n\n    if isinstance(ty, tuple):\n        return Tuple(ty)\n\n    if isinstance(ty, ParamType):\n        return ty\n\n    if ty is str or ty is None:\n        return STRING\n\n    if ty is int:\n        return INT\n\n    if ty is float:\n        return FLOAT\n\n    if ty is bool:\n        return BOOL\n\n    if guessed_type:\n        return STRING\n\n    if __debug__:\n        try:\n            if issubclass(ty, ParamType):\n                raise AssertionError(\n                    f\"Attempted to use an uninstantiated parameter type ({ty}).\"\n                )\n        except TypeError:\n            # ty is an instance (correct), so issubclass fails.\n            pass\n\n    return FuncParamType(ty)",
          "line_count": 58,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 62,
          "decorators": [],
          "is_async": false,
          "calls": [
            "type",
            "self",
            "hasattr",
            "self.name",
            "param_type",
            "unknown.__name__.partition",
            "param_type.partition"
          ],
          "docstring": "Gather information that could be useful for a tool generating\nuser-facing documentation.\n\nUse :meth:`click.Context.to_info_dict` to traverse the entire\nCLI structure.\n\n.. versionadded:: 8.0",
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        \"\"\"Gather information that could be useful for a tool generating\n        user-facing documentation.\n\n        Use :meth:`click.Context.to_info_dict` to traverse the entire\n        CLI structure.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        # The class name without the \"ParamType\" suffix.\n        param_type = type(self).__name__.partition(\"ParamType\")[0]\n        param_type = param_type.partition(\"ParameterType\")[0]\n\n        # Custom subclasses might not remember to set a name.\n        if hasattr(self, \"name\"):\n            name = self.name\n        else:\n            name = param_type\n\n        return {\"param_type\": param_type, \"name\": name}",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "__call__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 83,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "param",
            "self.convert",
            "value"
          ],
          "docstring": null,
          "code": "def __call__(\n        self,\n        value: t.Any,\n        param: Parameter | None = None,\n        ctx: Context | None = None,\n    ) -> t.Any:\n        if value is not None:\n            return self.convert(value, param, ctx)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "get_metavar",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 92,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Returns the metavar default for this param if it provides one.",
          "code": "def get_metavar(self, param: Parameter, ctx: Context) -> str | None:\n        \"\"\"Returns the metavar default for this param if it provides one.\"\"\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_missing_message",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 95,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Optionally might return extra information about a missing\nparameter.\n\n.. versionadded:: 2.0",
          "code": "def get_missing_message(self, param: Parameter, ctx: Context | None) -> str | None:\n        \"\"\"Optionally might return extra information about a missing\n        parameter.\n\n        .. versionadded:: 2.0\n        \"\"\"",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 102,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Convert the value to the correct type. This is not called if\nthe value is ``None`` (the missing value).\n\nThis must accept string values from the command line, as well as\nvalues that are already the correct type. It may also convert\nother compatible types.\n\nThe ``param`` and ``ctx`` arguments may be ``None`` in certain\nsituations, such as when converting prompt input.\n\nIf the value cannot be converted, call :meth:`fail` with a\ndescriptive message.\n\n:param value: The value to convert.\n:param param: The parameter that is using this type to convert\n    its value. May be ``None``.\n:param ctx: The current context that arrived at this value. May\n    be ``None``.",
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        \"\"\"Convert the value to the correct type. This is not called if\n        the value is ``None`` (the missing value).\n\n        This must accept string values from the command line, as well as\n        values that are already the correct type. It may also convert\n        other compatible types.\n\n        The ``param`` and ``ctx`` arguments may be ``None`` in certain\n        situations, such as when converting prompt input.\n\n        If the value cannot be converted, call :meth:`fail` with a\n        descriptive message.\n\n        :param value: The value to convert.\n        :param param: The parameter that is using this type to convert\n            its value. May be ``None``.\n        :param ctx: The current context that arrived at this value. May\n            be ``None``.\n        \"\"\"\n        return value",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "split_envvar_value",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rv",
              "type": "str"
            }
          ],
          "return_type": "cabc.Sequence[str]",
          "lineno": 126,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.envvar_list_splitter",
            "unknown.split"
          ],
          "docstring": "Given a value from an environment variable this splits it up\ninto small chunks depending on the defined envvar list splitter.\n\nIf the splitter is set to `None`, which means that whitespace splits,\nthen leading and trailing whitespace is ignored.  Otherwise, leading\nand trailing splitters usually lead to empty items being included.",
          "code": "def split_envvar_value(self, rv: str) -> cabc.Sequence[str]:\n        \"\"\"Given a value from an environment variable this splits it up\n        into small chunks depending on the defined envvar list splitter.\n\n        If the splitter is set to `None`, which means that whitespace splits,\n        then leading and trailing whitespace is ignored.  Otherwise, leading\n        and trailing splitters usually lead to empty items being included.\n        \"\"\"\n        return (rv or \"\").split(self.envvar_list_splitter)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "fail",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.NoReturn",
          "lineno": 136,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "BadParameter",
            "message",
            "param"
          ],
          "docstring": "Helper method to fail with an invalid value message.",
          "code": "def fail(\n        self,\n        message: str,\n        param: Parameter | None = None,\n        ctx: Context | None = None,\n    ) -> t.NoReturn:\n        \"\"\"Helper method to fail with an invalid value message.\"\"\"\n        raise BadParameter(message, ctx=ctx, param=param)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "shell_complete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "list[CompletionItem]",
          "lineno": 145,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Return a list of\n:class:`~click.shell_completion.CompletionItem` objects for the\nincomplete value. Most types do not provide completions, but\nsome do, and this allows custom types to provide custom\ncompletions as well.\n\n:param ctx: Invocation context for this command.\n:param param: The parameter that is requesting completion.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
          "code": "def shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Return a list of\n        :class:`~click.shell_completion.CompletionItem` objects for the\n        incomplete value. Most types do not provide completions, but\n        some do, and this allows custom types to provide custom\n        completions as well.\n\n        :param ctx: Invocation context for this command.\n        :param param: The parameter that is requesting completion.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        return []",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "arity",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "int",
          "lineno": 167,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": null,
          "code": "def arity(self) -> int:  # type: ignore\n        raise NotImplementedError()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "func",
              "type": "t.Callable[Any, t.Any]"
            }
          ],
          "return_type": "None",
          "lineno": 172,
          "decorators": [],
          "is_async": false,
          "calls": [
            "func"
          ],
          "docstring": null,
          "code": "def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:\n        self.name: str = func.__name__\n        self.func = func",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 176,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.func",
            "unknown.to_info_dict",
            "super"
          ],
          "docstring": null,
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict[\"func\"] = self.func\n        return info_dict",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 181,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.func",
            "value.decode",
            "param",
            "ctx",
            "value",
            "str",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        try:\n            return self.func(value)\n        except ValueError:\n            try:\n                value = str(value)\n            except UnicodeError:\n                value = value.decode(\"utf-8\", \"replace\")\n\n            self.fail(value, param, ctx)",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 198,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        return value",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 203,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return \"UNPROCESSED\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 210,
          "decorators": [],
          "is_async": false,
          "calls": [
            "enc",
            "_get_argv_encoding",
            "value.decode",
            "value",
            "str",
            "bytes",
            "isinstance",
            "sys.getfilesystemencoding",
            "fs_enc"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        if isinstance(value, bytes):\n            enc = _get_argv_encoding()\n            try:\n                value = value.decode(enc)\n            except UnicodeError:\n                fs_enc = sys.getfilesystemencoding()\n                if fs_enc != enc:\n                    try:\n                        value = value.decode(fs_enc)\n                    except UnicodeError:\n                        value = value.decode(\"utf-8\", \"replace\")\n                else:\n                    value = value.decode(\"utf-8\", \"replace\")\n            return value\n        return str(value)",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 229,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return \"STRING\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "choices",
              "type": "cabc.Iterable[ParamTypeValue]"
            },
            {
              "name": "case_sensitive",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 258,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "choices",
            "case_sensitive"
          ],
          "docstring": null,
          "code": "def __init__(\n        self, choices: cabc.Iterable[ParamTypeValue], case_sensitive: bool = True\n    ) -> None:\n        self.choices: cabc.Sequence[ParamTypeValue] = tuple(choices)\n        self.case_sensitive = case_sensitive",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 264,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "unknown.to_info_dict",
            "self.choices",
            "self.case_sensitive"
          ],
          "docstring": null,
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict[\"choices\"] = self.choices\n        info_dict[\"case_sensitive\"] = self.case_sensitive\n        return info_dict",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "_normalized_mapping",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "cabc.Mapping[ParamTypeValue, str]",
          "lineno": 270,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "choice",
            "self.normalize_choice"
          ],
          "docstring": "Returns mapping where keys are the original choices and the values are\nthe normalized values that are accepted via the command line.\n\nThis is a simple wrapper around :meth:`normalize_choice`, use that\ninstead which is supported.",
          "code": "def _normalized_mapping(\n        self, ctx: Context | None = None\n    ) -> cabc.Mapping[ParamTypeValue, str]:\n        \"\"\"\n        Returns mapping where keys are the original choices and the values are\n        the normalized values that are accepted via the command line.\n\n        This is a simple wrapper around :meth:`normalize_choice`, use that\n        instead which is supported.\n        \"\"\"\n        return {\n            choice: self.normalize_choice(\n                choice=choice,\n                ctx=ctx,\n            )\n            for choice in self.choices\n        }",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "normalize_choice",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "choice",
              "type": "ParamTypeValue"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 288,
          "decorators": [],
          "is_async": false,
          "calls": [
            "enum.Enum",
            "choice",
            "ctx.token_normalize_func",
            "normed_value.casefold",
            "str",
            "isinstance",
            "normed_value"
          ],
          "docstring": "Normalize a choice value, used to map a passed string to a choice.\nEach choice must have a unique normalized value.\n\nBy default uses :meth:`Context.token_normalize_func` and if not case\nsensitive, convert it to a casefolded value.\n\n.. versionadded:: 8.2.0",
          "code": "def normalize_choice(self, choice: ParamTypeValue, ctx: Context | None) -> str:\n        \"\"\"\n        Normalize a choice value, used to map a passed string to a choice.\n        Each choice must have a unique normalized value.\n\n        By default uses :meth:`Context.token_normalize_func` and if not case\n        sensitive, convert it to a casefolded value.\n\n        .. versionadded:: 8.2.0\n        \"\"\"\n        normed_value = choice.name if isinstance(choice, enum.Enum) else str(choice)\n\n        if ctx is not None and ctx.token_normalize_func is not None:\n            normed_value = ctx.token_normalize_func(normed_value)\n\n        if not self.case_sensitive:\n            normed_value = normed_value.casefold()\n\n        return normed_value",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "get_metavar",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 308,
          "decorators": [],
          "is_async": false,
          "calls": [
            "choice",
            "unknown.join",
            "type",
            "str",
            "ctx",
            "dict.fromkeys",
            "choice_metavars",
            "unknown.name.upper",
            "unknown.values",
            "self._normalized_mapping",
            "convert_type",
            "i"
          ],
          "docstring": null,
          "code": "def get_metavar(self, param: Parameter, ctx: Context) -> str | None:\n        if param.param_type_name == \"option\" and not param.show_choices:  # type: ignore\n            choice_metavars = [\n                convert_type(type(choice)).name.upper() for choice in self.choices\n            ]\n            choices_str = \"|\".join([*dict.fromkeys(choice_metavars)])\n        else:\n            choices_str = \"|\".join(\n                [str(i) for i in self._normalized_mapping(ctx=ctx).values()]\n            )\n\n        # Use curly braces to indicate a required argument.\n        if param.required and param.param_type_name == \"argument\":\n            return f\"{{{choices_str}}}\"\n\n        # Use square braces to indicate an option or optional argument.\n        return f\"[{choices_str}]\"",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "get_missing_message",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 326,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.join",
            "ctx",
            "_",
            "unknown.values",
            "self._normalized_mapping",
            "unknown.format"
          ],
          "docstring": "Message shown when no choice is passed.\n\n.. versionchanged:: 8.2.0 Added ``ctx`` argument.",
          "code": "def get_missing_message(self, param: Parameter, ctx: Context | None) -> str:\n        \"\"\"\n        Message shown when no choice is passed.\n\n        .. versionchanged:: 8.2.0 Added ``ctx`` argument.\n        \"\"\"\n        return _(\"Choose from:\\n\\t{choices}\").format(\n            choices=\",\\n\\t\".join(self._normalized_mapping(ctx=ctx).values())\n        )",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "ParamTypeValue",
          "lineno": 336,
          "decorators": [],
          "is_async": false,
          "calls": [
            "normalized_mapping.items",
            "self.normalize_choice",
            "self.get_invalid_choice_message",
            "value",
            "ctx",
            "next",
            "param",
            "self._normalized_mapping",
            "self.fail"
          ],
          "docstring": "For a given value from the parser, normalize it and find its\nmatching normalized value in the list of choices. Then return the\nmatched \"original\" choice.",
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> ParamTypeValue:\n        \"\"\"\n        For a given value from the parser, normalize it and find its\n        matching normalized value in the list of choices. Then return the\n        matched \"original\" choice.\n        \"\"\"\n        normed_value = self.normalize_choice(choice=value, ctx=ctx)\n        normalized_mapping = self._normalized_mapping(ctx=ctx)\n\n        try:\n            return next(\n                original\n                for original, normalized in normalized_mapping.items()\n                if normalized == normed_value\n            )\n        except StopIteration:\n            self.fail(\n                self.get_invalid_choice_message(value=value, ctx=ctx),\n                param=param,\n                ctx=ctx,\n            )",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "get_invalid_choice_message",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 360,
          "decorators": [],
          "is_async": false,
          "calls": [
            "repr",
            "unknown.join",
            "unknown.format",
            "self.choices",
            "value",
            "ctx",
            "len",
            "ngettext",
            "unknown.values",
            "self._normalized_mapping",
            "choices_str",
            "map"
          ],
          "docstring": "Get the error message when the given choice is invalid.\n\n:param value: The invalid value.\n\n.. versionadded:: 8.2",
          "code": "def get_invalid_choice_message(self, value: t.Any, ctx: Context | None) -> str:\n        \"\"\"Get the error message when the given choice is invalid.\n\n        :param value: The invalid value.\n\n        .. versionadded:: 8.2\n        \"\"\"\n        choices_str = \", \".join(map(repr, self._normalized_mapping(ctx=ctx).values()))\n        return ngettext(\n            \"{value!r} is not {choice}.\",\n            \"{value!r} is not one of {choices}.\",\n            len(self.choices),\n        ).format(value=value, choice=choices_str, choices=choices_str)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 374,
          "decorators": [],
          "is_async": false,
          "calls": [
            "list",
            "self.choices"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return f\"Choice({list(self.choices)})\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "shell_complete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "list[CompletionItem]",
          "lineno": 377,
          "decorators": [],
          "is_async": false,
          "calls": [
            "c",
            "self.choices",
            "incomplete",
            "str",
            "incomplete.lower",
            "CompletionItem",
            "c.startswith",
            "c.lower",
            "unknown.startswith",
            "map"
          ],
          "docstring": "Complete choices that start with the incomplete value.\n\n:param ctx: Invocation context for this command.\n:param param: The parameter that is requesting completion.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
          "code": "def shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Complete choices that start with the incomplete value.\n\n        :param ctx: Invocation context for this command.\n        :param param: The parameter that is requesting completion.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        str_choices = map(str, self.choices)\n\n        if self.case_sensitive:\n            matched = (c for c in str_choices if c.startswith(incomplete))\n        else:\n            incomplete = incomplete.lower()\n            matched = (c for c in str_choices if c.lower().startswith(incomplete))\n\n        return [CompletionItem(c) for c in matched]",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "formats",
              "type": "Any"
            }
          ],
          "return_type": null,
          "lineno": 424,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __init__(self, formats: cabc.Sequence[str] | None = None):\n        self.formats: cabc.Sequence[str] = formats or [\n            \"%Y-%m-%d\",\n            \"%Y-%m-%dT%H:%M:%S\",\n            \"%Y-%m-%d %H:%M:%S\",\n        ]",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 431,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "unknown.to_info_dict",
            "self.formats"
          ],
          "docstring": null,
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict[\"formats\"] = self.formats\n        return info_dict",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "get_metavar",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "ctx",
              "type": "Context"
            }
          ],
          "return_type": "Any",
          "lineno": 436,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.formats",
            "unknown.join"
          ],
          "docstring": null,
          "code": "def get_metavar(self, param: Parameter, ctx: Context) -> str | None:\n        return f\"[{'|'.join(self.formats)}]\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_try_to_convert_date",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "format",
              "type": "str"
            }
          ],
          "return_type": "Any",
          "lineno": 439,
          "decorators": [],
          "is_async": false,
          "calls": [
            "format",
            "datetime.strptime",
            "value"
          ],
          "docstring": null,
          "code": "def _try_to_convert_date(self, value: t.Any, format: str) -> datetime | None:\n        try:\n            return datetime.strptime(value, format)\n        except ValueError:\n            return None",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 445,
          "decorators": [],
          "is_async": false,
          "calls": [
            "repr",
            "datetime",
            "unknown.join",
            "unknown.format",
            "value",
            "param",
            "ctx",
            "len",
            "ngettext",
            "isinstance",
            "format",
            "self.formats",
            "formats_str",
            "map",
            "self.fail",
            "self._try_to_convert_date"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        if isinstance(value, datetime):\n            return value\n\n        for format in self.formats:\n            converted = self._try_to_convert_date(value, format)\n\n            if converted is not None:\n                return converted\n\n        formats_str = \", \".join(map(repr, self.formats))\n        self.fail(\n            ngettext(\n                \"{value!r} does not match the format {format}.\",\n                \"{value!r} does not match the formats {formats}.\",\n                len(self.formats),\n            ).format(value=value, format=formats_str, formats=formats_str),\n            param,\n            ctx,\n        )",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 468,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return \"DateTime\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 475,
          "decorators": [],
          "is_async": false,
          "calls": [
            "param",
            "ctx",
            "self._number_class",
            "value",
            "self.name",
            "_",
            "unknown.format",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        try:\n            return self._number_class(value)\n        except ValueError:\n            self.fail(\n                _(\"{value!r} is not a valid {number_type}.\").format(\n                    value=value, number_type=self.name\n                ),\n                param,\n                ctx,\n            )",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "min",
              "type": "Any"
            },
            {
              "name": "max",
              "type": "Any"
            },
            {
              "name": "min_open",
              "type": "bool"
            },
            {
              "name": "max_open",
              "type": "bool"
            },
            {
              "name": "clamp",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 491,
          "decorators": [],
          "is_async": false,
          "calls": [
            "min_open",
            "max",
            "min",
            "max_open",
            "clamp"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        min: float | None = None,\n        max: float | None = None,\n        min_open: bool = False,\n        max_open: bool = False,\n        clamp: bool = False,\n    ) -> None:\n        self.min = min\n        self.max = max\n        self.min_open = min_open\n        self.max_open = max_open\n        self.clamp = clamp",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 505,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.min",
            "unknown.to_info_dict",
            "self.max_open",
            "super",
            "self.min_open",
            "info_dict.update",
            "self.max",
            "self.clamp"
          ],
          "docstring": null,
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict.update(\n            min=self.min,\n            max=self.max,\n            min_open=self.min_open,\n            max_open=self.max_open,\n            clamp=self.clamp,\n        )\n        return info_dict",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 516,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.min",
            "unknown.format",
            "param",
            "ctx",
            "value",
            "unknown.convert",
            "rv",
            "self._describe_range",
            "_",
            "self._clamp",
            "self.max_open",
            "super",
            "self.min_open",
            "self.max",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        import operator\n\n        rv = super().convert(value, param, ctx)\n        lt_min: bool = self.min is not None and (\n            operator.le if self.min_open else operator.lt\n        )(rv, self.min)\n        gt_max: bool = self.max is not None and (\n            operator.ge if self.max_open else operator.gt\n        )(rv, self.max)\n\n        if self.clamp:\n            if lt_min:\n                return self._clamp(self.min, 1, self.min_open)  # type: ignore\n\n            if gt_max:\n                return self._clamp(self.max, -1, self.max_open)  # type: ignore\n\n        if lt_min or gt_max:\n            self.fail(\n                _(\"{value} is not in the range {range}.\").format(\n                    value=rv, range=self._describe_range()\n                ),\n                param,\n                ctx,\n            )\n\n        return rv",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "_clamp",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "bound",
              "type": "float"
            },
            {
              "name": "dir",
              "type": "t.Literal[1, Any]"
            },
            {
              "name": "open",
              "type": "bool"
            }
          ],
          "return_type": "float",
          "lineno": 547,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Find the valid value to clamp to bound in the given\ndirection.\n\n:param bound: The boundary value.\n:param dir: 1 or -1 indicating the direction to move.\n:param open: If true, the range does not include the bound.",
          "code": "def _clamp(self, bound: float, dir: t.Literal[1, -1], open: bool) -> float:\n        \"\"\"Find the valid value to clamp to bound in the given\n        direction.\n\n        :param bound: The boundary value.\n        :param dir: 1 or -1 indicating the direction to move.\n        :param open: If true, the range does not include the bound.\n        \"\"\"\n        raise NotImplementedError",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "_describe_range",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 557,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Describe the range for use in help text.",
          "code": "def _describe_range(self) -> str:\n        \"\"\"Describe the range for use in help text.\"\"\"\n        if self.min is None:\n            op = \"<\" if self.max_open else \"<=\"\n            return f\"x{op}{self.max}\"\n\n        if self.max is None:\n            op = \">\" if self.min_open else \">=\"\n            return f\"x{op}{self.min}\"\n\n        lop = \"<\" if self.min_open else \"<=\"\n        rop = \"<\" if self.max_open else \"<=\"\n        return f\"{self.min}{lop}x{rop}{self.max}\"",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 571,
          "decorators": [],
          "is_async": false,
          "calls": [
            "type",
            "self._describe_range",
            "self"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        clamp = \" clamped\" if self.clamp else \"\"\n        return f\"<{type(self).__name__} {self._describe_range()}{clamp}>\"",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 580,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return \"INT\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_clamp",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "bound",
              "type": "int"
            },
            {
              "name": "dir",
              "type": "t.Literal[1, Any]"
            },
            {
              "name": "open",
              "type": "bool"
            }
          ],
          "return_type": "int",
          "lineno": 601,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def _clamp(  # type: ignore\n        self, bound: int, dir: t.Literal[1, -1], open: bool\n    ) -> int:\n        if not open:\n            return bound\n\n        return bound + dir",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 614,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return \"FLOAT\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "min",
              "type": "Any"
            },
            {
              "name": "max",
              "type": "Any"
            },
            {
              "name": "min_open",
              "type": "bool"
            },
            {
              "name": "max_open",
              "type": "bool"
            },
            {
              "name": "clamp",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 636,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "min_open",
            "unknown.__init__",
            "max",
            "min",
            "TypeError",
            "max_open",
            "clamp"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        min: float | None = None,\n        max: float | None = None,\n        min_open: bool = False,\n        max_open: bool = False,\n        clamp: bool = False,\n    ) -> None:\n        super().__init__(\n            min=min, max=max, min_open=min_open, max_open=max_open, clamp=clamp\n        )\n\n        if (min_open or max_open) and clamp:\n            raise TypeError(\"Clamping is not supported for open bounds.\")",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "_clamp",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "bound",
              "type": "float"
            },
            {
              "name": "dir",
              "type": "t.Literal[1, Any]"
            },
            {
              "name": "open",
              "type": "bool"
            }
          ],
          "return_type": "float",
          "lineno": 651,
          "decorators": [],
          "is_async": false,
          "calls": [
            "RuntimeError"
          ],
          "docstring": null,
          "code": "def _clamp(self, bound: float, dir: t.Literal[1, -1], open: bool) -> float:\n        if not open:\n            return bound\n\n        # Could use math.nextafter here, but clamping an\n        # open float range doesn't seem to be particularly useful. It's\n        # left up to the user to write a callback to do it if needed.\n        raise RuntimeError(\"Clamping is not supported for open bounds.\")",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "str_to_bool",
          "args": [
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 698,
          "decorators": [
            {
              "name": "staticmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "value",
            "value.strip",
            "unknown.lower",
            "isinstance",
            "bool",
            "BoolParamType.bool_states.get"
          ],
          "docstring": "Convert a string to a boolean value.\n\nIf the value is already a boolean, it is returned as-is. If the value is a\nstring, it is stripped of whitespaces and lower-cased, then checked against\nthe known boolean states pre-defined in the `BoolParamType.bool_states` mapping\nabove.\n\nReturns `None` if the value does not match any known boolean state.",
          "code": "def str_to_bool(value: str | bool) -> bool | None:\n        \"\"\"Convert a string to a boolean value.\n\n        If the value is already a boolean, it is returned as-is. If the value is a\n        string, it is stripped of whitespaces and lower-cased, then checked against\n        the known boolean states pre-defined in the `BoolParamType.bool_states` mapping\n        above.\n\n        Returns `None` if the value does not match any known boolean state.\n        \"\"\"\n        if isinstance(value, bool):\n            return value\n        return BoolParamType.bool_states.get(value.strip().lower())",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 712,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.str_to_bool",
            "unknown.join",
            "self.bool_states",
            "param",
            "ctx",
            "value",
            "sorted",
            "_",
            "unknown.format",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> bool:\n        normalized = self.str_to_bool(value)\n        if normalized is None:\n            self.fail(\n                _(\n                    \"{value!r} is not a valid boolean. Recognized values: {states}\"\n                ).format(value=value, states=\", \".join(sorted(self.bool_states))),\n                param,\n                ctx,\n            )\n        return normalized",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 726,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return \"BOOL\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 733,
          "decorators": [],
          "is_async": false,
          "calls": [
            "uuid.UUID",
            "value",
            "param",
            "value.strip",
            "ctx",
            "_",
            "isinstance",
            "unknown.format",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        import uuid\n\n        if isinstance(value, uuid.UUID):\n            return value\n\n        value = value.strip()\n\n        try:\n            return uuid.UUID(value)\n        except ValueError:\n            self.fail(\n                _(\"{value!r} is not a valid UUID.\").format(value=value), param, ctx\n            )",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 750,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return \"UUID\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "mode",
              "type": "str"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "lazy",
              "type": "Any"
            },
            {
              "name": "atomic",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 787,
          "decorators": [],
          "is_async": false,
          "calls": [
            "mode",
            "encoding",
            "lazy",
            "errors",
            "atomic"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        mode: str = \"r\",\n        encoding: str | None = None,\n        errors: str | None = \"strict\",\n        lazy: bool | None = None,\n        atomic: bool = False,\n    ) -> None:\n        self.mode = mode\n        self.encoding = encoding\n        self.errors = errors\n        self.lazy = lazy\n        self.atomic = atomic",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 801,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.encoding",
            "unknown.to_info_dict",
            "self.mode",
            "super",
            "info_dict.update"
          ],
          "docstring": null,
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict.update(mode=self.mode, encoding=self.encoding)\n        return info_dict",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "resolve_lazy_flag",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 806,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.fspath",
            "value"
          ],
          "docstring": null,
          "code": "def resolve_lazy_flag(self, value: str | os.PathLike[str]) -> bool:\n        if self.lazy is not None:\n            return self.lazy\n        if os.fspath(value) == \"-\":\n            return False\n        elif \"w\" in self.mode:\n            return True\n        return False",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.IO[t.Any]",
          "lineno": 815,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "f.close",
            "_is_file_like",
            "lf.close_intelligently",
            "ctx.call_on_close",
            "open_stream",
            "lf",
            "param",
            "self.resolve_lazy_flag",
            "self.mode",
            "self.errors",
            "f.flush",
            "self.atomic",
            "format_filename",
            "self.encoding",
            "LazyFile",
            "value",
            "safecall",
            "t.cast",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(\n        self,\n        value: str | os.PathLike[str] | t.IO[t.Any],\n        param: Parameter | None,\n        ctx: Context | None,\n    ) -> t.IO[t.Any]:\n        if _is_file_like(value):\n            return value\n\n        value = t.cast(\"str | os.PathLike[str]\", value)\n\n        try:\n            lazy = self.resolve_lazy_flag(value)\n\n            if lazy:\n                lf = LazyFile(\n                    value, self.mode, self.encoding, self.errors, atomic=self.atomic\n                )\n\n                if ctx is not None:\n                    ctx.call_on_close(lf.close_intelligently)\n\n                return t.cast(\"t.IO[t.Any]\", lf)\n\n            f, should_close = open_stream(\n                value, self.mode, self.encoding, self.errors, atomic=self.atomic\n            )\n\n            # If a context is provided, we automatically close the file\n            # at the end of the context execution (or flush out).  If a\n            # context does not exist, it's the caller's responsibility to\n            # properly close the file.  This for instance happens when the\n            # type is used with prompts.\n            if ctx is not None:\n                if should_close:\n                    ctx.call_on_close(safecall(f.close))\n                else:\n                    ctx.call_on_close(safecall(f.flush))\n\n            return f\n        except OSError as e:\n            self.fail(f\"'{format_filename(value)}': {e.strerror}\", param, ctx)",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "shell_complete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "list[CompletionItem]",
          "lineno": 858,
          "decorators": [],
          "is_async": false,
          "calls": [
            "CompletionItem",
            "incomplete"
          ],
          "docstring": "Return a special completion marker that tells the completion\nsystem to use the shell to provide file path completions.\n\n:param ctx: Invocation context for this command.\n:param param: The parameter that is requesting completion.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
          "code": "def shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Return a special completion marker that tells the completion\n        system to use the shell to provide file path completions.\n\n        :param ctx: Invocation context for this command.\n        :param param: The parameter that is requesting completion.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        return [CompletionItem(incomplete, type=\"file\")]",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exists",
              "type": "bool"
            },
            {
              "name": "file_okay",
              "type": "bool"
            },
            {
              "name": "dir_okay",
              "type": "bool"
            },
            {
              "name": "writable",
              "type": "bool"
            },
            {
              "name": "readable",
              "type": "bool"
            },
            {
              "name": "resolve_path",
              "type": "bool"
            },
            {
              "name": "allow_dash",
              "type": "bool"
            },
            {
              "name": "path_type",
              "type": "Any"
            },
            {
              "name": "executable",
              "type": "bool"
            }
          ],
          "return_type": null,
          "lineno": 914,
          "decorators": [],
          "is_async": false,
          "calls": [
            "readable",
            "dir_okay",
            "file_okay",
            "resolve_path",
            "allow_dash",
            "_",
            "writable",
            "path_type",
            "exists",
            "executable"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        exists: bool = False,\n        file_okay: bool = True,\n        dir_okay: bool = True,\n        writable: bool = False,\n        readable: bool = True,\n        resolve_path: bool = False,\n        allow_dash: bool = False,\n        path_type: type[t.Any] | None = None,\n        executable: bool = False,\n    ):\n        self.exists = exists\n        self.file_okay = file_okay\n        self.dir_okay = dir_okay\n        self.readable = readable\n        self.writable = writable\n        self.executable = executable\n        self.resolve_path = resolve_path\n        self.allow_dash = allow_dash\n        self.type = path_type\n\n        if self.file_okay and not self.dir_okay:\n            self.name: str = _(\"file\")\n        elif self.dir_okay and not self.file_okay:\n            self.name = _(\"directory\")\n        else:\n            self.name = _(\"path\")",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 943,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.writable",
            "self.dir_okay",
            "self.file_okay",
            "unknown.to_info_dict",
            "self.allow_dash",
            "self.readable",
            "self.exists",
            "super",
            "info_dict.update"
          ],
          "docstring": null,
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict.update(\n            exists=self.exists,\n            file_okay=self.file_okay,\n            dir_okay=self.dir_okay,\n            writable=self.writable,\n            readable=self.readable,\n            allow_dash=self.allow_dash,\n        )\n        return info_dict",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "coerce_path_result",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 955,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.fsdecode",
            "value",
            "t.cast",
            "isinstance",
            "os.fsencode",
            "self.type"
          ],
          "docstring": null,
          "code": "def coerce_path_result(\n        self, value: str | os.PathLike[str]\n    ) -> str | bytes | os.PathLike[str]:\n        if self.type is not None and not isinstance(value, self.type):\n            if self.type is str:\n                return os.fsdecode(value)\n            elif self.type is bytes:\n                return os.fsencode(value)\n            else:\n                return t.cast(\"os.PathLike[str]\", self.type(value))\n\n        return value",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 968,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.stat",
            "ctx",
            "os.path.realpath",
            "unknown.format",
            "os.access",
            "self.coerce_path_result",
            "rv",
            "_",
            "stat.S_ISDIR",
            "param",
            "os.R_OK",
            "self.name.title",
            "format_filename",
            "value",
            "stat.S_ISREG",
            "os.X_OK",
            "os.W_OK",
            "st.st_mode",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(\n        self,\n        value: str | os.PathLike[str],\n        param: Parameter | None,\n        ctx: Context | None,\n    ) -> str | bytes | os.PathLike[str]:\n        rv = value\n\n        is_dash = self.file_okay and self.allow_dash and rv in (b\"-\", \"-\")\n\n        if not is_dash:\n            if self.resolve_path:\n                rv = os.path.realpath(rv)\n\n            try:\n                st = os.stat(rv)\n            except OSError:\n                if not self.exists:\n                    return self.coerce_path_result(rv)\n                self.fail(\n                    _(\"{name} {filename!r} does not exist.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n            if not self.file_okay and stat.S_ISREG(st.st_mode):\n                self.fail(\n                    _(\"{name} {filename!r} is a file.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n            if not self.dir_okay and stat.S_ISDIR(st.st_mode):\n                self.fail(\n                    _(\"{name} {filename!r} is a directory.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n            if self.readable and not os.access(rv, os.R_OK):\n                self.fail(\n                    _(\"{name} {filename!r} is not readable.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n            if self.writable and not os.access(rv, os.W_OK):\n                self.fail(\n                    _(\"{name} {filename!r} is not writable.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n            if self.executable and not os.access(value, os.X_OK):\n                self.fail(\n                    _(\"{name} {filename!r} is not executable.\").format(\n                        name=self.name.title(), filename=format_filename(value)\n                    ),\n                    param,\n                    ctx,\n                )\n\n        return self.coerce_path_result(rv)",
          "line_count": 72,
          "needs_llm_summary": true
        },
        {
          "name": "shell_complete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "Context"
            },
            {
              "name": "param",
              "type": "Parameter"
            },
            {
              "name": "incomplete",
              "type": "str"
            }
          ],
          "return_type": "list[CompletionItem]",
          "lineno": 1041,
          "decorators": [],
          "is_async": false,
          "calls": [
            "CompletionItem",
            "type",
            "incomplete"
          ],
          "docstring": "Return a special completion marker that tells the completion\nsystem to use the shell to provide path completions for only\ndirectories or any paths.\n\n:param ctx: Invocation context for this command.\n:param param: The parameter that is requesting completion.\n:param incomplete: Value being completed. May be empty.\n\n.. versionadded:: 8.0",
          "code": "def shell_complete(\n        self, ctx: Context, param: Parameter, incomplete: str\n    ) -> list[CompletionItem]:\n        \"\"\"Return a special completion marker that tells the completion\n        system to use the shell to provide path completions for only\n        directories or any paths.\n\n        :param ctx: Invocation context for this command.\n        :param param: The parameter that is requesting completion.\n        :param incomplete: Value being completed. May be empty.\n\n        .. versionadded:: 8.0\n        \"\"\"\n        from click.shell_completion import CompletionItem\n\n        type = \"dir\" if self.dir_okay and not self.file_okay else \"file\"\n        return [CompletionItem(incomplete, type=type)]",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "types",
              "type": "cabc.Sequence[Any]"
            }
          ],
          "return_type": "None",
          "lineno": 1074,
          "decorators": [],
          "is_async": false,
          "calls": [
            "convert_type",
            "ty"
          ],
          "docstring": null,
          "code": "def __init__(self, types: cabc.Sequence[type[t.Any] | ParamType]) -> None:\n        self.types: cabc.Sequence[ParamType] = [convert_type(ty) for ty in types]",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_info_dict",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 1077,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "unknown.to_info_dict",
            "t.to_info_dict"
          ],
          "docstring": null,
          "code": "def to_info_dict(self) -> dict[str, t.Any]:\n        info_dict = super().to_info_dict()\n        info_dict[\"types\"] = [t.to_info_dict() for t in self.types]\n        return info_dict",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "name",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 1083,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "unknown.join"
          ],
          "docstring": null,
          "code": "def name(self) -> str:  # type: ignore\n        return f\"<{' '.join(ty.name for ty in self.types)}>\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "arity",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "int",
          "lineno": 1087,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "len",
            "self.types"
          ],
          "docstring": null,
          "code": "def arity(self) -> int:  # type: ignore\n        return len(self.types)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 1090,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tuple",
            "value",
            "param",
            "ctx",
            "len",
            "self.types",
            "ngettext",
            "len_type",
            "ty",
            "len_value",
            "x",
            "zip",
            "unknown.format",
            "self.fail"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: Parameter | None, ctx: Context | None\n    ) -> t.Any:\n        len_type = len(self.types)\n        len_value = len(value)\n\n        if len_value != len_type:\n            self.fail(\n                ngettext(\n                    \"{len_type} values are required, but {len_value} was given.\",\n                    \"{len_type} values are required, but {len_value} were given.\",\n                    len_value,\n                ).format(len_type=len_type, len_value=len_value),\n                param=param,\n                ctx=ctx,\n            )\n\n        return tuple(\n            ty(x, param, ctx) for ty, x in zip(self.types, value, strict=False)\n        )",
          "line_count": 20,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "ParamType",
          "methods": [
            "to_info_dict",
            "__call__",
            "get_metavar",
            "get_missing_message",
            "convert",
            "split_envvar_value",
            "fail",
            "shell_complete"
          ],
          "base_classes": [],
          "lineno": 30,
          "docstring": "Represents the type of a parameter. Validates and converts values\nfrom the command line or Python into the correct type.\n\nTo implement a custom type, subclass and implement at least the\nfollowing:\n\n-   The :attr:`name` class attribute must be set.\n-   Calling an instance of the type with ``None`` must return\n    ``None``. This is already implemented by default.\n-   :meth:`convert` must convert string values to the correct type.\n-   :meth:`convert` must accept values that are already the correct\n    type.\n-   It must be able to convert a value if the ``ctx`` and ``param``\n    arguments are ``None``. This can occur when converting prompt\n    input."
        },
        {
          "name": "CompositeParamType",
          "methods": [
            "arity"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 163,
          "docstring": null
        },
        {
          "name": "FuncParamType",
          "methods": [
            "__init__",
            "to_info_dict",
            "convert"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 171,
          "docstring": null
        },
        {
          "name": "UnprocessedParamType",
          "methods": [
            "convert",
            "__repr__"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 195,
          "docstring": null
        },
        {
          "name": "StringParamType",
          "methods": [
            "convert",
            "__repr__"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 207,
          "docstring": null
        },
        {
          "name": "Choice",
          "methods": [
            "__init__",
            "to_info_dict",
            "_normalized_mapping",
            "normalize_choice",
            "get_metavar",
            "get_missing_message",
            "convert",
            "get_invalid_choice_message",
            "__repr__",
            "shell_complete"
          ],
          "base_classes": [
            "ParamType",
            "unknown"
          ],
          "lineno": 233,
          "docstring": "The choice type allows a value to be checked against a fixed set\nof supported values.\n\nYou may pass any iterable value which will be converted to a tuple\nand thus will only be iterated once.\n\nThe resulting value will always be one of the originally passed choices.\nSee :meth:`normalize_choice` for more info on the mapping of strings\nto choices. See :ref:`choice-opts` for an example.\n\n:param case_sensitive: Set to false to make choices case\n    insensitive. Defaults to true.\n\n.. versionchanged:: 8.2.0\n    Non-``str`` ``choices`` are now supported. It can additionally be any\n    iterable. Before you were not recommended to pass anything but a list or\n    tuple.\n\n.. versionadded:: 8.2.0\n    Choice normalization can be overridden via :meth:`normalize_choice`."
        },
        {
          "name": "DateTime",
          "methods": [
            "__init__",
            "to_info_dict",
            "get_metavar",
            "_try_to_convert_date",
            "convert",
            "__repr__"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 401,
          "docstring": "The DateTime type converts date strings into `datetime` objects.\n\nThe format strings which are checked are configurable, but default to some\ncommon (non-timezone aware) ISO 8601 formats.\n\nWhen specifying *DateTime* formats, you should only pass a list or a tuple.\nOther iterables, like generators, may lead to surprising results.\n\nThe format strings are processed using ``datetime.strptime``, and this\nconsequently defines the format strings which are allowed.\n\nParsing is tried using each format, in order, and the first format which\nparses successfully is used.\n\n:param formats: A list or tuple of date format strings, in the order in\n                which they should be tried. Defaults to\n                ``'%Y-%m-%d'``, ``'%Y-%m-%dT%H:%M:%S'``,\n                ``'%Y-%m-%d %H:%M:%S'``."
        },
        {
          "name": "_NumberParamTypeBase",
          "methods": [
            "convert"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 472,
          "docstring": null
        },
        {
          "name": "_NumberRangeBase",
          "methods": [
            "__init__",
            "to_info_dict",
            "convert",
            "_clamp",
            "_describe_range",
            "__repr__"
          ],
          "base_classes": [
            "_NumberParamTypeBase"
          ],
          "lineno": 490,
          "docstring": null
        },
        {
          "name": "IntParamType",
          "methods": [
            "__repr__"
          ],
          "base_classes": [
            "_NumberParamTypeBase"
          ],
          "lineno": 576,
          "docstring": null
        },
        {
          "name": "IntRange",
          "methods": [
            "_clamp"
          ],
          "base_classes": [
            "_NumberRangeBase",
            "IntParamType"
          ],
          "lineno": 584,
          "docstring": "Restrict an :data:`click.INT` value to a range of accepted\nvalues. See :ref:`ranges`.\n\nIf ``min`` or ``max`` are not passed, any value is accepted in that\ndirection. If ``min_open`` or ``max_open`` are enabled, the\ncorresponding boundary is not included in the range.\n\nIf ``clamp`` is enabled, a value outside the range is clamped to the\nboundary instead of failing.\n\n.. versionchanged:: 8.0\n    Added the ``min_open`` and ``max_open`` parameters."
        },
        {
          "name": "FloatParamType",
          "methods": [
            "__repr__"
          ],
          "base_classes": [
            "_NumberParamTypeBase"
          ],
          "lineno": 610,
          "docstring": null
        },
        {
          "name": "FloatRange",
          "methods": [
            "__init__",
            "_clamp"
          ],
          "base_classes": [
            "_NumberRangeBase",
            "FloatParamType"
          ],
          "lineno": 618,
          "docstring": "Restrict a :data:`click.FLOAT` value to a range of accepted\nvalues. See :ref:`ranges`.\n\nIf ``min`` or ``max`` are not passed, any value is accepted in that\ndirection. If ``min_open`` or ``max_open`` are enabled, the\ncorresponding boundary is not included in the range.\n\nIf ``clamp`` is enabled, a value outside the range is clamped to the\nboundary instead of failing. This is not supported if either\nboundary is marked ``open``.\n\n.. versionchanged:: 8.0\n    Added the ``min_open`` and ``max_open`` parameters."
        },
        {
          "name": "BoolParamType",
          "methods": [
            "str_to_bool",
            "convert",
            "__repr__"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 661,
          "docstring": null
        },
        {
          "name": "UUIDParameterType",
          "methods": [
            "convert",
            "__repr__"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 730,
          "docstring": null
        },
        {
          "name": "File",
          "methods": [
            "__init__",
            "to_info_dict",
            "resolve_lazy_flag",
            "convert",
            "shell_complete"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 754,
          "docstring": "Declares a parameter to be a file for reading or writing.  The file\nis automatically closed once the context tears down (after the command\nfinished working).\n\nFiles can be opened for reading or writing.  The special value ``-``\nindicates stdin or stdout depending on the mode.\n\nBy default, the file is opened for reading text data, but it can also be\nopened in binary mode or for writing.  The encoding parameter can be used\nto force a specific encoding.\n\nThe `lazy` flag controls if the file should be opened immediately or upon\nfirst IO. The default is to be non-lazy for standard input and output\nstreams as well as files opened for reading, `lazy` otherwise. When opening a\nfile lazily for reading, it is still opened temporarily for validation, but\nwill not be held open until first IO. lazy is mainly useful when opening\nfor writing to avoid creating the file until it is needed.\n\nFiles can also be opened atomically in which case all writes go into a\nseparate file in the same folder and upon completion the file will\nbe moved over to the original location.  This is useful if a file\nregularly read by other users is modified.\n\nSee :ref:`file-args` for more information.\n\n.. versionchanged:: 2.0\n    Added the ``atomic`` parameter."
        },
        {
          "name": "Path",
          "methods": [
            "__init__",
            "to_info_dict",
            "coerce_path_result",
            "convert",
            "shell_complete"
          ],
          "base_classes": [
            "ParamType"
          ],
          "lineno": 879,
          "docstring": "The ``Path`` type is similar to the :class:`File` type, but\nreturns the filename instead of an open file. Various checks can be\nenabled to validate the type of file and permissions.\n\n:param exists: The file or directory needs to exist for the value to\n    be valid. If this is not set to ``True``, and the file does not\n    exist, then all further checks are silently skipped.\n:param file_okay: Allow a file as a value.\n:param dir_okay: Allow a directory as a value.\n:param readable: if true, a readable check is performed.\n:param writable: if true, a writable check is performed.\n:param executable: if true, an executable check is performed.\n:param resolve_path: Make the value absolute and resolve any\n    symlinks. A ``~`` is not expanded, as this is supposed to be\n    done by the shell only.\n:param allow_dash: Allow a single dash as a value, which indicates\n    a standard stream (but does not open it). Use\n    :func:`~click.open_file` to handle opening this value.\n:param path_type: Convert the incoming path value to this type. If\n    ``None``, keep Python's default, which is ``str``. Useful to\n    convert to :class:`pathlib.Path`.\n\n.. versionchanged:: 8.1\n    Added the ``executable`` parameter.\n\n.. versionchanged:: 8.0\n    Allow passing ``path_type=pathlib.Path``.\n\n.. versionchanged:: 6.0\n    Added the ``allow_dash`` parameter."
        },
        {
          "name": "Tuple",
          "methods": [
            "__init__",
            "to_info_dict",
            "name",
            "arity",
            "convert"
          ],
          "base_classes": [
            "CompositeParamType"
          ],
          "lineno": 1060,
          "docstring": "The default behavior of Click is to apply a type on a value directly.\nThis works well in most cases, except for when `nargs` is set to a fixed\ncount and different types should be used for different items.  In this\ncase the :class:`Tuple` type can be used.  This type can only be used\nif `nargs` is set to a fixed number.\n\nFor more information see :ref:`tuple-type`.\n\nThis can be selected by using a Python tuple literal as a type.\n\n:param types: a list of types that should be used for the tuple items."
        },
        {
          "name": "OptionHelpExtra",
          "methods": [],
          "base_classes": [
            "t.TypedDict"
          ],
          "lineno": 1205,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "enum",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "stat",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "datetime",
          "name": "datetime",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "gettext",
          "alias": "_",
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "gettext",
          "name": "ngettext",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "_get_argv_encoding",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "open_stream",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "BadParameter",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "format_filename",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "LazyFile",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "safecall",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "typing_extensions",
          "alias": "te",
          "lineno": 21,
          "type": "import"
        },
        {
          "module": "core",
          "name": "Context",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "core",
          "name": "Parameter",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "click.shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 388,
          "type": "from_import"
        },
        {
          "module": "operator",
          "alias": null,
          "lineno": 519,
          "type": "import"
        },
        {
          "module": "uuid",
          "alias": null,
          "lineno": 736,
          "type": "import"
        },
        {
          "module": "click.shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 870,
          "type": "from_import"
        },
        {
          "module": "click.shell_completion",
          "name": "CompletionItem",
          "alias": null,
          "lineno": 1054,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "ParamTypeValue",
          "assigned_to": "t.TypeVar",
          "lineno": 27
        },
        {
          "name": "UNPROCESSED",
          "assigned_to": "UnprocessedParamType",
          "lineno": 1183
        },
        {
          "name": "STRING",
          "assigned_to": "StringParamType",
          "lineno": 1187
        },
        {
          "name": "INT",
          "assigned_to": "IntParamType",
          "lineno": 1191
        },
        {
          "name": "FLOAT",
          "assigned_to": "FloatParamType",
          "lineno": 1195
        },
        {
          "name": "BOOL",
          "assigned_to": "BoolParamType",
          "lineno": 1199
        },
        {
          "name": "UUID",
          "assigned_to": "UUIDParameterType",
          "lineno": 1202
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "FloatParamType",
          "IntParamType",
          "BoolParamType",
          "StringParamType",
          "t.TypeVar",
          "UUIDParameterType",
          "UnprocessedParamType"
        ],
        "class_instantiations": [
          "FloatParamType",
          "IntParamType",
          "BoolParamType",
          "StringParamType",
          "UUIDParameterType",
          "UnprocessedParamType"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "sys",
          "datetime",
          "typing",
          "os",
          "enum",
          "collections"
        ],
        "third_party": {
          "other": [
            "__future__",
            "stat",
            "gettext",
            "_compat",
            "exceptions",
            "utils",
            "typing_extensions",
            "core",
            "shell_completion",
            "click",
            "operator",
            "uuid"
          ]
        },
        "tech_stack": []
      },
      "line_count": 1210
    },
    "src/click/utils.py": {
      "filepath": "../click/src/click/utils.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_posixify",
          "args": [
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 32,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.lower",
            "unknown.join",
            "name.split"
          ],
          "docstring": null,
          "code": "def _posixify(name: str) -> str:\n    return \"-\".join(name.split()).lower()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "safecall",
          "args": [
            {
              "name": "func",
              "type": "t.Callable[P, R]"
            }
          ],
          "return_type": "t.Callable[P, Any]",
          "lineno": 36,
          "decorators": [],
          "is_async": false,
          "calls": [
            "wrapper",
            "update_wrapper",
            "kwargs",
            "func"
          ],
          "docstring": "Wraps a function so that it swallows exceptions.",
          "code": "def safecall(func: t.Callable[P, R]) -> t.Callable[P, R | None]:\n    \"\"\"Wraps a function so that it swallows exceptions.\"\"\"\n\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R | None:\n        try:\n            return func(*args, **kwargs)\n        except Exception:\n            pass\n        return None\n\n    return update_wrapper(wrapper, func)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "make_str",
          "args": [
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "str",
          "lineno": 49,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value.decode",
            "value",
            "str",
            "bytes",
            "isinstance",
            "sys.getfilesystemencoding"
          ],
          "docstring": "Converts a value into a valid string.",
          "code": "def make_str(value: t.Any) -> str:\n    \"\"\"Converts a value into a valid string.\"\"\"\n    if isinstance(value, bytes):\n        try:\n            return value.decode(sys.getfilesystemencoding())\n        except UnicodeError:\n            return value.decode(\"utf-8\", \"replace\")\n    return str(value)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "make_default_short_help",
          "args": [
            {
              "name": "help",
              "type": "str"
            },
            {
              "name": "max_length",
              "type": "int"
            }
          ],
          "return_type": "str",
          "lineno": 59,
          "decorators": [],
          "is_async": false,
          "calls": [
            "enumerate",
            "help.find",
            "unknown.join",
            "words",
            "word",
            "len",
            "help.split"
          ],
          "docstring": "Returns a condensed version of help string.",
          "code": "def make_default_short_help(help: str, max_length: int = 45) -> str:\n    \"\"\"Returns a condensed version of help string.\"\"\"\n    # Consider only the first paragraph.\n    paragraph_end = help.find(\"\\n\\n\")\n\n    if paragraph_end != -1:\n        help = help[:paragraph_end]\n\n    # Collapse newlines, tabs, and spaces.\n    words = help.split()\n\n    if not words:\n        return \"\"\n\n    # The first paragraph started with a \"no rewrap\" marker, ignore it.\n    if words[0] == \"\\b\":\n        words = words[1:]\n\n    total_length = 0\n    last_index = len(words) - 1\n\n    for i, word in enumerate(words):\n        total_length += len(word) + (i > 0)\n\n        if total_length > max_length:  # too long, truncate\n            break\n\n        if word[-1] == \".\":  # sentence end, truncate without \"...\"\n            return \" \".join(words[: i + 1])\n\n        if total_length == max_length and i != last_index:\n            break  # not at sentence end, truncate with \"...\"\n    else:\n        return \" \".join(words)  # no truncation needed\n\n    # Account for the length of the suffix.\n    total_length += len(\"...\")\n\n    # remove words until the length is short enough\n    while i > 0:\n        total_length -= len(words[i]) + (i > 0)\n\n        if total_length <= max_length:\n            break\n\n        i -= 1\n\n    return \" \".join(words[:i]) + \"...\"",
          "line_count": 48,
          "needs_llm_summary": true
        },
        {
          "name": "echo",
          "args": [
            {
              "name": "message",
              "type": "Any"
            },
            {
              "name": "file",
              "type": "Any"
            },
            {
              "name": "nl",
              "type": "bool"
            },
            {
              "name": "err",
              "type": "bool"
            },
            {
              "name": "color",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 222,
          "decorators": [],
          "is_async": false,
          "calls": [
            "out",
            "strip_ansi",
            "message",
            "binary_file.write",
            "str",
            "file",
            "_default_text_stderr",
            "file.write",
            "file.flush",
            "resolve_color_default",
            "should_strip_ansi",
            "isinstance",
            "_default_text_stdout",
            "color",
            "binary_file.flush",
            "auto_wrap_for_ansi",
            "_find_binary_writer"
          ],
          "docstring": "Print a message and newline to stdout or a file. This should be\nused instead of :func:`print` because it provides better support\nfor different data, files, and environments.\n\nCompared to :func:`print`, this does the following:\n\n-   Ensures that the output encoding is not misconfigured on Linux.\n-   Supports Unicode in the Windows console.\n-   Supports writing to binary outputs, and supports writing bytes\n    to text outputs.\n-   Supports colors and styles on Windows.\n-   Removes ANSI color and style codes if the output does not look\n    like an interactive terminal.\n-   Always flushes the output.\n\n:param message: The string or bytes to output. Other objects are\n    converted to strings.\n:param file: The file to write to. Defaults to ``stdout``.\n:param err: Write to ``stderr`` instead of ``stdout``.\n:param nl: Print a newline after the message. Enabled by default.\n:param color: Force showing or hiding colors and other styles. By\n    default Click will remove color if the output does not look like\n    an interactive terminal.\n\n.. versionchanged:: 6.0\n    Support Unicode output on the Windows console. Click does not\n    modify ``sys.stdout``, so ``sys.stdout.write()`` and ``print()``\n    will still not support Unicode.\n\n.. versionchanged:: 4.0\n    Added the ``color`` parameter.\n\n.. versionadded:: 3.0\n    Added the ``err`` parameter.\n\n.. versionchanged:: 2.0\n    Support colors on Windows if colorama is installed.",
          "code": "def echo(\n    message: t.Any | None = None,\n    file: t.IO[t.Any] | None = None,\n    nl: bool = True,\n    err: bool = False,\n    color: bool | None = None,\n) -> None:\n    \"\"\"Print a message and newline to stdout or a file. This should be\n    used instead of :func:`print` because it provides better support\n    for different data, files, and environments.\n\n    Compared to :func:`print`, this does the following:\n\n    -   Ensures that the output encoding is not misconfigured on Linux.\n    -   Supports Unicode in the Windows console.\n    -   Supports writing to binary outputs, and supports writing bytes\n        to text outputs.\n    -   Supports colors and styles on Windows.\n    -   Removes ANSI color and style codes if the output does not look\n        like an interactive terminal.\n    -   Always flushes the output.\n\n    :param message: The string or bytes to output. Other objects are\n        converted to strings.\n    :param file: The file to write to. Defaults to ``stdout``.\n    :param err: Write to ``stderr`` instead of ``stdout``.\n    :param nl: Print a newline after the message. Enabled by default.\n    :param color: Force showing or hiding colors and other styles. By\n        default Click will remove color if the output does not look like\n        an interactive terminal.\n\n    .. versionchanged:: 6.0\n        Support Unicode output on the Windows console. Click does not\n        modify ``sys.stdout``, so ``sys.stdout.write()`` and ``print()``\n        will still not support Unicode.\n\n    .. versionchanged:: 4.0\n        Added the ``color`` parameter.\n\n    .. versionadded:: 3.0\n        Added the ``err`` parameter.\n\n    .. versionchanged:: 2.0\n        Support colors on Windows if colorama is installed.\n    \"\"\"\n    if file is None:\n        if err:\n            file = _default_text_stderr()\n        else:\n            file = _default_text_stdout()\n\n        # There are no standard streams attached to write to. For example,\n        # pythonw on Windows.\n        if file is None:\n            return\n\n    # Convert non bytes/text into the native string type.\n    if message is not None and not isinstance(message, (str, bytes, bytearray)):\n        out: str | bytes | bytearray | None = str(message)\n    else:\n        out = message\n\n    if nl:\n        out = out or \"\"\n        if isinstance(out, str):\n            out += \"\\n\"\n        else:\n            out += b\"\\n\"\n\n    if not out:\n        file.flush()\n        return\n\n    # If there is a message and the value looks like bytes, we manually\n    # need to find the binary stream and write the message in there.\n    # This is done separately so that most stream types will work as you\n    # would expect. Eg: you can write to StringIO for other cases.\n    if isinstance(out, (bytes, bytearray)):\n        binary_file = _find_binary_writer(file)\n\n        if binary_file is not None:\n            file.flush()\n            binary_file.write(out)\n            binary_file.flush()\n            return\n\n    # ANSI style code support. For no message or bytes, nothing happens.\n    # When outputting to a file instead of a terminal, strip codes.\n    else:\n        color = resolve_color_default(color)\n\n        if should_strip_ansi(file, color):\n            out = strip_ansi(out)\n        elif WIN:\n            if auto_wrap_for_ansi is not None:\n                file = auto_wrap_for_ansi(file, color)  # type: ignore\n            elif not color:\n                out = strip_ansi(out)\n\n    file.write(out)  # type: ignore\n    file.flush()",
          "line_count": 101,
          "needs_llm_summary": true
        },
        {
          "name": "get_binary_stream",
          "args": [
            {
              "name": "name",
              "type": "t.Literal[stdin, stdout, stderr]"
            }
          ],
          "return_type": "t.BinaryIO",
          "lineno": 325,
          "decorators": [],
          "is_async": false,
          "calls": [
            "TypeError",
            "name",
            "opener",
            "binary_streams.get"
          ],
          "docstring": "Returns a system stream for byte processing.\n\n:param name: the name of the stream to open.  Valid names are ``'stdin'``,\n             ``'stdout'`` and ``'stderr'``",
          "code": "def get_binary_stream(name: t.Literal[\"stdin\", \"stdout\", \"stderr\"]) -> t.BinaryIO:\n    \"\"\"Returns a system stream for byte processing.\n\n    :param name: the name of the stream to open.  Valid names are ``'stdin'``,\n                 ``'stdout'`` and ``'stderr'``\n    \"\"\"\n    opener = binary_streams.get(name)\n    if opener is None:\n        raise TypeError(f\"Unknown standard stream '{name}'\")\n    return opener()",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "get_text_stream",
          "args": [
            {
              "name": "name",
              "type": "t.Literal[stdin, stdout, stderr]"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            }
          ],
          "return_type": "t.TextIO",
          "lineno": 337,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "text_streams.get",
            "TypeError",
            "errors",
            "opener",
            "encoding"
          ],
          "docstring": "Returns a system stream for text processing.  This usually returns\na wrapped stream around a binary stream returned from\n:func:`get_binary_stream` but it also can take shortcuts for already\ncorrectly configured streams.\n\n:param name: the name of the stream to open.  Valid names are ``'stdin'``,\n             ``'stdout'`` and ``'stderr'``\n:param encoding: overrides the detected default encoding.\n:param errors: overrides the default error mode.",
          "code": "def get_text_stream(\n    name: t.Literal[\"stdin\", \"stdout\", \"stderr\"],\n    encoding: str | None = None,\n    errors: str | None = \"strict\",\n) -> t.TextIO:\n    \"\"\"Returns a system stream for text processing.  This usually returns\n    a wrapped stream around a binary stream returned from\n    :func:`get_binary_stream` but it also can take shortcuts for already\n    correctly configured streams.\n\n    :param name: the name of the stream to open.  Valid names are ``'stdin'``,\n                 ``'stdout'`` and ``'stderr'``\n    :param encoding: overrides the detected default encoding.\n    :param errors: overrides the default error mode.\n    \"\"\"\n    opener = text_streams.get(name)\n    if opener is None:\n        raise TypeError(f\"Unknown standard stream '{name}'\")\n    return opener(encoding, errors)",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "open_file",
          "args": [
            {
              "name": "filename",
              "type": "Any"
            },
            {
              "name": "mode",
              "type": "str"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "lazy",
              "type": "bool"
            },
            {
              "name": "atomic",
              "type": "bool"
            }
          ],
          "return_type": "t.IO[t.Any]",
          "lineno": 358,
          "decorators": [],
          "is_async": false,
          "calls": [
            "filename",
            "open_stream",
            "mode",
            "LazyFile",
            "atomic",
            "t.cast",
            "f",
            "errors",
            "KeepOpenFile",
            "encoding"
          ],
          "docstring": "Open a file, with extra behavior to handle ``'-'`` to indicate\na standard stream, lazy open on write, and atomic write. Similar to\nthe behavior of the :class:`~click.File` param type.\n\nIf ``'-'`` is given to open ``stdout`` or ``stdin``, the stream is\nwrapped so that using it in a context manager will not close it.\nThis makes it possible to use the function without accidentally\nclosing a standard stream:\n\n.. code-block:: python\n\n    with open_file(filename) as f:\n        ...\n\n:param filename: The name or Path of the file to open, or ``'-'`` for\n    ``stdin``/``stdout``.\n:param mode: The mode in which to open the file.\n:param encoding: The encoding to decode or encode a file opened in\n    text mode.\n:param errors: The error handling mode.\n:param lazy: Wait to open the file until it is accessed. For read\n    mode, the file is temporarily opened to raise access errors\n    early, then closed until it is read again.\n:param atomic: Write to a temporary file and replace the given file\n    on close.\n\n.. versionadded:: 3.0",
          "code": "def open_file(\n    filename: str | os.PathLike[str],\n    mode: str = \"r\",\n    encoding: str | None = None,\n    errors: str | None = \"strict\",\n    lazy: bool = False,\n    atomic: bool = False,\n) -> t.IO[t.Any]:\n    \"\"\"Open a file, with extra behavior to handle ``'-'`` to indicate\n    a standard stream, lazy open on write, and atomic write. Similar to\n    the behavior of the :class:`~click.File` param type.\n\n    If ``'-'`` is given to open ``stdout`` or ``stdin``, the stream is\n    wrapped so that using it in a context manager will not close it.\n    This makes it possible to use the function without accidentally\n    closing a standard stream:\n\n    .. code-block:: python\n\n        with open_file(filename) as f:\n            ...\n\n    :param filename: The name or Path of the file to open, or ``'-'`` for\n        ``stdin``/``stdout``.\n    :param mode: The mode in which to open the file.\n    :param encoding: The encoding to decode or encode a file opened in\n        text mode.\n    :param errors: The error handling mode.\n    :param lazy: Wait to open the file until it is accessed. For read\n        mode, the file is temporarily opened to raise access errors\n        early, then closed until it is read again.\n    :param atomic: Write to a temporary file and replace the given file\n        on close.\n\n    .. versionadded:: 3.0\n    \"\"\"\n    if lazy:\n        return t.cast(\n            \"t.IO[t.Any]\", LazyFile(filename, mode, encoding, errors, atomic=atomic)\n        )\n\n    f, should_close = open_stream(filename, mode, encoding, errors, atomic=atomic)\n\n    if not should_close:\n        f = t.cast(\"t.IO[t.Any]\", KeepOpenFile(f))\n\n    return f",
          "line_count": 47,
          "needs_llm_summary": true
        },
        {
          "name": "format_filename",
          "args": [
            {
              "name": "filename",
              "type": "Any"
            },
            {
              "name": "shorten",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "lineno": 407,
          "decorators": [],
          "is_async": false,
          "calls": [
            "filename",
            "bytes",
            "filename.encode",
            "filename.decode",
            "isinstance",
            "sys.getfilesystemencoding",
            "os.path.basename",
            "unknown.decode",
            "os.fspath"
          ],
          "docstring": "Format a filename as a string for display. Ensures the filename can be\ndisplayed by replacing any invalid bytes or surrogate escapes in the name\nwith the replacement character ``\ufffd``.\n\nInvalid bytes or surrogate escapes will raise an error when written to a\nstream with ``errors=\"strict\"``. This will typically happen with ``stdout``\nwhen the locale is something like ``en_GB.UTF-8``.\n\nMany scenarios *are* safe to write surrogates though, due to PEP 538 and\nPEP 540, including:\n\n-   Writing to ``stderr``, which uses ``errors=\"backslashreplace\"``.\n-   The system has ``LANG=C.UTF-8``, ``C``, or ``POSIX``. Python opens\n    stdout and stderr with ``errors=\"surrogateescape\"``.\n-   None of ``LANG/LC_*`` are set. Python assumes ``LANG=C.UTF-8``.\n-   Python is started in UTF-8 mode  with  ``PYTHONUTF8=1`` or ``-X utf8``.\n    Python opens stdout and stderr with ``errors=\"surrogateescape\"``.\n\n:param filename: formats a filename for UI display.  This will also convert\n                 the filename into unicode without failing.\n:param shorten: this optionally shortens the filename to strip of the\n                path that leads up to it.",
          "code": "def format_filename(\n    filename: str | bytes | os.PathLike[str] | os.PathLike[bytes],\n    shorten: bool = False,\n) -> str:\n    \"\"\"Format a filename as a string for display. Ensures the filename can be\n    displayed by replacing any invalid bytes or surrogate escapes in the name\n    with the replacement character ``\ufffd``.\n\n    Invalid bytes or surrogate escapes will raise an error when written to a\n    stream with ``errors=\"strict\"``. This will typically happen with ``stdout``\n    when the locale is something like ``en_GB.UTF-8``.\n\n    Many scenarios *are* safe to write surrogates though, due to PEP 538 and\n    PEP 540, including:\n\n    -   Writing to ``stderr``, which uses ``errors=\"backslashreplace\"``.\n    -   The system has ``LANG=C.UTF-8``, ``C``, or ``POSIX``. Python opens\n        stdout and stderr with ``errors=\"surrogateescape\"``.\n    -   None of ``LANG/LC_*`` are set. Python assumes ``LANG=C.UTF-8``.\n    -   Python is started in UTF-8 mode  with  ``PYTHONUTF8=1`` or ``-X utf8``.\n        Python opens stdout and stderr with ``errors=\"surrogateescape\"``.\n\n    :param filename: formats a filename for UI display.  This will also convert\n                     the filename into unicode without failing.\n    :param shorten: this optionally shortens the filename to strip of the\n                    path that leads up to it.\n    \"\"\"\n    if shorten:\n        filename = os.path.basename(filename)\n    else:\n        filename = os.fspath(filename)\n\n    if isinstance(filename, bytes):\n        filename = filename.decode(sys.getfilesystemencoding(), \"replace\")\n    else:\n        filename = filename.encode(\"utf-8\", \"surrogateescape\").decode(\n            \"utf-8\", \"replace\"\n        )\n\n    return filename",
          "line_count": 40,
          "needs_llm_summary": true
        },
        {
          "name": "get_app_dir",
          "args": [
            {
              "name": "app_name",
              "type": "str"
            },
            {
              "name": "roaming",
              "type": "bool"
            },
            {
              "name": "force_posix",
              "type": "bool"
            }
          ],
          "return_type": "str",
          "lineno": 449,
          "decorators": [],
          "is_async": false,
          "calls": [
            "key",
            "os.path.join",
            "os.environ.get",
            "app_name",
            "os.path.expanduser",
            "_posixify",
            "folder"
          ],
          "docstring": "Returns the config folder for the application.  The default behavior\nis to return whatever is most appropriate for the operating system.\n\nTo give you an idea, for an app called ``\"Foo Bar\"``, something like\nthe following folders could be returned:\n\nMac OS X:\n  ``~/Library/Application Support/Foo Bar``\nMac OS X (POSIX):\n  ``~/.foo-bar``\nUnix:\n  ``~/.config/foo-bar``\nUnix (POSIX):\n  ``~/.foo-bar``\nWindows (roaming):\n  ``C:\\Users\\<user>\\AppData\\Roaming\\Foo Bar``\nWindows (not roaming):\n  ``C:\\Users\\<user>\\AppData\\Local\\Foo Bar``\n\n.. versionadded:: 2.0\n\n:param app_name: the application name.  This should be properly capitalized\n                 and can contain whitespace.\n:param roaming: controls if the folder should be roaming or not on Windows.\n                Has no effect otherwise.\n:param force_posix: if this is set to `True` then on any POSIX system the\n                    folder will be stored in the home folder with a leading\n                    dot instead of the XDG config home or darwin's\n                    application support folder.",
          "code": "def get_app_dir(app_name: str, roaming: bool = True, force_posix: bool = False) -> str:\n    r\"\"\"Returns the config folder for the application.  The default behavior\n    is to return whatever is most appropriate for the operating system.\n\n    To give you an idea, for an app called ``\"Foo Bar\"``, something like\n    the following folders could be returned:\n\n    Mac OS X:\n      ``~/Library/Application Support/Foo Bar``\n    Mac OS X (POSIX):\n      ``~/.foo-bar``\n    Unix:\n      ``~/.config/foo-bar``\n    Unix (POSIX):\n      ``~/.foo-bar``\n    Windows (roaming):\n      ``C:\\Users\\<user>\\AppData\\Roaming\\Foo Bar``\n    Windows (not roaming):\n      ``C:\\Users\\<user>\\AppData\\Local\\Foo Bar``\n\n    .. versionadded:: 2.0\n\n    :param app_name: the application name.  This should be properly capitalized\n                     and can contain whitespace.\n    :param roaming: controls if the folder should be roaming or not on Windows.\n                    Has no effect otherwise.\n    :param force_posix: if this is set to `True` then on any POSIX system the\n                        folder will be stored in the home folder with a leading\n                        dot instead of the XDG config home or darwin's\n                        application support folder.\n    \"\"\"\n    if WIN:\n        key = \"APPDATA\" if roaming else \"LOCALAPPDATA\"\n        folder = os.environ.get(key)\n        if folder is None:\n            folder = os.path.expanduser(\"~\")\n        return os.path.join(folder, app_name)\n    if force_posix:\n        return os.path.join(os.path.expanduser(f\"~/.{_posixify(app_name)}\"))\n    if sys.platform == \"darwin\":\n        return os.path.join(\n            os.path.expanduser(\"~/Library/Application Support\"), app_name\n        )\n    return os.path.join(\n        os.environ.get(\"XDG_CONFIG_HOME\", os.path.expanduser(\"~/.config\")),\n        _posixify(app_name),\n    )",
          "line_count": 47,
          "needs_llm_summary": true
        },
        {
          "name": "_detect_program_name",
          "args": [
            {
              "name": "path",
              "type": "Any"
            },
            {
              "name": "_main",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 523,
          "decorators": [],
          "is_async": false,
          "calls": [
            "path",
            "_main",
            "str",
            "os.path.exists",
            "py_module.lstrip",
            "os.path.splitext",
            "t.cast",
            "os.path.basename",
            "_main.__package__",
            "getattr"
          ],
          "docstring": "Determine the command used to run the program, for use in help\ntext. If a file or entry point was executed, the file name is\nreturned. If ``python -m`` was used to execute a module or package,\n``python -m name`` is returned.\n\nThis doesn't try to be too precise, the goal is to give a concise\nname for help text. Files are only shown as their name without the\npath. ``python`` is only shown for modules, and the full path to\n``sys.executable`` is not shown.\n\n:param path: The Python file being executed. Python puts this in\n    ``sys.argv[0]``, which is used by default.\n:param _main: The ``__main__`` module. This should only be passed\n    during internal testing.\n\n.. versionadded:: 8.0\n    Based on command args detection in the Werkzeug reloader.\n\n:meta private:",
          "code": "def _detect_program_name(\n    path: str | None = None, _main: ModuleType | None = None\n) -> str:\n    \"\"\"Determine the command used to run the program, for use in help\n    text. If a file or entry point was executed, the file name is\n    returned. If ``python -m`` was used to execute a module or package,\n    ``python -m name`` is returned.\n\n    This doesn't try to be too precise, the goal is to give a concise\n    name for help text. Files are only shown as their name without the\n    path. ``python`` is only shown for modules, and the full path to\n    ``sys.executable`` is not shown.\n\n    :param path: The Python file being executed. Python puts this in\n        ``sys.argv[0]``, which is used by default.\n    :param _main: The ``__main__`` module. This should only be passed\n        during internal testing.\n\n    .. versionadded:: 8.0\n        Based on command args detection in the Werkzeug reloader.\n\n    :meta private:\n    \"\"\"\n    if _main is None:\n        _main = sys.modules[\"__main__\"]\n\n    if not path:\n        path = sys.argv[0]\n\n    # The value of __package__ indicates how Python was called. It may\n    # not exist if a setuptools script is installed as an egg. It may be\n    # set incorrectly for entry points created with pip on Windows.\n    # It is set to \"\" inside a Shiv or PEX zipapp.\n    if getattr(_main, \"__package__\", None) in {None, \"\"} or (\n        os.name == \"nt\"\n        and _main.__package__ == \"\"\n        and not os.path.exists(path)\n        and os.path.exists(f\"{path}.exe\")\n    ):\n        # Executed a file, like \"python app.py\".\n        return os.path.basename(path)\n\n    # Executed a module, like \"python -m example\".\n    # Rewritten by Python from \"-m script\" to \"/path/to/script.py\".\n    # Need to look at main module to determine how it was executed.\n    py_module = t.cast(str, _main.__package__)\n    name = os.path.splitext(os.path.basename(path))[0]\n\n    # A submodule like \"example.cli\".\n    if name != \"__main__\":\n        py_module = f\"{py_module}.{name}\"\n\n    return f\"python -m {py_module.lstrip('.')}\"",
          "line_count": 53,
          "needs_llm_summary": true
        },
        {
          "name": "_expand_args",
          "args": [
            {
              "name": "args",
              "type": "cabc.Iterable[str]"
            }
          ],
          "return_type": "list[str]",
          "lineno": 578,
          "decorators": [],
          "is_async": false,
          "calls": [
            "arg",
            "os.path.expanduser",
            "glob_recursive",
            "os.path.expandvars",
            "glob",
            "matches",
            "out.append",
            "out.extend"
          ],
          "docstring": "Simulate Unix shell expansion with Python functions.\n\nSee :func:`glob.glob`, :func:`os.path.expanduser`, and\n:func:`os.path.expandvars`.\n\nThis is intended for use on Windows, where the shell does not do any\nexpansion. It may not exactly match what a Unix shell would do.\n\n:param args: List of command line arguments to expand.\n:param user: Expand user home directory.\n:param env: Expand environment variables.\n:param glob_recursive: ``**`` matches directories recursively.\n\n.. versionchanged:: 8.1\n    Invalid glob patterns are treated as empty expansions rather\n    than raising an error.\n\n.. versionadded:: 8.0\n\n:meta private:",
          "code": "def _expand_args(\n    args: cabc.Iterable[str],\n    *,\n    user: bool = True,\n    env: bool = True,\n    glob_recursive: bool = True,\n) -> list[str]:\n    \"\"\"Simulate Unix shell expansion with Python functions.\n\n    See :func:`glob.glob`, :func:`os.path.expanduser`, and\n    :func:`os.path.expandvars`.\n\n    This is intended for use on Windows, where the shell does not do any\n    expansion. It may not exactly match what a Unix shell would do.\n\n    :param args: List of command line arguments to expand.\n    :param user: Expand user home directory.\n    :param env: Expand environment variables.\n    :param glob_recursive: ``**`` matches directories recursively.\n\n    .. versionchanged:: 8.1\n        Invalid glob patterns are treated as empty expansions rather\n        than raising an error.\n\n    .. versionadded:: 8.0\n\n    :meta private:\n    \"\"\"\n    from glob import glob\n\n    out = []\n\n    for arg in args:\n        if user:\n            arg = os.path.expanduser(arg)\n\n        if env:\n            arg = os.path.expandvars(arg)\n\n        try:\n            matches = glob(arg, recursive=glob_recursive)\n        except re.error:\n            matches = []\n\n        if not matches:\n            out.append(arg)\n        else:\n            out.extend(matches)\n\n    return out",
          "line_count": 50,
          "needs_llm_summary": true
        },
        {
          "name": "wrapper",
          "args": [],
          "return_type": "Any",
          "lineno": 39,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "func"
          ],
          "docstring": null,
          "code": "def wrapper(*args: P.args, **kwargs: P.kwargs) -> R | None:\n        try:\n            return func(*args, **kwargs)\n        except Exception:\n            pass\n        return None",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "Any"
            },
            {
              "name": "mode",
              "type": "str"
            },
            {
              "name": "encoding",
              "type": "Any"
            },
            {
              "name": "errors",
              "type": "Any"
            },
            {
              "name": "atomic",
              "type": "bool"
            }
          ],
          "return_type": null,
          "lineno": 116,
          "decorators": [],
          "is_async": false,
          "calls": [
            "filename",
            "open_stream",
            "mode",
            "encoding",
            "os.fspath",
            "errors",
            "open",
            "atomic",
            "unknown.close"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        filename: str | os.PathLike[str],\n        mode: str = \"r\",\n        encoding: str | None = None,\n        errors: str | None = \"strict\",\n        atomic: bool = False,\n    ):\n        self.name: str = os.fspath(filename)\n        self.mode = mode\n        self.encoding = encoding\n        self.errors = errors\n        self.atomic = atomic\n        self._f: t.IO[t.Any] | None\n        self.should_close: bool\n\n        if self.name == \"-\":\n            self._f, self.should_close = open_stream(filename, mode, encoding, errors)\n        else:\n            if \"r\" in mode:\n                # Open and close the file in case we're opening it for\n                # reading so that we can catch at least some errors in\n                # some cases early.\n                open(filename, mode).close()\n            self._f = None\n            self.should_close = True",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 143,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "self.open",
            "getattr"
          ],
          "docstring": null,
          "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self.open(), name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 146,
          "decorators": [],
          "is_async": false,
          "calls": [
            "repr",
            "self._f",
            "self.name",
            "format_filename"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        if self._f is not None:\n            return repr(self._f)\n        return f\"<unopened file '{format_filename(self.name)}' {self.mode}>\"",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "open",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.IO[t.Any]",
          "lineno": 151,
          "decorators": [],
          "is_async": false,
          "calls": [
            "open_stream",
            "self.encoding",
            "rv",
            "self.name",
            "self.mode",
            "self.errors",
            "FileError",
            "self.atomic",
            "e.strerror"
          ],
          "docstring": "Opens the file if it's not yet open.  This call might fail with\na :exc:`FileError`.  Not handling this error will produce an error\nthat Click shows.",
          "code": "def open(self) -> t.IO[t.Any]:\n        \"\"\"Opens the file if it's not yet open.  This call might fail with\n        a :exc:`FileError`.  Not handling this error will produce an error\n        that Click shows.\n        \"\"\"\n        if self._f is not None:\n            return self._f\n        try:\n            rv, self.should_close = open_stream(\n                self.name, self.mode, self.encoding, self.errors, atomic=self.atomic\n            )\n        except OSError as e:\n            from .exceptions import FileError\n\n            raise FileError(self.name, hint=e.strerror) from e\n        self._f = rv\n        return rv",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "close",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 169,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._f.close"
          ],
          "docstring": "Closes the underlying file, no matter what.",
          "code": "def close(self) -> None:\n        \"\"\"Closes the underlying file, no matter what.\"\"\"\n        if self._f is not None:\n            self._f.close()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "close_intelligently",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 174,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.close"
          ],
          "docstring": "This function only closes the file if it was opened by the lazy\nfile wrapper.  For instance this will never close stdin.",
          "code": "def close_intelligently(self) -> None:\n        \"\"\"This function only closes the file if it was opened by the lazy\n        file wrapper.  For instance this will never close stdin.\n        \"\"\"\n        if self.should_close:\n            self.close()",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "LazyFile",
          "lineno": 181,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __enter__(self) -> LazyFile:\n        return self",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc_type",
              "type": "Any"
            },
            {
              "name": "exc_value",
              "type": "Any"
            },
            {
              "name": "tb",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 184,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.close_intelligently"
          ],
          "docstring": null,
          "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.close_intelligently()",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__iter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "cabc.Iterator[t.AnyStr]",
          "lineno": 192,
          "decorators": [],
          "is_async": false,
          "calls": [
            "iter",
            "self.open",
            "self._f"
          ],
          "docstring": null,
          "code": "def __iter__(self) -> cabc.Iterator[t.AnyStr]:\n        self.open()\n        return iter(self._f)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "file",
              "type": "t.IO[t.Any]"
            }
          ],
          "return_type": "None",
          "lineno": 198,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __init__(self, file: t.IO[t.Any]) -> None:\n        self._file: t.IO[t.Any] = file",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 201,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "self._file",
            "getattr"
          ],
          "docstring": null,
          "code": "def __getattr__(self, name: str) -> t.Any:\n        return getattr(self._file, name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "KeepOpenFile",
          "lineno": 204,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __enter__(self) -> KeepOpenFile:\n        return self",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc_type",
              "type": "Any"
            },
            {
              "name": "exc_value",
              "type": "Any"
            },
            {
              "name": "tb",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 207,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        pass",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 215,
          "decorators": [],
          "is_async": false,
          "calls": [
            "repr",
            "self._file"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return repr(self._file)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__iter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "cabc.Iterator[t.AnyStr]",
          "lineno": 218,
          "decorators": [],
          "is_async": false,
          "calls": [
            "iter",
            "self._file"
          ],
          "docstring": null,
          "code": "def __iter__(self) -> cabc.Iterator[t.AnyStr]:\n        return iter(self._file)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "wrapped",
              "type": "t.IO[t.Any]"
            }
          ],
          "return_type": "None",
          "lineno": 507,
          "decorators": [],
          "is_async": false,
          "calls": [
            "wrapped"
          ],
          "docstring": null,
          "code": "def __init__(self, wrapped: t.IO[t.Any]) -> None:\n        self.wrapped = wrapped",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "flush",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 510,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.wrapped.flush"
          ],
          "docstring": null,
          "code": "def flush(self) -> None:\n        try:\n            self.wrapped.flush()\n        except OSError as e:\n            import errno\n\n            if e.errno != errno.EPIPE:\n                raise",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "attr",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 519,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.wrapped",
            "attr",
            "getattr"
          ],
          "docstring": null,
          "code": "def __getattr__(self, attr: str) -> t.Any:\n        return getattr(self.wrapped, attr)",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "LazyFile",
          "methods": [
            "__init__",
            "__getattr__",
            "__repr__",
            "open",
            "close",
            "close_intelligently",
            "__enter__",
            "__exit__",
            "__iter__"
          ],
          "base_classes": [],
          "lineno": 109,
          "docstring": "A lazy file works like a regular file but it does not fully open\nthe file but it does perform some basic checks early to see if the\nfilename parameter does make sense.  This is useful for safely opening\nfiles for writing."
        },
        {
          "name": "KeepOpenFile",
          "methods": [
            "__init__",
            "__getattr__",
            "__enter__",
            "__exit__",
            "__repr__",
            "__iter__"
          ],
          "base_classes": [],
          "lineno": 197,
          "docstring": null
        },
        {
          "name": "PacifyFlushWrapper",
          "methods": [
            "__init__",
            "flush",
            "__getattr__"
          ],
          "base_classes": [],
          "lineno": 498,
          "docstring": "This wrapper is used to catch and suppress BrokenPipeErrors resulting\nfrom ``.flush()`` being called on broken pipe during the shutdown/final-GC\nof the Python interpreter. Notably ``.flush()`` is always called on\n``sys.stdout`` and ``sys.stderr``. So as to have minimal impact on any\nother cleanup code, and the case where the underlying file is not a broken\npipe, all calls and attributes are proxied."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "re",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "ModuleType",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "TracebackType",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "_default_text_stderr",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "_default_text_stdout",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "_find_binary_writer",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "auto_wrap_for_ansi",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "binary_streams",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "open_stream",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "should_strip_ansi",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "strip_ansi",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "text_streams",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "_compat",
          "name": "WIN",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "resolve_color_default",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "typing_extensions",
          "alias": "te",
          "lineno": 25,
          "type": "import"
        },
        {
          "module": "glob",
          "name": "glob",
          "alias": null,
          "lineno": 606,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "FileError",
          "alias": null,
          "lineno": 163,
          "type": "from_import"
        },
        {
          "module": "errno",
          "alias": null,
          "lineno": 514,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "R",
          "assigned_to": "t.TypeVar",
          "lineno": 29
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar",
          "te.ParamSpec"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "re",
          "sys",
          "functools",
          "typing",
          "os",
          "glob",
          "collections"
        ],
        "third_party": {
          "other": [
            "__future__",
            "types",
            "_compat",
            "globals",
            "typing_extensions",
            "exceptions",
            "errno"
          ]
        },
        "tech_stack": []
      },
      "line_count": 628
    },
    "__analysis_summary__": {
      "total_modules": 31,
      "total_functions": 347,
      "total_classes": 78,
      "dead_code_candidates": {
        "unreferenced_functions": [
          {
            "name": "push",
            "module": "examples/aliases/aliases.py",
            "lineno": 102
          },
          {
            "name": "pull",
            "module": "examples/aliases/aliases.py",
            "lineno": 108
          },
          {
            "name": "clone",
            "module": "examples/aliases/aliases.py",
            "lineno": 114
          },
          {
            "name": "commit",
            "module": "examples/aliases/aliases.py",
            "lineno": 120
          },
          {
            "name": "status",
            "module": "examples/aliases/aliases.py",
            "lineno": 127
          },
          {
            "name": "alias",
            "module": "examples/aliases/aliases.py",
            "lineno": 139
          },
          {
            "name": "ls",
            "module": "examples/completion/completion.py",
            "lineno": 14
          },
          {
            "name": "show_env",
            "module": "examples/completion/completion.py",
            "lineno": 26
          },
          {
            "name": "select_user",
            "module": "examples/completion/completion.py",
            "lineno": 52
          },
          {
            "name": "process_commands",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 24
          },
          {
            "name": "open_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 84
          },
          {
            "name": "save_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 110
          },
          {
            "name": "display_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 123
          },
          {
            "name": "resize_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 135
          },
          {
            "name": "crop_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 151
          },
          {
            "name": "transpose_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 195
          },
          {
            "name": "blur_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 212
          },
          {
            "name": "smoothen_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 229
          },
          {
            "name": "emboss_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 243
          },
          {
            "name": "sharpen_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 255
          },
          {
            "name": "paste_cmd",
            "module": "examples/imagepipe/imagepipe.py",
            "lineno": 267
          },
          {
            "name": "ship",
            "module": "examples/naval/naval.py",
            "lineno": 16
          },
          {
            "name": "ship_new",
            "module": "examples/naval/naval.py",
            "lineno": 22
          },
          {
            "name": "ship_move",
            "module": "examples/naval/naval.py",
            "lineno": 32
          },
          {
            "name": "ship_shoot",
            "module": "examples/naval/naval.py",
            "lineno": 41
          },
          {
            "name": "mine",
            "module": "examples/naval/naval.py",
            "lineno": 47
          },
          {
            "name": "mine_set",
            "module": "examples/naval/naval.py",
            "lineno": 62
          },
          {
            "name": "mine_remove",
            "module": "examples/naval/naval.py",
            "lineno": 70
          },
          {
            "name": "clone",
            "module": "examples/repo/repo.py",
            "lineno": 72
          },
          {
            "name": "delete",
            "module": "examples/repo/repo.py",
            "lineno": 91
          },
          {
            "name": "setuser",
            "module": "examples/repo/repo.py",
            "lineno": 105
          },
          {
            "name": "commit",
            "module": "examples/repo/repo.py",
            "lineno": 126
          },
          {
            "name": "colordemo",
            "module": "examples/termui/termui.py",
            "lineno": 15
          },
          {
            "name": "progress",
            "module": "examples/termui/termui.py",
            "lineno": 38
          },
          {
            "name": "menu",
            "module": "examples/termui/termui.py",
            "lineno": 145
          },
          {
            "name": "get_binary_stderr",
            "module": "src/click/_compat.py",
            "lineno": 330
          },
          {
            "name": "seekable",
            "module": "src/click/_compat.py",
            "lineno": 140
          },
          {
            "name": "_handle_long_word",
            "module": "src/click/_textwrap.py",
            "lineno": 9
          },
          {
            "name": "_get_text_stdin",
            "module": "src/click/_winconsole.py",
            "lineno": 226
          },
          {
            "name": "_get_text_stdout",
            "module": "src/click/_winconsole.py",
            "lineno": 236
          },
          {
            "name": "_get_text_stderr",
            "module": "src/click/_winconsole.py",
            "lineno": 246
          },
          {
            "name": "readinto",
            "module": "src/click/_winconsole.py",
            "lineno": 131
          },
          {
            "name": "writelines",
            "module": "src/click/_winconsole.py",
            "lineno": 212
          },
          {
            "name": "with_resource",
            "module": "src/click/core.py",
            "lineno": 575
          },
          {
            "name": "add_source",
            "module": "src/click/core.py",
            "lineno": 1987
          },
          {
            "name": "pass_meta_key",
            "module": "src/click/decorators.py",
            "lineno": 100
          },
          {
            "name": "add_completion_class",
            "module": "src/click/shell_completion.py",
            "lineno": 436
          },
          {
            "name": "isolated_filesystem",
            "module": "src/click/testing.py",
            "lineno": 547
          }
        ],
        "unused_classes": [
          {
            "name": "Sentinel",
            "module": "src/click/_utils.py",
            "lineno": 7
          },
          {
            "name": "_WindowsConsoleRawIOBase",
            "module": "src/click/_winconsole.py",
            "lineno": 118
          },
          {
            "name": "ParameterSource",
            "module": "src/click/core.py",
            "lineno": 143
          },
          {
            "name": "_FakeSubclassCheck",
            "module": "src/click/core.py",
            "lineno": 1488
          },
          {
            "name": "ShellComplete",
            "module": "src/click/shell_completion.py",
            "lineno": 200
          },
          {
            "name": "BashComplete",
            "module": "src/click/shell_completion.py",
            "lineno": 304
          },
          {
            "name": "ZshComplete",
            "module": "src/click/shell_completion.py",
            "lineno": 363
          },
          {
            "name": "FishComplete",
            "module": "src/click/shell_completion.py",
            "lineno": 399
          },
          {
            "name": "CliRunner",
            "module": "src/click/testing.py",
            "lineno": 229
          },
          {
            "name": "CompositeParamType",
            "module": "src/click/types.py",
            "lineno": 163
          },
          {
            "name": "_NumberParamTypeBase",
            "module": "src/click/types.py",
            "lineno": 472
          },
          {
            "name": "_NumberRangeBase",
            "module": "src/click/types.py",
            "lineno": 490
          },
          {
            "name": "OptionHelpExtra",
            "module": "src/click/types.py",
            "lineno": 1205
          }
        ],
        "unused_imports": [
          {
            "module": "examples/complex/complex/commands/cmd_init.py",
            "import_statement": "import complex.cli",
            "lineno": 1,
            "imported_module": "complex.cli",
            "symbols": [
              "pass_environment"
            ],
            "needs_llm": false
          },
          {
            "module": "examples/complex/complex/commands/cmd_status.py",
            "import_statement": "import complex.cli",
            "lineno": 1,
            "imported_module": "complex.cli",
            "symbols": [
              "pass_environment"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_compat.py",
            "import_statement": "import collections.abc",
            "lineno": 4,
            "imported_module": "collections.abc",
            "symbols": [
              "cabc"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_compat.py",
            "import_statement": "import types",
            "lineno": 10,
            "imported_module": "types",
            "symbols": [
              "TracebackType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_compat.py",
            "import_statement": "import errno",
            "lineno": 413,
            "imported_module": "errno",
            "symbols": [
              "errno"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_termui_impl.py",
            "import_statement": "import contextlib",
            "lineno": 10,
            "imported_module": "contextlib",
            "symbols": [
              "contextlib"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_termui_impl.py",
            "import_statement": "import types",
            "lineno": 20,
            "imported_module": "types",
            "symbols": [
              "TracebackType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_termui_impl.py",
            "import_statement": "import _compat",
            "lineno": 23,
            "imported_module": "_compat",
            "symbols": [
              "CYGWIN"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_termui_impl.py",
            "import_statement": "import _compat",
            "lineno": 29,
            "imported_module": "_compat",
            "symbols": [
              "WIN"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_textwrap.py",
            "import_statement": "import contextlib",
            "lineno": 5,
            "imported_module": "contextlib",
            "symbols": [
              "contextmanager"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_winconsole.py",
            "import_statement": "import sys",
            "lineno": 13,
            "imported_module": "sys",
            "symbols": [
              "sys"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/_winconsole.py",
            "import_statement": "import ctypes",
            "lineno": 19,
            "imported_module": "ctypes",
            "symbols": [
              "c_char_p"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/core.py",
            "import_statement": "import errno",
            "lineno": 5,
            "imported_module": "errno",
            "symbols": [
              "errno"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/core.py",
            "import_statement": "import contextlib",
            "lineno": 13,
            "imported_module": "contextlib",
            "symbols": [
              "contextmanager"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/core.py",
            "import_statement": "import types",
            "lineno": 19,
            "imported_module": "types",
            "symbols": [
              "TracebackType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/core.py",
            "import_statement": "import _utils",
            "lineno": 22,
            "imported_module": "_utils",
            "symbols": [
              "FLAG_NEEDS_VALUE"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/exceptions.py",
            "import_statement": "import collections.abc",
            "lineno": 3,
            "imported_module": "collections.abc",
            "symbols": [
              "cabc"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/formatting.py",
            "import_statement": "import contextlib",
            "lineno": 4,
            "imported_module": "contextlib",
            "symbols": [
              "contextmanager"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/parser.py",
            "import_statement": "import _utils",
            "lineno": 41,
            "imported_module": "_utils",
            "symbols": [
              "T_FLAG_NEEDS_VALUE"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/parser.py",
            "import_statement": "import _utils",
            "lineno": 42,
            "imported_module": "_utils",
            "symbols": [
              "T_UNSET"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/parser.py",
            "import_statement": "import shell_completion",
            "lineno": 522,
            "imported_module": "shell_completion",
            "symbols": [
              "split_arg_string"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/shell_completion.py",
            "import_statement": "import os",
            "lineno": 4,
            "imported_module": "os",
            "symbols": [
              "os"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/shell_completion.py",
            "import_statement": "import core",
            "lineno": 15,
            "imported_module": "core",
            "symbols": [
              "ParameterSource"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/termui.py",
            "import_statement": "import collections.abc",
            "lineno": 3,
            "imported_module": "collections.abc",
            "symbols": [
              "cabc"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/termui.py",
            "import_statement": "import utils",
            "lineno": 21,
            "imported_module": "utils",
            "symbols": [
              "LazyFile"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/testing.py",
            "import_statement": "import contextlib",
            "lineno": 4,
            "imported_module": "contextlib",
            "symbols": [
              "contextlib"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/testing.py",
            "import_statement": "import types",
            "lineno": 11,
            "imported_module": "types",
            "symbols": [
              "TracebackType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/types.py",
            "import_statement": "import operator",
            "lineno": 519,
            "imported_module": "operator",
            "symbols": [
              "operator"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/utils.py",
            "import_statement": "import types",
            "lineno": 9,
            "imported_module": "types",
            "symbols": [
              "ModuleType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/utils.py",
            "import_statement": "import types",
            "lineno": 10,
            "imported_module": "types",
            "symbols": [
              "TracebackType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/utils.py",
            "import_statement": "import _compat",
            "lineno": 21,
            "imported_module": "_compat",
            "symbols": [
              "WIN"
            ],
            "needs_llm": false
          },
          {
            "module": "src/click/utils.py",
            "import_statement": "import errno",
            "lineno": 514,
            "imported_module": "errno",
            "symbols": [
              "errno"
            ],
            "needs_llm": false
          }
        ],
        "unused_global_variables": [
          {
            "module": "src/click/_compat.py",
            "name": "CYGWIN",
            "lineno": 13,
            "assigned_to": "sys.platform.startswith",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "_default_text_stdin",
            "lineno": 607,
            "assigned_to": "_make_cached_stream_func",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "_default_text_stdout",
            "lineno": 608,
            "assigned_to": "_make_cached_stream_func",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "_default_text_stderr",
            "lineno": 609,
            "assigned_to": "_make_cached_stream_func",
            "needs_llm": true
          },
          {
            "module": "src/click/_utils.py",
            "name": "T_UNSET",
            "lineno": 32,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/click/_utils.py",
            "name": "T_FLAG_NEEDS_VALUE",
            "lineno": 35,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "GetCommandLineW",
            "lineno": 47,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "CommandLineToArgvW",
            "lineno": 48,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "LocalFree",
            "lineno": 51,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "STDIN_FILENO",
            "lineno": 64,
            "assigned_to": "int",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "STDOUT_FILENO",
            "lineno": 65,
            "assigned_to": "int",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "STDERR_FILENO",
            "lineno": 66,
            "assigned_to": "int",
            "needs_llm": true
          }
        ],
        "unreachable_code": [],
        "suspicious_patterns": [
          {
            "module": "examples/completion/completion.py",
            "name": "cli",
            "lineno": 8,
            "pattern_type": "empty_function",
            "details": "Function is empty or only contains pass/return None",
            "needs_llm": true
          },
          {
            "module": "examples/completion/completion.py",
            "name": "group",
            "lineno": 32,
            "pattern_type": "empty_function",
            "details": "Function is empty or only contains pass/return None",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "_force_correct_text_stream",
            "lineno": 238,
            "pattern_type": "too_many_parameters",
            "details": "Function has 7 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "main",
            "lineno": 1338,
            "pattern_type": "long_function",
            "details": "Function is very long (112 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help_record",
            "lineno": 2604,
            "pattern_type": "empty_function",
            "details": "Function is empty or only contains pass/return None",
            "needs_llm": true
          },
          {
            "module": "src/click/decorators.py",
            "name": "version_option",
            "lineno": 421,
            "pattern_type": "long_function",
            "details": "Function is very long (104 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/click/parser.py",
            "name": "add_option",
            "lineno": 261,
            "pattern_type": "too_many_parameters",
            "details": "Function has 7 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "prompt",
            "lineno": 83,
            "pattern_type": "long_function",
            "details": "Function is very long (112 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "prompt",
            "lineno": 83,
            "pattern_type": "too_many_parameters",
            "details": "Function has 10 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "progressbar",
            "lineno": 314,
            "pattern_type": "too_many_parameters",
            "details": "Function has 16 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "progressbar",
            "lineno": 334,
            "pattern_type": "long_function",
            "details": "Function is very long (157 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "progressbar",
            "lineno": 334,
            "pattern_type": "too_many_parameters",
            "details": "Function has 16 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "style",
            "lineno": 518,
            "pattern_type": "long_function",
            "details": "Function is very long (127 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "style",
            "lineno": 518,
            "pattern_type": "too_many_parameters",
            "details": "Function has 12 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/click/testing.py",
            "name": "isolation",
            "lineno": 280,
            "pattern_type": "long_function",
            "details": "Function is very long (152 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/click/testing.py",
            "name": "invoke",
            "lineno": 433,
            "pattern_type": "long_function",
            "details": "Function is very long (112 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/click/testing.py",
            "name": "invoke",
            "lineno": 433,
            "pattern_type": "too_many_parameters",
            "details": "Function has 7 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/click/utils.py",
            "name": "echo",
            "lineno": 222,
            "pattern_type": "long_function",
            "details": "Function is very long (101 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "examples/aliases/aliases.py",
            "name": "read_config",
            "lineno": 76,
            "pattern_type": "similar_function_names",
            "details": "Similar to read in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/aliases/aliases.py",
            "name": "push",
            "lineno": 102,
            "pattern_type": "similar_function_names",
            "details": "Similar to push_context in src/click/globals.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/aliases/aliases.py",
            "name": "read_config",
            "lineno": 17,
            "pattern_type": "similar_function_names",
            "details": "Similar to read in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/aliases/aliases.py",
            "name": "write_config",
            "lineno": 25,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/_winconsole.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/aliases/aliases.py",
            "name": "write_config",
            "lineno": 25,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/_winconsole.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/aliases/aliases.py",
            "name": "write_config",
            "lineno": 25,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/aliases/aliases.py",
            "name": "write_config",
            "lineno": 25,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/completion/completion.py",
            "name": "show_env",
            "lineno": 26,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/completion/completion.py",
            "name": "show_env",
            "lineno": 26,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/completion/completion.py",
            "name": "show_env",
            "lineno": 26,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "process_commands",
            "lineno": 24,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "process_commands",
            "lineno": 24,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "processor",
            "lineno": 42,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "processor",
            "lineno": 42,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "copy_filename",
            "lineno": 69,
            "pattern_type": "similar_function_names",
            "details": "Similar to copy in examples/repo/repo.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "open_cmd",
            "lineno": 84,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in examples/termui/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "open_cmd",
            "lineno": 84,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in examples/validation/validation.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_rotation",
            "lineno": 165,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in examples/validation/validation.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "convert_flip",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "processor",
            "lineno": 48,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/imagepipe/imagepipe.py",
            "name": "processor",
            "lineno": 48,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/naval/naval.py",
            "name": "ship",
            "lineno": 16,
            "pattern_type": "similar_function_names",
            "details": "Similar to ship_new in examples/naval/naval.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/naval/naval.py",
            "name": "ship",
            "lineno": 16,
            "pattern_type": "similar_function_names",
            "details": "Similar to ship_move in examples/naval/naval.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/naval/naval.py",
            "name": "ship",
            "lineno": 16,
            "pattern_type": "similar_function_names",
            "details": "Similar to ship_shoot in examples/naval/naval.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/naval/naval.py",
            "name": "mine",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to mine_set in examples/naval/naval.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/naval/naval.py",
            "name": "mine",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to mine_remove in examples/naval/naval.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "progress",
            "lineno": 38,
            "pattern_type": "similar_function_names",
            "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "progress",
            "lineno": 38,
            "pattern_type": "similar_function_names",
            "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "progress",
            "lineno": 38,
            "pattern_type": "similar_function_names",
            "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "open",
            "lineno": 105,
            "pattern_type": "similar_function_names",
            "details": "Similar to open_stream in src/click/_compat.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "open",
            "lineno": 105,
            "pattern_type": "similar_function_names",
            "details": "Similar to open_url in src/click/_termui_impl.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "open",
            "lineno": 105,
            "pattern_type": "similar_function_names",
            "details": "Similar to open_file in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "edit",
            "lineno": 118,
            "pattern_type": "similar_function_names",
            "details": "Similar to edit_files in src/click/_termui_impl.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "process_slowly",
            "lineno": 42,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "process_slowly",
            "lineno": 42,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "show_item",
            "lineno": 56,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "show_item",
            "lineno": 56,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/termui/termui.py",
            "name": "show_item",
            "lineno": 56,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/validation/validation.py",
            "name": "convert",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "get_text_stdin",
            "lineno": 337,
            "pattern_type": "similar_function_names",
            "details": "Similar to _get_text_stdin in src/click/_winconsole.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "get_text_stdout",
            "lineno": 344,
            "pattern_type": "similar_function_names",
            "details": "Similar to _get_text_stdout in src/click/_winconsole.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "get_text_stderr",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to _get_text_stderr in src/click/_winconsole.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "open_stream",
            "lineno": 371,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "read1",
            "lineno": 105,
            "pattern_type": "similar_function_names",
            "details": "Similar to read in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "readable",
            "lineno": 113,
            "pattern_type": "similar_function_names",
            "details": "Similar to read in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "close",
            "lineno": 463,
            "pattern_type": "similar_function_names",
            "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "__exit__",
            "lineno": 476,
            "pattern_type": "similar_function_names",
            "details": "Similar to exit in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "func",
            "lineno": 585,
            "pattern_type": "similar_function_names",
            "details": "Similar to function in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_compat.py",
            "name": "func",
            "lineno": 585,
            "pattern_type": "similar_function_names",
            "details": "Similar to func_name in src/click/shell_completion.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "open_url",
            "lineno": 676,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "__exit__",
            "lineno": 120,
            "pattern_type": "similar_function_names",
            "details": "Similar to exit in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "edit_files",
            "lineno": 594,
            "pattern_type": "similar_function_names",
            "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "edit_files",
            "lineno": 594,
            "pattern_type": "similar_function_names",
            "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "edit_files",
            "lineno": 594,
            "pattern_type": "similar_function_names",
            "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "edit_files",
            "lineno": 594,
            "pattern_type": "similar_function_names",
            "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "edit_files",
            "lineno": 594,
            "pattern_type": "similar_function_names",
            "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "edit_files",
            "lineno": 594,
            "pattern_type": "similar_function_names",
            "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "edit_files",
            "lineno": 594,
            "pattern_type": "similar_function_names",
            "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "getchar",
            "lineno": 767,
            "pattern_type": "similar_function_names",
            "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_termui_impl.py",
            "name": "getchar",
            "lineno": 844,
            "pattern_type": "similar_function_names",
            "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_textwrap.py",
            "name": "indent_only",
            "lineno": 40,
            "pattern_type": "similar_function_names",
            "details": "Similar to indent in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "readable",
            "lineno": 128,
            "pattern_type": "similar_function_names",
            "details": "Similar to read in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "readinto",
            "lineno": 131,
            "pattern_type": "similar_function_names",
            "details": "Similar to read in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 174,
            "pattern_type": "similar_function_names",
            "details": "Similar to writelines in src/click/_winconsole.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 174,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 174,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 174,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 174,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 174,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 203,
            "pattern_type": "similar_function_names",
            "details": "Similar to writelines in src/click/_winconsole.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 203,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 203,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 203,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 203,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "write",
            "lineno": 203,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "writelines",
            "lineno": 212,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/_winconsole.py",
            "name": "writelines",
            "lineno": 212,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "_check_iter",
            "lineno": 2017,
            "pattern_type": "similar_function_names",
            "details": "Similar to check_iter in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "__exit__",
            "lineno": 481,
            "pattern_type": "similar_function_names",
            "details": "Similar to exit in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "close",
            "lineno": 616,
            "pattern_type": "similar_function_names",
            "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "command_path",
            "lineno": 642,
            "pattern_type": "similar_function_names",
            "details": "Similar to command in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "command_path",
            "lineno": 642,
            "pattern_type": "similar_function_names",
            "details": "Similar to command in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "command_path",
            "lineno": 642,
            "pattern_type": "similar_function_names",
            "details": "Similar to command in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "command_path",
            "lineno": 642,
            "pattern_type": "similar_function_names",
            "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "command_path",
            "lineno": 642,
            "pattern_type": "similar_function_names",
            "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "command_path",
            "lineno": 642,
            "pattern_type": "similar_function_names",
            "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "command_path",
            "lineno": 642,
            "pattern_type": "similar_function_names",
            "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "command_path",
            "lineno": 642,
            "pattern_type": "similar_function_names",
            "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "exit",
            "lineno": 730,
            "pattern_type": "similar_function_names",
            "details": "Similar to __exit__ in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "exit",
            "lineno": 730,
            "pattern_type": "similar_function_names",
            "details": "Similar to __exit__ in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_usage",
            "lineno": 740,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_usage",
            "lineno": 740,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help",
            "lineno": 746,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_option_names in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help",
            "lineno": 746,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_option in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help",
            "lineno": 746,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help",
            "lineno": 746,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help",
            "lineno": 746,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_extra in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_usage",
            "lineno": 993,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_usage",
            "lineno": 993,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help_option_names",
            "lineno": 1046,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_option in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help_option_names",
            "lineno": 1046,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help_option",
            "lineno": 1054,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help",
            "lineno": 1088,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help",
            "lineno": 1088,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_help",
            "lineno": 1088,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_help_extra in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "format_help",
            "lineno": 1120,
            "pattern_type": "similar_function_names",
            "details": "Similar to format_help_text in src/click/core.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_default",
            "lineno": 2249,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_default",
            "lineno": 2254,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "get_default",
            "lineno": 2258,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "process_value",
            "lineno": 2411,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "process_value",
            "lineno": 2411,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "prompt_for_value",
            "lineno": 3117,
            "pattern_type": "similar_function_names",
            "details": "Similar to prompt in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "process_value",
            "lineno": 3301,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "process_value",
            "lineno": 3301,
            "pattern_type": "similar_function_names",
            "details": "Similar to process in src/click/parser.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "convert",
            "lineno": 2362,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "convert",
            "lineno": 2367,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/core.py",
            "name": "convert",
            "lineno": 2372,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/decorators.py",
            "name": "confirmation_option",
            "lineno": 380,
            "pattern_type": "similar_function_names",
            "details": "Similar to confirm in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/decorators.py",
            "name": "show_help",
            "lineno": 536,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/decorators.py",
            "name": "show_help",
            "lineno": 536,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/decorators.py",
            "name": "show_help",
            "lineno": 536,
            "pattern_type": "similar_function_names",
            "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write",
            "lineno": 135,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write",
            "lineno": 135,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write",
            "lineno": 135,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write",
            "lineno": 135,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write",
            "lineno": 135,
            "pattern_type": "similar_function_names",
            "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "indent",
            "lineno": 139,
            "pattern_type": "similar_function_names",
            "details": "Similar to indentation in src/click/formatting.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write_usage",
            "lineno": 147,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write_heading",
            "lineno": 185,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write_paragraph",
            "lineno": 189,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write_text",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/formatting.py",
            "name": "write_dl",
            "lineno": 210,
            "pattern_type": "similar_function_names",
            "details": "Similar to write in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/shell_completion.py",
            "name": "source_vars",
            "lineno": 244,
            "pattern_type": "similar_function_names",
            "details": "Similar to source in src/click/shell_completion.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/shell_completion.py",
            "name": "source_vars",
            "lineno": 244,
            "pattern_type": "similar_function_names",
            "details": "Similar to source in src/click/shell_completion.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "prompt",
            "lineno": 83,
            "pattern_type": "similar_function_names",
            "details": "Similar to prompt_func in src/click/termui.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "echo_via_pager",
            "lineno": 261,
            "pattern_type": "similar_function_names",
            "details": "Similar to echo in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/termui.py",
            "name": "getchar",
            "lineno": 816,
            "pattern_type": "similar_function_names",
            "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/testing.py",
            "name": "_echo",
            "lineno": 34,
            "pattern_type": "similar_function_names",
            "details": "Similar to echo in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/testing.py",
            "name": "read",
            "lineno": 40,
            "pattern_type": "similar_function_names",
            "details": "Similar to read1 in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/testing.py",
            "name": "read",
            "lineno": 40,
            "pattern_type": "similar_function_names",
            "details": "Similar to readline in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/testing.py",
            "name": "read",
            "lineno": 40,
            "pattern_type": "similar_function_names",
            "details": "Similar to readlines in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/testing.py",
            "name": "readline",
            "lineno": 46,
            "pattern_type": "similar_function_names",
            "details": "Similar to readlines in src/click/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/types.py",
            "name": "convert_type",
            "lineno": 1112,
            "pattern_type": "similar_function_names",
            "details": "Similar to convert in src/click/types.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/utils.py",
            "name": "open_file",
            "lineno": 358,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/click/utils.py",
            "name": "close",
            "lineno": 169,
            "pattern_type": "similar_function_names",
            "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
            "needs_llm": true
          }
        ]
      }
    }
  },
  "function_summaries": {
    "examples/aliases/aliases.py": {
      "read_config": {
        "human": "Loads shortcut names (aliases) from a configuration file so users can use simpler names instead of full commands or paths. If the file exists and has an \"aliases\" section, it reads those shortcuts and adds them to the program's list of available aliases. If there's no aliases section in the file, it simply skips that step without causing an error.",
        "technical": "Instantiates a `configparser.RawConfigParser` object and reads the specified configuration file. Attempts to extract key-value pairs from the \"aliases\" section using `parser.items()` and merges them into `self.aliases` dictionary via `update()`. Catches `NoSectionError` exception and silently continues if the \"aliases\" section doesn't exist. Returns None but has side effect of modifying `self.aliases` state."
      },
      "push": {
        "human": "This is a command-line interface function that appears to be a placeholder for pushing changes (likely to a version control system like Git). Currently, it doesn't actually perform any push operation - it just displays the word \"Push\" on the screen as a confirmation message or stub implementation.",
        "technical": "CLI command function decorated with `@cli.command` to register it as a command-line subcommand. Takes no parameters and returns None. Executes a single operation: calls `click.echo(\"Push\")` to output the string \"Push\" to stdout. No actual push logic is implemented - this is a stub/placeholder function that only prints a message without performing any file operations, network calls, or version control actions."
      },
      "pull": {
        "human": "This is a placeholder command that simulates pulling changes from a remote source (like downloading updates from a server or repository). Currently, it doesn't actually perform any real pulling operation - it just displays the word \"Pull\" on the screen to acknowledge the command was received.",
        "technical": "A CLI command decorator (@cli.command) registers this function as a command-line interface command. When invoked, it executes a single operation: calls click.echo() to print the string \"Pull\" to stdout. Returns None implicitly. No actual pull logic, data retrieval, or external API calls are implemented - this is a stub/placeholder function."
      },
      "clone": {
        "human": "This is a placeholder command that represents the ability to copy a repository from one location to another (like downloading code from a server). Currently, it doesn't actually perform any cloning - it just prints the word \"Clone\" to confirm the command was triggered. It's likely a stub waiting to be implemented with real functionality.",
        "technical": "CLI command function decorated with `@cli.command` that registers it as a command-line interface command. Currently contains only a stub implementation that calls `click.echo(\"Clone\")` to output text to the console. No actual repository cloning logic is implemented - no git operations, no file system interactions, and no return value. This is a placeholder function awaiting full implementation."
      },
      "commit": {
        "human": "This is a placeholder command that simulates committing changes to a version control system (like saving your work permanently). Currently, it doesn't actually perform any real commit operation - it just displays the word \"Commit\" on the screen to acknowledge the command was received.",
        "technical": "A CLI command decorator registers this function as a command-line interface command. When invoked, it executes a single operation: calls `click.echo()` to print the string \"Commit\" to stdout. No actual version control operations are performed, no data is processed or persisted, and the function returns None with no side effects beyond the console output."
      },
      "status": {
        "human": "Displays the current status information for a configuration by showing which path or location is being used. This is a simple status check command that helps users verify what configuration file or directory the application is currently working with.",
        "technical": "CLI command function decorated with `@cli.command` and `@pass_config` that receives a config object and outputs a formatted status string using `click.echo()`. Accesses `config.path` attribute and prints it to stdout. No return value (returns None). Pure side-effect function that only performs console output."
      },
      "alias": {
        "human": "This function creates a shortcut (alias) for a command-line command and saves it to a configuration file. For example, you could make \"ls\" a shortcut for \"list --all --verbose\". After creating the alias, it confirms what was added by displaying a message. This helps users avoid typing long commands repeatedly.",
        "technical": "Accepts alias name, target command string, and config file path as parameters. Calls `config.add_alias()` to register the alias-command mapping in the config object, then persists changes via `config.write_config()` to the specified file. Uses `click.echo()` to output confirmation message. Decorated as a Click CLI command with arguments for alias/cmd and option for config_file path."
      },
      "__init__": {
        "human": "Sets up a new object by remembering two things: where the program is currently running (the current folder location) and creating an empty storage space for shortcuts or alternative names. This initialization prepares the object to track its working location and manage name mappings.",
        "technical": "Constructor method that initializes two instance attributes: `self.path` stores the current working directory obtained via `os.getcwd()`, and `self.aliases` initializes as an empty dictionary. No parameters accepted, no return value. Sets up basic state for what appears to be a path/directory management object with alias support."
      },
      "write_config": {
        "human": "Saves a collection of shortcuts (aliases) to a configuration file on your computer. Think of it like bookmarking your favorite commands or shortcuts so you can use them again later. The function takes all the stored aliases and writes them into a file that can be read back when needed.",
        "technical": "Creates a ConfigParser object, adds an \"aliases\" section, iterates through self.aliases dictionary to populate key-value pairs using parser.set(), then writes the configuration to disk in binary mode. Uses configparser.RawConfigParser for INI-style file format. Side effect: creates/overwrites the specified file with serialized alias mappings."
      },
      "get_command": {
        "human": "This function helps find and run commands in a command-line tool, even when users don't type the full command name. It first checks if the command exists normally, then looks for any shortcuts or aliases the user has set up in their configuration. If that doesn't work, it tries to match what the user typed to existing commands (like typing \"st\" to run \"status\"). If multiple commands match, it shows an error message.",
        "technical": "Implements a three-tier command resolution strategy for a Click CLI application: (1) attempts standard command lookup via click.Group.get_command(), (2) checks Config object's aliases dictionary for explicit command mappings, (3) performs case-insensitive prefix matching against all available commands from list_commands(). Returns the matched Command object or None if no match found. Calls ctx.fail() with sorted matches if prefix matching is ambiguous (multiple matches)."
      },
      "resolve_command": {
        "human": "This function looks up a command but always returns its official name rather than any nickname or shortcut that might have been used. It's like ensuring you always get someone's full legal name even if you called them by a nickname. This helps maintain consistency when commands can be called by multiple names.",
        "technical": "Overrides parent class's `resolve_command` method to normalize command resolution. Calls `super().resolve_command(ctx, args)` which returns a tuple of (command_name, command_object, remaining_args), then replaces the first element with `cmd.name` to ensure the canonical command name is returned instead of any alias. Returns the modified tuple (canonical_name, cmd, args)."
      }
    },
    "examples/colors/colors.py": {
      "cli": {
        "human": "This is a demonstration program that shows off different text coloring and styling options in the terminal. It prints multiple lines of colored text to show what's possible - first in regular colors, then bold colored text, then reverse-colored text, and finally some special effects like blinking and underlining. It's designed to help users see what styling options are available.",
        "technical": "Iterates through an `all_colors` collection three times, using `click.style()` to apply different formatting combinations (foreground color, bold+color, reverse+color) and outputs each styled string via `click.echo()`. After the loops, outputs two additional examples demonstrating blink and underline text attributes. Uses Click library's styling API which automatically strips ANSI codes when output is redirected to non-TTY destinations. No return value; side effect is terminal output."
      }
    },
    "examples/completion/completion.py": {
      "get_env_vars": {
        "human": "This function helps users by suggesting environment variable names as they type. When someone starts typing a partial name, it searches through all the environment variables on the computer and shows them a list of matching options. It's like an autocomplete feature that makes it easier to find and select the right environment variable without having to remember the exact name.",
        "technical": "Implements a shell completion callback that filters environment variables based on partial user input. Iterates through `os.environ` dictionary keys using list comprehension, performing substring matching where `incomplete` parameter (partial user input) is checked against each environment variable name. Returns a list of matching environment variable names as strings, which the Click framework automatically converts to CompletionItem objects for shell autocompletion."
      },
      "show_env": {
        "human": "Displays the name and current value of an environment variable on your computer. When you provide the name of an environment variable (like PATH or HOME), it shows you what that variable is called and what value it currently holds. This helps users check system settings and configuration values that programs use.",
        "technical": "CLI command function that accepts an environment variable name as a string argument and outputs it to console using click.echo(). Retrieves the value directly from os.environ dictionary using bracket notation (will raise KeyError if variable doesn't exist). Prints two lines: the variable name and its corresponding value. No return value (returns None), side effect is console output only."
      },
      "list_users": {
        "human": "Provides auto-complete suggestions for usernames based on what the user has typed so far. When someone starts typing a name or job title, it searches through a list of three users (bob, alice, and jerry) and shows matching options with their occupations. This helps users quickly select the right person without typing the full name.",
        "technical": "Implements a Click CLI completion callback that filters a hardcoded list of (username, occupation) tuples against the `incomplete` parameter. Performs substring matching on both username and occupation fields, constructing CompletionItem objects with value and help parameters for matches. Returns a list of CompletionItem instances for the CLI framework to display as autocomplete suggestions."
      }
    },
    "examples/complex/complex/cli.py": {
      "cli": {
        "human": "Sets up the initial configuration for a command-line application by storing user preferences. Takes two optional settings - how much detail to show in messages (verbose mode) and where to store application files (home directory). These settings are saved so other parts of the program can use them later.",
        "technical": "Initializes CLI context object by setting verbose flag and conditionally updating home directory path. Receives context object (ctx) from Click's pass_environment decorator along with verbose boolean and home path parameters. Performs direct attribute assignment (ctx.verbose, ctx.home) to configure application state. No return value; modifies context object in-place as side effect for downstream command handlers."
      },
      "__init__": {
        "human": "Sets up the initial configuration for an object when it's first created. It prepares two basic settings: one that controls whether the object should display detailed information during operation (turned off by default), and another that remembers the current folder location where the program is running.",
        "technical": "Constructor method that initializes two instance attributes: `self.verbose` as a boolean flag set to `False` for controlling output verbosity, and `self.home` which captures the current working directory path using `os.getcwd()`. No parameters accepted, no return value (implicit `None`). Establishes baseline state for the object instance."
      },
      "log": {
        "human": "Writes a message to the error output stream (stderr) where diagnostic information and errors are typically displayed. If you provide additional formatting values, it will insert them into the message template (like filling in blanks). This allows the program to show status updates or warnings to users in a standardized way.",
        "technical": "Accepts a message and optional formatting arguments, applies string interpolation using the modulo operator (%) if args are provided, then outputs the formatted message to stderr using click.echo(). The function leverages Click's echo utility for cross-platform compatible output handling. Returns None; produces side effect of writing to stderr stream."
      },
      "vlog": {
        "human": "This function provides a way to display optional debug or status messages that only appear when the program is running in \"verbose mode.\" It's like having a volume control for program messages - when verbose is turned on, you see extra details; when it's off, the program runs quietly. This helps users choose between seeing detailed information or keeping output minimal.",
        "technical": "Conditional logging wrapper that checks the `self.verbose` boolean flag before delegating to `self.log()`. When verbose mode is enabled, forwards the message and any additional positional arguments to the underlying log method; otherwise performs no operation. Returns None. Provides no side effects beyond the delegated log call when verbose is True."
      },
      "list_commands": {
        "human": "Scans a folder to find all available command files and creates a list of their names. It looks for Python files that follow a specific naming pattern (starting with \"cmd_\"), extracts just the command name part, and returns them in alphabetical order. This helps the program discover what commands are available to run.",
        "technical": "Iterates through files in `cmd_folder` using `os.listdir()`, filters for files matching pattern `cmd_*.py` using `startswith()` and `endswith()` checks. Extracts command names by slicing filenames (removes \"cmd_\" prefix and \".py\" suffix via `[4:-3]`), appends to list, sorts alphabetically with `rv.sort()`, and returns the sorted list of command names."
      },
      "get_command": {
        "human": "This function loads additional command modules on-demand when a user requests a specific command by name. Instead of loading all commands at startup, it waits until a command is actually needed, then finds and loads the corresponding command module from a \"commands\" folder. If the requested command doesn't exist, it simply returns nothing rather than crashing.",
        "technical": "Dynamically imports command modules using `__import__()` with the pattern `complex.commands.cmd_{name}`. Attempts to load the module and extract its `cli` attribute (likely a Click command object). Uses try-except to catch ImportError and return None for non-existent commands. Returns the `mod.cli` object on successful import, enabling lazy-loading of CLI commands in a plugin-style architecture."
      }
    },
    "examples/complex/complex/commands/cmd_init.py": {
      "cli": {
        "human": "This function sets up a new repository in a specified location on your computer. If you don't tell it where to create the repository, it will use a default \"home\" location. Once it decides on the location, it displays a confirmation message showing where the repository was initialized.",
        "technical": "A Click CLI command that initializes a repository at a given path. Takes a `path` argument (nullable) and context object `ctx`. If path is None, defaults to `ctx.home`. Logs initialization confirmation using `ctx.log()` with the path formatted via `click.format_filename()`. Returns None; primary side effect is logging output. Uses Click decorators for command registration and argument parsing."
      }
    },
    "examples/complex/complex/commands/cmd_status.py": {
      "cli": {
        "human": "This is a command-line tool that checks for file changes in your current folder and reports them. Right now, it's a placeholder that always reports \"no changes found\" and logs some debug information. It's designed to be part of a larger command-line application that tracks file modifications.",
        "technical": "Click-decorated CLI command function that receives a context object and performs logging operations. Calls `ctx.log()` to output a hardcoded message indicating no changed files, then calls `ctx.vlog()` for verbose-level debug output. Returns None. Currently a stub implementation with no actual file system inspection - just static log messages. Uses `pass_environment` decorator to inject context."
      }
    },
    "examples/imagepipe/imagepipe.py": {
      "cli": {
        "human": "This is the main entry point for a command-line tool that processes images through a series of operations. It allows users to chain together multiple image manipulation commands (like opening, resizing, blurring, and saving images) in a pipeline style, where the output of one command feeds into the next. Think of it like an assembly line for image processing.",
        "technical": "Decorated with `@click.group()` to create a Click command group that serves as the parent command for subcommands. The function itself is empty (no implementation body), acting purely as a container/dispatcher for child commands. Click's group decorator handles command routing and CLI argument parsing. Returns None and has no side effects beyond Click's framework initialization."
      },
      "process_commands": {
        "human": "This function acts like a pipeline that processes data through multiple stages, similar to how Unix pipes work (e.g., `command1 | command2 | command3`). It takes a list of processing functions that were created by earlier commands, chains them together so each one feeds its output to the next, and then runs the entire pipeline to completion. The final results are discarded after processing.",
        "technical": "Implements a Click result callback that chains multiple processor functions together using function composition. Initializes an empty tuple as the starting stream, iterates through each processor function applying it to the current stream (each processor takes and returns an iterable), and finally forces evaluation of the lazy iterator chain by consuming all items with a for-loop. Side effects occur during stream consumption; return value is None."
      },
      "processor": {
        "human": "This is a decorator that transforms a regular function into a \"function factory\" - it makes the function return another function instead of executing directly. This pattern is useful when you want to configure how data will be processed later, rather than processing it immediately. It's like creating a customized tool that you can use multiple times with different inputs.",
        "technical": "A decorator that wraps function `f` to return a closure instead of executing directly. When the decorated function is called with arguments, it returns an inner `processor` function that captures those arguments. This inner function accepts a `stream` parameter and applies the original function `f` with the stream plus the captured args/kwargs. Uses `update_wrapper` to preserve the original function's metadata (name, docstring, etc.)."
      },
      "generator": {
        "human": "This function creates a decorator that transforms a regular function into a stream processor. It allows you to add new items to the end of a data stream without modifying the original items that were already in the stream. Think of it like adding new items to the end of a conveyor belt while letting existing items pass through untouched.",
        "technical": "Decorator that wraps function `f` to create a stream generator. Returns a new function decorated with `@processor` that first yields all items from the input stream unchanged (`yield from stream`), then appends items generated by calling `f(*args, **kwargs)`. Uses `update_wrapper` to preserve the original function's metadata. The wrapped function doesn't receive stream values as parameters, only additional args/kwargs."
      },
      "copy_filename": {
        "human": "Copies the filename property from one object to another. This is useful when you need to transfer or preserve the filename information from an existing object to a new one, such as when creating a modified version of a file object while keeping track of its original filename.",
        "technical": "Performs attribute assignment by copying the `filename` attribute from the `old` object to the `new` object using direct attribute access (`old.filename`). Despite the function signature indicating `return None`, it actually returns the modified `new` object. This is a simple shallow copy operation for a single attribute with no validation or error handling."
      },
      "open_cmd": {
        "human": "Opens image files one at a time so they can be processed by other tools. It can handle multiple images in sequence and also accepts images from standard input (like when piping data). If an image fails to open, it shows an error message but continues trying to open the remaining images instead of stopping completely.",
        "technical": "Generator function that iterates through image paths, opens each using PIL's Image.open(), and yields Image objects. Handles stdin input via click.get_binary_stdin() when path is \"-\". Uses click.echo() for status messages and error reporting (to stderr). Wraps each open operation in try-except to handle failures gracefully without breaking iteration. Returns generator of Image objects with filename attributes set."
      },
      "save_cmd": {
        "human": "Takes a collection of processed images and saves each one to your computer as a separate file. The function numbers each file automatically (like image_1.jpg, image_2.jpg, etc.) based on a filename pattern you provide. If any image fails to save, it displays an error message but continues saving the remaining images instead of stopping completely.",
        "technical": "Generator function that iterates through an image collection, formatting output filenames using string interpolation with 1-based indexing. Calls image.save() method for each image object and yields the result. Implements try-except error handling to catch save failures, logging errors to stderr via click.echo while continuing iteration. Uses click decorators for CLI integration and filename path validation."
      },
      "display_cmd": {
        "human": "This function displays a collection of images one by one using your computer's default image viewer application. As it processes each image, it prints a message telling you which image file is being opened. It's designed to help users quickly view multiple images in sequence, useful for reviewing batches of photos or graphics.",
        "technical": "Generator function that iterates through an image collection, outputs filename to console via click.echo, invokes the show() method on each image object (likely PIL/Pillow Image.show() which opens system image viewer), and yields each image to maintain the processing pipeline. Decorated as both a CLI command and processor, enabling it to be chained with other image operations while preserving the image stream for downstream commands."
      },
      "resize_cmd": {
        "human": "This function resizes images to fit within specified dimensions while keeping their original proportions intact. If you only provide a width or height, it keeps the other dimension unchanged. It processes multiple images one at a time, showing a message for each image being resized, and makes them smaller (never larger) to fit the given box.",
        "technical": "Generator function that iterates through image objects, applying thumbnail resizing to each. Uses `image.thumbnail()` method with dimensions tuple `(w, h)` where missing width/height defaults to original `image.size` values. Logs resize operation via `click.echo()` before transformation. Yields modified image objects for downstream processing. Decorated as CLI command with click options and processor decorator for pipeline integration."
      },
      "crop_cmd": {
        "human": "This function shrinks images by removing pixels from all four edges (top, bottom, left, right). You specify how many pixels to trim off, and it applies that same amount to each side. If you don't specify a border size, the images pass through unchanged. It's useful for removing unwanted borders or margins from photos.",
        "technical": "Iterates through image objects, creating a crop box initialized to full image dimensions [0, 0, width, height]. If border parameter is provided, reduces each box coordinate by the border value (clamped to 0 minimum using max()), then calls image.crop() with the adjusted box. Uses copy_filename() to preserve original filename metadata on cropped result. Yields either the cropped image or original image unchanged, making it a generator function suitable for image processing pipelines."
      },
      "convert_rotation": {
        "human": "Converts user-friendly rotation values (like \"90\", \"right\", \"left\", or degree numbers) into a standardized format that image processing software can understand. This allows users to specify how they want to rotate an image using intuitive terms instead of technical codes. If the user provides an invalid rotation value, it alerts them with an error message.",
        "technical": "Click callback function that validates and transforms rotation parameter values. Converts input string to lowercase, then maps recognized values (\"90\"/\"r\"/\"right\", \"180\"/\"-180\", \"-90\"/\"270\"/\"l\"/\"left\") to tuples containing PIL Image rotation constants (ROTATE_90/180/270) and their degree equivalents. Returns None for None input, raises click.BadParameter exception for unrecognized values. Used as a parameter converter in Click CLI applications."
      },
      "convert_flip": {
        "human": "This function helps convert user-friendly text commands into image flip instructions. When someone types something like \"lr\" or \"topbottom\", it translates that into the specific flip operation needed (flipping an image left-to-right or top-to-bottom). If the user enters an unrecognized flip command, it shows them an error message explaining the input was invalid.",
        "technical": "Click callback function that validates and converts flip direction strings into PIL Image flip constants. Takes input value, normalizes to lowercase, and maps aliases (\"lr\", \"leftright\") to Image.FLIP_LEFT_RIGHT tuple with description. Returns None for None input. Note: Bug on line 8 - both conditions return FLIP_LEFT_RIGHT instead of second returning FLIP_TOP_BOTTOM. Raises click.BadParameter exception for invalid inputs."
      },
      "transpose_cmd": {
        "human": "Processes a collection of images by rotating them by a specified angle (like 90 or 180 degrees) and/or flipping them horizontally or vertically. For each image, it applies the requested transformations in order, displays a message showing what's being done, and passes the modified image along. This is a command-line tool that helps users batch-transform multiple images at once.",
        "technical": "Generator function that iterates through image objects, applying PIL transpose operations based on rotate and flip parameters. For rotation, extracts mode and degrees from tuple, calls image.transpose(mode) and preserves original filename via copy_filename(). Similarly processes flip with mode and direction. Uses click.echo for CLI feedback. Yields transformed images, enabling pipeline processing through the @processor decorator pattern."
      },
      "blur_cmd": {
        "human": "This function takes a collection of images and makes them blurry by applying a soft, out-of-focus effect. You specify how blurry you want the images (the radius), and it processes each image one by one, showing you progress messages as it works. The blurred images keep their original filenames so you know which image is which.",
        "technical": "CLI command that applies Gaussian blur filter to a stream of images. Creates an ImageFilter.GaussianBlur object with the specified radius, iterates through input images, applies the filter using PIL's image.filter() method, and yields processed images as a generator. Uses click.echo for progress feedback and copy_filename to preserve original filename metadata on filtered output images."
      },
      "smoothen_cmd": {
        "human": "This function takes a collection of images and makes them blurrier by applying a smoothing filter multiple times. It processes each image one by one, showing progress messages that indicate which file is being worked on and how many times the blur effect will be applied. The more iterations specified, the smoother (blurrier) the final image becomes.",
        "technical": "Iterates through input images, applying PIL's ImageFilter.BLUR filter repeatedly based on the iterations parameter. For each image, prints a status message via click.echo with proper pluralization. Uses copy_filename() to preserve original filename metadata after each filter application. Yields processed images one at a time, making this a generator function. The blur filter is applied cumulatively, with each iteration using the output of the previous one."
      },
      "emboss_cmd": {
        "human": "Takes a collection of images and applies an embossing visual effect to each one, making them appear raised or carved. As it processes each image, it displays a message showing which file is being worked on. The embossed versions are created as new images while preserving the original filenames.",
        "technical": "Generator function that iterates through an image collection, applying PIL's ImageFilter.EMBOSS filter to each image object. Uses click.echo for console output feedback during processing. Yields processed images via copy_filename() which transfers metadata from source to filtered image. Decorated as both a CLI command and processor, enabling it to work in a command pipeline."
      },
      "sharpen_cmd": {
        "human": "This function makes images look sharper and clearer by increasing their sharpness level. You provide a collection of images and specify how much sharper you want them (the factor). It processes each image one by one, applies the sharpening effect, and creates new sharpened versions while keeping the original filenames. It also prints a message for each image being processed so you can track progress.",
        "technical": "Generator function that iterates through an image collection, applying PIL's ImageEnhance.Sharpness enhancement to each. Uses `max(1.0, factor)` to ensure sharpness factor is at least 1.0 (preventing image softening). Prints progress via click.echo for each image processed. Yields enhanced images with `copy_filename()` to preserve original filename metadata. Relies on PIL/Pillow's ImageEnhance API and Click framework for CLI integration."
      },
      "paste_cmd": {
        "human": "Takes a collection of images and combines the first two by placing the second image on top of the first one at a specified position. If the top image has transparency, it preserves that transparency when pasting. All remaining images in the collection are passed through unchanged. This is useful for layering or compositing images together.",
        "technical": "Generator function that iterates through image collection, extracts first two images using `next()`, and performs `image.paste()` operation with left/right coordinates as position tuple. Automatically detects transparency by checking RGBA mode or transparency info, using the pasted image itself as alpha mask if transparent. Updates filename metadata to reflect the composite operation, yields the modified base image, then yields remaining images unchanged via `yield from`."
      },
      "new_func": {
        "human": "This function acts as a bridge that first passes through all items from an incoming stream unchanged, then adds additional items generated by calling another function. It's like a pipeline that lets existing data flow through first, then appends new data at the end. The `@processor` decorator suggests this is part of a data processing workflow.",
        "technical": "Generator function that chains two iterables: first yields all items from the `stream` parameter using `yield from`, then yields all items produced by calling function `f(*args, **kwargs)`. Takes variable positional and keyword arguments which are forwarded to `f`. Returns None but produces values lazily through the generator protocol. The `@processor` decorator likely registers this as a stream processing component."
      }
    },
    "examples/inout/inout.py": {
      "cli": {
        "human": "This is a command-line tool that copies content from one or more input files to an output file, similar to the Unix `cat` command. It can read from files or keyboard input (stdin) and write to files or screen output (stdout). The dash symbol \"-\" represents standard input/output, allowing flexible combinations like copying multiple files to the screen or saving keyboard input to a file.",
        "technical": "Implements a Click CLI command that iterates through multiple input file objects, reading each in 1024-byte chunks and writing to a single output file object. Uses `f.read(1024)` for buffered reading, `output.write()` for writing chunks, and `output.flush()` to ensure immediate output. The function accepts file-like objects (via Click.File decorator) and performs streaming I/O without loading entire files into memory. No return value; operates purely through side effects (file I/O)."
      }
    },
    "examples/naval/naval.py": {
      "cli": {
        "human": "This is the main entry point for a command-line application called \"Naval Fate.\" It sets up the foundation for a multi-command CLI tool where users can type different commands to perform various naval-related operations. Think of it as the starting menu that organizes and displays all available commands when you run the program.",
        "technical": "Defines a Click command group decorated with `@click.group()` and `@click.version_option()` that serves as the root CLI entry point. The function body is empty (just docstring), as Click's decorator handles all routing logic to subcommands. Returns None. The decorators enable command grouping functionality and automatic version display flag (--version)."
      },
      "ship_new": {
        "human": "This function creates a new ship in the system by accepting a name from the user. When called, it simply confirms that a ship with the given name has been created by displaying a message. It's part of a command-line tool (likely for a game or simulation) that lets users manage ships through text commands.",
        "technical": "A Click CLI command decorated with `@ship.command` and `@click.argument` that accepts a `name` parameter of type `Any`. Outputs a formatted confirmation string to stdout using `click.echo()`. No actual ship object is instantiated or persisted - only prints acknowledgment message. Returns `None` with no side effects beyond console output."
      },
      "ship_move": {
        "human": "This function provides a command-line interface for moving a ship to a new position on a map or grid. When called, it takes the ship identifier, destination coordinates (X and Y), and movement speed as inputs, then displays a confirmation message showing where the ship is moving. It's designed to be used as part of a larger command-line application for managing ships.",
        "technical": "CLI command function decorated with Click decorators (@ship.command, @click.argument, @click.option) that accepts four parameters: ship identifier, x/y coordinates, and speed. Performs no actual ship movement logic\u2014only outputs a formatted string via click.echo() displaying the movement parameters. The function has no return value (returns None) and produces only a side effect of printing to stdout. Currently appears to be a stub or demonstration implementation lacking actual movement logic."
      },
      "ship_shoot": {
        "human": "This function simulates a spaceship firing at a target location. When called, it displays a message showing which ship is shooting and where it's aiming. It's likely part of a command-line game or simulation where users can control ships and make them attack specific coordinates on a map or battlefield.",
        "technical": "A Click CLI command that accepts three arguments (ship identifier, x coordinate, y coordinate) and outputs a formatted string to the console using click.echo(). The function performs no actual computation or state changes\u2014it only displays the firing action as text. The decorators suggest this is registered as a CLI command with two coordinate arguments, though the actual coordinate types are not validated in the function body."
      },
      "mine_set": {
        "human": "This function records the placement of a mine at a specific location on a map or grid. When you provide X and Y coordinates along with a mine type, it confirms the action by displaying a message showing where the mine was placed. It's part of a command-line tool for managing mine placements, likely in a game or simulation.",
        "technical": "CLI command handler decorated with click.command that accepts three arguments: x and y coordinates (Any type) and mine type (ty). Performs no actual data storage or validation - only outputs a formatted confirmation string via click.echo(). The function has no return value and produces only a side effect of printing to stdout. Despite float() appearing in key function calls, coordinates are not explicitly converted in the implementation."
      },
      "mine_remove": {
        "human": "This function removes a mine from a game board at a location specified by x and y coordinates. When called, it displays a confirmation message showing which coordinates the mine was removed from. It's part of a command-line mine management tool that lets users interact with mines on a grid.",
        "technical": "Click CLI command that accepts two arguments (x, y coordinates). Outputs a formatted string to console using click.echo() displaying the removal coordinates. No actual data structure manipulation occurs - function only prints confirmation message. No return value (returns None). The x and y parameters are passed as-is without type conversion despite the float() call appearing in key function calls list but not in actual implementation."
      }
    },
    "examples/repo/repo.py": {
      "cli": {
        "human": "Sets up the main entry point for a command-line tool that mimics a version control system (like Git). When you run the program, it initializes the workspace by finding the repository folder, setting how much detail to show in messages (verbose mode), and applying any custom configuration settings you've provided through command-line options.",
        "technical": "Initializes a Click CLI group by creating a Repo object with an absolute path to repo_home and storing it in ctx.obj for child commands to access via decorators. Sets the verbose flag on the Repo instance and iterates through config tuples to apply key-value configuration pairs using set_config(). Uses Click's context passing mechanism to share state across command hierarchy."
      },
      "clone": {
        "human": "This function prepares to copy a code repository from one location to another. If you don't specify where to put the copy, it automatically creates a folder using the source repository's name. It displays messages about what it's doing, including whether it's making a quick (shallow) copy and which version of the code it's checking out.",
        "technical": "Extracts destination folder name from source path using `posixpath.split()` if dest is None, then sets `repo.home` to the destination. Outputs informational messages via `click.echo()` about the cloning operation, shallow checkout status (if enabled), and revision being checked out. Note: This appears to be a mock/stub implementation as it only prints messages and sets repo.home without actually performing git clone operations."
      },
      "delete": {
        "human": "This function permanently removes a repository from the system. Before deletion, it asks the user to confirm they really want to proceed (to prevent accidental data loss). It displays messages showing which repository is being destroyed and confirms when the operation completes. This is a destructive action that cannot be undone.",
        "technical": "CLI command function decorated with `@click.confirmation_option` for user confirmation before execution. Receives a repository object via `@pass_repo` decorator. Outputs the repository's home path using `click.echo()`, but notably contains no actual deletion logic\u2014only prints \"Deleted!\" message. The actual repository destruction must occur elsewhere (likely in decorators or the repo object's lifecycle management)."
      },
      "setuser": {
        "human": "This function updates the user's login information for a repository system. It saves a new username, email address, and password to the repository's configuration settings, replacing any previous credentials. After successfully updating all three pieces of information, it displays a confirmation message to let the user know their credentials have been changed.",
        "technical": "Calls `repo.set_config()` three times to persist username, email, and a masked password (asterisks matching password length) to the repository configuration. The actual password is masked using `\"*\" * len(password)` before storage, suggesting the real password is handled elsewhere or this is for display purposes only. Outputs confirmation via `click.echo()`. Decorated as a Click CLI command with options for username, email, and password input, with `pass_repo` injecting the repository object."
      },
      "commit": {
        "human": "This function saves changes to files in a code repository with a descriptive message. If you don't provide a message upfront, it opens a text editor where you can write one while seeing which files will be saved. If you cancel the editor or leave the message empty, the save operation is cancelled. Finally, it shows you what files will be committed and what message will be used.",
        "technical": "Handles git-style commit workflow with interactive message editing via click.edit(). If no message provided, constructs a template with file list markers, opens editor, then parses user input by splitting on marker and extracting content before it. Validates message is non-empty after stripping whitespace. If message provided as argument, joins it with newlines. Outputs commit details via click.echo() but doesn't actually perform repository operations (display-only implementation)."
      },
      "copy": {
        "human": "This function is designed to copy files from one location to another in a repository. When you give it source file(s) and a destination, it's supposed to copy them over. However, the current implementation only prints messages about what it *would* copy without actually performing any file copying operations. The 'force' option suggests it might handle overwriting existing files.",
        "technical": "CLI command function that iterates through source file paths in the `src` parameter and prints copy intentions using `click.echo()`. Despite the docstring claiming it copies files, no actual file operations (shutil.copy, os.rename, etc.) are performed. The `force` parameter is accepted but unused. Decorated with Click decorators for CLI integration (@cli.command, @click.argument for src/dst, @click.option presumably for force flag, @pass_repo for repository context)."
      },
      "__init__": {
        "human": "Sets up a new object by storing where its \"home\" location is and preparing empty storage for configuration settings. Also sets a flag to indicate that detailed status messages should not be shown by default. This is the initial setup that happens when creating a new instance of this class.",
        "technical": "Constructor method that initializes three instance attributes: stores the `home` parameter as `self.home`, initializes an empty dictionary `self.config` for configuration data, and sets a boolean flag `self.verbose` to False. No validation or processing is performed on the input parameter. Returns None implicitly."
      },
      "set_config": {
        "human": "This function updates a configuration setting by storing a key-value pair. It's like changing a preference or setting in the system. If verbose mode is turned on, it also prints a message to show what configuration was changed, helping users track what's being modified in real-time.",
        "technical": "Sets a configuration value by assigning `value` to `self.config[key]` dictionary. Conditionally outputs debug information to stderr using `click.echo()` when `self.verbose` is True, displaying the key-value pair that was set. No return value (returns None). Side effect: modifies instance's config dictionary state and potentially writes to stderr stream."
      }
    },
    "examples/termui/termui.py": {
      "cli": {
        "human": "This function serves as the main entry point for a command-line application that demonstrates various interactive terminal features. It acts as a container that groups together multiple related commands, allowing users to access different terminal UI demonstrations through subcommands. Think of it as the \"home base\" that organizes all the demo commands under one umbrella.",
        "technical": "Defines a Click command group using the `@click.group` decorator that serves as a parent command for organizing subcommands. The function body contains only `pass`, meaning it performs no operations itself\u2014its purpose is purely structural. Subcommands would be attached to this group via `@cli.command()` decorators elsewhere in the codebase. Returns None and has no side effects beyond establishing the CLI group hierarchy."
      },
      "colordemo": {
        "human": "Shows users what colored text looks like in their terminal by displaying sample messages. It demonstrates both colored text and colored backgrounds using three basic colors (red, green, and blue). This helps users verify that their terminal supports color display and see what the colors look like before using them in actual applications.",
        "technical": "Iterates through a tuple of three color strings (\"red\", \"green\", \"blue\") and uses click.style() to apply ANSI color formatting. For each color, outputs two lines via click.echo(): one with the color applied as foreground text (fg parameter) and one with the color applied as background (bg parameter). Decorated with @cli.command to register as a CLI command. No return value; produces side effects by writing colored output to stdout."
      },
      "pager": {
        "human": "Creates a demonstration of a paging feature that displays a long list of 200 numbered greetings. Instead of flooding the screen with all lines at once, it uses a pager (like the \"more\" or \"less\" commands) that lets users scroll through the content page by page. Each line shows a green-colored number followed by \"Hello World!\" This is useful for showing how to display large amounts of text in a user-friendly, scrollable way.",
        "technical": "Generates a list of 200 formatted strings by iterating through range(200), where each string contains a green-styled number (using click.style with fg='green') concatenated with \". Hello World!\". Joins all lines with newline characters and outputs them through click.echo_via_pager(), which invokes the system pager for scrollable display. This is a CLI command decorator (@cli.command) that demonstrates Click's pager functionality for handling long terminal output."
      },
      "progress": {
        "human": "This is a demonstration function that shows different ways to display progress bars in a command-line application. It runs through five different examples, each showing a progress bar with different visual styles, colors, and information displays. Each example processes a series of items with artificial delays to simulate real work, allowing users to see how progress bars look and behave during actual operations.",
        "technical": "Implements a Click CLI command that demonstrates five progressbar variations using `click.progressbar()` context manager. Processes a range of items (count parameter) with simulated delays via `time.sleep()`. Examples include: basic progress with green styling, filtered items with yellow styling and custom item display, custom bar template with cyan styling, minimal progress bar without percentage/ETA, and non-linear progress using exponential steps. Each iteration calls `process_slowly()` for artificial 0-2ms delays."
      },
      "open": {
        "human": "This function opens any file or web address using your computer's default program. For example, if you give it a website URL, it opens in your default browser; if you give it a document path, it opens in the appropriate application (like a PDF reader or text editor). It's a simple command-line tool that acts like double-clicking a file or link.",
        "technical": "CLI command function decorated with `@cli.command` and `@click.argument` that accepts a URL/file path parameter and delegates to `click.launch()` for opening. The `click.launch()` function handles OS-specific logic to invoke the system's default handler for the given resource. Returns None; side effect is launching external application. No validation or error handling implemented at this level."
      },
      "locate": {
        "human": "This function reveals where a file or web link is actually stored on your computer. Instead of opening the file itself, it shows you the file's location in your file browser (like Finder on Mac or File Explorer on Windows). This is useful when you want to see where something is saved rather than just opening it.",
        "technical": "CLI command that wraps `click.launch()` with the `locate=True` parameter to reveal a file/URL's location in the system file manager rather than opening it. Accepts a single `url` argument (despite the name, handles both file paths and URLs). Decorated as a Click CLI command with argument binding. Returns None; side effect is launching the native file manager focused on the specified path."
      },
      "edit": {
        "human": "Opens a text editor where you can type a message. When you save and close the editor, it displays what you wrote. If you write nothing or cancel, it tells you the message was empty. Any text you write below a special marker line is automatically ignored, letting you add notes that won't be included in the final message.",
        "technical": "CLI command that invokes click.edit() to open system editor with a marker delimiter. Parses returned text by splitting on MARKER constant, extracts content before marker, strips trailing newlines. Handles three cases: None (cancelled/no input), empty string after parsing, or valid message content. Uses click.echo() for all output feedback to user."
      },
      "clear": {
        "human": "This function clears all text from your terminal or command-line window, giving you a fresh, blank screen to work with. It's like wiping a whiteboard clean. This is useful when your screen gets cluttered with previous commands and output, and you want to start fresh or improve readability.",
        "technical": "A CLI command decorator wraps this function to expose it as a command-line interface command. When invoked, it delegates to click.clear() which handles the platform-specific terminal clearing operation (using ANSI escape codes or system commands). Returns None and has the side effect of clearing the terminal display buffer. No parameters required, no data processing involved."
      },
      "pause": {
        "human": "This function pauses the program and waits for the user to press any key before continuing. It's useful when you want to give users time to read information on the screen or control when the program moves forward. Think of it like a \"Press any key to continue\" prompt you might see in applications.",
        "technical": "A CLI command decorator wraps a simple function that delegates to click.pause(). Makes a blocking call that halts execution until user input is received via stdin. Returns None and has no parameters. The @cli.command decorator registers this as a command-line interface command in the Click framework."
      },
      "menu": {
        "human": "Creates an interactive text-based menu system that lets users navigate between different screens using keyboard input. The main menu offers options to enter a debug menu or quit the program. Users press single keys ('d', 'q', 'b') to make selections, and the system responds to invalid choices with an error message. It keeps running until the user chooses to quit.",
        "technical": "Implements a state machine-based CLI menu using Click library's `getchar()` for single-character input and `echo()` for output. Maintains menu state as a string variable (\"main\", \"debug\", \"quit\") in an infinite while loop. Transitions between states based on character input, with \"main\" accepting 'd' or 'q', \"debug\" accepting 'b', and \"quit\" triggering function return. Invalid inputs echo error messages without state change."
      },
      "filter": {
        "human": "This function randomly filters out items from a collection, keeping roughly 70% of them and discarding about 30%. It's like a lottery where each item has a 70% chance of making it through the filter. This could be used for random sampling, creating test datasets, or simulating unpredictable selection processes.",
        "technical": "Generator function that iterates through input items and yields each one with 70% probability. Uses `random.random()` (returns float 0.0-1.0) compared against threshold 0.3 to determine inclusion. Returns generator object that lazily produces filtered items. No side effects beyond random number generation. Note: Shadows Python's built-in `filter()` function name."
      },
      "show_item": {
        "human": "This function takes an item and creates a formatted display text for it, but only if the item actually exists. If you give it something, it returns a label showing \"Item #\" followed by that item. If you give it nothing, it simply does nothing and returns None.",
        "technical": "Performs a null check on the input parameter and conditionally returns a formatted string. When `item` is not None, returns an f-string in format \"Item #{item}\". When `item` is None, implicitly returns None (no explicit return statement). Note: Function signature declares `-> None` return type but actually returns a string, creating a type annotation inconsistency."
      }
    },
    "examples/validation/validation.py": {
      "validate_count": {
        "human": "This function checks if a number meets two requirements: it must be positive (zero or greater) and it must be an even number (divisible by 2). If the number fails either check, it stops the program and shows an error message. This is typically used to validate user input in command-line applications where only positive, even numbers are acceptable.",
        "technical": "Click callback validator that checks if the input value is non-negative and even using modulo arithmetic (value % 2 != 0). Raises click.BadParameter exception with descriptive message if validation fails, otherwise returns the validated value unchanged. Accepts standard Click callback parameters (ctx, param, value) for integration with Click's parameter validation system."
      },
      "cli": {
        "human": "This is a command-line tool that demonstrates different ways to validate user input. It checks that a count number is valid, ensures that if a \"foo\" value is provided it must be exactly \"wat\", and validates that a URL is properly formatted. After checking all inputs are correct, it displays them back to the user.",
        "technical": "A Click CLI command decorated with options for count (validated via callback), foo (validated manually in function body), and url (validated via custom URL type). Raises click.BadParameter if foo is provided but not equal to \"wat\". Performs no return value but outputs three echo statements displaying the validated parameter values. Uses Click's parameter validation framework combining callbacks, custom types, and manual validation."
      },
      "convert": {
        "human": "This function validates that a URL is safe to use by checking if it uses either HTTP or HTTPS protocols. If someone provides a regular text URL, it breaks it down into parts to examine the protocol. If the URL uses any other protocol (like FTP or file://), it rejects it with an error message explaining only HTTP URLs are allowed.",
        "technical": "Converts and validates URL input by first checking if value is already a tuple (parsed). If not, parses the string using urlparse.urlparse() to extract URL components. Validates that the scheme attribute is either \"http\" or \"https\", calling self.fail() with error message, param, and ctx if validation fails. Returns the parsed value (as ParseResult object) or original tuple unchanged."
      }
    },
    "src/click/__init__.py": {
      "__getattr__": {
        "human": "This function handles requests for outdated Click library features that are being phased out. When someone tries to use old names like \"BaseCommand\" or \"MultiCommand\", it shows them a warning message explaining what to use instead, then provides the old feature anyway so their code still works. It also handles version number requests by looking up the current Click version.",
        "technical": "Module-level `__getattr__` implementation that intercepts attribute access for deprecated Click API names. For \"BaseCommand\", \"MultiCommand\", and \"OptionParser\", imports internal underscore-prefixed classes and emits DeprecationWarning with stacklevel=2. For \"__version__\", calls `importlib.metadata.version(\"click\")` with deprecation warning. Raises AttributeError for unrecognized names. Enables backward compatibility while warning users about API changes coming in Click 9.0/9.1."
      }
    },
    "src/click/_compat.py": {
      "_make_text_stream": {
        "human": "Converts a binary stream (raw bytes) into a text stream (readable characters) so that programs can work with human-readable text instead of raw data. It automatically figures out the best way to interpret the bytes as text if not specified, and ensures the conversion is forgiving of errors. Think of it as translating computer data into readable text.",
        "technical": "Wraps a binary stream (t.BinaryIO) in a text I/O wrapper with specified or auto-detected encoding. Calls get_best_encoding() to determine encoding if None provided, defaults errors parameter to \"replace\" for lenient decoding. Returns _NonClosingTextIOWrapper with line buffering enabled and optional force_readable/force_writable flags to override stream capabilities. The wrapper prevents accidental stream closure."
      },
      "is_ascii_encoding": {
        "human": "Determines whether a text encoding name (like \"utf-8\" or \"ascii\") actually refers to ASCII encoding. This is useful when you need to verify if text will be limited to basic ASCII characters (letters, numbers, and common symbols) rather than supporting international characters or special symbols. Returns a simple yes/no answer.",
        "technical": "Uses `codecs.lookup()` to normalize and resolve the encoding string to its canonical codec name, then compares against \"ascii\". Handles invalid encoding names via `LookupError` exception, returning `False` for unrecognized encodings. Returns `True` only when the canonical codec name exactly matches \"ascii\", accounting for encoding aliases (e.g., \"us-ascii\" resolves to \"ascii\")."
      },
      "get_best_encoding": {
        "human": "Figures out what character encoding (like UTF-8 or ASCII) a data stream uses for reading or writing text. If the stream doesn't specify an encoding, it uses the computer's default. When it detects basic ASCII encoding, it upgrades to UTF-8 since UTF-8 can handle more characters and is more versatile for modern applications.",
        "technical": "Retrieves encoding from stream object's `encoding` attribute via `getattr()`, falling back to `sys.getdefaultencoding()` if not present. Checks if retrieved encoding is ASCII-based using `is_ascii_encoding()` helper. Returns \"utf-8\" as replacement for ASCII encodings to ensure broader character support; otherwise returns the original encoding string. No side effects, pure retrieval and conditional transformation of encoding identifier."
      },
      "_is_binary_reader": {
        "human": "Checks whether a data stream (like a file or network connection) is set up to handle binary data (like images or videos) rather than text. It does this by attempting a small test read and seeing what type of data comes back. If the test fails for any reason, it returns a safe default answer that the caller can specify.",
        "technical": "Attempts to determine if a stream is in binary mode by calling `stream.read(0)` (zero-byte read) and checking if the result is a `bytes` instance using `isinstance()`. Returns `True` for binary streams, `False` for text streams. On any exception during the read operation, returns the `default` parameter value (defaults to `False`). Uses exception handling to gracefully handle streams that don't support read operations or are in invalid states."
      },
      "_is_binary_writer": {
        "human": "Checks whether a stream (like a file or output channel) accepts binary data (raw bytes) or text data (strings). It does this by attempting to write empty data to the stream and seeing what format works. If neither works or an error occurs, it returns a default answer you provide.",
        "technical": "Attempts to write an empty bytes object `b\"\"` to the stream. If successful, returns `True` indicating binary mode. If that raises an exception, attempts to write an empty string `\"\"`. If the string write succeeds, returns `False` (text mode). If both fail, returns the `default` parameter. Uses exception handling for duck-typing to determine stream type without inspecting attributes."
      },
      "_find_binary_reader": {
        "human": "This function tries to find a way to read binary data (like images or files) from a given stream. Sometimes streams are already set up for binary reading, and sometimes they have a special \"buffer\" property that can read binary data. The function checks both possibilities and returns whichever works, or nothing if neither option is available.",
        "technical": "Attempts to locate a binary reader from a given I/O stream by checking two sources: first validates if the stream itself is binary using `_is_binary_reader(stream, False)`, then checks for a `.buffer` attribute using `getattr()` and validates it with `_is_binary_reader(buf, True)`. Returns the first valid binary reader cast to `t.BinaryIO` type, or `None` if neither the stream nor its buffer are binary-capable. Handles the case where streams may be detached per official documentation recommendations."
      },
      "_find_binary_writer": {
        "human": "This function tries to find a way to write binary data (like images or files) to a given output stream. Sometimes streams are already set up for binary data, and sometimes they have a special \"buffer\" property that handles binary data. The function checks both possibilities and returns whichever works, or nothing if neither option is available.",
        "technical": "Attempts to locate a binary-compatible writer from a given I/O stream by checking two conditions: (1) directly tests if the stream itself is binary-writable using `_is_binary_writer()`, returning it as `t.BinaryIO` if true; (2) checks for a `buffer` attribute via `getattr()` and validates it as binary-writable. Returns the first valid binary writer found (either the stream or its buffer), or None if neither qualifies. Uses type casting to satisfy type hints."
      },
      "_stream_is_misconfigured": {
        "human": "Checks if a text stream (like a file or console output) is set up incorrectly for handling text characters. A stream is considered misconfigured if it only supports basic ASCII characters instead of a wider character set like UTF-8. This helps the Click library detect when it needs to work around limited text encoding capabilities, especially in testing environments where encoding might not be properly set.",
        "technical": "Retrieves the encoding attribute from the stream object using `getattr()`, defaulting to \"ascii\" if the attribute is missing or None. Passes this encoding value to `is_ascii_encoding()` helper function to determine if the stream uses ASCII encoding. Returns boolean True if ASCII-encoded (misconfigured), False otherwise. Handles edge case where unittest environments may not set stream encoding properly."
      },
      "_is_compat_stream_attr": {
        "human": "Checks whether a text stream (like a file or console output) has a specific property that matches what you're looking for. It's flexible: it considers the stream compatible either if the property matches exactly, or if you don't care about a specific value and the stream just has *something* set for that property. This helps determine if a stream can be used for a particular purpose.",
        "technical": "Retrieves an attribute from a TextIO stream object using `getattr()` with None as default. Returns True if the stream's attribute value equals the desired value parameter, or if the desired value is None but the stream has a non-None value for that attribute. Implements a two-condition compatibility check: exact match OR (unspecified requirement AND attribute exists). Returns boolean indicating compatibility status."
      },
      "_is_compatible_text_stream": {
        "human": "Checks whether a text stream (like a file or console output) is set up to handle text in the way you want it to. Specifically, it verifies that the stream's character encoding (how text is converted to bytes) and error handling method (what happens with invalid characters) match your requirements. Returns true if everything is compatible, false otherwise.",
        "technical": "Validates compatibility between a TextIO stream's attributes and desired encoding/error handling parameters. Calls `_is_compat_stream_attr()` twice to check both the \"encoding\" and \"errors\" attributes of the stream object against provided values. Returns boolean AND of both checks - true only if both the stream's encoding and errors attributes are compatible with the specified encoding and errors parameters."
      },
      "_force_correct_text_stream": {
        "human": "Ensures that text data can be read or written correctly by checking if a stream is using the right character encoding (like UTF-8). If the stream has encoding problems or is actually binary data, it wraps or converts it to use the correct encoding settings. This prevents garbled text (mojibake) or crashes when reading/writing text files.",
        "technical": "Validates and corrects text stream encoding configuration. First checks if input is binary using `is_binary()`, then verifies text stream compatibility via `_is_compatible_text_stream()` and `_stream_is_misconfigured()`. If incompatible, extracts underlying binary stream using `find_binary()`, defaults errors parameter to \"replace\", and wraps binary stream with correct encoding via `_make_text_stream()`. Returns properly configured `t.TextIO` object with specified encoding/error handling."
      },
      "_force_correct_text_reader": {
        "human": "Ensures that a text reader (something that reads text from a file or stream) is properly configured with the correct character encoding and error handling settings. It's like making sure a document reader understands the language and format of the text it's trying to read, so it can display the content correctly without errors.",
        "technical": "Wrapper function that delegates to `_force_correct_text_stream()` with text reader-specific helper functions. Passes the text_reader IO object along with encoding/errors parameters, and provides `_is_binary_reader` and `_find_binary_reader` as callbacks to handle binary stream detection and conversion. Returns a properly configured `t.TextIO` object with correct encoding settings and optional force_readable flag applied."
      },
      "_force_correct_text_writer": {
        "human": "Ensures that a text writer (something that writes text output) is properly configured with the correct character encoding and error handling settings. This is like making sure a document writer knows what language alphabet to use and how to handle characters it doesn't recognize. It's a wrapper that delegates the actual work to another function specialized for text streams.",
        "technical": "Delegates to `_force_correct_text_stream()` with writer-specific helper functions (`_is_binary_writer` and `_find_binary_writer`) to validate and potentially wrap a text writer stream. Passes through encoding, errors, and force_writable parameters to ensure the text writer has correct encoding configuration. Returns a properly configured `t.TextIO` object that can be used for text output operations."
      },
      "get_binary_stdin": {
        "human": "Gets access to the standard input (stdin) in a way that can read raw binary data instead of text. This is useful when a program needs to receive binary files or data (like images or compressed files) from the command line or a pipe. If it can't find a way to read binary data, it stops the program with an error message.",
        "technical": "Attempts to obtain a binary reader for `sys.stdin` by calling `_find_binary_reader()`. Returns a `BinaryIO` object if successful, enabling raw byte reading from stdin. Raises `RuntimeError` with descriptive message if no binary stream can be determined. Used for cross-platform binary stdin access, likely handling differences between text-mode and binary-mode stdin across operating systems."
      },
      "get_binary_stdout": {
        "human": "Gets access to the raw binary output stream for writing data directly to the console. This is needed when you want to write non-text data (like images or binary files) to the terminal output, rather than regular text. If it can't find a way to write binary data to the console, it stops with an error message.",
        "technical": "Attempts to locate a binary writer for sys.stdout by calling _find_binary_writer(). Returns a BinaryIO stream object if successful, enabling direct binary writes to stdout. Raises RuntimeError if no binary writer can be determined. Used for scenarios requiring raw byte output to stdout, bypassing text encoding layers."
      },
      "get_binary_stderr": {
        "human": "Gets access to the standard error stream (where error messages are normally printed) in a format that can handle raw binary data instead of just text. This is useful when you need to write non-text data like images or encoded bytes to the error output. If it can't find a way to write binary data to stderr, it stops with an error message.",
        "technical": "Attempts to obtain a binary writer for sys.stderr by calling _find_binary_writer(). Returns a t.BinaryIO object representing the binary-capable stderr stream. Raises RuntimeError if _find_binary_writer() returns None, indicating the binary stream could not be determined. Used for writing raw bytes to standard error instead of text strings."
      },
      "get_text_stdin": {
        "human": "Gets a text input stream for reading user input from the command line, making sure it works correctly across different operating systems. On Windows, it uses special handling for the console to properly display international characters and symbols. If not on Windows or if special handling isn't needed, it ensures the input stream is set up with the right text encoding so characters are read correctly.",
        "technical": "Returns a TextIO stream for stdin with proper encoding configuration. First attempts to get a Windows-specific console stream via `_get_windows_console_stream()` which handles Windows console encoding peculiarities. If that returns None (non-Windows or unavailable), falls back to `_force_correct_text_reader()` which wraps `sys.stdin` with specified encoding/error handling and forces readable mode. Accepts optional encoding and errors parameters to control text decoding behavior."
      },
      "get_text_stdout": {
        "human": "Gets the correct text output stream for writing text to the console/terminal. It handles special cases for Windows systems where console output needs special treatment, and ensures the output stream uses the right text encoding (like UTF-8). This prevents garbled text or errors when printing to the screen, especially with international characters.",
        "technical": "Returns a TextIO stream for stdout with proper encoding configuration. First attempts to get a Windows-specific console stream via `_get_windows_console_stream()` for native Windows console support. If that returns None (non-Windows or unavailable), falls back to `_force_correct_text_writer()` which wraps `sys.stdout` with specified encoding/error handling and forces writable mode. Accepts optional encoding and errors parameters for text encoding configuration."
      },
      "get_text_stderr": {
        "human": "Gets a text output stream for writing error messages to the console. On Windows, it tries to use a special console stream that handles Unicode characters properly. If that's not available, it falls back to the standard error output, making sure it can handle text correctly. This ensures error messages display properly across different operating systems and console types.",
        "technical": "Returns a TextIO stream for stderr output by first attempting to obtain a Windows-specific console stream via `_get_windows_console_stream()` with the provided encoding and error handling parameters. If Windows console stream is unavailable (returns None), falls back to `_force_correct_text_writer()` which wraps `sys.stderr` with proper text encoding/error handling and ensures writability. Accepts optional encoding and errors parameters to control text encoding behavior."
      },
      "_wrap_io_open": {
        "human": "This function opens a file while automatically handling a technical requirement: when opening files in binary mode (for images, videos, etc.), it skips text-related settings like character encoding. When opening text files, it includes those settings. This prevents errors that would occur if you tried to specify text encoding for binary files.",
        "technical": "Wraps Python's built-in `open()` function to conditionally pass encoding parameters based on file mode. Checks if 'b' flag exists in mode string; if present (binary mode), calls `open(file, mode)` without encoding/errors parameters. Otherwise (text mode), calls `open(file, mode, encoding=encoding, errors=errors)` with all parameters. Returns file handle typed as `t.IO[t.Any]`."
      },
      "open_stream": {
        "human": "Opens a file for reading or writing, with special handling for standard input/output (when filename is \"-\") and an optional \"atomic write\" mode that prevents data loss. Atomic writes work by first writing to a temporary file, then replacing the original file only after the write completes successfully. This ensures other programs never see a partially-written file.",
        "technical": "Handles three file-opening scenarios: (1) returns standard streams (stdin/stdout) when filename is \"-\", (2) calls _wrap_io_open directly for non-atomic operations, (3) implements atomic writes by creating a temporary file with random name using os.open with O_CREAT|O_EXCL flags, preserving original file permissions via os.stat/os.chmod, and wrapping in _AtomicFile that performs rename-on-close. Returns tuple of (file_object, should_close_flag). Validates atomic mode restrictions (no append/exclusive modes)."
      },
      "_is_jupyter_kernel_output": {
        "human": "Checks whether a given output stream is connected to a Jupyter notebook environment. This is useful when a program needs to behave differently depending on whether it's running in a regular terminal or inside a Jupyter notebook. It unwraps any wrapper layers around the stream to find the actual underlying stream before checking.",
        "technical": "Unwraps nested stream wrappers (_FixupStream, _NonClosingTextIOWrapper) by iteratively accessing the `_stream` attribute until reaching the base stream object. Then checks if the unwrapped stream's class module name starts with \"ipykernel.\" to determine if it originates from Jupyter kernel output. Returns boolean indicating Jupyter kernel detection."
      },
      "should_strip_ansi": {
        "human": "Determines whether colored text formatting (ANSI codes) should be removed from output. If no preference is specified, it automatically decides based on where the output is going - removing colors when writing to files or non-interactive environments, but keeping them in terminals and Jupyter notebooks where they display properly.",
        "technical": "Returns boolean indicating if ANSI escape codes should be stripped from output. When `color` parameter is None, checks if `stream` supports TTY using `isatty()` or is Jupyter kernel output via `_is_jupyter_kernel_output()`, defaulting to `sys.stdin` if no stream provided. Returns True (strip ANSI) for non-TTY/non-Jupyter streams. When `color` is explicitly set, returns its negation."
      },
      "isatty": {
        "human": "Checks whether the output is going to a terminal (like a command prompt or console) or somewhere else (like a file or pipe). This is useful for programs that want to behave differently when running interactively versus when their output is being redirected. For example, a program might show colored text only when running in a real terminal.",
        "technical": "Delegates to the underlying stream object's `isatty()` method to determine if the stream is connected to a TTY (terminal) device. Returns a boolean indicating terminal status. The comment references a PyPy bug tracker issue, suggesting this wrapper may address compatibility concerns. Simple pass-through method with no data transformation or side effects beyond the delegated call."
      },
      "_make_cached_stream_func": {
        "human": "Creates a special version of a function that remembers and reuses wrapped versions of streams (like file handles or console output). When you ask for the same stream multiple times, it gives you back the same wrapped version instead of creating a new one each time. This saves resources by avoiding duplicate wrappers for the same underlying stream.",
        "technical": "Returns a closure that caches wrapped stream objects using WeakKeyDictionary to map original streams to their wrappers. Calls src_func() to get the source stream, checks cache for existing wrapper, and if not found, creates new wrapper via wrapper_func() and stores it. Uses exception handling to gracefully handle unhashable streams or cache failures. WeakKeyDictionary ensures cache entries are automatically cleaned up when source streams are garbage collected."
      },
      "__init__": {
        "human": "Sets up a new file wrapper object that keeps track of both a temporary file and its final destination name. This is typically used when you want to write to a temporary location first and then move the file to its real location later (like when saving a file safely). It also marks the file as currently open and ready to use.",
        "technical": "Constructor that initializes a file wrapper object with three instance variables: stores the file handle (`_f`), temporary filename path (`_tmp_filename`), and target filename path (`_real_filename`). Sets `closed` flag to False to track file state. No validation or file operations performed - purely stores references for later use in file management operations (likely atomic file writes/renames)."
      },
      "__del__": {
        "human": "This is a cleanup function that runs automatically when an object is being deleted or destroyed by Python. It attempts to safely disconnect or detach the object from whatever it's connected to, ensuring proper cleanup happens even if the program crashes or the object is no longer needed. If the cleanup fails for any reason, it silently ignores the error to prevent issues during object destruction.",
        "technical": "Destructor method (`__del__`) that performs cleanup by calling `self.detach()` wrapped in a try-except block. Catches and suppresses all exceptions during detachment to prevent errors during garbage collection. Returns None. The broad exception handling ensures the destructor never raises exceptions, which is critical since exceptions in `__del__` can cause issues with Python's garbage collector and may be difficult to debug."
      },
      "read1": {
        "human": "This function reads a specific amount of data from a stream, trying to use an optimized single-read method if available. If the stream supports a special \"read1\" operation (which reads data in one go without multiple calls), it uses that. Otherwise, it falls back to the regular read method. This provides flexibility to work with different types of data streams efficiently.",
        "technical": "Attempts to retrieve the `read1` method from `self._stream` using `getattr`. If the method exists (not None), calls it with the specified size parameter and casts the result to bytes using `t.cast`. If `read1` is unavailable, falls back to calling the standard `self._stream.read(size)` method. Returns bytes in both cases. This pattern enables compatibility with streams that may or may not implement the `read1` interface."
      },
      "readable": {
        "human": "Checks whether a data stream can be read from. First looks for a simple override flag, then tries to ask the stream directly if it supports reading. If that doesn't work, it attempts a harmless test read to see if reading is possible. Returns yes or no based on whether the stream appears readable.",
        "technical": "Returns boolean indicating stream readability through three-tier check: (1) returns True if `_force_readable` flag set, (2) calls stream's `readable()` method if available using `getattr` and `t.cast`, (3) attempts `read(0)` as fallback test, catching exceptions to return False. Uses type casting for type safety and exception handling for streams lacking explicit readable interface."
      },
      "writable": {
        "human": "Checks whether a data stream can be written to. First looks for a quick answer through a flag or built-in method, but if those aren't available, it actually tries writing empty data to the stream twice to see if it works. Returns true if writing is possible, false if it fails.",
        "technical": "Returns boolean indicating stream writability. Checks `_force_writable` flag first, then attempts `_stream.writable()` method if available (with type casting). Falls back to defensive double-try of `_stream.write(b\"\")` with empty bytes - catches exceptions and returns False only if both attempts fail. Uses `getattr()` for safe attribute access and `t.cast()` for type hinting compliance."
      },
      "seekable": {
        "human": "Checks whether a data stream supports moving backward and forward (like rewinding a video). This is useful when you need to know if you can jump to different positions in a file or data source, rather than only reading it from start to finish. If the stream doesn't support this feature, the function safely reports that without causing errors.",
        "technical": "Determines if the underlying `_stream` object is seekable through a three-step approach: (1) checks for a `seekable` method using `getattr` and calls it if present, (2) attempts a no-op seek operation (`seek(tell())`) to test seekability empirically, (3) returns False if the seek attempt raises any exception. Returns boolean indicating stream seekability. Uses `t.cast` for type hinting the return value from the seekable method."
      },
      "close": {
        "human": "Safely saves a file by finalizing a temporary write operation. When you're done writing to a file, this ensures your changes are permanently saved by moving the temporary version to replace the actual file. It prevents doing this twice if you accidentally call it again after the file is already closed.",
        "technical": "Implements atomic file write completion using a temporary file pattern. Checks `self.closed` flag to prevent double-close, calls `_f.close()` to flush the file handle, then uses `os.replace()` to atomically move `_tmp_filename` over `_real_filename` (ensuring no partial writes are visible). Sets `self.closed = True` to track state. The `delete` parameter is accepted but unused in the implementation."
      },
      "__exit__": {
        "human": "This function handles cleanup when exiting a context (like when you use \"with\" statement in Python). It automatically closes and cleans up resources. If an error occurred while the context was active, it performs a more thorough cleanup by deleting associated data. If everything went smoothly, it just closes normally without deleting.",
        "technical": "Context manager exit method that implements the `__exit__` protocol for use with `with` statements. Calls `self.close()` with a `delete` parameter determined by checking if an exception occurred (`exc_type is not None`). When an exception is present, passes `delete=True` to trigger deletion of resources; otherwise passes `delete=False` for normal closure. Returns `None`, allowing exceptions to propagate."
      },
      "_get_argv_encoding": {
        "human": "Figures out what character encoding system should be used when reading command-line arguments that users type into the program. This ensures that special characters (like accents or non-English letters) in command-line inputs are interpreted correctly based on the user's computer settings.",
        "technical": "Returns the preferred character encoding string for the current locale by calling `locale.getpreferredencoding()`. This encoding is typically used to decode command-line arguments (`sys.argv`) into proper Unicode strings. Returns a string like 'UTF-8', 'cp1252', or other locale-specific encoding. No parameters, no side effects beyond importing the locale module."
      },
      "auto_wrap_for_ansi": {
        "human": "Makes colored text work properly on Windows terminals. When you want to display colored or styled text (like bold or underlined), Windows needs special handling. This function wraps the output stream so colors display correctly on Windows while working normally on other systems. It remembers streams it has already wrapped to avoid doing the work twice.",
        "technical": "Wraps a TextIO stream with colorama.AnsiToWin32 to enable ANSI escape sequence processing on Windows. Checks cache (_ansi_stream_wrappers) first to avoid re-wrapping. Determines whether to strip ANSI codes via should_strip_ansi(), then creates a wrapper with custom write() method (_safe_write) that calls reset_all() on exceptions. Caches the wrapped stream and returns it. Returns the colorama-processed stream object."
      },
      "_get_windows_console_stream": {
        "human": "This function is supposed to get a special Windows console stream for handling text input/output, but it's currently a placeholder that does nothing. It accepts a text stream and encoding settings but always returns None, meaning it's either not implemented yet or disabled. This would be used on Windows systems to handle console text properly with different character encodings.",
        "technical": "Stub implementation that accepts a TextIO stream object, optional encoding string, and optional errors string as parameters, but unconditionally returns None. No actual operations are performed - no Windows console API calls, no stream wrapping, no encoding configuration. This appears to be either a fallback implementation for non-Windows platforms or a placeholder for future Windows console stream handling functionality."
      },
      "func": {
        "human": "This function retrieves a text stream and tries to use a cached version if one exists. If there's no cached version or the cache lookup fails, it creates a new wrapped version of the stream, attempts to save it to the cache for future use, and returns it. It's designed to avoid recreating the same stream wrapper multiple times by remembering previously created ones.",
        "technical": "Calls `src_func()` to obtain a stream, returns None if no stream exists. Attempts cache lookup using the stream as key via `cache.get(stream)`, returning cached value if found. On cache miss or exception, calls `wrapper_func()` to generate new value, attempts to store in cache with `cache[stream] = rv` (silently ignoring storage failures), and returns the result. Implements a fault-tolerant caching pattern with exception handling around both cache read and write operations."
      },
      "_safe_write": {
        "human": "This function safely writes text to an output destination (like a terminal or console) while protecting against errors. If something goes wrong during the writing process, it makes sure to clean up any special text formatting (like colors or styles) before reporting the error. This prevents the terminal from being left in a messy state with broken formatting.",
        "technical": "Wraps the `_write(s)` call in a try-except block to handle any exceptions. On success, returns the result from `_write(s)` (likely bytes written). If any exception occurs (catches `BaseException`), calls `ansi_wrapper.reset_all()` to clear ANSI terminal formatting codes before re-raising the exception. Ensures terminal state is reset even when write operations fail catastrophically."
      }
    },
    "src/click/_termui_impl.py": {
      "pager": {
        "human": "Displays long text output one page at a time, like when reading a manual or help text that doesn't fit on one screen. It automatically chooses the best viewing method based on your system (Windows/Unix), available programs (like 'less' or 'more'), and whether you're in a terminal or running a script. If paging isn't possible, it just prints everything normally.",
        "technical": "Implements paginated text output by attempting multiple fallback strategies: first tries user's PAGER environment variable (via pipe on Unix, temp file on Windows), then system defaults ('less' on Unix, 'more' on Windows), finally falls back to _nullpager for direct output. Checks isatty() on stdin/stdout to detect terminal presence, handles special terminals (dumb/emacs), and manages temporary file creation/cleanup. Routes to _pipepager, _tempfilepager, or _nullpager based on platform and availability."
      },
      "_pipepager": {
        "human": "Displays text content one page at a time by sending it to an external paging program (like \"less\" or \"more\"). This allows users to read long text output comfortably by scrolling through it instead of having everything dumped to the screen at once. It handles color codes in the text and deals gracefully with situations where the user closes the pager early or interrupts it.",
        "technical": "Locates the pager command using `shutil.which()`, spawns it via `subprocess.Popen` with stdin pipe, and streams text from the generator to the pager's stdin. Automatically enables color support for \"less\" by setting LESS=\"-R\" environment variable when appropriate. Strips ANSI codes with `strip_ansi()` if color is disabled. Handles `BrokenPipeError` when pager exits early and catches `KeyboardInterrupt` in wait loop to prevent premature termination. Returns `True` if command exists, `False` otherwise."
      },
      "_tempfilepager": {
        "human": "This function displays long text output by saving it to a temporary file and opening it in an external viewer program (like \"less\" or \"more\"). It's useful when you have too much text to comfortably read in the terminal at once. The function checks if the requested viewer program exists on your computer, and if not, tells the calling code to try a different method instead.",
        "technical": "Creates a temporary file using `tempfile.mkstemp()`, joins the generator into a single string, optionally strips ANSI color codes if `color` is False, and writes the encoded text to the temp file. Validates the pager command exists via `shutil.which()`, resolves it to an absolute path without following symlinks (to preserve multi-call binary behavior), then invokes it via `subprocess.call()` with the temp file path. Cleans up by closing the file descriptor and unlinking the temp file in a finally block. Returns True if command found, False otherwise."
      },
      "_nullpager": {
        "human": "This function displays text directly to the screen without any special formatting or pagination. It's a basic fallback method used when more sophisticated text display options aren't available. If color formatting is disabled, it removes any color codes from the text before showing it. Think of it as the simplest possible way to show text output.",
        "technical": "Iterates through a generator of text strings and writes each to the provided stream. Conditionally strips ANSI escape sequences using `strip_ansi()` when the `color` parameter is False or None. Performs direct `stream.write()` calls without buffering or pagination logic. No return value; side effect is writing to the output stream. Serves as the most basic pager implementation in a fallback chain."
      },
      "open_url": {
        "human": "Opens a file or URL using the operating system's default application, like clicking a link or file in your file browser. Can optionally wait until the opened application closes before continuing, or show the file's location in the file explorer instead of opening it. Works across different operating systems (Mac, Windows, Linux) by using each system's native commands.",
        "technical": "Cross-platform URL/file opener that dispatches to OS-specific commands: `open` on macOS, `start`/`explorer` on Windows, `cygstart` on Cygwin, and `xdg-open` on Linux. Handles `file://` URLs by unquoting them with urllib.parse.unquote. The `locate` flag triggers file manager selection (`-R`, `/select`, or dirname). Returns subprocess exit codes (0 for success, 127 for command not found). Falls back to webbrowser.open() for HTTP(S) URLs on non-wait, non-locate failures."
      },
      "_translate_ch_to_exc": {
        "human": "Converts special keyboard control characters into Python exceptions that programs can handle. When users press Ctrl+C, it signals an interruption. When they press Ctrl+D (on Mac/Linux) or Ctrl+Z (on Windows), it signals they want to end input. This allows programs to respond appropriately to these common keyboard shortcuts.",
        "technical": "Translates control character strings to corresponding Python exceptions. Maps \"\\x03\" (Ctrl+C) to KeyboardInterrupt unconditionally. Maps \"\\x04\" (Ctrl+D) to EOFError on Unix-like systems only, and \"\\x1a\" (Ctrl+Z) to EOFError on Windows only, using WIN flag for platform detection. Returns None if no translation occurs. Side effect: raises exceptions that propagate to caller."
      },
      "__init__": {
        "human": "Sets up the initial configuration for an editor tool that will be used to edit text files. It stores preferences like which text editor program to use, what file extension to use for temporary files (like .txt), and whether changes must be saved before closing. Think of it as preparing the settings before opening a text editor.",
        "technical": "Constructor that initializes instance attributes for an editor wrapper class. Accepts optional parameters: `editor` (string path to editor executable), `env` (environment variables mapping), `require_save` (boolean flag for save enforcement), and `extension` (file extension string defaulting to \".txt\"). Directly assigns all parameters to corresponding instance attributes without validation or transformation. No return value or side effects beyond attribute assignment."
      },
      "__enter__": {
        "human": "This function sets up a progress bar when you start using it with Python's \"with\" statement. It marks the progress bar as active, displays the initial progress on screen, and makes the progress bar ready to track whatever task you're monitoring. Think of it like turning on a status indicator before starting a download or file processing operation.",
        "technical": "Implements the context manager entry protocol (`__enter__`) for the ProgressBar class. Sets the `entered` flag to True to track context manager state, calls `render_progress()` to display the initial progress bar UI, and returns `self` to enable the `with` statement binding. Returns a generic type `ProgressBar[V]` where V is a type variable. No parameters required as it operates on instance state."
      },
      "__exit__": {
        "human": "This function acts as a cleanup handler that runs automatically when exiting a context (like when you finish using something with a \"with\" statement). It ensures that any rendering or display work gets properly finished and wrapped up, regardless of whether an error occurred or everything completed successfully.",
        "technical": "Context manager exit method that implements the `__exit__` protocol for use with Python's `with` statement. Unconditionally calls `self.render_finish()` to finalize rendering operations. Accepts standard exception parameters (exc_type, exc_value, tb) but doesn't handle exceptions (returns None implicitly), allowing any exceptions to propagate after cleanup."
      },
      "__iter__": {
        "human": "This function allows you to loop through items in a progress bar, but only if you've properly set it up first using a \"with\" statement. It checks that you're using the progress bar correctly, updates the display to show current progress, and then starts providing the items one by one for processing.",
        "technical": "Implements the iterator protocol by returning an iterator from `self.generator()`. Performs validation check ensuring `self.entered` is True, raising RuntimeError if the progress bar context manager wasn't entered. Calls `self.render_progress()` to update the visual display before iteration begins. Returns a `cabc.Iterator[V]` type, enabling the object to be used in for-loops and other iteration contexts."
      },
      "__next__": {
        "human": "This function allows an object to be used in a loop (like \"for\" loops) by providing the next item each time it's called. Instead of implementing the iteration logic directly, it cleverly reuses the object's existing iteration mechanism to get the next value. This is the standard Python method that gets called automatically when you iterate through a collection.",
        "technical": "Implements the iterator protocol's `__next__()` method by delegating to `iter(self)` and calling `next()` on the resulting iterator. Returns a value of type `V` (generic type). Uses the object's `__iter__()` method to create a fresh generator each call, which is re-entry safe because the underlying `self.iter` iterable maintains state. This delegation pattern avoids duplicating iteration logic while maintaining proper iterator semantics."
      },
      "render_finish": {
        "human": "Completes and cleans up the display of a progress bar when a task finishes. It writes a final message or formatting to the screen and ensures it's immediately visible. If the progress bar is hidden or the output isn't going to a terminal, it does nothing to avoid cluttering logs or files.",
        "technical": "Finalizes progress bar rendering by checking two guard conditions (self.hidden and self._is_atty). If rendering is active, writes the AFTER_BAR constant (likely formatting/newline characters) to self.file stream and calls flush() to force immediate output to the terminal. Returns None with no return value. Side effect: modifies terminal display state."
      },
      "pct": {
        "human": "Calculates how much of a task or process has been completed as a percentage (from 0.0 to 1.0). If the task is already finished, it returns 100% (1.0). Otherwise, it divides the current position by the total length to show progress, making sure the result never exceeds 100% even if the numbers are unusual.",
        "technical": "Property method that returns completion percentage as float between 0.0 and 1.0. Returns 1.0 immediately if `self.finished` flag is True. Otherwise calculates `self.pos / self.length` with defensive programming: converts length to float, defaults to 1 if length is 0 or None, and uses `min()` to cap result at 1.0 to prevent values exceeding 100%."
      },
      "time_per_iteration": {
        "human": "Calculates the average time taken per iteration by looking at a collection of timing measurements. If there are no measurements available yet, it returns zero. This helps track performance by showing how long each iteration typically takes.",
        "technical": "Property method that computes arithmetic mean of timing values stored in `self.avg` list. Returns 0.0 if list is empty (guard clause), otherwise sums all values using `sum()` and divides by count using `len()` with explicit `float()` conversion. Returns float representing average iteration time."
      },
      "eta": {
        "human": "Estimates how much time is left until a task completes. It calculates this by looking at how fast the task is progressing and how much work remains. If the task is already finished or the total amount of work is unknown, it simply returns zero to indicate no time remaining.",
        "technical": "Property method that calculates estimated time to completion (ETA) by multiplying `time_per_iteration` by remaining iterations (`length - pos`). Returns float value representing seconds remaining. Guards against invalid states by checking `length is not None` and `not self.finished` before calculation; returns 0.0 otherwise. No external function calls or side effects."
      },
      "format_eta": {
        "human": "Converts a time duration (estimated time remaining) into a readable format showing days, hours, minutes, and seconds. If the time is known, it displays it like \"2d 05:30:45\" for durations over a day, or just \"05:30:45\" for shorter periods. If the time isn't available yet, it returns an empty string.",
        "technical": "Checks `self.eta_known` flag, then converts `self.eta` (assumed to be in seconds) to integer and performs modulo/floor division operations to extract seconds, minutes, hours, and days components. Returns formatted string with zero-padded time components (HH:MM:SS or Dd HH:MM:SS format) if eta is known, otherwise returns empty string. No side effects; pure formatting function."
      },
      "format_pos": {
        "human": "Creates a text representation of a position or progress indicator, showing where you are in a sequence. If a total length is known, it displays both the current position and the total (like \"5/10\"), otherwise just shows the current position (like \"5\"). This is commonly used for progress displays or navigation indicators.",
        "technical": "Converts the instance's `pos` attribute to string, then conditionally appends a forward slash and `length` attribute if `length` is not None, using f-string formatting. Returns the formatted string representation. Performs simple string concatenation with no side effects. The method accesses two instance attributes (`self.pos` and `self.length`) and returns a formatted position string in \"current/total\" or \"current\" format."
      },
      "format_bar": {
        "human": "Creates a visual progress bar as a text string. If the total length is known, it shows how much is complete versus remaining. If the length is unknown but work is finished, it shows a full bar. Otherwise, it displays an animated indicator that moves back and forth to show that work is ongoing.",
        "technical": "Generates a string representation of a progress bar based on three conditions: (1) if `self.length` exists, calculates bar_length from `self.pct * self.width` and fills with `fill_char` and `empty_char` proportionally; (2) if `self.finished` is true, returns full bar of `fill_char`; (3) otherwise creates indeterminate animation using `math.cos()` with `self.pos * self.time_per_iteration` to calculate oscillating position of single `fill_char` within `empty_char` array. Returns concatenated string."
      },
      "format_progress_line": {
        "human": "Creates a formatted text line that shows progress information for a task or operation. It assembles different pieces of information (like position, percentage complete, estimated time remaining, and current item details) and combines them with a visual progress bar into a single display line that can be shown to users.",
        "technical": "Constructs a progress display string by conditionally building an info_bits list based on configuration flags (show_pos, show_percent, show_eta). Calls format_pos(), format_pct(), format_eta() to generate respective components, and optionally invokes item_show_func() for custom item display. Returns a formatted string by substituting label, bar (from format_bar()), and joined info components into bar_template, with trailing whitespace removed via rstrip()."
      },
      "render_progress": {
        "human": "Displays a progress bar in the terminal that updates as work is being done. It shows the current status on one line that refreshes in place, avoiding cluttering the screen with multiple lines. If the terminal window is resized, it automatically adjusts the progress bar width to fit. For non-interactive outputs (like log files), it only prints the label once instead of continuously updating.",
        "technical": "Renders a progress bar to terminal by building a string buffer with formatted progress line. Handles three scenarios: hidden (returns early), non-TTY output (prints label once), and TTY output (dynamic updates). For TTY, detects terminal resize via `shutil.get_terminal_size()`, recalculates width based on available columns minus clutter length, tracks `max_width` for proper clearing, and only calls `echo()` when the rendered line differs from `_last_line` to minimize redraws. Flushes output stream after each render."
      },
      "make_step": {
        "human": "Updates a progress tracker by moving forward a certain number of steps and calculating how long the remaining work will take. It tracks the average speed of progress and updates the estimated completion time, but only refreshes this estimate once per second to avoid excessive calculations. Marks the task as finished when it reaches the total length.",
        "technical": "Increments `self.pos` by `n_steps`, sets `self.finished` flag if position reaches `self.length`. Throttles ETA calculations to once per second using `time.time()` comparison. Computes step duration as elapsed time divided by current position, maintains rolling average in `self.avg` (last 6 values plus current). Updates `self.eta_known` flag based on whether `self.length` is defined. Modifies instance state: `pos`, `finished`, `last_eta`, `avg`, and `eta_known`."
      },
      "update": {
        "human": "Moves a progress bar forward by a certain number of steps and updates what item is currently being processed. It doesn't update the display every single time though - it waits until enough steps have accumulated to avoid flickering or slowing things down. Think of it like a download progress bar that only refreshes every few percent instead of constantly.",
        "technical": "Increments internal counter `_completed_intervals` by `n_steps` and optionally sets `current_item` attribute. Implements throttled rendering: only calls `make_step()` and `render_progress()` when accumulated intervals reach `update_min_steps` threshold, then resets counter to zero. This batching mechanism prevents excessive UI updates for high-frequency progress updates."
      },
      "finish": {
        "human": "Marks a progress tracking operation as complete. When called, it signals that whatever task was being monitored has finished, clears out information about what was currently being tracked, and indicates that progress details are no longer available. This is typically the final step when a task completes.",
        "technical": "Sets three instance attributes to finalize state: sets `eta_known` to False (disabling estimated time remaining), clears `current_item` to None (removing reference to active item), and sets `finished` flag to True (marking completion state). No return value; operates purely through side effects on object state. No external function calls or I/O operations."
      },
      "generator": {
        "human": "Creates a generator that displays a progress bar while processing a list of items. As each item is processed, the progress bar updates to show how much work has been completed. It ensures the progress bar is properly set up before starting and handles both terminal and non-terminal environments differently. When all items are processed, it marks the progress bar as finished.",
        "technical": "Yields items from `self.iter` one at a time, calling `self.update(1)` after each yield to increment progress. Checks `self.entered` flag to ensure context manager usage. For TTY environments, renders progress display via `self.render_progress()` at interval boundaries and stores current item in `self.current_item`. For non-TTY, delegates directly to `self.iter`. Calls `self.finish()` and final `self.render_progress()` after iteration completes. Designed as stateless generator safe for repeated invocation by iterator protocol."
      },
      "get_editor": {
        "human": "Finds and returns the name of a text editor program that should be used to open files for editing. It checks several places in order: first any editor that was already set, then system preferences, then common editors installed on the computer. If nothing else is found, it falls back to basic default editors that are usually available.",
        "technical": "Returns a string containing the editor command name by checking in priority order: (1) instance attribute `self.editor` if set, (2) environment variables `VISUAL` and `EDITOR`, (3) \"notepad\" if on Windows platform, (4) searches PATH using `shutil.which()` for \"sensible-editor\", \"vim\", or \"nano\", (5) defaults to \"vi\" as final fallback. No side effects; purely reads configuration and system state."
      },
      "edit_files": {
        "human": "Opens one or more files in the user's preferred text editor (like Notepad, vim, or VS Code) and waits for them to finish editing. If the editor can't be opened or the editing process fails, it shows an error message. This allows programs to let users edit files interactively, pausing until they're done.",
        "technical": "Retrieves the configured editor via `get_editor()`, optionally merges custom environment variables with `os.environ.copy()`, then launches the editor as a subprocess using `subprocess.Popen` with shell=True. Concatenates multiple filenames into a quoted space-separated string for the command. Blocks on `c.wait()` to get exit code, raising `ClickException` if non-zero or if `OSError` occurs during process creation."
      },
      "edit": {
        "human": "Opens a temporary text file in an external editor (like Notepad or vim) so the user can edit some text. The function waits for the user to make changes and save the file, then reads back what they wrote. If the user closes the editor without saving, it returns nothing. This is commonly used in command-line tools to let users edit multi-line text.",
        "technical": "Creates a temporary file via `tempfile.mkstemp()`, writes input text (handling encoding for Windows CRLF vs Unix LF), then calls `self.edit_files()` to launch external editor. Uses filesystem timestamp comparison to detect if file was modified. Handles both text (UTF-8 with BOM support) and binary data modes. Returns edited content in same format as input, or None if `require_save` is True and no changes detected. Ensures cleanup via try/finally with `os.unlink()`."
      },
      "_unquote_file": {
        "human": "Converts a file URL into a regular file path that can be used to access files on your computer. If the URL starts with \"file://\", it removes that prefix and decodes any special characters (like %20 for spaces) back into their normal form. This makes file URLs usable as actual file paths.",
        "technical": "Takes a URL string and checks if it has a \"file://\" scheme prefix using `startswith()`. If present, strips the first 7 characters (\"file://\") and applies `urllib.parse.unquote()` to decode percent-encoded characters. Returns the processed string (either unquoted file path or original URL unchanged). No side effects; pure string transformation function."
      },
      "getchar": {
        "human": "Reads a single character (or key press) directly from the keyboard input in a special \"raw\" mode that captures the key immediately without waiting for Enter. Optionally displays the character back to the screen as you type it (echo). This is useful for interactive programs that need to respond to individual keystrokes, like password prompts or menu selections.",
        "technical": "Enters raw terminal mode to bypass line buffering, reads up to 32 bytes from the file descriptor using os.read(), decodes the bytes to a string using the best available encoding with replacement for invalid characters. Conditionally echoes the character to stdout if requested and output is a terminal. Calls _translate_ch_to_exc() to handle special character sequences (likely Ctrl+C/D), then returns the decoded character string."
      },
      "raw_terminal": {
        "human": "Temporarily switches the terminal into \"raw mode\" where it captures every single keystroke directly, without waiting for the Enter key or processing special characters. This is useful for interactive programs that need immediate keyboard input, like text editors or games. After the program is done, it automatically restores the terminal back to normal behavior so typing works normally again.",
        "technical": "Context manager that configures terminal in raw mode using tty.setraw(). Opens /dev/tty if stdin isn't a terminal, otherwise uses stdin's file descriptor. Saves original terminal settings via termios.tcgetattr(), yields the file descriptor for raw input operations, then restores settings with termios.tcsetattr(TCSADRAIN) in finally block. Handles termios.error exceptions silently and ensures cleanup of opened file handles."
      }
    },
    "src/click/_textwrap.py": {
      "_handle_long_word": {
        "human": "Handles words that are too long to fit on the current line when wrapping text. If breaking long words is allowed, it splits the word to fill the remaining space on the line and saves the rest for later. If breaking isn't allowed but the line is empty, it places the entire long word on the line anyway to avoid getting stuck.",
        "technical": "Calculates available space with `max(width - cur_len, 1)`. If `break_long_words` is True, slices the last chunk from `reversed_chunks` at `space_left`, appends the cut portion to `cur_line`, and updates the chunk with the remainder. If False and `cur_line` is empty, pops the entire chunk from `reversed_chunks` and appends to `cur_line`. Modifies `reversed_chunks` and `cur_line` in-place; returns None."
      },
      "extra_indent": {
        "human": "Temporarily adds extra spacing to the beginning of text lines. When you need to indent a block of text more than usual (like for nested lists or quotes), this function increases the indentation, lets you format your text, then automatically restores the original indentation level when done. It's like pressing the tab key extra times, but it cleans up after itself.",
        "technical": "Context manager that temporarily augments both `initial_indent` and `subsequent_indent` attributes by concatenating the provided indent string. Stores original values, modifies indentation attributes, yields control to caller, then restores original values in finally block. Uses try-finally pattern to guarantee restoration even if exceptions occur. Returns Iterator[None] as required by @contextmanager decorator."
      },
      "indent_only": {
        "human": "Takes a block of text and adds indentation (spacing) to the beginning of each line. The first line gets one type of indentation, and all following lines get a different type of indentation. This is useful for formatting text with hanging indents or consistent spacing, like in formatted paragraphs or code output.",
        "technical": "Splits input text into lines using splitlines(), iterates with enumerate() to track line position. Applies self.initial_indent to first line (idx=0) and self.subsequent_indent to all subsequent lines. Builds list of indented lines via rv.append(), then joins with newline separators. Returns single string with all lines indented according to the two-indent pattern."
      }
    },
    "src/click/_winconsole.py": {
      "_get_text_stdin": {
        "human": "Creates a special text input stream for reading from the Windows console that properly handles Unicode characters. This is needed because Windows consoles use a different character encoding (UTF-16) than standard text streams. It wraps the console input so programs can read text correctly from the command line on Windows systems.",
        "technical": "Constructs a Windows-specific text input stream by wrapping a `_WindowsConsoleReader` (using STDIN_HANDLE) in a `BufferedReader`, then wrapping that in a `_NonClosingTextIOWrapper` with UTF-16-LE encoding. Returns a `ConsoleStream` object that combines the text stream with the original binary buffer stream, cast to `t.TextIO`. Enables proper Unicode console input handling on Windows platforms."
      },
      "_get_text_stdout": {
        "human": "Creates a special text output stream for writing to the Windows console that handles Unicode characters properly. This solves the problem of displaying international characters and emojis correctly in Windows command prompts, which have special requirements different from regular text output. It wraps the Windows console with proper encoding so text appears correctly on screen.",
        "technical": "Constructs a text output stream for Windows console by wrapping _WindowsConsoleWriter with io.BufferedWriter for the Windows STDOUT_HANDLE, then wrapping in _NonClosingTextIOWrapper with UTF-16-LE encoding and line buffering enabled. Returns a ConsoleStream that combines this text stream with the original buffer_stream parameter, cast to t.TextIO. Handles Windows-specific console output requirements through custom writer classes."
      },
      "_get_text_stderr": {
        "human": "Creates a special text output stream for writing error messages to the Windows console. This is needed because Windows handles console text differently than regular files, requiring special encoding (UTF-16) and custom writing logic. The function wraps the Windows-specific console writer so that error messages display correctly in the command prompt or terminal.",
        "technical": "Constructs a text-mode stderr stream for Windows console output by wrapping `_WindowsConsoleWriter(STDERR_HANDLE)` in `io.BufferedWriter`, then wrapping that in `_NonClosingTextIOWrapper` with UTF-16-LE encoding and strict error handling. Returns a `ConsoleStream` object (cast to `t.TextIO`) that combines the text stream with the original binary buffer stream, enabling proper Windows console stderr output with line buffering enabled."
      },
      "_is_console": {
        "human": "Checks whether a given file object (like something you're reading from or writing to) is actually connected to a Windows console window (like Command Prompt or PowerShell). This is useful for programs that need to behave differently when running in an interactive terminal versus when their output is redirected to a file or pipe.",
        "technical": "Validates if a TextIO object represents a Windows console by: (1) checking for fileno attribute existence, (2) safely retrieving the file descriptor via fileno(), (3) converting it to a Windows OS handle using msvcrt.get_osfhandle(), and (4) testing if GetConsoleMode() succeeds on that handle (which only works for console handles). Returns True only if all checks pass, False otherwise including on any exceptions."
      },
      "_get_windows_console_stream": {
        "human": "Attempts to create a special Windows console stream for handling text input/output. It checks if the system supports Windows console operations and if the text encoding is compatible (UTF-16). If all conditions are met, it creates and returns a specialized stream object; otherwise, it returns None to indicate the standard stream should be used instead.",
        "technical": "Validates preconditions for Windows console stream creation: checks if `get_buffer` exists, encoding is UTF-16-LE or None, errors mode is strict or None, and `_is_console(f)` returns True. Retrieves a factory function from `_stream_factories` dict using file descriptor from `f.fileno()`, accesses the underlying buffer via `getattr(f, \"buffer\", None)`, and invokes the factory function with the buffer to construct the console stream. Returns None if any validation fails."
      },
      "get_buffer": {
        "human": "Provides direct access to the raw memory contents of any Python object that supports the buffer protocol (like bytes, bytearray, or memoryview). This allows reading or writing the underlying data directly without copying it, which is useful for performance-critical operations or interfacing with low-level code. The function ensures proper cleanup of resources even if errors occur.",
        "technical": "Uses Python's C API buffer protocol via ctypes to obtain a memory view of a buffer object. Calls PyObject_GetBuffer() with appropriate flags (PyBUF_WRITABLE or PyBUF_SIMPLE) to get a Py_buffer structure, then creates a ctypes c_char array from the buffer's memory address. Returns the array pointer while ensuring PyBuffer_Release() is called in a finally block to prevent memory leaks. The returned Array[c_char] provides direct memory access without copying data."
      },
      "isatty": {
        "human": "This function checks if the output is connected to a terminal (like a command prompt or console window). However, it's designed to always say \"yes, it's a terminal\" regardless of the actual situation. It's likely used in testing or special cases where you want to pretend the output is always going to an interactive terminal.",
        "technical": "Overrides the `isatty()` method by calling the parent class implementation via `super().isatty()` (likely for side effects or logging), then unconditionally returns `True`. The return type annotation `t.Literal[True]` explicitly indicates this method always returns the boolean value `True`, making it a stub or mock implementation that forces terminal-like behavior regardless of actual TTY status."
      },
      "readinto": {
        "human": "Reads text input from a Windows console terminal into a provided buffer. It handles the special way Windows consoles work with text (using UTF-16 encoding, where each character takes 2 bytes). If the user presses Ctrl+C or reaches the end of input, it handles those situations appropriately. Returns how many bytes were successfully read.",
        "technical": "Reads UTF-16-LE encoded data from Windows console using ReadConsoleW API. Validates buffer length is even (UTF-16 requirement), converts byte count to code units (\u00f72), and calls ReadConsoleW with handle and writable buffer. Handles ERROR_OPERATION_ABORTED for keyboard interrupts with 0.1s sleep. Checks for EOF marker in first buffer position. Returns bytes read (code_units * 2) or 0 for EOF/empty buffer."
      },
      "_get_error_message": {
        "human": "Converts Windows error codes into readable error messages. When something goes wrong in Windows operations, this function translates the numeric error code into a text description that people can understand. It recognizes two specific common errors (success and out-of-memory) and provides a generic message for all other error codes.",
        "technical": "Maps integer Windows error codes to string representations. Checks errno against two constants (ERROR_SUCCESS and ERROR_NOT_ENOUGH_MEMORY) and returns corresponding string literals. For unrecognized error codes, returns a formatted string containing the numeric value. Pure function with no side effects, simple conditional logic with early returns."
      },
      "write": {
        "human": "This function writes data to an output stream, handling both text and binary data. If you give it text (like a string), it writes it one way; if you give it binary data (like bytes), it writes it a different way. It's like a smart writer that automatically chooses the right pen depending on what type of content you're writing.",
        "technical": "Performs type-based routing for write operations: if input is a string, delegates to `_text_stream.write()`; otherwise, attempts to flush any buffered content (suppressing exceptions), then writes to `buffer.write()` for binary data. Returns the number of bytes/characters written. Implements a dual-stream write interface that separates text and binary I/O paths."
      },
      "__init__": {
        "human": "Sets up a dual-stream handler that can work with both text and binary data. This is like creating a container that holds two different types of communication channels - one for regular text and another for raw binary data (like images or files). This allows the object to handle different types of data appropriately.",
        "technical": "Constructor that initializes instance attributes for dual I/O stream handling. Stores the text_stream parameter as a private attribute `_text_stream` and byte_stream as a public attribute `buffer`. No validation, transformation, or I/O operations performed - purely assignment of the two stream objects for later use by other methods in the class."
      },
      "writelines": {
        "human": "Writes multiple lines of text to a file or output stream at once. Instead of writing each line separately, you can pass in a collection of lines (like a list) and this function will write them all out one after another. It's a convenience feature that saves you from having to write a loop yourself every time you want to output multiple lines.",
        "technical": "Iterates over an iterable collection of strings (lines parameter typed as cabc.Iterable[t.AnyStr]) and calls self.write() for each element. Performs no line separator insertion - relies on the caller to include newlines in the input strings if needed. Returns None and produces side effects through repeated write() calls. Standard implementation of the file-like object writelines() interface method."
      }
    },
    "src/click/core.py": {
      "_complete_visible_commands": {
        "human": "This function helps with command-line auto-completion by finding all available subcommands that match what the user has started typing. It filters out hidden commands (internal/administrative commands not meant for regular users) and only shows commands that begin with the partial text entered. This makes it easier for users to discover and complete command names without typing them fully.",
        "technical": "Casts the context's command to a Group type, then iterates through all subcommands via `multi.list_commands(ctx)`. For each command name matching the incomplete prefix (using `name.startswith()`), retrieves the Command object via `multi.get_command()`. Filters out None results and hidden commands, yielding tuples of (command_name, Command_object) as an iterator. Returns generator of visible, matching command completions for CLI autocomplete functionality."
      },
      "_check_nested_chain": {
        "human": "This function acts as a safety guard that prevents a specific invalid configuration in command-line interfaces. It checks if you're trying to add a group of commands inside another group that's set to \"chain mode\" (where commands run in sequence). If this forbidden combination is detected, it stops the program and explains why this setup isn't allowed.",
        "technical": "Validates that a Group command is not being added to a base_command Group that has chain mode enabled. Returns early if base_command.chain is False or cmd is not a Group instance. Otherwise, raises RuntimeError with context-specific message based on the `register` flag (True for registration attempts, False for existing subcommand detection). Performs type checking using isinstance() and accesses Group.chain and Group.name attributes."
      },
      "augment_usage_errors": {
        "human": "This function wraps code that might fail with command-line usage errors and automatically fills in missing context information. When errors occur (like invalid parameters or incorrect command usage), it ensures the error messages include details about which command and parameter caused the problem, making it easier for users to understand what went wrong.",
        "technical": "Context manager that catches `BadParameter` and `UsageError` exceptions, enriching them with context before re-raising. For `BadParameter`, populates both `e.ctx` (command context) and `e.param` (parameter object) if they're None. For `UsageError`, only populates `e.ctx`. Uses try-except-raise pattern to intercept, augment, and propagate exceptions without suppressing them. Returns an iterator that yields once for the with-block execution."
      },
      "iter_params_for_processing": {
        "human": "Determines the correct order to process command-line parameters by balancing two priorities: the order users typed them and which parameters are marked as \"eager\" (needing immediate processing). Eager parameters always go first, then everything else follows the order the user provided them. Parameters the user didn't specify at all are placed at the end.",
        "technical": "Sorts `declaration_order` parameters using a two-part key: eagerness flag (inverted boolean) and position in `invocation_order`. Uses `invocation_order.index()` to find each parameter's invocation position, assigning `float(\"inf\")` for parameters not invoked. The `sort_key` returns `(not item.is_eager, idx)` tuple, ensuring eager parameters sort first (False < True), then by invocation index. Returns sorted list of Parameter objects."
      },
      "_check_iter": {
        "human": "This function validates that a value can be looped over (like a list or tuple) but rejects text strings. It's used when you need to process collections of items but want to prevent accidentally treating a single word as a collection of letters. If the value passes validation, it prepares it for looping.",
        "technical": "Performs type guard validation by checking if input is a string instance using `isinstance()`, raising `TypeError` if true. For non-string values, calls built-in `iter()` to convert the value into an iterator object and returns it. Relies on `iter()` to implicitly validate iterability - will raise `TypeError` if value doesn't support iteration protocol."
      },
      "__getattr__": {
        "human": "This function handles requests for old, outdated names of Click library components. When someone tries to use the old names \"BaseCommand\" or \"MultiCommand\", it warns them that these names are being phased out and tells them to use the new names instead (\"Command\" and \"Group\"). If someone asks for any other unknown name, it reports an error.",
        "technical": "Module-level `__getattr__` implementation that provides backward compatibility for deprecated Click class names. Intercepts attribute access for \"BaseCommand\" and \"MultiCommand\", emits `DeprecationWarning` via `warnings.warn()` with stacklevel=2, and returns corresponding internal classes `_BaseCommand` and `_MultiCommand`. Raises `AttributeError` for any other undefined attribute access. Enables lazy deprecation warnings at import time."
      },
      "sort_key": {
        "human": "This function determines the sorting order for parameters by considering two factors: whether a parameter should be processed immediately (eager) or can wait, and the order in which parameters were originally called or defined. Parameters that can wait are sorted first, followed by eager ones. Within each group, they're ordered by when they were first used, with any unknown parameters placed at the end.",
        "technical": "Returns a tuple used as a sort key: first element is the negation of `item.is_eager` (non-eager parameters sort first), second element is the parameter's index in `invocation_order` list or `float(\"inf\")` if not found. Uses `invocation_order.index()` with ValueError exception handling to safely retrieve position. The tuple enables stable two-level sorting: primary by eagerness (boolean), secondary by invocation sequence (numeric)."
      },
      "__init__": {
        "human": "Sets up a command-line argument with smart defaults for whether it's required or optional. If you don't specify whether the argument is mandatory, it figures this out automatically: arguments without default values are required, while those with defaults are optional. It also prevents using an unsupported option called 'multiple' and passes everything to the parent setup process.",
        "technical": "Constructor that auto-detects the `required` parameter based on argument configuration. Checks if `default` is UNSET and `nargs > 0` to determine requirement status. Validates that 'multiple' keyword is not present in attrs (raises TypeError if found). Calls parent class `__init__` with processed param_decls, computed required flag, and remaining attrs. Uses UNSET sentinel value for default detection."
      },
      "protected_args": {
        "human": "This function retrieves a list of protected command-line arguments, but it's outdated and scheduled for removal. When you use it, the program warns you that this feature is being phased out and you should use a different approach instead. It's like a deprecated feature that still works but tells you to stop using it because it will be removed in the next major version.",
        "technical": "Property method that returns `self._protected_args` (a list of strings) while emitting a DeprecationWarning via `warnings.warn()`. The warning indicates this property is deprecated in favor of using 'args' directly for unparsed tokens, with removal planned for Click 9.0. Uses `stacklevel=2` to report the warning at the caller's location rather than within this function itself."
      },
      "to_info_dict": {
        "human": "Creates a detailed information dictionary about a command-line option or parameter that can be used for documentation or help displays. It gathers all the important characteristics of the option (like whether it's a flag, if it has a prompt, if it's hidden, etc.) and packages them into an easy-to-read format. Special care is taken to hide internal implementation details from users.",
        "technical": "Calls parent class `to_info_dict()` to get base dictionary, then updates it with option-specific attributes: `help`, `prompt`, `is_flag`, `flag_value`, `count`, and `hidden`. Implements special handling for `flag_value` by converting the internal `UNSET` sentinel value to `None` before returning, ensuring implementation details aren't exposed in the documentation-oriented output. Returns the merged dictionary containing all option metadata."
      },
      "__enter__": {
        "human": "This function sets up a context manager that can be used with Python's \"with\" statement. When you enter a \"with\" block, it tracks how deeply nested you are in these blocks and registers this context as the currently active one. It's like opening a door to a special workspace that keeps track of how many times you've entered it.",
        "technical": "Implements the context manager protocol's entry method. Increments the internal `_depth` counter to track nesting level, calls `push_context(self)` to register this context instance on a global context stack, and returns `self` to allow the context object to be bound to the `as` variable in a `with` statement. Side effect: modifies global context state."
      },
      "__exit__": {
        "human": "This function handles cleanup when exiting a context manager (like when leaving a \"with\" block). It tracks how deeply nested the context is and only performs final cleanup when completely exiting the outermost level. It ensures proper resource cleanup whether the code block succeeded or failed, and removes the context from a tracking system.",
        "technical": "Implements context manager exit protocol by decrementing depth counter and conditionally closing resources. When depth reaches 0, calls `_close_with_exception_info()` passing exception details (exc_type, exc_value, tb) for proper error handling. Always calls `pop_context()` to remove context from stack. Returns exit_result (bool | None) which can suppress exceptions if True, propagate if False/None."
      },
      "scope": {
        "human": "This function temporarily makes a context object the \"active\" one for the current thread, so other parts of the program can find and use it. You can optionally skip cleanup tasks (like closing files) if you only need the context briefly. It's a flexible way to control when a context becomes active and when its resources get released.",
        "technical": "Context manager that wraps `self` (the Context object) and yields it, with optional cleanup control via `_depth` counter manipulation. When `cleanup=False`, increments `_depth` before entering and decrements after exiting to prevent cleanup functions from running. Delegates to the Context's `__enter__`/`__exit__` methods via `with self as rv`. Returns an Iterator[Context] that yields the context instance."
      },
      "meta": {
        "human": "Provides access to a shared storage space where Click (a command-line tool framework) and its extensions can save temporary information that needs to be available across different levels of command execution. Think of it as a shared notepad that all parts of your command-line application can read from and write to, using unique names to avoid conflicts.",
        "technical": "Property getter that returns the internal `_meta` dictionary attribute. This dictionary is shared across nested Click contexts and serves as a key-value store for framework-level state management. Keys should follow dotted string naming convention (e.g., module paths) to ensure uniqueness. Returns `dict[str, t.Any]` allowing storage of arbitrary typed values. No computation or transformation occurs\u2014simply exposes the underlying `_meta` attribute."
      },
      "make_formatter": {
        "human": "Creates a formatting tool that controls how help messages and usage instructions are displayed to users. It sets up the visual layout by determining how wide the text should be on the screen, ensuring help text fits nicely within the terminal window without awkward line breaks or overflow.",
        "technical": "Instantiates and returns a HelpFormatter object using the class specified in `self.formatter_class`. Passes two width parameters to the formatter constructor: `width` from `self.terminal_width` (current terminal size) and `max_width` from `self.max_content_width` (maximum allowed content width). Returns the configured formatter instance for rendering help/usage output."
      },
      "with_resource": {
        "human": "Allows you to register a resource (like a database connection or file) that needs to be properly opened and closed. The function ensures the resource is automatically cleaned up later when you're done with it, similar to using Python's \"with\" statement. This prevents resource leaks by guaranteeing cleanup happens even if errors occur.",
        "technical": "Delegates to `ExitStack.enter_context()` to invoke the context manager's `__enter__()` method and register its `__exit__()` for deferred cleanup. Returns the result of `__enter__()` immediately while storing the exit callback in the internal `_exit_stack`. When the context is popped, the stack unwinds and calls all registered `__exit__()` methods in LIFO order. Generic type `V` preserves the return type of the context manager."
      },
      "call_on_close": {
        "human": "Registers a cleanup function that will automatically run when your program finishes or exits a specific section of code. This is useful for tasks like closing files, disconnecting from databases, or releasing resources that were opened during execution. It's specifically for simple cleanup functions, not for resources that have built-in cleanup mechanisms.",
        "technical": "Delegates to `ExitStack.callback()` to register a callable for deferred execution during context teardown. The function `f` is added to an internal stack and will be invoked in LIFO order when the exit stack unwinds. Returns the original function unchanged, allowing it to be used immediately if needed. No validation or wrapping occurs\u2014pure passthrough to the exit stack's callback mechanism."
      },
      "close": {
        "human": "Cleans up and releases all resources that were registered for cleanup when this object is done being used. This is like closing all open files, disconnecting from servers, or releasing any other resources that were marked to be cleaned up later. It ensures nothing is left hanging or wasting system resources.",
        "technical": "Delegates to `_close_with_exception_info()` with three `None` arguments (representing no exception context). Acts as a public interface for normal cleanup scenarios without exception handling. The actual cleanup logic (invoking registered callbacks and exiting context managers) is implemented in the private `_close_with_exception_info` method. No return value; performs side effects only."
      },
      "_close_with_exception_info": {
        "human": "This function performs cleanup when something goes wrong (or finishes normally) by notifying all registered resources about the exception so they can handle it appropriately. After cleanup is complete, it resets the system so it's ready to be used again. Think of it like closing all open doors in a building during an emergency, then resetting the door system for the next use.",
        "technical": "Delegates exception handling to the internal `ExitStack.__exit__()` method, passing through exception type, value, and traceback. Captures the exit result (boolean indicating if exception was suppressed). Immediately replaces `self._exit_stack` with a fresh `ExitStack()` instance to enable context reuse. Returns the original exit result to propagate exception suppression behavior up the call chain."
      },
      "command_path": {
        "human": "Builds the full command name by walking up the chain of parent commands to create a complete path. For example, if you run \"git commit --amend\", this creates the text \"git commit\" that appears in help messages. It shows users where they are in a nested command structure, making help text more informative about which specific command is being documented.",
        "technical": "Recursively constructs command path string by traversing parent context chain from current to root. Starts with `self.info_name`, then prepends `parent.command_path` and any parameter usage pieces from `parent.command.get_params()` if parent is a Command instance. Joins components with spaces, strips leading whitespace via `lstrip()`, and returns the complete path string used for usage documentation."
      },
      "find_root": {
        "human": "Climbs up a family tree or hierarchy to find the topmost ancestor. Starting from the current position, it keeps moving up to each parent until it reaches the very top level that has no parent above it. This is useful when you need to find the root or starting point of a nested structure.",
        "technical": "Traverses up the parent chain of Context objects using a while loop that continues until node.parent is None. Initializes traversal with self, then repeatedly reassigns node to node.parent. Returns the topmost Context object in the hierarchy. No side effects - purely reads the parent attribute without modifying any state."
      },
      "find_object": {
        "human": "Searches upward through a chain of connected contexts to find the first one that contains an object matching a specific type you're looking for. It starts from the current position and keeps checking parent contexts until it either finds a match or runs out of places to look. Returns the matching object if found, otherwise returns nothing. This is useful for locating resources or settings stored somewhere up the hierarchy.",
        "technical": "Traverses a linked list of Context nodes upward via parent references, using isinstance() to check if each node's obj attribute matches the requested object_type. Implements a simple while loop that terminates when either a matching object is found (returns node.obj) or the parent chain is exhausted (node becomes None). Returns V | None type, performing a linear search with O(n) complexity where n is the depth of the context hierarchy."
      },
      "ensure_object": {
        "human": "Finds an object of a specific type in a collection, and if it doesn't exist, automatically creates a new one and stores it. This ensures you always get back a valid object to work with, eliminating the need to check if something exists before using it. It's like asking for a tool from a toolbox - if the tool isn't there, it gets added first before being handed to you.",
        "technical": "Calls `self.find_object(object_type)` to search for an existing instance. If the search returns `None`, instantiates a new object using `object_type()` and assigns it to `self.obj`. Returns either the found object or the newly created instance. Has a side effect of modifying `self.obj` when creating a new instance. Guarantees non-None return value of type `V`."
      },
      "lookup_default": {
        "human": "Retrieves a default value for a parameter by looking it up in a stored dictionary of defaults. If the default value happens to be a function, it can automatically run that function and return its result, or just return the function itself depending on what you need. Returns a special \"not set\" marker if no default exists.",
        "technical": "Checks if `self.default_map` exists, then performs dictionary lookup using `get(name, UNSET)`. If `call=True` and the retrieved value is callable, invokes it with `value()` and returns the result; otherwise returns the raw value. Returns `UNSET` sentinel if `default_map` is None or key doesn't exist. Enables lazy evaluation of default values through callable support."
      },
      "fail": {
        "human": "This function stops the program immediately when something goes wrong with how the user is trying to use it. It displays a helpful error message explaining what the problem is, then exits the program. This is typically used when a user provides invalid input or uses a command incorrectly.",
        "technical": "Raises a UsageError exception with the provided error message and a reference to the current context object (self). The function signature uses t.NoReturn type hint to indicate it never returns normally - execution always terminates via exception. UsageError is a custom exception class that likely handles formatting and displaying usage-related errors to the user."
      },
      "abort": {
        "human": "This function immediately stops the script from running any further. It's like an emergency stop button that terminates the program when something goes wrong or when you need to exit immediately. Instead of letting the script continue or return normally, it forces an abrupt halt.",
        "technical": "Raises an `Abort` exception to terminate execution flow. This is a control flow mechanism that doesn't return a value (indicated by `t.NoReturn` type hint). The function acts as a wrapper around the `Abort` exception, providing a cleaner API for script termination. The exception propagates up the call stack until caught by an exception handler or terminates the program."
      },
      "exit": {
        "human": "Terminates the application and stops it from running any further. Before shutting down, it makes sure to properly clean up any resources that were being used (like open files or connections). This is the proper way to end the program with a specific exit status that indicates whether it succeeded or failed.",
        "technical": "Invokes `self.close()` to trigger cleanup of registered callbacks and context managers, then raises an `Exit` exception with the provided exit code (defaults to 0). The Exit exception propagates up the call stack to terminate program execution. Returns `t.NoReturn` type hint indicating this function never returns normally. Side effect: closes all registered resources before program termination."
      },
      "get_usage": {
        "human": "Creates a formatted text string that shows how to properly use a command or tool. This is the \"usage\" line you typically see at the top of help messages, like \"Usage: program [OPTIONS] COMMAND\". It takes the raw formatting information and converts it into a clean, ready-to-display string by removing any trailing blank lines.",
        "technical": "Instantiates a formatter object via `ctx.make_formatter()`, delegates formatting logic to `self.format_usage(ctx, formatter)` which populates the formatter's buffer, then retrieves the formatted string using `formatter.getvalue()`. Applies `rstrip(\"\\n\")` to remove trailing newlines before returning the final usage string. Acts as a convenience wrapper that encapsulates the formatter creation, population, and cleanup workflow."
      },
      "get_help": {
        "human": "Generates a formatted help text string that can be displayed to users who need assistance with a command or application. It takes the current context (information about where the user is in the application), creates a properly formatted help message, and returns it as clean text ready to be shown on screen.",
        "technical": "Creates a formatter object via `ctx.make_formatter()`, delegates help content generation to `self.format_help(ctx, formatter)` which populates the formatter, then retrieves the accumulated string using `formatter.getvalue()`. Strips trailing newlines with `.rstrip(\"\\n\")` before returning the final help string. No side effects; pure data transformation returning a formatted string."
      },
      "_make_sub_context": {
        "human": "Creates a child context that inherits from the current context but is associated with a different command. This is like creating a sub-folder that remembers its parent folder - it maintains the relationship between parent and child commands while keeping track of the command hierarchy. Used when one command needs to invoke another command while preserving the execution chain.",
        "technical": "Instantiates a new Context object of the same class type as the current instance using `type(self)`. Passes three arguments to the constructor: the new `command` object, `info_name` set to the command's name, and `parent` set to the current context (`self`). Returns the newly created child Context that maintains a reference to its parent, enabling context inheritance in the command execution chain."
      },
      "invoke": {
        "human": "This function executes commands in a command-line application that can have subcommands (like \"git commit\" where \"git\" is the main command and \"commit\" is a subcommand). It handles two modes: running a single subcommand at a time, or running multiple subcommands in sequence (chain mode). After executing the subcommands, it can optionally process the results through a callback function before returning them.",
        "technical": "Invokes a command group by resolving and executing subcommands from `ctx._protected_args` and `ctx.args`. In non-chain mode, resolves a single subcommand via `resolve_command()`, creates its context with `make_context()`, and invokes it. In chain mode, iterates through all subcommands, creates contexts with `allow_extra_args=True`, invokes each, and collects results in a list. Applies `_result_callback` via `ctx.invoke()` to transform final return value. Falls back to `invoke_without_command` behavior or fails if no subcommands provided."
      },
      "forward": {
        "human": "This function allows one command to call another command while automatically sharing any settings or parameters from the current command. It's like forwarding a phone call but also passing along all the context information. This is useful when you want to chain commands together without manually copying all the settings each time. It only works with commands, not with simple callback functions.",
        "technical": "Validates that `cmd` is a Command instance (raises TypeError otherwise), then merges the current context's parameters (`self.params`) into the provided `kwargs` dictionary, adding any missing parameters. Finally delegates to `self.invoke()` with the enriched arguments. Returns whatever the invoked command returns. The parameter merging ensures context propagation across multiple command invocation levels without explicit parameter passing."
      },
      "set_parameter_source": {
        "human": "Records where a parameter's value came from - whether it was provided by the user, came from a default setting, or was obtained from another source. This tracking helps the system understand how each parameter got its value, which is useful for debugging and understanding user input versus automatic settings.",
        "technical": "Stores a parameter name-to-source mapping in the instance's `_parameter_source` dictionary. Takes a parameter name string and a ParameterSource enum value, then performs a simple dictionary assignment. No validation or return value - pure side effect operation that updates internal state for parameter provenance tracking."
      },
      "get_parameter_source": {
        "human": "Tells you where a parameter's value came from - whether the user typed it on the command line, it came from an environment variable, or it's just using the default value. This helps distinguish between a user explicitly entering the default value versus the program just using it automatically because nothing else was provided.",
        "technical": "Retrieves the ParameterSource enum value for a given parameter name by performing a dictionary lookup on `self._parameter_source`. Returns the source type (e.g., COMMANDLINE, ENVIRONMENT, DEFAULT) or None if the parameter wasn't provided from any source. Simple getter method with no side effects - just a direct `.get()` call on an internal dictionary."
      },
      "get_params": {
        "human": "Retrieves all the parameters (options and arguments) that a command-line command accepts, including the help option if available. It also performs a safety check to warn developers if they accidentally defined the same option multiple times, which would cause confusion for users trying to use the command.",
        "technical": "Returns a list of Parameter objects by copying self.params and appending the help option from get_help_option(). In debug mode, flattens all parameter opts into a list, uses Counter to detect duplicates, and emits warnings via warnings.warn() for any option strings appearing multiple times. Returns the complete parameter list without modifying the original self.params."
      },
      "format_usage": {
        "human": "Generates and formats the usage instructions that show users how to run a command-line program. It collects all the necessary pieces of information about how to use the command (like required arguments and options), then writes them into a standardized help message format that users see when they ask for help.",
        "technical": "Calls `self.collect_usage_pieces(ctx)` to gather usage components from the command context, joins them with spaces using `\" \".join()`, then delegates to `formatter.write_usage()` passing the command path and joined usage string. Acts as a bridge between usage piece collection and formatter output, with no return value but side effect of writing to the HelpFormatter object."
      },
      "collect_usage_pieces": {
        "human": "This function builds a list of text pieces that show how to use a command in help messages. It takes the basic usage information from the parent class and adds information about subcommands (like \"add\", \"remove\", etc.) to give users a complete picture of how to run the command.",
        "technical": "Extends the parent class's `collect_usage_pieces()` method by calling `super().collect_usage_pieces(ctx)` to get the base usage components, then appends `self.subcommand_metavar` (a string placeholder for subcommands) to the result list. Returns the augmented list of strings that will be joined to form the complete usage line in CLI help output."
      },
      "get_help_option_names": {
        "human": "Finds which help option names (like \"--help\" or \"-h\") are still available to use for displaying help information. It starts with all the standard help option names and removes any that are already being used by other command-line parameters, ensuring there's no conflict. This prevents the help option from clashing with other options the command might have.",
        "technical": "Initializes a set with `ctx.help_option_names`, then iterates through `self.params` to remove any conflicting option names using `difference_update()` on both `param.opts` and `param.secondary_opts`. Returns the remaining non-conflicting help option names as a list. This filtering ensures help options don't collide with existing parameter definitions in the CLI command structure."
      },
      "get_help_option": {
        "human": "This function provides a help option (like \"--help\" or \"-h\") that users can use to get information about a command. It checks if help should be available, and if so, creates and returns the help option. To save resources, it remembers the help option after creating it once, so it doesn't have to recreate it every time it's needed.",
        "technical": "Retrieves help option names via `get_help_option_names()`, returns None if help is disabled or no names exist. Implements lazy initialization with caching in `self._help_option` to prevent multiple instantiations. On first call, imports and applies the `help_option` decorator with the option names, then extracts the resulting Option object from `self.params` via `pop()`. Returns the cached Option object or None."
      },
      "make_parser": {
        "human": "Sets up a command-line parser that knows how to handle all the options and arguments for a specific command. It creates an empty parser, then goes through each parameter the command accepts (like flags, options, or arguments) and teaches the parser how to recognize and process them. This prepares the system to understand what users type on the command line.",
        "technical": "Instantiates an _OptionParser object with the given Context, retrieves all parameters associated with the command via self.get_params(ctx), then iterates through each parameter calling param.add_to_parser(parser, ctx) to register it with the parser. Returns the fully configured _OptionParser instance ready to parse command-line input. No side effects beyond parser configuration."
      },
      "get_short_help_str": {
        "human": "Retrieves or creates a brief help message for a command that users see in command-line interfaces. If a short version exists, it uses that; otherwise, it automatically shortens the longer help text to fit within a character limit. If the command is marked as deprecated (outdated), it adds a warning label to alert users they shouldn't rely on this command anymore.",
        "technical": "Returns a formatted short help string by checking three sources in priority order: uses `self.short_help` with `inspect.cleandoc()` if available, generates from `self.help` via `make_default_short_help()` with the limit parameter (default 45 chars), or returns empty string. Appends deprecation notice using `_()` localization function if `self.deprecated` is set (either custom string or default message). Strips whitespace before returning final string."
      },
      "format_help": {
        "human": "This function assembles a complete help message for a command-line tool by gathering all the different pieces of help information. It collects the usage instructions, main help text, available options, and any closing remarks, then writes them into a formatter object in the proper order to create the final help display that users see when they ask for help.",
        "technical": "Orchestrates help text generation by sequentially calling four formatting methods: `format_usage()`, `format_help_text()`, `format_options()`, and `format_epilog()`. Each method receives the Context and HelpFormatter objects and writes its respective section directly into the formatter. Returns None as all operations mutate the formatter object via side effects. Acts as the main coordinator for help text assembly in what appears to be a Click-like CLI framework."
      },
      "format_help_text": {
        "human": "Formats and displays help documentation for a command or option in a command-line interface. It cleans up the help text, adds a deprecation warning if the feature is being phased out, and writes everything to the screen with proper spacing and indentation so users can understand how to use the command.",
        "technical": "Retrieves help text from self.help, cleans it with inspect.cleandoc() and truncates at form feed character (\\f). If self.deprecated is set, prepends a deprecation message using string formatting with internationalization support (_()). Writes formatted output to HelpFormatter via write_paragraph() and write_text() within an indentation context manager. Returns None; modifies formatter state as side effect."
      },
      "format_options": {
        "human": "This function generates help text for a command-line tool by first showing the standard options (like --help, --version) and then adding a list of available commands below them. It's used when someone types \"--help\" to see what the program can do, organizing the information in a clear, two-part format.",
        "technical": "Overrides the parent class's format_options method to extend help formatting behavior. Calls super().format_options() to render standard option flags to the HelpFormatter, then invokes self.format_commands() to append command listings. Takes Context and HelpFormatter objects as parameters; modifies formatter state as side effect rather than returning a value. Part of a Click-style CLI framework implementation."
      },
      "format_epilog": {
        "human": "Adds a closing message or footer text to help documentation if one has been defined. This is typically used to display additional information, notes, or instructions at the end of command-line help output. The text is cleaned up to remove extra spacing and properly indented to match the rest of the help display.",
        "technical": "Conditionally formats and writes epilog text to a HelpFormatter instance. Uses `inspect.cleandoc()` to normalize whitespace and indentation in the epilog string. Calls `formatter.write_paragraph()` to add vertical spacing, then writes the cleaned epilog text within an indentation context manager via `formatter.write_text()`. No return value; modifies formatter state as side effect."
      },
      "make_context": {
        "human": "Creates a new execution context for a command-line command without actually running it. This is like setting up all the necessary information and parsing the user's input arguments before the command executes. It merges default settings with any custom settings provided, then processes the command-line arguments to prepare everything the command will need when it eventually runs.",
        "technical": "Instantiates a Context object by first merging `self.context_settings` with provided `extra` kwargs (settings take precedence if key not in extra). Creates context via `self.context_class` constructor passing self, info_name, parent, and merged settings. Within a context scope (cleanup=False), invokes `self.parse_args(ctx, args)` to populate the context with parsed argument values. Returns the fully initialized but not-yet-invoked Context object."
      },
      "parse_args": {
        "human": "This function processes command-line arguments for a CLI application. It handles a special case where showing help text is needed when no arguments are provided. It also manages how remaining arguments are stored depending on whether commands can be \"chained\" together (run multiple commands in sequence) or run individually.",
        "technical": "Parses command-line arguments by first checking if `no_args_is_help` flag should trigger help display, then delegates to parent class `parse_args()`. Splits the returned `rest` list into `ctx._protected_args` and `ctx.args` based on `self.chain` flag: if chaining is enabled, all remaining args go to `_protected_args`; otherwise, first element goes to `_protected_args` and remainder to `ctx.args`. Returns `ctx.args` list."
      },
      "shell_complete": {
        "human": "Provides auto-completion suggestions when a user is typing a command-line parameter value. It helps users by showing possible options they can choose from as they type. The function checks if there's a custom completion function available; if not, it falls back to using the parameter's type-specific completion logic.",
        "technical": "Delegates shell completion to either a custom completion function (`_custom_shell_complete`) or the parameter type's built-in `shell_complete` method. If custom completion returns string results, wraps them in `CompletionItem` objects for standardization. Returns a list of `CompletionItem` objects containing completion suggestions. Uses type casting to ensure proper return type annotation compliance."
      },
      "main": {
        "human": "This is the main entry point for running a command-line application built with Click. It handles everything needed to execute a CLI command: processing the arguments you type, setting up the program environment, running the actual command, and gracefully handling errors or interruptions (like Ctrl+C). By default, it exits the program when done, but can optionally return control back to the caller instead.",
        "technical": "Processes command-line arguments (defaulting to sys.argv[1:], with Windows glob expansion), detects program name, handles shell completion, then creates a context via make_context() and invokes the command. In standalone mode, catches ClickException, EOFError, KeyboardInterrupt, OSError (EPIPE), Exit, and Abort exceptions, displaying appropriate error messages and calling sys.exit() with proper exit codes. In non-standalone mode, propagates exceptions and returns the invoke() result or exit code."
      },
      "_main_shell_completion": {
        "human": "Checks if the user's shell is requesting autocomplete suggestions (like when pressing Tab in a terminal). If autocomplete is requested, it processes the request to show available command options and then exits the program immediately. If no autocomplete is requested, the program continues normally. This enables the convenient Tab-completion feature in command-line tools.",
        "technical": "Constructs environment variable name from `prog_name` by replacing hyphens and dots with underscores and prepending underscore (e.g., `_MY_PROG_COMPLETE`). Checks `os.environ` for this variable containing completion instructions. If found, imports and calls `shell_complete()` with context args, program name, and instruction, then calls `sys.exit()` with the return value. Returns early (no-op) if environment variable not present, allowing normal program execution."
      },
      "__call__": {
        "human": "This function makes an object behave like a regular function that can be called directly. When you use parentheses on the object (like `object()`), it automatically runs the object's main method instead. This provides a convenient shortcut so users don't have to explicitly type `.main()` every time they want to execute the primary functionality.",
        "technical": "Implements the `__call__` magic method to make class instances callable. Forwards all positional (`*args`) and keyword (`**kwargs`) arguments directly to `self.main()` and returns its result unchanged. Acts as a transparent proxy/wrapper that delegates execution to the main method while preserving the complete argument signature and return value."
      },
      "add_command": {
        "human": "Adds a new command to a command group (like adding a new tool to a toolbox). If you don't specify what to call the command, it uses the command's own name. The function makes sure the command has a valid name and checks that it won't cause conflicts with other commands before adding it to the collection.",
        "technical": "Registers a Command object into the group's command dictionary using either the provided name parameter or the command's own name attribute. Validates that a name exists (raises TypeError if None), calls _check_nested_chain() to verify command compatibility and prevent nesting issues, then stores the command in self.commands dict with the name as key. Modifies instance state by adding to the commands collection."
      },
      "command": {
        "human": "This is a decorator that lets you easily add sub-commands to a command group. It works like a shortcut - instead of creating a command and then manually adding it to the group, this does both steps at once. You can use it with or without parentheses (like `@group.command` or `@group.command()`), making it flexible and convenient for building command-line interfaces.",
        "technical": "Decorator factory that wraps the `command()` function from `.decorators` and automatically calls `self.add_command()` to register the created command. Handles two invocation patterns: direct decoration (checks if first arg is callable) or parameterized decoration. Injects `self.command_class` into kwargs if set and no `cls` specified. Returns either a Command instance (direct) or decorator function (parameterized). Side effect: modifies parent group by adding command to its command collection."
      },
      "group": {
        "human": "This is a decorator that creates a subgroup within a command-line interface group and automatically registers it. It allows developers to organize commands hierarchically by nesting groups inside other groups. It can be used with or without parentheses for convenience, and respects custom group classes if specified.",
        "technical": "Decorator factory that handles both `@group` and `@group()` syntax by detecting callable first argument. Imports `group` from decorators module, injects `group_class` attribute into kwargs['cls'] if not already set (using `type(self)` if group_class is `type`). Returns decorator that wraps function with `group()` decorator, calls `self.add_command()` to register the created Group, and returns the Group instance. Supports immediate invocation when func is detected."
      },
      "result_callback": {
        "human": "This function allows you to attach a callback that processes the results after a command group's subcommands finish executing. It's like adding a final step that receives the output from your commands and can do additional processing on it. You can either replace an existing result processor or chain multiple processors together so they run in sequence.",
        "technical": "Returns a decorator that sets `self._result_callback` to the decorated function. If `replace=False` and a callback already exists, creates a wrapper function that chains callbacks by passing the old callback's return value as input to the new callback. Uses `update_wrapper` to preserve function metadata. The chained function receives the result value as first positional-only argument, followed by the original command parameters as `*args` and `**kwargs`."
      },
      "get_command": {
        "human": "Searches for a command by name, first checking the main location, then looking through additional backup locations if needed. If the command is found in a backup location and chaining is enabled, it verifies that the command is compatible with chaining. Returns the command if found, or nothing if it doesn't exist anywhere.",
        "technical": "Overrides parent's get_command() method to implement multi-source command resolution. First calls super().get_command() to check primary source, then iterates through self.sources list to find command in fallback sources. When command is found and self.chain is True, validates chain compatibility via _check_nested_chain(). Returns Command object on success or None if command not found in any source."
      },
      "list_commands": {
        "human": "This function collects all available commands from multiple sources and combines them into a single list. It gathers commands from a parent system and from additional command sources, removes any duplicates, and presents them in alphabetical order. This allows users to see all possible commands they can use in one organized list.",
        "technical": "Aggregates commands from a class hierarchy by calling `super().list_commands(ctx)` to get parent commands, then iterates through `self.sources` to collect commands from each source via `source.list_commands(ctx)`. Uses a set (`rv`) to automatically deduplicate command names across all sources, then returns a sorted list. The Context object is passed through to all command listing operations."
      },
      "format_commands": {
        "human": "Generates a formatted help section that displays all available subcommands with their descriptions. When a user requests help for a command-line tool with multiple subcommands, this function creates a neat list showing each subcommand name alongside a brief explanation of what it does. It filters out hidden commands and ensures the text fits nicely within the terminal width.",
        "technical": "Iterates through subcommands via `list_commands()` and `get_command()`, filtering out None and hidden commands. Calculates maximum column width based on formatter width minus spacing and longest command name. Retrieves short help text for each command using `get_short_help_str(limit)`, builds a list of (name, help) tuples, then renders them as a definition list using `formatter.write_dl(rows)` within a \"Commands\" section. Modifies formatter state as side effect."
      },
      "resolve_command": {
        "human": "Takes a command name typed by the user and finds the actual command to execute. If the exact command isn't found, it tries alternative spellings or normalizations. If the command still doesn't exist, it shows an error message to the user, unless what they typed looks like it might be a help flag (like --help), in which case it tries to handle that instead.",
        "technical": "Resolves command names from CLI arguments by: (1) extracting first arg via make_str(), (2) attempting lookup via self.get_command(), (3) retrying with ctx.token_normalize_func if available, (4) on failure, checking if arg is an option via _split_opt() and re-parsing with self.parse_args(), or calling ctx.fail() with error message. Returns tuple of (resolved_name|None, Command|None, remaining_args)."
      },
      "add_source": {
        "human": "Registers a group of commands to make them available for use. Think of it like adding a new toolbox to your workshop - the group contains a collection of related commands that can now be accessed. This allows the system to know about and use all the commands contained within that group.",
        "technical": "Appends a Group object to the instance's `self.sources` list attribute. The Group parameter contains a collection of commands that will be aggregated with other command sources. Simple list append operation with no return value; modifies internal state by extending the sources collection. No validation or transformation of the input group is performed."
      },
      "_parse_decls": {
        "human": "This function processes command-line argument declarations (like \"-v\" or \"--verbose\") to extract and standardize the argument name. It ensures that exactly one declaration is provided and converts it to a consistent format by replacing dashes with underscores and making it lowercase. If the argument is marked as \"exposed\" but has no name, it raises an error to prevent misconfiguration.",
        "technical": "Validates that `decls` sequence contains exactly one element, raising `TypeError` for empty sequences (when `expose_value=True`) or multiple elements. Extracts the single declaration string, normalizes it by calling `replace(\"-\", \"_\").lower()` to create a Python-compatible variable name. Returns a 3-tuple: the normalized name, a list containing the original argument string, and an empty list. The function enforces strict single-declaration constraint for argument parsing."
      },
      "human_readable_name": {
        "human": "Provides a display-friendly name for a command-line argument or option. If a custom display name (metavar) has been set, it uses that; otherwise, it converts the argument's internal name to uppercase letters. This helps show users what to type in help messages and error outputs.",
        "technical": "Property method that returns a string representation for display purposes. Checks if `self.metavar` attribute exists and is not None, returning it if present. Falls back to calling `self.name.upper()` to return the uppercased version of the name attribute. No side effects; pure getter that prioritizes explicit metavar over derived uppercase name."
      },
      "make_metavar": {
        "human": "Creates a display name for a command-line parameter that shows users how to use it. For example, it might show \"FILENAME\" for a required file parameter, or \"[OUTPUT]\" for an optional output parameter. It adds visual hints like brackets for optional parameters, exclamation marks for deprecated ones, and ellipses when multiple values are allowed.",
        "technical": "Generates metavar string for CLI parameter display by: 1) returning pre-set `self.metavar` if exists, 2) calling `self.type.get_metavar()` or falling back to `self.name.upper()`, 3) appending \"!\" suffix for deprecated parameters, 4) wrapping in brackets for optional parameters (`not self.required`), 5) appending \"...\" for parameters accepting multiple values (`self.nargs != 1`). Returns formatted string for help text display."
      },
      "get_default": {
        "human": "Retrieves the default value for a command-line parameter or option. First checks if the user has provided a custom default value in the context settings, and if not, uses the parameter's built-in default value. If the default is a function that generates a value, it can optionally execute that function to get the actual value instead of returning the function itself.",
        "technical": "Implements two-tier default value resolution: calls `ctx.lookup_default(self.name)` to check context's default_map first, falls back to `self.default` if result is UNSET. When `call=True` and value is callable, invokes it to resolve dynamic defaults. Returns the resolved value (or callable if `call=False`). No type casting performed. Returns `Any | Callable[[], Any] | None`."
      },
      "consume_value": {
        "human": "This function retrieves the value for a command-line option, handling special cases where the user needs to be prompted for input. It deals with flags that can work with or without values, and asks the user to provide a value interactively when the option requires one but wasn't given on the command line. It ensures options get their proper values whether from the command line, user prompts, or default flag values.",
        "technical": "Calls parent's consume_value() then processes the result through four conditional branches: (1) handles FLAG_NEEDS_VALUE sentinel by prompting or using flag_value, (2) replaces True with flag_value for non-bool flags, (3) processes multiple options by replacing FLAG_NEEDS_VALUE sentinels in lists, (4) prompts for UNSET/default values when prompt is enabled and required. Returns tuple of processed value and ParameterSource enum indicating value origin (COMMANDLINE, PROMPT, etc.)."
      },
      "type_cast_value": {
        "human": "Takes a user-provided value for a command-line parameter and transforms it into the correct format based on the parameter's configuration. Handles different scenarios like single values, multiple values, or a specific number of expected values. Validates that the right amount of values were provided and converts each one to the expected data type (like converting \"5\" to the number 5).",
        "technical": "Conditionally defines a `convert()` function based on `self.nargs` (expected argument count) and `self.type.is_composite` flag. For `nargs=1` or composite types, converts single values directly. For `nargs=-1`, converts all items in an iterable to a tuple. For `nargs>1`, validates exact count match and converts to tuple. If `self.multiple=True`, wraps conversion in another tuple comprehension. Returns `None` as-is or empty tuple for null values. Raises `BadParameter` for validation failures."
      },
      "value_is_missing": {
        "human": "Checks whether a command-line parameter value should be treated as \"missing\" or not provided. This helps distinguish between a user intentionally not providing a value versus providing an empty value. It's particularly important for parameters that can accept multiple values, where an empty list means nothing was provided at all.",
        "technical": "Returns `True` if the value is the sentinel `UNSET` constant, or if the value is an empty tuple `()` when the parameter expects multiple values (determined by checking `self.nargs != 1` or `self.multiple` flag). Uses identity check (`is`) for UNSET and equality check for empty tuple. Returns `False` for all other cases, indicating the value is present."
      },
      "process_value": {
        "human": "Handles special processing for command-line flag options that haven't been set by the user. When a boolean flag is optional and the user didn't provide it, the function automatically sets it to False instead of leaving it undefined. This ensures flags have a predictable default value. For all other cases, it uses the standard processing behavior.",
        "technical": "Overrides parent class's process_value() to intercept UNSET values for boolean flags before type casting occurs. Checks if option is_flag, not required, is_bool_flag, and value equals UNSET sentinel, then sets value to False and invokes callback if present. Otherwise delegates to super().process_value(ctx, value) for standard Parameter processing. Returns processed value in both code paths."
      },
      "resolve_envvar_value": {
        "human": "Looks up configuration values from environment variables for command-line options. First checks if a specific environment variable was manually set for this option. If not found, it automatically tries to build an environment variable name by combining a prefix with the option's name (like \"MYAPP_DEBUG\" for a \"debug\" option). Returns the value if found, otherwise returns nothing.",
        "technical": "Calls parent class's `resolve_envvar_value()` first to check explicitly configured envvars. If that returns None, conditionally constructs an auto-generated envvar name using `f\"{ctx.auto_envvar_prefix}_{self.name.upper()}\"` (requires `allow_from_autoenv`, non-null prefix, and option name). Retrieves value via `os.environ.get()`. Returns the resolved string value or None if no environment variable is found through either method."
      },
      "value_from_envvar": {
        "human": "Reads a configuration value from an environment variable and converts it into the appropriate format for a command-line option. Handles special cases like on/off flags (which need to interpret \"true\"/\"false\" text), and options that can be specified multiple times. Returns None if the environment variable isn't set, otherwise returns the properly formatted value.",
        "technical": "Retrieves raw environment variable value via `resolve_envvar_value()`, then applies type-specific processing. For non-boolean flags, uses `BoolParamType.str_to_bool()` to determine activation state or matches against `flag_value`. For multiple/nargs options, splits the value using `type.split_envvar_value()` and batches results with `batch()` when both multiple and nargs>1. Returns None for absent variables, otherwise returns processed value (bool, single value, or list)."
      },
      "handle_parse_result": {
        "human": "This function processes a command-line parameter value that a user has provided (or uses a default if they didn't). It checks if the parameter is marked as deprecated and warns the user with a red message if they're using an outdated option. It then validates the value to make sure it's the correct type, and finally stores it in the context so the rest of the program can use it.",
        "technical": "Consumes parameter value via `consume_value()`, records its source in context, and displays deprecation warning if parameter is deprecated and value is user-provided (not default). Processes value through `process_value()` for type conversion/validation, catching exceptions in resilient parsing mode by resetting to UNSET. If `expose_value` is True and name not already in `ctx.params`, stores the processed value in context params dict. Returns tuple of processed value and remaining args list."
      },
      "get_error_hint": {
        "human": "This function generates an error message hint to help users understand what went wrong. When an error occurs, it provides the basic error information and additionally tells the user which environment variable is related to the problem (if one exists). This makes it easier for users to troubleshoot issues by knowing they can check or set a specific environment variable.",
        "technical": "Overrides parent class's `get_error_hint()` method to augment error hints with environment variable information. Calls `super().get_error_hint(ctx)` to get base error message, then conditionally appends formatted environment variable name (from `self.envvar`) if `self.show_envvar` flag is True and `envvar` is not None. Returns the concatenated string result. No side effects, pure string manipulation."
      },
      "add_to_parser": {
        "human": "Configures how a command-line option should behave when added to a command parser. It determines whether the option should collect multiple values, count occurrences, act as a simple flag, or store a single value. For boolean flags, it can set up both positive and negative versions (like --verbose and --no-verbose) so users can explicitly enable or disable a feature.",
        "technical": "Determines the appropriate action type (append/count/store/store_const) based on self.multiple, self.count, and self.is_flag attributes. Calls parser.add_option() with configured parameters including opts, dest (self.name), action, and either const (for flags) or nargs (for value options). For boolean flags with secondary_opts, registers two options with opposing const values (True/False). No return value; modifies parser state as side effect."
      },
      "get_help_record": {
        "human": "Generates a formatted help text entry for a command-line option that users see when they request help. It shows the option names (like `-v` or `--verbose`), adds any required values, and includes helpful details like default values, environment variables, valid ranges, and whether the option is required. Returns None if the option should be hidden from help text.",
        "technical": "Constructs a tuple of (option_string, help_text) for CLI help display. Calls `join_options()` to format primary and secondary option names, appending metavar for non-flag options. Retrieves extra metadata via `get_help_extra()` and formats envvars, defaults, ranges, and required status into bracketed annotations. Uses slash separator for slash-prefixed options, otherwise space-slash-space. Returns None for hidden options, otherwise returns formatted tuple."
      },
      "get_help_extra": {
        "human": "Generates supplementary help text information for command-line options that appears when users run `--help`. It collects details like environment variable names that can override the option, default values (formatted appropriately), valid value ranges for numeric options, and whether the option is required. This extra information helps users understand how to properly use each command-line option.",
        "technical": "Builds a dictionary of help metadata by: (1) resolving environment variable names from `self.envvar` or auto-generating from `ctx.auto_envvar_prefix`, (2) retrieving default values via `self.get_default()` with resilient parsing enabled to prevent type casting errors, (3) formatting defaults based on type (enum, list, bool flag, function, etc.), (4) extracting range descriptions from `_NumberRangeBase` types via `_describe_range()`, and (5) marking required fields. Returns `types.OptionHelpExtra` dict with keys: envvars, default, range, required."
      },
      "prompt_for_value": {
        "human": "Interactively asks the user to provide a value when one isn't already available. For yes/no questions, it shows a simple confirmation prompt. For other types of input, it keeps asking until the user enters something valid. It handles showing default values and can hide sensitive input like passwords.",
        "technical": "Retrieves default value via `get_default()`, then branches on `is_bool_flag`: if true, calls `confirm()` with boolean default; otherwise calls `prompt()` with type conversion, input hiding, and validation through `process_value()` callback. Converts UNSET sentinel to None for prompt reiteration. Conditionally passes `show_default` to prompt_kwargs only if boolean type. Returns processed, validated user input."
      },
      "decorator": {
        "human": "This function allows you to chain together multiple callback functions that process results in sequence. When you add a new callback, it can either replace the existing one or wrap around it, so the result flows through the old callback first, then through the new one. It's like setting up a pipeline where data passes through multiple processing steps in order.",
        "technical": "Decorator factory that manages `_result_callback` chaining. If no existing callback or `replace=True`, directly assigns `f` as the callback. Otherwise, creates a wrapper function that pipes `value` through `old_callback` first, then passes that result to `f`. Uses `update_wrapper` to preserve function metadata and `t.cast` for type preservation. Returns the decorated function while mutating `self._result_callback` as a side effect."
      },
      "_process_result": {
        "human": "Takes a result value and optionally passes it through a callback function for additional processing before returning it. This allows the system to transform or validate results in a customizable way - if a callback is registered, the result goes through that extra step; otherwise, it's returned as-is.",
        "technical": "Conditionally invokes a result callback function if `self._result_callback` is not None. Uses `ctx.invoke()` to call the callback with the input `value` and unpacked context parameters (`**ctx.params`). Returns either the transformed value from the callback or the original value unchanged. Acts as a post-processing hook in a command/context execution pipeline."
      },
      "check_iter": {
        "human": "Validates that a given value can be used as an iterable (something you can loop through, like a list). If the value cannot be iterated over, it stops the program and shows a clear error message telling the user that an iterable value is required. This prevents the program from crashing later when it tries to loop through the value.",
        "technical": "Wraps a call to `_check_iter(value)` with exception handling. On success, returns the iterator from `_check_iter()`. Catches `TypeError` exceptions (indicating non-iterable input) and raises a `BadParameter` exception with localized error message, passing context (`ctx`) and parameter reference (`self`) for error reporting. Suppresses the original exception chain with `from None`."
      },
      "_write_opts": {
        "human": "Formats command-line options (like `-h` or `--help`) into a readable string for display in help text. If the option accepts a value (not just a flag), it adds a placeholder showing what type of value is expected. Also keeps track of whether any options use slash notation (like `/h` on Windows).",
        "technical": "Joins a sequence of option strings using `join_options()`, which returns formatted options and a boolean indicating slash usage. Updates the nonlocal `any_prefix_is_slash` flag if slashes are detected. For non-flag and non-count options, appends a metavar placeholder (e.g., \"TEXT\" or \"INTEGER\") generated by `self.make_metavar()`. Returns the formatted option string with optional metavar suffix."
      },
      "function": {
        "human": "This function acts as a wrapper that chains two operations together. It first processes an input value through an existing callback function, then takes that result and processes it through a second function. This creates a pipeline where the output of one step becomes the input for the next step, allowing for layered processing of data.",
        "technical": "Implements function composition by chaining two callbacks. Takes a value and variable arguments, passes them to `old_callback()` to get an intermediate result stored in `inner`, then passes that result along with the original arguments to function `f()`. Returns the final output from `f()`. Uses positional-only parameter syntax (`/`) for the value parameter and forwards all `*args` and `**kwargs` to both function calls."
      },
      "convert": {
        "human": "This function validates that the user has provided the correct number of input values and converts each value to the expected type. If the wrong number of values is given (for example, expecting 3 values but receiving 2), it raises an error with a helpful message that uses proper grammar for singular or plural cases. Once validated, it transforms all the values to their proper types.",
        "technical": "Converts input value to tuple via `check_iter()`, validates tuple length matches `self.nargs` requirement, raising `BadParameter` with localized singular/plural error message via `ngettext()` if mismatch occurs. On success, applies `self.type()` converter to each element, passing context and self reference, returning tuple of converted values. Part of a parameter/argument validation system with type coercion."
      }
    },
    "src/click/decorators.py": {
      "pass_context": {
        "human": "This is a decorator that automatically provides context information to functions that need it. Instead of manually passing context data every time you call a function, this decorator fetches and injects it automatically. It's like having an assistant that always hands you the current situation report before you start working, so you don't have to ask for it each time.",
        "technical": "A decorator function that wraps a callback to automatically inject the current Context object as the first argument. Creates a wrapper function `new_func` that calls `get_current_context()` to retrieve the active context, prepends it to the original arguments, and forwards the call to the decorated function `f`. Uses `update_wrapper` to preserve the original function's metadata (name, docstring, etc.). Returns the wrapped function with modified signature that no longer requires explicit Context parameter."
      },
      "pass_obj": {
        "human": "This is a decorator that automatically injects a specific piece of data (stored in a context object) into a function when it's called. Instead of manually retrieving the data each time, the decorator handles it for you. It's useful when you have nested commands or operations that need to share state, making the code cleaner by removing repetitive data-passing code.",
        "technical": "A decorator factory that wraps a function to automatically inject `Context.obj` as the first argument. Creates a wrapper function `new_func` that calls `get_current_context().obj` to retrieve the context object, then invokes the original function `f` with this object prepended to the arguments. Uses `update_wrapper` to preserve the original function's metadata. Returns the wrapped function with modified signature (removes first parameter from type signature via `Concatenate[T, P]` to `P`)."
      },
      "make_pass_decorator": {
        "human": "Creates a custom decorator factory that automatically finds and passes a specific type of object to a function. This is useful in command-line applications where you want functions to automatically receive configuration or state objects without manually passing them each time. If the object doesn't exist, it can either create one automatically or raise an error, depending on settings.",
        "technical": "Returns a decorator factory that wraps functions to inject context objects of a specified type. Uses `get_current_context()` to retrieve the current context, then calls either `ctx.ensure_object()` (creates if missing) or `ctx.find_object()` (returns None if missing) based on the `ensure` parameter. Raises `RuntimeError` if object not found when `ensure=False`. Invokes the wrapped function via `ctx.invoke()` with the found object as first argument, preserving function metadata with `update_wrapper()`."
      },
      "pass_meta_key": {
        "human": "Creates a decorator factory that automatically injects stored data from Click's context into command functions. Instead of manually retrieving data from the context storage area, this lets you automatically pass that data as the first parameter to your function. It's a convenience tool that reduces boilerplate code when working with Click command-line applications.",
        "technical": "Returns a decorator factory that wraps functions to inject `ctx.meta[key]` as the first argument. The inner `new_func` calls `get_current_context()` to retrieve the Click context, extracts the value from `ctx.meta[key]`, then uses `ctx.invoke()` to call the original function with the extracted object prepended to arguments. Uses `update_wrapper` to preserve function metadata and dynamically generates decorator docstring from `doc_description` parameter."
      },
      "command": {
        "human": "This decorator transforms a regular Python function into a command-line command that can be executed from the terminal. It automatically converts the function name into a CLI-friendly format (lowercase, dashes instead of underscores, removes suffixes like \"_command\"), collects any options or arguments that were added to the function, and packages everything into a command object that can be run or added to a command group.",
        "technical": "Implements a flexible decorator that handles both `@command` and `@command()` syntax by detecting if the first argument is callable. Extracts decorated parameters from `f.__click_params__` attribute (added by @option/@argument decorators), reverses and extends them to a params list, generates command name via string manipulation (lowercase, underscore-to-dash conversion, suffix stripping), then instantiates the specified `cls` (defaults to `Command`) with the callback function, processed params, and forwarded kwargs. Returns either the decorated Command instance or the decorator function itself."
      },
      "group": {
        "human": "This function creates a command group, which is a way to organize multiple related commands under a single parent command. It's a decorator that can be applied to a function to turn it into a group that can contain subcommands. You can use it with or without parentheses, making it flexible for different coding styles.",
        "technical": "Decorator factory that wraps the `command()` function with `cls` defaulting to `Group` class. Handles two invocation patterns: direct decoration (when `name` is callable) or parameterized decoration (when `name` is string/None). Uses `t.cast()` to type-hint the Group class, then delegates to `command()` with the appropriate cls parameter and any additional attributes passed through `**attrs`."
      },
      "_param_memo": {
        "human": "This function attaches a parameter (like a command-line option or argument) to a function so it can be used later. It's like adding a label or tag to a function that describes what inputs it needs. If the function is already a full command, it adds the parameter directly; otherwise, it creates a temporary storage list on the function to hold parameters until the command is fully built.",
        "technical": "Stores a Parameter object on a callable by appending it to either `f.params` (if f is a Command instance) or `f.__click_params__` (for regular functions). For non-Command callables, lazily initializes the `__click_params__` attribute as an empty list if it doesn't exist. This function mutates the input callable as a side effect and returns None. Used in Click's decorator pattern to accumulate parameter definitions before command instantiation."
      },
      "argument": {
        "human": "This function creates a decorator that adds command-line arguments to a Click command. It's like attaching labels to a function that tell the program what inputs it should expect from users when they run the command. For example, it could specify that a command needs a filename or a username as input.",
        "technical": "Returns a decorator factory that instantiates an `Argument` object (or custom `cls`) with provided `param_decls` and `attrs`, then attaches it to the decorated function via `_param_memo()`. The decorator pattern allows stacking multiple `@argument()` calls on a single function. Uses closure to capture argument configuration, defaults `cls` to `Argument` class, and returns the original function unmodified after registering the parameter."
      },
      "option": {
        "human": "This function creates a decorator that adds command-line options (like `--verbose` or `--output-file`) to a command. It's a helper that makes it easy to define what options your command accepts when building command-line tools. Instead of manually configuring options, you just use this decorator above your command function.",
        "technical": "Returns a decorator function that instantiates an Option class (or custom cls if provided) with param_decls and attrs, then attaches it to the decorated function via _param_memo(). The decorator pattern allows stacking multiple options on a single command function. Uses closure to capture param_decls, cls (defaulting to Option), and attrs, then passes them to the Option constructor when the decorator is applied."
      },
      "confirmation_option": {
        "human": "Creates a command-line confirmation prompt that asks users \"Do you want to continue?\" before proceeding with an action. If the user doesn't pass a `--yes` flag when running the command, they'll be prompted to confirm. If they decline the prompt, the program stops immediately. This is commonly used for dangerous operations like deleting files to prevent accidental actions.",
        "technical": "Returns a decorator factory that wraps the `option()` function with pre-configured defaults for a confirmation flag. Sets up a callback that calls `ctx.abort()` when the flag value is False. Configures kwargs with defaults: `is_flag=True`, `expose_value=False`, prompt text, and help text. Uses `--yes` as the default parameter name if none provided. The callback intercepts the option value and terminates execution via Context.abort() when confirmation is not given."
      },
      "password_option": {
        "human": "Creates a command-line password input field that hides what you type (showing dots or asterisks instead of characters) and asks you to type the password twice to make sure you didn't make a typo. This is the standard secure way programs ask for passwords - you can't see what you're typing, and you have to confirm it matches.",
        "technical": "Factory function that returns a decorator for adding a password option to Click CLI commands. Sets default param_decls to `(\"--password\",)` if none provided, then configures kwargs with three defaults: `prompt=True` (interactive input), `confirmation_prompt=True` (ask twice), and `hide_input=True` (mask characters). Delegates to Click's `option()` function with these parameters to create the actual decorator."
      },
      "version_option": {
        "human": "Creates a `--version` command-line option that displays the program's version number and immediately exits. When users run the program with `--version`, it automatically figures out what version to show by either using a provided version string or detecting it from the installed package. If it can't determine the version automatically, it raises an error to let developers know something needs to be configured.",
        "technical": "Returns a decorator that adds a version option to Click commands. Uses stack frame inspection (`inspect.currentframe()`) to auto-detect package name from caller's `__name__` and `__package__` globals. The callback function retrieves version via `importlib.metadata.version()` if not provided, formats the message with prog/package/version interpolation, calls `echo()` to print, and invokes `ctx.exit()`. Sets option defaults (is_flag=True, is_eager=True, expose_value=False) and delegates to `option()` decorator with the callback attached."
      },
      "help_option": {
        "human": "Creates a standardized \"--help\" option that can be added to command-line programs. When users type \"--help\", it displays instructions about how to use the program and then closes it. This is the familiar help feature you see in most command-line tools that explains what commands and options are available.",
        "technical": "Returns a decorator that wraps the `option()` function with pre-configured help behavior. Defines a `show_help` callback that invokes `ctx.get_help()` to retrieve help text, outputs it via `echo()` with color support, and calls `ctx.exit()`. Sets default kwargs: `is_flag=True`, `expose_value=False`, `is_eager=True` (processes before other options), and defaults `param_decls` to `(\"--help\",)` if not provided. The callback only executes when value is truthy and not in resilient parsing mode."
      },
      "decorator": {
        "human": "This is a decorator factory that attaches configuration information to a function. It's used to mark functions with special parameters and settings (like command-line options or arguments) so they can be processed later. The function itself remains unchanged but gets \"tagged\" with metadata that other parts of the system can read.",
        "technical": "Returns a decorator function that stores parameter metadata on the decorated function `f`. Calls `_param_memo(f, cls(param_decls, **attrs))` to instantiate a class (likely a parameter/option descriptor) with `param_decls` and `**attrs`, then memoizes this instance on function `f`. Returns the original function unmodified, creating a transparent decorator that only adds side-effect metadata storage."
      },
      "callback": {
        "human": "This function displays version information for a command-line application when requested by the user (like when typing `--version`). It automatically figures out the program's name and version number by looking them up from the installed package information, then shows a formatted message with these details before exiting the program.",
        "technical": "Click callback handler that retrieves and displays version information. Uses `ctx.find_root().info_name` to get program name and `importlib.metadata.version()` to fetch package version from installed metadata. Modifies nonlocal variables `prog_name` and `version`, formats output message with these values, calls `echo()` to display, and terminates execution via `ctx.exit()`. Raises RuntimeError if package not found or version cannot be determined."
      },
      "show_help": {
        "human": "This function displays a help page to the user when they request it (like typing `--help` in a command-line program). It checks if help was actually requested and if the program is ready to show it, then prints the help information to the screen and closes the program. It's a callback function that responds to user requests for assistance.",
        "technical": "Callback function that conditionally displays help text and terminates execution. Checks two conditions: `value` (help flag is True) and `not ctx.resilient_parsing` (not in parsing validation mode). If both pass, calls `echo()` to output the help text retrieved from `ctx.get_help()` with color formatting from `ctx.color`, then calls `ctx.exit()` to terminate the program with exit code 0. Returns None but has side effect of program termination."
      },
      "new_func": {
        "human": "This function acts as a wrapper that retrieves a stored object from the current execution context and passes it to another function. It's designed to automatically inject a specific object (identified by a key) into function calls, so the caller doesn't need to manually provide it each time. This is commonly used in frameworks where certain data needs to be available throughout a request or operation.",
        "technical": "Retrieves the current Click context via `get_current_context()`, extracts a stored object from `ctx.meta[key]`, then invokes the wrapped function `f` using `ctx.invoke()` with the extracted object as the first argument followed by all passed `*args` and `**kwargs`. Returns type `R` as specified by the wrapped function's signature. Uses generic types `P` (ParamSpec) and `R` for type-safe parameter forwarding."
      }
    },
    "src/click/exceptions.py": {
      "_join_param_hints": {
        "human": "Converts parameter hints into a readable text format. When given multiple hint options (like a list of acceptable values), it combines them into a single string separated by slashes. If given a single hint or nothing, it just passes that through unchanged. This helps display multiple parameter options in a user-friendly way.",
        "technical": "Takes a parameter hint that can be a sequence of strings, a single string, or None. If the input is a sequence (not a string), iterates through elements, applies `repr()` to each, and joins them with \" / \" separator. Returns the joined string for sequences, or returns the original value unchanged for string/None inputs. Type checks using `isinstance()` to distinguish between string and sequence types."
      },
      "__init__": {
        "human": "This function sets up an error object that tracks information about a file-related problem. It stores both the original filename and a user-friendly version of it, along with an error message describing what went wrong. If no specific error message is provided, it defaults to saying \"unknown error\" so users always get some feedback about the issue.",
        "technical": "Constructor that initializes an exception class with filename tracking. Takes `filename` (str) and optional `hint` (str|None) parameters. Sets default hint to localized \"unknown error\" string via `_()` if None. Calls parent class constructor with hint message. Stores two filename attributes: `filename` (original) and `ui_filename` (formatted via `format_filename()` for display purposes). No return value."
      },
      "show": {
        "human": "Displays an error message to the user in a helpful way. When something goes wrong, it shows what the error was and suggests how to get help by running the command with a help option (like `--help`). The message is printed to the error output stream so it doesn't mix with normal program output.",
        "technical": "Outputs formatted error messages to stderr (via `get_text_stderr()` if no file specified). Constructs a help hint using the command path and help option names from the context object. Calls `echo()` twice: first to display usage information and help hint, then to display the formatted error message with internationalization support via `_()`. Respects color settings from the context for terminal output formatting."
      },
      "format_message": {
        "human": "Creates an error message that tells the user when a file couldn't be opened. It takes the filename that failed and the reason why it failed, then combines them into a friendly, readable error message that can be displayed to the user. The message is also prepared for translation into different languages.",
        "technical": "Returns a localized error string by calling the `_()` translation function with a template message containing two placeholders. Uses `.format()` to inject `self.ui_filename` (the file path) and `self.message` (the error details) into the template. The `_()` function indicates this is part of an internationalization (i18n) system, likely gettext, enabling the error message to be translated based on user locale."
      },
      "__str__": {
        "human": "This function creates a readable error message when a required parameter is missing from a request or command. If no custom error message was provided, it automatically generates one that includes the name of the missing parameter. If a custom message already exists, it simply uses that instead.",
        "technical": "String representation method that returns either a pre-set `self.message` or constructs a localized error message using the `_()` translation function. Extracts parameter name from `self.param.name` if available, formats it into the template \"Missing parameter: {param_name}\" using `.format()`, and returns the resulting string. Implements conditional logic to prioritize existing messages over generated ones."
      }
    },
    "src/click/formatting.py": {
      "measure_table": {
        "human": "Calculates how wide each column needs to be in a table to fit all the content. It looks at every cell in every row, measures how much space each piece of text needs (accounting for terminal display width), and remembers the widest content in each column position. Returns these maximum widths so the table can be formatted properly without cutting off any text.",
        "technical": "Iterates through rows of string tuples, tracking maximum display width per column index in a dictionary. Uses `term_len()` to measure terminal display width of each cell (handling special characters/unicode). Employs `enumerate()` to map column positions, `max()` with `dict.get()` to update widths. Returns sorted tuple of column widths ordered by column index via `sorted(widths.items())` and tuple comprehension."
      },
      "iter_rows": {
        "human": "Takes rows of data that might have different numbers of columns and makes them all the same length by adding empty spaces to shorter rows. This ensures every row has exactly the number of columns you specify, filling in blanks where needed so the data forms a neat, rectangular table.",
        "technical": "Generator function that iterates over tuples of strings and pads each row to match `col_count` by appending empty string tuples. Calculates padding needed using `col_count - len(row)`, then concatenates `(\"\",) * padding_count` to the original row tuple. Yields normalized rows one at a time, transforming ragged input into uniform-width output without materializing full result set in memory."
      },
      "wrap_text": {
        "human": "This function wraps long text to fit within a specified width, like how a word processor breaks lines. It can handle simple text or preserve paragraph structure (separated by blank lines). Special paragraphs marked with `\\b` are kept as-is without rewrapping. It also respects the original indentation of paragraphs, making it useful for formatting command-line help text or documentation.",
        "technical": "Expands tabs and uses TextWrapper to wrap text to specified width with configurable indents. When `preserve_paragraphs=True`, splits input by `splitlines()`, detects paragraph boundaries (empty lines), calculates original indentation via `term_len()`, and stores paragraphs as tuples of (indent, raw_flag, text). Processes each paragraph through `wrapper.fill()` or `wrapper.indent_only()` (for `\\b`-prefixed blocks), then joins with double newlines. Returns single wrapped string."
      },
      "join_options": {
        "human": "Takes a list of command-line option strings (like \"-v\", \"--help\", or \"/debug\") and formats them into a nice, readable display. It sorts the options by their prefix length (shorter prefixes like \"-\" come before longer ones like \"--\") and joins them with commas. It also checks if any option uses a slash \"/\" as its prefix, which is common in Windows-style commands.",
        "technical": "Iterates through option strings, extracts each prefix using `_split_opt()`, and builds a list of tuples containing (prefix_length, option_string). Sets `any_prefix_is_slash` flag to True if any option has \"/\" prefix. Sorts the list by prefix length in ascending order, then joins the sorted options with \", \" separator. Returns a tuple of the formatted string and the slash flag. No side effects or external dependencies beyond the helper function `_split_opt()`."
      },
      "_flush_par": {
        "human": "Processes and saves accumulated text content from a temporary buffer. It checks if the content should be treated as a special block (marked with a backspace character) or regular text, then formats it appropriately - either joining lines with newlines for blocks or joining words with spaces for regular paragraphs. After saving, it clears the buffer for the next batch of content.",
        "technical": "Flushes a buffer (`buf`) by appending its contents to a list `p` as a tuple containing indentation level, block flag, and formatted text. If first element is \"\\b\" after stripping, creates a block entry with newline-joined content (excluding first element); otherwise creates a paragraph entry with space-joined content. Uses `del buf[:]` to clear the buffer in-place. Returns None but modifies closure variables `buf` and `p` as side effects."
      },
      "__init__": {
        "human": "Sets up a text formatter that controls how content is displayed on screen. It determines how wide the text should be (defaulting to terminal width but capped at 80 characters), how much to indent nested content (default 2 spaces), and prepares empty storage for text that will be formatted. This ensures text fits nicely within the available screen space.",
        "technical": "Initializes a formatter object with three parameters: indent_increment (default 2), width, and max_width (default 80). Retrieves terminal width via shutil.get_terminal_size().columns, constrains it between 50 and max_width-2. Checks FORCED_WIDTH override before auto-detection. Initializes instance attributes: indent_increment, width, current_indent (0), and buffer (empty list). No return value."
      },
      "write": {
        "human": "This function saves text to a temporary storage area (buffer) for later use. Think of it like writing notes on a scratch pad - the text isn't sent or processed yet, just stored. This is useful when you need to collect multiple pieces of text before doing something with all of it at once, like building up a complete message or document.",
        "technical": "Appends a string parameter to an internal list-based buffer (self.buffer) using the append() method. No validation, transformation, or processing of the input string occurs. Returns None and has the side effect of modifying the instance's buffer state. This is a simple accumulator pattern commonly used in stream/writer implementations for batching output before flushing."
      },
      "indent": {
        "human": "This function increases the level of indentation used when formatting or writing text. It's like pressing the Tab key to move text further to the right. Each time it's called, it adds one more level of indentation, making the text appear more nested or hierarchical.",
        "technical": "Mutates the instance's `current_indent` attribute by adding `indent_increment` to it. This is a simple state modification method with no parameters, return value, or external dependencies. Side effect: permanently increases the indentation level stored in the object until decreased by a corresponding method."
      },
      "dedent": {
        "human": "Moves the text or code formatting one level to the left by reducing the amount of spacing at the beginning of lines. This is used when you're done writing a nested section (like inside a loop or function) and want to return to the previous indentation level. Think of it like pressing the \"outdent\" button in a word processor.",
        "technical": "Decrements the `self.current_indent` instance variable by subtracting `self.indent_increment` from it. This mutates the object's state to reduce the current indentation level. No return value (returns None). Side effect: modifies the indentation tracking state of the object, affecting subsequent operations that depend on `current_indent`."
      },
      "write_usage": {
        "human": "Formats and writes a command-line usage message (like \"Usage: myprogram [options]\") to a text buffer. It intelligently decides whether to display the program name and its arguments on one line or split them across two lines, depending on how much horizontal space is available. This ensures the usage message looks clean and readable regardless of terminal width or how long the program name is.",
        "technical": "Constructs a usage string with optional localized prefix (defaults to \"Usage: \"), then conditionally formats based on available text_width. If prefix + program name + 20 chars fit within width, uses wrap_text() with hanging indent to keep arguments on same line. Otherwise, writes prefix/program on first line and wraps arguments on subsequent lines with increased indentation (current_indent or prefix length + 4 spaces). Uses term_len() for accurate character width calculation and writes formatted output via self.write()."
      },
      "write_heading": {
        "human": "Writes a formatted heading text to an output buffer with proper indentation. This is used when generating structured text output (like reports or logs) where section headings need to stand out and align with the current indentation level. The heading automatically gets a colon and newline added to it.",
        "technical": "Formats and writes a heading string by: (1) right-aligning empty string to `self.current_indent` width for indentation padding, (2) appending the heading text with a colon suffix and newline character, (3) delegating actual write operation to `self.write()` method. Uses f-string formatting with `>` alignment operator. No return value; modifies buffer state as side effect."
      },
      "write_paragraph": {
        "human": "Adds spacing between paragraphs in text output. When there's already content written to the buffer, it inserts a blank line before the next paragraph starts. This creates visual separation that makes text easier to read, similar to how paragraphs are separated in documents or books.",
        "technical": "Conditionally writes a newline character to the output buffer by calling `self.write(\"\\n\")`. Only executes if `self.buffer` is truthy (non-empty), preventing unnecessary leading newlines. Acts as a paragraph separator in a buffered writing system. Returns None and modifies internal state through the `write` method call."
      },
      "write_text": {
        "human": "Takes a block of text and writes it to an output buffer with proper formatting. The text is automatically wrapped to fit within a specified width, indented according to the current indentation level, and formatted to keep paragraphs separate. This ensures text output looks clean and readable regardless of the original formatting.",
        "technical": "Calculates indentation string from `self.current_indent`, calls `wrap_text()` with width constraints and paragraph preservation enabled, applies indent to both first and subsequent lines, writes the wrapped result to buffer via `self.write()`, then appends a newline. Side effect: modifies internal buffer state. Returns None. Delegates text wrapping logic to `wrap_text()` utility function."
      },
      "write_dl": {
        "human": "Formats and displays a two-column definition list (like a glossary or command help) where terms appear on the left and their descriptions on the right. If a term is short enough, its description starts on the same line; if too long, the description wraps to the next line. Long descriptions are automatically wrapped across multiple lines while maintaining proper indentation and alignment.",
        "technical": "Validates input has exactly 2 columns via `measure_table()`, calculates first column width (capped at `col_max`), then iterates through row pairs. For each row, writes the term with current indentation, determines if description fits on same line based on `term_len()` vs `first_col`, wraps second column text using `wrap_text()` with calculated width, and writes each wrapped line with appropriate spacing. Side effect: writes formatted output to buffer via `self.write()`."
      },
      "section": {
        "human": "Creates a formatted section in a document with a heading and indented content. When you use this, it automatically adds spacing before the section, writes the section title as a heading, and indents everything you write inside it. When you're done, it removes the indentation so the next content returns to normal formatting.",
        "technical": "Context manager that orchestrates document formatting by calling write_paragraph() for spacing, write_heading() with the section name, then indent() to increase indentation level. Yields control to allow nested content writing within the indented block. Uses try-finally to guarantee dedent() is called for cleanup, ensuring indentation state is properly restored even if exceptions occur during content generation."
      },
      "indentation": {
        "human": "This function temporarily increases the indentation level for formatting text or code output. When you enter this section, the indentation gets deeper (like pressing Tab), and when you exit, it automatically returns to the previous indentation level. It's useful for creating properly formatted, hierarchical text structures like nested lists or code blocks.",
        "technical": "Context manager that wraps indentation state changes with automatic cleanup. Calls `self.indent()` on entry to increase indentation level, yields control to the caller's code block, then guarantees `self.dedent()` execution in the finally block to restore previous indentation state even if exceptions occur. Returns Iterator[None] as required by @contextmanager decorator pattern."
      },
      "getvalue": {
        "human": "Retrieves all the text that has been stored in a buffer (a temporary storage area). Think of it like opening a notebook where you've been writing notes on separate pages, and this function combines all those pages into one continuous piece of text that you can read or use.",
        "technical": "Concatenates all string elements stored in the `self.buffer` list into a single string using an empty string as the separator. Calls the `join()` method on an empty string with `self.buffer` as the argument. Returns the complete concatenated string. No side effects - this is a read-only operation that doesn't modify the buffer state."
      }
    },
    "src/click/globals.py": {
      "get_current_context": {
        "human": "Retrieves the currently active Click command-line context from anywhere in your program. This is useful when you need to access information about the current command being executed without explicitly passing the context around. If no context exists, it either raises an error or quietly returns None, depending on your preference.",
        "technical": "Accesses the thread-local stack `_local.stack[-1]` to retrieve the most recent Context object and casts it to the proper type. Catches AttributeError (if _local has no stack attribute) or IndexError (if stack is empty). When `silent=False` (default), wraps exceptions in RuntimeError with descriptive message; when `silent=True`, returns None on failure. Returns Context object or None."
      },
      "push_context": {
        "human": "Adds a new context object to a stack that keeps track of active contexts in the application. Think of it like adding a new card to the top of a deck - this allows the program to remember what context it's currently working in and switch between different contexts as needed. If no stack exists yet, it creates one first.",
        "technical": "Appends a Context object to a thread-local stack stored in `_local.__dict__`. Uses `setdefault(\"stack\", [])` to lazily initialize an empty list if the stack doesn't exist, then appends the provided context. Operates on thread-local storage (_local), ensuring each thread maintains its own independent context stack. No return value; modifies thread-local state as a side effect."
      },
      "pop_context": {
        "human": "Removes the most recently added context from a stack of contexts. This is typically used when exiting a scope or finishing a task that required temporary context information. Think of it like closing a chapter in a book - you're done with that section and moving back to the previous one.",
        "technical": "Pops the top element from a thread-local stack (_local.stack) using the standard list pop() method. Operates on thread-local storage, meaning each thread maintains its own independent stack. No return value (returns None). Modifies global state by mutating the _local.stack data structure. Typically paired with a corresponding push_context() function for context management."
      },
      "resolve_color_default": {
        "human": "Determines whether colored output should be used in the terminal. If you've already specified whether you want colors (yes or no), it uses your choice. If you haven't decided, it checks the current application settings to see if colors are enabled there. If nothing is set anywhere, it defaults to no preference.",
        "technical": "Implements a three-tier fallback resolution for the color flag parameter. Returns the input `color` value immediately if not None. Otherwise, attempts to retrieve the color setting from the current Click context via `get_current_context(silent=True)`, returning `ctx.color` if context exists. Returns None if no color preference is found at any level. No side effects; pure resolution logic."
      }
    },
    "src/click/parser.py": {
      "_unpack_args": {
        "human": "Takes a list of command-line arguments and matches them to a specification that says how many arguments each position should consume. Some positions take one argument, some take multiple, and one special position can take all remaining arguments. Returns the organized arguments and any leftovers that weren't consumed.",
        "technical": "Processes args and nargs_spec as deques, iterating through nargs specifications to consume arguments accordingly. Handles three cases: nargs=1 (single arg), nargs>1 (tuple of args), nargs<0 (wildcard consuming all remaining args). Uses bidirectional fetching (popleft/pop) when wildcard is present, reverses post-wildcard results, fills missing values with UNSET sentinel, and returns tuple of unpacked args plus list of unconsumed args."
      },
      "_split_opt": {
        "human": "Separates command-line option prefixes (like `-` or `--`) from the actual option name. For example, it splits `--verbose` into `--` and `verbose`, or `-v` into `-` and `v`. If the option starts with a letter or number (no prefix), it returns an empty prefix and the whole option unchanged.",
        "technical": "Parses command-line option strings by examining the first character. Returns tuple of (prefix, name). If first character is alphanumeric (via `isalnum()`), returns `(\"\", opt)`. If first two characters match (e.g., `--`), returns `(opt[:2], opt[2:])`. Otherwise assumes single-character prefix and returns `(first, opt[1:])`. Handles short options (`-v`), long options (`--verbose`), and bare arguments."
      },
      "_normalize_opt": {
        "human": "Takes a command-line option (like \"--verbose\" or \"-v\") and applies a standardization process to make it consistent with the application's naming conventions. If no standardization rules are provided, it leaves the option unchanged. This ensures that options are formatted uniformly throughout the application, regardless of how users or different parts of the code write them.",
        "technical": "Normalizes a command-line option string using a context-provided normalization function. Returns the original opt string unchanged if ctx is None or lacks a token_normalize_func. Otherwise, splits the option into prefix (dashes) and name using _split_opt(), applies ctx.token_normalize_func() to the name portion only, then reconstructs and returns the normalized option with prefix intact (e.g., \"--\" + normalized_name)."
      },
      "__getattr__": {
        "human": "This function handles requests for old or moved features in a software library, warning users that they're using outdated code. When someone tries to access certain deprecated features, it shows a warning message explaining the feature is being phased out, then provides the old version anyway to keep existing code working. If the requested feature doesn't exist at all, it reports an error.",
        "technical": "Module-level `__getattr__` implementation that intercepts attribute access for backward compatibility. For a set of deprecated parser names (OptionParser, Argument, etc.), it emits a DeprecationWarning and returns the underscore-prefixed global equivalent. For 'split_arg_string', it dynamically imports from shell_completion module with a deprecation warning. Raises AttributeError for unrecognized names. Uses stacklevel=2 to report warnings at the caller's location."
      },
      "_fetch": {
        "human": "Retrieves an item from a queue-like collection, choosing which end to take from based on a setting. If the collection is empty, it returns a special \"not set\" value instead of crashing. This allows safely getting items from either the front or back of a line of data.",
        "technical": "Pops and returns an element from a deque, using `popleft()` when `spos` is None (FIFO behavior) or `pop()` otherwise (LIFO behavior). Catches `IndexError` when the deque is empty and returns `UNSET` sentinel value instead. Returns type is union of the deque's value type `V` or `T_UNSET`. The `spos` variable is captured from enclosing scope."
      },
      "__init__": {
        "human": "Sets up a command-line argument parser by initializing its configuration settings. It determines how the parser should handle arguments that appear in unexpected places and what to do when it encounters options it doesn't recognize. If connected to a parent context (like a command group), it inherits those settings; otherwise, it uses safe defaults that will report errors for unknown options.",
        "technical": "Initializes an OptionParser instance with a Context reference and two boolean flags: `allow_interspersed_args` (default True) and `ignore_unknown_options` (default False). If ctx is provided, overrides defaults with `ctx.allow_interspersed_args` and `ctx.ignore_unknown_options`. Initializes empty data structures for option storage: `_short_opt` and `_long_opt` dictionaries for option mappings, `_opt_prefixes` set with \"-\" and \"--\", and `_args` list for positional arguments."
      },
      "process": {
        "human": "Validates and stores a command-line argument value that was collected during parsing. When an argument expects multiple values, it checks that either all values were provided or none were provided - partial values are not allowed. Once validated, it saves the argument value and records the order in which arguments were processed.",
        "technical": "Validates multi-value arguments by counting UNSET placeholders using `sum()` and `isinstance()` checks against `cabc.Sequence`. Raises `BadArgumentUsage` if partial values detected (some UNSET, some not). Normalizes empty tuples to UNSET sentinel. Stores final value in `state.opts[self.dest]` dictionary and appends `self.obj` to `state.order` list to track argument processing sequence. No return value; modifies state object in-place."
      },
      "add_option": {
        "human": "Registers a new command-line option (like `-v` or `--verbose`) with the parser so it can recognize and handle that option when processing user input. It takes the option names (short and long forms), where to store the value, and how to handle it (store, append, count, etc.), then sets up the internal tracking needed to parse this option correctly.",
        "technical": "Normalizes option strings via `_normalize_opt()`, creates an `_Option` object with specified action/nargs/const parameters, then registers it in internal lookup dictionaries. Updates `_opt_prefixes` with option prefixes, populates `_short_opt` dict with short-form options (e.g., `-v`), and populates `_long_opt` dict with long-form options (e.g., `--verbose`). These dictionaries enable fast option lookup during parsing. No return value; modifies parser state via side effects."
      },
      "add_argument": {
        "human": "Registers a new positional argument that the command-line parser should expect from users. This tells the parser what kind of input to look for (like a filename or username) and how many values to accept for that argument. The `obj` parameter acts as a label to help identify this specific argument later when processing the parsed results.",
        "technical": "Creates an `_Argument` instance with the provided `obj` identifier, `dest` name, and `nargs` count (defaulting to 1), then appends it to the internal `self._args` list. This modifies parser state by adding to the positional arguments collection. The `obj` (CoreArgument type) serves as a reference key, `dest` specifies the attribute name for parsed values, and `nargs` controls how many values this argument consumes."
      },
      "parse_args": {
        "human": "This function reads through command-line arguments (like when you type commands in a terminal) and figures out which parts are options (settings/flags) and which are regular arguments. It separates everything into organized groups and keeps track of the order they appeared in. If there are extra arguments left over that don't match anything expected, it returns those too so the program knows what to do with them.",
        "technical": "Creates a `_ParsingState` object to track parsing progress, then sequentially processes arguments through `_process_args_for_options` and `_process_args_for_args` to populate the state. Catches `UsageError` exceptions and re-raises them unless resilient parsing mode is enabled via context. Returns a 3-tuple containing: parsed option values dictionary (`state.opts`), leftover arguments list (`state.largs`), and ordered list of `CoreParameter` objects (`state.order`) representing the sequence of parsed parameters."
      },
      "_process_args_for_args": {
        "human": "This function distributes command-line arguments to their proper destinations when a program is run. It takes all the arguments that were typed after the program name, figures out which argument belongs to which parameter based on how many values each parameter expects, and then processes each one accordingly. After handling all the arguments, it cleans up any leftovers.",
        "technical": "Unpacks combined left and right argument lists (state.largs + state.rargs) using _unpack_args() with nargs specifications from self._args to partition arguments. Iterates through self._args collection, calling each arg's process() method with its corresponding parsed arguments and state object. Updates state by assigning remaining unparsed args to state.largs and clearing state.rargs. Modifies state object in-place as side effect."
      },
      "_process_args_for_options": {
        "human": "Processes command-line arguments to separate options (like --help or -v) from regular arguments. It goes through arguments one by one, identifying which ones are options that need special handling versus regular values. Stops processing when it encounters a double-dash (--) or when options and arguments can't be mixed together anymore.",
        "technical": "Iterates through state.rargs (remaining arguments), popping each argument from the front. Detects options by checking if they start with valid prefixes (e.g., '-') and have length > 1, delegating to _process_opts(). Handles '--' as explicit termination. Non-option arguments are either appended to state.largs (if allow_interspersed_args is True) or cause early return by reinserting the argument. Modifies state object in-place with no return value."
      },
      "_match_long_opt": {
        "human": "Handles long command-line options (like `--verbose` or `--output=file.txt`) by finding the matching option definition and processing its value. If the option name doesn't exist, it suggests similar valid options to help users fix typos. It checks whether the option should have a value attached and raises an error if there's a mismatch between what's provided and what's expected.",
        "technical": "Looks up `opt` in `self._long_opt` dictionary, using `get_close_matches()` for fuzzy matching if not found. For value-taking options, inserts `explicit_value` into `state.rargs` and calls `_get_value_from_state()` to extract the value. Raises `BadOptionUsage` if a non-value option receives an explicit value, otherwise sets value to `UNSET`. Finally invokes `option.process()` to handle the parsed value and update parsing state."
      },
      "_match_short_opt": {
        "human": "Processes command-line arguments that start with a dash followed by single letters (like `-abc`). It goes through each letter, finds what option it represents, and handles it appropriately. If an option needs a value, it grabs it from the remaining text or next argument. Unknown options can either cause an error or be collected and passed along, depending on settings.",
        "technical": "Iterates through characters in a short-form option string (e.g., `-xyz`), normalizing each with `_normalize_opt()` and looking up in `_short_opt` dictionary. For options requiring values (`takes_value`), extracts remaining arg characters via `state.rargs.insert()` and calls `_get_value_from_state()`. Processes each option via `option.process()`. Handles unknown options by either raising `NoSuchOption` or appending to `state.largs` when `ignore_unknown_options` is enabled. Modifies `state` object in-place with no return value."
      },
      "_get_value_from_state": {
        "human": "Retrieves the value(s) for a command-line option from the remaining arguments. If the option expects a value but none is available (or the next argument looks like another option), it either returns a special flag indicating the value can be omitted, or raises an error. Handles options that need single values, multiple values, or can work without values.",
        "technical": "Extracts option values from `state.rargs` based on `option.nargs`. Checks if sufficient arguments remain; if not, returns `FLAG_NEEDS_VALUE` for optional-value options or raises `BadOptionUsage`. For single-arg options, detects if next arg is an option prefix and returns `FLAG_NEEDS_VALUE` if value is optional. Pops single values or slices multiple values as tuple from `state.rargs`, modifying state in-place. Returns string, sequence, or `T_FLAG_NEEDS_VALUE` sentinel."
      },
      "_process_opts": {
        "human": "Processes command-line options (like `--verbose` or `-v`) by figuring out whether they're long options (with `--`) or short options (with `-`). If an option has a value attached with `=`, it separates them. When an option isn't recognized, it either raises an error or adds it to a list of leftover arguments, depending on the settings.",
        "technical": "Parses command-line option strings by first splitting on `=` to extract explicit values, then normalizing and attempting `_match_long_opt()`. On `NoSuchOption` exception, falls back to `_match_short_opt()` unless the prefix is in `_opt_prefixes` (e.g., `--`). If `ignore_unknown_options` is True, appends unmatched options to `state.largs`; otherwise re-raises the exception. Modifies `state` object in-place as side effect."
      }
    },
    "src/click/shell_completion.py": {
      "shell_complete": {
        "human": "Handles auto-completion for command-line programs in different shells (like bash, zsh, etc.). When you press Tab in your terminal, this function figures out what shell you're using and either provides the setup script to enable completions or generates the actual completion suggestions based on what you've typed so far.",
        "technical": "Parses the instruction string to extract shell type and command (source/complete), retrieves the appropriate shell completion class via `get_completion_class()`, instantiates it with CLI context. For \"source\" instruction, outputs the shell-specific completion setup script; for \"complete\" instruction, generates and outputs completion candidates. Returns 0 on success, 1 if shell unsupported or invalid instruction. Uses `echo()` for output."
      },
      "add_completion_class": {
        "human": "Registers a shell completion handler so the system knows which code to use when providing command-line auto-completion for different shells (like Bash, Zsh, etc.). It stores the handler in a registry using a name as the lookup key. If no name is provided, it uses the handler's default name. This allows the completion system to find the right handler when a user presses Tab in their terminal.",
        "technical": "Registers a ShellComplete subclass in the `_available_shells` dictionary registry using a string key. Takes a completion class and optional name parameter; defaults to `cls.name` attribute if name is None. Performs dictionary assignment to store the class reference, then returns the original class unchanged (enabling use as a decorator). Side effect: modifies module-level `_available_shells` dictionary state."
      },
      "get_completion_class": {
        "human": "This function helps the system find the right tool for handling command-line auto-completion based on which shell you're using (like bash, zsh, or fish). When you type a command and press tab to see suggestions, this function looks up the appropriate completion handler for your specific shell. If it can't find a handler for your shell, it simply returns nothing.",
        "technical": "Performs a dictionary lookup on `_available_shells` using the provided shell name as the key. Returns the corresponding `ShellComplete` subclass if registered, or `None` if not found. Acts as a registry accessor for shell completion implementations. The function is a simple wrapper around `dict.get()` with type hints indicating it returns either a `ShellComplete` type or `None`."
      },
      "split_arg_string": {
        "human": "Takes a command-line argument string and splits it into separate pieces (like breaking \"run 'my file.txt'\" into [\"run\", \"my file.txt\"]), similar to how a shell would interpret it. Unlike standard parsing, it doesn't crash when the string is incomplete\u2014if you forget a closing quote or leave an escape character hanging, it just uses whatever partial text it found so far.",
        "technical": "Creates a shlex lexer configured for POSIX-style shell parsing with whitespace splitting and no comment handling. Iterates through tokens generated by the lexer, appending each to output list. Catches ValueError exceptions (raised when lexer encounters incomplete quotes or escapes at end-of-string) and appends the partial token from lex.token directly. Returns list of parsed string tokens, gracefully handling malformed input that would cause shlex.split() to fail."
      },
      "_is_incomplete_argument": {
        "human": "Checks whether a command-line argument is still waiting for more values to be provided. This is useful during auto-completion scenarios to determine if the user should be prompted for additional values for the current argument, or if the argument is already complete and the system should move on to suggesting the next parameter.",
        "technical": "Returns True if param is an Argument instance that can accept more values based on three conditions: (1) nargs=-1 (unlimited values), (2) parameter source is not COMMANDLINE (not yet provided), or (3) nargs>1 but current value length is less than required count. Retrieves current parameter value via ctx.params.get() and checks parameter source using ctx.get_parameter_source(). Returns False for non-Argument parameters."
      },
      "_start_of_option": {
        "human": "Checks whether a piece of text looks like it's starting a command-line option (like \"-h\" or \"--help\"). This helps a program distinguish between actual options/flags that control behavior versus regular text values that the user provides. Returns yes or no based on whether the text starts with a special prefix character.",
        "technical": "Validates if a string represents an option by checking if its first character matches any prefix in `ctx._opt_prefixes` (typically \"-\" or \"--\"). Returns False immediately for empty strings, otherwise extracts the first character and performs membership test against the context's configured option prefix set. Returns boolean indicating option detection without modifying state."
      },
      "_is_incomplete_option": {
        "human": "Checks if a command-line option is waiting for a value to be provided. For example, if someone types `--output` but hasn't yet specified the filename, this function detects that the option is incomplete and needs more input. It only applies to options that actually require values, not simple flags like `--verbose`.",
        "technical": "Returns True if `param` is an Option requiring a value and the last argument in `args` matches one of the parameter's option names. Iterates backwards through `args` up to `param.nargs` positions, searching for an option string using `_start_of_option()`. Excludes flags and count-based options via early return. Uses `isinstance()` check and `param.opts` comparison to validate the incomplete option state."
      },
      "_resolve_context": {
        "human": "Builds a complete chain of command contexts by parsing through nested commands and subcommands in a CLI application. It walks through the command hierarchy (like \"git commit --amend\") to understand the full structure of what the user is trying to execute, without actually running any of the commands or prompting for user input. This helps the system understand the complete command structure for features like auto-completion.",
        "technical": "Creates a Context hierarchy by iterating through command arguments with resilient_parsing enabled to suppress callbacks/prompts. Handles two command types: non-chained Groups (processes one subcommand at a time via resolve_command) and chained Groups (processes multiple subcommands sequentially with allow_extra_args). Uses make_context to instantiate nested contexts, tracking _protected_args and args at each level. Returns the deepest resolved Context in the command hierarchy."
      },
      "_resolve_incomplete": {
        "human": "This function figures out what kind of suggestion to show when a user is typing a command and presses tab for auto-completion. It looks at what the user has typed so far and determines whether they're completing an option name (like `--help`), an option's value, a command argument, or a subcommand name. It handles special cases like equals signs in options and the `--` marker that stops option processing.",
        "technical": "Parses incomplete input to identify the Click object (Command or Parameter) responsible for completion. Normalizes input by splitting \"=\" in option assignments and appending to args list. Returns ctx.command if incomplete starts with option prefix and no \"--\" marker exists. Iterates through params using _is_incomplete_option() to match incomplete option values, then _is_incomplete_argument() for positional arguments. Falls back to returning ctx.command for subcommand completion. Returns tuple of (handler_object, normalized_incomplete_string)."
      },
      "__init__": {
        "human": "Sets up a new completion handler by storing all the necessary information needed to provide command-line auto-completion suggestions. It saves details about the command being completed, any context information, the program's name, and which environment variable triggered the completion request. This is the initialization step that prepares the system to generate helpful suggestions when users press Tab.",
        "technical": "Constructor that initializes instance attributes for a command-line completion handler. Stores four parameters as instance variables: `cli` (Command object), `ctx_args` (mutable mapping for context arguments), `prog_name` (string for program name), and `complete_var` (string for completion environment variable). No validation, transformation, or side effects - pure attribute assignment for later use by completion methods."
      },
      "func_name": {
        "human": "Creates a safe, standardized name for a shell completion function based on the program's name. It cleans up the program name by removing special characters and converting hyphens to underscores, then adds an underscore prefix and \"_completion\" suffix. This ensures the function name follows shell naming rules and won't cause syntax errors.",
        "technical": "Sanitizes `self.prog_name` by first replacing hyphens with underscores, then uses `re.sub()` with `\\W*` pattern and `re.ASCII` flag to strip all non-word characters (anything except letters, digits, underscores). Returns formatted string with underscore prefix and \"_completion\" suffix (e.g., \"my-prog\" becomes \"_my_prog_completion\"). Pure transformation function with no side effects."
      },
      "source_vars": {
        "human": "Provides the necessary information needed to fill in a template for shell completion scripts. It gathers three pieces of information: the name of the completion function, the name of a special variable used for completion, and the name of the program being completed. This data is packaged together so it can be inserted into a completion script template.",
        "technical": "Returns a dictionary containing three key-value pairs mapping template variable names to instance attributes: `complete_func` maps to `self.func_name`, `complete_var` maps to `self.complete_var`, and `prog_name` maps to `self.prog_name`. These values are used for string formatting operations on `source_template`. No external function calls or data transformations occur; it's a simple accessor method that bundles instance attributes into a dict structure."
      },
      "source": {
        "human": "This function retrieves the source code or source information of something, but only after verifying that the version is compatible or up-to-date. It acts as a safety wrapper that ensures version requirements are met before allowing access to the underlying source data. Think of it like checking your software version before downloading a file.",
        "technical": "Performs version validation via `self._check_version()` before delegating to parent class's `source()` method using `super()`. Returns a string containing source information from the parent implementation. The version check acts as a guard clause that likely raises an exception if version requirements aren't met. No data transformation occurs; this is a pass-through method with added validation."
      },
      "get_completion_args": {
        "human": "Extracts and prepares command-line arguments for shell auto-completion. When you're typing a command and press Tab to see suggestions, this function figures out what you've already typed and what word you're currently completing. It handles a special case where the Fish shell includes the incomplete word twice, removing the duplicate to avoid confusion.",
        "technical": "Parses shell completion environment variables COMP_WORDS (full command line) and COMP_CWORD (incomplete word) using split_arg_string(). Extracts arguments by slicing cwords[1:] to exclude the command name. Implements Fish shell compatibility by detecting and removing duplicate incomplete word from args list using pop(). Returns tuple of (completed_args_list, incomplete_word_string) for completion matching."
      },
      "get_completions": {
        "human": "Provides auto-complete suggestions when a user is typing a command in the shell. It figures out what the user has already typed, understands the context of where they are in the command structure, and then asks the appropriate command or parameter object for relevant completion suggestions to show the user.",
        "technical": "Resolves the Click CLI context from partial command arguments using `_resolve_context()`, then determines the target object (command/parameter) and refined incomplete string via `_resolve_incomplete()`. Delegates to the resolved object's `shell_complete()` method, passing context and incomplete value, returning a list of `CompletionItem` objects. Acts as orchestrator between Click's context resolution and completion generation systems."
      },
      "format_completion": {
        "human": "Converts a completion item into a formatted text string for display. If the item has help text available, it includes that as additional information after a tab character. Otherwise, it just shows the basic type and value. This creates a consistent, readable format for showing auto-completion suggestions to users.",
        "technical": "Takes a CompletionItem object and returns a formatted string representation. Conditionally constructs the output: if `item.help` exists, returns \"{type},{value}\\t{help}\" format; otherwise returns \"{type},{value}\" format. Uses f-string formatting for string concatenation. Returns a string suitable for display in completion UI/menus."
      },
      "complete": {
        "human": "This function generates a list of auto-completion suggestions that can be displayed in a command-line shell. When a user starts typing a command and presses tab, this function figures out what they're typing, finds all possible ways to complete it, formats each suggestion nicely, and sends them back to the shell as a simple text list.",
        "technical": "Orchestrates shell completion by: (1) calling `get_completion_args()` to parse current command context into args and incomplete text, (2) invoking `get_completions(args, incomplete)` to retrieve completion candidates, (3) transforming each completion item via `format_completion()` into string format, and (4) returning newline-delimited string of all formatted completions. Acts as the main entry point coordinating three separate methods to produce shell-ready completion output."
      },
      "_check_version": {
        "human": "Checks if the user has a compatible version of the Bash shell installed on their computer. The function looks for Bash version 4.4 or newer, which is required for shell completion features to work properly. If Bash is too old or can't be found, it displays a warning message to the user explaining that shell completion won't be available.",
        "technical": "Locates bash executable using shutil.which(), then executes it with subprocess.run() to retrieve $BASH_VERSION. Parses version string using regex to extract major/minor version numbers. Compares against minimum requirement (4.4) using string comparison. Outputs localized error messages via echo() and _() for two failure cases: version too old or bash not detected. No return value; side effect is stderr output only."
      }
    },
    "src/click/termui.py": {
      "hidden_prompt_func": {
        "human": "This function securely collects sensitive information from a user by hiding what they type on the screen. When you need to enter a password or secret data, this function displays your custom message and lets you type without showing the characters on screen, protecting your private information from anyone looking over your shoulder.",
        "technical": "Wraps Python's `getpass.getpass()` function to provide secure password input with masked characters. Takes a string prompt as input, imports the getpass module, calls `getpass.getpass()` with the provided prompt, and returns the user's input as a string. The input is read from the terminal without echoing characters to stdout, providing basic security for credential collection."
      },
      "_build_prompt": {
        "human": "Builds a user-friendly prompt message for interactive command-line input. Takes basic prompt text and enhances it by optionally adding available choices (like \"yes/no\"), showing default values in brackets, and appending a suffix (like a colon). This creates clear, informative prompts that help users understand what input is expected and what the default option will be.",
        "technical": "Constructs a formatted prompt string by conditionally appending choice options and default values to base text. If `type` is a `Choice` instance and `show_choices` is True, extracts and joins `type.choices` as comma-separated string in parentheses. If `default` exists and `show_default` is True, formats default value via `_format_default()` and wraps in brackets. Returns concatenated string with suffix appended. Pure string manipulation with no side effects."
      },
      "_format_default": {
        "human": "Takes a default value and makes it more readable for display purposes. When the default value is a file object (like an open file), it extracts and returns just the filename instead of showing the complex file object. For non-file values, it simply returns them unchanged. This helps present cleaner, more understandable default values to users.",
        "technical": "Accepts any type and checks if it's an instance of io.IOBase or LazyFile with a 'name' attribute using isinstance() and hasattr(). If true, extracts and returns the 'name' attribute (typically the file path string). Otherwise, returns the input unchanged. Used for formatting default parameter values in CLI contexts, converting file objects to their string representations while preserving other types as-is."
      },
      "prompt": {
        "human": "Asks the user to type something and waits for their response. Can hide what they type (like for passwords), show default values, and ask them to type the same thing twice to confirm they didn't make a mistake. Keeps asking until it gets valid input or the user cancels by pressing Ctrl+C.",
        "technical": "Implements interactive CLI prompting with input validation loop. Uses `hidden_prompt_func` or `visible_prompt_func` for input capture, `_build_prompt()` to format prompt text with defaults/choices, and `convert_type()` for value validation. Handles KeyboardInterrupt/EOFError by raising `Abort`. Supports confirmation loop comparing two inputs, outputs to stderr if `err=True`, and applies custom `value_proc` for type conversion with `UsageError` exception handling."
      },
      "confirm": {
        "human": "Asks the user a yes/no question and waits for their answer. If the user doesn't provide a valid response (like typing something other than yes/no), it keeps asking until they do. Can optionally use a default answer if the user just presses Enter, and can stop the program entirely if the user answers \"no\" and the abort option is enabled.",
        "technical": "Builds a formatted prompt using `_build_prompt()` with y/n indicators, then enters a loop that displays the prompt via `echo()` and captures user input through `visible_prompt_func()`. Validates input against (\"y\", \"yes\", \"n\", \"no\") or empty string for default, repeating on invalid input. Catches `KeyboardInterrupt`/`EOFError` to raise `Abort` exception. Returns boolean result, optionally raising `Abort` if answer is negative and `abort=True`."
      },
      "echo_via_pager": {
        "human": "Displays text content to the user through their system's default paging program (like 'less' or 'more' on Unix systems). This allows users to read long text output one screen at a time instead of having everything scroll by at once. It can handle text provided as a simple string, a list of strings, or even a function that generates text on-demand, and optionally preserves color formatting.",
        "technical": "Normalizes input from three possible formats (generator function, string, or iterable) into a unified iterator. Calls `resolve_color_default()` to determine ANSI color support, converts all elements to strings via generator expression, then delegates to `_termui_impl.pager()` with the text generator chained with a newline. Uses `inspect.isgeneratorfunction()` for type detection and `itertools.chain()` to append final newline. Returns None but produces side effect of displaying paginated output to stdout."
      },
      "progressbar": {
        "human": "Creates a visual progress bar that displays while your program processes items in a list or completes a task. Shows helpful information like percentage complete, estimated time remaining, and current position. Designed to give users feedback during long-running operations so they know the program is working and how much longer it will take.",
        "technical": "Factory function that instantiates and returns a ProgressBar context manager with configurable display options. Resolves color support via `resolve_color_default()`, then passes all 15 parameters (iterable, length, display flags, formatting chars, file stream, etc.) directly to the ProgressBar constructor from `_termui_impl` module. Returns a generic ProgressBar[V] instance that can iterate over items or be manually updated via its `update()` method."
      },
      "clear": {
        "human": "Clears all text from your terminal window and moves the cursor back to the top-left corner, giving you a fresh, empty screen to work with. This is like hitting a \"reset\" button for your terminal display. If the program isn't running in an actual terminal (for example, if output is being saved to a file), it does nothing to avoid sending confusing characters.",
        "technical": "Checks if stdout is connected to a TTY using `isatty(sys.stdout)` and returns early if not. When connected to a terminal, sends ANSI escape sequences via `echo()`: `\\033[2J` to clear the entire screen buffer and `\\033[1;1H` to reposition the cursor to row 1, column 1. No return value; operates purely through side effects on the terminal display state."
      },
      "_interpret_color": {
        "human": "Converts different color formats into a standardized text format used for terminal display. Takes a color that could be specified as a number, RGB values, or a color name, and translates it into the specific code that terminals understand to display that color. The offset parameter allows switching between foreground and background colors.",
        "technical": "Converts color input into ANSI escape sequence format strings. Handles three input types: integers (returns 256-color palette format \"38+offset;5;{color}\"), tuples/lists of RGB values (returns true-color format \"38+offset;2;{r};{g};{b}\"), and string color names (looks up in _ansi_colors dictionary and adds offset). The offset parameter (typically 0 or 10) differentiates foreground (38) from background (48) color codes."
      },
      "style": {
        "human": "Adds visual styling to text for display in terminal windows by wrapping it with special formatting codes. Allows you to change text color (foreground and background), make text bold, italic, underlined, blinking, and apply other visual effects. By default, the styling automatically resets after the text so it doesn't affect subsequent output.",
        "technical": "Converts input to string, builds list of ANSI escape sequences based on provided style parameters (fg/bg colors via `_interpret_color()`, text attributes like bold/dim/underline with specific ANSI codes). Concatenates escape codes + text + optional reset code (`_ansi_reset_all`) into final string. Supports named colors, 8-bit (0-255), and 24-bit RGB color specifications. Raises TypeError for invalid color values."
      },
      "unstyle": {
        "human": "Removes color and formatting codes from text that would normally appear styled in a terminal. When you have text with colors or bold/italic formatting, this function strips out those invisible formatting instructions and returns just the plain text. This is useful when you need to save or process text without the visual styling information.",
        "technical": "Wrapper function that delegates to `strip_ansi()` to remove ANSI escape sequences from the input string. Takes a string parameter and returns a cleaned string with all ANSI control codes removed. Simple pass-through implementation with no data transformation beyond the underlying `strip_ansi()` call. No side effects or state modifications."
      },
      "secho": {
        "human": "Prints a message to the console with optional styling (like colors or formatting) in a single convenient function call. Instead of separately styling text and then printing it, this combines both steps. It handles different types of input - regular text gets styled, but raw binary data (bytes) is printed as-is without styling. This makes it easier to display formatted output in command-line applications.",
        "technical": "Convenience wrapper that combines `style()` and `echo()` functions. Accepts a message and styling kwargs (e.g., fg, bg), applies styling via `style()` if message is not bytes/bytearray, then passes result to `echo()` along with output parameters (file, nl, err, color). Returns None; performs side effect of writing styled output to specified stream. Bytes are passed directly to echo without style transformation to preserve binary data integrity."
      },
      "edit": {
        "human": "Opens a text editor (like Notepad or vim) so users can edit either some provided text or an existing file. If editing text, it creates a temporary file, opens it in the editor, waits for the user to save and close, then returns the modified content. If editing an existing file, it just opens that file directly and returns nothing since the file is modified in place.",
        "technical": "Instantiates an `Editor` object with configuration parameters (editor path, environment variables, save requirements, file extension), then branches on whether `filename` is provided. If no filename, calls `ed.edit(text)` which handles temporary file creation and returns modified text. If filename exists, normalizes it to a tuple (if string) and calls `ed.edit_files(filenames)` for direct file editing, returning `None`. Delegates all editor interaction logic to the `_termui_impl.Editor` class."
      },
      "launch": {
        "human": "Opens a file or web link using your computer's default application - like opening a website in your browser or a document in its associated program. Can also open a file manager to show where a file is located on your computer instead of opening the file itself. Optionally waits for the opened application to close before continuing.",
        "technical": "Thin wrapper function that delegates to `open_url()` from `_termui_impl` module, passing through all three parameters (url, wait, locate). Returns integer exit code from the launched application (0 typically indicates success). No validation or processing of inputs - acts purely as a public API facade over the internal implementation function."
      },
      "getchar": {
        "human": "Reads a single character from the keyboard when a user types it. The function always reads directly from the terminal (not from redirected input), and can optionally show the typed character on screen or hide it. This is useful for password entry or interactive menus where you need to capture one keypress at a time.",
        "technical": "Lazy-loads the platform-specific `_getchar` implementation from `_termui_impl` module on first call using a global cache variable. Delegates actual character reading to the cached implementation function, passing through the `echo` boolean parameter. Returns a string (usually single unicode character, occasionally multiple characters due to terminal buffering or Windows non-ASCII input handling). No direct I/O operations in this wrapper function."
      },
      "raw_terminal": {
        "human": "Puts the terminal into \"raw mode\" where it can read individual keystrokes directly without waiting for the Enter key. This is useful for interactive programs that need to respond immediately to user input, like text editors or games. Returns a context manager that handles switching the terminal mode on and off automatically.",
        "technical": "Lazy-imports the actual `raw_terminal` implementation from the `_termui_impl` module and returns its result. Acts as a public API wrapper that defers the import until called, likely to avoid circular dependencies or reduce initial load time. Returns an `AbstractContextManager[int]` that manages terminal mode state, where the integer likely represents a file descriptor or terminal state value."
      },
      "pause": {
        "human": "Pauses program execution and waits for the user to press any key before continuing, similar to the \"pause\" command in Windows. Displays a customizable message (defaulting to \"Press any key to continue...\") and only works when the program is running in an interactive terminal. If not in a terminal, it simply does nothing and lets the program continue.",
        "technical": "Checks if both stdin and stdout are connected to a TTY using `isatty()`, returning early if not. Displays the info message via `echo()` (to stdout or stderr based on `err` flag), then calls `getchar()` to block until user input. Catches KeyboardInterrupt and EOFError exceptions to handle Ctrl+C and EOF gracefully. Uses a try-finally block to ensure a newline is printed after user input via `echo()`."
      },
      "prompt_func": {
        "human": "Displays a prompt message to the user and waits for their input response. It handles the special case where the input might be hidden (like password entry) and ensures the prompt displays correctly with proper colors on different systems. If the user cancels the input (pressing Ctrl+C), it cleans up the display and stops the operation gracefully.",
        "technical": "Selects between hidden_prompt_func or visible_prompt_func based on hide_input flag. Splits prompt text to echo all but last character to stderr for colorama compatibility, then passes final character to the selected prompt function to work around a readline backspace bug. Catches KeyboardInterrupt/EOFError exceptions, echoes newline if input was hidden, and raises Abort exception. Returns the string input from the user."
      }
    },
    "src/click/testing.py": {
      "_pause_echo": {
        "human": "Temporarily pauses the \"echo\" feature of an input stream, allowing code to run without the stream repeating or displaying what's being typed. This is useful when you need to hide sensitive input (like passwords) or prevent duplicate output. After the code finishes running, it automatically turns the echo feature back on.",
        "technical": "Context manager that temporarily disables echoing on an EchoingStdin stream by setting its `_paused` attribute to True. Yields control to the caller's code block, then restores echoing by setting `_paused` back to False in the finally phase. Handles None streams gracefully by yielding immediately without modification. Uses the contextmanager decorator to provide automatic cleanup via try-finally semantics."
      },
      "make_input_stream": {
        "human": "Converts different types of input (text, bytes, or file-like objects) into a standardized binary stream that can be read from. This ensures that no matter what format the input comes in, the program can work with it in a consistent way. If the input is already a readable stream, it finds the binary version of it; otherwise, it wraps the data in a new stream object.",
        "technical": "Normalizes input into a `t.BinaryIO` stream through three pathways: (1) if input has a `read` attribute, calls `_find_binary_reader()` to locate binary reader or raises TypeError; (2) converts None to empty bytes `b\"\"`; (3) encodes string input using specified charset. Finally wraps the bytes in `io.BytesIO` and returns it. Handles type coercion with `t.cast` for type checking compliance."
      },
      "__init__": {
        "human": "Sets up the initial configuration for a testing or command-line environment. It stores settings like what character encoding to use (like UTF-8), what environment variables are available, whether to show what the user types, and whether to handle errors gracefully. Think of it as preparing the workspace before running commands.",
        "technical": "Constructor that initializes instance attributes for a CLI testing context. Accepts charset (defaults to \"utf-8\"), optional environment variable mapping, echo_stdin flag for input echoing, and catch_exceptions flag for error handling. Stores charset, env (defaulting to empty dict if None), echo_stdin, and catch_exceptions as instance variables. No validation or transformation performed on inputs."
      },
      "_echo": {
        "human": "This function acts as a conditional \"echo\" or pass-through mechanism that writes data to an output destination only when the system is not paused. It's like a valve that can be turned off - when open (not paused), data flows through to the output; when closed (paused), the data still passes through the function but doesn't get written anywhere. The data always gets returned regardless of the pause state.",
        "technical": "Conditionally writes bytes to `self._output` stream based on `self._paused` flag state. When not paused, invokes `self._output.write(rv)` to emit the byte data. Always returns the input `rv` unchanged, making it a transparent pass-through operation. Side effect: writes to output stream only when `_paused` is False. Return value is the original bytes parameter regardless of write operation execution."
      },
      "flush": {
        "human": "This function ensures that any buffered data waiting to be written is immediately sent to its destination. It's like forcing a save operation - instead of waiting for data to be written later, it pushes everything out right now. This happens in two places: first in the parent system, then in a secondary location where data is being copied.",
        "technical": "Implements a flush operation that propagates through an inheritance hierarchy. Calls `super().flush()` to invoke the parent class's flush method, then calls `self.copy_to.flush()` to flush a secondary output stream. This pattern suggests the class implements a tee-like functionality, duplicating output to multiple destinations and ensuring both are synchronized when flushing buffers. Returns None with no parameters beyond self."
      },
      "write": {
        "human": "This function acts as a \"tee\" or splitter for writing data - it sends the same data to two different destinations at once. Imagine copying a document while also filing the original; this writes data to a backup location first, then continues with the normal write operation. It's useful when you need to duplicate output, like saving to a file while also displaying on screen.",
        "technical": "Implements a write-through pattern by first writing the buffer `b` to a secondary destination (`self.copy_to`), then delegating to the parent class's write method via `super().write(b)`. Returns the integer result from the parent's write operation (typically bytes written). Creates a side effect of duplicating all written data to `copy_to` before performing the primary write operation. The buffer is passed unchanged to both destinations."
      },
      "__del__": {
        "human": "This is a cleanup function that runs automatically when an object is being destroyed. It ensures that three output streams (standard error, standard output, and main output) are closed in a specific order to prevent conflicts. This is important because if streams close in the wrong order, some data might not be saved properly or errors could occur.",
        "technical": "Destructor method that explicitly closes three file-like objects in reverse dependency order: stderr first, then stdout, then the main output stream. This ordering prevents race conditions where the output stream might close before dependent streams finish flushing their buffers. Implements deterministic cleanup during garbage collection to avoid unpredictable stream closure behavior in Python's default destructor chain."
      },
      "output": {
        "human": "Converts the raw terminal output from a command-line program into readable text that you can display or process. It takes the binary data captured from both regular output and error messages, converts it to text characters, and cleans up the line endings so they display correctly across different operating systems.",
        "technical": "Decodes `self.output_bytes` (binary data) to a Unicode string using the charset from `self.runner.charset`, applying 'replace' error handling for invalid characters. Normalizes Windows-style line endings (`\\r\\n`) to Unix-style (`\\n`) for cross-platform consistency. Returns the decoded and normalized string. This is a property accessor that combines stdout and stderr streams in chronological order (as of version 8.2)."
      },
      "stdout": {
        "human": "Converts the program's raw output data into readable text that can be displayed or processed. It takes the binary output captured from a command or process and transforms it into a normal text string, ensuring line breaks work correctly across different operating systems (Windows vs. Unix/Linux).",
        "technical": "Decodes `stdout_bytes` from bytes to string using the runner's configured charset with 'replace' error handling for invalid characters. Normalizes Windows-style line endings (\\r\\n) to Unix-style (\\n) for cross-platform consistency. Returns the decoded and normalized string. Implemented as a property for convenient attribute-style access to the processed stdout data."
      },
      "stderr": {
        "human": "Converts error messages from a program's execution into readable text that can be displayed to users. Takes the raw error output (which is in bytes) and transforms it into a proper text string, making sure line breaks work correctly across different operating systems. Always returns a readable string, even if some characters can't be properly converted.",
        "technical": "Decodes the `stderr_bytes` attribute from bytes to string using the runner's charset encoding with 'replace' error handling to prevent decode exceptions. Normalizes Windows-style line endings (\\r\\n) to Unix-style (\\n) for consistent output formatting. Returns a unicode string representation of standard error. The 'replace' mode ensures malformed bytes are substituted with replacement characters rather than raising UnicodeDecodeError."
      },
      "__repr__": {
        "human": "Creates a text representation of an object that shows whether it's in a successful state or has encountered an error. When you print or inspect this object, you'll see its type name along with either \"okay\" if everything is fine, or details about what went wrong if there's an error.",
        "technical": "Implements the `__repr__` special method to return a string representation of the object. Conditionally formats `self.exception` using `repr()` if it exists, otherwise uses \"okay\". Returns an f-string containing the class name (via `type(self).__name__`) and the exception status, wrapped in angle brackets (e.g., `<ClassName okay>` or `<ClassName Exception('error')>`)."
      },
      "get_default_prog_name": {
        "human": "Retrieves the display name for a command-line program. When a command has been given a specific name, it uses that name; otherwise, it defaults to calling it \"root\". This ensures every command always has some identifier to show to users, even if no custom name was provided.",
        "technical": "Returns the `name` attribute of a Command object, falling back to the string literal \"root\" if the name is None or empty (using Python's `or` operator for truthiness check). Simple getter method with no side effects, data transformations, or external dependencies. Returns a string value unconditionally."
      },
      "make_env": {
        "human": "Creates a customized set of environment variables for running a script. It starts with a base set of environment settings stored in the object, then allows you to override or add specific variables as needed. This lets you control what environment conditions a script runs under, like changing paths or configuration values for different situations.",
        "technical": "Creates a shallow copy of `self.env` dictionary using `dict()`, then conditionally merges the `overrides` mapping into it via `update()` if overrides are provided. Returns a mapping of environment variable names to their string values (or None). The function performs dictionary merging with overrides taking precedence over base environment values. No side effects - creates new dictionary rather than modifying `self.env`."
      },
      "isolation": {
        "human": "Creates an isolated testing environment for running command-line tools. It temporarily replaces the program's input/output streams and environment variables with test versions, captures all output, and then restores everything back to normal when done. This allows you to test how a command-line program behaves with specific inputs without affecting the real system or requiring actual user interaction.",
        "technical": "Context manager that mocks sys.stdin/stdout/stderr with BytesIO-backed text wrappers, overrides os.environ with provided env dict, and patches Click's prompt functions (visible_prompt_func, hidden_prompt_func, _getchar) to read from the mocked stdin. Uses StreamMixer to capture and separate stdout/stderr streams. Yields tuple of three BytesIO streams (stdout, stderr, mixed output). Finally block restores all original system state including streams, environment variables, and Click internals."
      },
      "invoke": {
        "human": "This function runs a command-line application in a controlled, isolated test environment and captures what happens. It's like running a program in a sandbox where you can provide fake input, check what it prints out, and see if it succeeded or failed. This is primarily used for testing command-line tools without affecting the real system.",
        "technical": "Executes a Click CLI command within an isolated context manager that captures stdout/stderr streams. Parses string args via shlex.split if needed, invokes cli.main() with provided arguments, and handles both SystemExit and general exceptions based on catch_exceptions flag. Extracts exit codes from SystemExit (converting non-int codes to strings), flushes output streams, and returns a Result object containing captured output bytes, return value, exit code, and exception info for test assertions."
      },
      "isolated_filesystem": {
        "human": "Creates a temporary workspace folder and switches your program to work inside it, like setting up a clean sandbox for testing. When done, it switches back to where you started and cleans up the temporary folder (unless you specified where to create it). This prevents tests from accidentally interfering with each other by keeping their file operations separate.",
        "technical": "Context manager that saves current working directory with `os.getcwd()`, creates temp directory via `tempfile.mkdtemp()`, and changes to it with `os.chdir()`. Yields the temp directory path for use in the context block. In the finally clause, restores original working directory and conditionally removes temp directory with `shutil.rmtree()` only if `temp_dir` parameter was None (auto-cleanup). Silently catches OSError during cleanup to handle permission issues."
      },
      "visible_input": {
        "human": "Displays a prompt to the user, reads their input from a pre-configured source, and shows what they typed back on the screen. This is useful when input is being read from a file or automated source instead of a keyboard, making it visible what values are being \"entered\" as if someone were typing them. It helps with debugging or replaying recorded inputs.",
        "technical": "Writes prompt to stdout, retrieves next line from `text_input` iterator (strips carriage return/newline), echoes the retrieved value back to stdout with newline, and flushes output buffer. Raises EOFError when `text_input` is exhausted (StopIteration). The `@_pause_echo` decorator suggests this function temporarily modifies echo behavior. Returns the stripped input string."
      },
      "hidden_input": {
        "human": "Prompts the user for input without displaying what they type on the screen (like entering a password). It shows the prompt message, waits for the user to type something, then returns what they typed. This is useful when you need to collect sensitive information that shouldn't be visible to others looking at the screen.",
        "technical": "Writes prompt to stdout and flushes buffer, then retrieves next line from text_input iterator. Strips carriage return and newline characters from input using rstrip(\"\\r\\n\"). Converts StopIteration exception to EOFError when input stream ends. The @_pause_echo decorator (not shown) likely disables terminal echo to hide user input during execution."
      },
      "_getchar": {
        "human": "Reads a single character from keyboard input and optionally displays it back on the screen as you type. This is like when you type a password - sometimes you see the characters (echo on) and sometimes you don't (echo off). It ensures the character is immediately shown on screen before continuing.",
        "technical": "Reads one character from stdin using sys.stdin.read(1). Conditionally writes the character to stdout if echo parameter is True. Calls sys.stdout.flush() to force immediate display of buffered output. Returns the single character string. Decorated with @_pause_echo which likely handles terminal echo mode configuration."
      },
      "should_strip_ansi": {
        "human": "Determines whether colored text formatting (ANSI codes) should be removed from output. If no color preference is specified, it checks a default setting to decide. If a color preference is given, it returns the opposite - meaning if color is wanted, don't strip it; if color isn't wanted, do strip it.",
        "technical": "Returns a boolean indicating whether ANSI escape codes should be stripped from output streams. Takes optional `stream` (unused) and `color` parameters. When `color` is None, returns the negation of `default_color` (an external variable). When `color` is provided, returns its negation (`not color`). The logic inverts the color preference: True for color means False for stripping, and vice versa."
      }
    },
    "src/click/types.py": {
      "convert_type": {
        "human": "Converts a Python data type (like string, integer, or boolean) into a special Click parameter type that can be used for command-line arguments. If no type is given, it tries to figure out the type by looking at a default value. For example, if the default value is the number 5, it knows you want an integer parameter.",
        "technical": "Takes a Python type annotation and optional default value, returning a Click ParamType instance. If ty is None, infers type from default using type() on scalar values or recursively mapping type() for nested tuples/lists. Maps built-in types (str, int, float, bool) to corresponding Click constants (STRING, INT, FLOAT, BOOL). Returns Tuple() for tuple types, wraps callable types in FuncParamType(), and includes debug assertion to catch uninstantiated ParamType classes."
      },
      "to_info_dict": {
        "human": "Converts an object into a dictionary format that contains information about it, including details about multiple \"types\" it contains. This is useful for exporting or displaying the object's data in a structured way, such as when saving to a file or sending over a network. It builds upon a basic conversion and adds specific information about the types associated with this object.",
        "technical": "Calls parent class's `to_info_dict()` method to get base dictionary representation, then augments it by adding a \"types\" key. The \"types\" value is a list comprehension that iterates over `self.types` and calls `to_info_dict()` on each type object. Returns the enhanced dictionary containing both inherited info and the serialized types list. No side effects; pure data transformation method."
      },
      "__call__": {
        "human": "This function acts as a gateway that processes incoming values before they're used. When given a value, it checks if the value actually exists (isn't empty or null). If the value is valid, it passes it through a conversion process to transform it into the correct format. If the value is empty or null, it simply does nothing and returns nothing.",
        "technical": "Implements the callable protocol (`__call__`) to make the object invocable like a function. Performs null-check on input value, returning None implicitly if value is None. Otherwise delegates to `self.convert(value, param, ctx)` method, passing through the value along with optional Parameter and Context objects. Acts as a wrapper/dispatcher that adds null-safety before invoking the actual conversion logic."
      },
      "get_missing_message": {
        "human": "Creates an error message that shows users what valid options they can choose from when they forget to provide a required choice. The message displays all available choices in a formatted list, making it easy for users to see what they should have entered. This helps users correct their mistake by showing them exactly what values are acceptable.",
        "technical": "Generates a localized error message string by retrieving normalized choice mappings via `_normalized_mapping(ctx)`, extracting the display values, and joining them with comma-newline-tab separators. Uses the `_()` function for internationalization support. Returns a formatted string with pattern \"Choose from:\\n\\t{choices}\" where choices are tab-indented and comma-separated. Takes Parameter and optional Context arguments but primarily uses Context for mapping normalization."
      },
      "convert": {
        "human": "This function validates that the correct number of values have been provided for a tuple-based parameter, then converts each value to its expected type. If the wrong number of values is given, it shows an error message that correctly uses singular or plural grammar. It ensures data matches the expected structure before processing it.",
        "technical": "Validates length match between `self.types` and input `value`, raising a localized error via `self.fail()` with `ngettext()` for proper pluralization if lengths differ. Converts each value by calling corresponding type converter from `self.types` on paired elements using `zip()`, returning a tuple of converted values. Part of a type conversion system where `self.types` contains callable converters for each tuple position."
      },
      "split_envvar_value": {
        "human": "Takes a text value from an environment variable and breaks it into a list of separate pieces. For example, if you have a setting like \"item1,item2,item3\" stored in an environment variable, this function splits it into individual items. The way it splits depends on a separator character (like comma or semicolon) that's been configured elsewhere.",
        "technical": "Calls the `split()` method on the input string `rv` (or empty string if `rv` is falsy) using `self.envvar_list_splitter` as the delimiter. Returns a sequence of string tokens. When `envvar_list_splitter` is `None`, `split()` uses whitespace as delimiter and strips leading/trailing whitespace. When a specific delimiter is set, empty strings may be included in the result from consecutive delimiters."
      },
      "fail": {
        "human": "This function is used to stop the program and report an error when something goes wrong with user input. It creates a clear error message that explains what invalid value was provided and where the problem occurred, helping users understand what they need to fix.",
        "technical": "Raises a `BadParameter` exception with the provided error message, parameter reference, and context object. Acts as a convenience wrapper that constructs and throws the exception in a single call. Takes optional `param` (Parameter) and `ctx` (Context) arguments to provide error location context. Returns `t.NoReturn` type hint indicating this function never returns normally (always raises)."
      },
      "shell_complete": {
        "human": "Helps the command-line interface suggest file or folder names as you type. When you're entering a path, it tells the auto-completion system whether to show only folders, or both files and folders, based on what the command accepts. This makes typing commands faster by letting you tab-complete paths.",
        "technical": "Returns a single-element list containing a CompletionItem configured for shell path completion. Determines completion type by checking self.dir_okay and self.file_okay flags: sets type=\"dir\" if only directories are allowed, otherwise type=\"file\". Passes the incomplete string and type to CompletionItem constructor, delegating actual path expansion to the shell completion system."
      },
      "__init__": {
        "human": "Sets up a validator for file or directory paths with specific requirements. Configures what types of paths are acceptable (files vs directories), whether they must already exist, and what permissions they need (readable, writable, executable). Also determines how to display the path type to users (as \"file\", \"directory\", or generic \"path\").",
        "technical": "Constructor that initializes 10 instance attributes controlling path validation behavior: exists, file_okay, dir_okay, readable, writable, executable, resolve_path, allow_dash, and path_type. Sets self.name based on file_okay/dir_okay combination using internationalization function _() for localized strings (\"file\", \"directory\", or \"path\"). No validation logic executed; purely stores configuration for later use."
      },
      "_normalized_mapping": {
        "human": "Creates a lookup table that shows both the original choice values and their normalized (standardized) versions that users can type on the command line. This helps the system understand different ways users might enter the same choice, like accepting both \"Yes\" and \"yes\" as the same option.",
        "technical": "Constructs and returns a dictionary mapping original choice values to their normalized string representations by iterating over `self.choices` and calling `self.normalize_choice()` for each choice with the provided context. Uses dictionary comprehension to build the mapping where keys are `ParamTypeValue` types and values are normalized strings. Returns an immutable `cabc.Mapping` type for read-only access to the choice-to-normalized-value mappings."
      },
      "normalize_choice": {
        "human": "Converts a choice value (like a menu option or command) into a standardized text format so it can be reliably compared with user input. This ensures that choices like \"Yes\", \"YES\", and \"yes\" are all treated as the same option when needed. It handles special choice types (like enums) and applies any custom text normalization rules that have been configured.",
        "technical": "Extracts string representation from choice parameter (using `.name` for enum.Enum instances, otherwise casting to str). Applies optional context-specific token normalization function if ctx and ctx.token_normalize_func exist. Conditionally applies case-folding transformation based on self.case_sensitive flag. Returns the normalized string value suitable for case-insensitive or custom-normalized choice matching."
      },
      "get_metavar": {
        "human": "Generates a display label (metavar) that shows users what type of value they should provide for a command-line parameter. For options, it shows the types of allowed choices (like \"INT|FLOAT\"). For required arguments, it wraps the choices in curly braces {}, while optional parameters get square brackets []. This helps users understand what input format is expected.",
        "technical": "Returns formatted string representing parameter's metavar for CLI help text. Branches on param.param_type_name and param.show_choices: for options without show_choices, extracts type names from self.choices using convert_type() and uppercases them; otherwise uses _normalized_mapping(ctx).values(). Deduplicates choices with dict.fromkeys(), joins with pipe separator. Wraps result in curly braces for required arguments, square brackets for options/optional arguments."
      },
      "get_invalid_choice_message": {
        "human": "Creates an error message to show users when they enter an invalid option from a list of allowed choices. If there's only one valid choice, it says \"X is not Y.\" If there are multiple choices, it says \"X is not one of A, B, C.\" This helps users understand what went wrong and what options are actually available.",
        "technical": "Generates a localized error message for invalid choice validation. Retrieves normalized choice values via `_normalized_mapping(ctx)`, converts them to comma-separated string using `map(repr, ...)` and `join()`. Uses `ngettext()` for singular/plural message selection based on `len(self.choices)`, then formats the message with the invalid value and choices string. Returns the formatted error string."
      },
      "_try_to_convert_date": {
        "human": "Attempts to convert a text value into a date using a specific date format pattern. If the conversion succeeds, it returns the date; if the text doesn't match the expected format, it safely returns nothing instead of crashing. This is useful when you're not sure if a piece of text is actually a valid date.",
        "technical": "Wraps datetime.strptime() in a try-except block to safely parse string values into datetime objects. Takes a value and format string, attempts conversion via strptime(), and returns the datetime object on success. Catches ValueError exceptions (raised when value doesn't match format) and returns None instead, providing graceful failure handling for date parsing operations."
      },
      "_clamp": {
        "human": "This function is designed to adjust boundary values for numeric ranges, but only when the boundary is \"closed\" (inclusive). If someone tries to use it with an \"open\" boundary (exclusive), it refuses to work and throws an error instead. The developers intentionally left this unsupported because adjusting exclusive boundaries in a meaningful way is complex and should be handled by custom code if needed.",
        "technical": "Takes a boundary value, direction indicator, and open/closed flag. Returns the bound unchanged if `open=False`. Raises `RuntimeError` if `open=True`, explicitly refusing to clamp open bounds. The comment references `math.nextafter` as a potential implementation but deems open bound clamping not useful enough to implement. The `dir` parameter (typed as `Literal[1, -1]`) is unused in the current implementation."
      },
      "_describe_range": {
        "human": "Creates a human-readable text description of a numeric range that shows what values are allowed. For example, it might produce \"x>=5\" for values at least 5, \"x<10\" for values below 10, or \"5<=x<=10\" for values between 5 and 10. The description adjusts based on whether the boundary values themselves are included or excluded from the valid range.",
        "technical": "Generates a string representation of a numeric range by checking three cases: upper-bound only (min is None), lower-bound only (max is None), or bounded range (both exist). Uses boolean flags `min_open` and `max_open` to determine whether to use strict inequality operators (\"<\", \">\") or inclusive operators (\"<=\", \">=\"). Returns formatted strings like \"x<{max}\", \"x>={min}\", or \"{min}<=x<={max}\" depending on the configuration."
      },
      "__repr__": {
        "human": "Creates a text representation of an object that shows what type of object it is and its valid range of values. If the object has clamping enabled (which restricts values to stay within bounds), it adds the word \"clamped\" to the description. This is useful when you want to see a quick summary of the object's settings.",
        "technical": "Implements the `__repr__` special method to return a string representation of the object. Constructs a formatted string containing the class name (via `type(self).__name__`), the range description (from `self._describe_range()` method), and optionally appends \" clamped\" based on the `self.clamp` boolean attribute. Returns a string in the format `<ClassName range_description [clamped]>`."
      },
      "str_to_bool": {
        "human": "Converts text representations of true/false values (like \"yes\", \"no\", \"1\", \"0\") into actual boolean values that the program can use. If you give it something that's already a boolean, it just returns it unchanged. If the text doesn't match any recognized true/false word, it returns nothing (None) to indicate it couldn't understand the input.",
        "technical": "Performs type-safe boolean conversion with early return for existing bool types. For string inputs, applies strip() and lower() transformations to normalize whitespace and casing, then performs dictionary lookup in BoolParamType.bool_states mapping. Returns bool | None, where None indicates unrecognized input strings. No side effects; pure function relying on external bool_states configuration."
      },
      "resolve_lazy_flag": {
        "human": "Determines whether file operations should be performed lazily (delayed) or immediately. If a lazy setting was already specified, it uses that. Otherwise, it decides based on whether the file is standard input/output (the \"-\" symbol) or if the file is being opened for writing. Standard input/output is never lazy, while write operations default to lazy mode.",
        "technical": "Returns boolean indicating lazy evaluation mode. First checks if `self.lazy` is explicitly set and returns that value. Converts `value` to filesystem path using `os.fspath()` and returns `False` if it equals \"-\" (stdin/stdout). Checks if \"w\" is present in `self.mode` string and returns `True` for write modes. Defaults to `False` for all other cases (typically read modes)."
      },
      "coerce_path_result": {
        "human": "Converts file paths between different formats (text strings, raw bytes, or special path objects) based on what format is needed. If the path isn't already in the right format, it transforms it to match the expected type. This ensures file paths work correctly across different systems and encoding requirements.",
        "technical": "Type coercion method that converts path values to match `self.type` specification. Uses `os.fsdecode()` to convert to string, `os.fsencode()` to convert to bytes, or calls custom PathLike constructor for other types. Performs `isinstance()` check to skip conversion if value already matches target type. Returns the coerced value or original if no type specified."
      }
    },
    "src/click/utils.py": {
      "safecall": {
        "human": "This function creates a \"safety wrapper\" around any other function to prevent crashes. When the wrapped function runs into an error, instead of stopping your program with an error message, it quietly catches the problem and returns nothing (None). This is useful when you want a program to keep running even if one part fails, though you won't know what went wrong.",
        "technical": "Decorator that wraps a callable in a try-except block to suppress all exceptions. Returns an inner wrapper function that executes the original function with passed arguments (*args, **kwargs), catches any Exception, and returns None on failure. Uses functools.update_wrapper to preserve the original function's metadata (__name__, __doc__, etc.). Return type annotation indicates R | None to reflect potential None return on exception."
      },
      "make_str": {
        "human": "Converts any type of data into readable text that can be displayed or processed. When dealing with raw binary data (like file contents), it tries to decode it using the computer's default text encoding. If that fails, it falls back to a universal encoding method that replaces unreadable characters with placeholders. For everything else, it simply converts the value to text format.",
        "technical": "Type-checks input for bytes objects and attempts decoding using sys.getfilesystemencoding() first, catching UnicodeError to fallback to UTF-8 with 'replace' error handling. Non-bytes values are converted via str() constructor. Returns a string representation in all cases, prioritizing filesystem encoding for bytes to maintain compatibility with platform-specific file path encodings before defaulting to UTF-8."
      },
      "make_default_short_help": {
        "human": "Takes a long help text and shortens it to fit within a character limit (default 45 characters). It extracts just the first paragraph, removes extra whitespace, and intelligently truncates the text. If the text ends at a natural sentence boundary (with a period), it stops there cleanly; otherwise, it adds \"...\" to show the text was cut off.",
        "technical": "Extracts first paragraph by finding \"\\n\\n\", then splits into words using `split()`. Iterates through words tracking cumulative length, stopping when `max_length` is exceeded. Returns early if sentence ends with period before limit. If truncation needed, removes words from end while accounting for \"...\" suffix length (3 chars), then joins remaining words with spaces and appends \"...\". Handles special \"\\b\" no-rewrap marker by skipping first word."
      },
      "echo": {
        "human": "Prints messages to the screen or a file in a way that works reliably across different operating systems and environments. It handles special cases like colored text, different character encodings, and situations where standard output might not be available (like some Windows applications). It's a safer, more robust alternative to Python's regular print function that ensures your message actually gets displayed correctly.",
        "technical": "Determines output destination (stdout/stderr via `_default_text_stdout()` or `_default_text_stderr()`), converts non-string/bytes messages to strings, and appends newline if requested. For bytes output, locates binary writer via `_find_binary_writer()` and writes directly. For text output, resolves color settings with `resolve_color_default()`, strips ANSI codes via `strip_ansi()` if not terminal or wraps with `auto_wrap_for_ansi()` on Windows, then writes and flushes. Always flushes output stream to ensure immediate display."
      },
      "get_binary_stream": {
        "human": "This function gives you access to one of the three main system streams (stdin, stdout, or stderr) in a format that can handle raw binary data instead of text. It's like requesting a specific communication channel with your computer - you tell it which channel you want (input, output, or error messages), and it opens that channel for you to read or write binary data.",
        "technical": "Retrieves a binary stream opener function from the `binary_streams` dictionary using the provided stream name as key. If the name is invalid (not found in dictionary), raises a TypeError with descriptive message. Otherwise, calls the opener function and returns the resulting `t.BinaryIO` object. Acts as a factory pattern wrapper that validates stream names and delegates actual stream creation to pre-registered opener callables."
      },
      "get_text_stream": {
        "human": "Retrieves one of the three standard input/output streams (stdin, stdout, or stderr) that your program uses to communicate with the user or system. It prepares these streams for reading or writing text (as opposed to raw binary data), allowing you to specify how text should be encoded and how errors should be handled. If you ask for an invalid stream name, it will raise an error.",
        "technical": "Looks up a stream opener function from the `text_streams` dictionary using the provided name ('stdin', 'stdout', or 'stderr'). Raises TypeError if the name is invalid. Calls the retrieved opener function with the specified encoding and error handling parameters, which returns a TextIO object. The opener functions handle wrapping binary streams or returning pre-configured text streams with appropriate encoding settings."
      },
      "open_file": {
        "human": "Opens a file for reading or writing with special conveniences: it treats a dash (\"-\") as a shortcut for standard input/output, can delay actually opening the file until you use it (lazy mode), and can write to a temporary file first then swap it in (atomic mode). The dash feature prevents accidentally closing your terminal's input/output streams when used in standard Python file-handling patterns.",
        "technical": "Returns a file handle by delegating to either LazyFile wrapper (if lazy=True) or open_stream() function. When open_stream() indicates a standard stream (should_close=False), wraps the file object in KeepOpenFile to prevent closure. Uses type casting to satisfy type checker requirements. Supports all standard file modes, encoding, and error handling parameters, passing them through to underlying implementations."
      },
      "format_filename": {
        "human": "Converts any type of filename (including file paths) into a safe, displayable text string that won't cause errors when printed to the screen. It handles filenames with unusual or invalid characters by replacing them with a placeholder symbol (\ufffd). Optionally strips away the directory path to show just the filename itself, making it cleaner for user interfaces.",
        "technical": "Normalizes filename input (str/bytes/PathLike) into a safe UTF-8 string by handling encoding errors. First applies `os.path.basename()` if shortening, otherwise `os.fspath()` to convert PathLike objects. For bytes input, decodes using filesystem encoding with \"replace\" error handling. For string input, performs encode-decode round-trip (utf-8 with surrogateescape then replace) to eliminate surrogate escapes that would fail on strict output streams. Returns sanitized string safe for stdout display."
      },
      "get_app_dir": {
        "human": "Finds the correct folder location where an application should store its configuration files, based on the operating system being used. On Windows, it uses the AppData folder; on Mac, it uses the Application Support folder; and on Linux/Unix, it uses a hidden folder in the user's home directory. The function adapts to each platform's conventions so apps can store settings in the right place.",
        "technical": "Returns platform-specific config directory path by checking WIN flag and sys.platform. On Windows, retrieves APPDATA or LOCALAPPDATA environment variable based on roaming parameter. On macOS (darwin), returns ~/Library/Application Support path unless force_posix is True. On Unix systems, uses XDG_CONFIG_HOME environment variable or defaults to ~/.config. Applies _posixify() transformation to app_name for POSIX paths, joins paths with os.path.join(), and expands user home directory with os.path.expanduser()."
      },
      "_detect_program_name": {
        "human": "Figures out what command the user typed to run the program, so it can be displayed in help messages. If they ran a Python file directly (like \"python app.py\"), it shows just the filename. If they used \"python -m\" to run a module (like \"python -m myapp\"), it shows that full command. This makes help text more accurate and useful.",
        "technical": "Detects program invocation method by examining `__main__.__package__` attribute and `sys.argv[0]`. Returns basename of path if `__package__` is None/empty (direct file execution), with special handling for Windows .exe wrappers. For module execution, reconstructs \"python -m\" command by combining `__package__` with the module name extracted from path via `os.path.splitext()` and `os.path.basename()`, handling submodule cases where filename isn't \"__main__\"."
      },
      "_expand_args": {
        "human": "This function takes a list of command-line arguments and expands special patterns into their actual values, similar to how Unix shells work. It replaces shortcuts like `~` with the user's home directory path, converts environment variable references (like `$HOME`) into their actual values, and expands wildcard patterns (like `*.txt`) into matching filenames. This is primarily needed on Windows where the command prompt doesn't automatically do these expansions.",
        "technical": "Iterates through input arguments, applying optional expansions via `os.path.expanduser()` for tilde expansion and `os.path.expandvars()` for environment variables. Then attempts glob pattern matching using `glob.glob()` with optional recursive support. If glob matching succeeds, extends output with all matches; if it fails (invalid pattern raises `re.error`) or finds no matches, appends the original/expanded argument unchanged. Returns flattened list of all expanded arguments."
      },
      "wrapper": {
        "human": "This function acts as a safety wrapper that protects your program from crashing. When it runs another function, if anything goes wrong or an error occurs, it simply ignores the problem and returns nothing instead of stopping the entire program. It's like a cushion that catches errors silently.",
        "technical": "Error-suppressing decorator wrapper that executes `func` with forwarded arguments (`*args`, `**kwargs`) inside a try-except block. Catches all Exception types, suppresses them without logging or re-raising, and returns None on failure. Uses ParamSpec (P) and TypeVar (R) for type preservation. Returns either the original function's return value (R) or None."
      },
      "__init__": {
        "human": "Sets up a file handler that can work with either regular files or standard input/output (represented by \"-\"). It stores information about how the file should be opened (like reading or writing mode, text encoding) and prepares the file for later use. For regular files in read mode, it quickly checks if the file can be opened to catch errors early.",
        "technical": "Initializes a LazyFile-like object by storing file parameters (name via os.fspath, mode, encoding, errors, atomic flag). For stdin/stdout (\"-\"), immediately opens stream via open_stream() and stores file handle. For regular files, defers opening by setting _f to None, but validates read-mode files by opening and immediately closing them. Sets should_close flag to control cleanup behavior based on stream type."
      },
      "__repr__": {
        "human": "Creates a text representation of a file object that can be displayed to users. If the file is already open, it shows the standard file representation. If the file hasn't been opened yet, it shows a custom message indicating it's an unopened file along with its name and mode (like read or write).",
        "technical": "Returns string representation by checking `self._f` attribute: if not None, delegates to built-in `repr()` of the file object; otherwise constructs formatted string with \"unopened file\" label, filename processed through `format_filename()`, and `self.mode`. Implements `__repr__` dunder method for custom object representation in debugging/logging contexts."
      },
      "open": {
        "human": "Opens a file for reading or writing, but only if it hasn't been opened already. If the file is already open, it simply returns the existing connection. If something goes wrong while trying to open the file (like the file doesn't exist or you don't have permission), it converts the error into a user-friendly format that can be displayed as a helpful message.",
        "technical": "Implements lazy file opening with caching - returns cached file handle `self._f` if already open. Calls `open_stream()` with instance attributes (name, mode, encoding, errors, atomic) and stores both the file handle and a `should_close` flag. Catches `OSError` exceptions and re-raises them as Click's `FileError` with the error message as a hint. Returns the opened file handle and stores it in `self._f` for future calls."
      },
      "close": {
        "human": "This function safely shuts down and releases a file that the program was using. It's like making sure a door is properly closed before leaving - it checks if there's actually a file open first, and only then closes it. This prevents errors that could happen if you tried to close something that wasn't open in the first place.",
        "technical": "Performs safe cleanup of file resource by checking if `self._f` attribute is not None before calling its `close()` method. Uses defensive programming pattern to avoid AttributeError on None object. Executes file handle cleanup as side effect with no return value. The None-check ensures idempotent behavior allowing multiple close() calls without raising exceptions."
      },
      "close_intelligently": {
        "human": "Safely closes a file by first checking whether it should be closed. This prevents accidentally closing important system files like standard input (stdin) that should remain open. Only closes files that were specifically opened by this wrapper, protecting files that were passed in from outside.",
        "technical": "Conditionally invokes self.close() based on the boolean flag self.should_close. Guards against closing file handles that weren't created by the lazy file wrapper instance (e.g., stdin, stdout, stderr). Returns None and produces side effect of closing the underlying file descriptor only when should_close is True."
      },
      "__exit__": {
        "human": "This function allows an object to be used with Python's \"with\" statement (context manager) by defining what happens when exiting the context block. Currently, it does nothing - it's a placeholder that simply allows the exit to complete without any cleanup actions. This is useful when you need the entry behavior of a context manager but don't need any special cleanup when leaving.",
        "technical": "Implements the context manager protocol's `__exit__` method with proper type hints for exception handling parameters (exc_type, exc_value, tb). Contains only a `pass` statement, performing no operations - no resource cleanup, no exception handling, no state changes. Returns None implicitly. This is a no-op implementation that satisfies the context manager interface requirements without side effects."
      },
      "__iter__": {
        "human": "Makes this object work with loops and iteration (like \"for\" loops). When you try to loop through this object, it first ensures the underlying resource is ready to use by opening it, then allows you to go through its contents one item at a time, just like reading lines from a file.",
        "technical": "Implements the iterator protocol by calling `self.open()` to ensure the underlying file/resource is opened, then returns an iterator over `self._f` (likely a file object). Returns `cabc.Iterator[t.AnyStr]` which can yield either strings or bytes. Side effect: opens the resource via `self.open()` if not already open. Delegates actual iteration to the wrapped file object's built-in iterator."
      },
      "flush": {
        "human": "This function forces any buffered data to be written out immediately to its destination (like a file or screen). It includes special error handling so that if the receiving end has closed the connection (a \"broken pipe\"), the program doesn't crash but simply ignores that specific error. Any other errors are still reported normally.",
        "technical": "Wraps the flush() method of self.wrapped object with exception handling for OSError. Catches broken pipe errors (errno.EPIPE) and silently suppresses them, while re-raising all other OSError exceptions. This is a common pattern for handling stdout/stderr flush operations when the pipe consumer has terminated unexpectedly. Returns None and has the side effect of flushing the wrapped stream's buffer."
      }
    }
  },
  "module_summaries": {
    "docs/conf.py": {
      "human": "This module serves as the Sphinx documentation configuration file for a Python project. It sets up the documentation build system by configuring Sphinx settings, theme options, and documentation generation parameters. The module imports the Pallets Sphinx theme to provide consistent styling for the project's documentation website.",
      "technical": "Imports `pallets_sphinx_themes` (imported twice, likely for theme setup and configuration access) to configure Sphinx documentation appearance. Defines Sphinx configuration variables such as project metadata, HTML theme settings, extension lists, and build options. Acts as the entry point for Sphinx documentation generation, controlling how RST/Markdown files are converted to HTML documentation. Standard location at `docs/conf.py` follows Sphinx conventions."
    },
    "examples/aliases/aliases.py": {
      "human": "This module provides a command-line interface with support for command aliases and shortcuts. It allows users to create short nicknames for longer commands (like \"st\" for \"status\") and saves these shortcuts to a configuration file for reuse. The module also implements smart command matching, so users can type partial command names and the system will figure out what they meant. It includes placeholder commands for common version control operations like push, pull, clone, and commit, demonstrating how to build an extensible CLI tool.",
      "technical": "Implements two main classes: `Config` manages alias storage/retrieval via configparser and tracks working directory state, while `AliasedGroup` extends click.Group to provide enhanced command resolution with alias support and prefix matching. The Config class handles INI-file persistence of alias mappings through read_config/write_config methods. AliasedGroup overrides get_command() with three-tier resolution (direct lookup, alias dictionary, prefix matching) and resolve_command() to normalize command names. Uses Click decorators (@cli.command, @pass_config) to build the CLI structure. Provides an extensible framework for building Git-like CLI tools with user-customizable command shortcuts."
    },
    "examples/colors/colors.py": {
      "human": "This module is a demonstration tool that showcases the various text styling and coloring capabilities available in terminal applications. It serves as a visual reference or example program that displays text in different colors, with different effects like bold, reverse video, blinking, and underlining. Users can run this program to see what styling options are available for their own terminal-based applications, making it easier to choose appropriate visual formatting for their projects.",
      "technical": "Implements a single CLI entry point using the Click framework's command decorator pattern. The module serves as an example/demo program with no reusable classes or APIs\u2014it's a standalone script that exercises Click's `click.style()` and `click.echo()` functions to demonstrate ANSI terminal formatting capabilities. Iterates through a color collection (likely defined elsewhere or in Click) to systematically display foreground colors, bold combinations, and reverse video effects, followed by special attribute demonstrations. Depends solely on the Click library for both CLI scaffolding and terminal styling functionality."
    },
    "examples/completion/completion.py": {
      "human": "This module demonstrates how to add intelligent autocomplete functionality to command-line programs. It shows two practical examples: helping users find environment variables on their computer by suggesting matching names as they type, and providing username suggestions from a list of people with their job titles. This makes command-line tools easier to use by reducing typing and helping users discover available options without memorizing exact names or values.",
      "technical": "Implements Click CLI completion examples demonstrating the shell_completion API. Provides two command functions (show_env, list_users) with custom completion callbacks (get_env_vars, list_users) that return CompletionItem objects for shell autocompletion. Uses os.environ for dynamic system environment variable completion and hardcoded data structures for static user completion. Demonstrates substring matching patterns for filtering completion suggestions based on partial user input. Serves as reference implementation for integrating Click's autocompletion features into CLI applications."
    },
    "examples/complex/complex/__init__.py": {
      "human": "This is an empty or placeholder module file.",
      "technical": "Module 'examples/complex/complex/__init__.py' contains no significant code (empty file or single comment/blank line)."
    },
    "examples/complex/complex/cli.py": {
      "human": "This module provides the foundation for a command-line application with a plugin-style architecture where commands can be dynamically loaded. It manages application settings like verbose output and working directory, provides logging utilities that respect user preferences, and automatically discovers command modules from a commands folder. The system allows users to run different commands without loading everything upfront, making the application faster to start and easier to extend with new commands.",
      "technical": "Implements two core classes: Environment (manages application state with verbose flag and home directory) and ComplexCLI (MultiCommand subclass enabling dynamic command discovery). Uses Click framework for CLI construction with context passing via pass_environment decorator. Provides lazy-loading command architecture through get_command() using dynamic imports from complex.commands.cmd_* pattern, and filesystem-based command discovery via list_commands(). Exposes logging API (log/vlog methods) with conditional verbosity control. Serves as entry point and plugin loader for modular CLI application structure."
    },
    "examples/complex/complex/commands/__init__.py": {
      "human": "This is an empty or placeholder module file.",
      "technical": "Module 'examples/complex/complex/commands/__init__.py' contains no significant code (empty file or single comment/blank line)."
    },
    "examples/complex/complex/commands/cmd_init.py": {
      "human": "This module provides a command-line tool for initializing new repositories. When a user wants to create a new repository, they can run this command and optionally specify where they want it created. If they don't specify a location, the system uses a sensible default location. After creating the repository, it confirms the action by showing the user exactly where the repository was set up. This is typically the first command someone would run when starting a new project.",
      "technical": "Implements a Click CLI command module that registers an `init` command for repository initialization. Exposes a single command function decorated with `@click.command()` and `@click.argument()` that accepts an optional path parameter. Integrates with the parent CLI context object to access configuration (ctx.home) and logging facilities (ctx.log()). Uses Click's `format_filename()` utility for cross-platform path display. Follows Click's command pattern where the function is registered to the CLI group via the `@complex.cli.command()` decorator, making it discoverable as a subcommand in the larger CLI application."
    },
    "examples/complex/complex/commands/cmd_status.py": {
      "human": "This module provides a status command for a command-line application that is meant to check and report file changes in the current directory. Think of it like a simplified version of \"git status\" that tells you what files have been modified. Currently, it's just a placeholder that always says \"no changes found\" - the actual file-checking functionality hasn't been implemented yet. It's part of a larger CLI tool being built with a modular command structure.",
      "technical": "Implements a single Click command function decorated with `@cli.command()` and `@pass_environment` that integrates into the complex.cli command framework. The `cli()` function receives an injected context object and uses its logging interface (`ctx.log()` and `ctx.vlog()`) to output status messages. Currently a stub implementation with hardcoded output rather than actual file system inspection logic. Designed as a pluggable command module following Click's command pattern, where commands are discovered and registered automatically into the parent CLI application."
    },
    "examples/imagepipe/imagepipe.py": {
      "human": "This module provides a command-line tool for processing images through a pipeline of operations. Users can chain together multiple image manipulation commands (like opening, resizing, cropping, blurring, rotating, and saving) where each operation feeds its output to the next, similar to Unix pipes. It's designed to make batch image processing easy by allowing users to apply multiple transformations to one or more images in a single command. The tool handles errors gracefully, continuing to process remaining images even if individual operations fail.",
      "technical": "Implements a Click-based CLI application using a command group pattern with chained processors. Core architecture uses decorator functions (`@processor` and `@generator`) to transform regular functions into stream processors that yield image objects through a pipeline. The `process_commands` callback chains processor functions together using function composition, consuming the lazy iterator to trigger side effects. Depends on PIL/Pillow for image manipulation operations and Click for CLI framework. All commands are generators that yield PIL Image objects, enabling memory-efficient processing of multiple images through transformation pipelines without loading all images simultaneously."
    },
    "examples/inout/inout.py": {
      "human": "This module provides a simple file copying utility that works like the Unix `cat` command. It allows users to copy content from one or multiple files into a single output file, or display file contents on the screen. Users can also type input from their keyboard and save it to a file. The dash symbol \"-\" acts as a special marker for keyboard input or screen output, making it flexible for different file operations from the command line.",
      "technical": "Implements a single-function Click-based CLI application that performs streaming file I/O operations. Uses Click's File type for automatic file handle management with support for stdin/stdout via \"-\" notation. Employs chunk-based reading (1024-byte buffer) to handle large files efficiently without loading entire contents into memory. The module serves as a demonstration example of Click's file handling capabilities, showing how to build Unix-style utilities with multiple input sources and single output destination. No classes or complex architecture\u2014purely procedural file streaming with immediate output flushing."
    },
    "examples/naval/naval.py": {
      "human": "This module implements a command-line interface for a naval simulation or game called \"Naval Fate.\" It allows users to manage ships and mines through text commands typed in a terminal. Users can create new ships, move them to different coordinates, make them shoot at targets, and place or remove mines at specific locations on a grid. The tool provides immediate feedback by displaying confirmation messages for each action performed, making it easy to interact with the naval simulation through simple commands.",
      "technical": "Implements a Click-based CLI application with a hierarchical command structure using `@click.group()` decorators. Provides two command groups: 'ship' (with new, move, shoot subcommands) and 'mine' (with set, remove subcommands). All functions are presentation-layer stubs that accept user input via Click decorators (`@click.argument`, `@click.option`) and output confirmation messages using `click.echo()` without actual business logic or state management. The module serves as a CLI skeleton/demo showcasing Click's command grouping capabilities, with no data persistence, validation, or actual game mechanics implemented. Entry point is the `cli()` function which routes to subcommands based on user input."
    },
    "examples/repo/repo.py": {
      "human": "This module provides a command-line interface that mimics a version control system like Git. It allows users to perform repository operations such as cloning repositories, committing changes with messages, managing user credentials, copying files, and deleting repositories. The tool is designed to help users interact with code repositories through simple commands in the terminal, though the current implementation appears to be a demonstration or mock version that primarily displays what actions would be taken rather than performing actual file operations.",
      "technical": "Implements a Click-based CLI application with a `Repo` class that maintains repository state (home path, config dictionary, verbose flag). The module exposes nine commands through Click decorators (@cli.command) with a context-passing pattern using @pass_repo to share the Repo instance across commands. Uses Click's group/command hierarchy with ctx.obj for state management, confirmation_option for destructive operations, and click.echo() for output. The Repo class provides a simple key-value configuration system via set_config(). Currently appears to be a stub/mock implementation as most commands only print intentions without executing actual repository operations."
    },
    "examples/termui/termui.py": {
      "human": "This module is a demonstration showcase for Click's terminal user interface capabilities. It provides a collection of interactive examples that show developers how to build command-line applications with features like colored text, progress bars, paginated output, file editing, and interactive menus. Each command demonstrates a different terminal UI feature in action, serving as both a learning tool and a testing ground for verifying that terminal features work correctly in different environments. It's essentially a \"gallery\" of terminal UI possibilities that developers can reference when building their own CLI applications.",
      "technical": "Implements a Click command group structure with 13 subcommands demonstrating various Click terminal UI features. Uses `@click.group()` as the root CLI entry point with individual commands registered via `@cli.command()` decorators. Demonstrates Click's core terminal APIs including `click.style()` for ANSI coloring, `click.echo_via_pager()` for scrollable output, `click.progressbar()` for progress tracking, `click.launch()` for system integration, `click.edit()` for text editing, `click.clear()` for screen management, `click.pause()` for input blocking, and `click.getchar()` for character-level input. Serves as both documentation and integration testing for Click's termui module, with no production functionality or external system dependencies beyond the Click framework itself."
    },
    "examples/validation/validation.py": {
      "human": "This module demonstrates how to validate user input in command-line applications. It shows three different validation techniques: checking that numbers meet specific criteria (like being positive and even), ensuring text values match expected strings, and verifying that web addresses use safe protocols. It's an educational example that teaches developers how to prevent users from entering invalid data that could cause problems in their programs.",
      "technical": "Implements a Click-based CLI validation example showcasing three validation patterns: callback validators (validate_count function), inline validation (foo parameter check), and custom parameter types (URL class). The URL class extends click.ParamType and overrides convert() method to parse and validate URL schemes using urllib.parse.urlparse(). Demonstrates Click's parameter validation framework integration points including ctx/param/value callback signatures, BadParameter exception handling, and self.fail() error reporting. Serves as reference implementation for Click validation best practices."
    },
    "src/click/__init__.py": {
      "human": "This module serves as the main entry point for the Click library, a Python package for building command-line interfaces. It acts as a compatibility layer that helps users transition from older versions of Click to newer ones. When developers use outdated feature names from previous Click versions, this module shows them helpful warnings about what they should use instead, while still allowing their old code to work. It also provides access to the library's version number when requested.",
      "technical": "Implements module-level `__getattr__` to provide backward compatibility for deprecated Click API names. Intercepts attribute access for legacy class names (\"BaseCommand\", \"MultiCommand\", \"OptionParser\") and maps them to internal underscore-prefixed implementations while emitting DeprecationWarning with appropriate stack levels. Handles `__version__` attribute by delegating to `importlib.metadata.version()`. Serves as the public API facade for the Click library, importing core functionality from `core` and `decorators` submodules. Raises AttributeError for undefined attributes, maintaining standard Python attribute access semantics."
    },
    "src/click/_compat.py": {
      "human": "This module provides cross-platform compatibility for terminal input/output operations in the Click library. It handles the complexities of text encoding, stream wrapping, and platform-specific quirks (especially Windows vs. Unix differences) to ensure consistent behavior when reading from stdin and writing to stdout/stderr. The module detects terminal capabilities, manages proper encoding/decoding of text, supports ANSI color codes on Windows, and provides safe atomic file writing. It essentially abstracts away all the messy details of terminal I/O so Click can work reliably across different operating systems, Python versions, and terminal environments.",
      "technical": "The module implements a compatibility layer with three main classes: `_NonClosingTextIOWrapper` (prevents accidental stream closure), `_FixupStream` (corrects encoding issues in text streams), and `_AtomicFile` (provides atomic file writes via temporary files). It exports approximately 49 functions organized around stream detection/wrapping (`get_text_stream`, `get_binary_stream`), encoding resolution (`get_best_encoding`, `_get_windows_console_stream`), and platform-specific terminal handling. Key dependencies include `io`, `codecs`, and `sys` for stream manipulation, with special Windows support via optional `colorama` and `ctypes`. The design uses wrapper classes and factory functions to normalize stream behavior, handle BOM markers, and manage resource cleanup through weak references."
    },
    "src/click/_termui_impl.py": {
      "human": "This module provides terminal user interface utilities for the Click command-line framework. It handles displaying long text output through pagers (like 'less' or 'more'), showing progress bars for long-running operations, opening files or URLs in external applications, and capturing raw keyboard input. It solves the problem of making command-line programs interactive and user-friendly by managing terminal display, handling cross-platform differences (Windows/Mac/Linux), and providing visual feedback during operations like file processing or downloads.",
      "technical": "Implements two main classes: ProgressBar (context manager for tracking and displaying operation progress with configurable rendering, ETA calculation, and throttled updates) and Editor (wrapper for launching external text editors with temporary file management). Provides cross-platform terminal I/O functions including pager() with fallback chain (_pipepager \u2192 _tempfilepager \u2192 _nullpager), open_url() with OS-specific command dispatching, and getchar()/raw_terminal() for low-level keyboard input using termios/tty. Depends on subprocess for external process management, tempfile for temporary file handling, and platform-specific modules (msvcrt on Windows, termios/tty on Unix). Integrates with Click's echo system and ANSI color handling."
    },
    "src/click/_textwrap.py": {
      "human": "This module provides enhanced text wrapping and indentation capabilities for the Click command-line interface library. It extends Python's standard text wrapping functionality to handle special formatting needs like nested indentation (for subcommands or help text), hanging indents (where first lines stick out), and proper handling of long words that don't fit on a single line. It's used to make command-line help text and output look clean and properly formatted, especially when dealing with complex nested structures or varying terminal widths.",
      "technical": "Extends Python's standard `textwrap.TextWrapper` class with Click-specific text formatting capabilities. Provides `TextWrapper` class that overrides `_handle_long_word()` for custom word-breaking behavior and adds two key methods: `extra_indent()` context manager for temporarily augmenting indentation levels, and `indent_only()` for applying dual-indent patterns (initial vs. subsequent lines) without wrapping. Depends on `textwrap` module for base functionality and `contextlib` for context manager implementation. Serves as Click's text formatting layer, enabling proper rendering of help text, command descriptions, and nested option documentation in terminal output."
    },
    "src/click/_utils.py": {
      "human": "This module provides internal utility components for the Click library, which is used for building command-line interfaces. It contains helper classes and functions that support the core Click functionality but aren't meant to be used directly by end users. The main purpose is to provide a special sentinel value class that can be used throughout Click's codebase to represent unique placeholder values that are distinct from None or other typical Python values.",
      "technical": "Implements the Sentinel class as a utility type for creating unique singleton marker objects used internally by Click. The module has minimal dependencies (only standard library imports: __future__, enum, typing), indicating it's a foundational utility layer. The Sentinel pattern allows Click to distinguish between \"no value provided\" versus \"None was explicitly provided\" in function arguments and configuration. Serves as a low-level infrastructure module that other Click components depend on for type-safe placeholder values."
    },
    "src/click/_winconsole.py": {
      "human": "This module solves text display problems when Python programs run in Windows command prompts and terminals. Windows consoles handle text differently than other systems, using a special encoding (UTF-16) that can cause international characters and emojis to display incorrectly. The module creates special input/output streams that properly translate between Python's text handling and Windows console requirements, ensuring that text appears correctly when reading from keyboard input or writing to the screen in Windows terminals.",
      "technical": "Implements Windows-specific console I/O handling through three custom stream classes: `_WindowsConsoleReader`, `_WindowsConsoleWriter`, and `ConsoleStream`. Uses ctypes to interface with Windows Console API (ReadConsoleW, WriteConsoleW, GetConsoleMode) for UTF-16-LE encoded I/O operations. Provides factory functions (`_get_text_stdin/stdout/stderr`) that wrap native console handles in buffered streams with proper encoding. The `_WindowsConsoleRawIOBase` class implements Python's RawIOBase interface while delegating to Windows API calls. Includes buffer protocol support via `get_buffer()` for zero-copy memory access and console detection via `_is_console()` for conditional stream replacement."
    },
    "src/click/core.py": {
      "human": "This module is the core engine of the Click library, a Python framework for building command-line applications. It provides the fundamental building blocks for creating CLI tools with commands, subcommands, options, and arguments. The module handles everything from parsing what users type on the command line, to validating their input, to displaying helpful error messages and documentation. It manages the execution context as commands run, supports nested command structures (like git's subcommands), and enables features like auto-completion, environment variable integration, and interactive prompts. Essentially, it's the complete infrastructure that transforms Python functions into professional command-line interfaces.",
      "technical": "This module implements Click's core CLI framework through several key classes: `Context` (manages execution state and parameter resolution), `Command` (represents executable CLI commands), `Group` (hierarchical command containers), `Parameter`/`Option`/`Argument` (input parameter definitions), and `ParameterSource` (enum tracking parameter origins). The architecture uses a visitor pattern for command traversal, context managers for resource cleanup, and a chain-of-responsibility pattern for parameter resolution across contexts. It integrates with Python's type system for validation, supports shell completion protocols, and provides extensive customization through callbacks and hooks. The module depends on standard library components (inspect, enum, typing) and implements 139 functions across parameter parsing, command invocation, help generation, and error handling subsystems."
    },
    "src/click/decorators.py": {
      "human": "This module provides decorators that make it easy to build command-line applications with Click. It offers tools to automatically pass context information to functions, define command-line options and arguments (like `--verbose` or filenames), and create commands and command groups. It includes ready-made decorators for common patterns like password prompts, version displays, and confirmation dialogs. Essentially, it's a toolkit that lets developers quickly add professional command-line interfaces to their Python programs without writing repetitive boilerplate code.",
      "technical": "Implements Click's decorator-based API for building CLI applications. Core decorators include `@command` and `@group` which transform functions into Command/Group instances, and `@option`/`@argument` which attach Parameter objects via `_param_memo()`. Context injection decorators (`pass_context`, `pass_obj`, `make_pass_decorator`) automatically provide Context or custom objects to callbacks. Provides specialized option factories (`confirmation_option`, `password_option`, `version_option`, `help_option`) with pre-configured callbacks. Uses decorator stacking pattern where parameters accumulate in `__click_params__` attribute before Command instantiation. Integrates with core.py classes (Command, Group, Option, Argument, Context) and uses `functools.update_wrapper` for metadata preservation."
    },
    "src/click/exceptions.py": {
      "human": "This module defines all the error types that Click (a command-line interface library) uses to communicate problems to users. When something goes wrong\u2014like a missing required option, an invalid parameter value, or a file that can't be opened\u2014these error classes create helpful, user-friendly messages. The module ensures errors are displayed consistently, with proper formatting and suggestions for getting help (like \"try --help\"). It handles internationalization so error messages can be translated into different languages for users worldwide.",
      "technical": "Implements a hierarchy of exception classes extending from base `ClickException` for CLI error handling. Core classes include `UsageError` (base for parameter errors), `BadParameter`, `MissingParameter`, `NoSuchOption`, `FileError`, and control-flow exceptions (`Abort`, `Exit`). Provides `show()` method for formatted error output to stderr with context-aware help hints, and `format_message()` for localized error strings via gettext. Integrates with Click's context system to access command metadata and uses utility functions from `utils` module for terminal output formatting. Exceptions store parameter references and hints for detailed error reporting."
    },
    "src/click/formatting.py": {
      "human": "This module provides text formatting tools specifically designed for creating command-line help messages and documentation. It handles the tricky work of making text look good in terminal windows of different sizes - wrapping long lines, aligning columns in tables, managing indentation for nested sections, and formatting usage instructions. Think of it as a specialized word processor for command-line interfaces that ensures help text is always readable and properly formatted, whether you're showing command options, descriptions, or multi-level documentation structures.",
      "technical": "Implements the HelpFormatter class as the primary API for building formatted terminal output with buffered writing and automatic text wrapping. Provides context managers (section(), indentation()) for managing hierarchical indentation state, specialized writers for CLI components (write_usage(), write_heading(), write_dl() for definition lists), and utility functions (measure_table(), wrap_text(), join_options()) for text layout calculations. Depends on shutil for terminal size detection, custom _textwrap module for width-aware wrapping, and term_len() for accurate character width measurement. Follows a builder pattern with buffered accumulation via write() and final retrieval through getvalue()."
    },
    "src/click/globals.py": {
      "human": "This module manages the global state for Click command-line applications by keeping track of which command context is currently active. It solves the problem of needing to access command information (like settings and parameters) from anywhere in your program without manually passing that information through every function call. Think of it as a shared notebook that any part of your application can read to understand what command is currently running and what settings are in effect.",
      "technical": "Implements thread-local context stack management using Python's threading.local() for Click's Context objects. Provides three core stack operations (push_context, pop_context, get_current_context) that maintain a LIFO stack of active contexts in `_local.stack`, ensuring thread-safety for concurrent command execution. Exposes get_current_context() as the primary API for retrieving the active Context from anywhere in the call stack, with optional silent failure mode. Includes resolve_color_default() utility for cascading color preference resolution. Serves as Click's global state management layer, enabling implicit context access without explicit parameter passing through the call chain."
    },
    "src/click/parser.py": {
      "human": "This module is the command-line argument parser for the Click library, responsible for understanding what users type when running command-line programs. It reads through arguments like `--verbose`, `-o file.txt`, or positional values, figures out which are options (settings) and which are regular arguments, and organizes them into a usable format. It handles complex scenarios like options with multiple values, short option combinations (like `-abc`), and provides helpful error messages when users make typos or use invalid options.",
      "technical": "Implements a custom argument parser through four core classes: `_OptionParser` (main parser orchestrating the process), `_Option` (represents flag/option definitions with actions like store/append/count), `_Argument` (represents positional arguments), and `_ParsingState` (tracks parsing progress with opts dict, largs/rargs deques, and order list). Provides `parse_args()` as primary API returning (opts_dict, leftover_args, order_list) tuple. Uses two-phase parsing: `_process_args_for_options()` extracts options, then `_process_args_for_args()` distributes positional arguments via `_unpack_args()`. Supports option normalization through context, interspersed arguments, and resilient parsing modes. Integrates with Click's Context system for configuration inheritance."
    },
    "src/click/shell_completion.py": {
      "human": "This module enables tab-completion functionality for command-line applications built with Click. When users press Tab while typing commands in their terminal, this module figures out what shell they're using (Bash, Zsh, or Fish), generates appropriate completion suggestions based on what they've typed, and provides the setup scripts needed to enable completions. It handles the complex logic of understanding partial commands, determining whether users are completing option names, values, or subcommands, and formatting suggestions in shell-specific formats.",
      "technical": "Implements shell-agnostic completion through abstract `ShellComplete` base class with concrete implementations (`BashComplete`, `ZshComplete`, `FishComplete`) registered in `_available_shells` dictionary. Primary API is `shell_complete()` function which dispatches to appropriate shell handler based on environment variables. Core workflow: `_resolve_context()` builds Click context hierarchy from partial input, `_resolve_incomplete()` identifies target parameter/command for completion, and `get_completions()` delegates to Click objects' `shell_complete()` methods. Uses `CompletionItem` as completion data structure. Integrates with Click's command/parameter system through context resolution and resilient parsing."
    },
    "src/click/termui.py": {
      "human": "This module provides all the interactive terminal user interface functionality for the Click command-line framework. It handles common terminal operations like prompting users for input (including hidden password entry), displaying yes/no confirmations, showing progress bars for long operations, styling text with colors and formatting, and managing text editors. It makes it easy for developers to create professional, user-friendly command-line applications with features like paginated output, terminal clearing, and file launching, while handling the complexity of different operating systems and terminal types.",
      "technical": "Provides high-level terminal UI abstractions as a facade over platform-specific implementations in `_termui_impl`. Core APIs include `prompt()` for validated input collection, `echo_via_pager()` for paginated output, `progressbar()` factory returning ProgressBar context managers, and `style()`/`secho()` for ANSI escape sequence formatting. Implements input handling through `prompt_func()` and `getchar()` with platform-specific delegation, editor integration via `Editor` class wrapper, and terminal control through `clear()` and `raw_terminal()` context manager. Depends on `_compat` for cross-platform compatibility and integrates with Click's exception system via `Abort` and `UsageError`."
    },
    "src/click/testing.py": {
      "human": "This module provides testing utilities for command-line applications built with the Click framework. It allows developers to test their CLI programs without requiring actual user interaction or affecting the real system. The module simulates user input, captures program output (both regular and error messages), and runs commands in isolated environments. It's like a testing sandbox where you can automatically \"type\" commands, check what gets printed, and verify if programs work correctly - all without touching real files or requiring manual testing.",
      "technical": "Implements `CliRunner` as the primary testing interface, providing `invoke()` to execute Click commands and `isolated_filesystem()` for temporary directory contexts. Uses `Result` class to encapsulate execution outcomes (stdout, stderr, exit codes, exceptions). Employs stream manipulation classes (`EchoingStdin`, `BytesIOCopy`, `StreamMixer`) to capture and separate output streams while optionally echoing input. The `isolation()` context manager mocks `sys.stdin/stdout/stderr` and patches Click's internal prompt functions. Integrates with Click's command execution pipeline by intercepting `cli.main()` calls and managing exception handling through the `catch_exceptions` flag."
    },
    "src/click/types.py": {
      "human": "This module provides the type system for Click, a command-line interface framework. It defines how different kinds of user input (text, numbers, file paths, dates, choices from a list, etc.) should be validated and converted into Python objects. When users type commands with arguments and options, this module ensures the input matches expected formats, provides helpful error messages when something is wrong, and even helps with auto-completion suggestions. It's the foundation that makes Click understand and validate all the different types of data users can provide on the command line.",
      "technical": "Implements Click's parameter type hierarchy with ParamType as the abstract base class. Provides concrete implementations for common types: StringParamType, IntParamType/IntRange, FloatParamType/FloatRange, BoolParamType, Choice, DateTime, File, Path, Tuple, and UUIDParameterType. Each type implements convert() for value transformation, fail() for error handling, and shell_complete() for tab-completion. The convert_type() function maps Python type annotations to Click types. Uses composition pattern (CompositeParamType, Tuple) for complex types and wrapper pattern (FuncParamType) for custom callables. Integrates with Click's Context and Parameter objects for validation and provides internationalization support via gettext."
    },
    "src/click/utils.py": {
      "human": "This module provides utility functions that make Click's command-line interface work reliably across different operating systems and environments. It handles common challenges like safely printing text with special characters, opening files that might be standard input/output, converting filenames for display, and finding the right folders to store application settings. The module acts as a compatibility layer that smooths over differences between Windows, Mac, and Linux, ensuring commands work consistently everywhere and don't crash when encountering unusual situations like broken pipes or encoding errors.",
      "technical": "Implements three wrapper classes (LazyFile, KeepOpenFile, PacifyFlushWrapper) that provide lazy file opening, prevent premature closure of stdin/stdout/stderr, and suppress broken pipe errors. Core APIs include echo() for cross-platform output with ANSI color support, open_file() for unified file/stream handling with atomic write support, get_binary_stream()/get_text_stream() for stream access, and get_app_dir() for platform-specific config directory resolution. Uses decorator patterns (safecall), factory patterns (stream getters), and context managers for resource management. Depends on _compat module for platform abstraction and integrates with Click's broader terminal handling infrastructure."
    }
  },
  "repo_summary": {
    "human": "Click is a Python library that makes it easy to create professional command-line applications. It helps developers build programs that users interact with through terminal commands, handling everything from parsing what users type, to validating their input, to displaying helpful error messages and documentation. The library provides ready-made tools for common CLI features like options, arguments, subcommands, progress bars, colored text, password prompts, and auto-completion. It's designed for Python developers who want to quickly build user-friendly command-line tools without writing repetitive code for input handling and help text generation. Click handles cross-platform differences (Windows, Mac, Linux) automatically, ensuring CLI applications work consistently everywhere.",
    "technical": "Implements a decorator-based CLI framework with hierarchical command architecture built around Context (execution state management), Command/Group (command hierarchy), and Parameter/Option/Argument (input specification) classes. Core system flow: decorators in `decorators.py` transform functions into Command objects, `parser.py` tokenizes command-line input, `core.py` orchestrates parameter resolution and command invocation through context chains, and `types.py` provides type conversion/validation. Terminal UI layer (`termui.py`, `_termui_impl.py`) abstracts platform-specific I/O operations with compatibility shims in `_compat.py` and `_winconsole.py` for Windows console handling. Supports shell completion via `shell_completion.py` with shell-specific adapters, testing through `testing.py` with stream mocking, and extensive formatting via `formatting.py` for help text generation. Uses thread-local context stacks for implicit state management and implements visitor pattern for command traversal."
  },
  "dead_code_analysis": {
    "unreferenced_functions": [
      {
        "name": "push",
        "module": "examples/aliases/aliases.py",
        "lineno": 102,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, which registers it as a Click CLI command. Click automatically calls this function when users run the corresponding command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click framework",
            "Click commands are invoked by the framework based on user input, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, which registers it as a Click CLI command. Click automatically calls this function when users run the corresponding command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "pull",
        "module": "examples/aliases/aliases.py",
        "lineno": 108,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, which registers it as a Click CLI command. Click automatically calls this function when users run the corresponding command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click framework",
            "Click commands are invoked by the framework based on user input, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, which registers it as a Click CLI command. Click automatically calls this function when users run the corresponding command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "clone",
        "module": "examples/aliases/aliases.py",
        "lineno": 114,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, which registers it as a Click CLI command. Click automatically calls this function when users run the corresponding command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click framework",
            "Click commands are invoked by the framework based on user input, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, which registers it as a Click CLI command. Click automatically calls this function when users run the corresponding command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "commit",
        "module": "examples/aliases/aliases.py",
        "lineno": 120,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, which registers it as a Click CLI command. Click automatically calls this function when users run the corresponding command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click framework",
            "Click commands are invoked by the framework based on user input, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, which registers it as a Click CLI command. Click automatically calls this function when users run the corresponding command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "status",
        "module": "examples/aliases/aliases.py",
        "lineno": 127,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with both @cli.command and @pass_config, which registers it as a Click CLI command with configuration injection. Click automatically calls this function when users run the status command.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click framework",
            "Additional @pass_config decorator shows it's part of Click's dependency injection system"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with both @cli.command and @pass_config, which registers it as a Click CLI command with configuration injection. Click automatically calls this function when users run the status command.",
        "recommendation": "keep"
      },
      {
        "name": "alias",
        "module": "examples/aliases/aliases.py",
        "lineno": 139,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, making it a Click CLI command that is invoked when users run the command from the command line. CLI commands are not called directly in code but through the Click framework.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command indicating it's a CLI command entry point",
            "Has click.argument and click.option decorators showing it's part of CLI interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, making it a Click CLI command that is invoked when users run the command from the command line. CLI commands are not called directly in code but through the Click framework.",
        "recommendation": "keep"
      },
      {
        "name": "ls",
        "module": "examples/completion/completion.py",
        "lineno": 14,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, making it a Click CLI command that users invoke from the command line. CLI commands are callbacks executed by the Click framework, not called directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command making it a CLI command entry point",
            "Has click.option decorator indicating it's part of CLI interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, making it a Click CLI command that users invoke from the command line. CLI commands are callbacks executed by the Click framework, not called directly in application code.",
        "recommendation": "keep"
      },
      {
        "name": "show_env",
        "module": "examples/completion/completion.py",
        "lineno": 26,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, making it a Click CLI command that is invoked when users run the command from the command line. CLI commands are framework callbacks, not directly called functions.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command indicating it's a CLI command entry point",
            "Has click.argument decorator showing it's part of CLI interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, making it a Click CLI command that is invoked when users run the command from the command line. CLI commands are framework callbacks, not directly called functions.",
        "recommendation": "keep"
      },
      {
        "name": "select_user",
        "module": "examples/completion/completion.py",
        "lineno": 52,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @group.command, making it a Click CLI subcommand that users invoke from the command line. CLI commands are executed by the Click framework as callbacks, not called directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @group.command making it a CLI subcommand entry point",
            "Has click.argument decorator indicating it's part of CLI interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @group.command, making it a Click CLI subcommand that users invoke from the command line. CLI commands are executed by the Click framework as callbacks, not called directly in code.",
        "recommendation": "keep"
      },
      {
        "name": "process_commands",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 24,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.result_callback, making it a Click result callback that is automatically invoked by the Click framework after command execution. Result callbacks are framework hooks, not directly called functions.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.result_callback making it a Click framework hook",
            "Docstring explicitly states it's a result callback invoked with chained subcommands"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.result_callback, making it a Click result callback that is automatically invoked by the Click framework after command execution. Result callbacks are framework hooks, not directly called functions.",
        "recommendation": "keep"
      },
      {
        "name": "open_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 84,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Has @cli.command decorator indicating it's a CLI command entry point",
            "Located in examples/imagepipe which suggests it's a CLI tool for image processing"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
        "recommendation": "keep"
      },
      {
        "name": "save_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 110,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Has @cli.command decorator indicating it's a CLI command entry point",
            "Also has @processor decorator suggesting it's part of an image processing pipeline"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
        "recommendation": "keep"
      },
      {
        "name": "display_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 123,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Has @cli.command decorator indicating it's a CLI command entry point",
            "Also has @processor decorator suggesting it's part of an image processing pipeline"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
        "recommendation": "keep"
      },
      {
        "name": "resize_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 135,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Has @cli.command decorator indicating it's a CLI command entry point",
            "Also has @processor decorator and multiple @click.option decorators for CLI arguments"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
        "recommendation": "keep"
      },
      {
        "name": "crop_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 151,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Has @cli.command decorator indicating it's a CLI command entry point",
            "Also has @processor decorator and @click.option decorator for CLI arguments"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a Click CLI command. CLI commands are invoked externally by users from the command line, not called internally by the codebase.",
        "recommendation": "keep"
      },
      {
        "name": "transpose_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 195,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click CLI framework",
            "Function has @processor decorator indicating it's part of the image processing pipeline",
            "Click commands are invoked externally by users, not called internally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
        "recommendation": "keep"
      },
      {
        "name": "blur_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 212,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click CLI framework",
            "Function has @processor decorator indicating it's part of the image processing pipeline",
            "Click commands are invoked externally by users, not called internally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
        "recommendation": "keep"
      },
      {
        "name": "smoothen_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 229,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click CLI framework",
            "Function has @processor decorator indicating it's part of the image processing pipeline",
            "Click commands are invoked externally by users, not called internally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
        "recommendation": "keep"
      },
      {
        "name": "emboss_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 243,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click CLI framework",
            "Function has @processor decorator indicating it's part of the image processing pipeline",
            "Click commands are invoked externally by users, not called internally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
        "recommendation": "keep"
      },
      {
        "name": "sharpen_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 255,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator which registers it with Click CLI framework",
            "Function has @processor decorator indicating it's part of the image processing pipeline",
            "Click commands are invoked externally by users, not called internally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command which registers it as a CLI command with Click framework. CLI commands are invoked by the framework when users run the command, not called directly in code.",
        "recommendation": "keep"
      },
      {
        "name": "paste_cmd",
        "module": "examples/imagepipe/imagepipe.py",
        "lineno": 267,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI command function decorated with @cli.command and @processor. Click framework automatically discovers and calls these decorated functions when the corresponding command is invoked from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.command decorator making it a CLI command",
            "Function has @processor decorator indicating it's part of the image processing pipeline",
            "Located in examples/imagepipe/ suggesting it's a CLI tool example"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI command function decorated with @cli.command and @processor. Click framework automatically discovers and calls these decorated functions when the corresponding command is invoked from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "ship",
        "module": "examples/naval/naval.py",
        "lineno": 16,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI group function decorated with @cli.group. Click framework automatically discovers and calls these decorated functions to organize subcommands under the 'ship' group.",
          "recommendation": "keep",
          "evidence": [
            "Function has @cli.group decorator making it a CLI command group",
            "Located in examples/naval/ suggesting it's a CLI tool example",
            "Serves as parent group for ship subcommands"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI group function decorated with @cli.group. Click framework automatically discovers and calls these decorated functions to organize subcommands under the 'ship' group.",
        "recommendation": "keep"
      },
      {
        "name": "ship_new",
        "module": "examples/naval/naval.py",
        "lineno": 22,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI command function decorated with @ship.command. Click framework automatically discovers and calls these decorated functions when the 'ship new' command is invoked from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function has @ship.command decorator making it a subcommand of ship group",
            "Function has @click.argument decorator for command line arguments",
            "Part of the naval CLI example application"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI command function decorated with @ship.command. Click framework automatically discovers and calls these decorated functions when the 'ship new' command is invoked from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "ship_move",
        "module": "examples/naval/naval.py",
        "lineno": 32,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI command function decorated with @ship.command. Click framework automatically discovers and calls these decorated functions when the 'ship move' command is invoked from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function has @ship.command decorator making it a subcommand of ship group",
            "Function has multiple @click.argument and @click.option decorators for command line interface",
            "Part of the naval CLI example application"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI command function decorated with @ship.command. Click framework automatically discovers and calls these decorated functions when the 'ship move' command is invoked from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "ship_shoot",
        "module": "examples/naval/naval.py",
        "lineno": 41,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI command function decorated with @ship.command. Click framework automatically discovers and calls these decorated functions when the 'ship shoot' command is invoked from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function has @ship.command decorator making it a subcommand of ship group",
            "Function has multiple @click.argument decorators for command line arguments",
            "Part of the naval CLI example application"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI command function decorated with @ship.command. Click framework automatically discovers and calls these decorated functions when the 'ship shoot' command is invoked from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "mine",
        "module": "examples/naval/naval.py",
        "lineno": 47,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI command group decorated with @cli.group. Click framework calls this function when users run the 'mine' command from the command line. No internal calls expected for CLI entry points.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.group making it a Click command group",
            "CLI commands are invoked by the Click framework, not internal code"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI command group decorated with @cli.group. Click framework calls this function when users run the 'mine' command from the command line. No internal calls expected for CLI entry points.",
        "recommendation": "keep"
      },
      {
        "name": "mine_set",
        "module": "examples/naval/naval.py",
        "lineno": 62,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI subcommand decorated with @mine.command. It's called by the Click framework when users run the mine set command. CLI commands don't need internal calls to be valid.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @mine.command making it a CLI subcommand",
            "Has click.argument and click.option decorators for CLI parameter handling"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI subcommand decorated with @mine.command. It's called by the Click framework when users run the mine set command. CLI commands don't need internal calls to be valid.",
        "recommendation": "keep"
      },
      {
        "name": "mine_remove",
        "module": "examples/naval/naval.py",
        "lineno": 70,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI subcommand decorated with @mine.command. Like other CLI commands, it's invoked by the Click framework when users execute the mine remove command, not by internal application code.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @mine.command making it a CLI subcommand",
            "Has click.argument decorators for CLI parameter handling"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI subcommand decorated with @mine.command. Like other CLI commands, it's invoked by the Click framework when users execute the mine remove command, not by internal application code.",
        "recommendation": "keep"
      },
      {
        "name": "clone",
        "module": "examples/repo/repo.py",
        "lineno": 72,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI command decorated with @cli.command and @pass_repo. It's executed by the Click framework when users run the clone command. CLI entry points are called externally, not internally.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command making it a CLI command",
            "Has @pass_repo decorator and multiple click parameter decorators",
            "Contains implementation logic for cloning repositories"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI command decorated with @cli.command and @pass_repo. It's executed by the Click framework when users run the clone command. CLI entry points are called externally, not internally.",
        "recommendation": "keep"
      },
      {
        "name": "delete",
        "module": "examples/repo/repo.py",
        "lineno": 91,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Click CLI command decorated with @cli.command and @pass_repo. The Click framework invokes this function when users execute the delete command. CLI commands are external entry points that don't require internal calls.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command making it a CLI command",
            "Has @click.confirmation_option and @pass_repo decorators",
            "Implements repository deletion functionality for CLI users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Click CLI command decorated with @cli.command and @pass_repo. The Click framework invokes this function when users execute the delete command. CLI commands are external entry points that don't require internal calls.",
        "recommendation": "keep"
      },
      {
        "name": "setuser",
        "module": "examples/repo/repo.py",
        "lineno": 105,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command and other click decorators, making it a CLI command callback. It's invoked by the click framework when users run the command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command which registers it as a CLI command",
            "Has click decorators (@click.option, @click.password_option) indicating it's a command-line interface function"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command and other click decorators, making it a CLI command callback. It's invoked by the click framework when users run the command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "commit",
        "module": "examples/repo/repo.py",
        "lineno": 126,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command and other click decorators, making it a CLI command callback. It's invoked by the click framework when users run the commit command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command which registers it as a CLI command",
            "Has click decorators (@click.option, @click.argument) indicating it's a command-line interface function"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command and other click decorators, making it a CLI command callback. It's invoked by the click framework when users run the commit command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "colordemo",
        "module": "examples/termui/termui.py",
        "lineno": 15,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, making it a CLI command callback. It's invoked by the click framework when users run the colordemo command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command which registers it as a CLI command",
            "Located in examples/termui/termui.py suggesting it's a demonstration command"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, making it a CLI command callback. It's invoked by the click framework when users run the colordemo command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "progress",
        "module": "examples/termui/termui.py",
        "lineno": 38,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command and @click.option, making it a CLI command callback. It's invoked by the click framework when users run the progress command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command which registers it as a CLI command",
            "Has @click.option decorator indicating it accepts command-line options"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command and @click.option, making it a CLI command callback. It's invoked by the click framework when users run the progress command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "menu",
        "module": "examples/termui/termui.py",
        "lineno": 145,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @cli.command, making it a CLI command callback. It's invoked by the click framework when users run the menu command from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @cli.command which registers it as a CLI command",
            "Located in examples/termui/termui.py suggesting it's a demonstration command"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @cli.command, making it a CLI command callback. It's invoked by the click framework when users run the menu command from the command line.",
        "recommendation": "keep"
      },
      {
        "name": "get_binary_stderr",
        "module": "src/click/_compat.py",
        "lineno": 330,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This is a utility function in an internal _compat module that provides binary stderr access. Since this is an APPLICATION project, if it's not called anywhere internally, it's dead code regardless of its potential utility.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Function is in internal _compat module (underscore prefix indicates internal)",
            "No internal calls found in application codebase",
            "Similar pattern to other compatibility utilities that may be unused"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This is a utility function in an internal _compat module that provides binary stderr access. Since this is an APPLICATION project, if it's not called anywhere internally, it's dead code regardless of its potential utility.",
        "recommendation": "safe_to_delete"
      },
      {
        "name": "seekable",
        "module": "src/click/_compat.py",
        "lineno": 140,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This method implements the seekable() protocol method for file-like objects. The _FixupStream class is designed to provide a compatible stream interface, and seekable() is a standard method that may be called by Python's I/O system or other code expecting file-like objects.",
          "recommendation": "keep",
          "evidence": [
            "Implements standard file-like object protocol method",
            "Part of _FixupStream class that provides stream compatibility",
            "May be called by Python's I/O system or external code expecting file interface"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method implements the seekable() protocol method for file-like objects. The _FixupStream class is designed to provide a compatible stream interface, and seekable() is a standard method that may be called by Python's I/O system or other code expecting file-like objects.",
        "recommendation": "keep"
      },
      {
        "name": "_handle_long_word",
        "module": "src/click/_textwrap.py",
        "lineno": 9,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This method overrides a method from textwrap.TextWrapper base class. It's part of the text wrapping algorithm and is called internally by the TextWrapper framework during text processing, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Overrides method from textwrap.TextWrapper base class",
            "Called internally by TextWrapper's wrap algorithm",
            "Part of text processing framework interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This method overrides a method from textwrap.TextWrapper base class. It's part of the text wrapping algorithm and is called internally by the TextWrapper framework during text processing, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "name": "_get_text_stdin",
        "module": "src/click/_winconsole.py",
        "lineno": 226,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 80,
          "category": "genuinely_unused",
          "reason": "This is a Windows console utility function in _winconsole module. Since this is an APPLICATION project and no internal calls are found, it's likely dead code. The underscore prefix indicates it's an internal helper function.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Internal helper function with underscore prefix",
            "No internal calls found in application",
            "Windows-specific console handling that may be unused"
          ]
        },
        "status": "dead_code",
        "confidence": 80,
        "reason": "This is a Windows console utility function in _winconsole module. Since this is an APPLICATION project and no internal calls are found, it's likely dead code. The underscore prefix indicates it's an internal helper function.",
        "recommendation": "safe_to_delete"
      },
      {
        "name": "_get_text_stdout",
        "module": "src/click/_winconsole.py",
        "lineno": 236,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 80,
          "category": "genuinely_unused",
          "reason": "This is a Windows console utility function in _winconsole module. Since this is an APPLICATION project and no internal calls are found, it's likely dead code. The underscore prefix indicates it's an internal helper function.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Internal helper function with underscore prefix",
            "No internal calls found in application",
            "Windows-specific console handling that may be unused"
          ]
        },
        "status": "dead_code",
        "confidence": 80,
        "reason": "This is a Windows console utility function in _winconsole module. Since this is an APPLICATION project and no internal calls are found, it's likely dead code. The underscore prefix indicates it's an internal helper function.",
        "recommendation": "safe_to_delete"
      },
      {
        "name": "_get_text_stderr",
        "module": "src/click/_winconsole.py",
        "lineno": 246,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This is a Windows console utility function that creates a stderr text stream. The underscore prefix suggests internal use, but it's likely called by Windows console handling code that wasn't analyzed.",
          "recommendation": "keep",
          "evidence": [
            "Part of Windows console module with specific STDERR_HANDLE functionality",
            "Mirrors _get_text_stdout pattern suggesting it's part of a console interface"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a Windows console utility function that creates a stderr text stream. The underscore prefix suggests internal use, but it's likely called by Windows console handling code that wasn't analyzed.",
        "recommendation": "keep"
      },
      {
        "name": "readinto",
        "module": "src/click/_winconsole.py",
        "lineno": 131,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This implements the standard Python IO protocol's readinto method. It's called by Python's IO system and buffering mechanisms, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Implements standard Python IO protocol method readinto()",
            "Part of _WindowsConsoleReader class that extends IO base classes"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This implements the standard Python IO protocol's readinto method. It's called by Python's IO system and buffering mechanisms, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "name": "writelines",
        "module": "src/click/_winconsole.py",
        "lineno": 212,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This implements the standard Python IO protocol's writelines method. It's part of the file-like object interface and called by Python's IO system, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Implements standard Python IO protocol method writelines()",
            "Part of ConsoleStream class providing file-like interface"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This implements the standard Python IO protocol's writelines method. It's part of the file-like object interface and called by Python's IO system, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "name": "with_resource",
        "module": "src/click/core.py",
        "lineno": 575,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public API method of the exported Context class. It provides resource management functionality for Click contexts and is intended for external use by Click application developers.",
          "recommendation": "keep",
          "evidence": [
            "Parent class Context is exported (Class is EXPORTED: True)",
            "Well-documented public method for resource management in Click contexts"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public API method of the exported Context class. It provides resource management functionality for Click contexts and is intended for external use by Click application developers.",
        "recommendation": "keep"
      },
      {
        "name": "add_source",
        "module": "src/click/core.py",
        "lineno": 1987,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public API method of the exported CommandCollection class. It allows users to programmatically add command groups as sources, which is core functionality for building complex Click applications.",
          "recommendation": "keep",
          "evidence": [
            "Parent class CommandCollection is exported (Class is EXPORTED: True)",
            "Well-documented public method for managing command sources"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public API method of the exported CommandCollection class. It allows users to programmatically add command groups as sources, which is core functionality for building complex Click applications.",
        "recommendation": "keep"
      },
      {
        "name": "pass_meta_key",
        "module": "src/click/decorators.py",
        "lineno": 100,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a decorator factory function in Click's public API that creates decorators for passing context metadata to command functions. It's designed to be used by application developers using the Click library, so lack of internal usage is expected.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented function with detailed docstring indicating public API usage",
            "Located in decorators.py module which suggests it's part of Click's decorator API",
            "Function signature and purpose indicate it's meant for external consumption by Click users"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a decorator factory function in Click's public API that creates decorators for passing context metadata to command functions. It's designed to be used by application developers using the Click library, so lack of internal usage is expected.",
        "recommendation": "keep"
      },
      {
        "name": "add_completion_class",
        "module": "src/click/shell_completion.py",
        "lineno": 436,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a registration function for shell completion classes in Click's public API. It allows users to register custom completion handlers, so it's meant to be called by external code rather than internally.",
          "recommendation": "keep",
          "evidence": [
            "Clear registration pattern with detailed docstring for external usage",
            "Part of shell completion system which is typically extended by users",
            "Function modifies global state (registering classes) indicating it's an extension point"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a registration function for shell completion classes in Click's public API. It allows users to register custom completion handlers, so it's meant to be called by external code rather than internally.",
        "recommendation": "keep"
      },
      {
        "name": "isolated_filesystem",
        "module": "src/click/testing.py",
        "lineno": 547,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a context manager method on the CliRunner class in Click's testing utilities. It's part of the public API for testing Click applications, decorated with @contextmanager, and meant to be used by developers writing tests.",
          "recommendation": "keep",
          "evidence": [
            "Method on CliRunner class which is a key part of Click's testing API",
            "Has @contextmanager decorator indicating it's meant to be used as 'with' statement",
            "Well-documented testing utility that external users would call directly in their test suites"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a context manager method on the CliRunner class in Click's testing utilities. It's part of the public API for testing Click applications, decorated with @contextmanager, and meant to be used by developers writing tests.",
        "recommendation": "keep"
      }
    ],
    "unused_classes": [
      {
        "name": "Sentinel",
        "module": "src/click/_utils.py",
        "lineno": 7,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a base class for creating sentinel values following PEP 661. It's likely used as a metaclass or base for other sentinel enums in the codebase, even if not directly instantiated.",
          "recommendation": "keep",
          "evidence": [
            "Documented as implementing PEP 661 sentinel values pattern",
            "Base classes for enums are typically used as metaclasses or inheritance targets"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a base class for creating sentinel values following PEP 661. It's likely used as a metaclass or base for other sentinel enums in the codebase, even if not directly instantiated.",
        "recommendation": "keep"
      },
      {
        "name": "_WindowsConsoleRawIOBase",
        "module": "src/click/_winconsole.py",
        "lineno": 118,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This class extends io.RawIOBase and is likely used as a base class for Windows console I/O operations. The leading underscore indicates internal use, but it's probably inherited by other classes in the Windows console handling code.",
          "recommendation": "keep",
          "evidence": [
            "Inherits from io.RawIOBase which suggests it implements I/O protocol methods",
            "Located in _winconsole.py indicating Windows-specific functionality that may be conditionally used"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This class extends io.RawIOBase and is likely used as a base class for Windows console I/O operations. The leading underscore indicates internal use, but it's probably inherited by other classes in the Windows console handling code.",
        "recommendation": "keep"
      },
      {
        "name": "ParameterSource",
        "module": "src/click/core.py",
        "lineno": 143,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This enum is explicitly documented as public API for tracking parameter sources in Click commands. It's referenced in the docstring as being used with Context.get_parameter_source method.",
          "recommendation": "keep",
          "evidence": [
            "Documented as public API with usage instructions",
            "Referenced as being used with Context.get_parameter_source method",
            "Has version change notes indicating active maintenance"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This enum is explicitly documented as public API for tracking parameter sources in Click commands. It's referenced in the docstring as being used with Context.get_parameter_source method.",
        "recommendation": "keep"
      },
      {
        "name": "_FakeSubclassCheck",
        "module": "src/click/core.py",
        "lineno": 1488,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "interface_method",
          "reason": "This is a metaclass (inherits from type) that likely implements custom subclass checking behavior. Metaclasses are used by Python's type system and may not show direct usage in code analysis.",
          "recommendation": "keep",
          "evidence": [
            "Inherits from type making it a metaclass",
            "Metaclasses are used by Python's type system and may not show direct calls"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This is a metaclass (inherits from type) that likely implements custom subclass checking behavior. Metaclasses are used by Python's type system and may not show direct usage in code analysis.",
        "recommendation": "keep"
      },
      {
        "name": "ShellComplete",
        "module": "src/click/shell_completion.py",
        "lineno": 200,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is documented as a base class for shell completion support that should be subclassed. Base classes in libraries are part of the public API even if not directly instantiated, as they're meant to be extended by users.",
          "recommendation": "keep",
          "evidence": [
            "Explicitly documented as base class meant for subclassing",
            "Located in shell_completion.py indicating it's part of Click's completion feature",
            "Docstring indicates it has source and complete methods that subclasses override"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is documented as a base class for shell completion support that should be subclassed. Base classes in libraries are part of the public API even if not directly instantiated, as they're meant to be extended by users.",
        "recommendation": "keep"
      },
      {
        "name": "BashComplete",
        "module": "src/click/shell_completion.py",
        "lineno": 304,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a shell completion class for Bash that's part of Click's shell completion system. It's designed to be used by the shell completion framework and likely instantiated through Click's completion mechanism.",
          "recommendation": "keep",
          "evidence": [
            "Part of Click's shell completion system in shell_completion.py",
            "Has proper docstring indicating it's for Bash shell completion",
            "Extends ShellComplete base class suggesting it's part of a completion framework"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a shell completion class for Bash that's part of Click's shell completion system. It's designed to be used by the shell completion framework and likely instantiated through Click's completion mechanism.",
        "recommendation": "keep"
      },
      {
        "name": "ZshComplete",
        "module": "src/click/shell_completion.py",
        "lineno": 363,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a shell completion class for Zsh that's part of Click's shell completion system. Like BashComplete, it's designed to be used by the shell completion framework.",
          "recommendation": "keep",
          "evidence": [
            "Part of Click's shell completion system in shell_completion.py",
            "Has proper docstring indicating it's for Zsh shell completion",
            "Extends ShellComplete base class as part of completion framework"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a shell completion class for Zsh that's part of Click's shell completion system. Like BashComplete, it's designed to be used by the shell completion framework.",
        "recommendation": "keep"
      },
      {
        "name": "FishComplete",
        "module": "src/click/shell_completion.py",
        "lineno": 399,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a shell completion class for Fish shell that's part of Click's shell completion system. It follows the same pattern as Bash and Zsh completion classes.",
          "recommendation": "keep",
          "evidence": [
            "Part of Click's shell completion system in shell_completion.py",
            "Has proper docstring indicating it's for Fish shell completion",
            "Extends ShellComplete base class completing the trio of major shell completions"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a shell completion class for Fish shell that's part of Click's shell completion system. It follows the same pattern as Bash and Zsh completion classes.",
        "recommendation": "keep"
      },
      {
        "name": "CliRunner",
        "module": "src/click/testing.py",
        "lineno": 229,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core testing utility class in Click's testing module. It's designed for external users to test their Click commands in isolation and is a fundamental part of Click's testing API.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py module suggesting it's for external testing use",
            "Has comprehensive docstring explaining its purpose for unittesting Click commands",
            "Testing utilities are typically public API components that users import and use"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core testing utility class in Click's testing module. It's designed for external users to test their Click commands in isolation and is a fundamental part of Click's testing API.",
        "recommendation": "keep"
      },
      {
        "name": "CompositeParamType",
        "module": "src/click/types.py",
        "lineno": 163,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a parameter type class that extends ParamType in Click's type system. It's likely part of Click's public API for handling composite parameter types in command-line interfaces.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py which contains Click's parameter type system",
            "Extends ParamType base class indicating it's part of the type system framework",
            "Parameter types are typically used by Click users to define custom argument/option types"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a parameter type class that extends ParamType in Click's type system. It's likely part of Click's public API for handling composite parameter types in command-line interfaces.",
        "recommendation": "keep"
      },
      {
        "name": "_NumberParamTypeBase",
        "module": "src/click/types.py",
        "lineno": 472,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a base class for number parameter types in Click's type system. The underscore prefix suggests it's internal, but it's likely used as a parent class for concrete number types like IntParamType or FloatParamType that are part of Click's public API.",
          "recommendation": "keep",
          "evidence": [
            "Base class in Click's parameter type hierarchy",
            "Likely inherited by concrete number parameter types"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a base class for number parameter types in Click's type system. The underscore prefix suggests it's internal, but it's likely used as a parent class for concrete number types like IntParamType or FloatParamType that are part of Click's public API.",
        "recommendation": "keep"
      },
      {
        "name": "_NumberRangeBase",
        "module": "src/click/types.py",
        "lineno": 490,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This inherits from _NumberParamTypeBase and appears to be a base class for number range validation types. Click provides IntRange and FloatRange types that likely inherit from this base class to implement range validation functionality.",
          "recommendation": "keep",
          "evidence": [
            "Inherits from _NumberParamTypeBase indicating it's part of the type system",
            "Base class for range validation functionality in Click"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This inherits from _NumberParamTypeBase and appears to be a base class for number range validation types. Click provides IntRange and FloatRange types that likely inherit from this base class to implement range validation functionality.",
        "recommendation": "keep"
      },
      {
        "name": "OptionHelpExtra",
        "module": "src/click/types.py",
        "lineno": 1205,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This is a TypedDict class which defines a type structure for type hints. TypedDict classes are used by type checkers and IDEs to provide type information and are not meant to be instantiated directly, so lack of direct usage is expected.",
          "recommendation": "keep",
          "evidence": [
            "TypedDict is used for type annotations, not direct instantiation",
            "Provides type structure for option help functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a TypedDict class which defines a type structure for type hints. TypedDict classes are used by type checkers and IDEs to provide type information and are not meant to be instantiated directly, so lack of direct usage is expected.",
        "recommendation": "keep"
      }
    ],
    "unused_imports": [],
    "unused_global_variables": [
      {
        "module": "src/click/_compat.py",
        "name": "CYGWIN",
        "lineno": 13,
        "assigned_to": "sys.platform.startswith",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "Platform detection variable in _compat.py used for Windows/Cygwin compatibility checks. This type of compatibility variable is typically used conditionally in platform-specific code paths throughout the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in _compat.py which is a compatibility module",
            "CYGWIN is a common platform detection pattern used for conditional logic"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Platform detection variable in _compat.py used for Windows/Cygwin compatibility checks. This type of compatibility variable is typically used conditionally in platform-specific code paths throughout the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "_default_text_stdin",
        "lineno": 607,
        "assigned_to": "_make_cached_stream_func",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "config",
          "reason": "Private module-level variable for default text stdin handling in compatibility layer. These default stream variables are typically used as fallbacks or initial values in I/O operations within the click library.",
          "recommendation": "keep",
          "evidence": [
            "Part of stream handling infrastructure in _compat.py",
            "Named as default value suggesting it's used as fallback"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "Private module-level variable for default text stdin handling in compatibility layer. These default stream variables are typically used as fallbacks or initial values in I/O operations within the click library.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "_default_text_stdout",
        "lineno": 608,
        "assigned_to": "_make_cached_stream_func",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "config",
          "reason": "Private module-level variable for default text stdout handling in compatibility layer. These default stream variables are typically used as fallbacks or initial values in I/O operations within the click library.",
          "recommendation": "keep",
          "evidence": [
            "Part of stream handling infrastructure in _compat.py",
            "Named as default value suggesting it's used as fallback"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "Private module-level variable for default text stdout handling in compatibility layer. These default stream variables are typically used as fallbacks or initial values in I/O operations within the click library.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "_default_text_stderr",
        "lineno": 609,
        "assigned_to": "_make_cached_stream_func",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "config",
          "reason": "Private module-level variable for default text stderr handling in compatibility layer. These default stream variables are typically used as fallbacks or initial values in I/O operations within the click library.",
          "recommendation": "keep",
          "evidence": [
            "Part of stream handling infrastructure in _compat.py",
            "Named as default value suggesting it's used as fallback"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "Private module-level variable for default text stderr handling in compatibility layer. These default stream variables are typically used as fallbacks or initial values in I/O operations within the click library.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_utils.py",
        "name": "T_UNSET",
        "lineno": 32,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "Sentinel/constant value in _utils.py likely used to represent unset state in type annotations or default parameter handling. T_ prefix suggests it's a type-related constant used throughout the codebase for state management.",
          "recommendation": "keep",
          "evidence": [
            "Located in _utils.py indicating it's a utility constant",
            "T_UNSET naming pattern suggests sentinel value for unset state"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Sentinel/constant value in _utils.py likely used to represent unset state in type annotations or default parameter handling. T_ prefix suggests it's a type-related constant used throughout the codebase for state management.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_utils.py",
        "name": "T_FLAG_NEEDS_VALUE",
        "lineno": 35,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This appears to be a type annotation constant used in click's internal type system for command-line flag processing. Such constants are typically used for type checking and internal validation logic.",
          "recommendation": "keep",
          "evidence": [
            "Located in _utils.py which suggests internal utility functionality",
            "Name pattern suggests it's a type flag constant for click's option parsing system"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a type annotation constant used in click's internal type system for command-line flag processing. Such constants are typically used for type checking and internal validation logic.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "GetCommandLineW",
        "lineno": 47,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This is a Windows API function binding used for console operations on Windows systems. Click uses these bindings for proper Windows console handling, and they're called conditionally based on platform detection.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py indicating Windows-specific console functionality",
            "Windows API functions are called conditionally and may not show up in static analysis"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a Windows API function binding used for console operations on Windows systems. Click uses these bindings for proper Windows console handling, and they're called conditionally based on platform detection.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "CommandLineToArgvW",
        "lineno": 48,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Another Windows API function binding for parsing command line arguments on Windows. Like other Windows API bindings, this is used conditionally and essential for proper Windows support in click.",
          "recommendation": "keep",
          "evidence": [
            "Windows API function for command line argument parsing",
            "Part of click's Windows console support infrastructure"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Another Windows API function binding for parsing command line arguments on Windows. Like other Windows API bindings, this is used conditionally and essential for proper Windows support in click.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "LocalFree",
        "lineno": 51,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Windows API function for memory management, typically used to free memory allocated by other Windows API calls like CommandLineToArgvW. Essential for preventing memory leaks in Windows-specific code paths.",
          "recommendation": "keep",
          "evidence": [
            "Windows API memory management function",
            "Required for proper cleanup after using other Windows API functions"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Windows API function for memory management, typically used to free memory allocated by other Windows API calls like CommandLineToArgvW. Essential for preventing memory leaks in Windows-specific code paths.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "STDIN_FILENO",
        "lineno": 64,
        "assigned_to": "int",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This is likely a constant defining the file descriptor number for standard input on Windows systems. Such constants are used for low-level console operations and may be referenced in platform-specific code paths.",
          "recommendation": "keep",
          "evidence": [
            "Located in Windows console module suggesting system-level constant",
            "FILENO constants are standard for file descriptor operations"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is likely a constant defining the file descriptor number for standard input on Windows systems. Such constants are used for low-level console operations and may be referenced in platform-specific code paths.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "STDOUT_FILENO",
        "lineno": 65,
        "assigned_to": "int",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This variable is defined but never referenced anywhere in the codebase. It appears to be a leftover constant that was defined for Windows console operations but is not actually used by any function or class in the module.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Variable is defined at module level but has no references in the codebase",
            "Similar constants in Windows console modules are typically used for file handle operations, but this one appears orphaned"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This variable is defined but never referenced anywhere in the codebase. It appears to be a leftover constant that was defined for Windows console operations but is not actually used by any function or class in the module.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "STDERR_FILENO",
        "lineno": 66,
        "assigned_to": "int",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This variable is defined but never referenced anywhere in the codebase. Like STDOUT_FILENO, it appears to be an unused constant that was intended for Windows console operations but is not actually utilized by any code.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Variable is defined at module level but has no references in the codebase",
            "Appears to be paired with STDOUT_FILENO as unused file descriptor constants"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This variable is defined but never referenced anywhere in the codebase. Like STDOUT_FILENO, it appears to be an unused constant that was intended for Windows console operations but is not actually utilized by any code.",
        "recommendation": "safe_to_delete"
      }
    ],
    "unreachable_code": [],
    "suspicious_patterns": [
      {
        "module": "examples/completion/completion.py",
        "name": "cli",
        "lineno": 8,
        "pattern_type": "empty_function",
        "details": "Function is empty or only contains pass/return None",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Click CLI decorator or function in an example file. Click CLI functions are typically called by the Click framework when the script is executed, not directly by other code in the application.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/completion/completion.py which suggests it's a runnable example",
            "Click CLI functions are entry points called by the framework, not internally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Click CLI decorator or function in an example file. Click CLI functions are typically called by the Click framework when the script is executed, not directly by other code in the application.",
        "recommendation": "keep"
      },
      {
        "module": "examples/completion/completion.py",
        "name": "group",
        "lineno": 32,
        "pattern_type": "empty_function",
        "details": "Function is empty or only contains pass/return None",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a Click group decorator or function in an example file. Click groups are command containers that are invoked by the Click framework when users run CLI commands, not called directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/completion/completion.py indicating it's part of a CLI example",
            "Click groups are framework entry points, not internal function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a Click group decorator or function in an example file. Click groups are command containers that are invoked by the Click framework when users run CLI commands, not called directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "_force_correct_text_stream",
        "lineno": 238,
        "pattern_type": "too_many_parameters",
        "details": "Function has 7 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a compatibility utility function in Click's _compat module. Even though it starts with underscore, compatibility functions are often used internally by the framework or by external code dealing with text streams.",
          "recommendation": "keep",
          "evidence": [
            "Located in _compat.py which contains compatibility utilities used throughout Click",
            "Text stream handling functions are typically called by I/O operations in the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a compatibility utility function in Click's _compat module. Even though it starts with underscore, compatibility functions are often used internally by the framework or by external code dealing with text streams.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "main",
        "lineno": 1338,
        "pattern_type": "long_function",
        "details": "Function is very long (112 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "The 'main' method is a standard Click method that serves as the entry point for command execution. It's called by the Click framework when commands are invoked, making it a critical part of the public API.",
          "recommendation": "keep",
          "evidence": [
            "Located in src/click/core.py which is the main Click framework code",
            "'main' is a standard entry point method pattern in CLI frameworks"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'main' method is a standard Click method that serves as the entry point for command execution. It's called by the Click framework when commands are invoked, making it a critical part of the public API.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help_record",
        "lineno": 2604,
        "pattern_type": "empty_function",
        "details": "Function is empty or only contains pass/return None",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This method is part of Click's help system and is called by the framework when generating help text for commands and options. It's a standard method in Click's command/option interface.",
          "recommendation": "keep",
          "evidence": [
            "Located in src/click/core.py indicating it's part of the core framework",
            "Help-related methods are called by Click's help generation system, not directly by user code"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method is part of Click's help system and is called by the framework when generating help text for commands and options. It's a standard method in Click's command/option interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/decorators.py",
        "name": "version_option",
        "lineno": 421,
        "pattern_type": "long_function",
        "details": "Function is very long (104 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator function in the click library for adding version options to CLI commands. It's part of click's public API that users import and use to decorate their command functions.",
          "recommendation": "keep",
          "evidence": [
            "Function is in a library's decorators module, indicating public API",
            "Click is a CLI framework where decorators like this are the primary interface for users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator function in the click library for adding version options to CLI commands. It's part of click's public API that users import and use to decorate their command functions.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/parser.py",
        "name": "add_option",
        "lineno": 261,
        "pattern_type": "too_many_parameters",
        "details": "Function has 7 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This method is part of click's option parser functionality, likely used internally by the framework and potentially by advanced users. Parser methods are typically part of the public interface in CLI libraries.",
          "recommendation": "keep",
          "evidence": [
            "Located in parser module which is core functionality for CLI frameworks",
            "Method name follows standard parser interface patterns"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method is part of click's option parser functionality, likely used internally by the framework and potentially by advanced users. Parser methods are typically part of the public interface in CLI libraries.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "prompt",
        "lineno": 83,
        "pattern_type": "long_function",
        "details": "Function is very long (112 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a terminal UI function in click for prompting user input. It's a core utility function that users of the click library would call directly in their applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in termui module which provides user interface utilities",
            "Prompt functions are essential public API for interactive CLI applications"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a terminal UI function in click for prompting user input. It's a core utility function that users of the click library would call directly in their applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "prompt",
        "lineno": 83,
        "pattern_type": "too_many_parameters",
        "details": "Function has 10 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Duplicate of previous item - this is the same prompt function in click's terminal UI module, which is part of the public API for creating interactive command-line interfaces.",
          "recommendation": "keep",
          "evidence": [
            "Same as previous prompt function",
            "Core utility for CLI user interaction"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Duplicate of previous item - this is the same prompt function in click's terminal UI module, which is part of the public API for creating interactive command-line interfaces.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "progressbar",
        "lineno": 314,
        "pattern_type": "too_many_parameters",
        "details": "Function has 16 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a progress bar utility function in click's terminal UI module. Progress bars are commonly used public API functions that developers import and use in their CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in termui module providing user interface components",
            "Progress bars are standard CLI utilities that users would call directly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a progress bar utility function in click's terminal UI module. Progress bars are commonly used public API functions that developers import and use in their CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "progressbar",
        "lineno": 334,
        "pattern_type": "long_function",
        "details": "Function is very long (157 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public utility function in Click's termui module that provides progress bar functionality for CLI applications. Click is a library for creating command-line interfaces, and this function is part of its public API for developers to use.",
          "recommendation": "keep",
          "evidence": [
            "Located in termui.py which contains terminal UI utilities for public use",
            "Click is a library framework where such utilities are expected to be called by user applications"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public utility function in Click's termui module that provides progress bar functionality for CLI applications. Click is a library for creating command-line interfaces, and this function is part of its public API for developers to use.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "progressbar",
        "lineno": 334,
        "pattern_type": "too_many_parameters",
        "details": "Function has 16 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Duplicate of item #1 - this is the same public progressbar function in Click's termui module. It's part of the library's public API for creating progress bars in CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Same function as item #1 in termui.py",
            "Part of Click's public terminal UI utilities"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Duplicate of item #1 - this is the same public progressbar function in Click's termui module. It's part of the library's public API for creating progress bars in CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "style",
        "lineno": 518,
        "pattern_type": "long_function",
        "details": "Function is very long (127 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public utility function in Click's termui module for styling terminal output with colors and formatting. It's a core feature that CLI application developers use to format their output.",
          "recommendation": "keep",
          "evidence": [
            "Located in termui.py which provides public terminal styling utilities",
            "Text styling is a fundamental feature of CLI libraries like Click"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public utility function in Click's termui module for styling terminal output with colors and formatting. It's a core feature that CLI application developers use to format their output.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "style",
        "lineno": 518,
        "pattern_type": "too_many_parameters",
        "details": "Function has 12 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Duplicate of item #3 - this is the same public style function in Click's termui module. It provides text styling capabilities that are part of the library's public API.",
          "recommendation": "keep",
          "evidence": [
            "Same function as item #3 in termui.py",
            "Part of Click's public terminal styling utilities"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Duplicate of item #3 - this is the same public style function in Click's termui module. It provides text styling capabilities that are part of the library's public API.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/testing.py",
        "name": "isolation",
        "lineno": 280,
        "pattern_type": "long_function",
        "details": "Function is very long (152 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This appears to be part of Click's testing utilities module, likely providing test isolation functionality. Testing utilities in libraries are typically part of the public API for developers writing tests for their Click-based applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py which contains public testing utilities",
            "Test isolation is a common pattern in testing frameworks and libraries"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be part of Click's testing utilities module, likely providing test isolation functionality. Testing utilities in libraries are typically part of the public API for developers writing tests for their Click-based applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/testing.py",
        "name": "invoke",
        "lineno": 433,
        "pattern_type": "long_function",
        "details": "Function is very long (112 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is likely the CliRunner.invoke() method which is a core public API method in Click's testing framework. Users rely on this method to invoke CLI commands in tests, so it's expected to have no internal calls within the Click codebase itself.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py which provides public testing utilities",
            "invoke() is a standard method name for CLI testing frameworks"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely the CliRunner.invoke() method which is a core public API method in Click's testing framework. Users rely on this method to invoke CLI commands in tests, so it's expected to have no internal calls within the Click codebase itself.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/testing.py",
        "name": "invoke",
        "lineno": 433,
        "pattern_type": "too_many_parameters",
        "details": "Function has 7 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be a duplicate of the previous invoke method. If it's the same CliRunner.invoke() method, it's a core public API for Click's testing framework that external users depend on for invoking CLI commands in their tests.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous invoke method",
            "Testing utilities are typically public API in CLI frameworks"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a duplicate of the previous invoke method. If it's the same CliRunner.invoke() method, it's a core public API for Click's testing framework that external users depend on for invoking CLI commands in their tests.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/utils.py",
        "name": "echo",
        "lineno": 222,
        "pattern_type": "long_function",
        "details": "Function is very long (101 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is likely click.echo() which is a fundamental public API function in Click for outputting text. It's designed to be called by user applications, not internally by Click itself, so lack of internal usage is expected.",
          "recommendation": "keep",
          "evidence": [
            "Located in utils.py which typically contains public utilities",
            "echo() is a core Click function used by CLI applications"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely click.echo() which is a fundamental public API function in Click for outputting text. It's designed to be called by user applications, not internally by Click itself, so lack of internal usage is expected.",
        "recommendation": "keep"
      },
      {
        "module": "examples/aliases/aliases.py",
        "name": "read_config",
        "lineno": 76,
        "pattern_type": "similar_function_names",
        "details": "Similar to read in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "This is in an example file, so it could be demonstrating functionality that isn't actually used within the example. However, examples are meant to show working code patterns, so it might be called in ways not easily detectable.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples directory which may have incomplete usage patterns",
            "Could be demonstration code showing how to implement config reading"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "This is in an example file, so it could be demonstrating functionality that isn't actually used within the example. However, examples are meant to show working code patterns, so it might be called in ways not easily detectable.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/aliases/aliases.py",
        "name": "push",
        "lineno": 102,
        "pattern_type": "similar_function_names",
        "details": "Similar to push_context in src/click/globals.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "Similar to read_config, this is in example code which may not demonstrate complete usage patterns. The push method could be part of a stack-like interface that's only partially implemented in the example.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples directory alongside other potentially unused methods",
            "Could be part of an incomplete example implementation"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "Similar to read_config, this is in example code which may not demonstrate complete usage patterns. The push method could be part of a stack-like interface that's only partially implemented in the example.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/aliases/aliases.py",
        "name": "read_config",
        "lineno": 17,
        "pattern_type": "similar_function_names",
        "details": "Similar to read in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This function is defined in an example file but appears to have no calls within the codebase. Since this is an application project, all functions should be actively used somewhere.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/ directory suggesting it may be sample/demo code",
            "No internal calls found in application codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This function is defined in an example file but appears to have no calls within the codebase. Since this is an application project, all functions should be actively used somewhere.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/aliases/aliases.py",
        "name": "write_config",
        "lineno": 25,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/_winconsole.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This function is defined in an example file but appears to have no calls within the codebase. Since this is an application project, all functions should be actively used somewhere.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/ directory suggesting it may be sample/demo code",
            "No internal calls found in application codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This function is defined in an example file but appears to have no calls within the codebase. Since this is an application project, all functions should be actively used somewhere.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/aliases/aliases.py",
        "name": "write_config",
        "lineno": 25,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/_winconsole.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be a duplicate entry of the same function. Since this is an application project, all functions should be actively used somewhere.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/ directory suggesting it may be sample/demo code",
            "No internal calls found in application codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be a duplicate entry of the same function. Since this is an application project, all functions should be actively used somewhere.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/aliases/aliases.py",
        "name": "write_config",
        "lineno": 25,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be a duplicate entry of the same function. Since this is an application project, all functions should be actively used somewhere.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/ directory suggesting it may be sample/demo code",
            "No internal calls found in application codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be a duplicate entry of the same function. Since this is an application project, all functions should be actively used somewhere.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/aliases/aliases.py",
        "name": "write_config",
        "lineno": 25,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be a duplicate entry of the same function. Since this is an application project, all functions should be actively used somewhere.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/ directory suggesting it may be sample/demo code",
            "No internal calls found in application codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be a duplicate entry of the same function. Since this is an application project, all functions should be actively used somewhere.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/completion/completion.py",
        "name": "show_env",
        "lineno": 26,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This appears to be a CLI command function in a completion example. Command functions are typically called by CLI frameworks like Click or argparse when users invoke the command, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/completion/ suggesting it's a CLI example",
            "Function name 'show_env' follows typical CLI command naming pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a CLI command function in a completion example. Command functions are typically called by CLI frameworks like Click or argparse when users invoke the command, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/completion/completion.py",
        "name": "show_env",
        "lineno": 26,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This appears to be a CLI command function in a completion example. Command functions are typically called by CLI frameworks like Click or argparse when users invoke the command, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/completion/ suggesting it's a CLI example",
            "Function name 'show_env' follows typical CLI command naming pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a CLI command function in a completion example. Command functions are typically called by CLI frameworks like Click or argparse when users invoke the command, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/completion/completion.py",
        "name": "show_env",
        "lineno": 26,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This appears to be a CLI command function in a completion example. Command functions are typically called by CLI frameworks like Click or argparse when users invoke the command, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/completion/ suggesting it's a CLI example",
            "Function name 'show_env' follows typical CLI command naming pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a CLI command function in a completion example. Command functions are typically called by CLI frameworks like Click or argparse when users invoke the command, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "process_commands",
        "lineno": 24,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "The function name 'process_commands' strongly suggests this is a command processing callback or handler function. Such functions are typically called by frameworks or as event handlers rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/imagepipe/ indicating it's part of an example application",
            "Name 'process_commands' follows callback/handler naming convention with 'process_' prefix"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "The function name 'process_commands' strongly suggests this is a command processing callback or handler function. Such functions are typically called by frameworks or as event handlers rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "process_commands",
        "lineno": 24,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "The function name 'process_commands' strongly suggests this is a command processing callback or handler function. Such functions are typically called by frameworks or as event handlers rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/imagepipe/ indicating it's part of an example application",
            "Name 'process_commands' follows callback/handler naming convention with 'process_' prefix"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "The function name 'process_commands' strongly suggests this is a command processing callback or handler function. Such functions are typically called by frameworks or as event handlers rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "processor",
        "lineno": 42,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This appears to be a pattern variable used in configuration or templating context within an imagepipe application. Pattern variables are typically used by external tools or runtime string formatting/substitution.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples directory suggesting it's part of a demonstration/configuration",
            "Pattern variables are commonly used for runtime substitution in image processing pipelines"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a pattern variable used in configuration or templating context within an imagepipe application. Pattern variables are typically used by external tools or runtime string formatting/substitution.",
        "recommendation": "keep"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "processor",
        "lineno": 42,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "Duplicate of the previous processor pattern variable. Same reasoning applies - likely used for configuration or runtime template substitution in the image processing pipeline.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples directory suggesting it's part of a demonstration/configuration",
            "Pattern variables are commonly used for runtime substitution in image processing pipelines"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of the previous processor pattern variable. Same reasoning applies - likely used for configuration or runtime template substitution in the image processing pipeline.",
        "recommendation": "keep"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "copy_filename",
        "lineno": 69,
        "pattern_type": "similar_function_names",
        "details": "Similar to copy in examples/repo/repo.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "config",
          "reason": "This appears to be a filename pattern variable used for file operations in the image processing pipeline. Such patterns are typically used by file handling systems or template engines at runtime.",
          "recommendation": "keep",
          "evidence": [
            "Filename patterns are essential for file operations and copying in image processing workflows",
            "Located in imagepipe application suggesting it's part of the file handling configuration"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This appears to be a filename pattern variable used for file operations in the image processing pipeline. Such patterns are typically used by file handling systems or template engines at runtime.",
        "recommendation": "keep"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "open_cmd",
        "lineno": 84,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in examples/termui/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This appears to be a command pattern variable likely used for opening files or executing external commands in the image processing pipeline. Command patterns are typically executed by shell interfaces or process managers.",
          "recommendation": "keep",
          "evidence": [
            "Command patterns are commonly used for external tool integration in image processing",
            "The 'open_cmd' name suggests it's used for file opening operations which are essential functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a command pattern variable likely used for opening files or executing external commands in the image processing pipeline. Command patterns are typically executed by shell interfaces or process managers.",
        "recommendation": "keep"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "open_cmd",
        "lineno": 84,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "Duplicate of the previous open_cmd pattern variable. Same reasoning applies - likely used for command execution or file opening operations in the image processing system.",
          "recommendation": "keep",
          "evidence": [
            "Command patterns are commonly used for external tool integration in image processing",
            "The 'open_cmd' name suggests it's used for file opening operations which are essential functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of the previous open_cmd pattern variable. Same reasoning applies - likely used for command execution or file opening operations in the image processing system.",
        "recommendation": "keep"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in examples/validation/validation.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "All five items appear to be the same function at the same location. Without seeing the actual code implementation or usage patterns, cannot definitively determine if this utility function is called elsewhere in the application.",
          "recommendation": "investigate",
          "evidence": [
            "Multiple duplicate entries suggest potential analysis tool error",
            "Location in examples/imagepipe suggests it may be demonstration code"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "All five items appear to be the same function at the same location. Without seeing the actual code implementation or usage patterns, cannot definitively determine if this utility function is called elsewhere in the application.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Duplicate entry of the same function. The repetition indicates potential tooling issues in the dead code detection process.",
          "recommendation": "investigate",
          "evidence": [
            "Identical location and name as previous entry",
            "Part of imagepipe example application"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Duplicate entry of the same function. The repetition indicates potential tooling issues in the dead code detection process.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Third duplicate entry of the same function. Need to examine actual code and call sites to make proper determination.",
          "recommendation": "investigate",
          "evidence": [
            "Same function reported multiple times",
            "Located in examples directory which may have different usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Third duplicate entry of the same function. Need to examine actual code and call sites to make proper determination.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Fourth duplicate entry. The repetition suggests this is likely a single function being reported multiple times rather than distinct dead code instances.",
          "recommendation": "investigate",
          "evidence": [
            "Consistent location across all entries",
            "Pattern suggests tool reporting error rather than multiple dead functions"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Fourth duplicate entry. The repetition suggests this is likely a single function being reported multiple times rather than distinct dead code instances.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Fifth duplicate entry of the same function. Without access to the actual code implementation and call graph, cannot make definitive assessment of whether this image processing utility is actually unused.",
          "recommendation": "investigate",
          "evidence": [
            "Fifth identical entry suggests analysis tool issue",
            "Function name suggests image rotation utility which may be called conditionally"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Fifth duplicate entry of the same function. Without access to the actual code implementation and call graph, cannot make definitive assessment of whether this image processing utility is actually unused.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "All 5 items reference the same function at the same location, suggesting a potential analysis error or duplicate detection. Without seeing the actual code content, function signature, or usage context, it's impossible to determine if this is genuinely dead code.",
          "recommendation": "investigate",
          "evidence": [
            "Multiple identical entries for same location suggest analysis issue",
            "No code content provided to assess actual usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "All 5 items reference the same function at the same location, suggesting a potential analysis error or duplicate detection. Without seeing the actual code content, function signature, or usage context, it's impossible to determine if this is genuinely dead code.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Duplicate entry of the same function. This appears to be an artifact of the analysis tool rather than separate instances of dead code.",
          "recommendation": "investigate",
          "evidence": [
            "Identical location to previous entries",
            "Likely duplicate detection rather than separate code instances"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Duplicate entry of the same function. This appears to be an artifact of the analysis tool rather than separate instances of dead code.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Third duplicate entry of the same function. Without the actual function implementation and surrounding context, cannot determine if it's truly unused.",
          "recommendation": "investigate",
          "evidence": [
            "Same location as previous entries",
            "Missing context about function purpose and potential usage"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Third duplicate entry of the same function. Without the actual function implementation and surrounding context, cannot determine if it's truly unused.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Fourth duplicate entry. The function name suggests it handles image rotation conversion, which could be used by an image processing pipeline even if not directly called in visible code.",
          "recommendation": "investigate",
          "evidence": [
            "Function name suggests image processing utility",
            "Could be used through configuration or dynamic dispatch"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Fourth duplicate entry. The function name suggests it handles image rotation conversion, which could be used by an image processing pipeline even if not directly called in visible code.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Fifth duplicate entry. In an image processing application, rotation conversion functions are commonly used but may be called indirectly through frameworks or configuration-driven pipelines.",
          "recommendation": "investigate",
          "evidence": [
            "Image processing functions often used indirectly",
            "May be called through plugin systems or configuration"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Fifth duplicate entry. In an image processing application, rotation conversion functions are commonly used but may be called indirectly through frameworks or configuration-driven pipelines.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "All 5 items reference the same function at the same location. Without seeing the actual code or usage patterns, it's unclear if this is a utility function used elsewhere in the application or genuinely unused.",
          "recommendation": "investigate",
          "evidence": [
            "Multiple identical references to same function location",
            "Insufficient context to determine usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "All 5 items reference the same function at the same location. Without seeing the actual code or usage patterns, it's unclear if this is a utility function used elsewhere in the application or genuinely unused.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Duplicate entry of the same function. Need to examine the actual function implementation and search for calls within the application codebase.",
          "recommendation": "investigate",
          "evidence": [
            "Same location as previous entry",
            "Pattern suggests potential dead code detection tool duplicates"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Duplicate entry of the same function. Need to examine the actual function implementation and search for calls within the application codebase.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Third reference to same function. This appears to be a utility function in an imagepipe module that may or may not be called by other parts of the application.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples directory which may indicate demo code",
            "Function name suggests image transformation utility"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Third reference to same function. This appears to be a utility function in an imagepipe module that may or may not be called by other parts of the application.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Fourth duplicate entry. The repetition suggests this function was flagged multiple times by analysis tools, possibly indicating it's genuinely unused.",
          "recommendation": "investigate",
          "evidence": [
            "Multiple flagging instances may indicate unused status",
            "Need to verify no dynamic calls or indirect usage"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Fourth duplicate entry. The repetition suggests this function was flagged multiple times by analysis tools, possibly indicating it's genuinely unused.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Fifth duplicate entry. Given this is in an examples directory of an application, it may be demonstration code that's not actively used in the main application flow.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/ subdirectory",
            "May be sample code not integrated into main application"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Fifth duplicate entry. Given this is in an examples directory of an application, it may be demonstration code that's not actively used in the main application flow.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "Function appears to be a utility method in an image processing pipeline example. Without seeing the full codebase context, it could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/imagepipe/ which suggests it's demonstration code",
            "Image processing pipelines often use functions like this in transformation chains"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "Function appears to be a utility method in an image processing pipeline example. Without seeing the full codebase context, it could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_rotation",
        "lineno": 165,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "Duplicate entry of the same function. Function appears to be a utility method in an image processing pipeline example. Without seeing the full codebase context, it could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/imagepipe/ which suggests it's demonstration code",
            "Image processing pipelines often use functions like this in transformation chains"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "Duplicate entry of the same function. Function appears to be a utility method in an image processing pipeline example. Without seeing the full codebase context, it could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in examples/validation/validation.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "Function appears to be a utility method in an image processing pipeline example. Similar to convert_rotation, this could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/imagepipe/ which suggests it's demonstration code",
            "Image processing pipelines often use functions like this in transformation chains"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "Function appears to be a utility method in an image processing pipeline example. Similar to convert_rotation, this could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "Duplicate entry of the same function. Function appears to be a utility method in an image processing pipeline example. Similar to convert_rotation, this could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/imagepipe/ which suggests it's demonstration code",
            "Image processing pipelines often use functions like this in transformation chains"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "Duplicate entry of the same function. Function appears to be a utility method in an image processing pipeline example. Similar to convert_rotation, this could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "Third duplicate entry of the same function. Function appears to be a utility method in an image processing pipeline example. Similar to convert_rotation, this could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/imagepipe/ which suggests it's demonstration code",
            "Image processing pipelines often use functions like this in transformation chains"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "Third duplicate entry of the same function. Function appears to be a utility method in an image processing pipeline example. Similar to convert_rotation, this could be part of a transformation pipeline that's called dynamically or used in configuration-driven processing.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 40,
          "category": "genuinely_unused",
          "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
          "recommendation": "investigate",
          "evidence": [
            "Same pattern reported 5 times at identical location (line 178)",
            "Insufficient context provided to determine actual usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 40,
        "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 40,
          "category": "genuinely_unused",
          "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
          "recommendation": "investigate",
          "evidence": [
            "Same pattern reported 5 times at identical location (line 178)",
            "Insufficient context provided to determine actual usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 40,
        "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 40,
          "category": "genuinely_unused",
          "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
          "recommendation": "investigate",
          "evidence": [
            "Same pattern reported 5 times at identical location (line 178)",
            "Insufficient context provided to determine actual usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 40,
        "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 40,
          "category": "genuinely_unused",
          "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
          "recommendation": "investigate",
          "evidence": [
            "Same pattern reported 5 times at identical location (line 178)",
            "Insufficient context provided to determine actual usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 40,
        "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 40,
          "category": "genuinely_unused",
          "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
          "recommendation": "investigate",
          "evidence": [
            "Same pattern reported 5 times at identical location (line 178)",
            "Insufficient context provided to determine actual usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 40,
        "reason": "Cannot determine usage without seeing the actual code implementation and call patterns. This appears to be a duplicate detection of the same pattern at the same location, which may indicate a false positive in the analysis tool.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Unable to determine usage without seeing the actual code implementation. This appears to be a pattern or function in an imagepipe application, but context is insufficient to assess if it's called elsewhere.",
          "recommendation": "investigate",
          "evidence": [
            "Location is in examples/imagepipe/ suggesting it's demonstration code",
            "Multiple identical entries suggest possible detection error or pattern matching issue"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Unable to determine usage without seeing the actual code implementation. This appears to be a pattern or function in an imagepipe application, but context is insufficient to assess if it's called elsewhere.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Duplicate entry of the same pattern at the same location. Without seeing the actual code, cannot determine if this image processing function is used in the pipeline.",
          "recommendation": "investigate",
          "evidence": [
            "Same location as previous entry suggests possible analysis error",
            "Image processing functions might be called dynamically or through configuration"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Duplicate entry of the same pattern at the same location. Without seeing the actual code, cannot determine if this image processing function is used in the pipeline.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Third duplicate entry of the same pattern. The repetition suggests an issue with the dead code detection tool rather than actual separate code instances.",
          "recommendation": "investigate",
          "evidence": [
            "Identical location to previous entries indicates possible tool malfunction",
            "Pattern-based detection might be incorrectly flagging the same code multiple times"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Third duplicate entry of the same pattern. The repetition suggests an issue with the dead code detection tool rather than actual separate code instances.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Fourth duplicate entry suggests systematic issue with the analysis tool. Cannot make accurate determination without actual code context and proper analysis.",
          "recommendation": "investigate",
          "evidence": [
            "Multiple identical entries indicate tool error rather than genuine code analysis",
            "Need to examine actual source code to determine real usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Fourth duplicate entry suggests systematic issue with the analysis tool. Cannot make accurate determination without actual code context and proper analysis.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "genuinely_unused",
          "reason": "Fifth duplicate entry confirms analysis tool malfunction. Real assessment requires examining the actual convert_flip implementation and its usage throughout the imagepipe application.",
          "recommendation": "investigate",
          "evidence": [
            "Five identical entries at same location proves tool error",
            "Need manual code review to determine if convert_flip is actually dead code"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Fifth duplicate entry confirms analysis tool malfunction. Real assessment requires examining the actual convert_flip implementation and its usage throughout the imagepipe application.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be a conversion pattern function that is defined but never called within the application codebase. Since this is an application project, all code should have internal usage.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Function is defined but has no internal callers in the application",
            "No evidence of external callback or framework usage patterns"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be a conversion pattern function that is defined but never called within the application codebase. Since this is an application project, all code should have internal usage.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be a conversion pattern function that is defined but never called within the application codebase. Since this is an application project, all code should have internal usage.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Function is defined but has no internal callers in the application",
            "No evidence of external callback or framework usage patterns"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be a conversion pattern function that is defined but never called within the application codebase. Since this is an application project, all code should have internal usage.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be a conversion pattern function that is defined but never called within the application codebase. Since this is an application project, all code should have internal usage.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Function is defined but has no internal callers in the application",
            "No evidence of external callback or framework usage patterns"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be a conversion pattern function that is defined but never called within the application codebase. Since this is an application project, all code should have internal usage.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "convert_flip",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be a conversion pattern function that is defined but never called within the application codebase. Since this is an application project, all code should have internal usage.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Function is defined but has no internal callers in the application",
            "No evidence of external callback or framework usage patterns"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be a conversion pattern function that is defined but never called within the application codebase. Since this is an application project, all code should have internal usage.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "processor",
        "lineno": 48,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 80,
          "category": "genuinely_unused",
          "reason": "This processor pattern function appears to be defined but never used internally in the application. In an application project, all code should have clear internal usage paths.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Function is defined but not called anywhere in the application codebase",
            "Located in examples directory suggests it may be leftover example code"
          ]
        },
        "status": "dead_code",
        "confidence": 80,
        "reason": "This processor pattern function appears to be defined but never used internally in the application. In an application project, all code should have clear internal usage paths.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/imagepipe/imagepipe.py",
        "name": "processor",
        "lineno": 48,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "callback",
          "reason": "This appears to be a pattern in an image processing pipeline example. Without seeing the full code context, it could be a callback function or processing step that gets invoked by the pipeline framework. The name 'processor' suggests it's meant to be called by the imagepipe system.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/imagepipe suggesting it's part of a processing pipeline",
            "Name 'processor' indicates callback or hook function pattern"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "This appears to be a pattern in an image processing pipeline example. Without seeing the full code context, it could be a callback function or processing step that gets invoked by the pipeline framework. The name 'processor' suggests it's meant to be called by the imagepipe system.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/naval/naval.py",
        "name": "ship",
        "lineno": 16,
        "pattern_type": "similar_function_names",
        "details": "Similar to ship_new in examples/naval/naval.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 65,
          "category": "callback",
          "reason": "This appears to be a pattern in a naval game/simulation example. The pattern could be used for ship movement, collision detection, or AI behavior that gets called by the game engine or simulation framework. Without full context, it's likely part of the game's entity system.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/naval suggesting game/simulation code",
            "Ship patterns often used in game loops or collision systems"
          ]
        },
        "status": "uncertain",
        "confidence": 65,
        "reason": "This appears to be a pattern in a naval game/simulation example. The pattern could be used for ship movement, collision detection, or AI behavior that gets called by the game engine or simulation framework. Without full context, it's likely part of the game's entity system.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/naval/naval.py",
        "name": "ship",
        "lineno": 16,
        "pattern_type": "similar_function_names",
        "details": "Similar to ship_move in examples/naval/naval.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 80,
          "category": "genuinely_unused",
          "reason": "This is a duplicate of the previous ship pattern at the same location. Having multiple identical patterns at line 16 suggests copy-paste code or refactoring leftovers that are no longer needed.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Duplicate pattern at same location as previous item",
            "Multiple identical patterns suggest redundant code"
          ]
        },
        "status": "dead_code",
        "confidence": 80,
        "reason": "This is a duplicate of the previous ship pattern at the same location. Having multiple identical patterns at line 16 suggests copy-paste code or refactoring leftovers that are no longer needed.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/naval/naval.py",
        "name": "ship",
        "lineno": 16,
        "pattern_type": "similar_function_names",
        "details": "Similar to ship_shoot in examples/naval/naval.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This is another duplicate of the ship pattern at line 16. Three identical patterns at the same location strongly indicates dead code from incomplete refactoring or copy-paste errors that should be cleaned up.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Third duplicate pattern at same location",
            "Multiple identical patterns are clear indication of dead code"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This is another duplicate of the ship pattern at line 16. Three identical patterns at the same location strongly indicates dead code from incomplete refactoring or copy-paste errors that should be cleaned up.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/naval/naval.py",
        "name": "mine",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to mine_set in examples/naval/naval.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 70,
          "category": "callback",
          "reason": "This appears to be a mine pattern in the naval simulation, likely used for collision detection, explosion triggers, or AI behavior. Similar to the ship pattern, it could be called by the game engine's collision system or event handlers.",
          "recommendation": "investigate",
          "evidence": [
            "Part of naval simulation example code",
            "Mine patterns typically used in collision/trigger systems"
          ]
        },
        "status": "uncertain",
        "confidence": 70,
        "reason": "This appears to be a mine pattern in the naval simulation, likely used for collision detection, explosion triggers, or AI behavior. Similar to the ship pattern, it could be called by the game engine's collision system or event handlers.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/naval/naval.py",
        "name": "mine",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to mine_remove in examples/naval/naval.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be a pattern or variable in an example file that is not referenced elsewhere. Example files typically contain demonstration code that may include unused patterns for illustration purposes.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples directory which contains demonstration code",
            "No apparent usage found in the codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be a pattern or variable in an example file that is not referenced elsewhere. Example files typically contain demonstration code that may include unused patterns for illustration purposes.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "progress",
        "lineno": 38,
        "pattern_type": "similar_function_names",
        "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be an unused pattern or variable in a terminal UI example. Since this is in an examples directory and is application code, any unused patterns are likely dead code.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui directory indicating demonstration code",
            "Pattern appears to be unused based on static analysis"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be an unused pattern or variable in a terminal UI example. Since this is in an examples directory and is application code, any unused patterns are likely dead code.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "progress",
        "lineno": 38,
        "pattern_type": "similar_function_names",
        "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "Duplicate occurrence of the same unused progress pattern in the terminal UI example file. Multiple instances of the same unused pattern suggest copy-paste or leftover code.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Duplicate of another unused pattern in the same file",
            "Located in examples directory with no apparent usage"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "Duplicate occurrence of the same unused progress pattern in the terminal UI example file. Multiple instances of the same unused pattern suggest copy-paste or leftover code.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "progress",
        "lineno": 38,
        "pattern_type": "similar_function_names",
        "details": "Similar to progressbar in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "Third occurrence of the same unused progress pattern. Multiple instances of unused patterns in example code are typically remnants from development or copy-paste operations.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Third instance of the same unused pattern",
            "Consistent with other unused progress patterns in the same file"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "Third occurrence of the same unused progress pattern. Multiple instances of unused patterns in example code are typically remnants from development or copy-paste operations.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "open",
        "lineno": 105,
        "pattern_type": "similar_function_names",
        "details": "Similar to open_stream in src/click/_compat.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "While this appears to be an unused pattern in example code, 'open' could potentially be a built-in override or have special significance in the terminal UI context that may not be immediately apparent.",
          "recommendation": "investigate",
          "evidence": [
            "Located in examples/termui which may have special patterns",
            "'open' is a common Python built-in that might be intentionally shadowed"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "While this appears to be an unused pattern in example code, 'open' could potentially be a built-in override or have special significance in the terminal UI context that may not be immediately apparent.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "open",
        "lineno": 105,
        "pattern_type": "similar_function_names",
        "details": "Similar to open_url in src/click/_termui_impl.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui/ which suggests demo/example code",
            "No evidence of the function being called elsewhere in the codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "open",
        "lineno": 105,
        "pattern_type": "similar_function_names",
        "details": "Similar to open_file in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui/ which suggests demo/example code",
            "Duplicate detection of the same function indicates it's unused"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "edit",
        "lineno": 118,
        "pattern_type": "similar_function_names",
        "details": "Similar to edit_files in src/click/_termui_impl.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui/ which suggests demo/example code",
            "No evidence of the function being called elsewhere in the codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "process_slowly",
        "lineno": 42,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui/ which suggests demo/example code",
            "No evidence of the function being called elsewhere in the codebase"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "process_slowly",
        "lineno": 42,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui/ which suggests demo/example code",
            "Duplicate detection of the same function indicates it's unused"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be an example function in a demo file that is not called anywhere in the application. Example files typically contain demonstration code that may not be actively used.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "show_item",
        "lineno": 56,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This appears to be in an examples directory which is typically demonstration code that may not be actively used. In an application project, example code that isn't called is dead code.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui directory suggesting demo/example code",
            "No indication this is part of active application functionality"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This appears to be in an examples directory which is typically demonstration code that may not be actively used. In an application project, example code that isn't called is dead code.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "show_item",
        "lineno": 56,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "Duplicate entry of the same function in examples directory. In an application project, unused example code should be removed.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui directory suggesting demo/example code",
            "Same function as previous item, likely unused demonstration code"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "Duplicate entry of the same function in examples directory. In an application project, unused example code should be removed.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/termui/termui.py",
        "name": "show_item",
        "lineno": 56,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "Third duplicate entry of the same function in examples directory. Clearly unused demonstration code in an application project.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/termui directory suggesting demo/example code",
            "Multiple duplicate entries suggest this is unused example code"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "Third duplicate entry of the same function in examples directory. Clearly unused demonstration code in an application project.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "examples/validation/validation.py",
        "name": "convert",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 80,
          "category": "genuinely_unused",
          "reason": "Located in examples/validation directory which suggests this is demonstration code. In an application project, unused example validation code is dead code.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Located in examples/validation directory indicating demo code",
            "No evidence of being called in actual application logic"
          ]
        },
        "status": "dead_code",
        "confidence": 80,
        "reason": "Located in examples/validation directory which suggests this is demonstration code. In an application project, unused example validation code is dead code.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "src/click/_compat.py",
        "name": "get_text_stdin",
        "lineno": 337,
        "pattern_type": "similar_function_names",
        "details": "Similar to _get_text_stdin in src/click/_winconsole.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 75,
          "category": "public_api",
          "reason": "Located in src/click/_compat.py which is a compatibility module. Functions in compat modules are typically used internally by the framework or exposed as utilities.",
          "recommendation": "keep",
          "evidence": [
            "Located in _compat.py suggesting it's a compatibility utility function",
            "Part of the main src code rather than examples, likely used by click internals"
          ]
        },
        "status": "false_positive",
        "confidence": 75,
        "reason": "Located in src/click/_compat.py which is a compatibility module. Functions in compat modules are typically used internally by the framework or exposed as utilities.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "get_text_stdout",
        "lineno": 344,
        "pattern_type": "similar_function_names",
        "details": "Similar to _get_text_stdout in src/click/_winconsole.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This function is in a _compat module which typically provides compatibility utilities for the click library. It's likely used by the public API or meant to be used by users for text output handling.",
          "recommendation": "keep",
          "evidence": [
            "Located in _compat module which suggests it's a compatibility utility",
            "Function name suggests it's for getting text stdout, a common need in CLI libraries"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This function is in a _compat module which typically provides compatibility utilities for the click library. It's likely used by the public API or meant to be used by users for text output handling.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "get_text_stderr",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to _get_text_stderr in src/click/_winconsole.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Similar to get_text_stdout, this function is in the compatibility module and provides stderr text handling functionality. It's likely part of the public API or used internally by click's core functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in _compat module which suggests it's a compatibility utility",
            "Function name suggests it's for getting text stderr, a common need in CLI libraries"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Similar to get_text_stdout, this function is in the compatibility module and provides stderr text handling functionality. It's likely part of the public API or used internally by click's core functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "open_stream",
        "lineno": 371,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This function is in the compatibility module and likely provides stream opening functionality that abstracts platform differences. It's probably used by click's file handling or could be part of the public API.",
          "recommendation": "keep",
          "evidence": [
            "Located in _compat module indicating it handles compatibility concerns",
            "Stream opening is a fundamental operation in CLI applications"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This function is in the compatibility module and likely provides stream opening functionality that abstracts platform differences. It's probably used by click's file handling or could be part of the public API.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "read1",
        "lineno": 105,
        "pattern_type": "similar_function_names",
        "details": "Similar to read in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 75,
          "category": "interface_method",
          "reason": "This appears to be a method that implements a file-like interface, likely the read1() method from the BufferedIOBase protocol. Such methods are called by Python's I/O system rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'read1' matches BufferedIOBase protocol method",
            "Located in _compat module suggesting it's part of compatibility layer for file-like objects"
          ]
        },
        "status": "false_positive",
        "confidence": 75,
        "reason": "This appears to be a method that implements a file-like interface, likely the read1() method from the BufferedIOBase protocol. Such methods are called by Python's I/O system rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "readable",
        "lineno": 113,
        "pattern_type": "similar_function_names",
        "details": "Similar to read in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "interface_method",
          "reason": "This is likely implementing the readable() method from Python's IOBase protocol. These protocol methods are called by Python's I/O system and other code that checks stream capabilities, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'readable' matches IOBase protocol method",
            "Protocol methods are called by Python's I/O system rather than application code directly"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This is likely implementing the readable() method from Python's IOBase protocol. These protocol methods are called by Python's I/O system and other code that checks stream capabilities, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "close",
        "lineno": 463,
        "pattern_type": "similar_function_names",
        "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a close method implementing a context manager or file-like interface protocol. Such methods are called by Python's runtime or frameworks, not necessarily by internal application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'close' follows standard Python protocol conventions",
            "Located in _compat.py suggesting it's part of compatibility layer implementation"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a close method implementing a context manager or file-like interface protocol. Such methods are called by Python's runtime or frameworks, not necessarily by internal application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "__exit__",
        "lineno": 476,
        "pattern_type": "similar_function_names",
        "details": "Similar to exit in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 98,
          "category": "interface_method",
          "reason": "__exit__ is a special method implementing the context manager protocol. It's automatically called by Python when exiting a 'with' statement, not by direct internal calls.",
          "recommendation": "keep",
          "evidence": [
            "Dunder method __exit__ is part of Python's context manager protocol",
            "Context manager methods are called by Python runtime, not application code directly"
          ]
        },
        "status": "false_positive",
        "confidence": 98,
        "reason": "__exit__ is a special method implementing the context manager protocol. It's automatically called by Python when exiting a 'with' statement, not by direct internal calls.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_compat.py",
        "name": "func",
        "lineno": 585,
        "pattern_type": "similar_function_names",
        "details": "Similar to function in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "callback",
          "reason": "Without seeing the code context, this could be a function property or callback. In _compat.py, it's likely part of a compatibility wrapper that stores or returns function references.",
          "recommendation": "investigate",
          "evidence": [
            "Located in compatibility module suggesting it's part of abstraction layer",
            "Name 'func' suggests it holds or returns function references"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "Without seeing the code context, this could be a function property or callback. In _compat.py, it's likely part of a compatibility wrapper that stores or returns function references.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/_compat.py",
        "name": "func",
        "lineno": 585,
        "pattern_type": "similar_function_names",
        "details": "Similar to func_name in src/click/shell_completion.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "callback",
          "reason": "This appears to be the same pattern as the previous func entry. Without code context, it's likely a function property or callback mechanism in the compatibility layer.",
          "recommendation": "investigate",
          "evidence": [
            "Duplicate pattern suggests consistent usage across compatibility layer",
            "Function properties are often accessed rather than called directly"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "This appears to be the same pattern as the previous func entry. Without code context, it's likely a function property or callback mechanism in the compatibility layer.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "open_url",
        "lineno": 676,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a utility function for opening URLs, likely part of Click's terminal UI functionality. Such utilities are often called conditionally or by external code paths not detected by static analysis.",
          "recommendation": "keep",
          "evidence": [
            "Located in _termui_impl.py suggesting it's part of terminal UI implementation",
            "URL opening functionality is typically called conditionally based on user actions or system state"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a utility function for opening URLs, likely part of Click's terminal UI functionality. Such utilities are often called conditionally or by external code paths not detected by static analysis.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "__exit__",
        "lineno": 120,
        "pattern_type": "similar_function_names",
        "details": "Similar to exit in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "__exit__ is part of Python's context manager protocol. It's called automatically by the Python runtime when exiting a 'with' statement, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Part of context manager protocol (__enter__/__exit__)",
            "Called automatically by Python runtime during 'with' statement cleanup"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "__exit__ is part of Python's context manager protocol. It's called automatically by the Python runtime when exiting a 'with' statement, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "edit_files",
        "lineno": 594,
        "pattern_type": "similar_function_names",
        "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a utility function in Click's terminal UI implementation module. Click is a library for creating command-line interfaces, and this function is likely part of the public API for file editing functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in Click library's _termui_impl module",
            "Function name suggests file editing utility functionality for CLI applications"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a utility function in Click's terminal UI implementation module. Click is a library for creating command-line interfaces, and this function is likely part of the public API for file editing functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "edit_files",
        "lineno": 594,
        "pattern_type": "similar_function_names",
        "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate entry of the same edit_files function. This appears to be a utility function in Click's terminal UI implementation module that provides file editing functionality for CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Same function as previous entry",
            "Part of Click library's terminal UI utilities"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate entry of the same edit_files function. This appears to be a utility function in Click's terminal UI implementation module that provides file editing functionality for CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "edit_files",
        "lineno": 594,
        "pattern_type": "similar_function_names",
        "details": "Similar to edit in src/click/_termui_impl.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Another duplicate entry of the same edit_files function. This function is part of Click's terminal UI implementation and provides file editing capabilities for command-line applications.",
          "recommendation": "keep",
          "evidence": [
            "Same function as previous entries",
            "Part of Click library's public API for file editing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Another duplicate entry of the same edit_files function. This function is part of Click's terminal UI implementation and provides file editing capabilities for command-line applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "edit_files",
        "lineno": 594,
        "pattern_type": "similar_function_names",
        "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Final duplicate entry of the edit_files function. This function is part of Click's terminal UI utilities and provides file editing functionality that may be used by CLI applications built with Click.",
          "recommendation": "keep",
          "evidence": [
            "Same function as all previous entries",
            "Part of Click's terminal UI implementation for file editing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Final duplicate entry of the edit_files function. This function is part of Click's terminal UI utilities and provides file editing functionality that may be used by CLI applications built with Click.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "edit_files",
        "lineno": 594,
        "pattern_type": "similar_function_names",
        "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "The edit_files function is part of Click's terminal UI implementation and is likely used as a public API for file editing functionality. Even in an application context, this appears to be a utility function that may be called by other parts of the Click framework.",
          "recommendation": "keep",
          "evidence": [
            "Located in _termui_impl.py which suggests it's part of Click's terminal UI implementation",
            "Function name suggests it's a utility for file editing operations"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "The edit_files function is part of Click's terminal UI implementation and is likely used as a public API for file editing functionality. Even in an application context, this appears to be a utility function that may be called by other parts of the Click framework.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "edit_files",
        "lineno": 594,
        "pattern_type": "similar_function_names",
        "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of the first edit_files entry. The edit_files function is part of Click's terminal UI implementation and is likely used as a public API for file editing functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in _termui_impl.py which suggests it's part of Click's terminal UI implementation",
            "Function name suggests it's a utility for file editing operations"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of the first edit_files entry. The edit_files function is part of Click's terminal UI implementation and is likely used as a public API for file editing functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "edit_files",
        "lineno": 594,
        "pattern_type": "similar_function_names",
        "details": "Similar to edit in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of the previous edit_files entries. The edit_files function is part of Click's terminal UI implementation and is likely used as a public API for file editing functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in _termui_impl.py which suggests it's part of Click's terminal UI implementation",
            "Function name suggests it's a utility for file editing operations"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of the previous edit_files entries. The edit_files function is part of Click's terminal UI implementation and is likely used as a public API for file editing functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "getchar",
        "lineno": 767,
        "pattern_type": "similar_function_names",
        "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "The getchar function is a low-level terminal input function that's typically called by the system or terminal handling code rather than directly by application code. It's part of Click's terminal UI implementation for character input.",
          "recommendation": "keep",
          "evidence": [
            "Located in _termui_impl.py indicating it's part of terminal interface implementation",
            "getchar is a standard terminal input function pattern that's called by system/framework code"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "The getchar function is a low-level terminal input function that's typically called by the system or terminal handling code rather than directly by application code. It's part of Click's terminal UI implementation for character input.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_termui_impl.py",
        "name": "getchar",
        "lineno": 844,
        "pattern_type": "similar_function_names",
        "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Duplicate of the previous getchar entry. This is a low-level terminal input function that's typically called by the system or terminal handling code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _termui_impl.py indicating it's part of terminal interface implementation",
            "getchar is a standard terminal input function pattern that's called by system/framework code"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Duplicate of the previous getchar entry. This is a low-level terminal input function that's typically called by the system or terminal handling code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_textwrap.py",
        "name": "indent_only",
        "lineno": 40,
        "pattern_type": "similar_function_names",
        "details": "Similar to indent in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "This appears to be a regex pattern in a text wrapping module. Without seeing the full context, it could be used for text formatting operations that may be called conditionally or through dynamic code paths.",
          "recommendation": "investigate",
          "evidence": [
            "Located in _textwrap.py suggesting text processing functionality",
            "Patterns are often used dynamically making static analysis difficult"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "This appears to be a regex pattern in a text wrapping module. Without seeing the full context, it could be used for text formatting operations that may be called conditionally or through dynamic code paths.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "readable",
        "lineno": 128,
        "pattern_type": "similar_function_names",
        "details": "Similar to read in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be implementing the readable() method of a file-like object interface. This is a standard Python protocol method that may be called by the Python runtime or other code expecting a file-like object.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting console/stream handling",
            "readable() is a standard file-like object protocol method"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be implementing the readable() method of a file-like object interface. This is a standard Python protocol method that may be called by the Python runtime or other code expecting a file-like object.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "readinto",
        "lineno": 131,
        "pattern_type": "similar_function_names",
        "details": "Similar to read in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This implements the readinto() method of the file-like object protocol. This is a standard Python buffer protocol method that can be called by the runtime or other code expecting a buffered reader interface.",
          "recommendation": "keep",
          "evidence": [
            "readinto() is part of the standard Python buffered I/O protocol",
            "Located in console handling code where buffer operations are expected"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This implements the readinto() method of the file-like object protocol. This is a standard Python buffer protocol method that can be called by the runtime or other code expecting a buffered reader interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 174,
        "pattern_type": "similar_function_names",
        "details": "Similar to writelines in src/click/_winconsole.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This implements the write() method of a file-like object. This is a fundamental method of the Python file protocol that will be called by the runtime and other code treating this object as a writable stream.",
          "recommendation": "keep",
          "evidence": [
            "write() is a core method of Python's file-like object protocol",
            "Essential for console/stream functionality in Windows console handling"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This implements the write() method of a file-like object. This is a fundamental method of the Python file protocol that will be called by the runtime and other code treating this object as a writable stream.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 174,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Same as the previous write method - this implements the essential write() method for file-like objects. May be a duplicate entry in the analysis but represents the same protocol method implementation.",
          "recommendation": "keep",
          "evidence": [
            "Duplicate of the previous write() method analysis",
            "Still represents essential file protocol functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Same as the previous write method - this implements the essential write() method for file-like objects. May be a duplicate entry in the analysis but represents the same protocol method implementation.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 174,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in a Windows console wrapper class that implements a file-like interface. Such methods are typically called by Python's I/O system or click's output handling mechanisms rather than directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console handling",
            "write() is a standard file-like interface method called by print(), sys.stdout, etc."
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in a Windows console wrapper class that implements a file-like interface. Such methods are typically called by Python's I/O system or click's output handling mechanisms rather than directly in application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 174,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in a Windows console wrapper class that implements a file-like interface. Such methods are typically called by Python's I/O system or click's output handling mechanisms rather than directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console handling",
            "write() is a standard file-like interface method called by print(), sys.stdout, etc."
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in a Windows console wrapper class that implements a file-like interface. Such methods are typically called by Python's I/O system or click's output handling mechanisms rather than directly in application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 174,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in a Windows console wrapper class that implements a file-like interface. Such methods are typically called by Python's I/O system or click's output handling mechanisms rather than directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console handling",
            "write() is a standard file-like interface method called by print(), sys.stdout, etc."
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in a Windows console wrapper class that implements a file-like interface. Such methods are typically called by Python's I/O system or click's output handling mechanisms rather than directly in application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 174,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in a Windows console wrapper class that implements a file-like interface. Such methods are typically called by Python's I/O system or click's output handling mechanisms rather than directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console handling",
            "write() is a standard file-like interface method called by print(), sys.stdout, etc."
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in a Windows console wrapper class that implements a file-like interface. Such methods are typically called by Python's I/O system or click's output handling mechanisms rather than directly in application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 203,
        "pattern_type": "similar_function_names",
        "details": "Similar to writelines in src/click/_winconsole.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This is another write method in the Windows console module, likely in a different class or context but serving the same purpose of implementing a file-like interface. These methods are called by Python's I/O infrastructure.",
          "recommendation": "keep",
          "evidence": [
            "Part of Windows console handling in click library",
            "write() methods implement file-like protocol used by Python's output system"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is another write method in the Windows console module, likely in a different class or context but serving the same purpose of implementing a file-like interface. These methods are called by Python's I/O infrastructure.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 203,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console I/O handling",
            "Write methods commonly implement file-like protocols called by Python internals"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 203,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console I/O handling",
            "Write methods commonly implement file-like protocols called by Python internals"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 203,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console I/O handling",
            "Write methods commonly implement file-like protocols called by Python internals"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 203,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console I/O handling",
            "Write methods commonly implement file-like protocols called by Python internals"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "write",
        "lineno": 203,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in _winconsole.py suggesting Windows-specific console I/O handling",
            "Write methods commonly implement file-like protocols called by Python internals"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a write method in Windows console handling code, likely implementing a file-like interface. Such methods are typically called by Python's I/O system or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "writelines",
        "lineno": 212,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "The writelines method is part of the file-like object protocol in Python. It's expected to be called by external code or Python's built-in functions that work with file-like objects.",
          "recommendation": "keep",
          "evidence": [
            "Method implements standard file-like object interface",
            "Located in _winconsole.py suggesting it's used for console I/O operations"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "The writelines method is part of the file-like object protocol in Python. It's expected to be called by external code or Python's built-in functions that work with file-like objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/_winconsole.py",
        "name": "writelines",
        "lineno": 212,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "Duplicate of item #1. The writelines method is part of the file-like object protocol in Python. It's expected to be called by external code or Python's built-in functions that work with file-like objects.",
          "recommendation": "keep",
          "evidence": [
            "Method implements standard file-like object interface",
            "Located in _winconsole.py suggesting it's used for console I/O operations"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of item #1. The writelines method is part of the file-like object protocol in Python. It's expected to be called by external code or Python's built-in functions that work with file-like objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "_check_iter",
        "lineno": 2017,
        "pattern_type": "similar_function_names",
        "details": "Similar to check_iter in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "This appears to be an internal helper method (prefixed with underscore). Without seeing the code context, it could be a validation utility that should be called but isn't, or legitimate dead code in an application.",
          "recommendation": "investigate",
          "evidence": [
            "Private method naming convention suggests internal use",
            "Located in core.py which is likely central to the application"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "This appears to be an internal helper method (prefixed with underscore). Without seeing the code context, it could be a validation utility that should be called but isn't, or legitimate dead code in an application.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/core.py",
        "name": "__exit__",
        "lineno": 481,
        "pattern_type": "similar_function_names",
        "details": "Similar to exit in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The __exit__ method is part of Python's context manager protocol. It's automatically called by the Python interpreter when exiting a 'with' statement block.",
          "recommendation": "keep",
          "evidence": [
            "Part of context manager protocol (__enter__/__exit__)",
            "Called automatically by Python runtime, not by user code directly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The __exit__ method is part of Python's context manager protocol. It's automatically called by the Python interpreter when exiting a 'with' statement block.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "close",
        "lineno": 616,
        "pattern_type": "similar_function_names",
        "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "interface_method",
          "reason": "The close method is a standard interface method for resource cleanup. It may be called by context managers, cleanup routines, or external code following standard Python conventions.",
          "recommendation": "keep",
          "evidence": [
            "Standard method name for resource cleanup",
            "Often called by context managers or cleanup frameworks"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "The close method is a standard interface method for resource cleanup. It may be called by context managers, cleanup routines, or external code following standard Python conventions.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "command_path",
        "lineno": 642,
        "pattern_type": "similar_function_names",
        "details": "Similar to command in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "All five items point to the same location (src/click/core.py:642) and are identified only as 'command_path (pattern)' without additional context. Without seeing the actual code or understanding what specific pattern or method this refers to, it's impossible to make a definitive determination.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location and description",
            "No code context provided to analyze usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "All five items point to the same location (src/click/core.py:642) and are identified only as 'command_path (pattern)' without additional context. Without seeing the actual code or understanding what specific pattern or method this refers to, it's impossible to make a definitive determination.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/core.py",
        "name": "command_path",
        "lineno": 642,
        "pattern_type": "similar_function_names",
        "details": "Similar to command in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Duplicate entry with insufficient information to analyze. The repeated identical entries suggest either a data collection issue or multiple references to the same code pattern that requires investigation.",
          "recommendation": "investigate",
          "evidence": [
            "Identical to previous entries",
            "Insufficient context for proper analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Duplicate entry with insufficient information to analyze. The repeated identical entries suggest either a data collection issue or multiple references to the same code pattern that requires investigation.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/core.py",
        "name": "command_path",
        "lineno": 642,
        "pattern_type": "similar_function_names",
        "details": "Similar to command in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Another duplicate entry pointing to the same location. Without access to the actual code at line 642 or understanding what 'command_path (pattern)' specifically refers to, proper dead code analysis cannot be performed.",
          "recommendation": "investigate",
          "evidence": [
            "Third identical entry",
            "Location src/click/core.py suggests Click library code"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Another duplicate entry pointing to the same location. Without access to the actual code at line 642 or understanding what 'command_path (pattern)' specifically refers to, proper dead code analysis cannot be performed.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/core.py",
        "name": "command_path",
        "lineno": 642,
        "pattern_type": "similar_function_names",
        "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Fourth duplicate entry with same insufficient information. The Click library context suggests this could be part of command-line interface functionality, but without seeing the actual implementation, status cannot be determined.",
          "recommendation": "investigate",
          "evidence": [
            "Fourth identical entry",
            "Click is a command-line library where command paths are important"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Fourth duplicate entry with same insufficient information. The Click library context suggests this could be part of command-line interface functionality, but without seeing the actual implementation, status cannot be determined.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/core.py",
        "name": "command_path",
        "lineno": 642,
        "pattern_type": "similar_function_names",
        "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Final duplicate entry. The repetition of identical entries suggests a systematic issue in the dead code detection tool or data collection process that needs investigation before making removal decisions.",
          "recommendation": "investigate",
          "evidence": [
            "Fifth identical entry indicating potential tooling issue",
            "Need actual code inspection to make informed decision"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Final duplicate entry. The repetition of identical entries suggests a systematic issue in the dead code detection tool or data collection process that needs investigation before making removal decisions.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/core.py",
        "name": "command_path",
        "lineno": 642,
        "pattern_type": "similar_function_names",
        "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a property or method in Click's core Context class that provides the command path for CLI applications. Click is a library for building command-line interfaces, and this would be part of the public API for users to access command hierarchy information.",
          "recommendation": "keep",
          "evidence": [
            "Located in core.py which contains fundamental Click classes",
            "Command path functionality is essential for CLI frameworks to track command hierarchy"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a property or method in Click's core Context class that provides the command path for CLI applications. Click is a library for building command-line interfaces, and this would be part of the public API for users to access command hierarchy information.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "command_path",
        "lineno": 642,
        "pattern_type": "similar_function_names",
        "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of the previous item - this is the same command_path functionality in Click's core module. As part of a CLI framework's public API, it would be accessed by users building command-line applications.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous item in core.py",
            "Essential CLI framework functionality for command path tracking"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of the previous item - this is the same command_path functionality in Click's core module. As part of a CLI framework's public API, it would be accessed by users building command-line applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "command_path",
        "lineno": 642,
        "pattern_type": "similar_function_names",
        "details": "Similar to command in src/click/decorators.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Another duplicate of the command_path functionality. This is part of Click's public API for accessing command hierarchy information in CLI applications built with the framework.",
          "recommendation": "keep",
          "evidence": [
            "Same core.py location as other command_path items",
            "Public API method for CLI command path access"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Another duplicate of the command_path functionality. This is part of Click's public API for accessing command hierarchy information in CLI applications built with the framework.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "exit",
        "lineno": 730,
        "pattern_type": "similar_function_names",
        "details": "Similar to __exit__ in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is likely the exit method in Click's Context class, which is a fundamental part of the CLI framework's public API. It allows controlled termination of CLI applications with proper exit codes and cleanup.",
          "recommendation": "keep",
          "evidence": [
            "Located in core.py which contains Click's main classes",
            "Exit functionality is essential for CLI applications and would be called by user code"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely the exit method in Click's Context class, which is a fundamental part of the CLI framework's public API. It allows controlled termination of CLI applications with proper exit codes and cleanup.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "exit",
        "lineno": 730,
        "pattern_type": "similar_function_names",
        "details": "Similar to __exit__ in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Duplicate of the previous exit method - this is the same functionality for controlled CLI application termination. As part of Click's public API, it would be used by applications built with the framework.",
          "recommendation": "keep",
          "evidence": [
            "Same location in core.py as previous exit item",
            "Core CLI framework functionality for application termination"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Duplicate of the previous exit method - this is the same functionality for controlled CLI application termination. As part of Click's public API, it would be used by applications built with the framework.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_usage",
        "lineno": 740,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be a public API method in Click's core module. Click is a command-line interface library where get_usage would be called by the framework to generate usage strings for help text.",
          "recommendation": "keep",
          "evidence": [
            "Located in click/core.py which is part of Click's public API",
            "get_usage is a standard method name for CLI frameworks to generate help text",
            "Click framework likely calls this internally during command processing"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a public API method in Click's core module. Click is a command-line interface library where get_usage would be called by the framework to generate usage strings for help text.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_usage",
        "lineno": 740,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be a public API method in Click's core module. Click is a command-line interface library where get_usage would be called by the framework to generate usage strings for help text.",
          "recommendation": "keep",
          "evidence": [
            "Located in click/core.py which is part of Click's public API",
            "get_usage is a standard method name for CLI frameworks to generate help text",
            "Click framework likely calls this internally during command processing"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a public API method in Click's core module. Click is a command-line interface library where get_usage would be called by the framework to generate usage strings for help text.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help",
        "lineno": 746,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_option_names in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public API method in Click's core module for generating help text. The Click framework calls this method when users request help for commands using --help flag.",
          "recommendation": "keep",
          "evidence": [
            "Located in click/core.py which is core Click functionality",
            "get_help is essential for CLI help system functionality",
            "Called by Click framework when --help is invoked"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public API method in Click's core module for generating help text. The Click framework calls this method when users request help for commands using --help flag.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help",
        "lineno": 746,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_option in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public API method in Click's core module for generating help text. The Click framework calls this method when users request help for commands using --help flag.",
          "recommendation": "keep",
          "evidence": [
            "Located in click/core.py which is core Click functionality",
            "get_help is essential for CLI help system functionality",
            "Called by Click framework when --help is invoked"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public API method in Click's core module for generating help text. The Click framework calls this method when users request help for commands using --help flag.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help",
        "lineno": 746,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public API method in Click's core module for generating help text. The Click framework calls this method when users request help for commands using --help flag.",
          "recommendation": "keep",
          "evidence": [
            "Located in click/core.py which is core Click functionality",
            "get_help is essential for CLI help system functionality",
            "Called by Click framework when --help is invoked"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public API method in Click's core module for generating help text. The Click framework calls this method when users request help for commands using --help flag.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help",
        "lineno": 746,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public API method in the Click library's core Context class. It's designed to be called by users and the Click framework itself to generate help text for commands.",
          "recommendation": "keep",
          "evidence": [
            "Click is a library for creating command-line interfaces",
            "get_help is a fundamental method for displaying help information",
            "Method is part of the core Context class which is central to Click's API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public API method in the Click library's core Context class. It's designed to be called by users and the Click framework itself to generate help text for commands.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help",
        "lineno": 746,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_extra in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a duplicate entry of the same public API method in the Click library's core Context class. It's designed to be called by users and the Click framework itself to generate help text for commands.",
          "recommendation": "keep",
          "evidence": [
            "Click is a library for creating command-line interfaces",
            "get_help is a fundamental method for displaying help information",
            "Method is part of the core Context class which is central to Click's API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a duplicate entry of the same public API method in the Click library's core Context class. It's designed to be called by users and the Click framework itself to generate help text for commands.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_usage",
        "lineno": 993,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public API method in the Click library's core class used to generate usage strings for commands. It's essential functionality that users and the framework call to display command usage information.",
          "recommendation": "keep",
          "evidence": [
            "Click is a command-line interface library where usage information is critical",
            "get_usage is a standard method for generating command usage strings",
            "Part of Click's core API for command-line help systems"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public API method in the Click library's core class used to generate usage strings for commands. It's essential functionality that users and the framework call to display command usage information.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_usage",
        "lineno": 993,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_usage_pieces in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a duplicate entry of the same public API method in the Click library's core class used to generate usage strings for commands. It's essential functionality that users and the framework call to display command usage information.",
          "recommendation": "keep",
          "evidence": [
            "Click is a command-line interface library where usage information is critical",
            "get_usage is a standard method for generating command usage strings",
            "Part of Click's core API for command-line help systems"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a duplicate entry of the same public API method in the Click library's core class used to generate usage strings for commands. It's essential functionality that users and the framework call to display command usage information.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help_option_names",
        "lineno": 1046,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_option in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a public API method in Click's core library used to retrieve the names of help options (like --help, -h). It's part of Click's help system infrastructure and would be called by the framework and potentially by users customizing help behavior.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows Click's pattern for help-related functionality",
            "Click library needs to manage help option names for command parsing",
            "Part of the core help system that users may need to customize or query"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a public API method in Click's core library used to retrieve the names of help options (like --help, -h). It's part of Click's help system infrastructure and would be called by the framework and potentially by users customizing help behavior.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help_option_names",
        "lineno": 1046,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is part of the BaseCommand class in click, which is a library framework. It provides a way for users to customize help option names and is likely part of the public API for command customization.",
          "recommendation": "keep",
          "evidence": [
            "Located in BaseCommand class which is core to click's public interface",
            "Method name suggests it's designed for customization/extension by users"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of the BaseCommand class in click, which is a library framework. It provides a way for users to customize help option names and is likely part of the public API for command customization.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help_option",
        "lineno": 1054,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is part of the BaseCommand class and appears to be designed for users to override or customize help option behavior. It's a typical pattern in click for providing extension points.",
          "recommendation": "keep",
          "evidence": [
            "Part of BaseCommand class which is central to click's architecture",
            "Follows naming convention for overrideable methods in click framework"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of the BaseCommand class and appears to be designed for users to override or customize help option behavior. It's a typical pattern in click for providing extension points.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help",
        "lineno": 1088,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This method is clearly part of click's public API for retrieving help text. Even if not called internally, it's designed for external users to programmatically access command help information.",
          "recommendation": "keep",
          "evidence": [
            "Standard method name for accessing help in command-line frameworks",
            "Part of BaseCommand class which users extend and interact with"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method is clearly part of click's public API for retrieving help text. Even if not called internally, it's designed for external users to programmatically access command help information.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help",
        "lineno": 1088,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_record in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Duplicate of item #3 - this method is part of click's public API for retrieving help text programmatically.",
          "recommendation": "keep",
          "evidence": [
            "Standard method name for accessing help in command-line frameworks",
            "Part of BaseCommand class which users extend and interact with"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Duplicate of item #3 - this method is part of click's public API for retrieving help text programmatically.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_help",
        "lineno": 1088,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_help_extra in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Duplicate of item #3 - this method is part of click's public API for retrieving help text programmatically.",
          "recommendation": "keep",
          "evidence": [
            "Standard method name for accessing help in command-line frameworks",
            "Part of BaseCommand class which users extend and interact with"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Duplicate of item #3 - this method is part of click's public API for retrieving help text programmatically.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "format_help",
        "lineno": 1120,
        "pattern_type": "similar_function_names",
        "details": "Similar to format_help_text in src/click/core.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a method in Click's core module that formats help text for commands. Click is a library for creating command-line interfaces, and this method is likely part of the public API for customizing help output.",
          "recommendation": "keep",
          "evidence": [
            "Located in core.py which contains Click's main API classes",
            "Method name suggests it's for formatting help text, a common customization point in CLI libraries"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a method in Click's core module that formats help text for commands. Click is a library for creating command-line interfaces, and this method is likely part of the public API for customizing help output.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_default",
        "lineno": 2249,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This appears to be a method for retrieving default values in Click's parameter system. Since Click is a library, this method is likely part of the public API for parameter handling and customization.",
          "recommendation": "keep",
          "evidence": [
            "Part of Click's core parameter handling system",
            "get_default is a common pattern for retrieving default values in configuration/parameter systems"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a method for retrieving default values in Click's parameter system. Since Click is a library, this method is likely part of the public API for parameter handling and customization.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_default",
        "lineno": 2254,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Another get_default method implementation, likely an override or specialization for a different parameter type. As part of Click's public API, external users may rely on this method.",
          "recommendation": "keep",
          "evidence": [
            "Part of Click's parameter system which is core functionality",
            "Multiple get_default implementations suggest polymorphic behavior for different parameter types"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Another get_default method implementation, likely an override or specialization for a different parameter type. As part of Click's public API, external users may rely on this method.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "get_default",
        "lineno": 2258,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_default_prog_name in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Third get_default method implementation, continuing the pattern of polymorphic default value retrieval across different parameter types in Click's public API.",
          "recommendation": "keep",
          "evidence": [
            "Consistent with other get_default implementations in the same file",
            "Part of Click's parameter handling which is essential public API functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Third get_default method implementation, continuing the pattern of polymorphic default value retrieval across different parameter types in Click's public API.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "process_value",
        "lineno": 2411,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This method has a name pattern typical of callback/hook methods that process values during parameter parsing. In CLI libraries like Click, these methods are often called by the framework during command processing.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows callback pattern (process_*)",
            "Located in core.py suggesting it's part of Click's parameter processing pipeline"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method has a name pattern typical of callback/hook methods that process values during parameter parsing. In CLI libraries like Click, these methods are often called by the framework during command processing.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "process_value",
        "lineno": 2411,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a process_value method in Click's core module, which is a widely-used CLI library. Such methods are typically part of the parameter processing pipeline and called by Click's internal framework during command line parsing.",
          "recommendation": "keep",
          "evidence": [
            "Located in Click's core.py module which contains the main framework classes",
            "Method name suggests it's part of parameter/value processing pipeline"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a process_value method in Click's core module, which is a widely-used CLI library. Such methods are typically part of the parameter processing pipeline and called by Click's internal framework during command line parsing.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "prompt_for_value",
        "lineno": 3117,
        "pattern_type": "similar_function_names",
        "details": "Similar to prompt in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is likely a method that handles interactive prompting for parameter values in Click. These methods are called by Click's framework when parameters need user input, making them essential parts of the CLI interaction system.",
          "recommendation": "keep",
          "evidence": [
            "Method name clearly indicates interactive prompting functionality",
            "Part of Click's core parameter handling system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely a method that handles interactive prompting for parameter values in Click. These methods are called by Click's framework when parameters need user input, making them essential parts of the CLI interaction system.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "process_value",
        "lineno": 3301,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Another process_value method in Click's core, likely belonging to a different parameter class (Option vs Argument). These methods are called during command line parsing to process and validate parameter values.",
          "recommendation": "keep",
          "evidence": [
            "Duplicate process_value methods suggest different parameter types implementing the same interface",
            "Essential for Click's parameter processing pipeline"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Another process_value method in Click's core, likely belonging to a different parameter class (Option vs Argument). These methods are called during command line parsing to process and validate parameter values.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "process_value",
        "lineno": 3301,
        "pattern_type": "similar_function_names",
        "details": "Similar to process in src/click/parser.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a duplicate entry of the same process_value method. As with the previous entry, this is part of Click's parameter processing system and is called by the framework during command parsing.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous entry - likely duplicate detection",
            "Part of Click's core parameter processing functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a duplicate entry of the same process_value method. As with the previous entry, this is part of Click's parameter processing system and is called by the framework during command parsing.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "convert",
        "lineno": 2362,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "The convert method is a fundamental part of Click's type conversion system. It's called by the framework to convert string command line arguments to appropriate Python types, making it essential for parameter processing.",
          "recommendation": "keep",
          "evidence": [
            "Convert methods are core to CLI argument type conversion",
            "Called by Click's parameter processing pipeline, not directly by user code"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "The convert method is a fundamental part of Click's type conversion system. It's called by the framework to convert string command line arguments to appropriate Python types, making it essential for parameter processing.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "convert",
        "lineno": 2367,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This appears to be a convert method in Click's core module, which is a library framework. Convert methods are typically part of the parameter/option processing API that users extend when creating custom types.",
          "recommendation": "keep",
          "evidence": [
            "Located in core.py of Click library framework",
            "Convert methods are standard pattern for type conversion in Click's parameter system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a convert method in Click's core module, which is a library framework. Convert methods are typically part of the parameter/option processing API that users extend when creating custom types.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/core.py",
        "name": "convert",
        "lineno": 2372,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert_type in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is another convert method in Click's core module. These methods are part of Click's type system API and are called by the framework during parameter processing, not directly by user code.",
          "recommendation": "keep",
          "evidence": [
            "Located in core.py of Click library framework",
            "Part of Click's parameter type conversion system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is another convert method in Click's core module. These methods are part of Click's type system API and are called by the framework during parameter processing, not directly by user code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/decorators.py",
        "name": "confirmation_option",
        "lineno": 380,
        "pattern_type": "similar_function_names",
        "details": "Similar to confirm in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator function in Click's decorators module. Click is a command-line library where decorators like confirmation_option are exported for users to decorate their CLI commands.",
          "recommendation": "keep",
          "evidence": [
            "Located in decorators.py which contains Click's public decorator API",
            "Confirmation options are common CLI patterns that users would import and use"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator function in Click's decorators module. Click is a command-line library where decorators like confirmation_option are exported for users to decorate their CLI commands.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/decorators.py",
        "name": "show_help",
        "lineno": 536,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a show_help decorator or function in Click's decorators module. Help display functionality is core to CLI libraries and would be part of the public API.",
          "recommendation": "keep",
          "evidence": [
            "Located in decorators.py of Click library",
            "Help display is fundamental CLI functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a show_help decorator or function in Click's decorators module. Help display functionality is core to CLI libraries and would be part of the public API.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/decorators.py",
        "name": "show_help",
        "lineno": 536,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is the same show_help pattern at the same location as item #4. It's likely part of Click's public API for help display functionality in CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in decorators.py of Click library",
            "Duplicate detection of same public API method"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is the same show_help pattern at the same location as item #4. It's likely part of Click's public API for help display functionality in CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/decorators.py",
        "name": "show_help",
        "lineno": 536,
        "pattern_type": "similar_function_names",
        "details": "Similar to show in src/click/exceptions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be part of Click's decorator API for command-line interfaces. Click is a library where decorators like this are used by external applications to define CLI commands and help functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in decorators.py which suggests it's part of Click's public decorator API",
            "Click is a CLI library where help functionality is core feature used by external applications"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be part of Click's decorator API for command-line interfaces. Click is a library where decorators like this are used by external applications to define CLI commands and help functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write",
        "lineno": 135,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_usage in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This is part of Click's formatting module which provides text formatting utilities. The write method is likely part of a formatter class that external users utilize for output formatting in CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in formatting.py indicating it's part of Click's text formatting API",
            "Write methods in formatting classes are typically called by external code for output generation"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This is part of Click's formatting module which provides text formatting utilities. The write method is likely part of a formatter class that external users utilize for output formatting in CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write",
        "lineno": 135,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_heading in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "Same as occurrence 1 - this is part of Click's formatting API. Multiple occurrences suggest this method is part of the core formatting functionality that external applications rely on.",
          "recommendation": "keep",
          "evidence": [
            "Part of Click's formatting module public API",
            "Multiple occurrences indicate this is a key method in the formatting system"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "Same as occurrence 1 - this is part of Click's formatting API. Multiple occurrences suggest this method is part of the core formatting functionality that external applications rely on.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write",
        "lineno": 135,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_paragraph in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "Consistent with other write method occurrences - this is part of Click's public formatting API used by external applications for text output and formatting in CLI tools.",
          "recommendation": "keep",
          "evidence": [
            "Part of Click's formatting module which is public API",
            "Write functionality is essential for CLI output formatting"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "Consistent with other write method occurrences - this is part of Click's public formatting API used by external applications for text output and formatting in CLI tools.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write",
        "lineno": 135,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_text in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "Final occurrence of the write method in formatting.py. Like the others, this is part of Click's public API for text formatting that external CLI applications depend on for output generation.",
          "recommendation": "keep",
          "evidence": [
            "Consistent with other write method instances in formatting module",
            "Part of Click's core formatting capabilities for external use"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "Final occurrence of the write method in formatting.py. Like the others, this is part of Click's public API for text formatting that external CLI applications depend on for output generation.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write",
        "lineno": 135,
        "pattern_type": "similar_function_names",
        "details": "Similar to write_dl in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a method in the HelpFormatter class which is part of Click's public API for customizing help text formatting. Users extend this class and override methods like write() to customize output formatting.",
          "recommendation": "keep",
          "evidence": [
            "HelpFormatter is a public class in Click used for customizing help text",
            "Method name 'write' is a standard formatting interface method"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a method in the HelpFormatter class which is part of Click's public API for customizing help text formatting. Users extend this class and override methods like write() to customize output formatting.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "indent",
        "lineno": 139,
        "pattern_type": "similar_function_names",
        "details": "Similar to indentation in src/click/formatting.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a method in the HelpFormatter class that provides indentation functionality for help text formatting. It's part of the public API that users can utilize when customizing help output formatting.",
          "recommendation": "keep",
          "evidence": [
            "Part of HelpFormatter public API for text formatting",
            "Indentation is a common requirement when customizing help text display"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a method in the HelpFormatter class that provides indentation functionality for help text formatting. It's part of the public API that users can utilize when customizing help output formatting.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write_usage",
        "lineno": 147,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This method in HelpFormatter is specifically designed for writing usage information in help text. It's a key part of Click's help formatting API that users override to customize how usage messages are displayed.",
          "recommendation": "keep",
          "evidence": [
            "Usage formatting is a core feature of command-line help systems",
            "Method name follows Click's convention for help formatting methods"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This method in HelpFormatter is specifically designed for writing usage information in help text. It's a key part of Click's help formatting API that users override to customize how usage messages are displayed.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write_heading",
        "lineno": 185,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This method handles writing section headings in help text formatting. It's part of Click's public HelpFormatter API that users can override to customize how headings appear in help output.",
          "recommendation": "keep",
          "evidence": [
            "Heading formatting is essential for structured help text display",
            "Follows the write_* pattern common in Click's formatting API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This method handles writing section headings in help text formatting. It's part of Click's public HelpFormatter API that users can override to customize how headings appear in help output.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write_paragraph",
        "lineno": 189,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This method handles paragraph formatting in help text output. As part of the HelpFormatter public API, users can override this method to customize how paragraphs are rendered in help messages.",
          "recommendation": "keep",
          "evidence": [
            "Paragraph formatting is a fundamental text display feature",
            "Part of the comprehensive HelpFormatter API for text customization"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method handles paragraph formatting in help text output. As part of the HelpFormatter public API, users can override this method to customize how paragraphs are rendered in help messages.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write_text",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a method on the HelpFormatter class in Click, which is a library for building command-line interfaces. The HelpFormatter class is likely part of Click's public API for customizing help text formatting.",
          "recommendation": "keep",
          "evidence": [
            "Located in formatting.py which suggests it's part of Click's formatting API",
            "Method name indicates it's designed for external use to write formatted text"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a method on the HelpFormatter class in Click, which is a library for building command-line interfaces. The HelpFormatter class is likely part of Click's public API for customizing help text formatting.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/formatting.py",
        "name": "write_dl",
        "lineno": 210,
        "pattern_type": "similar_function_names",
        "details": "Similar to write in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is another method on the HelpFormatter class in Click's formatting module. The name suggests it writes definition lists, which is a common formatting need for CLI help text that users would want to customize.",
          "recommendation": "keep",
          "evidence": [
            "Part of the same HelpFormatter class as write_text",
            "Name 'write_dl' suggests writing definition lists, a common help formatting pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is another method on the HelpFormatter class in Click's formatting module. The name suggests it writes definition lists, which is a common formatting need for CLI help text that users would want to customize.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/shell_completion.py",
        "name": "source_vars",
        "lineno": 244,
        "pattern_type": "similar_function_names",
        "details": "Similar to source in src/click/shell_completion.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This appears to be a method in Click's shell completion module. Shell completion systems often need to access environment variables and configuration, making this likely part of the public API for shell completion customization.",
          "recommendation": "keep",
          "evidence": [
            "Located in shell_completion.py indicating it's part of Click's completion API",
            "Name suggests it provides source variables needed for shell completion setup"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This appears to be a method in Click's shell completion module. Shell completion systems often need to access environment variables and configuration, making this likely part of the public API for shell completion customization.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/shell_completion.py",
        "name": "source_vars",
        "lineno": 244,
        "pattern_type": "similar_function_names",
        "details": "Similar to source in src/click/shell_completion.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "Duplicate of item #3 - this is the same method in Click's shell completion module that provides source variables for shell completion functionality.",
          "recommendation": "keep",
          "evidence": [
            "Same as item #3 - part of shell completion API",
            "Duplicate entry of the same method"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "Duplicate of item #3 - this is the same method in Click's shell completion module that provides source variables for shell completion functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "prompt",
        "lineno": 83,
        "pattern_type": "similar_function_names",
        "details": "Similar to prompt_func in src/click/termui.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is in Click's termui module and is almost certainly the main prompt function that Click provides for interactive user input. This is a core feature of Click that CLI applications use extensively.",
          "recommendation": "keep",
          "evidence": [
            "Located in termui.py which contains Click's terminal UI utilities",
            "Prompting for user input is a fundamental CLI library feature that must be publicly accessible"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is in Click's termui module and is almost certainly the main prompt function that Click provides for interactive user input. This is a core feature of Click that CLI applications use extensively.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "echo_via_pager",
        "lineno": 261,
        "pattern_type": "similar_function_names",
        "details": "Similar to echo in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public utility function in Click's termui module for displaying text through a pager. Click is a library for building command-line interfaces, and this function would be used by applications built with Click.",
          "recommendation": "keep",
          "evidence": [
            "Located in termui.py which contains terminal utility functions",
            "Function name suggests it's a utility for paging output, common in CLI applications"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public utility function in Click's termui module for displaying text through a pager. Click is a library for building command-line interfaces, and this function would be used by applications built with Click.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/termui.py",
        "name": "getchar",
        "lineno": 816,
        "pattern_type": "similar_function_names",
        "details": "Similar to _getchar in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a public utility function in Click's termui module for reading a single character from input. This is a common need in CLI applications for interactive prompts and single-key responses.",
          "recommendation": "keep",
          "evidence": [
            "Located in termui.py alongside other terminal interaction utilities",
            "getchar is a standard pattern for single character input in CLI applications"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a public utility function in Click's termui module for reading a single character from input. This is a common need in CLI applications for interactive prompts and single-key responses.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/testing.py",
        "name": "_echo",
        "lineno": 34,
        "pattern_type": "similar_function_names",
        "details": "Similar to echo in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a method in Click's testing module, likely part of a mock or test utility class that implements an echo interface. Testing utilities often have methods that are called by the testing framework rather than directly by user code.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py which suggests it's part of test infrastructure",
            "Underscore prefix suggests internal method but still part of testing interface"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a method in Click's testing module, likely part of a mock or test utility class that implements an echo interface. Testing utilities often have methods that are called by the testing framework rather than directly by user code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/testing.py",
        "name": "read",
        "lineno": 40,
        "pattern_type": "similar_function_names",
        "details": "Similar to read1 in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This is a method in Click's testing module that likely implements a file-like interface for testing purposes. The read method is a standard protocol method that would be called by Python's I/O system or testing framework.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py indicating it's part of test infrastructure",
            "read() is a standard protocol method for file-like objects"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a method in Click's testing module that likely implements a file-like interface for testing purposes. The read method is a standard protocol method that would be called by Python's I/O system or testing framework.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/testing.py",
        "name": "read",
        "lineno": 40,
        "pattern_type": "similar_function_names",
        "details": "Similar to readline in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This is the same method as item #4 - a read method in Click's testing module that implements a file-like interface. It's called by Python's I/O system rather than directly by user code.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py indicating it's part of test infrastructure",
            "read() is a standard protocol method for file-like objects"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is the same method as item #4 - a read method in Click's testing module that implements a file-like interface. It's called by Python's I/O system rather than directly by user code.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/testing.py",
        "name": "read",
        "lineno": 40,
        "pattern_type": "similar_function_names",
        "details": "Similar to readlines in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This appears to be implementing a file-like interface method in a testing utility class. The read() method is a standard file protocol method that would be called by Python's I/O system or other code expecting a file-like object.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py suggesting it's part of a mock/stub file-like object",
            "read() is a standard file protocol method called by Python I/O operations"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be implementing a file-like interface method in a testing utility class. The read() method is a standard file protocol method that would be called by Python's I/O system or other code expecting a file-like object.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/testing.py",
        "name": "readline",
        "lineno": 46,
        "pattern_type": "similar_function_names",
        "details": "Similar to readlines in src/click/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This is implementing the readline() method of a file-like interface in a testing utility. Like read(), this is a standard protocol method that would be called by Python's I/O system or other code expecting a file-like object.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py suggesting it's part of a mock/stub file-like object",
            "readline() is a standard file protocol method called by Python I/O operations"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is implementing the readline() method of a file-like interface in a testing utility. Like read(), this is a standard protocol method that would be called by Python's I/O system or other code expecting a file-like object.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is in types.py which likely contains type conversion utilities for Click (a CLI library). The convert_type method is likely part of the public API for type conversion that users would call when building CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py suggesting it's a core type conversion utility",
            "Click is a library framework where type conversion methods are commonly used by applications"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is in types.py which likely contains type conversion utilities for Click (a CLI library). The convert_type method is likely part of the public API for type conversion that users would call when building CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Same as previous - this is in types.py which likely contains type conversion utilities for Click. The convert_type method is likely part of the public API for type conversion that users would call when building CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py suggesting it's a core type conversion utility",
            "Click is a library framework where type conversion methods are commonly used by applications"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Same as previous - this is in types.py which likely contains type conversion utilities for Click. The convert_type method is likely part of the public API for type conversion that users would call when building CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Same as previous instances - this is in types.py which likely contains type conversion utilities for Click. The convert_type method is likely part of the public API for type conversion that users would call when building CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py suggesting it's a core type conversion utility",
            "Click is a library framework where type conversion methods are commonly used by applications"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Same as previous instances - this is in types.py which likely contains type conversion utilities for Click. The convert_type method is likely part of the public API for type conversion that users would call when building CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "public_api",
          "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
          "recommendation": "investigate",
          "evidence": [
            "Located in types.py which suggests it's part of Click's type system",
            "Click is a library where type conversion methods would be expected public API"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "public_api",
          "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
          "recommendation": "investigate",
          "evidence": [
            "Located in types.py which suggests it's part of Click's type system",
            "Click is a library where type conversion methods would be expected public API"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "public_api",
          "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
          "recommendation": "investigate",
          "evidence": [
            "Located in types.py which suggests it's part of Click's type system",
            "Click is a library where type conversion methods would be expected public API"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "public_api",
          "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
          "recommendation": "investigate",
          "evidence": [
            "Located in types.py which suggests it's part of Click's type system",
            "Click is a library where type conversion methods would be expected public API"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "public_api",
          "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
          "recommendation": "investigate",
          "evidence": [
            "Located in types.py which suggests it's part of Click's type system",
            "Click is a library where type conversion methods would be expected public API"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "This appears to be a method in Click's types module which is likely part of the public API for type conversion. Without seeing the actual code implementation or usage context, it's difficult to determine if this is genuinely unused or part of Click's external interface.",
        "recommendation": "investigate"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py which is core Click functionality",
            "Pattern conversion is fundamental to Click's type system",
            "Framework methods are called internally by Click's parameter processing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py which is core Click functionality",
            "Pattern conversion is fundamental to Click's type system",
            "Framework methods are called internally by Click's parameter processing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py which is core Click functionality",
            "Pattern conversion is fundamental to Click's type system",
            "Framework methods are called internally by Click's parameter processing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py which is core Click functionality",
            "Pattern conversion is fundamental to Click's type system",
            "Framework methods are called internally by Click's parameter processing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/types.py",
        "name": "convert_type",
        "lineno": 1112,
        "pattern_type": "similar_function_names",
        "details": "Similar to convert in src/click/types.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
          "recommendation": "keep",
          "evidence": [
            "Located in types.py which is core Click functionality",
            "Pattern conversion is fundamental to Click's type system",
            "Framework methods are called internally by Click's parameter processing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is part of Click's type conversion system in types.py. Click is a library for creating command-line interfaces, and this method would be called by the Click framework during parameter processing and validation.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/utils.py",
        "name": "open_file",
        "lineno": 358,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a utility function in Click's utils module that could be used by external code or other parts of the Click library. Click is a library for creating command-line interfaces, and file operations are common in CLI applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in utils.py which typically contains helper functions for external use",
            "Click is a library where utility functions are often part of the public API"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a utility function in Click's utils module that could be used by external code or other parts of the Click library. Click is a library for creating command-line interfaces, and file operations are common in CLI applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/click/utils.py",
        "name": "close",
        "lineno": 169,
        "pattern_type": "similar_function_names",
        "details": "Similar to close_intelligently in src/click/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "interface_method",
          "reason": "This is likely a close method implementing a standard interface protocol (like context manager or file-like object). Close methods are typically called by Python's garbage collector, context management, or frameworks rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Standard method name 'close' suggests interface implementation",
            "Close methods are often called by Python runtime or frameworks, not directly in code"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This is likely a close method implementing a standard interface protocol (like context manager or file-like object). Close methods are typically called by Python's garbage collector, context management, or frameworks rather than directly by application code.",
        "recommendation": "keep"
      }
    ],
    "summary": {
      "total_analyzed": 280,
      "confirmed_dead_code": 30,
      "false_positives": 200,
      "uncertain": 50,
      "avg_confidence": 81.35
    }
  },
  "logical_groups": {
    "Documentation & Configuration": [
      "docs/conf.py"
    ],
    "Core Framework Engine": [
      "src/click/__init__.py",
      "src/click/core.py",
      "src/click/decorators.py",
      "src/click/globals.py",
      "src/click/parser.py"
    ],
    "Type System & Validation": [
      "src/click/types.py",
      "src/click/exceptions.py"
    ],
    "Terminal UI & Interaction": [
      "src/click/termui.py",
      "src/click/_termui_impl.py",
      "src/click/formatting.py",
      "src/click/_textwrap.py"
    ],
    "Platform Compatibility": [
      "src/click/_compat.py",
      "src/click/_winconsole.py",
      "src/click/utils.py",
      "src/click/_utils.py"
    ],
    "Shell Integration": [
      "src/click/shell_completion.py"
    ],
    "Testing Infrastructure": [
      "src/click/testing.py"
    ],
    "Example Applications - Simple CLI Tools": [
      "examples/colors/colors.py",
      "examples/inout/inout.py",
      "examples/naval/naval.py",
      "examples/validation/validation.py"
    ],
    "Example Applications - Advanced Features": [
      "examples/aliases/aliases.py",
      "examples/completion/completion.py",
      "examples/imagepipe/imagepipe.py",
      "examples/repo/repo.py",
      "examples/termui/termui.py"
    ],
    "Example Applications - Complex Architecture": [
      "examples/complex/complex/__init__.py",
      "examples/complex/complex/cli.py",
      "examples/complex/complex/commands/__init__.py",
      "examples/complex/complex/commands/cmd_init.py",
      "examples/complex/complex/commands/cmd_status.py"
    ]
  },
  "audio_narration": {
    "audio_file": "/Users/navyan/Desktop/LLM-Project/repospeak/audio/click_summary.mp3",
    "script_file": "/Users/navyan/Desktop/LLM-Project/repospeak/audio/click_audio_script.txt",
    "audio_text": "Imagine you're building a Swiss Army knife... but for command-line tools. That's exactly what Click is.\n\nHere's the thing... if you've ever used a terminal or command prompt, you know those programs where you type commands and get things done? Well, creating those from scratch is surprisingly tedious. You'd spend hours writing code just to handle basic stuff like \"what did the user type?\" or \"did they forget a required option?\"\n\nClick swoops in and says, \"I've got this.\"\n\nThink of Click as your personal assistant for building command-line applications... or CLIs, which stands for command-line interfaces. It's a Python library that handles all the boring, repetitive work so you can focus on what your tool actually does.\n\nFirst, it parses everything users type... breaking down their commands into digestible pieces your program can understand. Next, it validates their input, catching mistakes before they cause problems. And here's the beautiful part... it automatically generates helpful error messages and documentation, so users aren't left scratching their heads.\n\nBut wait, there's more. Click comes loaded with ready-made features... progress bars that show how long tasks will take, colored text that makes output easier to read, secure password prompts, and even auto-completion that predicts what users want to type.\n\nAnd here's what really sets it apart... Click handles all the quirky differences between Windows, Mac, and Linux automatically. Your command-line tool works consistently everywhere, without you writing platform-specific code.\n\nSo whether you're building a simple script or a complex tool with subcommands... Click transforms what used to take days into something you can build in an afternoon. It's professional command-line applications... made ridiculously easy.",
    "word_count": 271,
    "estimated_duration_minutes": 1.8
  }
}