{
  "repo_name": "requests",
  "ast_results": {
    "docs/_themes/flask_theme_support.py": {
      "filepath": "../requests/docs/_themes/flask_theme_support.py",
      "module_docstring": null,
      "functions": [],
      "classes": [
        {
          "name": "FlaskyStyle",
          "methods": [],
          "base_classes": [
            "Style"
          ],
          "lineno": 7,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "pygments.style",
          "name": "Style",
          "alias": null,
          "lineno": 2,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Keyword",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Name",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Comment",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "String",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Error",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Number",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Operator",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Generic",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Whitespace",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Punctuation",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Other",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "pygments.token",
          "name": "Literal",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "pygments"
          ]
        },
        "tech_stack": []
      },
      "line_count": 87
    },
    "docs/conf.py": {
      "filepath": "../requests/docs/conf.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "sys",
          "alias": null,
          "lineno": 15,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 16,
          "type": "import"
        },
        {
          "module": "requests",
          "alias": null,
          "lineno": 27,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "extensions",
          "assigned_to": null,
          "lineno": 38
        },
        {
          "name": "templates_path",
          "assigned_to": null,
          "lineno": 46
        },
        {
          "name": "source_suffix",
          "assigned_to": "str",
          "lineno": 51
        },
        {
          "name": "master_doc",
          "assigned_to": "str",
          "lineno": 57
        },
        {
          "name": "project",
          "assigned_to": "str",
          "lineno": 60
        },
        {
          "name": "copyright",
          "assigned_to": "str",
          "lineno": 61
        },
        {
          "name": "author",
          "assigned_to": "str",
          "lineno": 62
        },
        {
          "name": "version",
          "assigned_to": null,
          "lineno": 69
        },
        {
          "name": "release",
          "assigned_to": null,
          "lineno": 71
        },
        {
          "name": "language",
          "assigned_to": "NoneType",
          "lineno": 78
        },
        {
          "name": "exclude_patterns",
          "assigned_to": null,
          "lineno": 88
        },
        {
          "name": "add_function_parentheses",
          "assigned_to": "bool",
          "lineno": 95
        },
        {
          "name": "add_module_names",
          "assigned_to": "bool",
          "lineno": 99
        },
        {
          "name": "pygments_style",
          "assigned_to": "str",
          "lineno": 106
        },
        {
          "name": "todo_include_todos",
          "assigned_to": "bool",
          "lineno": 115
        },
        {
          "name": "html_theme",
          "assigned_to": "str",
          "lineno": 122
        },
        {
          "name": "html_theme_options",
          "assigned_to": null,
          "lineno": 127
        },
        {
          "name": "html_static_path",
          "assigned_to": null,
          "lineno": 158
        },
        {
          "name": "html_use_smartypants",
          "assigned_to": "bool",
          "lineno": 171
        },
        {
          "name": "html_sidebars",
          "assigned_to": null,
          "lineno": 174
        },
        {
          "name": "html_show_sourcelink",
          "assigned_to": "bool",
          "lineno": 200
        },
        {
          "name": "html_show_sphinx",
          "assigned_to": "bool",
          "lineno": 203
        },
        {
          "name": "html_show_copyright",
          "assigned_to": "bool",
          "lineno": 206
        },
        {
          "name": "htmlhelp_basename",
          "assigned_to": "str",
          "lineno": 231
        },
        {
          "name": "latex_elements",
          "assigned_to": null,
          "lineno": 235
        },
        {
          "name": "latex_documents",
          "assigned_to": null,
          "lineno": 249
        },
        {
          "name": "man_pages",
          "assigned_to": null,
          "lineno": 278
        },
        {
          "name": "texinfo_documents",
          "assigned_to": null,
          "lineno": 289
        },
        {
          "name": "epub_title",
          "assigned_to": "project",
          "lineno": 317
        },
        {
          "name": "epub_author",
          "assigned_to": "author",
          "lineno": 318
        },
        {
          "name": "epub_publisher",
          "assigned_to": "author",
          "lineno": 319
        },
        {
          "name": "epub_copyright",
          "assigned_to": "copyright",
          "lineno": 320
        },
        {
          "name": "epub_exclude_files",
          "assigned_to": null,
          "lineno": 360
        },
        {
          "name": "intersphinx_mapping",
          "assigned_to": null,
          "lineno": 383
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "requests.__version__",
          "os.path.abspath",
          "author",
          "project",
          "sys.path.insert",
          "copyright"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "sys",
          "os"
        ],
        "third_party": {
          "web": [
            "requests"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 387
    },
    "setup.py": {
      "filepath": "../requests/setup.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "os",
          "alias": null,
          "lineno": 2,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "codecs",
          "name": "open",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "setuptools",
          "name": "setup",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "CURRENT_PYTHON",
          "assigned_to": null,
          "lineno": 8
        },
        {
          "name": "REQUIRED_PYTHON",
          "assigned_to": null,
          "lineno": 9
        },
        {
          "name": "requires",
          "assigned_to": null,
          "lineno": 36
        },
        {
          "name": "test_requirements",
          "assigned_to": null,
          "lineno": 42
        },
        {
          "name": "about",
          "assigned_to": null,
          "lineno": 51
        },
        {
          "name": "here",
          "assigned_to": "os.path.abspath",
          "lineno": 52
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "setup",
          "os.path.abspath",
          "sys.stderr.write",
          "open",
          "os.path.dirname",
          "about",
          "sys.exit",
          "__file__",
          "requires",
          "unknown.format",
          "exec",
          "os.system",
          "here",
          "os.path.join",
          "test_requirements",
          "f.read",
          "readme"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os",
          "sys"
        ],
        "third_party": {
          "other": [
            "codecs",
            "setuptools"
          ]
        },
        "tech_stack": []
      },
      "line_count": 108
    },
    "src/requests/__init__.py": {
      "filepath": "../requests/src/requests/__init__.py",
      "module_docstring": "Requests HTTP Library\n~~~~~~~~~~~~~~~~~~~~~\n\nRequests is an HTTP library, written in Python, for human beings.\nBasic GET usage:\n\n   >>> import requests\n   >>> r = requests.get('https://www.python.org')\n   >>> r.status_code\n   200\n   >>> b'Python is a programming language' in r.content\n   True\n\n... or POST:\n\n   >>> payload = dict(key1='value1', key2='value2')\n   >>> r = requests.post('https://httpbin.org/post', data=payload)\n   >>> print(r.text)\n   {\n     ...\n     \"form\": {\n       \"key1\": \"value1\",\n       \"key2\": \"value2\"\n     },\n     ...\n   }\n\nThe other HTTP methods are supported - see `requests.api`. Full documentation\nis at <https://requests.readthedocs.io>.\n\n:copyright: (c) 2017 by Kenneth Reitz.\n:license: Apache 2.0, see LICENSE for more details.",
      "functions": [
        {
          "name": "check_compatibility",
          "args": [
            {
              "name": "urllib3_version"
            },
            {
              "name": "chardet_version"
            },
            {
              "name": "charset_normalizer_version"
            }
          ],
          "return_type": null,
          "lineno": 58,
          "decorators": [],
          "is_async": false,
          "calls": [
            "urllib3_version.split",
            "major",
            "len",
            "charset_normalizer_version.split",
            "minor",
            "urllib3_version",
            "warnings.warn",
            "RequestsDependencyWarning",
            "patch",
            "chardet_version.split",
            "int",
            "urllib3_version.append"
          ],
          "docstring": null,
          "code": "def check_compatibility(urllib3_version, chardet_version, charset_normalizer_version):\n    urllib3_version = urllib3_version.split(\".\")\n    assert urllib3_version != [\"dev\"]  # Verify urllib3 isn't installed from git.\n\n    # Sometimes, urllib3 only reports its version as 16.1.\n    if len(urllib3_version) == 2:\n        urllib3_version.append(\"0\")\n\n    # Check urllib3 for compatibility.\n    major, minor, patch = urllib3_version  # noqa: F811\n    major, minor, patch = int(major), int(minor), int(patch)\n    # urllib3 >= 1.21.1\n    assert major >= 1\n    if major == 1:\n        assert minor >= 21\n\n    # Check charset_normalizer for compatibility.\n    if chardet_version:\n        major, minor, patch = chardet_version.split(\".\")[:3]\n        major, minor, patch = int(major), int(minor), int(patch)\n        # chardet_version >= 3.0.2, < 6.0.0\n        assert (3, 0, 2) <= (major, minor, patch) < (6, 0, 0)\n    elif charset_normalizer_version:\n        major, minor, patch = charset_normalizer_version.split(\".\")[:3]\n        major, minor, patch = int(major), int(minor), int(patch)\n        # charset_normalizer >= 2.0.0 < 4.0.0\n        assert (2, 0, 0) <= (major, minor, patch) < (4, 0, 0)\n    else:\n        warnings.warn(\n            \"Unable to find acceptable character detection dependency \"\n            \"(chardet or charset_normalizer).\",\n            RequestsDependencyWarning,\n        )",
          "line_count": 33,
          "needs_llm_summary": true
        },
        {
          "name": "_check_cryptography",
          "args": [
            {
              "name": "cryptography_version"
            }
          ],
          "return_type": null,
          "lineno": 93,
          "decorators": [],
          "is_async": false,
          "calls": [
            "warning",
            "list",
            "map",
            "unknown.format",
            "cryptography_version.split",
            "warnings.warn",
            "cryptography_version",
            "RequestsDependencyWarning",
            "int"
          ],
          "docstring": null,
          "code": "def _check_cryptography(cryptography_version):\n    # cryptography < 1.3.4\n    try:\n        cryptography_version = list(map(int, cryptography_version.split(\".\")))\n    except ValueError:\n        return\n\n    if cryptography_version < [1, 3, 4]:\n        warning = \"Old version of cryptography ({}) may cause slowdown.\".format(\n            cryptography_version\n        )\n        warnings.warn(warning, RequestsDependencyWarning)",
          "line_count": 12,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "warnings",
          "alias": null,
          "lineno": 41,
          "type": "import"
        },
        {
          "module": "urllib3",
          "alias": null,
          "lineno": 43,
          "type": "import"
        },
        {
          "module": "exceptions",
          "name": "RequestsDependencyWarning",
          "alias": null,
          "lineno": 45,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "DependencyWarning",
          "alias": null,
          "lineno": 143,
          "type": "from_import"
        },
        {
          "module": "logging",
          "alias": null,
          "lineno": 148,
          "type": "import"
        },
        {
          "module": "logging",
          "name": "NullHandler",
          "alias": null,
          "lineno": 149,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "packages",
          "alias": null,
          "lineno": 151,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "utils",
          "alias": null,
          "lineno": 151,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__author__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__author_email__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__build__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__cake__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__copyright__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__description__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__license__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__title__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__url__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__version__",
          "alias": null,
          "lineno": 152,
          "type": "from_import"
        },
        {
          "module": "api",
          "name": "delete",
          "alias": null,
          "lineno": 164,
          "type": "from_import"
        },
        {
          "module": "api",
          "name": "get",
          "alias": null,
          "lineno": 164,
          "type": "from_import"
        },
        {
          "module": "api",
          "name": "head",
          "alias": null,
          "lineno": 164,
          "type": "from_import"
        },
        {
          "module": "api",
          "name": "options",
          "alias": null,
          "lineno": 164,
          "type": "from_import"
        },
        {
          "module": "api",
          "name": "patch",
          "alias": null,
          "lineno": 164,
          "type": "from_import"
        },
        {
          "module": "api",
          "name": "post",
          "alias": null,
          "lineno": 164,
          "type": "from_import"
        },
        {
          "module": "api",
          "name": "put",
          "alias": null,
          "lineno": 164,
          "type": "from_import"
        },
        {
          "module": "api",
          "name": "request",
          "alias": null,
          "lineno": 164,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ConnectionError",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ConnectTimeout",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "FileModeWarning",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "HTTPError",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "JSONDecodeError",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ReadTimeout",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "RequestException",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "Timeout",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "TooManyRedirects",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "URLRequired",
          "alias": null,
          "lineno": 165,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "PreparedRequest",
          "alias": null,
          "lineno": 177,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "Request",
          "alias": null,
          "lineno": 177,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "Response",
          "alias": null,
          "lineno": 177,
          "type": "from_import"
        },
        {
          "module": "sessions",
          "name": "Session",
          "alias": null,
          "lineno": 178,
          "type": "from_import"
        },
        {
          "module": "sessions",
          "name": "session",
          "alias": null,
          "lineno": 178,
          "type": "from_import"
        },
        {
          "module": "status_codes",
          "name": "codes",
          "alias": null,
          "lineno": 179,
          "type": "from_import"
        },
        {
          "module": "charset_normalizer",
          "name": "__version__",
          "alias": "charset_normalizer_version",
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "chardet",
          "name": "__version__",
          "alias": "chardet_version",
          "lineno": 53,
          "type": "from_import"
        },
        {
          "module": "ssl",
          "alias": null,
          "lineno": 126,
          "type": "import"
        },
        {
          "module": "urllib3.contrib",
          "name": "pyopenssl",
          "alias": null,
          "lineno": 131,
          "type": "from_import"
        },
        {
          "module": "cryptography",
          "name": "__version__",
          "alias": "cryptography_version",
          "lineno": 136,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "NullHandler",
          "_check_cryptography",
          "unknown.format",
          "__name__",
          "charset_normalizer_version",
          "ssl",
          "urllib3.__version__",
          "DependencyWarning",
          "logging.getLogger",
          "chardet_version",
          "cryptography_version",
          "check_compatibility",
          "warnings.warn",
          "FileModeWarning",
          "warnings.simplefilter",
          "pyopenssl.inject_into_urllib3",
          "unknown.addHandler",
          "RequestsDependencyWarning",
          "getattr"
        ],
        "class_instantiations": [
          "NullHandler"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "warnings",
          "logging"
        ],
        "third_party": {
          "other": [
            "urllib3",
            "exceptions",
            "packages",
            "utils",
            "__version__",
            "api",
            "models",
            "sessions",
            "status_codes",
            "charset_normalizer",
            "chardet",
            "ssl",
            "cryptography"
          ]
        },
        "tech_stack": []
      },
      "line_count": 185
    },
    "src/requests/__version__.py": {
      "filepath": "../requests/src/requests/__version__.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [],
      "variables": [
        {
          "name": "__title__",
          "assigned_to": "str",
          "lineno": 5
        },
        {
          "name": "__description__",
          "assigned_to": "str",
          "lineno": 6
        },
        {
          "name": "__url__",
          "assigned_to": "str",
          "lineno": 7
        },
        {
          "name": "__version__",
          "assigned_to": "str",
          "lineno": 8
        },
        {
          "name": "__build__",
          "assigned_to": "int",
          "lineno": 9
        },
        {
          "name": "__author__",
          "assigned_to": "str",
          "lineno": 10
        },
        {
          "name": "__author_email__",
          "assigned_to": "str",
          "lineno": 11
        },
        {
          "name": "__license__",
          "assigned_to": "str",
          "lineno": 12
        },
        {
          "name": "__copyright__",
          "assigned_to": "str",
          "lineno": 13
        },
        {
          "name": "__cake__",
          "assigned_to": "str",
          "lineno": 14
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {},
        "tech_stack": []
      },
      "line_count": 15
    },
    "src/requests/_internal_utils.py": {
      "filepath": "../requests/src/requests/_internal_utils.py",
      "module_docstring": "requests._internal_utils\n~~~~~~~~~~~~~~\n\nProvides utility functions that are consumed internally by Requests\nwhich depend on extremely few external helpers (such as compat)",
      "functions": [
        {
          "name": "to_native_string",
          "args": [
            {
              "name": "string"
            },
            {
              "name": "encoding"
            }
          ],
          "return_type": null,
          "lineno": 25,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "encoding",
            "builtin_str",
            "string",
            "string.decode"
          ],
          "docstring": "Given a string object, regardless of type, returns a representation of\nthat string in the native string type, encoding and decoding where\nnecessary. This assumes ASCII unless told otherwise.",
          "code": "def to_native_string(string, encoding=\"ascii\"):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        out = string.decode(encoding)\n\n    return out",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "unicode_is_ascii",
          "args": [
            {
              "name": "u_string"
            }
          ],
          "return_type": null,
          "lineno": 38,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "str",
            "u_string",
            "u_string.encode"
          ],
          "docstring": "Determine if unicode string only contains ASCII characters.\n\n:param str u_string: unicode string to check. Must be unicode\n    and not Python 2 `str`.\n:rtype: bool",
          "code": "def unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n\n    :param str u_string: unicode string to check. Must be unicode\n        and not Python 2 `str`.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode(\"ascii\")\n        return True\n    except UnicodeEncodeError:\n        return False",
          "line_count": 13,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "re",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "compat",
          "name": "builtin_str",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "_VALID_HEADER_NAME_RE_BYTE",
          "assigned_to": "re.compile",
          "lineno": 12
        },
        {
          "name": "_VALID_HEADER_NAME_RE_STR",
          "assigned_to": "re.compile",
          "lineno": 13
        },
        {
          "name": "_VALID_HEADER_VALUE_RE_BYTE",
          "assigned_to": "re.compile",
          "lineno": 14
        },
        {
          "name": "_VALID_HEADER_VALUE_RE_STR",
          "assigned_to": "re.compile",
          "lineno": 15
        },
        {
          "name": "_HEADER_VALIDATORS_STR",
          "assigned_to": null,
          "lineno": 17
        },
        {
          "name": "_HEADER_VALIDATORS_BYTE",
          "assigned_to": null,
          "lineno": 18
        },
        {
          "name": "HEADER_VALIDATORS",
          "assigned_to": null,
          "lineno": 19
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "re.compile"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "re"
        ],
        "third_party": {
          "other": [
            "compat"
          ]
        },
        "tech_stack": []
      },
      "line_count": 51
    },
    "src/requests/adapters.py": {
      "filepath": "../requests/src/requests/adapters.py",
      "module_docstring": "requests.adapters\n~~~~~~~~~~~~~~~~~\n\nThis module contains the transport adapters that Requests uses to define\nand maintain connections.",
      "functions": [
        {
          "name": "_urllib3_request_context",
          "args": [
            {
              "name": "request",
              "type": "PreparedRequest"
            },
            {
              "name": "verify",
              "type": "bool | str | None"
            },
            {
              "name": "client_cert",
              "type": "typing.Tuple[str, str] | str | None"
            },
            {
              "name": "poolmanager",
              "type": "PoolManager"
            }
          ],
          "return_type": "(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])",
          "lineno": 76,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "len",
            "os.path.isdir",
            "str",
            "parsed_request_url.scheme.lower",
            "parsed_request_url.port",
            "urlparse",
            "request.url",
            "tuple",
            "client_cert",
            "verify",
            "cert_reqs"
          ],
          "docstring": null,
          "code": "def _urllib3_request_context(\n    request: \"PreparedRequest\",\n    verify: \"bool | str | None\",\n    client_cert: \"typing.Tuple[str, str] | str | None\",\n    poolmanager: \"PoolManager\",\n) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":\n    host_params = {}\n    pool_kwargs = {}\n    parsed_request_url = urlparse(request.url)\n    scheme = parsed_request_url.scheme.lower()\n    port = parsed_request_url.port\n\n    cert_reqs = \"CERT_REQUIRED\"\n    if verify is False:\n        cert_reqs = \"CERT_NONE\"\n    elif isinstance(verify, str):\n        if not os.path.isdir(verify):\n            pool_kwargs[\"ca_certs\"] = verify\n        else:\n            pool_kwargs[\"ca_cert_dir\"] = verify\n    pool_kwargs[\"cert_reqs\"] = cert_reqs\n    if client_cert is not None:\n        if isinstance(client_cert, tuple) and len(client_cert) == 2:\n            pool_kwargs[\"cert_file\"] = client_cert[0]\n            pool_kwargs[\"key_file\"] = client_cert[1]\n        else:\n            # According to our docs, we allow users to specify just the client\n            # cert path\n            pool_kwargs[\"cert_file\"] = client_cert\n    host_params = {\n        \"scheme\": scheme,\n        \"host\": parsed_request_url.hostname,\n        \"port\": port,\n    }\n    return host_params, pool_kwargs",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 116,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "super"
          ],
          "docstring": null,
          "code": "def __init__(self):\n        super().__init__()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "send",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            },
            {
              "name": "stream"
            },
            {
              "name": "timeout"
            },
            {
              "name": "verify"
            },
            {
              "name": "cert"
            },
            {
              "name": "proxies"
            }
          ],
          "return_type": null,
          "lineno": 119,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Sends PreparedRequest object. Returns Response object.\n\n:param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n:param stream: (optional) Whether to stream the request content.\n:param timeout: (optional) How long to wait for the server to send\n    data before giving up, as a float, or a :ref:`(connect timeout,\n    read timeout) <timeouts>` tuple.\n:type timeout: float or tuple\n:param verify: (optional) Either a boolean, in which case it controls whether we verify\n    the server's TLS certificate, or a string, in which case it must be a path\n    to a CA bundle to use\n:param cert: (optional) Any user-provided SSL certificate to be trusted.\n:param proxies: (optional) The proxies dictionary to apply to the request.",
          "code": "def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        \"\"\"\n        raise NotImplementedError",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "close",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 138,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Cleans up adapter specific items.",
          "code": "def close(self):\n        \"\"\"Cleans up adapter specific items.\"\"\"\n        raise NotImplementedError",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "pool_connections"
            },
            {
              "name": "pool_maxsize"
            },
            {
              "name": "max_retries"
            },
            {
              "name": "pool_block"
            }
          ],
          "return_type": null,
          "lineno": 178,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.init_poolmanager",
            "pool_connections",
            "pool_block",
            "unknown.__init__",
            "super",
            "pool_maxsize",
            "Retry",
            "max_retries",
            "Retry.from_int"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        pool_connections=DEFAULT_POOLSIZE,\n        pool_maxsize=DEFAULT_POOLSIZE,\n        max_retries=DEFAULT_RETRIES,\n        pool_block=DEFAULT_POOLBLOCK,\n    ):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n\n        super().__init__()\n\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "__getstate__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 200,
          "decorators": [],
          "is_async": false,
          "calls": [
            "getattr",
            "self",
            "attr"
          ],
          "docstring": null,
          "code": "def __getstate__(self):\n        return {attr: getattr(self, attr, None) for attr in self.__attrs__}",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__setstate__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "state"
            }
          ],
          "return_type": null,
          "lineno": 203,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.init_poolmanager",
            "state.items",
            "self._pool_block",
            "self._pool_connections",
            "attr",
            "self",
            "value",
            "self._pool_maxsize",
            "setattr"
          ],
          "docstring": null,
          "code": "def __setstate__(self, state):\n        # Can't handle by adding 'proxy_manager' to self.__attrs__ because\n        # self.poolmanager uses a lambda function, which isn't pickleable.\n        self.proxy_manager = {}\n        self.config = {}\n\n        for attr, value in state.items():\n            setattr(self, attr, value)\n\n        self.init_poolmanager(\n            self._pool_connections, self._pool_maxsize, block=self._pool_block\n        )",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "init_poolmanager",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "connections"
            },
            {
              "name": "maxsize"
            },
            {
              "name": "block"
            }
          ],
          "return_type": null,
          "lineno": 216,
          "decorators": [],
          "is_async": false,
          "calls": [
            "connections",
            "block",
            "PoolManager",
            "pool_kwargs",
            "maxsize"
          ],
          "docstring": "Initializes a urllib3 PoolManager.\n\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param connections: The number of urllib3 connection pools to cache.\n:param maxsize: The maximum number of connections to save in the pool.\n:param block: Block when no free connections are available.\n:param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.",
          "code": "def init_poolmanager(\n        self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs\n    ):\n        \"\"\"Initializes a urllib3 PoolManager.\n\n        This method should not be called from user code, and is only\n        exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param connections: The number of urllib3 connection pools to cache.\n        :param maxsize: The maximum number of connections to save in the pool.\n        :param block: Block when no free connections are available.\n        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.\n        \"\"\"\n        # save these values for pickling\n        self._pool_connections = connections\n        self._pool_maxsize = maxsize\n        self._pool_block = block\n\n        self.poolmanager = PoolManager(\n            num_pools=connections,\n            maxsize=maxsize,\n            block=block,\n            **pool_kwargs,\n        )",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "proxy_manager_for",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "proxy"
            }
          ],
          "return_type": null,
          "lineno": 242,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.startswith",
            "SOCKSProxyManager",
            "proxy_headers",
            "proxy.lower",
            "self._pool_block",
            "self._pool_connections",
            "self.proxy_headers",
            "proxy_from_url",
            "proxy",
            "self._pool_maxsize",
            "password",
            "proxy_kwargs",
            "get_auth_from_url",
            "username"
          ],
          "docstring": "Return urllib3 ProxyManager for the given proxy.\n\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param proxy: The proxy to return a urllib3 ProxyManager for.\n:param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.\n:returns: ProxyManager\n:rtype: urllib3.ProxyManager",
          "code": "def proxy_manager_for(self, proxy, **proxy_kwargs):\n        \"\"\"Return urllib3 ProxyManager for the given proxy.\n\n        This method should not be called from user code, and is only\n        exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param proxy: The proxy to return a urllib3 ProxyManager for.\n        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.\n        :returns: ProxyManager\n        :rtype: urllib3.ProxyManager\n        \"\"\"\n        if proxy in self.proxy_manager:\n            manager = self.proxy_manager[proxy]\n        elif proxy.lower().startswith(\"socks\"):\n            username, password = get_auth_from_url(proxy)\n            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n                **proxy_kwargs,\n            )\n        else:\n            proxy_headers = self.proxy_headers(proxy)\n            manager = self.proxy_manager[proxy] = proxy_from_url(\n                proxy,\n                proxy_headers=proxy_headers,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n                **proxy_kwargs,\n            )\n\n        return manager",
          "line_count": 37,
          "needs_llm_summary": true
        },
        {
          "name": "cert_verify",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "conn"
            },
            {
              "name": "url"
            },
            {
              "name": "verify"
            },
            {
              "name": "cert"
            }
          ],
          "return_type": null,
          "lineno": 280,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.startswith",
            "isinstance",
            "DEFAULT_CA_BUNDLE_PATH",
            "conn.cert_file",
            "cert",
            "os.path.isdir",
            "basestring",
            "conn.key_file",
            "extract_zipped_paths",
            "OSError",
            "os.path.exists",
            "url.lower",
            "cert_loc",
            "verify"
          ],
          "docstring": "Verify a SSL certificate. This method should not be called from user\ncode, and is only exposed for use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param conn: The urllib3 connection object associated with the cert.\n:param url: The requested URL.\n:param verify: Either a boolean, in which case it controls whether we verify\n    the server's TLS certificate, or a string, in which case it must be a path\n    to a CA bundle to use\n:param cert: The SSL certificate to verify.",
          "code": "def cert_verify(self, conn, url, verify, cert):\n        \"\"\"Verify a SSL certificate. This method should not be called from user\n        code, and is only exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param conn: The urllib3 connection object associated with the cert.\n        :param url: The requested URL.\n        :param verify: Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use\n        :param cert: The SSL certificate to verify.\n        \"\"\"\n        if url.lower().startswith(\"https\") and verify:\n            cert_loc = None\n\n            # Allow self-specified cert location.\n            if verify is not True:\n                cert_loc = verify\n\n            if not cert_loc:\n                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n\n            if not cert_loc or not os.path.exists(cert_loc):\n                raise OSError(\n                    f\"Could not find a suitable TLS CA certificate bundle, \"\n                    f\"invalid path: {cert_loc}\"\n                )\n\n            conn.cert_reqs = \"CERT_REQUIRED\"\n\n            if not os.path.isdir(cert_loc):\n                conn.ca_certs = cert_loc\n            else:\n                conn.ca_cert_dir = cert_loc\n        else:\n            conn.cert_reqs = \"CERT_NONE\"\n            conn.ca_certs = None\n            conn.ca_cert_dir = None\n\n        if cert:\n            if not isinstance(cert, basestring):\n                conn.cert_file = cert[0]\n                conn.key_file = cert[1]\n            else:\n                conn.cert_file = cert\n                conn.key_file = None\n            if conn.cert_file and not os.path.exists(conn.cert_file):\n                raise OSError(\n                    f\"Could not find the TLS certificate file, \"\n                    f\"invalid path: {conn.cert_file}\"\n                )\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise OSError(\n                    f\"Could not find the TLS key file, invalid path: {conn.key_file}\"\n                )",
          "line_count": 55,
          "needs_llm_summary": true
        },
        {
          "name": "build_response",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "req"
            },
            {
              "name": "resp"
            }
          ],
          "return_type": null,
          "lineno": 336,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "response.cookies",
            "get_encoding_from_headers",
            "Response",
            "self",
            "CaseInsensitiveDict",
            "response.headers",
            "resp",
            "bytes",
            "getattr",
            "req",
            "response.raw.reason",
            "req.url.decode",
            "extract_cookies_to_jar",
            "req.url"
          ],
          "docstring": "Builds a :class:`Response <requests.Response>` object from a urllib3\nresponse. This should not be called from user code, and is only exposed\nfor use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`\n\n:param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.\n:param resp: The urllib3 response object.\n:rtype: requests.Response",
          "code": "def build_response(self, req, resp):\n        \"\"\"Builds a :class:`Response <requests.Response>` object from a urllib3\n        response. This should not be called from user code, and is only exposed\n        for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`\n\n        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.\n        :param resp: The urllib3 response object.\n        :rtype: requests.Response\n        \"\"\"\n        response = Response()\n\n        # Fallback to None if there's no status_code, for whatever reason.\n        response.status_code = getattr(resp, \"status\", None)\n\n        # Make headers case-insensitive.\n        response.headers = CaseInsensitiveDict(getattr(resp, \"headers\", {}))\n\n        # Set encoding.\n        response.encoding = get_encoding_from_headers(response.headers)\n        response.raw = resp\n        response.reason = response.raw.reason\n\n        if isinstance(req.url, bytes):\n            response.url = req.url.decode(\"utf-8\")\n        else:\n            response.url = req.url\n\n        # Add new cookies from the server.\n        extract_cookies_to_jar(response.cookies, req, resp)\n\n        # Give the Response some context.\n        response.request = req\n        response.connection = self\n\n        return response",
          "line_count": 36,
          "needs_llm_summary": true
        },
        {
          "name": "build_connection_pool_key_attributes",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            },
            {
              "name": "verify"
            },
            {
              "name": "cert"
            }
          ],
          "return_type": null,
          "lineno": 373,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.poolmanager",
            "cert",
            "_urllib3_request_context",
            "request",
            "verify"
          ],
          "docstring": "Build the PoolKey attributes used by urllib3 to return a connection.\n\nThis looks at the PreparedRequest, the user-specified verify value,\nand the value of the cert parameter to determine what PoolKey values\nto use to select a connection from a given urllib3 Connection Pool.\n\nThe SSL related pool key arguments are not consistently set. As of\nthis writing, use the following to determine what keys may be in that\ndictionary:\n\n* If ``verify`` is ``True``, ``\"ssl_context\"`` will be set and will be the\n  default Requests SSL Context\n* If ``verify`` is ``False``, ``\"ssl_context\"`` will not be set but\n  ``\"cert_reqs\"`` will be set\n* If ``verify`` is a string, (i.e., it is a user-specified trust bundle)\n  ``\"ca_certs\"`` will be set if the string is not a directory recognized\n  by :py:func:`os.path.isdir`, otherwise ``\"ca_cert_dir\"`` will be\n  set.\n* If ``\"cert\"`` is specified, ``\"cert_file\"`` will always be set. If\n  ``\"cert\"`` is a tuple with a second item, ``\"key_file\"`` will also\n  be present\n\nTo override these settings, one may subclass this class, call this\nmethod and use the above logic to change parameters as desired. For\nexample, if one wishes to use a custom :py:class:`ssl.SSLContext` one\nmust both set ``\"ssl_context\"`` and based on what else they require,\nalter the other keys to ensure the desired behaviour.\n\n:param request:\n    The PreparedReqest being sent over the connection.\n:type request:\n    :class:`~requests.models.PreparedRequest`\n:param verify:\n    Either a boolean, in which case it controls whether\n    we verify the server's TLS certificate, or a string, in which case it\n    must be a path to a CA bundle to use.\n:param cert:\n    (optional) Any user-provided SSL certificate for client\n    authentication (a.k.a., mTLS). This may be a string (i.e., just\n    the path to a file which holds both certificate and key) or a\n    tuple of length 2 with the certificate file path and key file\n    path.\n:returns:\n    A tuple of two dictionaries. The first is the \"host parameters\"\n    portion of the Pool Key including scheme, hostname, and port. The\n    second is a dictionary of SSLContext related parameters.",
          "code": "def build_connection_pool_key_attributes(self, request, verify, cert=None):\n        \"\"\"Build the PoolKey attributes used by urllib3 to return a connection.\n\n        This looks at the PreparedRequest, the user-specified verify value,\n        and the value of the cert parameter to determine what PoolKey values\n        to use to select a connection from a given urllib3 Connection Pool.\n\n        The SSL related pool key arguments are not consistently set. As of\n        this writing, use the following to determine what keys may be in that\n        dictionary:\n\n        * If ``verify`` is ``True``, ``\"ssl_context\"`` will be set and will be the\n          default Requests SSL Context\n        * If ``verify`` is ``False``, ``\"ssl_context\"`` will not be set but\n          ``\"cert_reqs\"`` will be set\n        * If ``verify`` is a string, (i.e., it is a user-specified trust bundle)\n          ``\"ca_certs\"`` will be set if the string is not a directory recognized\n          by :py:func:`os.path.isdir`, otherwise ``\"ca_cert_dir\"`` will be\n          set.\n        * If ``\"cert\"`` is specified, ``\"cert_file\"`` will always be set. If\n          ``\"cert\"`` is a tuple with a second item, ``\"key_file\"`` will also\n          be present\n\n        To override these settings, one may subclass this class, call this\n        method and use the above logic to change parameters as desired. For\n        example, if one wishes to use a custom :py:class:`ssl.SSLContext` one\n        must both set ``\"ssl_context\"`` and based on what else they require,\n        alter the other keys to ensure the desired behaviour.\n\n        :param request:\n            The PreparedReqest being sent over the connection.\n        :type request:\n            :class:`~requests.models.PreparedRequest`\n        :param verify:\n            Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use.\n        :param cert:\n            (optional) Any user-provided SSL certificate for client\n            authentication (a.k.a., mTLS). This may be a string (i.e., just\n            the path to a file which holds both certificate and key) or a\n            tuple of length 2 with the certificate file path and key file\n            path.\n        :returns:\n            A tuple of two dictionaries. The first is the \"host parameters\"\n            portion of the Pool Key including scheme, hostname, and port. The\n            second is a dictionary of SSLContext related parameters.\n        \"\"\"\n        return _urllib3_request_context(request, verify, cert, self.poolmanager)",
          "line_count": 49,
          "needs_llm_summary": true
        },
        {
          "name": "get_connection_with_tls_context",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            },
            {
              "name": "verify"
            },
            {
              "name": "proxies"
            },
            {
              "name": "cert"
            }
          ],
          "return_type": null,
          "lineno": 423,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.build_connection_pool_key_attributes",
            "e",
            "InvalidProxyURL",
            "proxies",
            "cert",
            "host_params",
            "request",
            "self.poolmanager.connection_from_host",
            "pool_kwargs",
            "proxy",
            "parse_url",
            "request.url",
            "prepend_scheme_if_needed",
            "self.proxy_manager_for",
            "select_proxy",
            "verify",
            "InvalidURL",
            "proxy_manager.connection_from_host"
          ],
          "docstring": "Returns a urllib3 connection for the given request and TLS settings.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param request:\n    The :class:`PreparedRequest <PreparedRequest>` object to be sent\n    over the connection.\n:param verify:\n    Either a boolean, in which case it controls whether we verify the\n    server's TLS certificate, or a string, in which case it must be a\n    path to a CA bundle to use.\n:param proxies:\n    (optional) The proxies dictionary to apply to the request.\n:param cert:\n    (optional) Any user-provided SSL certificate to be used for client\n    authentication (a.k.a., mTLS).\n:rtype:\n    urllib3.ConnectionPool",
          "code": "def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):\n        \"\"\"Returns a urllib3 connection for the given request and TLS settings.\n        This should not be called from user code, and is only exposed for use\n        when subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request:\n            The :class:`PreparedRequest <PreparedRequest>` object to be sent\n            over the connection.\n        :param verify:\n            Either a boolean, in which case it controls whether we verify the\n            server's TLS certificate, or a string, in which case it must be a\n            path to a CA bundle to use.\n        :param proxies:\n            (optional) The proxies dictionary to apply to the request.\n        :param cert:\n            (optional) Any user-provided SSL certificate to be used for client\n            authentication (a.k.a., mTLS).\n        :rtype:\n            urllib3.ConnectionPool\n        \"\"\"\n        proxy = select_proxy(request.url, proxies)\n        try:\n            host_params, pool_kwargs = self.build_connection_pool_key_attributes(\n                request,\n                verify,\n                cert,\n            )\n        except ValueError as e:\n            raise InvalidURL(e, request=request)\n        if proxy:\n            proxy = prepend_scheme_if_needed(proxy, \"http\")\n            proxy_url = parse_url(proxy)\n            if not proxy_url.host:\n                raise InvalidProxyURL(\n                    \"Please check proxy URL. It is malformed \"\n                    \"and could be missing the host.\"\n                )\n            proxy_manager = self.proxy_manager_for(proxy)\n            conn = proxy_manager.connection_from_host(\n                **host_params, pool_kwargs=pool_kwargs\n            )\n        else:\n            # Only scheme should be lower case\n            conn = self.poolmanager.connection_from_host(\n                **host_params, pool_kwargs=pool_kwargs\n            )\n\n        return conn",
          "line_count": 48,
          "needs_llm_summary": true
        },
        {
          "name": "get_connection",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            },
            {
              "name": "proxies"
            }
          ],
          "return_type": null,
          "lineno": 472,
          "decorators": [],
          "is_async": false,
          "calls": [
            "proxy_manager.connection_from_url",
            "InvalidProxyURL",
            "DeprecationWarning",
            "proxies",
            "url",
            "proxy",
            "warnings.warn",
            "parse_url",
            "urlparse",
            "parsed.geturl",
            "self.proxy_manager_for",
            "self.poolmanager.connection_from_url",
            "select_proxy",
            "prepend_scheme_if_needed"
          ],
          "docstring": "DEPRECATED: Users should move to `get_connection_with_tls_context`\nfor all subclasses of HTTPAdapter using Requests>=2.32.2.\n\nReturns a urllib3 connection for the given URL. This should not be\ncalled from user code, and is only exposed for use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param url: The URL to connect to.\n:param proxies: (optional) A Requests-style dictionary of proxies used on this request.\n:rtype: urllib3.ConnectionPool",
          "code": "def get_connection(self, url, proxies=None):\n        \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`\n        for all subclasses of HTTPAdapter using Requests>=2.32.2.\n\n        Returns a urllib3 connection for the given URL. This should not be\n        called from user code, and is only exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param url: The URL to connect to.\n        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.\n        :rtype: urllib3.ConnectionPool\n        \"\"\"\n        warnings.warn(\n            (\n                \"`get_connection` has been deprecated in favor of \"\n                \"`get_connection_with_tls_context`. Custom HTTPAdapter subclasses \"\n                \"will need to migrate for Requests>=2.32.2. Please see \"\n                \"https://github.com/psf/requests/pull/6710 for more details.\"\n            ),\n            DeprecationWarning,\n        )\n        proxy = select_proxy(url, proxies)\n\n        if proxy:\n            proxy = prepend_scheme_if_needed(proxy, \"http\")\n            proxy_url = parse_url(proxy)\n            if not proxy_url.host:\n                raise InvalidProxyURL(\n                    \"Please check proxy URL. It is malformed \"\n                    \"and could be missing the host.\"\n                )\n            proxy_manager = self.proxy_manager_for(proxy)\n            conn = proxy_manager.connection_from_url(url)\n        else:\n            # Only scheme should be lower case\n            parsed = urlparse(url)\n            url = parsed.geturl()\n            conn = self.poolmanager.connection_from_url(url)\n\n        return conn",
          "line_count": 40,
          "needs_llm_summary": true
        },
        {
          "name": "close",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 513,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.proxy_manager.values",
            "proxy.clear",
            "self.poolmanager.clear"
          ],
          "docstring": "Disposes of any internal state.\n\nCurrently, this closes the PoolManager and any active ProxyManager,\nwhich closes any pooled connections.",
          "code": "def close(self):\n        \"\"\"Disposes of any internal state.\n\n        Currently, this closes the PoolManager and any active ProxyManager,\n        which closes any pooled connections.\n        \"\"\"\n        self.poolmanager.clear()\n        for proxy in self.proxy_manager.values():\n            proxy.clear()",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "request_url",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            },
            {
              "name": "proxies"
            }
          ],
          "return_type": null,
          "lineno": 523,
          "decorators": [],
          "is_async": false,
          "calls": [
            "url.lstrip",
            "proxies",
            "url.startswith",
            "urldefragauth",
            "unknown.scheme.lower",
            "proxy",
            "urlparse",
            "request.url",
            "unknown.scheme",
            "proxy_scheme.startswith",
            "select_proxy",
            "request.path_url"
          ],
          "docstring": "Obtain the url to use when making the final request.\n\nIf the message is being sent through a HTTP proxy, the full URL has to\nbe used. Otherwise, we should only use the path portion of the URL.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n:param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.\n:rtype: str",
          "code": "def request_url(self, request, proxies):\n        \"\"\"Obtain the url to use when making the final request.\n\n        If the message is being sent through a HTTP proxy, the full URL has to\n        be used. Otherwise, we should only use the path portion of the URL.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.\n        :rtype: str\n        \"\"\"\n        proxy = select_proxy(request.url, proxies)\n        scheme = urlparse(request.url).scheme\n\n        is_proxied_http_request = proxy and scheme != \"https\"\n        using_socks_proxy = False\n        if proxy:\n            proxy_scheme = urlparse(proxy).scheme.lower()\n            using_socks_proxy = proxy_scheme.startswith(\"socks\")\n\n        url = request.path_url\n        if url.startswith(\"//\"):  # Don't confuse urllib3\n            url = f\"/{url.lstrip('/')}\"\n\n        if is_proxied_http_request and not using_socks_proxy:\n            url = urldefragauth(request.url)\n\n        return url",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "add_headers",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            }
          ],
          "return_type": null,
          "lineno": 555,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Add any headers needed by the connection. As of v2.0 this does\nnothing by default, but is left for overriding by users that subclass\nthe :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.\n:param kwargs: The keyword arguments from the call to send().",
          "code": "def add_headers(self, request, **kwargs):\n        \"\"\"Add any headers needed by the connection. As of v2.0 this does\n        nothing by default, but is left for overriding by users that subclass\n        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.\n        :param kwargs: The keyword arguments from the call to send().\n        \"\"\"\n        pass",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "proxy_headers",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "proxy"
            }
          ],
          "return_type": null,
          "lineno": 569,
          "decorators": [],
          "is_async": false,
          "calls": [
            "proxy",
            "_basic_auth_str",
            "password",
            "get_auth_from_url",
            "username"
          ],
          "docstring": "Returns a dictionary of the headers to add to any request sent\nthrough a proxy. This works with urllib3 magic to ensure that they are\ncorrectly sent to the proxy, rather than in a tunnelled request if\nCONNECT is being used.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param proxy: The url of the proxy being used for this request.\n:rtype: dict",
          "code": "def proxy_headers(self, proxy):\n        \"\"\"Returns a dictionary of the headers to add to any request sent\n        through a proxy. This works with urllib3 magic to ensure that they are\n        correctly sent to the proxy, rather than in a tunnelled request if\n        CONNECT is being used.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param proxy: The url of the proxy being used for this request.\n        :rtype: dict\n        \"\"\"\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n\n        if username:\n            headers[\"Proxy-Authorization\"] = _basic_auth_str(username, password)\n\n        return headers",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "send",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            },
            {
              "name": "stream"
            },
            {
              "name": "timeout"
            },
            {
              "name": "verify"
            },
            {
              "name": "cert"
            },
            {
              "name": "proxies"
            }
          ],
          "return_type": null,
          "lineno": 590,
          "decorators": [],
          "is_async": false,
          "calls": [
            "request.method",
            "self.request_url",
            "chunked",
            "stream",
            "ProxyError",
            "ReadTimeout",
            "request",
            "conn.urlopen",
            "ValueError",
            "resp",
            "connect",
            "e.reason",
            "self.cert_verify",
            "_InvalidHeader",
            "request.body",
            "timeout",
            "url",
            "err",
            "ConnectTimeoutError",
            "InvalidHeader",
            "request.url",
            "ConnectTimeout",
            "RetryError",
            "verify",
            "self.max_retries",
            "isinstance",
            "e",
            "_ProxyError",
            "conn",
            "ResponseError",
            "read",
            "self.get_connection_with_tls_context",
            "tuple",
            "self.build_response",
            "SSLError",
            "NewConnectionError",
            "ConnectionError",
            "cert",
            "proxies",
            "TimeoutSauce",
            "ReadTimeoutError",
            "self.add_headers",
            "_SSLError",
            "request.headers",
            "InvalidURL"
          ],
          "docstring": "Sends PreparedRequest object. Returns Response object.\n\n:param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n:param stream: (optional) Whether to stream the request content.\n:param timeout: (optional) How long to wait for the server to send\n    data before giving up, as a float, or a :ref:`(connect timeout,\n    read timeout) <timeouts>` tuple.\n:type timeout: float or tuple or urllib3 Timeout object\n:param verify: (optional) Either a boolean, in which case it controls whether\n    we verify the server's TLS certificate, or a string, in which case it\n    must be a path to a CA bundle to use\n:param cert: (optional) Any user-provided SSL certificate to be trusted.\n:param proxies: (optional) The proxies dictionary to apply to the request.\n:rtype: requests.Response",
          "code": "def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n\n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n\n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n\n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n\n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n\n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n\n            if isinstance(e.reason, ResponseError):\n                raise RetryError(e, request=request)\n\n            if isinstance(e.reason, _ProxyError):\n                raise ProxyError(e, request=request)\n\n            if isinstance(e.reason, _SSLError):\n                # This branch is for urllib3 v1.22 and later.\n                raise SSLError(e, request=request)\n\n            raise ConnectionError(e, request=request)\n\n        except ClosedPoolError as e:\n            raise ConnectionError(e, request=request)\n\n        except _ProxyError as e:\n            raise ProxyError(e)\n\n        except (_SSLError, _HTTPError) as e:\n            if isinstance(e, _SSLError):\n                # This branch is for urllib3 versions earlier than v1.22\n                raise SSLError(e, request=request)\n            elif isinstance(e, ReadTimeoutError):\n                raise ReadTimeout(e, request=request)\n            elif isinstance(e, _InvalidHeader):\n                raise InvalidHeader(e, request=request)\n            else:\n                raise\n\n        return self.build_response(request, resp)",
          "line_count": 107,
          "needs_llm_summary": true
        },
        {
          "name": "SOCKSProxyManager",
          "args": [],
          "return_type": null,
          "lineno": 62,
          "decorators": [],
          "is_async": false,
          "calls": [
            "InvalidSchema"
          ],
          "docstring": null,
          "code": "def SOCKSProxyManager(*args, **kwargs):\n        raise InvalidSchema(\"Missing dependencies for SOCKS support.\")",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "BaseAdapter",
          "methods": [
            "__init__",
            "send",
            "close"
          ],
          "base_classes": [],
          "lineno": 113,
          "docstring": "The Base Transport Adapter"
        },
        {
          "name": "HTTPAdapter",
          "methods": [
            "__init__",
            "__getstate__",
            "__setstate__",
            "init_poolmanager",
            "proxy_manager_for",
            "cert_verify",
            "build_response",
            "build_connection_pool_key_attributes",
            "get_connection_with_tls_context",
            "get_connection",
            "close",
            "request_url",
            "add_headers",
            "proxy_headers",
            "send"
          ],
          "base_classes": [
            "BaseAdapter"
          ],
          "lineno": 143,
          "docstring": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)"
        }
      ],
      "imports": [
        {
          "module": "os.path",
          "alias": null,
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "socket",
          "alias": null,
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 12,
          "type": "import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "ClosedPoolError",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "ConnectTimeoutError",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "HTTPError",
          "alias": "_HTTPError",
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "InvalidHeader",
          "alias": "_InvalidHeader",
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "LocationValueError",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "MaxRetryError",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "NewConnectionError",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "ProtocolError",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "ProxyError",
          "alias": "_ProxyError",
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "ReadTimeoutError",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "ResponseError",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "SSLError",
          "alias": "_SSLError",
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "urllib3.poolmanager",
          "name": "PoolManager",
          "alias": null,
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "urllib3.poolmanager",
          "name": "proxy_from_url",
          "alias": null,
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "urllib3.util",
          "name": "Timeout",
          "alias": "TimeoutSauce",
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "urllib3.util",
          "name": "parse_url",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "urllib3.util.retry",
          "name": "Retry",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "auth",
          "name": "_basic_auth_str",
          "alias": null,
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "basestring",
          "alias": null,
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlparse",
          "alias": null,
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "extract_cookies_to_jar",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ConnectionError",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ConnectTimeout",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidHeader",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidProxyURL",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidSchema",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidURL",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ProxyError",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ReadTimeout",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "RetryError",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "SSLError",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "Response",
          "alias": null,
          "lineno": 46,
          "type": "from_import"
        },
        {
          "module": "structures",
          "name": "CaseInsensitiveDict",
          "alias": null,
          "lineno": 47,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "DEFAULT_CA_BUNDLE_PATH",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "extract_zipped_paths",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_auth_from_url",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_encoding_from_headers",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "prepend_scheme_if_needed",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "select_proxy",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "urldefragauth",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "urllib3.contrib.socks",
          "name": "SOCKSProxyManager",
          "alias": null,
          "lineno": 59,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "PreparedRequest",
          "alias": null,
          "lineno": 67,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "DEFAULT_POOLBLOCK",
          "assigned_to": "bool",
          "lineno": 70
        },
        {
          "name": "DEFAULT_POOLSIZE",
          "assigned_to": "int",
          "lineno": 71
        },
        {
          "name": "DEFAULT_RETRIES",
          "assigned_to": "int",
          "lineno": 72
        },
        {
          "name": "DEFAULT_POOL_TIMEOUT",
          "assigned_to": "NoneType",
          "lineno": 73
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "InvalidSchema"
        ],
        "class_instantiations": [
          "InvalidSchema"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "warnings",
          "os",
          "typing"
        ],
        "third_party": {
          "other": [
            "socket",
            "urllib3",
            "auth",
            "compat",
            "cookies",
            "exceptions",
            "models",
            "structures",
            "utils"
          ]
        },
        "tech_stack": []
      },
      "line_count": 697
    },
    "src/requests/api.py": {
      "filepath": "../requests/src/requests/api.py",
      "module_docstring": "requests.api\n~~~~~~~~~~~~\n\nThis module implements the Requests API.\n\n:copyright: (c) 2012 by Kenneth Reitz.\n:license: Apache2, see LICENSE for more details.",
      "functions": [
        {
          "name": "request",
          "args": [
            {
              "name": "method"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 14,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "method",
            "url",
            "session.request",
            "sessions.Session"
          ],
          "docstring": "Constructs and sends a :class:`Request <Request>`.\n\n:param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n:param url: URL for the new :class:`Request` object.\n:param params: (optional) Dictionary, list of tuples or bytes to send\n    in the query string for the :class:`Request`.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n:param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n:param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n:param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.\n    ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``\n    or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content_type'`` is a string\n    defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers\n    to add for the file.\n:param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n:param timeout: (optional) How many seconds to wait for the server to send data\n    before giving up, as a float, or a :ref:`(connect timeout, read\n    timeout) <timeouts>` tuple.\n:type timeout: float or tuple\n:param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.\n:type allow_redirects: bool\n:param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n:param verify: (optional) Either a boolean, in which case it controls whether we verify\n        the server's TLS certificate, or a string, in which case it must be a path\n        to a CA bundle to use. Defaults to ``True``.\n:param stream: (optional) if ``False``, the response content will be immediately downloaded.\n:param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.request('GET', 'https://httpbin.org/get')\n  >>> req\n  <Response [200]>",
          "code": "def request(method, url, **kwargs):\n    \"\"\"Constructs and sends a :class:`Request <Request>`.\n\n    :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n    :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.\n        ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``\n        or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content_type'`` is a string\n        defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers\n        to add for the file.\n    :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n    :param timeout: (optional) How many seconds to wait for the server to send data\n        before giving up, as a float, or a :ref:`(connect timeout, read\n        timeout) <timeouts>` tuple.\n    :type timeout: float or tuple\n    :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.\n    :type allow_redirects: bool\n    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n    :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``.\n    :param stream: (optional) if ``False``, the response content will be immediately downloaded.\n    :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n\n    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n\n    # By using the 'with' statement we are sure the session is closed, thus we\n    # avoid leaving sockets open which can trigger a ResourceWarning in some\n    # cases, and look like a memory leak in others.\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)",
          "line_count": 46,
          "needs_llm_summary": true
        },
        {
          "name": "get",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "params"
            }
          ],
          "return_type": null,
          "lineno": 62,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url",
            "request",
            "params"
          ],
          "docstring": "Sends a GET request.\n\n:param url: URL for the new :class:`Request` object.\n:param params: (optional) Dictionary, list of tuples or bytes to send\n    in the query string for the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
          "code": "def get(url, params=None, **kwargs):\n    r\"\"\"Sends a GET request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n\n    return request(\"get\", url, params=params, **kwargs)",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "options",
          "args": [
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 76,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url",
            "request"
          ],
          "docstring": "Sends an OPTIONS request.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
          "code": "def options(url, **kwargs):\n    r\"\"\"Sends an OPTIONS request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n\n    return request(\"options\", url, **kwargs)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "head",
          "args": [
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 88,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url",
            "request",
            "kwargs.setdefault"
          ],
          "docstring": "Sends a HEAD request.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n    `allow_redirects` is not provided, it will be set to `False` (as\n    opposed to the default :meth:`request` behavior).\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
          "code": "def head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n        `allow_redirects` is not provided, it will be set to `False` (as\n        opposed to the default :meth:`request` behavior).\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n\n    kwargs.setdefault(\"allow_redirects\", False)\n    return request(\"head\", url, **kwargs)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "post",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "data"
            },
            {
              "name": "json"
            }
          ],
          "return_type": null,
          "lineno": 103,
          "decorators": [],
          "is_async": false,
          "calls": [
            "json",
            "kwargs",
            "url",
            "request",
            "data"
          ],
          "docstring": "Sends a POST request.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
          "code": "def post(url, data=None, json=None, **kwargs):\n    r\"\"\"Sends a POST request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n\n    return request(\"post\", url, data=data, json=json, **kwargs)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "put",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "data"
            }
          ],
          "return_type": null,
          "lineno": 118,
          "decorators": [],
          "is_async": false,
          "calls": [
            "data",
            "kwargs",
            "url",
            "request"
          ],
          "docstring": "Sends a PUT request.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
          "code": "def put(url, data=None, **kwargs):\n    r\"\"\"Sends a PUT request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n\n    return request(\"put\", url, data=data, **kwargs)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "patch",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "data"
            }
          ],
          "return_type": null,
          "lineno": 133,
          "decorators": [],
          "is_async": false,
          "calls": [
            "data",
            "kwargs",
            "url",
            "request"
          ],
          "docstring": "Sends a PATCH request.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
          "code": "def patch(url, data=None, **kwargs):\n    r\"\"\"Sends a PATCH request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n\n    return request(\"patch\", url, data=data, **kwargs)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "delete",
          "args": [
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 148,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url",
            "request"
          ],
          "docstring": "Sends a DELETE request.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
          "code": "def delete(url, **kwargs):\n    r\"\"\"Sends a DELETE request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n\n    return request(\"delete\", url, **kwargs)",
          "line_count": 10,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "",
          "name": "sessions",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "sessions"
          ]
        },
        "tech_stack": []
      },
      "line_count": 158
    },
    "src/requests/auth.py": {
      "filepath": "../requests/src/requests/auth.py",
      "module_docstring": "requests.auth\n~~~~~~~~~~~~~\n\nThis module contains the authentication handlers for Requests.",
      "functions": [
        {
          "name": "_basic_auth_str",
          "args": [
            {
              "name": "username"
            },
            {
              "name": "password"
            }
          ],
          "return_type": null,
          "lineno": 25,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "to_native_string",
            "DeprecationWarning",
            "username.encode",
            "basestring",
            "str",
            "type",
            "unknown.format",
            "warnings.warn",
            "b64encode",
            "password.encode",
            "unknown.strip",
            "password",
            "username",
            "unknown.join"
          ],
          "docstring": "Returns a Basic Auth string.",
          "code": "def _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n    #\n    # These are here solely to maintain backwards compatibility\n    # for things like ints. This will be removed in 3.0.0.\n    if not isinstance(username, basestring):\n        warnings.warn(\n            \"Non-string usernames will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(username),\n            category=DeprecationWarning,\n        )\n        username = str(username)\n\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n        username = username.encode(\"latin1\")\n\n    if isinstance(password, str):\n        password = password.encode(\"latin1\")\n\n    authstr = \"Basic \" + to_native_string(\n        b64encode(b\":\".join((username, password))).strip()\n    )\n\n    return authstr",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "__call__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "r"
            }
          ],
          "return_type": null,
          "lineno": 72,
          "decorators": [],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": null,
          "code": "def __call__(self, r):\n        raise NotImplementedError(\"Auth hooks must be callable.\")",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "username"
            },
            {
              "name": "password"
            }
          ],
          "return_type": null,
          "lineno": 79,
          "decorators": [],
          "is_async": false,
          "calls": [
            "password",
            "username"
          ],
          "docstring": null,
          "code": "def __init__(self, username, password):\n        self.username = username\n        self.password = password",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__eq__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "other"
            }
          ],
          "return_type": null,
          "lineno": 83,
          "decorators": [],
          "is_async": false,
          "calls": [
            "all",
            "getattr",
            "other"
          ],
          "docstring": null,
          "code": "def __eq__(self, other):\n        return all(\n            [\n                self.username == getattr(other, \"username\", None),\n                self.password == getattr(other, \"password\", None),\n            ]\n        )",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__ne__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "other"
            }
          ],
          "return_type": null,
          "lineno": 91,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __ne__(self, other):\n        return not self == other",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__call__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "r"
            }
          ],
          "return_type": null,
          "lineno": 94,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.password",
            "_basic_auth_str",
            "self.username"
          ],
          "docstring": null,
          "code": "def __call__(self, r):\n        r.headers[\"Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__call__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "r"
            }
          ],
          "return_type": null,
          "lineno": 102,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.password",
            "_basic_auth_str",
            "self.username"
          ],
          "docstring": null,
          "code": "def __call__(self, r):\n        r.headers[\"Proxy-Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "username"
            },
            {
              "name": "password"
            }
          ],
          "return_type": null,
          "lineno": 110,
          "decorators": [],
          "is_async": false,
          "calls": [
            "password",
            "username",
            "threading.local"
          ],
          "docstring": null,
          "code": "def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "init_per_thread_state",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 116,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._thread_local",
            "hasattr"
          ],
          "docstring": null,
          "code": "def init_per_thread_state(self):\n        # Ensure state is initialized just once per-thread\n        if not hasattr(self._thread_local, \"init\"):\n            self._thread_local.init = True\n            self._thread_local.last_nonce = \"\"\n            self._thread_local.nonce_count = 0\n            self._thread_local.chal = {}\n            self._thread_local.pos = None\n            self._thread_local.num_401_calls = None",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "build_digest_header",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "method"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 126,
          "decorators": [],
          "is_async": false,
          "calls": [
            "noncebit",
            "urlparse",
            "algorithm.upper",
            "sha256_utf8",
            "s",
            "self._thread_local.nonce_count",
            "sha512_utf8",
            "os.urandom",
            "url",
            "qop.split",
            "nonce.encode",
            "x.encode",
            "A1",
            "isinstance",
            "hashlib.sha512",
            "md5_utf8",
            "hash_utf8",
            "str",
            "nonce",
            "unknown.hexdigest",
            "unknown.encode",
            "sha_utf8",
            "time.ctime",
            "self._thread_local.chal.get",
            "hashlib.sha256",
            "KD",
            "hashlib.md5",
            "x",
            "hashlib.sha1",
            "A2",
            "HA1"
          ],
          "docstring": ":rtype: str",
          "code": "def build_digest_header(self, method, url):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n\n        realm = self._thread_local.chal[\"realm\"]\n        nonce = self._thread_local.chal[\"nonce\"]\n        qop = self._thread_local.chal.get(\"qop\")\n        algorithm = self._thread_local.chal.get(\"algorithm\")\n        opaque = self._thread_local.chal.get(\"opaque\")\n        hash_utf8 = None\n\n        if algorithm is None:\n            _algorithm = \"MD5\"\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == \"MD5\" or _algorithm == \"MD5-SESS\":\n\n            def md5_utf8(x):\n                if isinstance(x, str):\n                    x = x.encode(\"utf-8\")\n                return hashlib.md5(x).hexdigest()\n\n            hash_utf8 = md5_utf8\n        elif _algorithm == \"SHA\":\n\n            def sha_utf8(x):\n                if isinstance(x, str):\n                    x = x.encode(\"utf-8\")\n                return hashlib.sha1(x).hexdigest()\n\n            hash_utf8 = sha_utf8\n        elif _algorithm == \"SHA-256\":\n\n            def sha256_utf8(x):\n                if isinstance(x, str):\n                    x = x.encode(\"utf-8\")\n                return hashlib.sha256(x).hexdigest()\n\n            hash_utf8 = sha256_utf8\n        elif _algorithm == \"SHA-512\":\n\n            def sha512_utf8(x):\n                if isinstance(x, str):\n                    x = x.encode(\"utf-8\")\n                return hashlib.sha512(x).hexdigest()\n\n            hash_utf8 = sha512_utf8\n\n        KD = lambda s, d: hash_utf8(f\"{s}:{d}\")  # noqa:E731\n\n        if hash_utf8 is None:\n            return None\n\n        # XXX not implemented yet\n        entdig = None\n        p_parsed = urlparse(url)\n        #: path is request-uri defined in RFC 2616 which should not be empty\n        path = p_parsed.path or \"/\"\n        if p_parsed.query:\n            path += f\"?{p_parsed.query}\"\n\n        A1 = f\"{self.username}:{realm}:{self.password}\"\n        A2 = f\"{method}:{path}\"\n\n        HA1 = hash_utf8(A1)\n        HA2 = hash_utf8(A2)\n\n        if nonce == self._thread_local.last_nonce:\n            self._thread_local.nonce_count += 1\n        else:\n            self._thread_local.nonce_count = 1\n        ncvalue = f\"{self._thread_local.nonce_count:08x}\"\n        s = str(self._thread_local.nonce_count).encode(\"utf-8\")\n        s += nonce.encode(\"utf-8\")\n        s += time.ctime().encode(\"utf-8\")\n        s += os.urandom(8)\n\n        cnonce = hashlib.sha1(s).hexdigest()[:16]\n        if _algorithm == \"MD5-SESS\":\n            HA1 = hash_utf8(f\"{HA1}:{nonce}:{cnonce}\")\n\n        if not qop:\n            respdig = KD(HA1, f\"{nonce}:{HA2}\")\n        elif qop == \"auth\" or \"auth\" in qop.split(\",\"):\n            noncebit = f\"{nonce}:{ncvalue}:{cnonce}:auth:{HA2}\"\n            respdig = KD(HA1, noncebit)\n        else:\n            # XXX handle auth-int.\n            return None\n\n        self._thread_local.last_nonce = nonce\n\n        # XXX should the partial digests be encoded too?\n        base = (\n            f'username=\"{self.username}\", realm=\"{realm}\", nonce=\"{nonce}\", '\n            f'uri=\"{path}\", response=\"{respdig}\"'\n        )\n        if opaque:\n            base += f', opaque=\"{opaque}\"'\n        if algorithm:\n            base += f', algorithm=\"{algorithm}\"'\n        if entdig:\n            base += f', digest=\"{entdig}\"'\n        if qop:\n            base += f', qop=\"auth\", nc={ncvalue}, cnonce=\"{cnonce}\"'\n\n        return f\"Digest {base}\"",
          "line_count": 109,
          "needs_llm_summary": true
        },
        {
          "name": "handle_redirect",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "r"
            }
          ],
          "return_type": null,
          "lineno": 236,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Reset num_401_calls counter on redirects.",
          "code": "def handle_redirect(self, r, **kwargs):\n        \"\"\"Reset num_401_calls counter on redirects.\"\"\"\n        if r.is_redirect:\n            self._thread_local.num_401_calls = 1",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "handle_401",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "r"
            }
          ],
          "return_type": null,
          "lineno": 241,
          "decorators": [],
          "is_async": false,
          "calls": [
            "r.close",
            "prep._cookies",
            "s_auth",
            "r.connection.send",
            "pat.sub",
            "prep.prepare_cookies",
            "r.request",
            "prep.method",
            "parse_dict_header",
            "s_auth.lower",
            "self.build_digest_header",
            "r.raw",
            "r.headers.get",
            "prep",
            "re.compile",
            "re.IGNORECASE",
            "_r.history.append",
            "r.request.body.seek",
            "extract_cookies_to_jar",
            "r.request.copy",
            "kwargs",
            "self._thread_local.pos",
            "r",
            "prep.url"
          ],
          "docstring": "Takes the given response and tries digest-auth, if needed.\n\n:rtype: requests.Response",
          "code": "def handle_401(self, r, **kwargs):\n        \"\"\"\n        Takes the given response and tries digest-auth, if needed.\n\n        :rtype: requests.Response\n        \"\"\"\n\n        # If response is not 4xx, do not auth\n        # See https://github.com/psf/requests/issues/3772\n        if not 400 <= r.status_code < 500:\n            self._thread_local.num_401_calls = 1\n            return r\n\n        if self._thread_local.pos is not None:\n            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get(\"www-authenticate\", \"\")\n\n        if \"digest\" in s_auth.lower() and self._thread_local.num_401_calls < 2:\n            self._thread_local.num_401_calls += 1\n            pat = re.compile(r\"digest \", flags=re.IGNORECASE)\n            self._thread_local.chal = parse_dict_header(pat.sub(\"\", s_auth, count=1))\n\n            # Consume content and release the original connection\n            # to allow our new request to reuse the same one.\n            r.content\n            r.close()\n            prep = r.request.copy()\n            extract_cookies_to_jar(prep._cookies, r.request, r.raw)\n            prep.prepare_cookies(prep._cookies)\n\n            prep.headers[\"Authorization\"] = self.build_digest_header(\n                prep.method, prep.url\n            )\n            _r = r.connection.send(prep, **kwargs)\n            _r.history.append(r)\n            _r.request = prep\n\n            return _r\n\n        self._thread_local.num_401_calls = 1\n        return r",
          "line_count": 43,
          "needs_llm_summary": true
        },
        {
          "name": "__call__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "r"
            }
          ],
          "return_type": null,
          "lineno": 285,
          "decorators": [],
          "is_async": false,
          "calls": [
            "r.register_hook",
            "r.body.tell",
            "self.init_per_thread_state",
            "r.url",
            "r.method",
            "self.build_digest_header",
            "self.handle_redirect",
            "self.handle_401"
          ],
          "docstring": null,
          "code": "def __call__(self, r):\n        # Initialize per-thread state, if needed\n        self.init_per_thread_state()\n        # If we have a saved nonce, skip the 401\n        if self._thread_local.last_nonce:\n            r.headers[\"Authorization\"] = self.build_digest_header(r.method, r.url)\n        try:\n            self._thread_local.pos = r.body.tell()\n        except AttributeError:\n            # In the case of HTTPDigestAuth being reused and the body of\n            # the previous request was a file-like object, pos has the\n            # file position of the previous body. Ensure it's set to\n            # None.\n            self._thread_local.pos = None\n        r.register_hook(\"response\", self.handle_401)\n        r.register_hook(\"response\", self.handle_redirect)\n        self._thread_local.num_401_calls = 1\n\n        return r",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "__eq__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "other"
            }
          ],
          "return_type": null,
          "lineno": 305,
          "decorators": [],
          "is_async": false,
          "calls": [
            "all",
            "getattr",
            "other"
          ],
          "docstring": null,
          "code": "def __eq__(self, other):\n        return all(\n            [\n                self.username == getattr(other, \"username\", None),\n                self.password == getattr(other, \"password\", None),\n            ]\n        )",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__ne__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "other"
            }
          ],
          "return_type": null,
          "lineno": 313,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __ne__(self, other):\n        return not self == other",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "md5_utf8",
          "args": [
            {
              "name": "x"
            }
          ],
          "return_type": null,
          "lineno": 145,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "hashlib.md5",
            "x",
            "str",
            "unknown.hexdigest",
            "x.encode"
          ],
          "docstring": null,
          "code": "def md5_utf8(x):\n                if isinstance(x, str):\n                    x = x.encode(\"utf-8\")\n                return hashlib.md5(x).hexdigest()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "sha_utf8",
          "args": [
            {
              "name": "x"
            }
          ],
          "return_type": null,
          "lineno": 153,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "x",
            "hashlib.sha1",
            "str",
            "unknown.hexdigest",
            "x.encode"
          ],
          "docstring": null,
          "code": "def sha_utf8(x):\n                if isinstance(x, str):\n                    x = x.encode(\"utf-8\")\n                return hashlib.sha1(x).hexdigest()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "sha256_utf8",
          "args": [
            {
              "name": "x"
            }
          ],
          "return_type": null,
          "lineno": 161,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "x",
            "str",
            "unknown.hexdigest",
            "x.encode",
            "hashlib.sha256"
          ],
          "docstring": null,
          "code": "def sha256_utf8(x):\n                if isinstance(x, str):\n                    x = x.encode(\"utf-8\")\n                return hashlib.sha256(x).hexdigest()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "sha512_utf8",
          "args": [
            {
              "name": "x"
            }
          ],
          "return_type": null,
          "lineno": 169,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "hashlib.sha512",
            "x",
            "str",
            "unknown.hexdigest",
            "x.encode"
          ],
          "docstring": null,
          "code": "def sha512_utf8(x):\n                if isinstance(x, str):\n                    x = x.encode(\"utf-8\")\n                return hashlib.sha512(x).hexdigest()",
          "line_count": 4,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "AuthBase",
          "methods": [
            "__call__"
          ],
          "base_classes": [],
          "lineno": 69,
          "docstring": "Base class that all auth implementations derive from"
        },
        {
          "name": "HTTPBasicAuth",
          "methods": [
            "__init__",
            "__eq__",
            "__ne__",
            "__call__"
          ],
          "base_classes": [
            "AuthBase"
          ],
          "lineno": 76,
          "docstring": "Attaches HTTP Basic Authentication to the given Request object."
        },
        {
          "name": "HTTPProxyAuth",
          "methods": [
            "__call__"
          ],
          "base_classes": [
            "HTTPBasicAuth"
          ],
          "lineno": 99,
          "docstring": "Attaches HTTP Proxy Authentication to a given Request object."
        },
        {
          "name": "HTTPDigestAuth",
          "methods": [
            "__init__",
            "init_per_thread_state",
            "build_digest_header",
            "handle_redirect",
            "handle_401",
            "__call__",
            "__eq__",
            "__ne__"
          ],
          "base_classes": [
            "AuthBase"
          ],
          "lineno": 107,
          "docstring": "Attaches HTTP Digest Authentication to the given Request object."
        }
      ],
      "imports": [
        {
          "module": "hashlib",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "re",
          "alias": null,
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "threading",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "time",
          "alias": null,
          "lineno": 12,
          "type": "import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 13,
          "type": "import"
        },
        {
          "module": "base64",
          "name": "b64encode",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "_internal_utils",
          "name": "to_native_string",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "basestring",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "str",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlparse",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "extract_cookies_to_jar",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "parse_dict_header",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "CONTENT_TYPE_FORM_URLENCODED",
          "assigned_to": "str",
          "lineno": 21
        },
        {
          "name": "CONTENT_TYPE_MULTI_PART",
          "assigned_to": "str",
          "lineno": 22
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "threading",
          "time",
          "warnings",
          "os",
          "re"
        ],
        "third_party": {
          "other": [
            "hashlib",
            "base64",
            "_internal_utils",
            "compat",
            "cookies",
            "utils"
          ]
        },
        "tech_stack": []
      },
      "line_count": 315
    },
    "src/requests/certs.py": {
      "filepath": "../requests/src/requests/certs.py",
      "module_docstring": "requests.certs\n~~~~~~~~~~~~~~\n\nThis module returns the preferred default CA certificate bundle. There is\nonly one \u2014 the one from the certifi package.\n\nIf you are packaging Requests, e.g., for a Linux distribution or a managed\nenvironment, you can change the definition of where() to return a separately\npackaged CA bundle.",
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "certifi",
          "name": "where",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": true,
      "main_block_calls": [
        "print",
        "where"
      ],
      "module_level_calls": {
        "function_calls": [
          "print",
          "where"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "certifi"
          ]
        },
        "tech_stack": []
      },
      "line_count": 18
    },
    "src/requests/compat.py": {
      "filepath": "../requests/src/requests/compat.py",
      "module_docstring": "requests.compat\n~~~~~~~~~~~~~~~\n\nThis module previously handled import compatibility issues\nbetween Python 2 and Python 3. It remains for backwards\ncompatibility until the next major version.",
      "functions": [
        {
          "name": "_resolve_char_detection",
          "args": [],
          "return_type": null,
          "lineno": 30,
          "decorators": [],
          "is_async": false,
          "calls": [
            "lib",
            "importlib.import_module"
          ],
          "docstring": "Find supported character detection libraries.",
          "code": "def _resolve_char_detection():\n    \"\"\"Find supported character detection libraries.\"\"\"\n    chardet = None\n    for lib in (\"chardet\", \"charset_normalizer\"):\n        if chardet is None:\n            try:\n                chardet = importlib.import_module(lib)\n            except ImportError:\n                pass\n    return chardet",
          "line_count": 10,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "importlib",
          "alias": null,
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "urllib3",
          "name": "__version__",
          "alias": "urllib3_version",
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "collections",
          "name": "OrderedDict",
          "alias": null,
          "lineno": 72,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "name": "Callable",
          "alias": null,
          "lineno": 73,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "name": "Mapping",
          "alias": null,
          "lineno": 73,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "name": "MutableMapping",
          "alias": null,
          "lineno": 73,
          "type": "from_import"
        },
        {
          "module": "http",
          "name": "cookiejar",
          "alias": "cookielib",
          "lineno": 74,
          "type": "from_import"
        },
        {
          "module": "http.cookies",
          "name": "Morsel",
          "alias": null,
          "lineno": 75,
          "type": "from_import"
        },
        {
          "module": "io",
          "name": "StringIO",
          "alias": null,
          "lineno": 76,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "quote",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "quote_plus",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "unquote",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "unquote_plus",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "urldefrag",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "urlencode",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "urljoin",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "urlparse",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "urlsplit",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "urlunparse",
          "alias": null,
          "lineno": 81,
          "type": "from_import"
        },
        {
          "module": "urllib.request",
          "name": "getproxies",
          "alias": null,
          "lineno": 93,
          "type": "from_import"
        },
        {
          "module": "urllib.request",
          "name": "getproxies_environment",
          "alias": null,
          "lineno": 93,
          "type": "from_import"
        },
        {
          "module": "urllib.request",
          "name": "parse_http_list",
          "alias": null,
          "lineno": 93,
          "type": "from_import"
        },
        {
          "module": "urllib.request",
          "name": "proxy_bypass",
          "alias": null,
          "lineno": 93,
          "type": "from_import"
        },
        {
          "module": "urllib.request",
          "name": "proxy_bypass_environment",
          "alias": null,
          "lineno": 93,
          "type": "from_import"
        },
        {
          "module": "simplejson",
          "alias": "json",
          "lineno": 60,
          "type": "import"
        },
        {
          "module": "simplejson",
          "name": "JSONDecodeError",
          "alias": null,
          "lineno": 67,
          "type": "from_import"
        },
        {
          "module": "json",
          "name": "JSONDecodeError",
          "alias": null,
          "lineno": 69,
          "type": "from_import"
        },
        {
          "module": "json",
          "alias": null,
          "lineno": 64,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "chardet",
          "assigned_to": "_resolve_char_detection",
          "lineno": 42
        },
        {
          "name": "_ver",
          "assigned_to": null,
          "lineno": 49
        },
        {
          "name": "is_py2",
          "assigned_to": null,
          "lineno": 52
        },
        {
          "name": "is_py3",
          "assigned_to": null,
          "lineno": 55
        },
        {
          "name": "has_simplejson",
          "assigned_to": "bool",
          "lineno": 58
        },
        {
          "name": "builtin_str",
          "assigned_to": "str",
          "lineno": 101
        },
        {
          "name": "str",
          "assigned_to": "str",
          "lineno": 102
        },
        {
          "name": "bytes",
          "assigned_to": "bytes",
          "lineno": 103
        },
        {
          "name": "basestring",
          "assigned_to": null,
          "lineno": 104
        },
        {
          "name": "numeric_types",
          "assigned_to": null,
          "lineno": 105
        },
        {
          "name": "integer_types",
          "assigned_to": null,
          "lineno": 106
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "urllib3_version.split",
          "_resolve_char_detection",
          "str",
          "sys.version_info",
          "bytes",
          "int"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "json",
          "sys",
          "io",
          "collections"
        ],
        "third_party": {
          "other": [
            "importlib",
            "urllib3",
            "http",
            "urllib",
            "simplejson"
          ]
        },
        "tech_stack": []
      },
      "line_count": 107
    },
    "src/requests/cookies.py": {
      "filepath": "../requests/src/requests/cookies.py",
      "module_docstring": "requests.cookies\n~~~~~~~~~~~~~~~~\n\nCompatibility code to be able to use `http.cookiejar.CookieJar` with requests.\n\nrequests.utils imports from here, so be careful with imports.",
      "functions": [
        {
          "name": "extract_cookies_to_jar",
          "args": [
            {
              "name": "jar"
            },
            {
              "name": "request"
            },
            {
              "name": "response"
            }
          ],
          "return_type": null,
          "lineno": 124,
          "decorators": [],
          "is_async": false,
          "calls": [
            "MockRequest",
            "jar.extract_cookies",
            "res",
            "request",
            "response._original_response.msg",
            "response",
            "hasattr",
            "req",
            "MockResponse"
          ],
          "docstring": "Extract the cookies from the response into a CookieJar.\n\n:param jar: http.cookiejar.CookieJar (not necessarily a RequestsCookieJar)\n:param request: our own requests.Request object\n:param response: urllib3.HTTPResponse object",
          "code": "def extract_cookies_to_jar(jar, request, response):\n    \"\"\"Extract the cookies from the response into a CookieJar.\n\n    :param jar: http.cookiejar.CookieJar (not necessarily a RequestsCookieJar)\n    :param request: our own requests.Request object\n    :param response: urllib3.HTTPResponse object\n    \"\"\"\n    if not (hasattr(response, \"_original_response\") and response._original_response):\n        return\n    # the _original_response field is the wrapped httplib.HTTPResponse object,\n    req = MockRequest(request)\n    # pull out the HTTPMessage with the headers and put it in the mock:\n    res = MockResponse(response._original_response.msg)\n    jar.extract_cookies(res, req)",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "get_cookie_header",
          "args": [
            {
              "name": "jar"
            },
            {
              "name": "request"
            }
          ],
          "return_type": null,
          "lineno": 140,
          "decorators": [],
          "is_async": false,
          "calls": [
            "MockRequest",
            "jar.add_cookie_header",
            "request",
            "r",
            "r.get_new_headers",
            "unknown.get"
          ],
          "docstring": "Produce an appropriate Cookie header string to be sent with `request`, or None.\n\n:rtype: str",
          "code": "def get_cookie_header(jar, request):\n    \"\"\"\n    Produce an appropriate Cookie header string to be sent with `request`, or None.\n\n    :rtype: str\n    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get(\"Cookie\")",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "remove_cookie_by_name",
          "args": [
            {
              "name": "cookiejar"
            },
            {
              "name": "name"
            },
            {
              "name": "domain"
            },
            {
              "name": "path"
            }
          ],
          "return_type": null,
          "lineno": 151,
          "decorators": [],
          "is_async": false,
          "calls": [
            "path",
            "clearables.append",
            "name",
            "domain",
            "cookiejar.clear"
          ],
          "docstring": "Unsets a cookie by name, by default over all domains and paths.\n\nWraps CookieJar.clear(), is O(n).",
          "code": "def remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n    \"\"\"Unsets a cookie by name, by default over all domains and paths.\n\n    Wraps CookieJar.clear(), is O(n).\n    \"\"\"\n    clearables = []\n    for cookie in cookiejar:\n        if cookie.name != name:\n            continue\n        if domain is not None and domain != cookie.domain:\n            continue\n        if path is not None and path != cookie.path:\n            continue\n        clearables.append((cookie.domain, cookie.path, cookie.name))\n\n    for domain, path, name in clearables:\n        cookiejar.clear(domain, path, name)",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "_copy_cookie_jar",
          "args": [
            {
              "name": "jar"
            }
          ],
          "return_type": null,
          "lineno": 440,
          "decorators": [],
          "is_async": false,
          "calls": [
            "copy.copy",
            "new_jar.clear",
            "hasattr",
            "new_jar.set_cookie",
            "jar",
            "cookie",
            "jar.copy"
          ],
          "docstring": null,
          "code": "def _copy_cookie_jar(jar):\n    if jar is None:\n        return None\n\n    if hasattr(jar, \"copy\"):\n        # We're dealing with an instance of RequestsCookieJar\n        return jar.copy()\n    # We're dealing with a generic CookieJar instance\n    new_jar = copy.copy(jar)\n    new_jar.clear()\n    for cookie in jar:\n        new_jar.set_cookie(copy.copy(cookie))\n    return new_jar",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "create_cookie",
          "args": [
            {
              "name": "name"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 455,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.startswith",
            "cookielib.Cookie",
            "result",
            "kwargs",
            "list",
            "bool",
            "set",
            "TypeError",
            "result.update",
            "badargs"
          ],
          "docstring": "Make a cookie from underspecified parameters.\n\nBy default, the pair of `name` and `value` will be set for the domain ''\nand sent on every request (this is sometimes called a \"supercookie\").",
          "code": "def create_cookie(name, value, **kwargs):\n    \"\"\"Make a cookie from underspecified parameters.\n\n    By default, the pair of `name` and `value` will be set for the domain ''\n    and sent on every request (this is sometimes called a \"supercookie\").\n    \"\"\"\n    result = {\n        \"version\": 0,\n        \"name\": name,\n        \"value\": value,\n        \"port\": None,\n        \"domain\": \"\",\n        \"path\": \"/\",\n        \"secure\": False,\n        \"expires\": None,\n        \"discard\": True,\n        \"comment\": None,\n        \"comment_url\": None,\n        \"rest\": {\"HttpOnly\": None},\n        \"rfc2109\": False,\n    }\n\n    badargs = set(kwargs) - set(result)\n    if badargs:\n        raise TypeError(\n            f\"create_cookie() got unexpected keyword arguments: {list(badargs)}\"\n        )\n\n    result.update(kwargs)\n    result[\"port_specified\"] = bool(result[\"port\"])\n    result[\"domain_specified\"] = bool(result[\"domain\"])\n    result[\"domain_initial_dot\"] = result[\"domain\"].startswith(\".\")\n    result[\"path_specified\"] = bool(result[\"path\"])\n\n    return cookielib.Cookie(**result)",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "morsel_to_cookie",
          "args": [
            {
              "name": "morsel"
            }
          ],
          "return_type": null,
          "lineno": 492,
          "decorators": [],
          "is_async": false,
          "calls": [
            "expires",
            "morsel.value",
            "time.time",
            "morsel.key",
            "create_cookie",
            "time_template",
            "bool",
            "TypeError",
            "time.strptime",
            "calendar.timegm",
            "int"
          ],
          "docstring": "Convert a Morsel object into a Cookie containing the one k/v pair.",
          "code": "def morsel_to_cookie(morsel):\n    \"\"\"Convert a Morsel object into a Cookie containing the one k/v pair.\"\"\"\n\n    expires = None\n    if morsel[\"max-age\"]:\n        try:\n            expires = int(time.time() + int(morsel[\"max-age\"]))\n        except ValueError:\n            raise TypeError(f\"max-age: {morsel['max-age']} must be integer\")\n    elif morsel[\"expires\"]:\n        time_template = \"%a, %d-%b-%Y %H:%M:%S GMT\"\n        expires = calendar.timegm(time.strptime(morsel[\"expires\"], time_template))\n    return create_cookie(\n        comment=morsel[\"comment\"],\n        comment_url=bool(morsel[\"comment\"]),\n        discard=False,\n        domain=morsel[\"domain\"],\n        expires=expires,\n        name=morsel.key,\n        path=morsel[\"path\"],\n        port=None,\n        rest={\"HttpOnly\": morsel[\"httponly\"]},\n        rfc2109=False,\n        secure=bool(morsel[\"secure\"]),\n        value=morsel.value,\n        version=morsel[\"version\"] or 0,\n    )",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "cookiejar_from_dict",
          "args": [
            {
              "name": "cookie_dict"
            },
            {
              "name": "cookiejar"
            },
            {
              "name": "overwrite"
            }
          ],
          "return_type": null,
          "lineno": 521,
          "decorators": [],
          "is_async": false,
          "calls": [
            "create_cookie",
            "RequestsCookieJar",
            "cookiejar.set_cookie",
            "name"
          ],
          "docstring": "Returns a CookieJar from a key/value dictionary.\n\n:param cookie_dict: Dict of key/values to insert into CookieJar.\n:param cookiejar: (optional) A cookiejar to add the cookies to.\n:param overwrite: (optional) If False, will not replace cookies\n    already in the jar with new ones.\n:rtype: CookieJar",
          "code": "def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :param cookiejar: (optional) A cookiejar to add the cookies to.\n    :param overwrite: (optional) If False, will not replace cookies\n        already in the jar with new ones.\n    :rtype: CookieJar\n    \"\"\"\n    if cookiejar is None:\n        cookiejar = RequestsCookieJar()\n\n    if cookie_dict is not None:\n        names_from_jar = [cookie.name for cookie in cookiejar]\n        for name in cookie_dict:\n            if overwrite or (name not in names_from_jar):\n                cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))\n\n    return cookiejar",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "merge_cookies",
          "args": [
            {
              "name": "cookiejar"
            },
            {
              "name": "cookies"
            }
          ],
          "return_type": null,
          "lineno": 542,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "cookiejar.update",
            "cookiejar.set_cookie",
            "cookie_in_jar",
            "cookielib.CookieJar",
            "ValueError",
            "cookiejar_from_dict",
            "cookiejar",
            "cookies",
            "dict"
          ],
          "docstring": "Add cookies to cookiejar and returns a merged CookieJar.\n\n:param cookiejar: CookieJar object to add the cookies to.\n:param cookies: Dictionary or CookieJar object to be added.\n:rtype: CookieJar",
          "code": "def merge_cookies(cookiejar, cookies):\n    \"\"\"Add cookies to cookiejar and returns a merged CookieJar.\n\n    :param cookiejar: CookieJar object to add the cookies to.\n    :param cookies: Dictionary or CookieJar object to be added.\n    :rtype: CookieJar\n    \"\"\"\n    if not isinstance(cookiejar, cookielib.CookieJar):\n        raise ValueError(\"You can only merge into CookieJar\")\n\n    if isinstance(cookies, dict):\n        cookiejar = cookiejar_from_dict(cookies, cookiejar=cookiejar, overwrite=False)\n    elif isinstance(cookies, cookielib.CookieJar):\n        try:\n            cookiejar.update(cookies)\n        except AttributeError:\n            for cookie_in_jar in cookies:\n                cookiejar.set_cookie(cookie_in_jar)\n\n    return cookiejar",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            }
          ],
          "return_type": null,
          "lineno": 35,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.scheme",
            "self._r.url",
            "urlparse",
            "request"
          ],
          "docstring": null,
          "code": "def __init__(self, request):\n        self._r = request\n        self._new_headers = {}\n        self.type = urlparse(self._r.url).scheme",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "get_type",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 40,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_type(self):\n        return self.type",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_host",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 43,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._r.url",
            "urlparse"
          ],
          "docstring": null,
          "code": "def get_host(self):\n        return urlparse(self._r.url).netloc",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_origin_req_host",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 46,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.get_host"
          ],
          "docstring": null,
          "code": "def get_origin_req_host(self):\n        return self.get_host()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_full_url",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 49,
          "decorators": [],
          "is_async": false,
          "calls": [
            "to_native_string",
            "self._r.url",
            "self._r.headers.get",
            "urlparse",
            "urlunparse"
          ],
          "docstring": null,
          "code": "def get_full_url(self):\n        # Only return the response's URL if the user hadn't set the Host\n        # header\n        if not self._r.headers.get(\"Host\"):\n            return self._r.url\n        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers[\"Host\"], encoding=\"utf-8\")\n        parsed = urlparse(self._r.url)\n        # Reconstruct the URL as we expect it\n        return urlunparse(\n            [\n                parsed.scheme,\n                host,\n                parsed.path,\n                parsed.params,\n                parsed.query,\n                parsed.fragment,\n            ]\n        )",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "is_unverifiable",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 69,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def is_unverifiable(self):\n        return True",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "has_header",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 72,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def has_header(self, name):\n        return name in self._r.headers or name in self._new_headers",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_header",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            },
            {
              "name": "default"
            }
          ],
          "return_type": null,
          "lineno": 75,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._r.headers.get",
            "self._new_headers.get",
            "default",
            "name"
          ],
          "docstring": null,
          "code": "def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "add_header",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key"
            },
            {
              "name": "val"
            }
          ],
          "return_type": null,
          "lineno": 78,
          "decorators": [],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": "cookiejar has no legitimate use for this method; add it back if you find one.",
          "code": "def add_header(self, key, val):\n        \"\"\"cookiejar has no legitimate use for this method; add it back if you find one.\"\"\"\n        raise NotImplementedError(\n            \"Cookie headers should be added with add_unredirected_header()\"\n        )",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "add_unredirected_header",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 84,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value"
          ],
          "docstring": null,
          "code": "def add_unredirected_header(self, name, value):\n        self._new_headers[name] = value",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_new_headers",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 87,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def get_new_headers(self):\n        return self._new_headers",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "unverifiable",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 91,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.is_unverifiable"
          ],
          "docstring": null,
          "code": "def unverifiable(self):\n        return self.is_unverifiable()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "origin_req_host",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 95,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.get_origin_req_host"
          ],
          "docstring": null,
          "code": "def origin_req_host(self):\n        return self.get_origin_req_host()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "host",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 99,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.get_host"
          ],
          "docstring": null,
          "code": "def host(self):\n        return self.get_host()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "headers"
            }
          ],
          "return_type": null,
          "lineno": 110,
          "decorators": [],
          "is_async": false,
          "calls": [
            "headers"
          ],
          "docstring": "Make a MockResponse for `cookiejar` to read.\n\n:param headers: a httplib.HTTPMessage or analogous carrying the headers",
          "code": "def __init__(self, headers):\n        \"\"\"Make a MockResponse for `cookiejar` to read.\n\n        :param headers: a httplib.HTTPMessage or analogous carrying the headers\n        \"\"\"\n        self._headers = headers",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "info",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 117,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def info(self):\n        return self._headers",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "getheaders",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 120,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._headers.getheaders",
            "name"
          ],
          "docstring": null,
          "code": "def getheaders(self, name):\n        self._headers.getheaders(name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            },
            {
              "name": "default"
            },
            {
              "name": "domain"
            },
            {
              "name": "path"
            }
          ],
          "return_type": null,
          "lineno": 194,
          "decorators": [],
          "is_async": false,
          "calls": [
            "path",
            "domain",
            "name",
            "self._find_no_duplicates"
          ],
          "docstring": "Dict-like get() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n\n.. warning:: operation is O(n), not O(1).",
          "code": "def get(self, name, default=None, domain=None, path=None):\n        \"\"\"Dict-like get() that also supports optional domain and path args in\n        order to resolve naming collisions from using one cookie jar over\n        multiple domains.\n\n        .. warning:: operation is O(n), not O(1).\n        \"\"\"\n        try:\n            return self._find_no_duplicates(name, domain, path)\n        except KeyError:\n            return default",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "set",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 206,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "kwargs.get",
            "create_cookie",
            "kwargs",
            "self.set_cookie",
            "remove_cookie_by_name",
            "morsel_to_cookie",
            "self",
            "c",
            "Morsel",
            "value",
            "name"
          ],
          "docstring": "Dict-like set() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.",
          "code": "def set(self, name, value, **kwargs):\n        \"\"\"Dict-like set() that also supports optional domain and path args in\n        order to resolve naming collisions from using one cookie jar over\n        multiple domains.\n        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(\n                self, name, domain=kwargs.get(\"domain\"), path=kwargs.get(\"path\")\n            )\n            return\n\n        if isinstance(value, Morsel):\n            c = morsel_to_cookie(value)\n        else:\n            c = create_cookie(name, value, **kwargs)\n        self.set_cookie(c)\n        return c",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "iterkeys",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 225,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "iter"
          ],
          "docstring": "Dict-like iterkeys() that returns an iterator of names of cookies\nfrom the jar.\n\n.. seealso:: itervalues() and iteritems().",
          "code": "def iterkeys(self):\n        \"\"\"Dict-like iterkeys() that returns an iterator of names of cookies\n        from the jar.\n\n        .. seealso:: itervalues() and iteritems().\n        \"\"\"\n        for cookie in iter(self):\n            yield cookie.name",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "keys",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 234,
          "decorators": [],
          "is_async": false,
          "calls": [
            "list",
            "self.iterkeys"
          ],
          "docstring": "Dict-like keys() that returns a list of names of cookies from the\njar.\n\n.. seealso:: values() and items().",
          "code": "def keys(self):\n        \"\"\"Dict-like keys() that returns a list of names of cookies from the\n        jar.\n\n        .. seealso:: values() and items().\n        \"\"\"\n        return list(self.iterkeys())",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "itervalues",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 242,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "iter"
          ],
          "docstring": "Dict-like itervalues() that returns an iterator of values of cookies\nfrom the jar.\n\n.. seealso:: iterkeys() and iteritems().",
          "code": "def itervalues(self):\n        \"\"\"Dict-like itervalues() that returns an iterator of values of cookies\n        from the jar.\n\n        .. seealso:: iterkeys() and iteritems().\n        \"\"\"\n        for cookie in iter(self):\n            yield cookie.value",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "values",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 251,
          "decorators": [],
          "is_async": false,
          "calls": [
            "list",
            "self.itervalues"
          ],
          "docstring": "Dict-like values() that returns a list of values of cookies from the\njar.\n\n.. seealso:: keys() and items().",
          "code": "def values(self):\n        \"\"\"Dict-like values() that returns a list of values of cookies from the\n        jar.\n\n        .. seealso:: keys() and items().\n        \"\"\"\n        return list(self.itervalues())",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "iteritems",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 259,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "iter"
          ],
          "docstring": "Dict-like iteritems() that returns an iterator of name-value tuples\nfrom the jar.\n\n.. seealso:: iterkeys() and itervalues().",
          "code": "def iteritems(self):\n        \"\"\"Dict-like iteritems() that returns an iterator of name-value tuples\n        from the jar.\n\n        .. seealso:: iterkeys() and itervalues().\n        \"\"\"\n        for cookie in iter(self):\n            yield cookie.name, cookie.value",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "items",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 268,
          "decorators": [],
          "is_async": false,
          "calls": [
            "list",
            "self.iteritems"
          ],
          "docstring": "Dict-like items() that returns a list of name-value tuples from the\njar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a\nvanilla python dict of key value pairs.\n\n.. seealso:: keys() and values().",
          "code": "def items(self):\n        \"\"\"Dict-like items() that returns a list of name-value tuples from the\n        jar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a\n        vanilla python dict of key value pairs.\n\n        .. seealso:: keys() and values().\n        \"\"\"\n        return list(self.iteritems())",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "list_domains",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 277,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "domains.append",
            "iter",
            "cookie.domain"
          ],
          "docstring": "Utility method to list all the domains in the jar.",
          "code": "def list_domains(self):\n        \"\"\"Utility method to list all the domains in the jar.\"\"\"\n        domains = []\n        for cookie in iter(self):\n            if cookie.domain not in domains:\n                domains.append(cookie.domain)\n        return domains",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "list_paths",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 285,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "iter",
            "cookie.path",
            "paths.append"
          ],
          "docstring": "Utility method to list all the paths in the jar.",
          "code": "def list_paths(self):\n        \"\"\"Utility method to list all the paths in the jar.\"\"\"\n        paths = []\n        for cookie in iter(self):\n            if cookie.path not in paths:\n                paths.append(cookie.path)\n        return paths",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "multiple_domains",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 293,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "domains.append",
            "iter",
            "cookie.domain"
          ],
          "docstring": "Returns True if there are multiple domains in the jar.\nReturns False otherwise.\n\n:rtype: bool",
          "code": "def multiple_domains(self):\n        \"\"\"Returns True if there are multiple domains in the jar.\n        Returns False otherwise.\n\n        :rtype: bool\n        \"\"\"\n        domains = []\n        for cookie in iter(self):\n            if cookie.domain is not None and cookie.domain in domains:\n                return True\n            domains.append(cookie.domain)\n        return False",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "get_dict",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "domain"
            },
            {
              "name": "path"
            }
          ],
          "return_type": null,
          "lineno": 306,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "cookie.value",
            "iter"
          ],
          "docstring": "Takes as an argument an optional domain and path and returns a plain\nold Python dict of name-value pairs of cookies that meet the\nrequirements.\n\n:rtype: dict",
          "code": "def get_dict(self, domain=None, path=None):\n        \"\"\"Takes as an argument an optional domain and path and returns a plain\n        old Python dict of name-value pairs of cookies that meet the\n        requirements.\n\n        :rtype: dict\n        \"\"\"\n        dictionary = {}\n        for cookie in iter(self):\n            if (domain is None or cookie.domain == domain) and (\n                path is None or cookie.path == path\n            ):\n                dictionary[cookie.name] = cookie.value\n        return dictionary",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "__contains__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 321,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__contains__",
            "name",
            "super"
          ],
          "docstring": null,
          "code": "def __contains__(self, name):\n        try:\n            return super().__contains__(name)\n        except CookieConflictError:\n            return True",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__getitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 327,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "self._find_no_duplicates"
          ],
          "docstring": "Dict-like __getitem__() for compatibility with client code. Throws\nexception if there are more than one cookie with name. In that case,\nuse the more explicit get() method instead.\n\n.. warning:: operation is O(n), not O(1).",
          "code": "def __getitem__(self, name):\n        \"\"\"Dict-like __getitem__() for compatibility with client code. Throws\n        exception if there are more than one cookie with name. In that case,\n        use the more explicit get() method instead.\n\n        .. warning:: operation is O(n), not O(1).\n        \"\"\"\n        return self._find_no_duplicates(name)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "__setitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 336,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "self.set",
            "value"
          ],
          "docstring": "Dict-like __setitem__ for compatibility with client code. Throws\nexception if there is already a cookie of that name in the jar. In that\ncase, use the more explicit set() method instead.",
          "code": "def __setitem__(self, name, value):\n        \"\"\"Dict-like __setitem__ for compatibility with client code. Throws\n        exception if there is already a cookie of that name in the jar. In that\n        case, use the more explicit set() method instead.\n        \"\"\"\n        self.set(name, value)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "__delitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 343,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "remove_cookie_by_name",
            "name"
          ],
          "docstring": "Deletes a cookie given a name. Wraps ``http.cookiejar.CookieJar``'s\n``remove_cookie_by_name()``.",
          "code": "def __delitem__(self, name):\n        \"\"\"Deletes a cookie given a name. Wraps ``http.cookiejar.CookieJar``'s\n        ``remove_cookie_by_name()``.\n        \"\"\"\n        remove_cookie_by_name(self, name)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "set_cookie",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "cookie"
            }
          ],
          "return_type": null,
          "lineno": 349,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.set_cookie",
            "cookie.value",
            "kwargs",
            "cookie.value.endswith",
            "super",
            "hasattr",
            "cookie.value.startswith",
            "cookie.value.replace",
            "cookie"
          ],
          "docstring": null,
          "code": "def set_cookie(self, cookie, *args, **kwargs):\n        if (\n            hasattr(cookie.value, \"startswith\")\n            and cookie.value.startswith('\"')\n            and cookie.value.endswith('\"')\n        ):\n            cookie.value = cookie.value.replace('\\\\\"', \"\")\n        return super().set_cookie(cookie, *args, **kwargs)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "update",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "other"
            }
          ],
          "return_type": null,
          "lineno": 358,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "unknown.update",
            "other",
            "self.set_cookie",
            "cookielib.CookieJar",
            "super",
            "copy.copy",
            "cookie"
          ],
          "docstring": "Updates this jar with cookies from another CookieJar or dict-like",
          "code": "def update(self, other):\n        \"\"\"Updates this jar with cookies from another CookieJar or dict-like\"\"\"\n        if isinstance(other, cookielib.CookieJar):\n            for cookie in other:\n                self.set_cookie(copy.copy(cookie))\n        else:\n            super().update(other)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_find",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            },
            {
              "name": "domain"
            },
            {
              "name": "path"
            }
          ],
          "return_type": null,
          "lineno": 366,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "iter",
            "KeyError"
          ],
          "docstring": "Requests uses this method internally to get cookie values.\n\nIf there are conflicting cookies, _find arbitrarily chooses one.\nSee _find_no_duplicates if you want an exception thrown if there are\nconflicting cookies.\n\n:param name: a string containing name of cookie\n:param domain: (optional) string containing domain of cookie\n:param path: (optional) string containing path of cookie\n:return: cookie.value",
          "code": "def _find(self, name, domain=None, path=None):\n        \"\"\"Requests uses this method internally to get cookie values.\n\n        If there are conflicting cookies, _find arbitrarily chooses one.\n        See _find_no_duplicates if you want an exception thrown if there are\n        conflicting cookies.\n\n        :param name: a string containing name of cookie\n        :param domain: (optional) string containing domain of cookie\n        :param path: (optional) string containing path of cookie\n        :return: cookie.value\n        \"\"\"\n        for cookie in iter(self):\n            if cookie.name == name:\n                if domain is None or cookie.domain == domain:\n                    if path is None or cookie.path == path:\n                        return cookie.value\n\n        raise KeyError(f\"name={name!r}, domain={domain!r}, path={path!r}\")",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "_find_no_duplicates",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            },
            {
              "name": "domain"
            },
            {
              "name": "path"
            }
          ],
          "return_type": null,
          "lineno": 386,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cookie.value",
            "CookieConflictError",
            "KeyError",
            "self",
            "iter"
          ],
          "docstring": "Both ``__get_item__`` and ``get`` call this function: it's never\nused elsewhere in Requests.\n\n:param name: a string containing name of cookie\n:param domain: (optional) string containing domain of cookie\n:param path: (optional) string containing path of cookie\n:raises KeyError: if cookie is not found\n:raises CookieConflictError: if there are multiple cookies\n    that match name and optionally domain and path\n:return: cookie.value",
          "code": "def _find_no_duplicates(self, name, domain=None, path=None):\n        \"\"\"Both ``__get_item__`` and ``get`` call this function: it's never\n        used elsewhere in Requests.\n\n        :param name: a string containing name of cookie\n        :param domain: (optional) string containing domain of cookie\n        :param path: (optional) string containing path of cookie\n        :raises KeyError: if cookie is not found\n        :raises CookieConflictError: if there are multiple cookies\n            that match name and optionally domain and path\n        :return: cookie.value\n        \"\"\"\n        toReturn = None\n        for cookie in iter(self):\n            if cookie.name == name:\n                if domain is None or cookie.domain == domain:\n                    if path is None or cookie.path == path:\n                        if toReturn is not None:\n                            # if there are multiple cookies that meet passed in criteria\n                            raise CookieConflictError(\n                                f\"There are multiple cookies with name, {name!r}\"\n                            )\n                        # we will eventually return this as long as no cookie conflict\n                        toReturn = cookie.value\n\n        if toReturn:\n            return toReturn\n        raise KeyError(f\"name={name!r}, domain={domain!r}, path={path!r}\")",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "__getstate__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 415,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.__dict__.copy",
            "state.pop"
          ],
          "docstring": "Unlike a normal CookieJar, this class is pickleable.",
          "code": "def __getstate__(self):\n        \"\"\"Unlike a normal CookieJar, this class is pickleable.\"\"\"\n        state = self.__dict__.copy()\n        # remove the unpickleable RLock object\n        state.pop(\"_cookies_lock\")\n        return state",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "__setstate__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "state"
            }
          ],
          "return_type": null,
          "lineno": 422,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.__dict__.update",
            "threading.RLock",
            "state"
          ],
          "docstring": "Unlike a normal CookieJar, this class is pickleable.",
          "code": "def __setstate__(self, state):\n        \"\"\"Unlike a normal CookieJar, this class is pickleable.\"\"\"\n        self.__dict__.update(state)\n        if \"_cookies_lock\" not in self.__dict__:\n            self._cookies_lock = threading.RLock()",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "copy",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 428,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.get_policy",
            "new_cj.update",
            "new_cj.set_policy",
            "self",
            "RequestsCookieJar"
          ],
          "docstring": "Return a copy of this RequestsCookieJar.",
          "code": "def copy(self):\n        \"\"\"Return a copy of this RequestsCookieJar.\"\"\"\n        new_cj = RequestsCookieJar()\n        new_cj.set_policy(self.get_policy())\n        new_cj.update(self)\n        return new_cj",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "get_policy",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 435,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Return the CookiePolicy instance used.",
          "code": "def get_policy(self):\n        \"\"\"Return the CookiePolicy instance used.\"\"\"\n        return self._policy",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "MockRequest",
          "methods": [
            "__init__",
            "get_type",
            "get_host",
            "get_origin_req_host",
            "get_full_url",
            "is_unverifiable",
            "has_header",
            "get_header",
            "add_header",
            "add_unredirected_header",
            "get_new_headers",
            "unverifiable",
            "origin_req_host",
            "host"
          ],
          "base_classes": [],
          "lineno": 23,
          "docstring": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below."
        },
        {
          "name": "MockResponse",
          "methods": [
            "__init__",
            "info",
            "getheaders"
          ],
          "base_classes": [],
          "lineno": 103,
          "docstring": "Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.\n\n...what? Basically, expose the parsed HTTP headers from the server response\nthe way `http.cookiejar` expects to see them."
        },
        {
          "name": "CookieConflictError",
          "methods": [],
          "base_classes": [
            "RuntimeError"
          ],
          "lineno": 170,
          "docstring": "There are two cookies that meet the criteria specified in the cookie jar.\nUse .get and .set and include domain and path args in order to be more specific."
        },
        {
          "name": "RequestsCookieJar",
          "methods": [
            "get",
            "set",
            "iterkeys",
            "keys",
            "itervalues",
            "values",
            "iteritems",
            "items",
            "list_domains",
            "list_paths",
            "multiple_domains",
            "get_dict",
            "__contains__",
            "__getitem__",
            "__setitem__",
            "__delitem__",
            "set_cookie",
            "update",
            "_find",
            "_find_no_duplicates",
            "__getstate__",
            "__setstate__",
            "copy",
            "get_policy"
          ],
          "base_classes": [
            "cookielib.CookieJar",
            "MutableMapping"
          ],
          "lineno": 176,
          "docstring": "Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of ``CookieJar``, e.g.\n``LWPCookieJar`` and ``FileCookieJar``.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n.. warning:: dictionary operations that are normally O(1) may be O(n)."
        }
      ],
      "imports": [
        {
          "module": "calendar",
          "alias": null,
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "copy",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "time",
          "alias": null,
          "lineno": 12,
          "type": "import"
        },
        {
          "module": "_internal_utils",
          "name": "to_native_string",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "Morsel",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "MutableMapping",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "cookielib",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlparse",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlunparse",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "threading",
          "alias": null,
          "lineno": 18,
          "type": "import"
        },
        {
          "module": "dummy_threading",
          "alias": "threading",
          "lineno": 20,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "copy",
          "threading",
          "time"
        ],
        "third_party": {
          "other": [
            "calendar",
            "_internal_utils",
            "compat",
            "dummy_threading"
          ]
        },
        "tech_stack": []
      },
      "line_count": 562
    },
    "src/requests/exceptions.py": {
      "filepath": "../requests/src/requests/exceptions.py",
      "module_docstring": "requests.exceptions\n~~~~~~~~~~~~~~~~~~~\n\nThis module contains the set of Requests' exceptions.",
      "functions": [
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 17,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs.pop",
            "self.response.request",
            "unknown.__init__",
            "kwargs",
            "super",
            "response",
            "hasattr"
          ],
          "docstring": "Initialize RequestException with `request` and `response` objects.",
          "code": "def __init__(self, *args, **kwargs):\n        \"\"\"Initialize RequestException with `request` and `response` objects.\"\"\"\n        response = kwargs.pop(\"response\", None)\n        self.response = response\n        self.request = kwargs.pop(\"request\", None)\n        if response is not None and not self.request and hasattr(response, \"request\"):\n            self.request = self.response.request\n        super().__init__(*args, **kwargs)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 34,
          "decorators": [],
          "is_async": false,
          "calls": [
            "CompatJSONDecodeError.__init__",
            "kwargs",
            "InvalidJSONError.__init__",
            "self"
          ],
          "docstring": "Construct the JSONDecodeError instance first with all\nargs. Then use it's args to construct the IOError so that\nthe json specific args aren't used as IOError specific args\nand the error message from JSONDecodeError is preserved.",
          "code": "def __init__(self, *args, **kwargs):\n        \"\"\"\n        Construct the JSONDecodeError instance first with all\n        args. Then use it's args to construct the IOError so that\n        the json specific args aren't used as IOError specific args\n        and the error message from JSONDecodeError is preserved.\n        \"\"\"\n        CompatJSONDecodeError.__init__(self, *args)\n        InvalidJSONError.__init__(self, *self.args, **kwargs)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__reduce__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 44,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "CompatJSONDecodeError.__reduce__"
          ],
          "docstring": "The __reduce__ method called when pickling the object must\nbe the one from the JSONDecodeError (be it json/simplejson)\nas it expects all the arguments for instantiation, not just\none like the IOError, and the MRO would by default call the\n__reduce__ method from the IOError due to the inheritance order.",
          "code": "def __reduce__(self):\n        \"\"\"\n        The __reduce__ method called when pickling the object must\n        be the one from the JSONDecodeError (be it json/simplejson)\n        as it expects all the arguments for instantiation, not just\n        one like the IOError, and the MRO would by default call the\n        __reduce__ method from the IOError due to the inheritance order.\n        \"\"\"\n        return CompatJSONDecodeError.__reduce__(self)",
          "line_count": 9,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "RequestException",
          "methods": [
            "__init__"
          ],
          "base_classes": [
            "IOError"
          ],
          "lineno": 12,
          "docstring": "There was an ambiguous exception that occurred while handling your\nrequest."
        },
        {
          "name": "InvalidJSONError",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 27,
          "docstring": "A JSON error occurred."
        },
        {
          "name": "JSONDecodeError",
          "methods": [
            "__init__",
            "__reduce__"
          ],
          "base_classes": [
            "InvalidJSONError",
            "CompatJSONDecodeError"
          ],
          "lineno": 31,
          "docstring": "Couldn't decode the text into json"
        },
        {
          "name": "HTTPError",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 55,
          "docstring": "An HTTP error occurred."
        },
        {
          "name": "ConnectionError",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 59,
          "docstring": "A Connection error occurred."
        },
        {
          "name": "ProxyError",
          "methods": [],
          "base_classes": [
            "ConnectionError"
          ],
          "lineno": 63,
          "docstring": "A proxy error occurred."
        },
        {
          "name": "SSLError",
          "methods": [],
          "base_classes": [
            "ConnectionError"
          ],
          "lineno": 67,
          "docstring": "An SSL error occurred."
        },
        {
          "name": "Timeout",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 71,
          "docstring": "The request timed out.\n\nCatching this error will catch both\n:exc:`~requests.exceptions.ConnectTimeout` and\n:exc:`~requests.exceptions.ReadTimeout` errors."
        },
        {
          "name": "ConnectTimeout",
          "methods": [],
          "base_classes": [
            "ConnectionError",
            "Timeout"
          ],
          "lineno": 80,
          "docstring": "The request timed out while trying to connect to the remote server.\n\nRequests that produced this error are safe to retry."
        },
        {
          "name": "ReadTimeout",
          "methods": [],
          "base_classes": [
            "Timeout"
          ],
          "lineno": 87,
          "docstring": "The server did not send any data in the allotted amount of time."
        },
        {
          "name": "URLRequired",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 91,
          "docstring": "A valid URL is required to make a request."
        },
        {
          "name": "TooManyRedirects",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 95,
          "docstring": "Too many redirects."
        },
        {
          "name": "MissingSchema",
          "methods": [],
          "base_classes": [
            "RequestException",
            "ValueError"
          ],
          "lineno": 99,
          "docstring": "The URL scheme (e.g. http or https) is missing."
        },
        {
          "name": "InvalidSchema",
          "methods": [],
          "base_classes": [
            "RequestException",
            "ValueError"
          ],
          "lineno": 103,
          "docstring": "The URL scheme provided is either invalid or unsupported."
        },
        {
          "name": "InvalidURL",
          "methods": [],
          "base_classes": [
            "RequestException",
            "ValueError"
          ],
          "lineno": 107,
          "docstring": "The URL provided was somehow invalid."
        },
        {
          "name": "InvalidHeader",
          "methods": [],
          "base_classes": [
            "RequestException",
            "ValueError"
          ],
          "lineno": 111,
          "docstring": "The header value provided was somehow invalid."
        },
        {
          "name": "InvalidProxyURL",
          "methods": [],
          "base_classes": [
            "InvalidURL"
          ],
          "lineno": 115,
          "docstring": "The proxy URL provided is invalid."
        },
        {
          "name": "ChunkedEncodingError",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 119,
          "docstring": "The server declared chunked encoding but sent an invalid chunk."
        },
        {
          "name": "ContentDecodingError",
          "methods": [],
          "base_classes": [
            "RequestException",
            "BaseHTTPError"
          ],
          "lineno": 123,
          "docstring": "Failed to decode response content."
        },
        {
          "name": "StreamConsumedError",
          "methods": [],
          "base_classes": [
            "RequestException",
            "TypeError"
          ],
          "lineno": 127,
          "docstring": "The content for this response was already consumed."
        },
        {
          "name": "RetryError",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 131,
          "docstring": "Custom retries logic failed"
        },
        {
          "name": "UnrewindableBodyError",
          "methods": [],
          "base_classes": [
            "RequestException"
          ],
          "lineno": 135,
          "docstring": "Requests encountered an error when trying to rewind a body."
        },
        {
          "name": "RequestsWarning",
          "methods": [],
          "base_classes": [
            "Warning"
          ],
          "lineno": 142,
          "docstring": "Base warning for Requests."
        },
        {
          "name": "FileModeWarning",
          "methods": [],
          "base_classes": [
            "RequestsWarning",
            "DeprecationWarning"
          ],
          "lineno": 146,
          "docstring": "A file was opened in text mode, but Requests determined its binary length."
        },
        {
          "name": "RequestsDependencyWarning",
          "methods": [],
          "base_classes": [
            "RequestsWarning"
          ],
          "lineno": 150,
          "docstring": "An imported dependency doesn't match the expected version range."
        }
      ],
      "imports": [
        {
          "module": "urllib3.exceptions",
          "name": "HTTPError",
          "alias": "BaseHTTPError",
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "JSONDecodeError",
          "alias": "CompatJSONDecodeError",
          "lineno": 9,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "urllib3",
            "compat"
          ]
        },
        "tech_stack": []
      },
      "line_count": 152
    },
    "src/requests/help.py": {
      "filepath": "../requests/src/requests/help.py",
      "module_docstring": "Module containing bug report helper(s).",
      "functions": [
        {
          "name": "_implementation",
          "args": [],
          "return_type": null,
          "lineno": 34,
          "decorators": [],
          "is_async": false,
          "calls": [
            "platform.python_version",
            "sys.pypy_version_info.micro",
            "unknown.format",
            "sys.pypy_version_info.minor",
            "sys.pypy_version_info.major",
            "platform.python_implementation",
            "unknown.join"
          ],
          "docstring": "Return a dict with the Python implementation and version.\n\nProvide both the name and the version of the Python implementation\ncurrently running. For example, on CPython 3.10.3 it will return\n{'name': 'CPython', 'version': '3.10.3'}.\n\nThis function works best on CPython and PyPy: in particular, it probably\ndoesn't work for Jython or IronPython. Future investigation should be done\nto work out the correct shape of the code for those platforms.",
          "code": "def _implementation():\n    \"\"\"Return a dict with the Python implementation and version.\n\n    Provide both the name and the version of the Python implementation\n    currently running. For example, on CPython 3.10.3 it will return\n    {'name': 'CPython', 'version': '3.10.3'}.\n\n    This function works best on CPython and PyPy: in particular, it probably\n    doesn't work for Jython or IronPython. Future investigation should be done\n    to work out the correct shape of the code for those platforms.\n    \"\"\"\n    implementation = platform.python_implementation()\n\n    if implementation == \"CPython\":\n        implementation_version = platform.python_version()\n    elif implementation == \"PyPy\":\n        implementation_version = \"{}.{}.{}\".format(\n            sys.pypy_version_info.major,\n            sys.pypy_version_info.minor,\n            sys.pypy_version_info.micro,\n        )\n        if sys.pypy_version_info.releaselevel != \"final\":\n            implementation_version = \"\".join(\n                [implementation_version, sys.pypy_version_info.releaselevel]\n            )\n    elif implementation == \"Jython\":\n        implementation_version = platform.python_version()  # Complete Guess\n    elif implementation == \"IronPython\":\n        implementation_version = platform.python_version()  # Complete Guess\n    else:\n        implementation_version = \"Unknown\"\n\n    return {\"name\": implementation, \"version\": implementation_version}",
          "line_count": 33,
          "needs_llm_summary": true
        },
        {
          "name": "info",
          "args": [],
          "return_type": null,
          "lineno": 69,
          "decorators": [],
          "is_async": false,
          "calls": [
            "platform.system",
            "platform.release",
            "_implementation",
            "ssl.OPENSSL_VERSION_NUMBER",
            "getattr",
            "cryptography",
            "idna"
          ],
          "docstring": "Generate information for a bug report.",
          "code": "def info():\n    \"\"\"Generate information for a bug report.\"\"\"\n    try:\n        platform_info = {\n            \"system\": platform.system(),\n            \"release\": platform.release(),\n        }\n    except OSError:\n        platform_info = {\n            \"system\": \"Unknown\",\n            \"release\": \"Unknown\",\n        }\n\n    implementation_info = _implementation()\n    urllib3_info = {\"version\": urllib3.__version__}\n    charset_normalizer_info = {\"version\": None}\n    chardet_info = {\"version\": None}\n    if charset_normalizer:\n        charset_normalizer_info = {\"version\": charset_normalizer.__version__}\n    if chardet:\n        chardet_info = {\"version\": chardet.__version__}\n\n    pyopenssl_info = {\n        \"version\": None,\n        \"openssl_version\": \"\",\n    }\n    if OpenSSL:\n        pyopenssl_info = {\n            \"version\": OpenSSL.__version__,\n            \"openssl_version\": f\"{OpenSSL.SSL.OPENSSL_VERSION_NUMBER:x}\",\n        }\n    cryptography_info = {\n        \"version\": getattr(cryptography, \"__version__\", \"\"),\n    }\n    idna_info = {\n        \"version\": getattr(idna, \"__version__\", \"\"),\n    }\n\n    system_ssl = ssl.OPENSSL_VERSION_NUMBER\n    system_ssl_info = {\"version\": f\"{system_ssl:x}\" if system_ssl is not None else \"\"}\n\n    return {\n        \"platform\": platform_info,\n        \"implementation\": implementation_info,\n        \"system_ssl\": system_ssl_info,\n        \"using_pyopenssl\": pyopenssl is not None,\n        \"using_charset_normalizer\": chardet is None,\n        \"pyOpenSSL\": pyopenssl_info,\n        \"urllib3\": urllib3_info,\n        \"chardet\": chardet_info,\n        \"charset_normalizer\": charset_normalizer_info,\n        \"cryptography\": cryptography_info,\n        \"idna\": idna_info,\n        \"requests\": {\n            \"version\": requests_version,\n        },\n    }",
          "line_count": 57,
          "needs_llm_summary": true
        },
        {
          "name": "main",
          "args": [],
          "return_type": null,
          "lineno": 128,
          "decorators": [],
          "is_async": false,
          "calls": [
            "print",
            "json.dumps",
            "info"
          ],
          "docstring": "Pretty-print the bug information as JSON.",
          "code": "def main():\n    \"\"\"Pretty-print the bug information as JSON.\"\"\"\n    print(json.dumps(info(), sort_keys=True, indent=2))",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "json",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "platform",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "ssl",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "idna",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "urllib3",
          "alias": null,
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "",
          "name": "__version__",
          "alias": "requests_version",
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "charset_normalizer",
          "alias": null,
          "lineno": 14,
          "type": "import"
        },
        {
          "module": "chardet",
          "alias": null,
          "lineno": 19,
          "type": "import"
        },
        {
          "module": "urllib3.contrib",
          "name": "pyopenssl",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "cryptography",
          "alias": null,
          "lineno": 30,
          "type": "import"
        },
        {
          "module": "OpenSSL",
          "alias": null,
          "lineno": 31,
          "type": "import"
        }
      ],
      "variables": [],
      "is_entry_point": true,
      "main_block_calls": [
        "main"
      ],
      "module_level_calls": {
        "function_calls": [
          "main"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "json",
          "sys"
        ],
        "third_party": {
          "other": [
            "platform",
            "ssl",
            "idna",
            "urllib3",
            "__version__",
            "charset_normalizer",
            "chardet",
            "cryptography",
            "OpenSSL"
          ]
        },
        "tech_stack": []
      },
      "line_count": 135
    },
    "src/requests/hooks.py": {
      "filepath": "../requests/src/requests/hooks.py",
      "module_docstring": "requests.hooks\n~~~~~~~~~~~~~~\n\nThis module provides the capabilities for the Requests hooks system.\n\nAvailable hooks:\n\n``response``:\n    The response generated from a Request.",
      "functions": [
        {
          "name": "default_hooks",
          "args": [],
          "return_type": null,
          "lineno": 15,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def default_hooks():\n    return {event: [] for event in HOOKS}",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "dispatch_hook",
          "args": [
            {
              "name": "key"
            },
            {
              "name": "hooks"
            },
            {
              "name": "hook_data"
            }
          ],
          "return_type": null,
          "lineno": 22,
          "decorators": [],
          "is_async": false,
          "calls": [
            "hook_data",
            "_hook_data",
            "hook",
            "hooks.get",
            "kwargs",
            "key",
            "hasattr",
            "hooks"
          ],
          "docstring": "Dispatches a hook dictionary on a given piece of data.",
          "code": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if _hook_data is not None:\n                hook_data = _hook_data\n    return hook_data",
          "line_count": 12,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [],
      "variables": [
        {
          "name": "HOOKS",
          "assigned_to": null,
          "lineno": 12
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {},
        "tech_stack": []
      },
      "line_count": 34
    },
    "src/requests/models.py": {
      "filepath": "../requests/src/requests/models.py",
      "module_docstring": "requests.models\n~~~~~~~~~~~~~~~\n\nThis module contains the primary objects that power Requests.",
      "functions": [
        {
          "name": "path_url",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 86,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "p.path",
            "urlsplit",
            "url.append",
            "path",
            "url",
            "query",
            "self.url",
            "p.query",
            "unknown.join"
          ],
          "docstring": "Build the path URL to use.",
          "code": "def path_url(self):\n        \"\"\"Build the path URL to use.\"\"\"\n\n        url = []\n\n        p = urlsplit(self.url)\n\n        path = p.path\n        if not path:\n            path = \"/\"\n\n        url.append(path)\n\n        query = p.query\n        if query:\n            url.append(\"?\")\n            url.append(query)\n\n        return \"\".join(url)",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "_encode_params",
          "args": [
            {
              "name": "data"
            }
          ],
          "return_type": null,
          "lineno": 107,
          "decorators": [
            {
              "name": "staticmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "isinstance",
            "urlencode",
            "to_key_val_list",
            "k",
            "result",
            "basestring",
            "str",
            "vs",
            "v.encode",
            "result.append",
            "k.encode",
            "v",
            "hasattr",
            "data"
          ],
          "docstring": "Encode parameters in a piece of data.\n\nWill successfully encode parameters when passed as a dict or a list of\n2-tuples. Order is retained if data is a list of 2-tuples but arbitrary\nif parameters are supplied as a dict.",
          "code": "def _encode_params(data):\n        \"\"\"Encode parameters in a piece of data.\n\n        Will successfully encode parameters when passed as a dict or a list of\n        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary\n        if parameters are supplied as a dict.\n        \"\"\"\n\n        if isinstance(data, (str, bytes)):\n            return data\n        elif hasattr(data, \"read\"):\n            return data\n        elif hasattr(data, \"__iter__\"):\n            result = []\n            for k, vs in to_key_val_list(data):\n                if isinstance(vs, basestring) or not hasattr(vs, \"__iter__\"):\n                    vs = [vs]\n                for v in vs:\n                    if v is not None:\n                        result.append(\n                            (\n                                k.encode(\"utf-8\") if isinstance(k, str) else k,\n                                v.encode(\"utf-8\") if isinstance(v, str) else v,\n                            )\n                        )\n            return urlencode(result, doseq=True)\n        else:\n            return data",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "_encode_files",
          "args": [
            {
              "name": "files"
            },
            {
              "name": "data"
            }
          ],
          "return_type": null,
          "lineno": 137,
          "decorators": [
            {
              "name": "staticmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "fdata",
            "rf.make_multipart",
            "val",
            "ValueError",
            "guess_filename",
            "fp.read",
            "fp",
            "new_fields",
            "fh",
            "len",
            "k",
            "basestring",
            "v.encode",
            "isinstance",
            "ft",
            "to_key_val_list",
            "field",
            "str",
            "encode_multipart_formdata",
            "v",
            "bytes",
            "rf",
            "fn",
            "RequestField",
            "new_fields.append",
            "field.decode",
            "hasattr",
            "data"
          ],
          "docstring": "Build the body for a multipart/form-data request.\n\nWill successfully encode files when passed as a dict or a list of\ntuples. Order is retained if data is a list of tuples but arbitrary\nif parameters are supplied as a dict.\nThe tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)\nor 4-tuples (filename, fileobj, contentype, custom_headers).",
          "code": "def _encode_files(files, data):\n        \"\"\"Build the body for a multipart/form-data request.\n\n        Will successfully encode files when passed as a dict or a list of\n        tuples. Order is retained if data is a list of tuples but arbitrary\n        if parameters are supplied as a dict.\n        The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)\n        or 4-tuples (filename, fileobj, contentype, custom_headers).\n        \"\"\"\n        if not files:\n            raise ValueError(\"Files must be provided.\")\n        elif isinstance(data, basestring):\n            raise ValueError(\"Data must not be a string.\")\n\n        new_fields = []\n        fields = to_key_val_list(data or {})\n        files = to_key_val_list(files or {})\n\n        for field, val in fields:\n            if isinstance(val, basestring) or not hasattr(val, \"__iter__\"):\n                val = [val]\n            for v in val:\n                if v is not None:\n                    # Don't call str() on bytestrings: in Py3 it all goes wrong.\n                    if not isinstance(v, bytes):\n                        v = str(v)\n\n                    new_fields.append(\n                        (\n                            field.decode(\"utf-8\")\n                            if isinstance(field, bytes)\n                            else field,\n                            v.encode(\"utf-8\") if isinstance(v, str) else v,\n                        )\n                    )\n\n        for k, v in files:\n            # support for explicit filename\n            ft = None\n            fh = None\n            if isinstance(v, (tuple, list)):\n                if len(v) == 2:\n                    fn, fp = v\n                elif len(v) == 3:\n                    fn, fp, ft = v\n                else:\n                    fn, fp, ft, fh = v\n            else:\n                fn = guess_filename(v) or k\n                fp = v\n\n            if isinstance(fp, (str, bytes, bytearray)):\n                fdata = fp\n            elif hasattr(fp, \"read\"):\n                fdata = fp.read()\n            elif fp is None:\n                continue\n            else:\n                fdata = fp\n\n            rf = RequestField(name=k, data=fdata, filename=fn, headers=fh)\n            rf.make_multipart(content_type=ft)\n            new_fields.append(rf)\n\n        body, content_type = encode_multipart_formdata(new_fields)\n\n        return body, content_type",
          "line_count": 67,
          "needs_llm_summary": true
        },
        {
          "name": "register_hook",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "event"
            },
            {
              "name": "hook"
            }
          ],
          "return_type": null,
          "lineno": 207,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "hook",
            "unknown.extend",
            "ValueError",
            "h",
            "hasattr",
            "Callable",
            "unknown.append"
          ],
          "docstring": "Properly register a hook.",
          "code": "def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "deregister_hook",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "event"
            },
            {
              "name": "hook"
            }
          ],
          "return_type": null,
          "lineno": 218,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.remove",
            "hook"
          ],
          "docstring": "Deregister a previously registered hook.\nReturns True if the hook existed, False if not.",
          "code": "def deregister_hook(self, event, hook):\n        \"\"\"Deregister a previously registered hook.\n        Returns True if the hook existed, False if not.\n        \"\"\"\n\n        try:\n            self.hooks[event].remove(hook)\n            return True\n        except ValueError:\n            return False",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "method"
            },
            {
              "name": "url"
            },
            {
              "name": "headers"
            },
            {
              "name": "files"
            },
            {
              "name": "data"
            },
            {
              "name": "params"
            },
            {
              "name": "auth"
            },
            {
              "name": "cookies"
            },
            {
              "name": "hooks"
            },
            {
              "name": "json"
            }
          ],
          "return_type": null,
          "lineno": 258,
          "decorators": [],
          "is_async": false,
          "calls": [
            "default_hooks",
            "hooks.items",
            "k",
            "list",
            "json",
            "method",
            "url",
            "v",
            "files",
            "auth",
            "headers",
            "data",
            "cookies",
            "self.register_hook",
            "params"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        method=None,\n        url=None,\n        headers=None,\n        files=None,\n        data=None,\n        params=None,\n        auth=None,\n        cookies=None,\n        hooks=None,\n        json=None,\n    ):\n        # Default empty dicts for dict params.\n        data = [] if data is None else data\n        files = [] if files is None else files\n        headers = {} if headers is None else headers\n        params = {} if params is None else params\n        hooks = {} if hooks is None else hooks\n\n        self.hooks = default_hooks()\n        for k, v in list(hooks.items()):\n            self.register_hook(event=k, hook=v)\n\n        self.method = method\n        self.url = url\n        self.headers = headers\n        self.files = files\n        self.data = data\n        self.json = json\n        self.params = params\n        self.auth = auth\n        self.cookies = cookies",
          "line_count": 33,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 292,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self):\n        return f\"<Request [{self.method}]>\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "prepare",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 295,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.data",
            "self.auth",
            "p.prepare",
            "self.json",
            "self.hooks",
            "self.method",
            "PreparedRequest",
            "self.headers",
            "self.files",
            "self.params",
            "self.url",
            "self.cookies"
          ],
          "docstring": "Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.",
          "code": "def prepare(self):\n        \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.\"\"\"\n        p = PreparedRequest()\n        p.prepare(\n            method=self.method,\n            url=self.url,\n            headers=self.headers,\n            files=self.files,\n            data=self.data,\n            json=self.json,\n            params=self.params,\n            auth=self.auth,\n            cookies=self.cookies,\n            hooks=self.hooks,\n        )\n        return p",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 334,
          "decorators": [],
          "is_async": false,
          "calls": [
            "default_hooks"
          ],
          "docstring": null,
          "code": "def __init__(self):\n        #: HTTP verb to send to the server.\n        self.method = None\n        #: HTTP URL to send the request to.\n        self.url = None\n        #: dictionary of HTTP headers.\n        self.headers = None\n        # The `CookieJar` used to create the Cookie header will be stored here\n        # after prepare_cookies is called\n        self._cookies = None\n        #: request body to send to the server.\n        self.body = None\n        #: dictionary of callback hooks, for internal usage.\n        self.hooks = default_hooks()\n        #: integer denoting starting position of a readable file-like body.\n        self._body_position = None",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "prepare",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "method"
            },
            {
              "name": "url"
            },
            {
              "name": "headers"
            },
            {
              "name": "files"
            },
            {
              "name": "data"
            },
            {
              "name": "params"
            },
            {
              "name": "auth"
            },
            {
              "name": "cookies"
            },
            {
              "name": "hooks"
            },
            {
              "name": "json"
            }
          ],
          "return_type": null,
          "lineno": 351,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.prepare_url",
            "self.prepare_hooks",
            "json",
            "hooks",
            "self.prepare_cookies",
            "self.prepare_body",
            "method",
            "url",
            "auth",
            "self.prepare_method",
            "self.prepare_auth",
            "files",
            "self.prepare_headers",
            "headers",
            "data",
            "cookies",
            "params"
          ],
          "docstring": "Prepares the entire request with the given parameters.",
          "code": "def prepare(\n        self,\n        method=None,\n        url=None,\n        headers=None,\n        files=None,\n        data=None,\n        params=None,\n        auth=None,\n        cookies=None,\n        hooks=None,\n        json=None,\n    ):\n        \"\"\"Prepares the entire request with the given parameters.\"\"\"\n\n        self.prepare_method(method)\n        self.prepare_url(url, params)\n        self.prepare_headers(headers)\n        self.prepare_cookies(cookies)\n        self.prepare_body(data, files, json)\n        self.prepare_auth(auth, url)\n\n        # Note that prepare_auth must be last to enable authentication schemes\n        # such as OAuth to work on a fully prepared request.\n\n        # This MUST go after prepare_auth. Authenticators could add a hook\n        self.prepare_hooks(hooks)",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 379,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self):\n        return f\"<PreparedRequest [{self.method}]>\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "copy",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 382,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._body_position",
            "_copy_cookie_jar",
            "self.hooks",
            "self.headers.copy",
            "self.method",
            "PreparedRequest",
            "self._cookies",
            "self.body",
            "self.url"
          ],
          "docstring": null,
          "code": "def copy(self):\n        p = PreparedRequest()\n        p.method = self.method\n        p.url = self.url\n        p.headers = self.headers.copy() if self.headers is not None else None\n        p._cookies = _copy_cookie_jar(self._cookies)\n        p.body = self.body\n        p.hooks = self.hooks\n        p._body_position = self._body_position\n        return p",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_method",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "method"
            }
          ],
          "return_type": null,
          "lineno": 393,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.method.upper",
            "to_native_string",
            "method"
          ],
          "docstring": "Prepares the given HTTP method.",
          "code": "def prepare_method(self, method):\n        \"\"\"Prepares the given HTTP method.\"\"\"\n        self.method = method\n        if self.method is not None:\n            self.method = to_native_string(self.method.upper())",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "_get_idna_encoded_host",
          "args": [
            {
              "name": "host"
            }
          ],
          "return_type": null,
          "lineno": 400,
          "decorators": [
            {
              "name": "staticmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "host",
            "unknown.decode",
            "idna.encode"
          ],
          "docstring": null,
          "code": "def _get_idna_encoded_host(host):\n        import idna\n\n        try:\n            host = idna.encode(host, uts46=True).decode(\"utf-8\")\n        except idna.IDNAError:\n            raise UnicodeError\n        return host",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_url",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            },
            {
              "name": "params"
            }
          ],
          "return_type": null,
          "lineno": 409,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.startswith",
            "enc_params",
            "url",
            "MissingSchema",
            "self._encode_params",
            "params",
            "urlunparse",
            "isinstance",
            "requote_uri",
            "unicode_is_ascii",
            "str",
            "host.startswith",
            "bytes",
            "url.decode",
            "url.lstrip",
            "to_native_string",
            "parse_url",
            "url.lower",
            "host",
            "self._get_idna_encoded_host",
            "InvalidURL"
          ],
          "docstring": "Prepares the given HTTP URL.",
          "code": "def prepare_url(self, url, params):\n        \"\"\"Prepares the given HTTP URL.\"\"\"\n        #: Accept objects that have string representations.\n        #: We're unable to blindly call unicode/str functions\n        #: as this will include the bytestring indicator (b'')\n        #: on python 3.x.\n        #: https://github.com/psf/requests/pull/2238\n        if isinstance(url, bytes):\n            url = url.decode(\"utf8\")\n        else:\n            url = str(url)\n\n        # Remove leading whitespaces from url\n        url = url.lstrip()\n\n        # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n        # `data` etc to work around exceptions from `url_parse`, which\n        # handles RFC 3986 only.\n        if \":\" in url and not url.lower().startswith(\"http\"):\n            self.url = url\n            return\n\n        # Support for unicode domain names and paths.\n        try:\n            scheme, auth, host, port, path, query, fragment = parse_url(url)\n        except LocationParseError as e:\n            raise InvalidURL(*e.args)\n\n        if not scheme:\n            raise MissingSchema(\n                f\"Invalid URL {url!r}: No scheme supplied. \"\n                f\"Perhaps you meant https://{url}?\"\n            )\n\n        if not host:\n            raise InvalidURL(f\"Invalid URL {url!r}: No host supplied\")\n\n        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n        if not unicode_is_ascii(host):\n            try:\n                host = self._get_idna_encoded_host(host)\n            except UnicodeError:\n                raise InvalidURL(\"URL has an invalid label.\")\n        elif host.startswith((\"*\", \".\")):\n            raise InvalidURL(\"URL has an invalid label.\")\n\n        # Carefully reconstruct the network location\n        netloc = auth or \"\"\n        if netloc:\n            netloc += \"@\"\n        netloc += host\n        if port:\n            netloc += f\":{port}\"\n\n        # Bare domains aren't valid URLs.\n        if not path:\n            path = \"/\"\n\n        if isinstance(params, (str, bytes)):\n            params = to_native_string(params)\n\n        enc_params = self._encode_params(params)\n        if enc_params:\n            if query:\n                query = f\"{query}&{enc_params}\"\n            else:\n                query = enc_params\n\n        url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n        self.url = url",
          "line_count": 73,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_headers",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "headers"
            }
          ],
          "return_type": null,
          "lineno": 483,
          "decorators": [],
          "is_async": false,
          "calls": [
            "check_header_validity",
            "to_native_string",
            "header",
            "CaseInsensitiveDict",
            "value",
            "name",
            "headers.items"
          ],
          "docstring": "Prepares the given HTTP headers.",
          "code": "def prepare_headers(self, headers):\n        \"\"\"Prepares the given HTTP headers.\"\"\"\n\n        self.headers = CaseInsensitiveDict()\n        if headers:\n            for header in headers.items():\n                # Raise exception on invalid header value.\n                check_header_validity(header)\n                name, value = header\n                self.headers[to_native_string(name)] = value",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_body",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "data"
            },
            {
              "name": "files"
            },
            {
              "name": "json"
            }
          ],
          "return_type": null,
          "lineno": 494,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ve",
            "content_type",
            "complexjson.dumps",
            "body.encode",
            "body",
            "super_len",
            "basestring",
            "all",
            "self._encode_params",
            "files",
            "object",
            "isinstance",
            "json",
            "builtin_str",
            "body.tell",
            "bytes",
            "self.prepare_content_length",
            "NotImplementedError",
            "length",
            "InvalidJSONError",
            "self",
            "hasattr",
            "getattr",
            "data",
            "self._encode_files"
          ],
          "docstring": "Prepares the given HTTP body data.",
          "code": "def prepare_body(self, data, files, json=None):\n        \"\"\"Prepares the given HTTP body data.\"\"\"\n\n        # Check if file, fo, generator, iterator.\n        # If not, run through normal process.\n\n        # Nottin' on you.\n        body = None\n        content_type = None\n\n        if not data and json is not None:\n            # urllib3 requires a bytes-like body. Python 2's json.dumps\n            # provides this natively, but Python 3 gives a Unicode string.\n            content_type = \"application/json\"\n\n            try:\n                body = complexjson.dumps(json, allow_nan=False)\n            except ValueError as ve:\n                raise InvalidJSONError(ve, request=self)\n\n            if not isinstance(body, bytes):\n                body = body.encode(\"utf-8\")\n\n        is_stream = all(\n            [\n                hasattr(data, \"__iter__\"),\n                not isinstance(data, (basestring, list, tuple, Mapping)),\n            ]\n        )\n\n        if is_stream:\n            try:\n                length = super_len(data)\n            except (TypeError, AttributeError, UnsupportedOperation):\n                length = None\n\n            body = data\n\n            if getattr(body, \"tell\", None) is not None:\n                # Record the current file position before reading.\n                # This will allow us to rewind a file in the event\n                # of a redirect.\n                try:\n                    self._body_position = body.tell()\n                except OSError:\n                    # This differentiates from None, allowing us to catch\n                    # a failed `tell()` later when trying to rewind the body\n                    self._body_position = object()\n\n            if files:\n                raise NotImplementedError(\n                    \"Streamed bodies and files are mutually exclusive.\"\n                )\n\n            if length:\n                self.headers[\"Content-Length\"] = builtin_str(length)\n            else:\n                self.headers[\"Transfer-Encoding\"] = \"chunked\"\n        else:\n            # Multi-part file uploads.\n            if files:\n                (body, content_type) = self._encode_files(files, data)\n            else:\n                if data:\n                    body = self._encode_params(data)\n                    if isinstance(data, basestring) or hasattr(data, \"read\"):\n                        content_type = None\n                    else:\n                        content_type = \"application/x-www-form-urlencoded\"\n\n            self.prepare_content_length(body)\n\n            # Add content-type if it wasn't explicitly provided.\n            if content_type and (\"content-type\" not in self.headers):\n                self.headers[\"Content-Type\"] = content_type\n\n        self.body = body",
          "line_count": 77,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_content_length",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "body"
            }
          ],
          "return_type": null,
          "lineno": 572,
          "decorators": [],
          "is_async": false,
          "calls": [
            "length",
            "builtin_str",
            "super_len",
            "self.headers.get",
            "body"
          ],
          "docstring": "Prepare Content-Length header based on request method and body",
          "code": "def prepare_content_length(self, body):\n        \"\"\"Prepare Content-Length header based on request method and body\"\"\"\n        if body is not None:\n            length = super_len(body)\n            if length:\n                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers[\"Content-Length\"] = builtin_str(length)\n        elif (\n            self.method not in (\"GET\", \"HEAD\")\n            and self.headers.get(\"Content-Length\") is None\n        ):\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers[\"Content-Length\"] = \"0\"",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_auth",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "auth"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 588,
          "decorators": [],
          "is_async": false,
          "calls": [
            "any",
            "isinstance",
            "len",
            "r.__dict__",
            "HTTPBasicAuth",
            "self",
            "self.body",
            "tuple",
            "auth",
            "self.url",
            "self.__dict__.update",
            "self.prepare_content_length",
            "get_auth_from_url",
            "url_auth"
          ],
          "docstring": "Prepares the given HTTP auth data.",
          "code": "def prepare_auth(self, auth, url=\"\"):\n        \"\"\"Prepares the given HTTP auth data.\"\"\"\n\n        # If no Auth is explicitly provided, extract it from the URL first.\n        if auth is None:\n            url_auth = get_auth_from_url(self.url)\n            auth = url_auth if any(url_auth) else None\n\n        if auth:\n            if isinstance(auth, tuple) and len(auth) == 2:\n                # special-case basic HTTP auth\n                auth = HTTPBasicAuth(*auth)\n\n            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n            self.prepare_content_length(self.body)",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_cookies",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "cookies"
            }
          ],
          "return_type": null,
          "lineno": 610,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "cookie_header",
            "self._cookies",
            "cookielib.CookieJar",
            "self",
            "cookiejar_from_dict",
            "cookies",
            "get_cookie_header"
          ],
          "docstring": "Prepares the given HTTP cookie data.\n\nThis function eventually generates a ``Cookie`` header from the\ngiven cookies using cookielib. Due to cookielib's design, the header\nwill not be regenerated if it already exists, meaning this function\ncan only be called once for the life of the\n:class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls\nto ``prepare_cookies`` will have no actual effect, unless the \"Cookie\"\nheader is removed beforehand.",
          "code": "def prepare_cookies(self, cookies):\n        \"\"\"Prepares the given HTTP cookie data.\n\n        This function eventually generates a ``Cookie`` header from the\n        given cookies using cookielib. Due to cookielib's design, the header\n        will not be regenerated if it already exists, meaning this function\n        can only be called once for the life of the\n        :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls\n        to ``prepare_cookies`` will have no actual effect, unless the \"Cookie\"\n        header is removed beforehand.\n        \"\"\"\n        if isinstance(cookies, cookielib.CookieJar):\n            self._cookies = cookies\n        else:\n            self._cookies = cookiejar_from_dict(cookies)\n\n        cookie_header = get_cookie_header(self._cookies, self)\n        if cookie_header is not None:\n            self.headers[\"Cookie\"] = cookie_header",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_hooks",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "hooks"
            }
          ],
          "return_type": null,
          "lineno": 630,
          "decorators": [],
          "is_async": false,
          "calls": [
            "event",
            "self.register_hook"
          ],
          "docstring": "Prepares the given hooks.",
          "code": "def prepare_hooks(self, hooks):\n        \"\"\"Prepares the given hooks.\"\"\"\n        # hooks can be passed as None to the prepare method and to this\n        # method. To prevent iterating over None, simply use an empty list\n        # if hooks is False-y\n        hooks = hooks or []\n        for event in hooks:\n            self.register_hook(event, hooks[event])",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 658,
          "decorators": [],
          "is_async": false,
          "calls": [
            "CaseInsensitiveDict",
            "datetime.timedelta",
            "cookiejar_from_dict"
          ],
          "docstring": null,
          "code": "def __init__(self):\n        self._content = False\n        self._content_consumed = False\n        self._next = None\n\n        #: Integer Code of responded HTTP Status, e.g. 404 or 200.\n        self.status_code = None\n\n        #: Case-insensitive Dictionary of Response Headers.\n        #: For example, ``headers['content-encoding']`` will return the\n        #: value of a ``'Content-Encoding'`` response header.\n        self.headers = CaseInsensitiveDict()\n\n        #: File-like object representation of response (for advanced usage).\n        #: Use of ``raw`` requires that ``stream=True`` be set on the request.\n        #: This requirement does not apply for use internally to Requests.\n        self.raw = None\n\n        #: Final URL location of Response.\n        self.url = None\n\n        #: Encoding to decode with when accessing r.text.\n        self.encoding = None\n\n        #: A list of :class:`Response <Response>` objects from\n        #: the history of the Request. Any redirect responses will end\n        #: up here. The list is sorted from the oldest to the most recent request.\n        self.history = []\n\n        #: Textual reason of responded HTTP Status, e.g. \"Not Found\" or \"OK\".\n        self.reason = None\n\n        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n        self.elapsed = datetime.timedelta(0)\n\n        #: The :class:`PreparedRequest <PreparedRequest>` object to which this\n        #: is a response.\n        self.request = None",
          "line_count": 46,
          "needs_llm_summary": true
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 705,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __enter__(self):\n        return self",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 708,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.close"
          ],
          "docstring": null,
          "code": "def __exit__(self, *args):\n        self.close()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__getstate__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 711,
          "decorators": [],
          "is_async": false,
          "calls": [
            "getattr",
            "self",
            "attr"
          ],
          "docstring": null,
          "code": "def __getstate__(self):\n        # Consume everything; accessing the content attribute makes\n        # sure the content has been fully read.\n        if not self._content_consumed:\n            self.content\n\n        return {attr: getattr(self, attr, None) for attr in self.__attrs__}",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__setstate__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "state"
            }
          ],
          "return_type": null,
          "lineno": 719,
          "decorators": [],
          "is_async": false,
          "calls": [
            "state.items",
            "self",
            "name",
            "value",
            "setattr"
          ],
          "docstring": null,
          "code": "def __setstate__(self, state):\n        for name, value in state.items():\n            setattr(self, name, value)\n\n        # pickled objects do not have .raw\n        setattr(self, \"_content_consumed\", True)\n        setattr(self, \"raw\", None)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 727,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self):\n        return f\"<Response [{self.status_code}]>\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__bool__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 730,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Returns True if :attr:`status_code` is less than 400.\n\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code, is between 200 and 400, this will return True. This\nis **not** a check to see if the response code is ``200 OK``.",
          "code": "def __bool__(self):\n        \"\"\"Returns True if :attr:`status_code` is less than 400.\n\n        This attribute checks if the status code of the response is between\n        400 and 600 to see if there was a client error or a server error. If\n        the status code, is between 200 and 400, this will return True. This\n        is **not** a check to see if the response code is ``200 OK``.\n        \"\"\"\n        return self.ok",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__nonzero__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 740,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Returns True if :attr:`status_code` is less than 400.\n\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code, is between 200 and 400, this will return True. This\nis **not** a check to see if the response code is ``200 OK``.",
          "code": "def __nonzero__(self):\n        \"\"\"Returns True if :attr:`status_code` is less than 400.\n\n        This attribute checks if the status code of the response is between\n        400 and 600 to see if there was a client error or a server error. If\n        the status code, is between 200 and 400, this will return True. This\n        is **not** a check to see if the response code is ``200 OK``.\n        \"\"\"\n        return self.ok",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__iter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 750,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.iter_content"
          ],
          "docstring": "Allows you to use a response as an iterator.",
          "code": "def __iter__(self):\n        \"\"\"Allows you to use a response as an iterator.\"\"\"\n        return self.iter_content(128)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "ok",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 755,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.raise_for_status"
          ],
          "docstring": "Returns True if :attr:`status_code` is less than 400, False if not.\n\nThis attribute checks if the status code of the response is between\n400 and 600 to see if there was a client error or a server error. If\nthe status code is between 200 and 400, this will return True. This\nis **not** a check to see if the response code is ``200 OK``.",
          "code": "def ok(self):\n        \"\"\"Returns True if :attr:`status_code` is less than 400, False if not.\n\n        This attribute checks if the status code of the response is between\n        400 and 600 to see if there was a client error or a server error. If\n        the status code is between 200 and 400, this will return True. This\n        is **not** a check to see if the response code is ``200 OK``.\n        \"\"\"\n        try:\n            self.raise_for_status()\n        except HTTPError:\n            return False\n        return True",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "is_redirect",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 770,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "True if this Response is a well-formed HTTP redirect that could have\nbeen processed automatically (by :meth:`Session.resolve_redirects`).",
          "code": "def is_redirect(self):\n        \"\"\"True if this Response is a well-formed HTTP redirect that could have\n        been processed automatically (by :meth:`Session.resolve_redirects`).\n        \"\"\"\n        return \"location\" in self.headers and self.status_code in REDIRECT_STATI",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "is_permanent_redirect",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 777,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "True if this Response one of the permanent versions of redirect.",
          "code": "def is_permanent_redirect(self):\n        \"\"\"True if this Response one of the permanent versions of redirect.\"\"\"\n        return \"location\" in self.headers and self.status_code in (\n            codes.moved_permanently,\n            codes.permanent_redirect,\n        )",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "next",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 785,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "Returns a PreparedRequest for the next request in a redirect chain, if there is one.",
          "code": "def next(self):\n        \"\"\"Returns a PreparedRequest for the next request in a redirect chain, if there is one.\"\"\"\n        return self._next",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "apparent_encoding",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 790,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "chardet.detect",
            "self.content"
          ],
          "docstring": "The apparent encoding, provided by the charset_normalizer or chardet libraries.",
          "code": "def apparent_encoding(self):\n        \"\"\"The apparent encoding, provided by the charset_normalizer or chardet libraries.\"\"\"\n        if chardet is not None:\n            return chardet.detect(self.content)[\"encoding\"]\n        else:\n            # If no character detection library is available, we'll fall back\n            # to a standard Python utf-8 str.\n            return \"utf-8\"",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "iter_content",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "chunk_size"
            },
            {
              "name": "decode_unicode"
            }
          ],
          "return_type": null,
          "lineno": 799,
          "decorators": [],
          "is_async": false,
          "calls": [
            "type",
            "RequestsSSLError",
            "ChunkedEncodingError",
            "iter_slices",
            "self.raw.stream",
            "self.raw.read",
            "StreamConsumedError",
            "self.raw",
            "int",
            "isinstance",
            "e",
            "self._content",
            "generate",
            "chunks",
            "bool",
            "stream_decode_response_unicode",
            "ConnectionError",
            "chunk_size",
            "ContentDecodingError",
            "self",
            "TypeError",
            "hasattr"
          ],
          "docstring": "Iterates over the response data.  When stream=True is set on the\nrequest, this avoids reading the content at once into memory for\nlarge responses.  The chunk size is the number of bytes it should\nread into memory.  This is not necessarily the length of each item\nreturned as decoding can take place.\n\nchunk_size must be of type int or None. A value of None will\nfunction differently depending on the value of `stream`.\nstream=True will read data as it arrives in whatever size the\nchunks are received. If stream=False, data is returned as\na single chunk.\n\nIf decode_unicode is True, content will be decoded using the best\navailable encoding based on the response.",
          "code": "def iter_content(self, chunk_size=1, decode_unicode=False):\n        \"\"\"Iterates over the response data.  When stream=True is set on the\n        request, this avoids reading the content at once into memory for\n        large responses.  The chunk size is the number of bytes it should\n        read into memory.  This is not necessarily the length of each item\n        returned as decoding can take place.\n\n        chunk_size must be of type int or None. A value of None will\n        function differently depending on the value of `stream`.\n        stream=True will read data as it arrives in whatever size the\n        chunks are received. If stream=False, data is returned as\n        a single chunk.\n\n        If decode_unicode is True, content will be decoded using the best\n        available encoding based on the response.\n        \"\"\"\n\n        def generate():\n            # Special case for urllib3.\n            if hasattr(self.raw, \"stream\"):\n                try:\n                    yield from self.raw.stream(chunk_size, decode_content=True)\n                except ProtocolError as e:\n                    raise ChunkedEncodingError(e)\n                except DecodeError as e:\n                    raise ContentDecodingError(e)\n                except ReadTimeoutError as e:\n                    raise ConnectionError(e)\n                except SSLError as e:\n                    raise RequestsSSLError(e)\n            else:\n                # Standard file-like object.\n                while True:\n                    chunk = self.raw.read(chunk_size)\n                    if not chunk:\n                        break\n                    yield chunk\n\n            self._content_consumed = True\n\n        if self._content_consumed and isinstance(self._content, bool):\n            raise StreamConsumedError()\n        elif chunk_size is not None and not isinstance(chunk_size, int):\n            raise TypeError(\n                f\"chunk_size must be an int, it is instead a {type(chunk_size)}.\"\n            )\n        # simulate reading small chunks of the content\n        reused_chunks = iter_slices(self._content, chunk_size)\n\n        stream_chunks = generate()\n\n        chunks = reused_chunks if self._content_consumed else stream_chunks\n\n        if decode_unicode:\n            chunks = stream_decode_response_unicode(chunks, self)\n\n        return chunks",
          "line_count": 57,
          "needs_llm_summary": true
        },
        {
          "name": "iter_lines",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "chunk_size"
            },
            {
              "name": "decode_unicode"
            },
            {
              "name": "delimiter"
            }
          ],
          "return_type": null,
          "lineno": 857,
          "decorators": [],
          "is_async": false,
          "calls": [
            "lines.pop",
            "decode_unicode",
            "chunk_size",
            "delimiter",
            "self.iter_content",
            "chunk.split",
            "chunk.splitlines"
          ],
          "docstring": "Iterates over the response data, one line at a time.  When\nstream=True is set on the request, this avoids reading the\ncontent at once into memory for large responses.\n\n.. note:: This method is not reentrant safe.",
          "code": "def iter_lines(\n        self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None\n    ):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n        .. note:: This method is not reentrant safe.\n        \"\"\"\n\n        pending = None\n\n        for chunk in self.iter_content(\n            chunk_size=chunk_size, decode_unicode=decode_unicode\n        ):\n            if pending is not None:\n                chunk = pending + chunk\n\n            if delimiter:\n                lines = chunk.split(delimiter)\n            else:\n                lines = chunk.splitlines()\n\n            if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:\n                pending = lines.pop()\n            else:\n                pending = None\n\n            yield from lines\n\n        if pending is not None:\n            yield pending",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "content",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 891,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "RuntimeError",
            "unknown.join",
            "self.iter_content",
            "CONTENT_CHUNK_SIZE"
          ],
          "docstring": "Content of the response, in bytes.",
          "code": "def content(self):\n        \"\"\"Content of the response, in bytes.\"\"\"\n\n        if self._content is False:\n            # Read the contents.\n            if self._content_consumed:\n                raise RuntimeError(\"The content for this response was already consumed\")\n\n            if self.status_code == 0 or self.raw is None:\n                self._content = None\n            else:\n                self._content = b\"\".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b\"\"\n\n        self._content_consumed = True\n        # don't need to release the connection; that's been handled by urllib3\n        # since we exhausted the data.\n        return self._content",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "text",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 910,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.apparent_encoding",
            "self.content",
            "encoding",
            "str",
            "self.encoding"
          ],
          "docstring": "Content of the response, in unicode.\n\nIf Response.encoding is None, encoding will be guessed using\n``charset_normalizer`` or ``chardet``.\n\nThe encoding of the response content is determined based solely on HTTP\nheaders, following RFC 2616 to the letter. If you can take advantage of\nnon-HTTP knowledge to make a better guess at the encoding, you should\nset ``r.encoding`` appropriately before accessing this property.",
          "code": "def text(self):\n        \"\"\"Content of the response, in unicode.\n\n        If Response.encoding is None, encoding will be guessed using\n        ``charset_normalizer`` or ``chardet``.\n\n        The encoding of the response content is determined based solely on HTTP\n        headers, following RFC 2616 to the letter. If you can take advantage of\n        non-HTTP knowledge to make a better guess at the encoding, you should\n        set ``r.encoding`` appropriately before accessing this property.\n        \"\"\"\n\n        # Try charset from content-type\n        content = None\n        encoding = self.encoding\n\n        if not self.content:\n            return \"\"\n\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors=\"replace\")\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors=\"replace\")\n\n        return content",
          "line_count": 36,
          "needs_llm_summary": true
        },
        {
          "name": "json",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 947,
          "decorators": [],
          "is_async": false,
          "calls": [
            "guess_json_utf",
            "len",
            "self.content",
            "encoding",
            "self.content.decode",
            "complexjson.loads",
            "kwargs",
            "e.doc",
            "self.text",
            "e.msg",
            "e.pos",
            "RequestsJSONDecodeError"
          ],
          "docstring": "Decodes the JSON response body (if any) as a Python object.\n\nThis may return a dictionary, list, etc. depending on what is in the response.\n\n:param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n:raises requests.exceptions.JSONDecodeError: If the response body does not\n    contain valid json.",
          "code": "def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n\n        This may return a dictionary, list, etc. depending on what is in the response.\n\n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n\n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n\n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n            raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)",
          "line_count": 34,
          "needs_llm_summary": true
        },
        {
          "name": "links",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 983,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "link",
            "self.headers.get",
            "link.get",
            "parse_header_links",
            "header"
          ],
          "docstring": "Returns the parsed header links of the response, if any.",
          "code": "def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n        header = self.headers.get(\"link\")\n\n        resolved_links = {}\n\n        if header:\n            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get(\"rel\") or link.get(\"url\")\n                resolved_links[key] = link\n\n        return resolved_links",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "raise_for_status",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 999,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "self.reason.decode",
            "http_error_msg",
            "HTTPError",
            "self",
            "bytes",
            "self.reason"
          ],
          "docstring": "Raises :class:`HTTPError`, if one occurred.",
          "code": "def raise_for_status(self):\n        \"\"\"Raises :class:`HTTPError`, if one occurred.\"\"\"\n\n        http_error_msg = \"\"\n        if isinstance(self.reason, bytes):\n            # We attempt to decode utf-8 first because some servers\n            # choose to localize their reason strings. If the string\n            # isn't utf-8, we fall back to iso-8859-1 for all other\n            # encodings. (See PR #3538)\n            try:\n                reason = self.reason.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                reason = self.reason.decode(\"iso-8859-1\")\n        else:\n            reason = self.reason\n\n        if 400 <= self.status_code < 500:\n            http_error_msg = (\n                f\"{self.status_code} Client Error: {reason} for url: {self.url}\"\n            )\n\n        elif 500 <= self.status_code < 600:\n            http_error_msg = (\n                f\"{self.status_code} Server Error: {reason} for url: {self.url}\"\n            )\n\n        if http_error_msg:\n            raise HTTPError(http_error_msg, response=self)",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "close",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 1028,
          "decorators": [],
          "is_async": false,
          "calls": [
            "getattr",
            "release_conn",
            "self.raw",
            "self.raw.close"
          ],
          "docstring": "Releases the connection back to the pool. Once this method has been\ncalled the underlying ``raw`` object must not be accessed again.\n\n*Note: Should not normally need to be called explicitly.*",
          "code": "def close(self):\n        \"\"\"Releases the connection back to the pool. Once this method has been\n        called the underlying ``raw`` object must not be accessed again.\n\n        *Note: Should not normally need to be called explicitly.*\n        \"\"\"\n        if not self._content_consumed:\n            self.raw.close()\n\n        release_conn = getattr(self.raw, \"release_conn\", None)\n        if release_conn is not None:\n            release_conn()",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "generate",
          "args": [],
          "return_type": null,
          "lineno": 816,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.raw.read",
            "e",
            "ConnectionError",
            "chunk_size",
            "ContentDecodingError",
            "RequestsSSLError",
            "ChunkedEncodingError",
            "hasattr",
            "self.raw.stream",
            "self.raw"
          ],
          "docstring": null,
          "code": "def generate():\n            # Special case for urllib3.\n            if hasattr(self.raw, \"stream\"):\n                try:\n                    yield from self.raw.stream(chunk_size, decode_content=True)\n                except ProtocolError as e:\n                    raise ChunkedEncodingError(e)\n                except DecodeError as e:\n                    raise ContentDecodingError(e)\n                except ReadTimeoutError as e:\n                    raise ConnectionError(e)\n                except SSLError as e:\n                    raise RequestsSSLError(e)\n            else:\n                # Standard file-like object.\n                while True:\n                    chunk = self.raw.read(chunk_size)\n                    if not chunk:\n                        break\n                    yield chunk\n\n            self._content_consumed = True",
          "line_count": 22,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "RequestEncodingMixin",
          "methods": [
            "path_url",
            "_encode_params",
            "_encode_files"
          ],
          "base_classes": [],
          "lineno": 84,
          "docstring": null
        },
        {
          "name": "RequestHooksMixin",
          "methods": [
            "register_hook",
            "deregister_hook"
          ],
          "base_classes": [],
          "lineno": 206,
          "docstring": null
        },
        {
          "name": "Request",
          "methods": [
            "__init__",
            "__repr__",
            "prepare"
          ],
          "base_classes": [
            "RequestHooksMixin"
          ],
          "lineno": 230,
          "docstring": "A user-created :class:`Request <Request>` object.\n\nUsed to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n:param method: HTTP method to use.\n:param url: URL to send.\n:param headers: dictionary of headers to send.\n:param files: dictionary of {filename: fileobject} files to multipart upload.\n:param data: the body to attach to the request. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param json: json for the body to attach to the request (if files or data is not specified).\n:param params: URL parameters to append to the URL. If a dictionary or\n    list of tuples ``[(key, value)]`` is provided, form-encoding will\n    take place.\n:param auth: Auth handler or (user, pass) tuple.\n:param cookies: dictionary or CookieJar of cookies to attach to this request.\n:param hooks: dictionary of callback hooks, for internal usage.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> req.prepare()\n  <PreparedRequest [GET]>"
        },
        {
          "name": "PreparedRequest",
          "methods": [
            "__init__",
            "prepare",
            "__repr__",
            "copy",
            "prepare_method",
            "_get_idna_encoded_host",
            "prepare_url",
            "prepare_headers",
            "prepare_body",
            "prepare_content_length",
            "prepare_auth",
            "prepare_cookies",
            "prepare_hooks"
          ],
          "base_classes": [
            "RequestEncodingMixin",
            "RequestHooksMixin"
          ],
          "lineno": 313,
          "docstring": "The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\ncontaining the exact bytes that will be sent to the server.\n\nInstances are generated from a :class:`Request <Request>` object, and\nshould not be instantiated manually; doing so may produce undesirable\neffects.\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.Request('GET', 'https://httpbin.org/get')\n  >>> r = req.prepare()\n  >>> r\n  <PreparedRequest [GET]>\n\n  >>> s = requests.Session()\n  >>> s.send(r)\n  <Response [200]>"
        },
        {
          "name": "Response",
          "methods": [
            "__init__",
            "__enter__",
            "__exit__",
            "__getstate__",
            "__setstate__",
            "__repr__",
            "__bool__",
            "__nonzero__",
            "__iter__",
            "ok",
            "is_redirect",
            "is_permanent_redirect",
            "next",
            "apparent_encoding",
            "iter_content",
            "iter_lines",
            "content",
            "text",
            "json",
            "links",
            "raise_for_status",
            "close"
          ],
          "base_classes": [],
          "lineno": 640,
          "docstring": "The :class:`Response <Response>` object, which contains a\nserver's response to an HTTP request."
        }
      ],
      "imports": [
        {
          "module": "datetime",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "encodings.idna",
          "alias": null,
          "lineno": 13,
          "type": "import"
        },
        {
          "module": "io",
          "name": "UnsupportedOperation",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "DecodeError",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "LocationParseError",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "ProtocolError",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "ReadTimeoutError",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "urllib3.exceptions",
          "name": "SSLError",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "urllib3.fields",
          "name": "RequestField",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "urllib3.filepost",
          "name": "encode_multipart_formdata",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "urllib3.util",
          "name": "parse_url",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "_internal_utils",
          "name": "to_native_string",
          "alias": null,
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "_internal_utils",
          "name": "unicode_is_ascii",
          "alias": null,
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "auth",
          "name": "HTTPBasicAuth",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "Callable",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "JSONDecodeError",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "Mapping",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "basestring",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "builtin_str",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "chardet",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "cookielib",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "json",
          "alias": "complexjson",
          "lineno": 38,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlencode",
          "alias": null,
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlsplit",
          "alias": null,
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlunparse",
          "alias": null,
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "_copy_cookie_jar",
          "alias": null,
          "lineno": 40,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "cookiejar_from_dict",
          "alias": null,
          "lineno": 40,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "get_cookie_header",
          "alias": null,
          "lineno": 40,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ChunkedEncodingError",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ConnectionError",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ContentDecodingError",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "HTTPError",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidJSONError",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidURL",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "JSONDecodeError",
          "alias": "RequestsJSONDecodeError",
          "lineno": 49,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "MissingSchema",
          "alias": null,
          "lineno": 50,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "SSLError",
          "alias": "RequestsSSLError",
          "lineno": 51,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "StreamConsumedError",
          "alias": null,
          "lineno": 52,
          "type": "from_import"
        },
        {
          "module": "hooks",
          "name": "default_hooks",
          "alias": null,
          "lineno": 53,
          "type": "from_import"
        },
        {
          "module": "status_codes",
          "name": "codes",
          "alias": null,
          "lineno": 54,
          "type": "from_import"
        },
        {
          "module": "structures",
          "name": "CaseInsensitiveDict",
          "alias": null,
          "lineno": 55,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "check_header_validity",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_auth_from_url",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "guess_filename",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "guess_json_utf",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "iter_slices",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "parse_header_links",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "requote_uri",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "stream_decode_response_unicode",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "super_len",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "to_key_val_list",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "idna",
          "alias": null,
          "lineno": 401,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "REDIRECT_STATI",
          "assigned_to": null,
          "lineno": 71
        },
        {
          "name": "DEFAULT_REDIRECT_LIMIT",
          "assigned_to": "int",
          "lineno": 79
        },
        {
          "name": "CONTENT_CHUNK_SIZE",
          "assigned_to": null,
          "lineno": 80
        },
        {
          "name": "ITER_CHUNK_SIZE",
          "assigned_to": "int",
          "lineno": 81
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "datetime",
          "io"
        ],
        "third_party": {
          "other": [
            "encodings",
            "urllib3",
            "_internal_utils",
            "auth",
            "compat",
            "cookies",
            "exceptions",
            "hooks",
            "status_codes",
            "structures",
            "utils",
            "idna"
          ]
        },
        "tech_stack": []
      },
      "line_count": 1040
    },
    "src/requests/packages.py": {
      "filepath": "../requests/src/requests/packages.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "sys",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "compat",
          "name": "chardet",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "package",
          "target",
          "list",
          "chardet.__name__",
          "__import__",
          "imported_mod",
          "locals",
          "mod.startswith",
          "sys.modules",
          "mod.replace"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "sys"
        ],
        "third_party": {
          "other": [
            "compat"
          ]
        },
        "tech_stack": []
      },
      "line_count": 24
    },
    "src/requests/sessions.py": {
      "filepath": "../requests/src/requests/sessions.py",
      "module_docstring": "requests.sessions\n~~~~~~~~~~~~~~~~~\n\nThis module provides a Session object to manage and persist settings across\nrequests (cookies, auth, proxies).",
      "functions": [
        {
          "name": "merge_setting",
          "args": [
            {
              "name": "request_setting"
            },
            {
              "name": "session_setting"
            },
            {
              "name": "dict_class"
            }
          ],
          "return_type": null,
          "lineno": 61,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "to_key_val_list",
            "session_setting",
            "merged_setting.items",
            "request_setting",
            "Mapping",
            "dict_class",
            "merged_setting.update"
          ],
          "docstring": "Determines appropriate setting for a given request, taking into account\nthe explicit setting on that request, and the setting in the session. If a\nsetting is a dictionary, they will be merged together using `dict_class`",
          "code": "def merge_setting(request_setting, session_setting, dict_class=OrderedDict):\n    \"\"\"Determines appropriate setting for a given request, taking into account\n    the explicit setting on that request, and the setting in the session. If a\n    setting is a dictionary, they will be merged together using `dict_class`\n    \"\"\"\n\n    if session_setting is None:\n        return request_setting\n\n    if request_setting is None:\n        return session_setting\n\n    # Bypass if not a dictionary (e.g. verify)\n    if not (\n        isinstance(session_setting, Mapping) and isinstance(request_setting, Mapping)\n    ):\n        return request_setting\n\n    merged_setting = dict_class(to_key_val_list(session_setting))\n    merged_setting.update(to_key_val_list(request_setting))\n\n    # Remove keys that are set to None. Extract keys first to avoid altering\n    # the dictionary during iteration.\n    none_keys = [k for (k, v) in merged_setting.items() if v is None]\n    for key in none_keys:\n        del merged_setting[key]\n\n    return merged_setting",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "merge_hooks",
          "args": [
            {
              "name": "request_hooks"
            },
            {
              "name": "session_hooks"
            },
            {
              "name": "dict_class"
            }
          ],
          "return_type": null,
          "lineno": 91,
          "decorators": [],
          "is_async": false,
          "calls": [
            "session_hooks",
            "request_hooks.get",
            "merge_setting",
            "request_hooks",
            "dict_class",
            "session_hooks.get"
          ],
          "docstring": "Properly merges both requests and session hooks.\n\nThis is necessary because when request_hooks == {'response': []}, the\nmerge breaks Session hooks entirely.",
          "code": "def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n    \"\"\"Properly merges both requests and session hooks.\n\n    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get(\"response\") == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get(\"response\") == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "session",
          "args": [],
          "return_type": null,
          "lineno": 819,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Session"
          ],
          "docstring": "Returns a :class:`Session` for context-management.\n\n.. deprecated:: 1.0.0\n\n    This method has been deprecated since version 1.0.0 and is only kept for\n    backwards compatibility. New code should use :class:`~requests.sessions.Session`\n    to create a session. This may be removed at a future date.\n\n:rtype: Session",
          "code": "def session():\n    \"\"\"\n    Returns a :class:`Session` for context-management.\n\n    .. deprecated:: 1.0.0\n\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n    return Session()",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "get_redirect_target",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "resp"
            }
          ],
          "return_type": null,
          "lineno": 107,
          "decorators": [],
          "is_async": false,
          "calls": [
            "location.encode",
            "location",
            "to_native_string"
          ],
          "docstring": "Receives a Response. Returns a redirect URI or ``None``",
          "code": "def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:\n            location = resp.headers[\"location\"]\n            # Currently the underlying http module on py3 decode headers\n            # in latin1, but empirical evidence suggests that latin1 is very\n            # rarely used with non-ASCII characters in HTTP headers.\n            # It is more likely to get UTF8 header rather than latin1.\n            # This causes incorrect handling of UTF8 encoded location headers.\n            # To solve this, we re-encode the location in latin1.\n            location = location.encode(\"latin1\")\n            return to_native_string(location, \"utf8\")\n        return None",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "should_strip_auth",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "old_url"
            },
            {
              "name": "new_url"
            }
          ],
          "return_type": null,
          "lineno": 127,
          "decorators": [],
          "is_async": false,
          "calls": [
            "old_url",
            "DEFAULT_PORTS.get",
            "new_url",
            "urlparse",
            "old_parsed.scheme"
          ],
          "docstring": "Decide whether Authorization header should be removed when redirecting",
          "code": "def should_strip_auth(self, old_url, new_url):\n        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n        # breaking backwards compatibility with older versions of requests\n        # that allowed any redirects on the same host.\n        if (\n            old_parsed.scheme == \"http\"\n            and old_parsed.port in (80, None)\n            and new_parsed.scheme == \"https\"\n            and new_parsed.port in (443, None)\n        ):\n            return False\n\n        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (\n            not changed_scheme\n            and old_parsed.port in default_port\n            and new_parsed.port in default_port\n        ):\n            return False\n\n        # Standard case: root URI must match\n        return changed_port or changed_scheme",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "resolve_redirects",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "resp"
            },
            {
              "name": "req"
            },
            {
              "name": "stream"
            },
            {
              "name": "timeout"
            },
            {
              "name": "verify"
            },
            {
              "name": "cert"
            },
            {
              "name": "proxies"
            },
            {
              "name": "yield_requests"
            }
          ],
          "return_type": null,
          "lineno": 159,
          "decorators": [],
          "is_async": false,
          "calls": [
            "resp.raw",
            "urljoin",
            "resp.url",
            "url.startswith",
            "stream",
            "rewind_body",
            "urlparse",
            "resp",
            "prepared_request._cookies",
            "header",
            "len",
            "parsed_rurl.scheme",
            "url",
            "parsed.fragment",
            "prepared_request.headers",
            "resp.close",
            "self.send",
            "timeout",
            "adapter_kwargs",
            "unknown.join",
            "previous_fragment",
            "verify",
            "prepared_request",
            "requote_uri",
            "merge_cookies",
            "TooManyRedirects",
            "hist.append",
            "self.rebuild_proxies",
            "parsed._replace",
            "resp.raw.read",
            "prepared_request.headers.pop",
            "resp.history",
            "self.cookies",
            "req",
            "req.copy",
            "extract_cookies_to_jar",
            "req.url",
            "self.rebuild_auth",
            "to_native_string",
            "self.get_redirect_target",
            "unknown.fragment",
            "headers.pop",
            "proxies",
            "cert",
            "prepared_request.prepare_cookies",
            "parsed.geturl",
            "self.rebuild_method"
          ],
          "docstring": "Receives a Response. Returns a generator of Responses or Requests.",
          "code": "def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):\n        \"\"\"Receives a Response. Returns a generator of Responses or Requests.\"\"\"\n\n        hist = []  # keep track of history\n\n        url = self.get_redirect_target(resp)\n        previous_fragment = urlparse(req.url).fragment\n        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            self.rebuild_auth(prepared_request, resp)\n\n            # A failed tell() sets `_body_position` to `object()`. This non-None\n            # value ensures `rewindable` will be True, allowing us to raise an\n            # UnrewindableBodyError, instead of hanging the connection.\n            rewindable = prepared_request._body_position is not None and (\n                \"Content-Length\" in headers or \"Transfer-Encoding\" in headers\n            )\n\n            # Attempt to rewind consumed file-like object.\n            if rewindable:\n                rewind_body(prepared_request)\n\n            # Override the original request.\n            req = prepared_request\n\n            if yield_requests:\n                yield req\n            else:\n                resp = self.send(\n                    req,\n                    stream=stream,\n                    timeout=timeout,\n                    verify=verify,\n                    cert=cert,\n                    proxies=proxies,\n                    allow_redirects=False,\n                    **adapter_kwargs,\n                )\n\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n                # extract redirect url, if any, for the next loop\n                url = self.get_redirect_target(resp)\n                yield resp",
          "line_count": 122,
          "needs_llm_summary": true
        },
        {
          "name": "rebuild_auth",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "prepared_request"
            },
            {
              "name": "response"
            }
          ],
          "return_type": null,
          "lineno": 282,
          "decorators": [],
          "is_async": false,
          "calls": [
            "prepared_request.prepare_auth",
            "prepared_request.url",
            "url",
            "new_auth",
            "prepared_request.headers",
            "response.request.url",
            "get_netrc_auth",
            "self.should_strip_auth"
          ],
          "docstring": "When being redirected we may want to strip authentication from the\nrequest to avoid leaking credentials. This method intelligently removes\nand reapplies authentication where possible to avoid credential loss.",
          "code": "def rebuild_auth(self, prepared_request, response):\n        \"\"\"When being redirected we may want to strip authentication from the\n        request to avoid leaking credentials. This method intelligently removes\n        and reapplies authentication where possible to avoid credential loss.\n        \"\"\"\n        headers = prepared_request.headers\n        url = prepared_request.url\n\n        if \"Authorization\" in headers and self.should_strip_auth(\n            response.request.url, url\n        ):\n            # If we get redirected to a new host, we should strip out any\n            # authentication headers.\n            del headers[\"Authorization\"]\n\n        # .netrc might have more auth for us on our new host.\n        new_auth = get_netrc_auth(url) if self.trust_env else None\n        if new_auth is not None:\n            prepared_request.prepare_auth(new_auth)",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "rebuild_proxies",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "prepared_request"
            },
            {
              "name": "proxies"
            }
          ],
          "return_type": null,
          "lineno": 302,
          "decorators": [],
          "is_async": false,
          "calls": [
            "prepared_request",
            "resolve_proxies",
            "proxies",
            "password",
            "scheme.startswith",
            "prepared_request.url",
            "prepared_request.headers",
            "urlparse",
            "_basic_auth_str",
            "unknown.scheme",
            "self.trust_env",
            "get_auth_from_url",
            "username"
          ],
          "docstring": "This method re-evaluates the proxy configuration by considering the\nenvironment variables. If we are redirected to a URL covered by\nNO_PROXY, we strip the proxy configuration. Otherwise, we set missing\nproxy keys for this URL (in case they were stripped by a previous\nredirect).\n\nThis method also replaces the Proxy-Authorization header where\nnecessary.\n\n:rtype: dict",
          "code": "def rebuild_proxies(self, prepared_request, proxies):\n        \"\"\"This method re-evaluates the proxy configuration by considering the\n        environment variables. If we are redirected to a URL covered by\n        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n        proxy keys for this URL (in case they were stripped by a previous\n        redirect).\n\n        This method also replaces the Proxy-Authorization header where\n        necessary.\n\n        :rtype: dict\n        \"\"\"\n        headers = prepared_request.headers\n        scheme = urlparse(prepared_request.url).scheme\n        new_proxies = resolve_proxies(prepared_request, proxies, self.trust_env)\n\n        if \"Proxy-Authorization\" in headers:\n            del headers[\"Proxy-Authorization\"]\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        # urllib3 handles proxy authorization for us in the standard adapter.\n        # Avoid appending this to TLS tunneled requests where it may be leaked.\n        if not scheme.startswith(\"https\") and username and password:\n            headers[\"Proxy-Authorization\"] = _basic_auth_str(username, password)\n\n        return new_proxies",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "rebuild_method",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "prepared_request"
            },
            {
              "name": "response"
            }
          ],
          "return_type": null,
          "lineno": 333,
          "decorators": [],
          "is_async": false,
          "calls": [
            "method",
            "prepared_request.method"
          ],
          "docstring": "When being redirected we may want to change the method of the request\nbased on certain specs or browser behavior.",
          "code": "def rebuild_method(self, prepared_request, response):\n        \"\"\"When being redirected we may want to change the method of the request\n        based on certain specs or browser behavior.\n        \"\"\"\n        method = prepared_request.method\n\n        # https://tools.ietf.org/html/rfc7231#section-6.4.4\n        if response.status_code == codes.see_other and method != \"HEAD\":\n            method = \"GET\"\n\n        # Do what the browsers do, despite standards...\n        # First, turn 302s into GETs.\n        if response.status_code == codes.found and method != \"HEAD\":\n            method = \"GET\"\n\n        # Second, if a POST is responded to with a 301, turn it into a GET.\n        # This bizarre behaviour is explained in Issue 1704.\n        if response.status_code == codes.moved and method == \"POST\":\n            method = \"GET\"\n\n        prepared_request.method = method",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 390,
          "decorators": [],
          "is_async": false,
          "calls": [
            "OrderedDict",
            "DEFAULT_REDIRECT_LIMIT",
            "default_hooks",
            "HTTPAdapter",
            "self.mount",
            "cookiejar_from_dict",
            "default_headers"
          ],
          "docstring": null,
          "code": "def __init__(self):\n        #: A case-insensitive dictionary of headers to be sent on each\n        #: :class:`Request <Request>` sent from this\n        #: :class:`Session <Session>`.\n        self.headers = default_headers()\n\n        #: Default Authentication tuple or object to attach to\n        #: :class:`Request <Request>`.\n        self.auth = None\n\n        #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n        #: be used on each :class:`Request <Request>`.\n        self.proxies = {}\n\n        #: Event-handling hooks.\n        self.hooks = default_hooks()\n\n        #: Dictionary of querystring data to attach to each\n        #: :class:`Request <Request>`. The dictionary values may be lists for\n        #: representing multivalued query parameters.\n        self.params = {}\n\n        #: Stream response content default.\n        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n        self.verify = True\n\n        #: SSL client certificate default, if String, path to ssl client\n        #: cert file (.pem). If Tuple, ('cert', 'key') pair.\n        self.cert = None\n\n        #: Maximum number of redirects allowed. If the request exceeds this\n        #: limit, a :class:`TooManyRedirects` exception is raised.\n        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n        #: 30.\n        self.max_redirects = DEFAULT_REDIRECT_LIMIT\n\n        #: Trust environment settings for proxy configuration, default\n        #: authentication and similar.\n        self.trust_env = True\n\n        #: A CookieJar containing all currently outstanding cookies set on this\n        #: session. By default it is a\n        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n        #: may be any other ``cookielib.CookieJar`` compatible object.\n        self.cookies = cookiejar_from_dict({})\n\n        # Default connection adapters.\n        self.adapters = OrderedDict()\n        self.mount(\"https://\", HTTPAdapter())\n        self.mount(\"http://\", HTTPAdapter())",
          "line_count": 60,
          "needs_llm_summary": true
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 451,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __enter__(self):\n        return self",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 454,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.close"
          ],
          "docstring": null,
          "code": "def __exit__(self, *args):\n        self.close()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "prepare_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            }
          ],
          "return_type": null,
          "lineno": 457,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.auth",
            "self.hooks",
            "request.params",
            "self.params",
            "RequestsCookieJar",
            "cookies",
            "request.files",
            "cookielib.CookieJar",
            "request.method.upper",
            "request.url",
            "request.data",
            "isinstance",
            "request.hooks",
            "merge_cookies",
            "request.json",
            "merge_setting",
            "CaseInsensitiveDict",
            "self.cookies",
            "request.auth",
            "merge_hooks",
            "p.prepare",
            "PreparedRequest",
            "self.headers",
            "cookiejar_from_dict",
            "get_netrc_auth",
            "auth",
            "merged_cookies",
            "request.headers"
          ],
          "docstring": "Constructs a :class:`PreparedRequest <PreparedRequest>` for\ntransmission and returns it. The :class:`PreparedRequest` has settings\nmerged from the :class:`Request <Request>` instance and those of the\n:class:`Session`.\n\n:param request: :class:`Request` instance to prepare with this\n    session's settings.\n:rtype: requests.PreparedRequest",
          "code": "def prepare_request(self, request):\n        \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for\n        transmission and returns it. The :class:`PreparedRequest` has settings\n        merged from the :class:`Request <Request>` instance and those of the\n        :class:`Session`.\n\n        :param request: :class:`Request` instance to prepare with this\n            session's settings.\n        :rtype: requests.PreparedRequest\n        \"\"\"\n        cookies = request.cookies or {}\n\n        # Bootstrap CookieJar.\n        if not isinstance(cookies, cookielib.CookieJar):\n            cookies = cookiejar_from_dict(cookies)\n\n        # Merge with session cookies\n        merged_cookies = merge_cookies(\n            merge_cookies(RequestsCookieJar(), self.cookies), cookies\n        )\n\n        # Set environment's basic authentication if not explicitly set.\n        auth = request.auth\n        if self.trust_env and not auth and not self.auth:\n            auth = get_netrc_auth(request.url)\n\n        p = PreparedRequest()\n        p.prepare(\n            method=request.method.upper(),\n            url=request.url,\n            files=request.files,\n            data=request.data,\n            json=request.json,\n            headers=merge_setting(\n                request.headers, self.headers, dict_class=CaseInsensitiveDict\n            ),\n            params=merge_setting(request.params, self.params),\n            auth=merge_setting(auth, self.auth),\n            cookies=merged_cookies,\n            hooks=merge_hooks(request.hooks, self.hooks),\n        )\n        return p",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "method"
            },
            {
              "name": "url"
            },
            {
              "name": "params"
            },
            {
              "name": "data"
            },
            {
              "name": "headers"
            },
            {
              "name": "cookies"
            },
            {
              "name": "files"
            },
            {
              "name": "auth"
            },
            {
              "name": "timeout"
            },
            {
              "name": "allow_redirects"
            },
            {
              "name": "proxies"
            },
            {
              "name": "hooks"
            },
            {
              "name": "stream"
            },
            {
              "name": "verify"
            },
            {
              "name": "cert"
            },
            {
              "name": "json"
            }
          ],
          "return_type": null,
          "lineno": 500,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "send_kwargs",
            "hooks",
            "cookies",
            "url",
            "self.send",
            "files",
            "prep",
            "headers",
            "verify",
            "send_kwargs.update",
            "Request",
            "json",
            "self.merge_environment_settings",
            "req",
            "proxies",
            "cert",
            "settings",
            "auth",
            "self.prepare_request",
            "method.upper",
            "prep.url"
          ],
          "docstring": "Constructs a :class:`Request <Request>`, prepares it and sends it.\nReturns :class:`Response <Response>` object.\n\n:param method: method for the new :class:`Request` object.\n:param url: URL for the new :class:`Request` object.\n:param params: (optional) Dictionary or bytes to be sent in the query\n    string for the :class:`Request`.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) json to send in the body of the\n    :class:`Request`.\n:param headers: (optional) Dictionary of HTTP Headers to send with the\n    :class:`Request`.\n:param cookies: (optional) Dict or CookieJar object to send with the\n    :class:`Request`.\n:param files: (optional) Dictionary of ``'filename': file-like-objects``\n    for multipart encoding upload.\n:param auth: (optional) Auth tuple or callable to enable\n    Basic/Digest/Custom HTTP Auth.\n:param timeout: (optional) How many seconds to wait for the server to send\n    data before giving up, as a float, or a :ref:`(connect timeout,\n    read timeout) <timeouts>` tuple.\n:type timeout: float or tuple\n:param allow_redirects: (optional) Set to True by default.\n:type allow_redirects: bool\n:param proxies: (optional) Dictionary mapping protocol or protocol and\n    hostname to the URL of the proxy.\n:param hooks: (optional) Dictionary mapping hook name to one event or\n    list of events, event must be callable.\n:param stream: (optional) whether to immediately download the response\n    content. Defaults to ``False``.\n:param verify: (optional) Either a boolean, in which case it controls whether we verify\n    the server's TLS certificate, or a string, in which case it must be a path\n    to a CA bundle to use. Defaults to ``True``. When set to\n    ``False``, requests will accept any TLS certificate presented by\n    the server, and will ignore hostname mismatches and/or expired\n    certificates, which will make your application vulnerable to\n    man-in-the-middle (MitM) attacks. Setting verify to ``False``\n    may be useful during local development or testing.\n:param cert: (optional) if String, path to ssl client cert file (.pem).\n    If Tuple, ('cert', 'key') pair.\n:rtype: requests.Response",
          "code": "def request(\n        self,\n        method,\n        url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None,\n    ):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How many seconds to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param hooks: (optional) Dictionary mapping hook name to one event or\n            list of events, event must be callable.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False``\n            may be useful during local development or testing.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            \"timeout\": timeout,\n            \"allow_redirects\": allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp",
          "line_count": 92,
          "needs_llm_summary": true
        },
        {
          "name": "get",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 593,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url",
            "self.request",
            "kwargs.setdefault"
          ],
          "docstring": "Sends a GET request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
          "code": "def get(self, url, **kwargs):\n        r\"\"\"Sends a GET request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :rtype: requests.Response\n        \"\"\"\n\n        kwargs.setdefault(\"allow_redirects\", True)\n        return self.request(\"GET\", url, **kwargs)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "options",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 604,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url",
            "self.request",
            "kwargs.setdefault"
          ],
          "docstring": "Sends a OPTIONS request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
          "code": "def options(self, url, **kwargs):\n        r\"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :rtype: requests.Response\n        \"\"\"\n\n        kwargs.setdefault(\"allow_redirects\", True)\n        return self.request(\"OPTIONS\", url, **kwargs)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "head",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 615,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url",
            "self.request",
            "kwargs.setdefault"
          ],
          "docstring": "Sends a HEAD request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
          "code": "def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :rtype: requests.Response\n        \"\"\"\n\n        kwargs.setdefault(\"allow_redirects\", False)\n        return self.request(\"HEAD\", url, **kwargs)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "post",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            },
            {
              "name": "data"
            },
            {
              "name": "json"
            }
          ],
          "return_type": null,
          "lineno": 626,
          "decorators": [],
          "is_async": false,
          "calls": [
            "json",
            "kwargs",
            "url",
            "self.request",
            "data"
          ],
          "docstring": "Sends a POST request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) json to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
          "code": "def post(self, url, data=None, json=None, **kwargs):\n        r\"\"\"Sends a POST request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the :class:`Request`.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :rtype: requests.Response\n        \"\"\"\n\n        return self.request(\"POST\", url, data=data, json=json, **kwargs)",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "put",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            },
            {
              "name": "data"
            }
          ],
          "return_type": null,
          "lineno": 639,
          "decorators": [],
          "is_async": false,
          "calls": [
            "data",
            "kwargs",
            "url",
            "self.request"
          ],
          "docstring": "Sends a PUT request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
          "code": "def put(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PUT request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :rtype: requests.Response\n        \"\"\"\n\n        return self.request(\"PUT\", url, data=data, **kwargs)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "patch",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            },
            {
              "name": "data"
            }
          ],
          "return_type": null,
          "lineno": 651,
          "decorators": [],
          "is_async": false,
          "calls": [
            "data",
            "kwargs",
            "url",
            "self.request"
          ],
          "docstring": "Sends a PATCH request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
          "code": "def patch(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PATCH request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :rtype: requests.Response\n        \"\"\"\n\n        return self.request(\"PATCH\", url, data=data, **kwargs)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "delete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 663,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url",
            "self.request"
          ],
          "docstring": "Sends a DELETE request. Returns :class:`Response` object.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:rtype: requests.Response",
          "code": "def delete(self, url, **kwargs):\n        r\"\"\"Sends a DELETE request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :rtype: requests.Response\n        \"\"\"\n\n        return self.request(\"DELETE\", url, **kwargs)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "send",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request"
            }
          ],
          "return_type": null,
          "lineno": 673,
          "decorators": [],
          "is_async": false,
          "calls": [
            "adapter.send",
            "resp.raw",
            "self.get_adapter",
            "resolve_proxies",
            "elapsed",
            "self.verify",
            "self.stream",
            "request",
            "ValueError",
            "hooks",
            "kwargs.pop",
            "history.pop",
            "preferred_clock",
            "dispatch_hook",
            "r.raw",
            "request.url",
            "self.trust_env",
            "history",
            "isinstance",
            "request.hooks",
            "kwargs.get",
            "history.insert",
            "kwargs.setdefault",
            "Request",
            "self.proxies",
            "self.cert",
            "timedelta",
            "next",
            "self.cookies",
            "resp.request",
            "extract_cookies_to_jar",
            "kwargs",
            "self.resolve_redirects",
            "r"
          ],
          "docstring": "Send a given PreparedRequest.\n\n:rtype: requests.Response",
          "code": "def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n\n        :rtype: requests.Response\n        \"\"\"\n        # Set defaults that the hooks can utilize to ensure they always have\n        # the correct parameters to reproduce the previous request.\n        kwargs.setdefault(\"stream\", self.stream)\n        kwargs.setdefault(\"verify\", self.verify)\n        kwargs.setdefault(\"cert\", self.cert)\n        if \"proxies\" not in kwargs:\n            kwargs[\"proxies\"] = resolve_proxies(request, self.proxies, self.trust_env)\n\n        # It's possible that users might accidentally send a Request object.\n        # Guard against that specific failure case.\n        if isinstance(request, Request):\n            raise ValueError(\"You can only send PreparedRequests.\")\n\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop(\"allow_redirects\", True)\n        stream = kwargs.get(\"stream\")\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n        # Response manipulation hooks\n        r = dispatch_hook(\"response\", hooks, r, **kwargs)\n\n        # Persist cookies\n        if r.history:\n            # If the hooks create history then we want those cookies too\n            for resp in r.history:\n                extract_cookies_to_jar(self.cookies, resp.request, resp.raw)\n\n        extract_cookies_to_jar(self.cookies, request, r.raw)\n\n        # Resolve redirects if allowed.\n        if allow_redirects:\n            # Redirect resolving generator.\n            gen = self.resolve_redirects(r, request, **kwargs)\n            history = [resp for resp in gen]\n        else:\n            history = []\n\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n            r.history = history\n\n        # If redirects aren't being followed, store the response on the Request for Response.next().\n        if not allow_redirects:\n            try:\n                r._next = next(\n                    self.resolve_redirects(r, request, yield_requests=True, **kwargs)\n                )\n            except StopIteration:\n                pass\n\n        if not stream:\n            r.content\n\n        return r",
          "line_count": 76,
          "needs_llm_summary": true
        },
        {
          "name": "merge_environment_settings",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            },
            {
              "name": "proxies"
            },
            {
              "name": "stream"
            },
            {
              "name": "verify"
            },
            {
              "name": "cert"
            }
          ],
          "return_type": null,
          "lineno": 750,
          "decorators": [],
          "is_async": false,
          "calls": [
            "stream",
            "self.proxies",
            "self.stream",
            "proxies",
            "self.verify",
            "cert",
            "merge_setting",
            "url",
            "proxies.setdefault",
            "no_proxy",
            "self.cert",
            "k",
            "v",
            "os.environ.get",
            "proxies.get",
            "verify",
            "get_environ_proxies",
            "env_proxies.items"
          ],
          "docstring": "Check the environment and merge it with some settings.\n\n:rtype: dict",
          "code": "def merge_environment_settings(self, url, proxies, stream, verify, cert):\n        \"\"\"\n        Check the environment and merge it with some settings.\n\n        :rtype: dict\n        \"\"\"\n        # Gather clues from the surrounding environment.\n        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get(\"no_proxy\") if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for k, v in env_proxies.items():\n                proxies.setdefault(k, v)\n\n            # Look for requests environment configuration\n            # and be compatible with cURL.\n            if verify is True or verify is None:\n                verify = (\n                    os.environ.get(\"REQUESTS_CA_BUNDLE\")\n                    or os.environ.get(\"CURL_CA_BUNDLE\")\n                    or verify\n                )\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n        stream = merge_setting(stream, self.stream)\n        verify = merge_setting(verify, self.verify)\n        cert = merge_setting(cert, self.cert)\n\n        return {\"proxies\": proxies, \"stream\": stream, \"verify\": verify, \"cert\": cert}",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "get_adapter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 781,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.startswith",
            "self.adapters.items",
            "InvalidSchema",
            "url.lower",
            "prefix.lower"
          ],
          "docstring": "Returns the appropriate connection adapter for the given URL.\n\n:rtype: requests.adapters.BaseAdapter",
          "code": "def get_adapter(self, url):\n        \"\"\"\n        Returns the appropriate connection adapter for the given URL.\n\n        :rtype: requests.adapters.BaseAdapter\n        \"\"\"\n        for prefix, adapter in self.adapters.items():\n            if url.lower().startswith(prefix.lower()):\n                return adapter\n\n        # Nothing matches :-/\n        raise InvalidSchema(f\"No connection adapters were found for {url!r}\")",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "close",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 794,
          "decorators": [],
          "is_async": false,
          "calls": [
            "v.close",
            "self.adapters.values"
          ],
          "docstring": "Closes all adapters and as such the session",
          "code": "def close(self):\n        \"\"\"Closes all adapters and as such the session\"\"\"\n        for v in self.adapters.values():\n            v.close()",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "mount",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "prefix"
            },
            {
              "name": "adapter"
            }
          ],
          "return_type": null,
          "lineno": 799,
          "decorators": [],
          "is_async": false,
          "calls": [
            "len",
            "k",
            "prefix",
            "adapter",
            "self.adapters.pop",
            "key"
          ],
          "docstring": "Registers a connection adapter to a prefix.\n\nAdapters are sorted in descending order by prefix length.",
          "code": "def mount(self, prefix, adapter):\n        \"\"\"Registers a connection adapter to a prefix.\n\n        Adapters are sorted in descending order by prefix length.\n        \"\"\"\n        self.adapters[prefix] = adapter\n        keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]\n\n        for key in keys_to_move:\n            self.adapters[key] = self.adapters.pop(key)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "__getstate__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 810,
          "decorators": [],
          "is_async": false,
          "calls": [
            "getattr",
            "self",
            "attr"
          ],
          "docstring": null,
          "code": "def __getstate__(self):\n        state = {attr: getattr(self, attr, None) for attr in self.__attrs__}\n        return state",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__setstate__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "state"
            }
          ],
          "return_type": null,
          "lineno": 814,
          "decorators": [],
          "is_async": false,
          "calls": [
            "state.items",
            "attr",
            "self",
            "value",
            "setattr"
          ],
          "docstring": null,
          "code": "def __setstate__(self, state):\n        for attr, value in state.items():\n            setattr(self, attr, value)",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "SessionRedirectMixin",
          "methods": [
            "get_redirect_target",
            "should_strip_auth",
            "resolve_redirects",
            "rebuild_auth",
            "rebuild_proxies",
            "rebuild_method"
          ],
          "base_classes": [],
          "lineno": 106,
          "docstring": null
        },
        {
          "name": "Session",
          "methods": [
            "__init__",
            "__enter__",
            "__exit__",
            "prepare_request",
            "request",
            "get",
            "options",
            "head",
            "post",
            "put",
            "patch",
            "delete",
            "send",
            "merge_environment_settings",
            "get_adapter",
            "close",
            "mount",
            "__getstate__",
            "__setstate__"
          ],
          "base_classes": [
            "SessionRedirectMixin"
          ],
          "lineno": 356,
          "docstring": "A Requests session.\n\nProvides cookie persistence, connection-pooling, and configuration.\n\nBasic Usage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> s.get('https://httpbin.org/get')\n  <Response [200]>\n\nOr as a context manager::\n\n  >>> with requests.Session() as s:\n  ...     s.get('https://httpbin.org/get')\n  <Response [200]>"
        }
      ],
      "imports": [
        {
          "module": "os",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "time",
          "alias": null,
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "collections",
          "name": "OrderedDict",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "datetime",
          "name": "timedelta",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "_internal_utils",
          "name": "to_native_string",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "adapters",
          "name": "HTTPAdapter",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "auth",
          "name": "_basic_auth_str",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "Mapping",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "cookielib",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urljoin",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlparse",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "RequestsCookieJar",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "cookiejar_from_dict",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "extract_cookies_to_jar",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "merge_cookies",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ChunkedEncodingError",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "ContentDecodingError",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidSchema",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "TooManyRedirects",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "hooks",
          "name": "default_hooks",
          "alias": null,
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "hooks",
          "name": "dispatch_hook",
          "alias": null,
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "DEFAULT_REDIRECT_LIMIT",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "REDIRECT_STATI",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "PreparedRequest",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "models",
          "name": "Request",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "status_codes",
          "name": "codes",
          "alias": null,
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "structures",
          "name": "CaseInsensitiveDict",
          "alias": null,
          "lineno": 40,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "DEFAULT_PORTS",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "default_headers",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_auth_from_url",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_environ_proxies",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "get_netrc_auth",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "requote_uri",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "resolve_proxies",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "rewind_body",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "should_bypass_proxies",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "utils",
          "name": "to_key_val_list",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "time.perf_counter",
          "time.time"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "sys",
          "datetime",
          "collections",
          "time",
          "os"
        ],
        "third_party": {
          "other": [
            "_internal_utils",
            "adapters",
            "auth",
            "compat",
            "cookies",
            "exceptions",
            "hooks",
            "models",
            "status_codes",
            "structures",
            "utils"
          ]
        },
        "tech_stack": []
      },
      "line_count": 832
    },
    "src/requests/status_codes.py": {
      "filepath": "../requests/src/requests/status_codes.py",
      "module_docstring": "The ``codes`` object defines a mapping from common names for HTTP statuses\nto their numerical codes, accessible either as attributes or as dictionary\nitems.\n\nExample::\n\n    >>> import requests\n    >>> requests.codes['temporary_redirect']\n    307\n    >>> requests.codes.teapot\n    418\n    >>> requests.codes['\\o/']\n    200\n\nSome codes have multiple names, and both upper- and lower-case versions of\nthe names are allowed. For example, ``codes.ok``, ``codes.OK``, and\n``codes.okay`` all correspond to the HTTP status code 200.",
      "functions": [
        {
          "name": "_init",
          "args": [],
          "return_type": null,
          "lineno": 109,
          "decorators": [],
          "is_async": false,
          "calls": [
            "title.upper",
            "_codes",
            "doc",
            "code",
            "_codes.items",
            "title",
            "codes",
            "unknown.join",
            "setattr",
            "sorted",
            "title.startswith"
          ],
          "docstring": null,
          "code": "def _init():\n    for code, titles in _codes.items():\n        for title in titles:\n            setattr(codes, title, code)\n            if not title.startswith((\"\\\\\", \"/\")):\n                setattr(codes, title.upper(), code)\n\n    def doc(code):\n        names = \", \".join(f\"``{n}``\" for n in _codes[code])\n        return \"* %d: %s\" % (code, names)\n\n    global __doc__\n    __doc__ = (\n        __doc__ + \"\\n\" + \"\\n\".join(doc(code) for code in sorted(_codes))\n        if __doc__ is not None\n        else None\n    )",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "doc",
          "args": [
            {
              "name": "code"
            }
          ],
          "return_type": null,
          "lineno": 116,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.join"
          ],
          "docstring": null,
          "code": "def doc(code):\n        names = \", \".join(f\"``{n}``\" for n in _codes[code])\n        return \"* %d: %s\" % (code, names)",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "structures",
          "name": "LookupDict",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "_codes",
          "assigned_to": null,
          "lineno": 23
        },
        {
          "name": "codes",
          "assigned_to": "LookupDict",
          "lineno": 106
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "LookupDict",
          "_init"
        ],
        "class_instantiations": [
          "LookupDict"
        ]
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "structures"
          ]
        },
        "tech_stack": []
      },
      "line_count": 129
    },
    "src/requests/structures.py": {
      "filepath": "../requests/src/requests/structures.py",
      "module_docstring": "requests.structures\n~~~~~~~~~~~~~~~~~~~\n\nData structures that power Requests.",
      "functions": [
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "data"
            }
          ],
          "return_type": null,
          "lineno": 40,
          "decorators": [],
          "is_async": false,
          "calls": [
            "data",
            "OrderedDict",
            "kwargs",
            "self.update"
          ],
          "docstring": null,
          "code": "def __init__(self, data=None, **kwargs):\n        self._store = OrderedDict()\n        if data is None:\n            data = {}\n        self.update(data, **kwargs)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__setitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 46,
          "decorators": [],
          "is_async": false,
          "calls": [
            "key.lower"
          ],
          "docstring": null,
          "code": "def __setitem__(self, key, value):\n        # Use the lowercased key for lookups, but store the actual\n        # key alongside the value.\n        self._store[key.lower()] = (key, value)",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "__getitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key"
            }
          ],
          "return_type": null,
          "lineno": 51,
          "decorators": [],
          "is_async": false,
          "calls": [
            "key.lower"
          ],
          "docstring": null,
          "code": "def __getitem__(self, key):\n        return self._store[key.lower()][1]",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__delitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key"
            }
          ],
          "return_type": null,
          "lineno": 54,
          "decorators": [],
          "is_async": false,
          "calls": [
            "key.lower"
          ],
          "docstring": null,
          "code": "def __delitem__(self, key):\n        del self._store[key.lower()]",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__iter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 57,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._store.values"
          ],
          "docstring": null,
          "code": "def __iter__(self):\n        return (casedkey for casedkey, mappedvalue in self._store.values())",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__len__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 60,
          "decorators": [],
          "is_async": false,
          "calls": [
            "len",
            "self._store"
          ],
          "docstring": null,
          "code": "def __len__(self):\n        return len(self._store)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "lower_items",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 63,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._store.items"
          ],
          "docstring": "Like iteritems(), but with all lowercase keys.",
          "code": "def lower_items(self):\n        \"\"\"Like iteritems(), but with all lowercase keys.\"\"\"\n        return ((lowerkey, keyval[1]) for (lowerkey, keyval) in self._store.items())",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__eq__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "other"
            }
          ],
          "return_type": null,
          "lineno": 67,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "other",
            "Mapping",
            "CaseInsensitiveDict",
            "self.lower_items",
            "other.lower_items",
            "dict"
          ],
          "docstring": null,
          "code": "def __eq__(self, other):\n        if isinstance(other, Mapping):\n            other = CaseInsensitiveDict(other)\n        else:\n            return NotImplemented\n        # Compare insensitively\n        return dict(self.lower_items()) == dict(other.lower_items())",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "copy",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 76,
          "decorators": [],
          "is_async": false,
          "calls": [
            "CaseInsensitiveDict",
            "self._store.values"
          ],
          "docstring": null,
          "code": "def copy(self):\n        return CaseInsensitiveDict(self._store.values())",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 79,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.items",
            "dict",
            "str"
          ],
          "docstring": null,
          "code": "def __repr__(self):\n        return str(dict(self.items()))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 86,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "name",
            "super"
          ],
          "docstring": null,
          "code": "def __init__(self, name=None):\n        self.name = name\n        super().__init__()",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "lineno": 90,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __repr__(self):\n        return f\"<lookup '{self.name}'>\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__getitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key"
            }
          ],
          "return_type": null,
          "lineno": 93,
          "decorators": [],
          "is_async": false,
          "calls": [
            "key",
            "self.__dict__.get"
          ],
          "docstring": null,
          "code": "def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n\n        return self.__dict__.get(key, None)",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "get",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key"
            },
            {
              "name": "default"
            }
          ],
          "return_type": null,
          "lineno": 98,
          "decorators": [],
          "is_async": false,
          "calls": [
            "key",
            "default",
            "self.__dict__.get"
          ],
          "docstring": null,
          "code": "def get(self, key, default=None):\n        return self.__dict__.get(key, default)",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "CaseInsensitiveDict",
          "methods": [
            "__init__",
            "__setitem__",
            "__getitem__",
            "__delitem__",
            "__iter__",
            "__len__",
            "lower_items",
            "__eq__",
            "copy",
            "__repr__"
          ],
          "base_classes": [
            "MutableMapping"
          ],
          "lineno": 13,
          "docstring": "A case-insensitive ``dict``-like object.\n\nImplements all methods and operations of\n``MutableMapping`` as well as dict's ``copy``. Also\nprovides ``lower_items``.\n\nAll keys are expected to be strings. The structure remembers the\ncase of the last key to be set, and ``iter(instance)``,\n``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``\nwill contain case-sensitive keys. However, querying and contains\ntesting is case insensitive::\n\n    cid = CaseInsensitiveDict()\n    cid['Accept'] = 'application/json'\n    cid['aCCEPT'] == 'application/json'  # True\n    list(cid) == ['Accept']  # True\n\nFor example, ``headers['content-encoding']`` will return the\nvalue of a ``'Content-Encoding'`` response header, regardless\nof how the header name was originally stored.\n\nIf the constructor, ``.update``, or equality comparison\noperations are given keys that have equal ``.lower()``s, the\nbehavior is undefined."
        },
        {
          "name": "LookupDict",
          "methods": [
            "__init__",
            "__repr__",
            "__getitem__",
            "get"
          ],
          "base_classes": [
            "dict"
          ],
          "lineno": 83,
          "docstring": "Dictionary lookup object."
        }
      ],
      "imports": [
        {
          "module": "collections",
          "name": "OrderedDict",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "Mapping",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "MutableMapping",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "collections"
        ],
        "third_party": {
          "other": [
            "compat"
          ]
        },
        "tech_stack": []
      },
      "line_count": 100
    },
    "src/requests/utils.py": {
      "filepath": "../requests/src/requests/utils.py",
      "module_docstring": "requests.utils\n~~~~~~~~~~~~~~\n\nThis module provides utility functions that are used within Requests\nthat are also useful for external consumption.",
      "functions": [
        {
          "name": "dict_to_sequence",
          "args": [
            {
              "name": "d"
            }
          ],
          "return_type": null,
          "lineno": 127,
          "decorators": [],
          "is_async": false,
          "calls": [
            "d",
            "d.items",
            "hasattr"
          ],
          "docstring": "Returns an internal sequence dictionary update.",
          "code": "def dict_to_sequence(d):\n    \"\"\"Returns an internal sequence dictionary update.\"\"\"\n\n    if hasattr(d, \"items\"):\n        d = d.items()\n\n    return d",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "super_len",
          "args": [
            {
              "name": "o"
            }
          ],
          "return_type": null,
          "lineno": 136,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "len",
            "os.fstat",
            "o.len",
            "o.seek",
            "str",
            "max",
            "total_length",
            "unknown.st_size",
            "warnings.warn",
            "fileno",
            "hasattr",
            "o",
            "o.encode",
            "FileModeWarning",
            "o.fileno",
            "o.tell"
          ],
          "docstring": null,
          "code": "def super_len(o):\n    total_length = None\n    current_position = 0\n\n    if not is_urllib3_1 and isinstance(o, str):\n        # urllib3 2.x+ treats all strings as utf-8 instead\n        # of latin-1 (iso-8859-1) like http.client.\n        o = o.encode(\"utf-8\")\n\n    if hasattr(o, \"__len__\"):\n        total_length = len(o)\n\n    elif hasattr(o, \"len\"):\n        total_length = o.len\n\n    elif hasattr(o, \"fileno\"):\n        try:\n            fileno = o.fileno()\n        except (io.UnsupportedOperation, AttributeError):\n            # AttributeError is a surprising exception, seeing as how we've just checked\n            # that `hasattr(o, 'fileno')`.  It happens for objects obtained via\n            # `Tarfile.extractfile()`, per issue 5229.\n            pass\n        else:\n            total_length = os.fstat(fileno).st_size\n\n            # Having used fstat to determine the file length, we need to\n            # confirm that this file was opened up in binary mode.\n            if \"b\" not in o.mode:\n                warnings.warn(\n                    (\n                        \"Requests has determined the content-length for this \"\n                        \"request using the binary size of the file: however, the \"\n                        \"file has been opened in text mode (i.e. without the 'b' \"\n                        \"flag in the mode). This may lead to an incorrect \"\n                        \"content-length. In Requests 3.0, support will be removed \"\n                        \"for files in text mode.\"\n                    ),\n                    FileModeWarning,\n                )\n\n    if hasattr(o, \"tell\"):\n        try:\n            current_position = o.tell()\n        except OSError:\n            # This can happen in some weird situations, such as when the file\n            # is actually a special file descriptor like stdin. In this\n            # instance, we don't know what the length is, so set it to zero and\n            # let requests chunk it instead.\n            if total_length is not None:\n                current_position = total_length\n        else:\n            if hasattr(o, \"seek\") and total_length is None:\n                # StringIO and BytesIO have seek but no usable fileno\n                try:\n                    # seek to end of file\n                    o.seek(0, 2)\n                    total_length = o.tell()\n\n                    # seek back to current position to support\n                    # partially read file-like objects\n                    o.seek(current_position or 0)\n                except OSError:\n                    total_length = 0\n\n    if total_length is None:\n        total_length = 0\n\n    return max(0, total_length - current_position)",
          "line_count": 69,
          "needs_llm_summary": true
        },
        {
          "name": "get_netrc_auth",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "raise_errors"
            }
          ],
          "return_type": null,
          "lineno": 207,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.path.expanduser",
            "netrc",
            "loc",
            "netrc_path",
            "url",
            "f",
            "os.environ.get",
            "os.path.exists",
            "urlparse",
            "ri.hostname",
            "host",
            "unknown.authenticators"
          ],
          "docstring": "Returns the Requests tuple auth for a given url from netrc.",
          "code": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get(\"NETRC\")\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n        netrc_locations = (f\"~/{f}\" for f in NETRC_FILES)\n\n    try:\n        from netrc import NetrcParseError, netrc\n\n        netrc_path = None\n\n        for f in netrc_locations:\n            loc = os.path.expanduser(f)\n            if os.path.exists(loc):\n                netrc_path = loc\n                break\n\n        # Abort early if there isn't one.\n        if netrc_path is None:\n            return\n\n        ri = urlparse(url)\n        host = ri.hostname\n\n        try:\n            _netrc = netrc(netrc_path).authenticators(host)\n            if _netrc:\n                # Return with login / password\n                login_i = 0 if _netrc[0] else 1\n                return (_netrc[login_i], _netrc[2])\n        except (NetrcParseError, OSError):\n            # If there was a parsing error or a permissions issue reading the file,\n            # we'll just skip netrc auth unless explicitly asked to raise errors.\n            if raise_errors:\n                raise\n\n    # App Engine hackiness.\n    except (ImportError, AttributeError):\n        pass",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "guess_filename",
          "args": [
            {
              "name": "obj"
            }
          ],
          "return_type": null,
          "lineno": 251,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "basestring",
            "os.path.basename",
            "obj",
            "name",
            "getattr"
          ],
          "docstring": "Tries to guess the filename of the given object.",
          "code": "def guess_filename(obj):\n    \"\"\"Tries to guess the filename of the given object.\"\"\"\n    name = getattr(obj, \"name\", None)\n    if name and isinstance(name, basestring) and name[0] != \"<\" and name[-1] != \">\":\n        return os.path.basename(name)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "extract_zipped_paths",
          "args": [
            {
              "name": "path"
            }
          ],
          "return_type": null,
          "lineno": 258,
          "decorators": [],
          "is_async": false,
          "calls": [
            "archive",
            "tempfile.gettempdir",
            "atomic_open",
            "tmp",
            "zip_file.read",
            "path",
            "zipfile.ZipFile",
            "member.split",
            "os.path.exists",
            "zipfile.is_zipfile",
            "file_handler.write",
            "os.path.split",
            "os.path.join",
            "extracted_path",
            "unknown.join",
            "zip_file.namelist",
            "member"
          ],
          "docstring": "Replace nonexistent paths that look like they refer to a member of a zip\narchive with the location of an extracted copy of the target, or else\njust return the provided path unchanged.",
          "code": "def extract_zipped_paths(path):\n    \"\"\"Replace nonexistent paths that look like they refer to a member of a zip\n    archive with the location of an extracted copy of the target, or else\n    just return the provided path unchanged.\n    \"\"\"\n    if os.path.exists(path):\n        # this is already a valid path, no need to do anything further\n        return path\n\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive\n    archive, member = os.path.split(path)\n    while archive and not os.path.exists(archive):\n        archive, prefix = os.path.split(archive)\n        if not prefix:\n            # If we don't check for an empty prefix after the split (in other words, archive remains unchanged after the split),\n            # we _can_ end up in an infinite loop on a rare corner case affecting a small number of users\n            break\n        member = \"/\".join([prefix, member])\n\n    if not zipfile.is_zipfile(archive):\n        return path\n\n    zip_file = zipfile.ZipFile(archive)\n    if member not in zip_file.namelist():\n        return path\n\n    # we have a valid zip archive and a valid member of that archive\n    tmp = tempfile.gettempdir()\n    extracted_path = os.path.join(tmp, member.split(\"/\")[-1])\n    if not os.path.exists(extracted_path):\n        # use read + write to avoid the creating nested folders, we only want the file, avoids mkdir racing condition\n        with atomic_open(extracted_path) as file_handler:\n            file_handler.write(zip_file.read(member))\n    return extracted_path",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "atomic_open",
          "args": [
            {
              "name": "filename"
            }
          ],
          "return_type": null,
          "lineno": 296,
          "decorators": [
            {
              "name": "contextlib.contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "tempfile.mkstemp",
            "os.path.dirname",
            "os.remove",
            "tmp_name",
            "os.fdopen",
            "os.replace",
            "tmp_descriptor",
            "filename"
          ],
          "docstring": "Write a file to the disk in an atomic fashion",
          "code": "def atomic_open(filename):\n    \"\"\"Write a file to the disk in an atomic fashion\"\"\"\n    tmp_descriptor, tmp_name = tempfile.mkstemp(dir=os.path.dirname(filename))\n    try:\n        with os.fdopen(tmp_descriptor, \"wb\") as tmp_handler:\n            yield tmp_handler\n        os.replace(tmp_name, filename)\n    except BaseException:\n        os.remove(tmp_name)\n        raise",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "from_key_val_list",
          "args": [
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 308,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "OrderedDict",
            "ValueError",
            "value"
          ],
          "docstring": "Take an object and test to see if it can be represented as a\ndictionary. Unless it can not be represented as such, return an\nOrderedDict, e.g.,\n\n::\n\n    >>> from_key_val_list([('key', 'val')])\n    OrderedDict([('key', 'val')])\n    >>> from_key_val_list('string')\n    Traceback (most recent call last):\n    ...\n    ValueError: cannot encode objects that are not 2-tuples\n    >>> from_key_val_list({'key': 'val'})\n    OrderedDict([('key', 'val')])\n\n:rtype: OrderedDict",
          "code": "def from_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. Unless it can not be represented as such, return an\n    OrderedDict, e.g.,\n\n    ::\n\n        >>> from_key_val_list([('key', 'val')])\n        OrderedDict([('key', 'val')])\n        >>> from_key_val_list('string')\n        Traceback (most recent call last):\n        ...\n        ValueError: cannot encode objects that are not 2-tuples\n        >>> from_key_val_list({'key': 'val'})\n        OrderedDict([('key', 'val')])\n\n    :rtype: OrderedDict\n    \"\"\"\n    if value is None:\n        return None\n\n    if isinstance(value, (str, bytes, bool, int)):\n        raise ValueError(\"cannot encode objects that are not 2-tuples\")\n\n    return OrderedDict(value)",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "to_key_val_list",
          "args": [
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 335,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "list",
            "Mapping",
            "ValueError",
            "value",
            "value.items"
          ],
          "docstring": "Take an object and test to see if it can be represented as a\ndictionary. If it can be, return a list of tuples, e.g.,\n\n::\n\n    >>> to_key_val_list([('key', 'val')])\n    [('key', 'val')]\n    >>> to_key_val_list({'key': 'val'})\n    [('key', 'val')]\n    >>> to_key_val_list('string')\n    Traceback (most recent call last):\n    ...\n    ValueError: cannot encode objects that are not 2-tuples\n\n:rtype: list",
          "code": "def to_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. If it can be, return a list of tuples, e.g.,\n\n    ::\n\n        >>> to_key_val_list([('key', 'val')])\n        [('key', 'val')]\n        >>> to_key_val_list({'key': 'val'})\n        [('key', 'val')]\n        >>> to_key_val_list('string')\n        Traceback (most recent call last):\n        ...\n        ValueError: cannot encode objects that are not 2-tuples\n\n    :rtype: list\n    \"\"\"\n    if value is None:\n        return None\n\n    if isinstance(value, (str, bytes, bool, int)):\n        raise ValueError(\"cannot encode objects that are not 2-tuples\")\n\n    if isinstance(value, Mapping):\n        value = value.items()\n\n    return list(value)",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "parse_list_header",
          "args": [
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 365,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unquote_header_value",
            "item",
            "result.append",
            "value",
            "_parse_list_header"
          ],
          "docstring": "Parse lists as described by RFC 2068 Section 2.\n\nIn particular, parse comma-separated lists where the elements of\nthe list may include quoted-strings.  A quoted-string could\ncontain a comma.  A non-quoted string could have quotes in the\nmiddle.  Quotes are removed automatically after parsing.\n\nIt basically works like :func:`parse_set_header` just that items\nmay appear multiple times and case sensitivity is preserved.\n\nThe return value is a standard :class:`list`:\n\n>>> parse_list_header('token, \"quoted value\"')\n['token', 'quoted value']\n\nTo create a header from the :class:`list` again, use the\n:func:`dump_header` function.\n\n:param value: a string with a list header.\n:return: :class:`list`\n:rtype: list",
          "code": "def parse_list_header(value):\n    \"\"\"Parse lists as described by RFC 2068 Section 2.\n\n    In particular, parse comma-separated lists where the elements of\n    the list may include quoted-strings.  A quoted-string could\n    contain a comma.  A non-quoted string could have quotes in the\n    middle.  Quotes are removed automatically after parsing.\n\n    It basically works like :func:`parse_set_header` just that items\n    may appear multiple times and case sensitivity is preserved.\n\n    The return value is a standard :class:`list`:\n\n    >>> parse_list_header('token, \"quoted value\"')\n    ['token', 'quoted value']\n\n    To create a header from the :class:`list` again, use the\n    :func:`dump_header` function.\n\n    :param value: a string with a list header.\n    :return: :class:`list`\n    :rtype: list\n    \"\"\"\n    result = []\n    for item in _parse_list_header(value):\n        if item[:1] == item[-1:] == '\"':\n            item = unquote_header_value(item[1:-1])\n        result.append(item)\n    return result",
          "line_count": 29,
          "needs_llm_summary": true
        },
        {
          "name": "parse_dict_header",
          "args": [
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 397,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unquote_header_value",
            "item.split",
            "value",
            "_parse_list_header"
          ],
          "docstring": "Parse lists of key, value pairs as described by RFC 2068 Section 2 and\nconvert them into a python dict:\n\n>>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n>>> type(d) is dict\nTrue\n>>> sorted(d.items())\n[('bar', 'as well'), ('foo', 'is a fish')]\n\nIf there is no value for a key it will be `None`:\n\n>>> parse_dict_header('key_without_value')\n{'key_without_value': None}\n\nTo create a header from the :class:`dict` again, use the\n:func:`dump_header` function.\n\n:param value: a string with a dict header.\n:return: :class:`dict`\n:rtype: dict",
          "code": "def parse_dict_header(value):\n    \"\"\"Parse lists of key, value pairs as described by RFC 2068 Section 2 and\n    convert them into a python dict:\n\n    >>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n    >>> type(d) is dict\n    True\n    >>> sorted(d.items())\n    [('bar', 'as well'), ('foo', 'is a fish')]\n\n    If there is no value for a key it will be `None`:\n\n    >>> parse_dict_header('key_without_value')\n    {'key_without_value': None}\n\n    To create a header from the :class:`dict` again, use the\n    :func:`dump_header` function.\n\n    :param value: a string with a dict header.\n    :return: :class:`dict`\n    :rtype: dict\n    \"\"\"\n    result = {}\n    for item in _parse_list_header(value):\n        if \"=\" not in item:\n            result[item] = None\n            continue\n        name, value = item.split(\"=\", 1)\n        if value[:1] == value[-1:] == '\"':\n            value = unquote_header_value(value[1:-1])\n        result[name] = value\n    return result",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "unquote_header_value",
          "args": [
            {
              "name": "value"
            },
            {
              "name": "is_filename"
            }
          ],
          "return_type": null,
          "lineno": 432,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.replace",
            "value.replace"
          ],
          "docstring": "Unquotes a header value.  (Reversal of :func:`quote_header_value`).\nThis does not use the real unquoting but what browsers are actually\nusing for quoting.\n\n:param value: the header value to unquote.\n:rtype: str",
          "code": "def unquote_header_value(value, is_filename=False):\n    r\"\"\"Unquotes a header value.  (Reversal of :func:`quote_header_value`).\n    This does not use the real unquoting but what browsers are actually\n    using for quoting.\n\n    :param value: the header value to unquote.\n    :rtype: str\n    \"\"\"\n    if value and value[0] == value[-1] == '\"':\n        # this is not the real unquoting, but fixing this so that the\n        # RFC is met will result in bugs with internet explorer and\n        # probably some other browsers as well.  IE for example is\n        # uploading files with \"C:\\foo\\bar.txt\" as filename\n        value = value[1:-1]\n\n        # if this is a filename and the starting characters look like\n        # a UNC path, then just return the value without quotes.  Using the\n        # replace sequence below on a UNC path has the effect of turning\n        # the leading double slash into a single slash and then\n        # _fix_ie_filename() doesn't work correctly.  See #458.\n        if not is_filename or value[:2] != \"\\\\\\\\\":\n            return value.replace(\"\\\\\\\\\", \"\\\\\").replace('\\\\\"', '\"')\n    return value",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "dict_from_cookiejar",
          "args": [
            {
              "name": "cj"
            }
          ],
          "return_type": null,
          "lineno": 457,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Returns a key/value dictionary from a CookieJar.\n\n:param cj: CookieJar object to extract cookies from.\n:rtype: dict",
          "code": "def dict_from_cookiejar(cj):\n    \"\"\"Returns a key/value dictionary from a CookieJar.\n\n    :param cj: CookieJar object to extract cookies from.\n    :rtype: dict\n    \"\"\"\n\n    cookie_dict = {cookie.name: cookie.value for cookie in cj}\n    return cookie_dict",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "add_dict_to_cookiejar",
          "args": [
            {
              "name": "cj"
            },
            {
              "name": "cookie_dict"
            }
          ],
          "return_type": null,
          "lineno": 468,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cj",
            "cookie_dict",
            "cookiejar_from_dict"
          ],
          "docstring": "Returns a CookieJar from a key/value dictionary.\n\n:param cj: CookieJar to insert cookies into.\n:param cookie_dict: Dict of key/values to insert into CookieJar.\n:rtype: CookieJar",
          "code": "def add_dict_to_cookiejar(cj, cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n\n    :param cj: CookieJar to insert cookies into.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :rtype: CookieJar\n    \"\"\"\n\n    return cookiejar_from_dict(cookie_dict, cj)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "get_encodings_from_content",
          "args": [
            {
              "name": "content"
            }
          ],
          "return_type": null,
          "lineno": 479,
          "decorators": [],
          "is_async": false,
          "calls": [
            "re.compile",
            "pragma_re.findall",
            "DeprecationWarning",
            "re.I",
            "warnings.warn",
            "xml_re.findall",
            "charset_re.findall",
            "content"
          ],
          "docstring": "Returns encodings from given content string.\n\n:param content: bytestring to extract encodings from.",
          "code": "def get_encodings_from_content(content):\n    \"\"\"Returns encodings from given content string.\n\n    :param content: bytestring to extract encodings from.\n    \"\"\"\n    warnings.warn(\n        (\n            \"In requests 3.0, get_encodings_from_content will be removed. For \"\n            \"more information, please see the discussion on issue #2266. (This\"\n            \" warning should only appear once.)\"\n        ),\n        DeprecationWarning,\n    )\n\n    charset_re = re.compile(r'<meta.*?charset=[\"\\']*(.+?)[\"\\'>]', flags=re.I)\n    pragma_re = re.compile(r'<meta.*?content=[\"\\']*;?charset=(.+?)[\"\\'>]', flags=re.I)\n    xml_re = re.compile(r'^<\\?xml.*?encoding=[\"\\']*(.+?)[\"\\'>]')\n\n    return (\n        charset_re.findall(content)\n        + pragma_re.findall(content)\n        + xml_re.findall(content)\n    )",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "_parse_content_type_header",
          "args": [
            {
              "name": "header"
            }
          ],
          "return_type": null,
          "lineno": 504,
          "decorators": [],
          "is_async": false,
          "calls": [
            "key.lower",
            "param.find",
            "items_to_strip",
            "value",
            "header.split",
            "unknown.strip",
            "param.strip"
          ],
          "docstring": "Returns content type and parameters from given header\n\n:param header: string\n:return: tuple containing content type and dictionary of\n     parameters",
          "code": "def _parse_content_type_header(header):\n    \"\"\"Returns content type and parameters from given header\n\n    :param header: string\n    :return: tuple containing content type and dictionary of\n         parameters\n    \"\"\"\n\n    tokens = header.split(\";\")\n    content_type, params = tokens[0].strip(), tokens[1:]\n    params_dict = {}\n    items_to_strip = \"\\\"' \"\n\n    for param in params:\n        param = param.strip()\n        if param:\n            key, value = param, True\n            index_of_equals = param.find(\"=\")\n            if index_of_equals != -1:\n                key = param[:index_of_equals].strip(items_to_strip)\n                value = param[index_of_equals + 1 :].strip(items_to_strip)\n            params_dict[key.lower()] = value\n    return content_type, params_dict",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "get_encoding_from_headers",
          "args": [
            {
              "name": "headers"
            }
          ],
          "return_type": null,
          "lineno": 529,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_parse_content_type_header",
            "unknown.strip",
            "content_type",
            "headers.get"
          ],
          "docstring": "Returns encodings from given HTTP Header Dict.\n\n:param headers: dictionary to extract encoding from.\n:rtype: str",
          "code": "def get_encoding_from_headers(headers):\n    \"\"\"Returns encodings from given HTTP Header Dict.\n\n    :param headers: dictionary to extract encoding from.\n    :rtype: str\n    \"\"\"\n\n    content_type = headers.get(\"content-type\")\n\n    if not content_type:\n        return None\n\n    content_type, params = _parse_content_type_header(content_type)\n\n    if \"charset\" in params:\n        return params[\"charset\"].strip(\"'\\\"\")\n\n    if \"text\" in content_type:\n        return \"ISO-8859-1\"\n\n    if \"application/json\" in content_type:\n        # Assume UTF-8 based on RFC 4627: https://www.ietf.org/rfc/rfc4627.txt since the charset was unset\n        return \"utf-8\"",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "stream_decode_response_unicode",
          "args": [
            {
              "name": "iterator"
            },
            {
              "name": "r"
            }
          ],
          "return_type": null,
          "lineno": 554,
          "decorators": [],
          "is_async": false,
          "calls": [
            "chunk",
            "decoder.decode",
            "codecs.getincrementaldecoder",
            "r.encoding"
          ],
          "docstring": "Stream decodes an iterator.",
          "code": "def stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes an iterator.\"\"\"\n\n    if r.encoding is None:\n        yield from iterator\n        return\n\n    decoder = codecs.getincrementaldecoder(r.encoding)(errors=\"replace\")\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b\"\", final=True)\n    if rv:\n        yield rv",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "iter_slices",
          "args": [
            {
              "name": "string"
            },
            {
              "name": "slice_length"
            }
          ],
          "return_type": null,
          "lineno": 571,
          "decorators": [],
          "is_async": false,
          "calls": [
            "string",
            "len"
          ],
          "docstring": "Iterate over slices of a string.",
          "code": "def iter_slices(string, slice_length):\n    \"\"\"Iterate over slices of a string.\"\"\"\n    pos = 0\n    if slice_length is None or slice_length <= 0:\n        slice_length = len(string)\n    while pos < len(string):\n        yield string[pos : pos + slice_length]\n        pos += slice_length",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "get_unicode_from_response",
          "args": [
            {
              "name": "r"
            }
          ],
          "return_type": null,
          "lineno": 581,
          "decorators": [],
          "is_async": false,
          "calls": [
            "get_encoding_from_headers",
            "encoding",
            "DeprecationWarning",
            "r.content",
            "str",
            "tried_encodings.append",
            "warnings.warn",
            "r.headers"
          ],
          "docstring": "Returns the requested content back in unicode.\n\n:param r: Response object to get unicode content from.\n\nTried:\n\n1. charset from content-type\n2. fall back and replace all unicode characters\n\n:rtype: str",
          "code": "def get_unicode_from_response(r):\n    \"\"\"Returns the requested content back in unicode.\n\n    :param r: Response object to get unicode content from.\n\n    Tried:\n\n    1. charset from content-type\n    2. fall back and replace all unicode characters\n\n    :rtype: str\n    \"\"\"\n    warnings.warn(\n        (\n            \"In requests 3.0, get_unicode_from_response will be removed. For \"\n            \"more information, please see the discussion on issue #2266. (This\"\n            \" warning should only appear once.)\"\n        ),\n        DeprecationWarning,\n    )\n\n    tried_encodings = []\n\n    # Try charset from content-type\n    encoding = get_encoding_from_headers(r.headers)\n\n    if encoding:\n        try:\n            return str(r.content, encoding)\n        except UnicodeError:\n            tried_encodings.append(encoding)\n\n    # Fall back:\n    try:\n        return str(r.content, encoding, errors=\"replace\")\n    except TypeError:\n        return r.content",
          "line_count": 37,
          "needs_llm_summary": true
        },
        {
          "name": "unquote_unreserved",
          "args": [
            {
              "name": "uri"
            }
          ],
          "return_type": null,
          "lineno": 626,
          "decorators": [],
          "is_async": false,
          "calls": [
            "len",
            "InvalidURL",
            "uri.split",
            "h.isalnum",
            "h",
            "chr",
            "range",
            "int",
            "parts",
            "unknown.join"
          ],
          "docstring": "Un-escape any percent-escape sequences in a URI that are unreserved\ncharacters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n\n:rtype: str",
          "code": "def unquote_unreserved(uri):\n    \"\"\"Un-escape any percent-escape sequences in a URI that are unreserved\n    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.\n\n    :rtype: str\n    \"\"\"\n    parts = uri.split(\"%\")\n    for i in range(1, len(parts)):\n        h = parts[i][0:2]\n        if len(h) == 2 and h.isalnum():\n            try:\n                c = chr(int(h, 16))\n            except ValueError:\n                raise InvalidURL(f\"Invalid percent-escape sequence: '{h}'\")\n\n            if c in UNRESERVED_SET:\n                parts[i] = c + parts[i][2:]\n            else:\n                parts[i] = f\"%{parts[i]}\"\n        else:\n            parts[i] = f\"%{parts[i]}\"\n    return \"\".join(parts)",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "requote_uri",
          "args": [
            {
              "name": "uri"
            }
          ],
          "return_type": null,
          "lineno": 650,
          "decorators": [],
          "is_async": false,
          "calls": [
            "safe_with_percent",
            "unquote_unreserved",
            "quote",
            "uri",
            "safe_without_percent"
          ],
          "docstring": "Re-quote the given URI.\n\nThis function passes the given URI through an unquote/quote cycle to\nensure that it is fully and consistently quoted.\n\n:rtype: str",
          "code": "def requote_uri(uri):\n    \"\"\"Re-quote the given URI.\n\n    This function passes the given URI through an unquote/quote cycle to\n    ensure that it is fully and consistently quoted.\n\n    :rtype: str\n    \"\"\"\n    safe_with_percent = \"!#$%&'()*+,/:;=?@[]~\"\n    safe_without_percent = \"!#$&'()*+,/:;=?@[]~\"\n    try:\n        # Unquote only the unreserved characters\n        # Then quote only illegal characters (do not quote reserved,\n        # unreserved, or '%')\n        return quote(unquote_unreserved(uri), safe=safe_with_percent)\n    except InvalidURL:\n        # We couldn't unquote the given URI, so let's try quoting it, but\n        # there may be unquoted '%'s in the URI. We need to make sure they're\n        # properly quoted so they do not cause issues elsewhere.\n        return quote(uri, safe=safe_without_percent)",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "address_in_network",
          "args": [
            {
              "name": "ip"
            },
            {
              "name": "net"
            }
          ],
          "return_type": null,
          "lineno": 672,
          "decorators": [],
          "is_async": false,
          "calls": [
            "struct.unpack",
            "bits",
            "dotted_netmask",
            "ip",
            "netaddr",
            "net.split",
            "socket.inet_aton",
            "int"
          ],
          "docstring": "This function allows you to check if an IP belongs to a network subnet\n\nExample: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n         returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n:rtype: bool",
          "code": "def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n    \"\"\"\n    ipaddr = struct.unpack(\"=L\", socket.inet_aton(ip))[0]\n    netaddr, bits = net.split(\"/\")\n    netmask = struct.unpack(\"=L\", socket.inet_aton(dotted_netmask(int(bits))))[0]\n    network = struct.unpack(\"=L\", socket.inet_aton(netaddr))[0] & netmask\n    return (ipaddr & netmask) == (network & netmask)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "dotted_netmask",
          "args": [
            {
              "name": "mask"
            }
          ],
          "return_type": null,
          "lineno": 687,
          "decorators": [],
          "is_async": false,
          "calls": [
            "socket.inet_ntoa",
            "bits",
            "struct.pack"
          ],
          "docstring": "Converts mask from /xx format to xxx.xxx.xxx.xxx\n\nExample: if mask is 24 function returns 255.255.255.0\n\n:rtype: str",
          "code": "def dotted_netmask(mask):\n    \"\"\"Converts mask from /xx format to xxx.xxx.xxx.xxx\n\n    Example: if mask is 24 function returns 255.255.255.0\n\n    :rtype: str\n    \"\"\"\n    bits = 0xFFFFFFFF ^ (1 << 32 - mask) - 1\n    return socket.inet_ntoa(struct.pack(\">I\", bits))",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "is_ipv4_address",
          "args": [
            {
              "name": "string_ip"
            }
          ],
          "return_type": null,
          "lineno": 698,
          "decorators": [],
          "is_async": false,
          "calls": [
            "socket.inet_aton",
            "string_ip"
          ],
          "docstring": ":rtype: bool",
          "code": "def is_ipv4_address(string_ip):\n    \"\"\"\n    :rtype: bool\n    \"\"\"\n    try:\n        socket.inet_aton(string_ip)\n    except OSError:\n        return False\n    return True",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "is_valid_cidr",
          "args": [
            {
              "name": "string_network"
            }
          ],
          "return_type": null,
          "lineno": 709,
          "decorators": [],
          "is_async": false,
          "calls": [
            "string_network.count",
            "socket.inet_aton",
            "int",
            "string_network.split"
          ],
          "docstring": "Very simple check of the cidr format in no_proxy variable.\n\n:rtype: bool",
          "code": "def is_valid_cidr(string_network):\n    \"\"\"\n    Very simple check of the cidr format in no_proxy variable.\n\n    :rtype: bool\n    \"\"\"\n    if string_network.count(\"/\") == 1:\n        try:\n            mask = int(string_network.split(\"/\")[1])\n        except ValueError:\n            return False\n\n        if mask < 1 or mask > 32:\n            return False\n\n        try:\n            socket.inet_aton(string_network.split(\"/\")[0])\n        except OSError:\n            return False\n    else:\n        return False\n    return True",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "set_environ",
          "args": [
            {
              "name": "env_name"
            },
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 734,
          "decorators": [
            {
              "name": "contextlib.contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "old_value",
            "env_name",
            "value",
            "os.environ.get"
          ],
          "docstring": "Set the environment variable 'env_name' to 'value'\n\nSave previous value, yield, and then restore the previous value stored in\nthe environment variable 'env_name'.\n\nIf 'value' is None, do nothing",
          "code": "def set_environ(env_name, value):\n    \"\"\"Set the environment variable 'env_name' to 'value'\n\n    Save previous value, yield, and then restore the previous value stored in\n    the environment variable 'env_name'.\n\n    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n    finally:\n        if value_changed:\n            if old_value is None:\n                del os.environ[env_name]\n            else:\n                os.environ[env_name] = old_value",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "should_bypass_proxies",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "no_proxy"
            }
          ],
          "return_type": null,
          "lineno": 755,
          "decorators": [],
          "is_async": false,
          "calls": [
            "is_valid_cidr",
            "host_with_port.endswith",
            "is_ipv4_address",
            "no_proxy.replace",
            "os.environ.get",
            "no_proxy",
            "urlparse",
            "no_proxy_arg",
            "proxy_bypass",
            "url",
            "key.upper",
            "unknown.split",
            "parsed.hostname",
            "proxy_ip",
            "get_proxy",
            "set_environ",
            "address_in_network",
            "parsed.hostname.endswith",
            "key",
            "host"
          ],
          "docstring": "Returns whether we should bypass proxies or not.\n\n:rtype: bool",
          "code": "def should_bypass_proxies(url, no_proxy):\n    \"\"\"\n    Returns whether we should bypass proxies or not.\n\n    :rtype: bool\n    \"\"\"\n\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    def get_proxy(key):\n        return os.environ.get(key) or os.environ.get(key.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n    no_proxy_arg = no_proxy\n    if no_proxy is None:\n        no_proxy = get_proxy(\"no_proxy\")\n    parsed = urlparse(url)\n\n    if parsed.hostname is None:\n        # URLs don't always have hostnames, e.g. file:/// urls.\n        return True\n\n    if no_proxy:\n        # We need to check whether we match here. We need to see if we match\n        # the end of the hostname, both with and without the port.\n        no_proxy = (host for host in no_proxy.replace(\" \", \"\").split(\",\") if host)\n\n        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n            if parsed.port:\n                host_with_port += f\":{parsed.port}\"\n\n            for host in no_proxy:\n                if parsed.hostname.endswith(host) or host_with_port.endswith(host):\n                    # The URL does match something in no_proxy, so we don't want\n                    # to apply the proxies on this URL.\n                    return True\n\n    with set_environ(\"no_proxy\", no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n            bypass = False\n\n    if bypass:\n        return True\n\n    return False",
          "line_count": 59,
          "needs_llm_summary": true
        },
        {
          "name": "get_environ_proxies",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "no_proxy"
            }
          ],
          "return_type": null,
          "lineno": 816,
          "decorators": [],
          "is_async": false,
          "calls": [
            "no_proxy",
            "getproxies",
            "should_bypass_proxies",
            "url"
          ],
          "docstring": "Return a dict of environment proxies.\n\n:rtype: dict",
          "code": "def get_environ_proxies(url, no_proxy=None):\n    \"\"\"\n    Return a dict of environment proxies.\n\n    :rtype: dict\n    \"\"\"\n    if should_bypass_proxies(url, no_proxy=no_proxy):\n        return {}\n    else:\n        return getproxies()",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "select_proxy",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "proxies"
            }
          ],
          "return_type": null,
          "lineno": 828,
          "decorators": [],
          "is_async": false,
          "calls": [
            "urlparse",
            "proxies.get",
            "url",
            "urlparts.scheme"
          ],
          "docstring": "Select a proxy for the url, if applicable.\n\n:param url: The url being for the request\n:param proxies: A dictionary of schemes or schemes and hosts to proxy URLs",
          "code": "def select_proxy(url, proxies):\n    \"\"\"Select a proxy for the url, if applicable.\n\n    :param url: The url being for the request\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get(\"all\"))\n\n    proxy_keys = [\n        urlparts.scheme + \"://\" + urlparts.hostname,\n        urlparts.scheme,\n        \"all://\" + urlparts.hostname,\n        \"all\",\n    ]\n    proxy = None\n    for proxy_key in proxy_keys:\n        if proxy_key in proxies:\n            proxy = proxies[proxy_key]\n            break\n\n    return proxy",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "resolve_proxies",
          "args": [
            {
              "name": "request"
            },
            {
              "name": "proxies"
            },
            {
              "name": "trust_env"
            }
          ],
          "return_type": null,
          "lineno": 854,
          "decorators": [],
          "is_async": false,
          "calls": [
            "new_proxies.setdefault",
            "url",
            "scheme",
            "should_bypass_proxies",
            "no_proxy",
            "proxy",
            "urlparse",
            "proxies.copy",
            "request.url",
            "unknown.scheme",
            "proxies.get",
            "get_environ_proxies",
            "environ_proxies.get"
          ],
          "docstring": "This method takes proxy information from a request and configuration\ninput to resolve a mapping of target proxies. This will consider settings\nsuch as NO_PROXY to strip proxy configurations.\n\n:param request: Request or PreparedRequest\n:param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n:param trust_env: Boolean declaring whether to trust environment configs\n\n:rtype: dict",
          "code": "def resolve_proxies(request, proxies, trust_env=True):\n    \"\"\"This method takes proxy information from a request and configuration\n    input to resolve a mapping of target proxies. This will consider settings\n    such as NO_PROXY to strip proxy configurations.\n\n    :param request: Request or PreparedRequest\n    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n    :param trust_env: Boolean declaring whether to trust environment configs\n\n    :rtype: dict\n    \"\"\"\n    proxies = proxies if proxies is not None else {}\n    url = request.url\n    scheme = urlparse(url).scheme\n    no_proxy = proxies.get(\"no_proxy\")\n    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get(\"all\"))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n    return new_proxies",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "default_user_agent",
          "args": [
            {
              "name": "name"
            }
          ],
          "return_type": null,
          "lineno": 881,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Return a string representing the default user agent.\n\n:rtype: str",
          "code": "def default_user_agent(name=\"python-requests\"):\n    \"\"\"\n    Return a string representing the default user agent.\n\n    :rtype: str\n    \"\"\"\n    return f\"{name}/{__version__}\"",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "default_headers",
          "args": [],
          "return_type": null,
          "lineno": 890,
          "decorators": [],
          "is_async": false,
          "calls": [
            "CaseInsensitiveDict",
            "default_user_agent"
          ],
          "docstring": ":rtype: requests.structures.CaseInsensitiveDict",
          "code": "def default_headers():\n    \"\"\"\n    :rtype: requests.structures.CaseInsensitiveDict\n    \"\"\"\n    return CaseInsensitiveDict(\n        {\n            \"User-Agent\": default_user_agent(),\n            \"Accept-Encoding\": DEFAULT_ACCEPT_ENCODING,\n            \"Accept\": \"*/*\",\n            \"Connection\": \"keep-alive\",\n        }\n    )",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "parse_header_links",
          "args": [
            {
              "name": "value"
            }
          ],
          "return_type": null,
          "lineno": 904,
          "decorators": [],
          "is_async": false,
          "calls": [
            "re.split",
            "replace_chars",
            "links.append",
            "value.strip",
            "link",
            "param.split",
            "val.split",
            "key.strip",
            "url.strip",
            "value",
            "params.split"
          ],
          "docstring": "Return a list of parsed link headers proxies.\n\ni.e. Link: <http:/.../front.jpeg>; rel=front; type=\"image/jpeg\",<http://.../back.jpeg>; rel=back;type=\"image/jpeg\"\n\n:rtype: list",
          "code": "def parse_header_links(value):\n    \"\"\"Return a list of parsed link headers proxies.\n\n    i.e. Link: <http:/.../front.jpeg>; rel=front; type=\"image/jpeg\",<http://.../back.jpeg>; rel=back;type=\"image/jpeg\"\n\n    :rtype: list\n    \"\"\"\n\n    links = []\n\n    replace_chars = \" '\\\"\"\n\n    value = value.strip(replace_chars)\n    if not value:\n        return links\n\n    for val in re.split(\", *<\", value):\n        try:\n            url, params = val.split(\";\", 1)\n        except ValueError:\n            url, params = val, \"\"\n\n        link = {\"url\": url.strip(\"<> '\\\"\")}\n\n        for param in params.split(\";\"):\n            try:\n                key, value = param.split(\"=\")\n            except ValueError:\n                break\n\n            link[key.strip(replace_chars)] = value.strip(replace_chars)\n\n        links.append(link)\n\n    return links",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "guess_json_utf",
          "args": [
            {
              "name": "data"
            }
          ],
          "return_type": null,
          "lineno": 947,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_null",
            "sample.count"
          ],
          "docstring": ":rtype: str",
          "code": "def guess_json_utf(data):\n    \"\"\"\n    :rtype: str\n    \"\"\"\n    # JSON always starts with two ASCII characters, so detection is as\n    # easy as counting the nulls and from their location and count\n    # determine the encoding. Also detect a BOM, if present.\n    sample = data[:4]\n    if sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):\n        return \"utf-32\"  # BOM included\n    if sample[:3] == codecs.BOM_UTF8:\n        return \"utf-8-sig\"  # BOM included, MS style (discouraged)\n    if sample[:2] in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):\n        return \"utf-16\"  # BOM included\n    nullcount = sample.count(_null)\n    if nullcount == 0:\n        return \"utf-8\"\n    if nullcount == 2:\n        if sample[::2] == _null2:  # 1st and 3rd are null\n            return \"utf-16-be\"\n        if sample[1::2] == _null2:  # 2nd and 4th are null\n            return \"utf-16-le\"\n        # Did not detect 2 valid UTF-16 ascii-range characters\n    if nullcount == 3:\n        if sample[:3] == _null3:\n            return \"utf-32-be\"\n        if sample[1:] == _null3:\n            return \"utf-32-le\"\n        # Did not detect a valid UTF-32 ascii-range character\n    return None",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "prepend_scheme_if_needed",
          "args": [
            {
              "name": "url"
            },
            {
              "name": "new_scheme"
            }
          ],
          "return_type": null,
          "lineno": 979,
          "decorators": [],
          "is_async": false,
          "calls": [
            "parsed",
            "url",
            "parse_url",
            "unknown.join",
            "parsed.netloc",
            "new_scheme",
            "urlunparse"
          ],
          "docstring": "Given a URL that may or may not have a scheme, prepend the given scheme.\nDoes not replace a present scheme with the one provided as an argument.\n\n:rtype: str",
          "code": "def prepend_scheme_if_needed(url, new_scheme):\n    \"\"\"Given a URL that may or may not have a scheme, prepend the given scheme.\n    Does not replace a present scheme with the one provided as an argument.\n\n    :rtype: str\n    \"\"\"\n    parsed = parse_url(url)\n    scheme, auth, host, port, path, query, fragment = parsed\n\n    # A defect in urlparse determines that there isn't a netloc present in some\n    # urls. We previously assumed parsing was overly cautious, and swapped the\n    # netloc and path. Due to a lack of tests on the original defect, this is\n    # maintained with parse_url for backwards compatibility.\n    netloc = parsed.netloc\n    if not netloc:\n        netloc, path = path, netloc\n\n    if auth:\n        # parse_url doesn't provide the netloc with auth\n        # so we'll add it ourselves.\n        netloc = \"@\".join([auth, netloc])\n    if scheme is None:\n        scheme = new_scheme\n    if path is None:\n        path = \"\"\n\n    return urlunparse((scheme, netloc, path, \"\", query, fragment))",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "get_auth_from_url",
          "args": [
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 1008,
          "decorators": [],
          "is_async": false,
          "calls": [
            "parsed.username",
            "url",
            "urlparse",
            "parsed.password",
            "unquote"
          ],
          "docstring": "Given a url with authentication components, extract them into a tuple of\nusername,password.\n\n:rtype: (str,str)",
          "code": "def get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n\n    :rtype: (str,str)\n    \"\"\"\n    parsed = urlparse(url)\n\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = (\"\", \"\")\n\n    return auth",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "check_header_validity",
          "args": [
            {
              "name": "header"
            }
          ],
          "return_type": null,
          "lineno": 1024,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "name",
            "header",
            "_validate_header_part"
          ],
          "docstring": "Verifies that header parts don't contain leading whitespace\nreserved characters, or return characters.\n\n:param header: tuple, in the format (name, value).",
          "code": "def check_header_validity(header):\n    \"\"\"Verifies that header parts don't contain leading whitespace\n    reserved characters, or return characters.\n\n    :param header: tuple, in the format (name, value).\n    \"\"\"\n    name, value = header\n    _validate_header_part(header, name, 0)\n    _validate_header_part(header, value, 1)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "_validate_header_part",
          "args": [
            {
              "name": "header"
            },
            {
              "name": "header_part"
            },
            {
              "name": "header_validator_index"
            }
          ],
          "return_type": null,
          "lineno": 1035,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "validator.match",
            "str",
            "InvalidHeader",
            "type",
            "header_part",
            "bytes"
          ],
          "docstring": null,
          "code": "def _validate_header_part(header, header_part, header_validator_index):\n    if isinstance(header_part, str):\n        validator = _HEADER_VALIDATORS_STR[header_validator_index]\n    elif isinstance(header_part, bytes):\n        validator = _HEADER_VALIDATORS_BYTE[header_validator_index]\n    else:\n        raise InvalidHeader(\n            f\"Header part ({header_part!r}) from {header} \"\n            f\"must be of type str or bytes, not {type(header_part)}\"\n        )\n\n    if not validator.match(header_part):\n        header_kind = \"name\" if header_validator_index == 0 else \"value\"\n        raise InvalidHeader(\n            f\"Invalid leading whitespace, reserved character(s), or return \"\n            f\"character(s) in header {header_kind}: {header_part!r}\"\n        )",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "urldefragauth",
          "args": [
            {
              "name": "url"
            }
          ],
          "return_type": null,
          "lineno": 1054,
          "decorators": [],
          "is_async": false,
          "calls": [
            "netloc.rsplit",
            "urlparse",
            "url",
            "urlunparse"
          ],
          "docstring": "Given a url remove the fragment and the authentication part.\n\n:rtype: str",
          "code": "def urldefragauth(url):\n    \"\"\"\n    Given a url remove the fragment and the authentication part.\n\n    :rtype: str\n    \"\"\"\n    scheme, netloc, path, params, query, fragment = urlparse(url)\n\n    # see func:`prepend_scheme_if_needed`\n    if not netloc:\n        netloc, path = path, netloc\n\n    netloc = netloc.rsplit(\"@\", 1)[-1]\n\n    return urlunparse((scheme, netloc, path, params, query, \"\"))",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "rewind_body",
          "args": [
            {
              "name": "prepared_request"
            }
          ],
          "return_type": null,
          "lineno": 1071,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "body_seek",
            "prepared_request._body_position",
            "UnrewindableBodyError",
            "getattr",
            "prepared_request.body",
            "integer_types"
          ],
          "docstring": "Move file pointer back to its recorded starting position\nso it can be read again on redirect.",
          "code": "def rewind_body(prepared_request):\n    \"\"\"Move file pointer back to its recorded starting position\n    so it can be read again on redirect.\n    \"\"\"\n    body_seek = getattr(prepared_request.body, \"seek\", None)\n    if body_seek is not None and isinstance(\n        prepared_request._body_position, integer_types\n    ):\n        try:\n            body_seek(prepared_request._body_position)\n        except OSError:\n            raise UnrewindableBodyError(\n                \"An error occurred when rewinding request body for redirect.\"\n            )\n    else:\n        raise UnrewindableBodyError(\"Unable to rewind request body for redirect.\")",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "proxy_bypass_registry",
          "args": [
            {
              "name": "host"
            }
          ],
          "return_type": null,
          "lineno": 77,
          "decorators": [],
          "is_async": false,
          "calls": [
            "winreg.OpenKey",
            "winreg.QueryValueEx",
            "test.replace",
            "proxyOverride.split",
            "re.match",
            "re.I",
            "winreg.HKEY_CURRENT_USER",
            "proxyOverride",
            "test",
            "host",
            "int",
            "filter",
            "internetSettings"
          ],
          "docstring": null,
          "code": "def proxy_bypass_registry(host):\n        try:\n            import winreg\n        except ImportError:\n            return False\n\n        try:\n            internetSettings = winreg.OpenKey(\n                winreg.HKEY_CURRENT_USER,\n                r\"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\",\n            )\n            # ProxyEnable could be REG_SZ or REG_DWORD, normalizing it\n            proxyEnable = int(winreg.QueryValueEx(internetSettings, \"ProxyEnable\")[0])\n            # ProxyOverride is almost always a string\n            proxyOverride = winreg.QueryValueEx(internetSettings, \"ProxyOverride\")[0]\n        except (OSError, ValueError):\n            return False\n        if not proxyEnable or not proxyOverride:\n            return False\n\n        # make a check value list from the registry entry: replace the\n        # '<local>' string by the localhost entry and the corresponding\n        # canonical entry.\n        proxyOverride = proxyOverride.split(\";\")\n        # filter out empty strings to avoid re.match return true in the following code.\n        proxyOverride = filter(None, proxyOverride)\n        # now check if we match one of the registry values.\n        for test in proxyOverride:\n            if test == \"<local>\":\n                if \".\" not in host:\n                    return True\n            test = test.replace(\".\", r\"\\.\")  # mask dots\n            test = test.replace(\"*\", r\".*\")  # change glob sequence\n            test = test.replace(\"?\", r\".\")  # change glob char\n            if re.match(test, host, re.I):\n                return True\n        return False",
          "line_count": 37,
          "needs_llm_summary": true
        },
        {
          "name": "proxy_bypass",
          "args": [
            {
              "name": "host"
            }
          ],
          "return_type": null,
          "lineno": 115,
          "decorators": [],
          "is_async": false,
          "calls": [
            "proxy_bypass_environment",
            "host",
            "getproxies_environment",
            "proxy_bypass_registry"
          ],
          "docstring": "Return True, if the host should be bypassed.\n\nChecks proxy settings gathered from the environment, if specified,\nor the registry.",
          "code": "def proxy_bypass(host):  # noqa\n        \"\"\"Return True, if the host should be bypassed.\n\n        Checks proxy settings gathered from the environment, if specified,\n        or the registry.\n        \"\"\"\n        if getproxies_environment():\n            return proxy_bypass_environment(host)\n        else:\n            return proxy_bypass_registry(host)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "get_proxy",
          "args": [
            {
              "name": "key"
            }
          ],
          "return_type": null,
          "lineno": 764,
          "decorators": [],
          "is_async": false,
          "calls": [
            "key.upper",
            "key",
            "os.environ.get"
          ],
          "docstring": null,
          "code": "def get_proxy(key):\n        return os.environ.get(key) or os.environ.get(key.upper())",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "codecs",
          "alias": null,
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "contextlib",
          "alias": null,
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "io",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 12,
          "type": "import"
        },
        {
          "module": "re",
          "alias": null,
          "lineno": 13,
          "type": "import"
        },
        {
          "module": "socket",
          "alias": null,
          "lineno": 14,
          "type": "import"
        },
        {
          "module": "struct",
          "alias": null,
          "lineno": 15,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 16,
          "type": "import"
        },
        {
          "module": "tempfile",
          "alias": null,
          "lineno": 17,
          "type": "import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 18,
          "type": "import"
        },
        {
          "module": "zipfile",
          "alias": null,
          "lineno": 19,
          "type": "import"
        },
        {
          "module": "collections",
          "name": "OrderedDict",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "urllib3.util",
          "name": "make_headers",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "urllib3.util",
          "name": "parse_url",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "certs",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "__version__",
          "name": "__version__",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "_internal_utils",
          "name": "_HEADER_VALIDATORS_BYTE",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "_internal_utils",
          "name": "_HEADER_VALIDATORS_STR",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "_internal_utils",
          "name": "HEADER_VALIDATORS",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "_internal_utils",
          "name": "to_native_string",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "Mapping",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "basestring",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "bytes",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "getproxies",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "getproxies_environment",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "integer_types",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "is_urllib3_1",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "parse_http_list",
          "alias": "_parse_list_header",
          "lineno": 43,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "proxy_bypass",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "proxy_bypass_environment",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "quote",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "str",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "unquote",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlparse",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "compat",
          "name": "urlunparse",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "cookies",
          "name": "cookiejar_from_dict",
          "alias": null,
          "lineno": 53,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "FileModeWarning",
          "alias": null,
          "lineno": 54,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidHeader",
          "alias": null,
          "lineno": 54,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "InvalidURL",
          "alias": null,
          "lineno": 54,
          "type": "from_import"
        },
        {
          "module": "exceptions",
          "name": "UnrewindableBodyError",
          "alias": null,
          "lineno": 54,
          "type": "from_import"
        },
        {
          "module": "structures",
          "name": "CaseInsensitiveDict",
          "alias": null,
          "lineno": 60,
          "type": "from_import"
        },
        {
          "module": "netrc",
          "name": "NetrcParseError",
          "alias": null,
          "lineno": 217,
          "type": "from_import"
        },
        {
          "module": "netrc",
          "name": "netrc",
          "alias": null,
          "lineno": 217,
          "type": "from_import"
        },
        {
          "module": "winreg",
          "alias": null,
          "lineno": 79,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "NETRC_FILES",
          "assigned_to": null,
          "lineno": 62
        },
        {
          "name": "DEFAULT_CA_BUNDLE_PATH",
          "assigned_to": "certs.where",
          "lineno": 64
        },
        {
          "name": "DEFAULT_PORTS",
          "assigned_to": null,
          "lineno": 66
        },
        {
          "name": "DEFAULT_ACCEPT_ENCODING",
          "assigned_to": "unknown.join",
          "lineno": 69
        },
        {
          "name": "UNRESERVED_SET",
          "assigned_to": "frozenset",
          "lineno": 621
        },
        {
          "name": "_null",
          "assigned_to": "unknown.encode",
          "lineno": 942
        },
        {
          "name": "_null2",
          "assigned_to": null,
          "lineno": 943
        },
        {
          "name": "_null3",
          "assigned_to": null,
          "lineno": 944
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "re.split",
          "winreg.QueryValueEx",
          "make_headers",
          "internetSettings",
          "getproxies_environment",
          "re.I",
          "proxyOverride",
          "unknown.join",
          "int",
          "frozenset",
          "proxy_bypass_environment",
          "winreg.OpenKey",
          "certs.where",
          "unknown.encode",
          "proxy_bypass_registry",
          "filter",
          "test.replace",
          "proxyOverride.split",
          "re.match",
          "winreg.HKEY_CURRENT_USER",
          "test",
          "host"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "sys",
          "tempfile",
          "io",
          "collections",
          "warnings",
          "os",
          "contextlib",
          "re"
        ],
        "third_party": {
          "other": [
            "codecs",
            "socket",
            "struct",
            "zipfile",
            "urllib3",
            "certs",
            "__version__",
            "_internal_utils",
            "compat",
            "cookies",
            "exceptions",
            "structures",
            "netrc",
            "winreg"
          ]
        },
        "tech_stack": []
      },
      "line_count": 1087
    },
    "__analysis_summary__": {
      "total_modules": 20,
      "total_functions": 185,
      "total_classes": 45,
      "dead_code_candidates": {
        "unreferenced_functions": [
          {
            "name": "get_connection",
            "module": "src/requests/adapters.py",
            "lineno": 472
          },
          {
            "name": "get_type",
            "module": "src/requests/cookies.py",
            "lineno": 40
          },
          {
            "name": "get_full_url",
            "module": "src/requests/cookies.py",
            "lineno": 49
          },
          {
            "name": "has_header",
            "module": "src/requests/cookies.py",
            "lineno": 72
          },
          {
            "name": "get_header",
            "module": "src/requests/cookies.py",
            "lineno": 75
          },
          {
            "name": "add_header",
            "module": "src/requests/cookies.py",
            "lineno": 78
          },
          {
            "name": "add_unredirected_header",
            "module": "src/requests/cookies.py",
            "lineno": 84
          },
          {
            "name": "list_domains",
            "module": "src/requests/cookies.py",
            "lineno": 277
          },
          {
            "name": "list_paths",
            "module": "src/requests/cookies.py",
            "lineno": 285
          },
          {
            "name": "multiple_domains",
            "module": "src/requests/cookies.py",
            "lineno": 293
          },
          {
            "name": "get_dict",
            "module": "src/requests/cookies.py",
            "lineno": 306
          },
          {
            "name": "_find",
            "module": "src/requests/cookies.py",
            "lineno": 366
          },
          {
            "name": "deregister_hook",
            "module": "src/requests/models.py",
            "lineno": 218
          },
          {
            "name": "iter_lines",
            "module": "src/requests/models.py",
            "lineno": 857
          },
          {
            "name": "dict_to_sequence",
            "module": "src/requests/utils.py",
            "lineno": 127
          },
          {
            "name": "from_key_val_list",
            "module": "src/requests/utils.py",
            "lineno": 308
          },
          {
            "name": "parse_list_header",
            "module": "src/requests/utils.py",
            "lineno": 365
          },
          {
            "name": "dict_from_cookiejar",
            "module": "src/requests/utils.py",
            "lineno": 457
          },
          {
            "name": "add_dict_to_cookiejar",
            "module": "src/requests/utils.py",
            "lineno": 468
          },
          {
            "name": "get_encodings_from_content",
            "module": "src/requests/utils.py",
            "lineno": 479
          },
          {
            "name": "get_unicode_from_response",
            "module": "src/requests/utils.py",
            "lineno": 581
          }
        ],
        "unused_classes": [
          {
            "name": "FlaskyStyle",
            "module": "docs/_themes/flask_theme_support.py",
            "lineno": 7
          },
          {
            "name": "BaseAdapter",
            "module": "src/requests/adapters.py",
            "lineno": 113
          },
          {
            "name": "AuthBase",
            "module": "src/requests/auth.py",
            "lineno": 69
          },
          {
            "name": "HTTPProxyAuth",
            "module": "src/requests/auth.py",
            "lineno": 99
          },
          {
            "name": "HTTPDigestAuth",
            "module": "src/requests/auth.py",
            "lineno": 107
          },
          {
            "name": "RequestsWarning",
            "module": "src/requests/exceptions.py",
            "lineno": 142
          },
          {
            "name": "RequestEncodingMixin",
            "module": "src/requests/models.py",
            "lineno": 84
          },
          {
            "name": "RequestHooksMixin",
            "module": "src/requests/models.py",
            "lineno": 206
          },
          {
            "name": "SessionRedirectMixin",
            "module": "src/requests/sessions.py",
            "lineno": 106
          }
        ],
        "unused_imports": [
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Keyword"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Name"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Comment"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "String"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Error"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Number"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Operator"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Generic"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Whitespace"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Punctuation"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Other"
            ],
            "needs_llm": false
          },
          {
            "module": "docs/_themes/flask_theme_support.py",
            "import_statement": "import pygments.token",
            "lineno": 3,
            "imported_module": "pygments.token",
            "symbols": [
              "Literal"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/adapters.py",
            "import_statement": "import socket",
            "lineno": 10,
            "imported_module": "socket",
            "symbols": [
              "socket"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/adapters.py",
            "import_statement": "import urllib3.exceptions",
            "lineno": 14,
            "imported_module": "urllib3.exceptions",
            "symbols": [
              "ClosedPoolError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/adapters.py",
            "import_statement": "import urllib3.exceptions",
            "lineno": 15,
            "imported_module": "urllib3.exceptions",
            "symbols": [
              "_HTTPError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/adapters.py",
            "import_statement": "import urllib3.exceptions",
            "lineno": 17,
            "imported_module": "urllib3.exceptions",
            "symbols": [
              "LocationValueError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/adapters.py",
            "import_statement": "import urllib3.exceptions",
            "lineno": 17,
            "imported_module": "urllib3.exceptions",
            "symbols": [
              "MaxRetryError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/adapters.py",
            "import_statement": "import urllib3.exceptions",
            "lineno": 17,
            "imported_module": "urllib3.exceptions",
            "symbols": [
              "ProtocolError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import collections",
            "lineno": 72,
            "imported_module": "collections",
            "symbols": [
              "OrderedDict"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import collections.abc",
            "lineno": 73,
            "imported_module": "collections.abc",
            "symbols": [
              "Callable"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import collections.abc",
            "lineno": 73,
            "imported_module": "collections.abc",
            "symbols": [
              "Mapping"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import collections.abc",
            "lineno": 73,
            "imported_module": "collections.abc",
            "symbols": [
              "MutableMapping"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import http",
            "lineno": 74,
            "imported_module": "http",
            "symbols": [
              "cookielib"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import http.cookies",
            "lineno": 75,
            "imported_module": "http.cookies",
            "symbols": [
              "Morsel"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import io",
            "lineno": 76,
            "imported_module": "io",
            "symbols": [
              "StringIO"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "quote"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "quote_plus"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "unquote"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "unquote_plus"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "urldefrag"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "urlencode"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "urljoin"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "urlparse"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "urlsplit"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.parse",
            "lineno": 81,
            "imported_module": "urllib.parse",
            "symbols": [
              "urlunparse"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.request",
            "lineno": 93,
            "imported_module": "urllib.request",
            "symbols": [
              "getproxies"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.request",
            "lineno": 93,
            "imported_module": "urllib.request",
            "symbols": [
              "getproxies_environment"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.request",
            "lineno": 93,
            "imported_module": "urllib.request",
            "symbols": [
              "parse_http_list"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.request",
            "lineno": 93,
            "imported_module": "urllib.request",
            "symbols": [
              "proxy_bypass"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import urllib.request",
            "lineno": 93,
            "imported_module": "urllib.request",
            "symbols": [
              "proxy_bypass_environment"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import simplejson",
            "lineno": 60,
            "imported_module": "simplejson",
            "symbols": [
              "json"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/compat.py",
            "import_statement": "import json",
            "lineno": 64,
            "imported_module": "json",
            "symbols": [
              "json"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/help.py",
            "import_statement": "import charset_normalizer",
            "lineno": 14,
            "imported_module": "charset_normalizer",
            "symbols": [
              "charset_normalizer"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/help.py",
            "import_statement": "import chardet",
            "lineno": 19,
            "imported_module": "chardet",
            "symbols": [
              "chardet"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/help.py",
            "import_statement": "import OpenSSL",
            "lineno": 31,
            "imported_module": "OpenSSL",
            "symbols": [
              "OpenSSL"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/models.py",
            "import_statement": "import encodings.idna",
            "lineno": 13,
            "imported_module": "encodings.idna",
            "symbols": [
              "encodings.idna"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/models.py",
            "import_statement": "import io",
            "lineno": 14,
            "imported_module": "io",
            "symbols": [
              "UnsupportedOperation"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/models.py",
            "import_statement": "import urllib3.exceptions",
            "lineno": 16,
            "imported_module": "urllib3.exceptions",
            "symbols": [
              "LocationParseError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/models.py",
            "import_statement": "import urllib3.exceptions",
            "lineno": 16,
            "imported_module": "urllib3.exceptions",
            "symbols": [
              "ProtocolError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/models.py",
            "import_statement": "import urllib3.exceptions",
            "lineno": 16,
            "imported_module": "urllib3.exceptions",
            "symbols": [
              "ReadTimeoutError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/models.py",
            "import_statement": "import compat",
            "lineno": 29,
            "imported_module": "compat",
            "symbols": [
              "Mapping"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/sessions.py",
            "import_statement": "import sys",
            "lineno": 9,
            "imported_module": "sys",
            "symbols": [
              "sys"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/sessions.py",
            "import_statement": "import exceptions",
            "lineno": 24,
            "imported_module": "exceptions",
            "symbols": [
              "ChunkedEncodingError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/sessions.py",
            "import_statement": "import exceptions",
            "lineno": 24,
            "imported_module": "exceptions",
            "symbols": [
              "ContentDecodingError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/sessions.py",
            "import_statement": "import models",
            "lineno": 33,
            "imported_module": "models",
            "symbols": [
              "REDIRECT_STATI"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/sessions.py",
            "import_statement": "import utils",
            "lineno": 41,
            "imported_module": "utils",
            "symbols": [
              "should_bypass_proxies"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/utils.py",
            "import_statement": "import contextlib",
            "lineno": 10,
            "imported_module": "contextlib",
            "symbols": [
              "contextlib"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/utils.py",
            "import_statement": "import sys",
            "lineno": 16,
            "imported_module": "sys",
            "symbols": [
              "sys"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/utils.py",
            "import_statement": "import _internal_utils",
            "lineno": 28,
            "imported_module": "_internal_utils",
            "symbols": [
              "_HEADER_VALIDATORS_BYTE"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/utils.py",
            "import_statement": "import _internal_utils",
            "lineno": 28,
            "imported_module": "_internal_utils",
            "symbols": [
              "_HEADER_VALIDATORS_STR"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/utils.py",
            "import_statement": "import _internal_utils",
            "lineno": 28,
            "imported_module": "_internal_utils",
            "symbols": [
              "HEADER_VALIDATORS"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/utils.py",
            "import_statement": "import _internal_utils",
            "lineno": 28,
            "imported_module": "_internal_utils",
            "symbols": [
              "to_native_string"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/utils.py",
            "import_statement": "import compat",
            "lineno": 34,
            "imported_module": "compat",
            "symbols": [
              "is_urllib3_1"
            ],
            "needs_llm": false
          },
          {
            "module": "src/requests/utils.py",
            "import_statement": "import netrc",
            "lineno": 217,
            "imported_module": "netrc",
            "symbols": [
              "NetrcParseError"
            ],
            "needs_llm": false
          }
        ],
        "unused_global_variables": [
          {
            "module": "src/requests/_internal_utils.py",
            "name": "HEADER_VALIDATORS",
            "lineno": 19,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "DEFAULT_POOL_TIMEOUT",
            "lineno": 73,
            "assigned_to": "NoneType",
            "needs_llm": true
          },
          {
            "module": "src/requests/auth.py",
            "name": "CONTENT_TYPE_FORM_URLENCODED",
            "lineno": 21,
            "assigned_to": "str",
            "needs_llm": true
          },
          {
            "module": "src/requests/auth.py",
            "name": "CONTENT_TYPE_MULTI_PART",
            "lineno": 22,
            "assigned_to": "str",
            "needs_llm": true
          },
          {
            "module": "src/requests/compat.py",
            "name": "is_py2",
            "lineno": 52,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/requests/compat.py",
            "name": "is_py3",
            "lineno": 55,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/requests/compat.py",
            "name": "builtin_str",
            "lineno": 101,
            "assigned_to": "str",
            "needs_llm": true
          },
          {
            "module": "src/requests/compat.py",
            "name": "basestring",
            "lineno": 104,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/requests/compat.py",
            "name": "numeric_types",
            "lineno": 105,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/requests/compat.py",
            "name": "integer_types",
            "lineno": 106,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "DEFAULT_REDIRECT_LIMIT",
            "lineno": 79,
            "assigned_to": "int",
            "needs_llm": true
          },
          {
            "module": "src/requests/utils.py",
            "name": "DEFAULT_CA_BUNDLE_PATH",
            "lineno": 64,
            "assigned_to": "certs.where",
            "needs_llm": true
          },
          {
            "module": "src/requests/utils.py",
            "name": "DEFAULT_PORTS",
            "lineno": 66,
            "assigned_to": null,
            "needs_llm": true
          }
        ],
        "unreachable_code": [],
        "suspicious_patterns": [
          {
            "module": "src/requests/adapters.py",
            "name": "send",
            "lineno": 119,
            "pattern_type": "too_many_parameters",
            "details": "Function has 7 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "send",
            "lineno": 590,
            "pattern_type": "long_function",
            "details": "Function is very long (107 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "send",
            "lineno": 590,
            "pattern_type": "too_many_parameters",
            "details": "Function has 7 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/requests/auth.py",
            "name": "build_digest_header",
            "lineno": 126,
            "pattern_type": "long_function",
            "details": "Function is very long (109 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "too_many_parameters",
            "details": "Function has 11 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "resolve_redirects",
            "lineno": 159,
            "pattern_type": "long_function",
            "details": "Function is very long (122 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "resolve_redirects",
            "lineno": 159,
            "pattern_type": "too_many_parameters",
            "details": "Function has 9 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "request",
            "lineno": 500,
            "pattern_type": "too_many_parameters",
            "details": "Function has 17 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "__init__",
            "lineno": 116,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "__init__",
            "lineno": 178,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection_with_tls_context",
            "lineno": 423,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_connection in src/requests/adapters.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection_with_tls_context",
            "lineno": 423,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/api.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection_with_tls_context",
            "lineno": 423,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection_with_tls_context",
            "lineno": 423,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection_with_tls_context",
            "lineno": 423,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection",
            "lineno": 472,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/api.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection",
            "lineno": 472,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection",
            "lineno": 472,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "get_connection",
            "lineno": 472,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "request_url",
            "lineno": 523,
            "pattern_type": "similar_function_names",
            "details": "Similar to request in src/requests/api.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "request_url",
            "lineno": 523,
            "pattern_type": "similar_function_names",
            "details": "Similar to request in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/adapters.py",
            "name": "add_headers",
            "lineno": 555,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_header in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_header in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_type in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_host in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_origin_req_host in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_full_url in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_header in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_new_headers in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to getheaders in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_dict in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_policy in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_redirect_target in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_adapter in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_netrc_auth in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_encodings_from_content in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_encoding_from_headers in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_unicode_from_response in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_environ_proxies in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_auth_from_url in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/api.py",
            "name": "get",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_proxy in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/auth.py",
            "name": "__init__",
            "lineno": 79,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/auth.py",
            "name": "__init__",
            "lineno": 110,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_cookie_header",
            "lineno": 140,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_cookie_header",
            "lineno": 140,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_cookie_header",
            "lineno": 140,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "__init__",
            "lineno": 35,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_type",
            "lineno": 40,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_type",
            "lineno": 40,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_type",
            "lineno": 40,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_host",
            "lineno": 43,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_host",
            "lineno": 43,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_host",
            "lineno": 43,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_origin_req_host",
            "lineno": 46,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_origin_req_host",
            "lineno": 46,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_origin_req_host",
            "lineno": 46,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_full_url",
            "lineno": 49,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_full_url",
            "lineno": 49,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_full_url",
            "lineno": 49,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_header",
            "lineno": 75,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_header",
            "lineno": 75,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_header",
            "lineno": 75,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_new_headers",
            "lineno": 87,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_new_headers",
            "lineno": 87,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_new_headers",
            "lineno": 87,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "__init__",
            "lineno": 110,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "getheaders",
            "lineno": 120,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "getheaders",
            "lineno": 120,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "getheaders",
            "lineno": 120,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_dict in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_policy in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_redirect_target in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_adapter in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_netrc_auth in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_encodings_from_content in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_encoding_from_headers in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_unicode_from_response in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_environ_proxies in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_auth_from_url in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get",
            "lineno": 194,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_proxy in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "set",
            "lineno": 206,
            "pattern_type": "similar_function_names",
            "details": "Similar to set_cookie in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "set",
            "lineno": 206,
            "pattern_type": "similar_function_names",
            "details": "Similar to set_environ in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_dict",
            "lineno": 306,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_dict",
            "lineno": 306,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "_find",
            "lineno": 366,
            "pattern_type": "similar_function_names",
            "details": "Similar to _find_no_duplicates in src/requests/cookies.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_policy",
            "lineno": 435,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/cookies.py",
            "name": "get_policy",
            "lineno": 435,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/exceptions.py",
            "name": "__init__",
            "lineno": 17,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/exceptions.py",
            "name": "__init__",
            "lineno": 34,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "__init__",
            "lineno": 258,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_method in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_url in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_headers in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_body in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_content_length in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_auth in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_cookies in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_hooks in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 295,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_request in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "__init__",
            "lineno": 334,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_method in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_url in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_headers in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_body in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_content_length in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_auth in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_cookies in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_hooks in src/requests/models.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "prepare",
            "lineno": 351,
            "pattern_type": "similar_function_names",
            "details": "Similar to prepare_request in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/models.py",
            "name": "__init__",
            "lineno": 658,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get_redirect_target",
            "lineno": 107,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get_redirect_target",
            "lineno": 107,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "__init__",
            "lineno": 390,
            "pattern_type": "similar_function_names",
            "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get",
            "lineno": 593,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_adapter in src/requests/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get",
            "lineno": 593,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_netrc_auth in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get",
            "lineno": 593,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_encodings_from_content in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get",
            "lineno": 593,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_encoding_from_headers in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get",
            "lineno": 593,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_unicode_from_response in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get",
            "lineno": 593,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_environ_proxies in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get",
            "lineno": 593,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_auth_from_url in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get",
            "lineno": 593,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_proxy in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/sessions.py",
            "name": "get_adapter",
            "lineno": 781,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/status_codes.py",
            "name": "_init",
            "lineno": 109,
            "pattern_type": "similar_function_names",
            "details": "Similar to __init__ in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/status_codes.py",
            "name": "_init",
            "lineno": 109,
            "pattern_type": "similar_function_names",
            "details": "Similar to __init__ in src/requests/structures.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/structures.py",
            "name": "get",
            "lineno": 98,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_netrc_auth in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/structures.py",
            "name": "get",
            "lineno": 98,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_encodings_from_content in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/structures.py",
            "name": "get",
            "lineno": 98,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_encoding_from_headers in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/structures.py",
            "name": "get",
            "lineno": 98,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_unicode_from_response in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/structures.py",
            "name": "get",
            "lineno": 98,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_environ_proxies in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/structures.py",
            "name": "get",
            "lineno": 98,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_auth_from_url in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/structures.py",
            "name": "get",
            "lineno": 98,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_proxy in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/requests/utils.py",
            "name": "proxy_bypass_registry",
            "lineno": 77,
            "pattern_type": "similar_function_names",
            "details": "Similar to proxy_bypass in src/requests/utils.py - possible duplicate logic",
            "needs_llm": true
          }
        ]
      }
    }
  },
  "function_summaries": {
    "src/requests/__init__.py": {
      "check_compatibility": {
        "human": "Checks that the installed versions of required libraries (urllib3, chardet, and charset_normalizer) are compatible with the application. It verifies that urllib3 is at least version 1.21.1 and that either chardet (3.0.2 to 6.0.0) or charset_normalizer (2.0.0 to 4.0.0) is installed. If the versions don't meet requirements, the program stops; if no character detection library is found, it issues a warning.",
        "technical": "Parses version strings by splitting on dots and converting to integers for comparison. Validates urllib3 >= 1.21.1 using assertions, handles 2-part version strings by appending \"0\". Checks chardet version range (3.0.2 to 6.0.0) or charset_normalizer range (2.0.0 to 4.0.0) using tuple comparisons. Raises AssertionError for incompatible versions. Issues RequestsDependencyWarning via warnings.warn() if neither character detection library is present. Returns None; side effects are assertions and warnings."
      },
      "_check_cryptography": {
        "human": "Checks if the installed version of the cryptography library is too old (before version 1.3.4). If an outdated version is detected, it warns the user that this old version might cause their program to run slower than expected. This helps users understand why they might be experiencing performance issues.",
        "technical": "Parses a cryptography version string by splitting on dots and converting to integers for comparison. Returns early if parsing fails (ValueError). Compares the parsed version list against [1, 3, 4] using list comparison. If version is older, emits a warning using warnings.warn() with RequestsDependencyWarning category. No return value; side effect is the warning emission."
      }
    },
    "src/requests/_internal_utils.py": {
      "to_native_string": {
        "human": "Converts any type of string into Python's standard string format. If you give it text that's already in the right format, it leaves it alone. If the text is in a different format (like raw bytes), it converts it into readable text. By default, it assumes the text uses basic English characters (ASCII), but you can tell it to use a different character set if needed.",
        "technical": "Performs type-based string normalization by checking if input is already `builtin_str` (native string type). If true, returns input unchanged. Otherwise, calls `.decode(encoding)` method on the input (assumed to be bytes) to convert to native string, defaulting to ASCII encoding. Returns the native string representation. Note: The type signature in the header is incorrect - function actually returns a string, not None."
      },
      "unicode_is_ascii": {
        "human": "Checks whether a text string contains only basic English letters, numbers, and common symbols (ASCII characters). This is useful when you need to verify that text doesn't contain special characters like emojis, accented letters, or characters from non-Latin alphabets before processing or storing it in systems that only support basic English text.",
        "technical": "Validates that input is a string type via assertion, then attempts to encode the unicode string using ASCII encoding. Returns True if encoding succeeds (all characters are ASCII-compatible), or False if UnicodeEncodeError is raised (indicating presence of non-ASCII characters). Uses try-except pattern for control flow rather than character-by-character validation."
      }
    },
    "src/requests/adapters.py": {
      "_urllib3_request_context": {
        "human": "Prepares the connection settings needed to make an HTTPS request through urllib3. It figures out how to verify the server's identity (using SSL certificates) and whether to use a client certificate for authentication. The function extracts the website address details and packages all security settings so urllib3 knows how to safely connect to the server.",
        "technical": "Parses the request URL to extract scheme, hostname, and port into host_params dict. Configures SSL/TLS settings in pool_kwargs: sets cert_reqs based on verify parameter (CERT_NONE if False, CERT_REQUIRED otherwise), handles ca_certs/ca_cert_dir for certificate verification paths, and processes client_cert as either a tuple (cert_file, key_file) or single cert_file string. Returns two dicts: host_params for connection targeting and pool_kwargs for urllib3 PoolManager SSL configuration."
      },
      "send": {
        "human": "Sends an HTTP request to a web server and handles the response. It sets up the connection with proper security settings (SSL/TLS certificates), configures timeout limits for how long to wait, and translates any network errors that occur into user-friendly error messages. This is the core function that actually transmits your web request over the internet.",
        "technical": "Establishes connection via `get_connection_with_tls_context()`, performs certificate verification, and executes HTTP request using `conn.urlopen()` with configured method, URL, headers, body, and timeout parameters. Converts timeout values into `TimeoutSauce` objects, determines chunked encoding based on Content-Length header presence. Catches urllib3 exceptions (MaxRetryError, ProtocolError, _SSLError, _ProxyError, etc.) and re-raises them as requests library equivalents. Returns Response object via `build_response()`."
      },
      "close": {
        "human": "Cleans up and closes all network connections that were being kept open for reuse. This is like hanging up all phone lines that were left open - it ensures no connections are left dangling when you're done using them, freeing up system resources and preventing connection leaks.",
        "technical": "Performs cleanup by calling `clear()` on the poolmanager instance to close all pooled HTTP connections, then iterates through all proxy managers in the `proxy_manager` dictionary and calls `clear()` on each to close pooled proxy connections. No return value; side effect is closing all active connection pools and releasing associated resources."
      },
      "__init__": {
        "human": "Sets up a connection pool manager that handles multiple network requests efficiently. It configures how many simultaneous connections are allowed, how big each connection pool can be, and how the system should retry failed requests. Think of it as preparing a team of workers (connections) that can handle multiple tasks at once, with rules for what to do when things go wrong.",
        "technical": "Initializes an HTTP adapter with connection pooling parameters. Configures retry logic using urllib3's Retry class (either default Retry(0, read=False) or via Retry.from_int()). Stores pool configuration (_pool_connections, _pool_maxsize, _pool_block), initializes empty config and proxy_manager dicts, calls parent class constructor, and invokes init_poolmanager() to create the actual connection pool with specified parameters."
      },
      "__setstate__": {
        "human": "Restores an object back to a working state after it has been unpickled (loaded from storage). This is necessary because some parts of the object, like connection pools, can't be saved directly and need to be recreated. It rebuilds the object by restoring its saved properties and then setting up fresh connection pools for making HTTP requests.",
        "technical": "Implements pickle deserialization protocol by restoring object state from a dictionary. Initializes proxy_manager and config as empty dicts, then iterates through state dict using setattr() to restore all saved attributes. Finally calls init_poolmanager() with saved pool parameters (_pool_connections, _pool_maxsize, _pool_block) to recreate the non-pickleable connection pool manager. This is part of a requests Session or HTTPAdapter class."
      },
      "init_poolmanager": {
        "human": "Sets up a connection pool manager that handles multiple HTTP connections efficiently. This allows the application to reuse existing connections instead of creating new ones each time, making web requests faster. It's like having a parking lot of ready-to-use connections rather than building a new road every time you need to make a request. This is an internal setup method not meant to be called directly by users.",
        "technical": "Stores the pool configuration parameters (connections, maxsize, block) as instance variables for serialization support, then instantiates a urllib3 PoolManager object with these settings. Maps the connections parameter to num_pools, passes maxsize and block directly, and forwards any additional keyword arguments. Creates self.poolmanager as the primary connection pool handler. No return value; modifies instance state only."
      },
      "proxy_manager_for": {
        "human": "This function manages the creation and retrieval of proxy connections for routing internet requests through intermediary servers. It acts like a factory that either returns an existing proxy connection if one was already created, or builds a new one based on the proxy type (SOCKS or standard HTTP/HTTPS). It handles the technical details of setting up these connections so users don't have to worry about the underlying complexity.",
        "technical": "Implements a caching proxy manager factory that checks `self.proxy_manager` dictionary for existing managers. For SOCKS proxies (detected via `proxy.lower().startswith(\"socks\")`), creates `SOCKSProxyManager` with extracted credentials from `get_auth_from_url()`. For HTTP/HTTPS proxies, creates standard manager via `proxy_from_url()` with headers from `self.proxy_headers()`. All managers are configured with connection pool settings (`_pool_connections`, `_pool_maxsize`, `_pool_block`) and cached in the dictionary before returning."
      },
      "cert_verify": {
        "human": "Configures security settings for an HTTPS connection by setting up certificate verification. When verification is enabled, it locates the trusted certificate authority files needed to validate the server's identity. It also handles client-side certificates if the user needs to prove their own identity to the server. Raises errors if required certificate files cannot be found.",
        "technical": "Configures urllib3 connection object's SSL/TLS settings based on verify and cert parameters. For HTTPS URLs with verify=True, sets conn.cert_reqs to \"CERT_REQUIRED\" and assigns CA bundle path to conn.ca_certs (file) or conn.ca_cert_dir (directory), using DEFAULT_CA_BUNDLE_PATH if no custom path provided. Handles client certificates by setting conn.cert_file and conn.key_file from tuple or string. Validates all certificate paths with os.path.exists() and raises OSError for missing files."
      },
      "build_response": {
        "human": "Converts a low-level HTTP response from the urllib3 library into a higher-level Response object that the requests library uses. This translation makes the raw network response easier to work with by organizing status codes, headers, cookies, and other response data into a user-friendly format. It's an internal conversion step that happens automatically when you make HTTP requests.",
        "technical": "Creates a requests.Response object and populates it from a urllib3 response by: extracting status code via getattr, wrapping headers in CaseInsensitiveDict for case-insensitive access, detecting encoding from headers, storing the raw urllib3 response object, decoding URL from bytes if necessary, extracting cookies using extract_cookies_to_jar, and linking back to the original PreparedRequest and connection (self). Returns the fully constructed Response object."
      },
      "build_connection_pool_key_attributes": {
        "human": "This function figures out which existing network connection can be reused for making an HTTP request. It examines the request details and security settings (like SSL certificates and verification options) to create a \"key\" that identifies the right connection from a pool of available connections, avoiding the need to create new connections unnecessarily.",
        "technical": "Delegates to `_urllib3_request_context()` helper function, passing the PreparedRequest object, verify parameter (boolean or CA bundle path), optional cert parameter (client certificate for mTLS), and the poolmanager instance. Returns a tuple of two dictionaries: host parameters (scheme, hostname, port) and SSL context parameters (ssl_context, cert_reqs, ca_certs, cert_file, key_file) used by urllib3 for connection pool key matching."
      },
      "get_connection_with_tls_context": {
        "human": "This function establishes a network connection to send an HTTP request, handling secure communication settings like SSL certificates. It figures out whether the request needs to go through a proxy server or directly to the destination, then creates the appropriate connection with the right security settings. It's like setting up a secure phone line before making a call, choosing whether to go direct or through an operator.",
        "technical": "Retrieves a urllib3 connection pool for an HTTP request by first calling `build_connection_pool_key_attributes()` to construct connection parameters from verify/cert settings. Determines if a proxy is needed via `select_proxy()`, validates proxy URL format, then either calls `proxy_manager.connection_from_host()` for proxied requests or `poolmanager.connection_from_host()` for direct connections. Wraps ValueError exceptions as InvalidURL and validates proxy URLs, raising InvalidProxyURL for malformed proxies. Returns a configured ConnectionPool object."
      },
      "get_connection": {
        "human": "This function gets a network connection to communicate with a website, either directly or through a proxy server (an intermediary that routes your requests). It's being phased out in favor of a newer, more secure version. When you want to connect to a URL, it figures out if you need to go through a proxy first, validates that the proxy is properly configured, and then establishes the appropriate connection pathway.",
        "technical": "Retrieves a urllib3 ConnectionPool for a given URL, with optional proxy support. Calls `select_proxy()` to determine if proxying is needed, validates proxy URL format using `parse_url()`, and routes through `proxy_manager_for()` if proxy exists, otherwise uses direct `poolmanager.connection_from_url()`. Emits a DeprecationWarning directing users to `get_connection_with_tls_context()`. Raises `InvalidProxyURL` exception if proxy host is malformed. Returns the established connection pool object."
      },
      "request_url": {
        "human": "Determines the correct web address format to use when sending an HTTP request. When using a regular HTTP proxy, it needs the complete web address; otherwise it only needs the path part (like \"/page.html\" instead of \"http://site.com/page.html\"). This ensures the request is formatted correctly for different proxy configurations and prevents confusion in the underlying networking library.",
        "technical": "Calls `select_proxy()` to determine if a proxy is configured, then checks if it's an HTTP (non-HTTPS) proxy or SOCKS proxy via `urlparse()`. Returns `request.path_url` by default, sanitizes URLs starting with \"//\" to prevent urllib3 issues, and returns the full defragmented URL via `urldefragauth()` only for HTTP requests through non-SOCKS proxies. HTTPS and SOCKS-proxied requests always use path-only URLs."
      },
      "add_headers": {
        "human": "This is a placeholder function that allows developers to customize how HTTP headers are added to web requests. By default, it does nothing, but developers can override it in their own code to add custom headers (like authentication tokens or special identifiers) when making HTTP connections. It's designed as an extension point for advanced users who need to modify request behavior.",
        "technical": "Empty hook method (contains only `pass`) in the HTTPAdapter class that accepts a PreparedRequest object and keyword arguments but performs no operations. Serves as an override point for subclasses to inject custom header logic into the request pipeline. No return value, no side effects in base implementation. The request parameter would be modified in-place by overriding implementations."
      },
      "proxy_headers": {
        "human": "Prepares special authentication information that needs to be sent when your internet request goes through a proxy server (an intermediary server). If the proxy requires a username and password, this function extracts those credentials from the proxy URL and formats them properly so the proxy will allow your request to pass through.",
        "technical": "Extracts authentication credentials from proxy URL using `get_auth_from_url()`, then constructs a headers dictionary. If username exists, generates Basic Authentication header using `_basic_auth_str(username, password)` and adds it as \"Proxy-Authorization\" header. Returns empty dict if no credentials found, otherwise returns dict with proxy auth header for urllib3 to send to proxy server (not through CONNECT tunnel)."
      }
    },
    "src/requests/api.py": {
      "request": {
        "human": "This function sends an HTTP request to a web server and gets back a response. You provide what type of request you want to make (like GET or POST) and the web address, along with any optional details like headers, authentication, or data to send. It handles the entire process of connecting to the server, sending your request, and returning the server's response, while properly cleaning up the connection afterwards.",
        "technical": "Creates a temporary Session object using a context manager (with statement) and delegates the actual HTTP request to session.request(), passing through the method, url, and all keyword arguments (**kwargs). The context manager ensures the session is properly closed after the request completes, preventing resource leaks and socket warnings. Returns a Response object from the session's request method. Acts as a convenience wrapper around the Session API for one-off requests."
      },
      "get": {
        "human": "This function retrieves information from a website by sending a GET request to a specified web address. It's like asking a website for data - you provide the URL (web address) and optionally some search parameters (like filters or search terms), and it fetches the information back for you. This is the most common way programs request data from web servers.",
        "technical": "Wrapper function that delegates to a generic `request()` function with method=\"get\". Accepts a URL string, optional params (dict/list/bytes for query string), and arbitrary keyword arguments via **kwargs. Passes all arguments through to the underlying `request()` call and returns a Response object. Acts as a convenience method to simplify GET request syntax by pre-specifying the HTTP method."
      },
      "options": {
        "human": "This function sends an OPTIONS request to a web server to find out what communication methods (like GET, POST, etc.) are allowed for a specific web address. It's like asking a website \"what am I allowed to do here?\" before actually doing anything. This is useful when you need to check what operations a server supports before making other requests.",
        "technical": "Wrapper function that delegates to a generic `request()` function with \"options\" as the HTTP method parameter. Accepts a URL string and forwards all additional keyword arguments unchanged to the underlying request handler. Returns a Response object from the requests library containing the server's response to the OPTIONS HTTP method, which typically includes allowed methods in headers."
      },
      "head": {
        "human": "This function retrieves just the header information from a web page without downloading the full content. It's like checking if a door exists and getting basic information about it without actually opening it. By default, it won't follow redirects to other pages, making it useful for quickly checking if a URL is valid or getting metadata about a resource without wasting bandwidth.",
        "technical": "Wrapper function that sends an HTTP HEAD request by calling the underlying `request()` function with method=\"head\". Sets `allow_redirects` to False by default using `kwargs.setdefault()`, overriding the standard behavior of following redirects. Accepts arbitrary keyword arguments via `**kwargs` which are passed through to the `request()` function. Returns a Response object containing headers and status information without a response body."
      },
      "post": {
        "human": "This function sends information to a website or web service using the POST method, which is commonly used when submitting forms or uploading data. You can send data in two formats: either as form data (like filling out a web form) or as JSON (a structured data format). It's a convenient wrapper that simplifies the process of making POST requests without needing to specify all the technical details yourself.",
        "technical": "Wrapper function that delegates to a generic `request()` function with method=\"post\". Accepts a URL string, optional `data` parameter for form/multipart data, optional `json` parameter for JSON payloads (mutually exclusive with data), and passes through any additional keyword arguments to the underlying request handler. Returns a Response object from the requests library. Acts as a convenience method to avoid manually specifying the HTTP method."
      },
      "put": {
        "human": "This function sends a PUT request to update or replace data on a web server at a specific URL. It's like filling out a form online and clicking \"Update\" - you're sending information to change something that already exists on a website or web service. You provide the web address and the data you want to send, and it handles the communication with the server.",
        "technical": "Wrapper function that delegates to a generic `request()` function with HTTP method \"put\". Accepts a URL string, optional data payload (dict, tuples, bytes, or file-like object), and arbitrary keyword arguments. Passes all parameters through to `request(\"put\", url, data=data, **kwargs)` which handles the actual HTTP PUT operation. Returns a Response object containing the server's response to the PUT request."
      },
      "patch": {
        "human": "This function sends a PATCH request to update or modify data on a web server at a specific URL. PATCH requests are typically used when you want to make partial changes to existing information (like updating just your email address in a profile, rather than resending all your profile data). It's a convenience wrapper that makes it easier to send this specific type of web request.",
        "technical": "Wrapper function that delegates to a generic `request()` function with HTTP method \"patch\". Accepts a URL string, optional data parameter (dict, tuples, bytes, or file-like object), and arbitrary keyword arguments (**kwargs) which are passed through to the underlying request function. Returns a Response object from the request call. Acts as a thin convenience layer over the base request implementation."
      },
      "delete": {
        "human": "This function allows you to send a DELETE request to a web address, which is typically used to remove or delete something from a server (like deleting a user account, removing a file, or canceling a reservation). It's a simple wrapper that makes it easy to perform deletion operations over the internet by just providing the web address and any additional options you need.",
        "technical": "Thin wrapper function that delegates to a generic `request()` function with \"delete\" as the HTTP method parameter. Accepts a URL string and forwards all keyword arguments (`**kwargs`) unchanged to the underlying `request()` call. Returns a Response object from the requests library containing the server's response to the DELETE operation. No validation, transformation, or side effects\u2014purely a convenience method for HTTP DELETE requests."
      }
    },
    "src/requests/auth.py": {
      "_basic_auth_str": {
        "human": "Creates an authentication header string used when logging into websites or services that require a username and password. It converts the credentials into a special encoded format (Basic Authentication) that can be safely sent over the internet. The function also handles cases where people accidentally pass in numbers or other non-text values instead of proper usernames/passwords, converting them automatically while warning that this won't be supported in future versions.",
        "technical": "Generates HTTP Basic Authentication header by encoding username and password credentials. First validates inputs are string/basestring types, issuing DeprecationWarnings and converting non-strings via str(). Encodes unicode strings to latin1 bytes, then base64-encodes the combined \"username:password\" format with b\":\".join(). Returns formatted string \"Basic <base64_credentials>\" using to_native_string() for the encoded value. Side effect: emits deprecation warnings to stderr for non-string inputs."
      },
      "__init__": {
        "human": "Sets up a new authentication object that stores a username and password for logging into a system. It also creates a special storage area that keeps separate information for each thread of execution, which is useful when multiple operations are happening at the same time without interfering with each other.",
        "technical": "Constructor that initializes instance attributes for username and password credentials. Creates a `threading.local()` object stored in `self._thread_local` to maintain thread-safe state isolation, allowing each thread to have its own independent data storage. No validation or transformation is performed on the input parameters; they are stored as-is."
      },
      "__eq__": {
        "human": "Checks if two user account objects are the same by comparing their credentials. This allows the program to determine if two user objects represent the same person by verifying that both their username and password match. Returns true only when both credentials are identical, false otherwise.",
        "technical": "Implements equality comparison operator (`==`) for a credentials/user class. Uses `getattr()` with `None` default to safely access `username` and `password` attributes from the `other` object, preventing AttributeError if comparing with incompatible types. Returns boolean result from `all()` evaluating a list of two equality comparisons. Handles comparison with non-class objects gracefully by treating missing attributes as `None`."
      },
      "__call__": {
        "human": "Prepares an HTTP request to use digest authentication, which is a secure way to prove your identity to a website. If you've already authenticated before, it reuses that information to avoid asking for credentials again. It also sets up the request to handle authentication challenges and redirects that might come back from the server.",
        "technical": "Implements the `__call__` method for HTTP Digest Authentication middleware. Initializes thread-local state, adds pre-emptive Authorization header if a nonce exists from previous auth. Captures request body position for potential replay after 401 response. Registers two response hooks (`handle_401` and `handle_redirect`) to process authentication challenges and redirects. Resets 401 call counter and returns the modified request object."
      },
      "init_per_thread_state": {
        "human": "Sets up a fresh workspace for each separate thread of execution in the program. This is like giving each worker their own clean desk with empty notebooks and counters reset to zero. It only does this setup once per thread to avoid duplicating work. This ensures each thread has its own isolated tracking variables for authentication-related operations.",
        "technical": "Initializes thread-local storage attributes for HTTP digest authentication state management. Uses `hasattr()` to check if initialization already occurred, then sets up six thread-local variables: `init` flag (True), `last_nonce` (empty string), `nonce_count` (0), `chal` (empty dict), `pos` (None), and `num_401_calls` (None). Ensures thread-safe state isolation by leveraging `self._thread_local` object, preventing race conditions in multi-threaded authentication scenarios."
      },
      "build_digest_header": {
        "human": "Creates an authentication header for HTTP Digest Authentication, which is a secure way to prove your identity to a web server without sending your password directly. It takes your username and password, combines them with server-provided challenge data, and creates a special encrypted response that proves you know the password. The server can verify this response without you having to transmit the actual password over the network.",
        "technical": "Implements RFC 2616 HTTP Digest Authentication by extracting challenge parameters (realm, nonce, qop, algorithm) from thread-local storage, selecting appropriate hash function (MD5, SHA-1, SHA-256, or SHA-512), computing HA1 (hash of username:realm:password) and HA2 (hash of method:path), generating client nonce from urandom and timestamp, calculating response digest using KD function, and formatting the Authorization header string with all required fields including nonce count tracking for replay protection."
      },
      "handle_redirect": {
        "human": "This function helps manage authentication retry attempts when a web request gets redirected to a different URL. When the server sends a redirect response, it resets a counter that tracks how many times authentication has been attempted. This prevents the system from getting stuck in endless authentication loops after following redirects.",
        "technical": "Checks if the response object `r` has `is_redirect` flag set to True. If redirected, resets the thread-local variable `num_401_calls` to 1, which tracks HTTP 401 (Unauthorized) authentication attempts. Uses thread-local storage to maintain separate counters per thread. This is typically part of an authentication handler class (likely requests library auth handler) to manage retry logic across redirects."
      },
      "handle_401": {
        "human": "Handles authentication when a server responds with a 401 (Unauthorized) error by implementing digest authentication. If the server requests digest authentication and this is the first retry attempt, it extracts the authentication challenge from the response, builds proper authentication credentials, and resends the original request with those credentials included. This allows users to access protected resources without manual intervention.",
        "technical": "Processes 401/4xx responses by checking for \"digest\" in www-authenticate header. On first retry (num_401_calls < 2), parses digest challenge using regex and parse_dict_header, rewinds request body to saved position, closes original response, copies the request with extracted cookies, adds Authorization header via build_digest_header, and resends through r.connection.send. Returns authenticated response with history chain or original response if digest auth not needed. Uses thread-local storage for retry counting and file position tracking."
      },
      "md5_utf8": {
        "human": "Creates a unique fingerprint (called an MD5 hash) for any piece of data you give it. This fingerprint is a fixed-length code that represents the input data - like a digital signature. If you give it text, it automatically converts it to the right format first. This is commonly used to verify data integrity or create unique identifiers.",
        "technical": "Computes MD5 hash of input data and returns hexadecimal digest string. Accepts any data type; if input is a string, encodes it to UTF-8 bytes before hashing. Uses hashlib.md5() to generate hash, then calls hexdigest() to convert binary hash to 32-character hex string. Returns the hash digest as a string representation."
      },
      "sha_utf8": {
        "human": "Creates a unique fingerprint (hash) for any piece of data you give it. If you provide text, it automatically converts it to a format that can be processed. This fingerprint is always the same length and can be used to verify data integrity or create unique identifiers for content.",
        "technical": "Computes SHA-1 hash of input data and returns hexadecimal digest string. Accepts either string or bytes input; strings are automatically encoded to UTF-8 bytes before hashing. Uses hashlib.sha1() for hash computation and hexdigest() to convert binary hash to 40-character hex string. Returns string representation of hash regardless of input type."
      },
      "sha256_utf8": {
        "human": "Creates a unique fingerprint (hash) for any piece of text or data. This fingerprint is always the same length and uniquely identifies the input - like a digital signature. If the input is text, it first converts it to a computer-readable format, then generates a fixed-length code that represents that data. Useful for verifying data hasn't changed or for creating unique identifiers.",
        "technical": "Computes SHA-256 hash of input data and returns hexadecimal string representation. Accepts string or bytes input; if string is provided, encodes to UTF-8 bytes first using `str.encode()`. Calls `hashlib.sha256()` to create hash object, then `hexdigest()` to convert to hex string. Returns 64-character hexadecimal string. No side effects; pure function that transforms input to cryptographic hash."
      },
      "sha512_utf8": {
        "human": "This function creates a unique fingerprint (called a hash) for any piece of data you give it. Think of it like creating a digital signature that always produces the same result for the same input, but completely different results for even slightly different inputs. It's commonly used for security purposes, like verifying data hasn't been tampered with or storing passwords safely.",
        "technical": "Computes SHA-512 hash of input data and returns hexadecimal string representation. Accepts any input type, automatically encodes string inputs to UTF-8 bytes before hashing. Uses hashlib.sha512() to generate 512-bit cryptographic hash, then converts to hex digest string via hexdigest(). Non-string inputs are passed directly to sha512() (assumes they're already bytes-like). Returns 128-character hexadecimal string."
      }
    },
    "src/requests/compat.py": {
      "_resolve_char_detection": {
        "human": "Searches for and loads a library that can detect what character encoding a file or text is using (like UTF-8, ASCII, etc.). It tries two different popular libraries in order of preference and uses whichever one is installed on the system. If neither library is available, it returns nothing. This helps programs read text files correctly even when they don't know the encoding beforehand.",
        "technical": "Iterates through a tuple of two character detection library names (\"chardet\", \"charset_normalizer\") and attempts to dynamically import the first available one using `importlib.import_module()`. Returns the successfully imported module object or None if both imports fail with ImportError. Uses a simple first-found strategy with no fallback logic beyond returning None. The function has a bug: the docstring says it returns None but the code can return a module object."
      }
    },
    "src/requests/cookies.py": {
      "extract_cookies_to_jar": {
        "human": "This function transfers cookies from a web server's response into a cookie storage container (like a cookie jar in your browser). It acts as a bridge between two different systems that handle HTTP responses differently, ensuring cookies are properly saved so they can be sent back in future requests to the same website.",
        "technical": "Extracts cookies from a urllib3.HTTPResponse object into a CookieJar by adapting between incompatible interfaces. Checks for `_original_response` attribute existence, then wraps the requests.Request in MockRequest and the httplib.HTTPResponse.msg headers in MockResponse. Calls jar.extract_cookies() with these mock objects to perform the actual cookie extraction. Returns None; modifies jar in-place as a side effect."
      },
      "get_cookie_header": {
        "human": "Takes a cookie storage container and a web request, then figures out which cookies should be sent along with that request. It's like checking your cookie jar to see which cookies are appropriate to include when visiting a particular website, based on rules like domain and path matching.",
        "technical": "Wraps the input request object in a MockRequest adapter, invokes the cookie jar's `add_cookie_header()` method to apply cookie selection logic and populate appropriate headers, then extracts and returns the \"Cookie\" header string from the modified mock request. Returns None if no cookies match. Acts as a bridge between the cookie jar's internal API and the request object's interface."
      },
      "remove_cookie_by_name": {
        "human": "Removes specific cookies from a cookie storage container. You can remove all cookies with a certain name, or be more selective by also specifying which website (domain) and location (path) the cookie belongs to. This is useful when you want to delete login information or tracking cookies without clearing everything.",
        "technical": "Iterates through a CookieJar to identify cookies matching the given name and optional domain/path filters. Collects matching cookies into a list of (domain, path, name) tuples, then calls cookiejar.clear() for each match. Uses two-pass approach to avoid modifying the collection during iteration. Returns None but mutates the cookiejar parameter as a side effect. Time complexity is O(n) where n is the number of cookies."
      },
      "_copy_cookie_jar": {
        "human": "Creates a complete copy of a cookie jar (a container that stores web cookies). If the cookie jar is empty, it returns nothing. If it has a built-in copy feature, it uses that. Otherwise, it manually creates a new empty jar and copies each cookie one by one into it, ensuring the original jar remains unchanged.",
        "technical": "Returns None for null input, otherwise creates a deep copy of a cookie jar object. First attempts to use the jar's native `copy()` method (RequestsCookieJar optimization). Falls back to manual copying: uses `copy.copy()` to create shallow jar copy, calls `clear()` to empty it, then iterates through original jar calling `set_cookie()` with `copy.copy(cookie)` for each cookie. Returns the new jar instance."
      },
      "create_cookie": {
        "human": "Creates a web cookie with a name and value that you provide. By default, it makes a \"supercookie\" that works across all domains and paths, meaning it gets sent with every web request. You can customize various cookie properties like expiration time, security settings, and which domain or path it applies to by passing additional options.",
        "technical": "Constructs a `cookielib.Cookie` object by merging user-provided kwargs with default cookie attributes (version, port, domain, path, secure, expires, etc.). Validates kwargs against allowed parameters, raising TypeError for unexpected arguments. Derives specification flags (`port_specified`, `domain_specified`, `domain_initial_dot`, `path_specified`) from the presence/format of their corresponding values. Returns a fully-formed Cookie instance suitable for use with Python's cookie handling libraries."
      },
      "morsel_to_cookie": {
        "human": "Converts a web cookie from one format (Morsel object, used by Python's cookie handling) into another format (Cookie object, used by the requests library). It extracts cookie properties like expiration time, security settings, and domain information, calculating the expiration date from either a \"max-age\" value (seconds from now) or an \"expires\" timestamp, then packages everything into a standardized cookie format.",
        "technical": "Transforms a Morsel object into a Cookie by extracting attributes and computing expiration time. Handles two expiration formats: converts \"max-age\" to Unix timestamp by adding to current time.time(), or parses \"expires\" string using time.strptime() with GMT format and calendar.timegm(). Calls create_cookie() with mapped attributes including name (morsel.key), value (morsel.value), domain, path, secure flag, HttpOnly flag, and version. Raises TypeError for invalid max-age integers."
      },
      "cookiejar_from_dict": {
        "human": "Converts a simple dictionary of cookie names and values into a proper cookie container that web browsers and HTTP libraries can use. If you already have a cookie container, it can add new cookies to it. You can choose whether new cookies should replace existing ones with the same name or be skipped.",
        "technical": "Creates or populates a RequestsCookieJar from a dictionary by iterating through key-value pairs and calling create_cookie() for each entry. Initializes new RequestsCookieJar if none provided. Implements conditional insertion logic: extracts existing cookie names from jar, then only calls set_cookie() if overwrite=True or cookie name doesn't exist. Returns the populated cookiejar instance."
      },
      "merge_cookies": {
        "human": "This function combines two collections of web cookies into one. It takes an existing cookie storage container and adds new cookies to it, making sure not to replace cookies that are already there. Think of it like merging two cookie jars - you pour the contents of one jar into another, keeping all the cookies together in a single container.",
        "technical": "Validates that `cookiejar` is a `cookielib.CookieJar` instance, then merges `cookies` into it based on type. If `cookies` is a dict, calls `cookiejar_from_dict()` with `overwrite=False`. If `cookies` is a CookieJar, attempts `cookiejar.update()` or falls back to iterating and calling `set_cookie()` for each cookie. Returns the merged CookieJar. Note: Despite docstring claiming no return, function actually returns the modified cookiejar."
      },
      "__init__": {
        "human": "Creates a mock (fake) response object that can be used by cookie-handling code. This is useful when you need to simulate an HTTP response without actually making a real network request, specifically so that cookie management systems can extract and process cookie information from headers.",
        "technical": "Constructor that initializes a MockResponse instance by storing the provided headers object in the `_headers` instance attribute. Accepts headers parameter (typically httplib.HTTPMessage or compatible type) and performs simple assignment with no validation, transformation, or side effects. Returns None implicitly as standard for `__init__` methods."
      },
      "get_full_url": {
        "human": "Returns the complete web address (URL) that was actually used for a request. If the user manually specified which server to contact (using a Host header), it rebuilds the URL to reflect that custom server address instead of just returning the original URL. This ensures the returned URL matches what was actually requested.",
        "technical": "Checks if a custom Host header exists in the request headers. If absent, returns the original URL from `self._r.url`. If present, extracts the Host value using `to_native_string()`, parses the original URL with `urlparse()`, then reconstructs a new URL via `urlunparse()` by replacing the original hostname with the custom Host header value while preserving scheme, path, params, query, and fragment components."
      },
      "add_header": {
        "human": "This function is intentionally disabled and will always produce an error if called. It exists to prevent incorrect usage when working with cookies in web requests. The error message guides users to use a different, more appropriate method for adding cookie-related information to web requests.",
        "technical": "Raises NotImplementedError unconditionally when invoked, regardless of the key/val parameters passed. Does not perform any operations or return values. Serves as a guard method to prevent direct header addition in cookie handling contexts, directing developers to use add_unredirected_header() instead. Part of a cookie jar implementation's request interface."
      },
      "get": {
        "human": "Retrieves a cookie from a cookie jar by its name, similar to getting a value from a dictionary. When multiple websites share the same cookie jar, you can specify which website (domain) and location (path) the cookie belongs to, to avoid confusion. If the cookie isn't found, it returns a default value instead of causing an error.",
        "technical": "Implements dict-like get() method for cookie retrieval with optional domain/path filtering. Delegates lookup to `_find_no_duplicates(name, domain, path)` which performs O(n) linear search through cookie collection. Catches KeyError exceptions from failed lookups and returns the `default` parameter (None if unspecified). Enables disambiguation of cookies with identical names across different domains/paths within a single cookie jar."
      },
      "set": {
        "human": "This function adds a cookie to a cookie jar (a collection of cookies). It works like setting a value in a dictionary, but handles web cookies which can have the same name across different websites. If you set a cookie's value to None, it removes that cookie instead. It can handle both simple cookie values and special cookie objects that contain extra information.",
        "technical": "Sets a cookie in the jar by accepting name/value pairs plus optional kwargs (domain, path). If value is None, calls remove_cookie_by_name() to delete the cookie. If value is a Morsel object, converts it via morsel_to_cookie(); otherwise creates a new cookie via create_cookie(). Calls self.set_cookie() to store the cookie object and returns the created cookie instance. Handles naming collisions through domain/path parameters."
      },
      "iterkeys": {
        "human": "This function lets you loop through all the cookie names stored in a cookie jar, one at a time. It's like getting a list of labels from a collection of cookies without actually touching the cookies themselves. This is useful when you only need to know what cookies exist by their names, rather than getting all their details.",
        "technical": "Generator function that iterates over the cookie jar object (self) and yields only the `name` attribute of each cookie. Uses `iter(self)` to traverse the collection and extracts the name property from each cookie object. Returns an iterator (via yield) rather than a list, enabling memory-efficient lazy evaluation. Implements dict-like interface for cookie jar access patterns."
      },
      "keys": {
        "human": "Retrieves all the cookie names stored in the cookie jar and gives them back as a simple list. Think of it like getting a list of all the labels on cookie containers in your pantry - you see what cookies you have available, but not the cookies themselves or their details.",
        "technical": "Implements dict-like interface for cookie jar by calling `self.iterkeys()` to get an iterator of cookie names, then wraps it with `list()` to convert the iterator into a concrete list object. Returns a list of strings representing cookie names. No side effects - purely read-only operation that creates a new list from the iterator."
      },
      "itervalues": {
        "human": "This function lets you loop through all the cookie values stored in a cookie jar, one at a time. Instead of getting the entire cookie objects, it extracts just the value part of each cookie (like the actual data stored, not the name or other details). It's useful when you only care about what's stored in the cookies, not their names or metadata.",
        "technical": "Generator function that iterates over the cookie jar's collection using `iter(self)` and yields only the `value` attribute of each cookie object. Returns a lazy iterator rather than a list, allowing memory-efficient traversal of cookie values. Implements dict-like interface for cookie jar objects by providing value-only iteration, complementing `iterkeys()` and `iteritems()` methods."
      },
      "values": {
        "human": "Retrieves all the cookie values stored in a cookie jar and returns them as a simple list. This is useful when you only care about what values are stored in the cookies, not their names or other details. It's like looking at just the contents of labeled jars without reading the labels.",
        "technical": "Implements dict-like interface by calling `self.itervalues()` to get an iterator over cookie values, then wraps it with `list()` to convert to a concrete list. Returns a list containing all cookie values from the jar. No side effects - purely read-only operation that creates a new list from the iterator."
      },
      "iteritems": {
        "human": "This function allows you to loop through all cookies stored in a cookie jar and get both the name and value of each cookie as pairs. It's like opening a cookie jar and reading both the label and contents of each cookie inside, one at a time, rather than getting everything at once.",
        "technical": "Implements a generator function that iterates over the cookie jar's collection using `iter(self)` and yields tuples of `(cookie.name, cookie.value)` for each cookie object. Returns an iterator rather than a list, enabling memory-efficient lazy evaluation. Provides dict-like interface for cookie jar objects, extracting name-value pairs from cookie objects during iteration."
      },
      "items": {
        "human": "Converts a cookie jar into a simple list of pairs, where each pair contains a cookie's name and its value. This makes it easy to turn the cookie jar into a regular Python dictionary that other programs can easily work with. It's like taking cookies out of a jar and organizing them into labeled pairs.",
        "technical": "Returns a list of (name, value) tuples by calling `self.iteritems()` and converting the iterator to a list. Implements the dict-like `items()` interface for RequestsCookieJar, enabling conversion to standard dict via `dict()` constructor. Single-line implementation that materializes all cookie name-value pairs into memory as a list data structure."
      },
      "list_domains": {
        "human": "Collects and returns a list of all unique website domains that have stored cookies. This is useful when you want to see which websites have placed cookies in your browser's cookie storage, without seeing duplicate entries for sites that have multiple cookies.",
        "technical": "Iterates through all cookie objects in the jar (self), extracts the domain attribute from each cookie, and builds a list containing only unique domain values by checking membership before appending. Returns a list of strings representing distinct domains. Uses linear search for duplicate detection (O(n\u00b2) complexity)."
      },
      "list_paths": {
        "human": "Collects and returns a list of all unique website paths (like \"/home\" or \"/products\") that are stored in cookies. This helps you see which different areas of a website have saved cookies, without showing duplicate paths. It's like getting a directory of all the places where cookies exist.",
        "technical": "Iterates through all cookie objects in the jar using `iter(self)`, extracts the `path` attribute from each cookie, and builds a deduplicated list by checking membership before appending. Returns a list of unique path strings. Note: The signature indicates `-> None` but the function actually returns a list, suggesting a documentation error."
      },
      "multiple_domains": {
        "human": "Checks whether a cookie jar contains cookies from more than one website domain. This is useful for security and privacy purposes - for example, to detect if cookies from different websites are being mixed together. Returns True if multiple different domains are found, False if all cookies are from the same domain or there are no cookies.",
        "technical": "Iterates through cookies in the jar using `iter(self)`, maintaining a list of encountered domains. Uses early-return optimization: returns True immediately upon finding a duplicate domain (when `cookie.domain` already exists in the domains list). Appends each domain to the tracking list and returns False if iteration completes without finding duplicates. Note: The docstring is misleading - the function actually checks for duplicate domains, not multiple unique domains."
      },
      "get_dict": {
        "human": "Filters through a collection of cookies and creates a simple dictionary containing only the cookies you're interested in. You can optionally specify which website (domain) and which part of the website (path) the cookies should be from. If you don't specify anything, it returns all cookies as name-value pairs.",
        "technical": "Iterates through cookie objects in self (likely a CookieJar), applying optional domain and path filters using equality comparison. Builds and returns a dictionary where keys are cookie.name and values are cookie.value. Filters are applied with short-circuit evaluation - both domain and path must match if provided, otherwise all cookies pass through."
      },
      "__contains__": {
        "human": "Checks if a specific item (like a cookie name) exists in a collection. If there's a conflict where multiple items have the same name, it still reports that the item exists rather than raising an error. This allows the program to continue working even when there are duplicate entries.",
        "technical": "Implements the `__contains__` method (enables `in` operator) by delegating to parent class's `__contains__`. Catches `CookieConflictError` exceptions that occur when duplicate cookie names exist and returns `True` in those cases, effectively treating conflicts as positive membership. Returns boolean indicating membership status. Uses try-except for exception-based control flow."
      },
      "__getitem__": {
        "human": "Allows you to retrieve a cookie by its name using square bracket notation (like `cookies[name]`), similar to how you'd look up a value in a dictionary. This is a convenience feature that makes the code easier to read and write. However, it will raise an error if multiple cookies share the same name, ensuring you don't accidentally get the wrong cookie.",
        "technical": "Implements the `__getitem__` magic method to enable dictionary-style indexing syntax on the cookie container object. Delegates to `_find_no_duplicates(name)` which performs a linear search (O(n) complexity) through the cookie collection and raises an exception if duplicate cookie names exist. Returns the single matching cookie object or raises an error for duplicates/missing cookies."
      },
      "__setitem__": {
        "human": "Allows you to add a cookie to a cookie jar using dictionary-style syntax (like `jar['cookie_name'] = value`). This makes the cookie jar behave like a regular Python dictionary, so you can store cookies using familiar square bracket notation. If a cookie with that name already exists, it will raise an error to prevent accidental overwrites.",
        "technical": "Implements the `__setitem__` magic method to enable dictionary-style assignment syntax for the cookie jar object. Delegates to the internal `self.set(name, value)` method which handles the actual cookie storage logic and enforces uniqueness constraints. The method signature accepts any type for name and value parameters, returning None as a standard setter operation."
      },
      "__delitem__": {
        "human": "Removes a cookie from storage by its name, similar to deleting an item from a dictionary. This allows the application to forget specific cookies, such as when a user logs out or when outdated tracking information needs to be cleared. It's the standard way to delete cookies using Python's dictionary-like syntax (e.g., `del cookies['session_id']`).",
        "technical": "Implements the `__delitem__` magic method to enable dictionary-style deletion syntax on a cookie container object. Delegates to the `remove_cookie_by_name()` helper function, passing `self` (the cookie jar instance) and the cookie `name` as arguments. This is a thin wrapper that provides Pythonic interface over the underlying `http.cookiejar.CookieJar` functionality. Returns None; modifies the cookie jar in-place as a side effect."
      },
      "set_cookie": {
        "human": "This function fixes a formatting issue with cookie values before saving them. When a cookie's value is wrapped in double quotes, it removes any escaped quote marks (backslash-quote combinations) from inside the value. This prevents double-escaping problems that can occur when storing cookies. After cleaning up the value, it saves the cookie normally.",
        "technical": "Overrides parent class's set_cookie method to preprocess cookie values. Checks if cookie.value has string methods and is quote-delimited (starts and ends with `\"`). If true, strips escaped quotes (`\\\"`) by replacing them with empty strings using `cookie.value.replace('\\\\\"', \"\")`. Delegates actual cookie setting to parent class via `super().set_cookie(cookie, *args, **kwargs)`. Returns result from parent's set_cookie method."
      },
      "update": {
        "human": "Merges cookies from another source into the current cookie collection. If the source is a specialized cookie container, it copies each cookie individually to preserve their properties. If it's a regular dictionary-like object, it uses the standard merging process. This allows the cookie jar to accept cookies from different types of sources.",
        "technical": "Performs type-conditional merge operation on cookie storage. Uses `isinstance()` to check if `other` is a `cookielib.CookieJar`; if true, iterates through cookies and calls `self.set_cookie()` with `copy.copy()` to create deep copies. Otherwise, delegates to parent class's `update()` method via `super()` for dict-like objects. Modifies internal state by adding/updating cookies without returning a value."
      },
      "_find": {
        "human": "Searches through a collection of cookies to find one that matches the given name, and optionally a specific domain and path. If multiple cookies match, it simply returns the first one it finds. This is used internally by the Requests library when it needs to retrieve a cookie's value. If no matching cookie exists, it reports an error.",
        "technical": "Iterates through cookie collection using iter(self), performing sequential matching on cookie.name (required), cookie.domain (if specified), and cookie.path (if specified). Returns the value attribute of the first matching cookie object. Raises KeyError with formatted string containing all search parameters if no match is found. No duplicate detection - returns first match arbitrarily when multiple cookies satisfy criteria."
      },
      "_find_no_duplicates": {
        "human": "Searches through a collection of cookies to find one that matches the given name, and optionally a specific domain and path. If it finds exactly one matching cookie, it returns its value. If no cookie matches, it reports an error. If multiple cookies match the same criteria, it also reports an error to prevent confusion about which cookie value to use.",
        "technical": "Iterates through cookie collection using `iter(self)`, filtering by name (required) and optionally domain/path using nested conditionals. Tracks matches in `toReturn` variable; raises `CookieConflictError` if multiple cookies match the criteria, `KeyError` if no matches found. Returns `cookie.value` of the single matching cookie. Note: Contains a bug where `if toReturn:` should be `if toReturn is not None:` to handle falsy cookie values."
      },
      "__getstate__": {
        "human": "Prepares this cookie storage object to be saved to disk or transferred between programs. It creates a safe copy of the object's data by removing a component (a lock) that can't be saved, allowing the cookie jar to be preserved and restored later unlike standard cookie jars.",
        "technical": "Implements pickle serialization protocol by creating a shallow copy of the instance dictionary using `self.__dict__.copy()`, then removes the `_cookies_lock` RLock object (which is not serializable) via `state.pop(\"_cookies_lock\")`. Returns the modified state dictionary that can be pickled. Works in conjunction with `__setstate__` to enable full pickle support for the CookieJar subclass."
      },
      "__setstate__": {
        "human": "Restores a CookieJar object from saved data (like when loading from a file). This is part of making cookies saveable and loadable, which normal cookie storage doesn't support. It rebuilds the object's internal state and ensures the thread-safety lock exists, which is needed when multiple parts of a program access cookies simultaneously.",
        "technical": "Implements pickle deserialization protocol by restoring instance state from the `state` dictionary via `__dict__.update()`. Performs defensive initialization by checking if `_cookies_lock` exists in the restored state, and creates a new `threading.RLock()` if missing (handles backward compatibility or corrupted pickle data). No return value; modifies instance state in-place as a side effect."
      },
      "copy": {
        "human": "Creates a duplicate copy of a cookie jar that stores web cookies. This is useful when you need to preserve the original set of cookies while making changes to a separate copy, similar to photocopying a document so you can mark up one version while keeping the original intact.",
        "technical": "Instantiates a new RequestsCookieJar object, copies the cookie policy from the current instance using get_policy() and set_policy(), then transfers all cookie data via update(). Returns the new independent cookie jar instance with identical policy settings and cookie contents. No side effects on the original object."
      },
      "get_policy": {
        "human": "This function provides access to the cookie policy settings that control how cookies are handled. It's like asking \"what are the rules for managing cookies?\" and getting back the rulebook that's currently being used. This allows other parts of the program to check or use the same cookie handling rules.",
        "technical": "Simple getter method that returns the private instance variable `self._policy` containing a CookiePolicy object. No computation, validation, or side effects - performs direct attribute access and return. The CookiePolicy instance is stored internally and this method provides read-only external access to it."
      }
    },
    "src/requests/exceptions.py": {
      "__init__": {
        "human": "This is a constructor that creates a special error object for handling invalid JSON data. It carefully combines two different types of error information - one specific to JSON problems and one for general input/output errors - to ensure the detailed JSON error message is preserved and displayed correctly to users when something goes wrong with JSON parsing.",
        "technical": "Initializes a dual-inheritance exception class by first calling `CompatJSONDecodeError.__init__()` with all positional arguments, then calling `InvalidJSONError.__init__()` with the processed `self.args` from the first initialization plus any keyword arguments. This two-step initialization ensures JSONDecodeError-specific arguments (like position, line number) are properly handled while preventing them from being misinterpreted as IOError parameters, preserving the formatted error message from the JSON decoder."
      },
      "__reduce__": {
        "human": "This function ensures that when the object is saved (pickled) for storage or transfer, it uses the correct saving method. It specifically uses the JSONDecodeError's saving approach instead of the default one that would normally be used, which prevents errors when the object is later restored. This is necessary because different parent classes have different requirements for how they should be saved.",
        "technical": "Overrides the `__reduce__` method to explicitly delegate pickle serialization to `CompatJSONDecodeError.__reduce__()` instead of allowing Python's Method Resolution Order (MRO) to select IOError's implementation. This ensures the pickled object includes all arguments required by JSONDecodeError's constructor rather than IOError's single-argument constructor. Returns the result of the parent class's `__reduce__` method for proper serialization."
      }
    },
    "src/requests/help.py": {
      "_implementation": {
        "human": "Identifies which version of Python your program is currently running on and what type of Python interpreter is being used (like CPython or PyPy). This is useful when you need to know the exact Python environment, similar to checking which version of an app you have installed. It packages this information into an easy-to-read format showing both the interpreter name and its version number.",
        "technical": "Retrieves Python implementation name via `platform.python_implementation()`, then determines version string based on implementation type. For CPython, uses `platform.python_version()`. For PyPy, constructs version from `sys.pypy_version_info` tuple (major.minor.micro) and appends release level if non-final. Falls back to `platform.python_version()` for Jython/IronPython or \"Unknown\" for unrecognized implementations. Returns dict with 'name' and 'version' keys."
      },
      "info": {
        "human": "Collects diagnostic information about the Python environment and installed libraries to help troubleshoot issues. Gathers details like operating system type, Python version, and versions of networking/security libraries (urllib3, SSL, cryptography, etc.). This information is useful when reporting bugs because it shows exactly what software versions are being used.",
        "technical": "Retrieves system metadata via platform.system/release() and _implementation(), then queries version attributes from multiple optional dependencies (OpenSSL, cryptography, idna, charset_normalizer, chardet). Converts SSL version numbers to hexadecimal format. Returns a dictionary containing platform info, implementation details, SSL configuration, and version strings for all relevant libraries. Handles missing modules gracefully by setting version fields to None."
      },
      "main": {
        "human": "This function displays bug-related information in a readable, organized format on the screen. It takes system or application diagnostic data and presents it in a structured way that's easy to read and share. Think of it as creating a neatly formatted report that shows technical details about bugs or system information.",
        "technical": "Calls the `info()` function to retrieve bug/system information (likely returns a dictionary), serializes it to JSON format using `json.dumps()` with alphabetically sorted keys and 2-space indentation for readability, then outputs the formatted JSON string to stdout via `print()`. Returns None; primary side effect is console output of formatted diagnostic data."
      }
    },
    "src/requests/hooks.py": {
      "dispatch_hook": {
        "human": "This function acts as a flexible event system that allows custom code to process and modify data at specific points in a program. When triggered with a key (like \"response\" or \"request\"), it looks up any registered callback functions for that key and runs them in sequence, allowing each one to transform the data before passing it to the next one.",
        "technical": "Retrieves hooks from a dictionary using the provided key, normalizes single callables into a list, then iterates through each hook function passing hook_data and kwargs. Each hook can return modified data which replaces hook_data for subsequent hooks; if a hook returns None, the original data is preserved. Returns the final transformed hook_data after all hooks execute, or the original data if no hooks are registered."
      }
    },
    "src/requests/models.py": {
      "path_url": {
        "human": "Extracts and reconstructs just the path and query string portion of a full URL, removing the domain and protocol parts. For example, if given \"https://example.com/page?id=5\", it returns \"/page?id=5\". This is useful when you need to work with only the resource location part of a URL without the server information. If no path exists in the URL, it defaults to using \"/\" (the root path).",
        "technical": "Parses the instance's URL using `urlsplit()` to extract path and query components. Builds a list by appending the path (defaulting to \"/\" if empty), then conditionally appends \"?\" and the query string if present. Returns the joined string representation. Uses list building with `join()` for efficient string concatenation rather than repeated string addition. Returns a string containing only the path and query portions of the original URL."
      },
      "_encode_params": {
        "human": "Prepares data for sending in a web request by converting it into a URL-friendly format. Takes various types of input (text, files, or structured data like dictionaries) and either leaves them as-is or converts them into properly encoded key-value pairs. Handles special cases like multiple values for the same key and ensures text is properly encoded in UTF-8 format.",
        "technical": "Performs conditional encoding based on input type: returns strings/bytes/file-like objects unchanged, processes iterables through to_key_val_list() conversion. Handles multi-value parameters by wrapping non-iterables in lists, filters out None values, encodes string keys/values to UTF-8 bytes, and returns urlencode() result with doseq=True. Falls through to return unmodified data for unrecognized types."
      },
      "_encode_files": {
        "human": "Prepares files and form data to be uploaded through a web request, like when you attach files to an online form. It takes your regular form fields (like text boxes) and file attachments, then packages everything together in a special format that web servers understand. Handles different ways files can be provided (with or without filenames, content types, and custom settings) and ensures everything is properly formatted for transmission.",
        "technical": "Converts form data and files into multipart/form-data format for HTTP requests. Normalizes both data and files to key-value lists, processes form fields by encoding strings to UTF-8 bytes, then handles file entries supporting 2-4 tuple formats (filename, fileobj, content_type, headers). Reads file content from file-like objects or uses raw data, creates RequestField objects with make_multipart(), and calls encode_multipart_formdata() to generate final body and content-type header. Returns tuple of (body, content_type)."
      },
      "register_hook": {
        "human": "This function adds callback functions (hooks) to a system that responds to specific events. Think of it like registering listeners for notifications - when certain events happen, the registered functions will be called. It validates that the event exists and accepts either a single function or a list of functions to register. If the event name is invalid, it stops and reports an error.",
        "technical": "Validates that the specified event exists in `self.hooks` dictionary, raising `ValueError` if not found. Accepts hook parameter as either a single `Callable` object (appended directly) or an iterable collection (filters for `Callable` items using generator expression and extends the event's hook list). Modifies `self.hooks[event]` list in-place as a side effect. Returns `None`. Non-callable items in iterables are silently ignored during registration."
      },
      "deregister_hook": {
        "human": "Removes a previously registered callback function (hook) from a specific event's list of listeners. This is used when you no longer want a particular function to be triggered when an event occurs. Returns True if the removal was successful, or False if the hook wasn't found in the list.",
        "technical": "Attempts to remove a hook from the self.hooks[event] list using the list.remove() method. Catches ValueError exception if the hook doesn't exist in the list, returning False in that case. Returns True on successful removal. Note: The docstring mentions a return value, but the function signature shows None as return type, indicating a signature mismatch."
      },
      "__init__": {
        "human": "Sets up a blank container to store information about a web server's response to a request. This creates empty slots for all the important details like the status code (whether the request succeeded or failed), headers, cookies, the actual content, and how long the request took. Think of it as preparing an empty form that will be filled in when a website responds to your request.",
        "technical": "Initializes a Response object with default values for all HTTP response attributes. Sets status_code, url, encoding, raw, reason, and request to None; creates empty CaseInsensitiveDict for headers; initializes empty history list; creates empty CookieJar via cookiejar_from_dict({}); sets elapsed time to zero timedelta; and initializes internal state flags (_content, _content_consumed, _next) for content management."
      },
      "prepare": {
        "human": "This function sets up an HTTP request by organizing all its components in the correct order before sending it. It takes various pieces like the web address, request type (GET/POST), headers, data to send, and authentication details, then arranges them properly. The function ensures authentication happens at the right time and that all hooks (custom actions) are added last so they can work with the fully prepared request.",
        "technical": "Orchestrates HTTP request preparation by sequentially calling six preparation methods: prepare_method(), prepare_url() (with params), prepare_headers(), prepare_cookies(), prepare_body() (with data/files/json), and prepare_auth() (with url). Critically, prepare_auth() executes second-to-last to enable OAuth-style schemes that need access to the complete request, while prepare_hooks() runs last so authenticators can inject hooks. Mutates self state; returns None."
      },
      "copy": {
        "human": "Creates a duplicate copy of a prepared HTTP request. This is useful when you need to send the same request multiple times or modify a request without affecting the original. It's like making a photocopy of a form before filling it out, so you can keep the blank original.",
        "technical": "Creates a shallow copy of a PreparedRequest object by instantiating a new PreparedRequest and copying over all attributes (method, url, headers, cookies, body, hooks, body_position). Uses headers.copy() for dictionary duplication and _copy_cookie_jar() for cookie jar cloning. Returns the new PreparedRequest instance with identical state to the original."
      },
      "prepare_method": {
        "human": "This function standardizes how HTTP methods (like GET, POST, PUT) are stored before making a web request. It takes whatever method name you provide and converts it to uppercase letters in a standard text format, ensuring consistency. For example, if you pass in \"get\" or \"Get\", it will store it as \"GET\". This prevents errors that could happen from inconsistent formatting.",
        "technical": "Assigns the provided HTTP method to `self.method` instance attribute. If method is not None, applies two transformations: (1) converts to uppercase using `.upper()` method, (2) converts to native string format via `to_native_string()` helper function (likely handles Python 2/3 compatibility for string types). Modifies object state directly with no return value. Ensures HTTP method is stored in standardized uppercase native string format."
      },
      "_get_idna_encoded_host": {
        "human": "Converts international domain names (like websites with non-English characters) into a standardized format that computers can understand and process. This allows URLs with special characters from languages like Chinese, Arabic, or Russian to work properly in web applications. If the conversion fails, it raises an error to indicate the domain name is invalid.",
        "technical": "Encodes a hostname using IDNA (Internationalized Domain Names in Applications) protocol with UTS46 compatibility mode. Calls `idna.encode()` with `uts46=True` parameter, then decodes the result from bytes to UTF-8 string. Catches `idna.IDNAError` exceptions and re-raises them as generic `UnicodeError`. Returns the ASCII-compatible encoded hostname string. Note: Function signature incorrectly shows `-> None` return type despite returning a string."
      },
      "prepare_url": {
        "human": "Takes a web address (URL) and optional parameters, then cleans and validates it to ensure it's properly formatted for making an HTTP request. Handles different text formats, removes extra spaces, checks that the URL has required parts like \"http://\" and a domain name, converts international domain names to the correct format, and adds any extra parameters to the URL. Stores the final cleaned URL for later use.",
        "technical": "Normalizes and validates HTTP URLs by: decoding bytes to UTF-8, stripping whitespace, parsing URL components via parse_url(), validating scheme and host presence, applying IDNA encoding to non-ASCII hostnames via _get_idna_encoded_host(), reconstructing netloc from auth/host/port, encoding query parameters via _encode_params(), merging with existing query string, and reassembling via urlunparse() and requote_uri(). Sets self.url as side effect. Raises MissingSchema or InvalidURL for malformed inputs."
      },
      "prepare_headers": {
        "human": "Takes a collection of HTTP headers and prepares them for use in a web request. It validates that each header is properly formatted, converts header names to a standard text format, and stores them in a special dictionary that treats uppercase and lowercase letters the same way (so \"Content-Type\" and \"content-type\" are treated as identical).",
        "technical": "Initializes self.headers as a CaseInsensitiveDict, then iterates through input headers dictionary using .items(). For each header tuple, calls check_header_validity() to ensure compliance, unpacks into name/value pairs, converts header name to native string format via to_native_string(), and stores in the case-insensitive dictionary. Modifies instance state by setting self.headers; returns None."
      },
      "prepare_body": {
        "human": "Prepares the body content of an HTTP request based on what type of data you're sending. It handles three main scenarios: sending JSON data, streaming large files or data, or sending regular form data with optional file uploads. It also sets the appropriate headers to tell the server what kind of data is being sent and how large it is.",
        "technical": "Processes HTTP request body by handling three data types: (1) JSON - serializes via complexjson.dumps and UTF-8 encodes, (2) streams - detects iterables, calculates length via super_len, sets Content-Length or Transfer-Encoding:chunked, records file position via tell(), (3) regular data - encodes multipart files via _encode_files or URL-encodes params via _encode_params. Sets Content-Type header appropriately and assigns final body to self.body. Raises InvalidJSONError for invalid JSON and NotImplementedError for stream+file combinations."
      },
      "prepare_content_length": {
        "human": "This function figures out how large the data being sent in a web request is and adds that information to the request headers. If there's actual content to send, it measures it and records the size. If there's no content but the request type normally allows content (like POST requests), it explicitly marks the size as zero so the receiving server knows nothing is coming.",
        "technical": "Sets the Content-Length HTTP header based on request body presence and HTTP method. For non-None bodies, calls super_len() to calculate length and sets header using builtin_str() conversion. For None bodies with methods other than GET/HEAD (which shouldn't have bodies), explicitly sets Content-Length to \"0\" if not already present. Modifies self.headers dictionary in-place; returns None."
      },
      "prepare_auth": {
        "human": "This function sets up authentication credentials for an HTTP request. If no authentication is provided directly, it first tries to extract username and password from the URL itself (like http://user:pass@example.com). It then applies the authentication method to the request and updates the request's properties accordingly, including recalculating the content length since authentication might modify the request body or headers.",
        "technical": "Extracts auth credentials from URL via `get_auth_from_url()` if auth parameter is None. Converts tuple credentials (username, password) to `HTTPBasicAuth` object. Calls the auth callable with self as argument, which returns a modified request object. Updates instance attributes via `self.__dict__.update(r.__dict__)` to apply auth changes. Invokes `self.prepare_content_length()` to recalculate Content-Length header after authentication modifications. Mutates self in-place; returns None."
      },
      "prepare_cookies": {
        "human": "Takes cookie data provided by the user and prepares it for inclusion in an HTTP request. Converts cookies into the proper format if needed, then generates a \"Cookie\" header that will be sent with the web request. This allows websites to recognize returning users and maintain login sessions or preferences.",
        "technical": "Accepts cookies as either a CookieJar object or dict-like structure. If not already a CookieJar, converts input using `cookiejar_from_dict()`. Calls `get_cookie_header()` to serialize cookies into HTTP header format. Sets the \"Cookie\" header in `self.headers` dictionary if cookie_header is not None. Stores the CookieJar in `self._cookies` for potential reuse."
      },
      "prepare_hooks": {
        "human": "Sets up event-based callbacks (hooks) for an object by registering them one by one. If no hooks are provided, it safely handles that by doing nothing. This allows the object to respond to different events (like \"before request\" or \"after response\") by executing custom code that was registered for each event type.",
        "technical": "Iterates over a dictionary of hooks where keys are event names and values are callback functions. Normalizes None input to empty list to avoid iteration errors. Calls `self.register_hook(event, hooks[event])` for each event-callback pair to register them with the object. No return value; modifies object state through side effects of `register_hook()` method."
      },
      "__getstate__": {
        "human": "Prepares an object to be saved or copied by collecting its important data. Before saving, it makes sure any content that was supposed to be read has actually been read completely. This is like making sure you've finished reading a document before filing it away, so nothing gets lost.",
        "technical": "Implements pickle serialization protocol by returning object state as a dictionary. Forces lazy-loaded content consumption by accessing `self.content` if `_content_consumed` flag is False. Uses dictionary comprehension with `getattr()` to extract all attributes listed in `self.__attrs__`, defaulting to None for missing attributes. Returns serializable state dictionary for pickling."
      },
      "__setstate__": {
        "human": "This function restores an object from a saved state (like when loading from a file). It takes all the saved properties and puts them back into the object. After restoring, it marks that the content has already been read and clears out any raw data reference, since saved objects don't preserve that information.",
        "technical": "Implements pickle deserialization protocol by iterating through state dictionary and using setattr() to restore each attribute to the instance. Post-restoration, explicitly sets `_content_consumed` flag to True and `raw` attribute to None to handle attributes that aren't preserved during pickling. Modifies object state in-place with no return value."
      },
      "__bool__": {
        "human": "This function allows a response object to be used in true/false checks (like in if-statements). It tells you whether an HTTP request was successful by returning True if there were no client or server errors. For example, you can write \"if response:\" to check if a web request worked properly, without needing to check the specific status code.",
        "technical": "Implements the `__bool__` magic method to enable truthiness evaluation of response objects. Delegates to the `self.ok` property, which evaluates whether `status_code < 400`. Returns boolean indicating success (True for 2xx-3xx status codes, False for 4xx-5xx). Enables Pythonic conditional checks like `if response:` instead of explicit status code comparisons."
      },
      "__nonzero__": {
        "human": "This function allows a response object to be used in true/false checks (like in if-statements). It returns True when the HTTP request was successful (no client or server errors), and False when there was an error. This lets you write simple code like \"if response:\" to check if a web request worked properly.",
        "technical": "Implements Python's `__nonzero__` magic method (Python 2 boolean conversion) by delegating to the `self.ok` property. Returns the boolean value of `self.ok`, which evaluates whether `status_code` is less than 400. This enables truthiness testing of response objects in conditional expressions. Note: Python 3 uses `__bool__` instead of `__nonzero__`."
      },
      "__iter__": {
        "human": "Makes the response object work with Python's for-loop syntax, allowing you to process the response data piece by piece instead of all at once. This is useful when dealing with large responses (like downloading big files) because you can handle the data in small chunks without loading everything into memory at once.",
        "technical": "Implements the iterator protocol by returning the result of `self.iter_content(128)`, which yields the response body in 128-byte chunks. This allows the response object to be used in iteration contexts (for-loops, list comprehensions). The chunk size of 128 bytes provides a balance between memory efficiency and iteration overhead. No side effects beyond initiating content streaming."
      },
      "ok": {
        "human": "Checks whether a web request was successful or not. Returns a simple yes/no answer based on whether the server responded with an error. This helps programs quickly determine if they should proceed with using the response data or handle a problem. It's like checking if a webpage loaded correctly before trying to read its content.",
        "technical": "Property method that returns a boolean indicating HTTP response success by delegating to `raise_for_status()` within a try-except block. Catches `HTTPError` exceptions (raised for 4xx/5xx status codes) and returns False; returns True if no exception occurs. Provides a non-throwing alternative to `raise_for_status()` for status code validation without explicit status code comparison."
      },
      "is_redirect": {
        "human": "Checks whether a web server's response is telling the browser to go to a different web page. This happens when you click a link and get automatically sent somewhere else. The function looks for two things: a \"location\" (the new address to go to) and a special status code that means \"redirect.\"",
        "technical": "Property method that returns a boolean indicating if the HTTP response is a valid redirect. Performs two checks: (1) verifies \"location\" header exists in self.headers dictionary, and (2) confirms self.status_code is in the REDIRECT_STATI collection (likely contains codes like 301, 302, 303, 307, 308). Returns True only when both conditions are met via short-circuit AND evaluation."
      },
      "is_permanent_redirect": {
        "human": "Checks whether a web page has been moved to a new location permanently (as opposed to temporarily). This is useful when a website needs to know if a redirect is meant to last forever, so it can update bookmarks or links accordingly. Returns a simple yes/no answer based on the server's response.",
        "technical": "Returns a boolean indicating if the HTTP response is a permanent redirect by checking two conditions: (1) presence of a \"location\" header in self.headers, and (2) status_code matching either codes.moved_permanently (301) or codes.permanent_redirect (308). Uses short-circuit evaluation with 'and' operator, returning True only when both conditions are met."
      },
      "next": {
        "human": "This function retrieves the next web request that should be made when a website redirects you to another page. When you click a link and get automatically sent to a different URL, this helps track what that next destination is. It simply returns whatever next request was previously stored, or nothing if there are no more redirects to follow.",
        "technical": "Property getter that returns the value of the private instance variable `_next`. Acts as read-only accessor for a PreparedRequest object representing the next request in an HTTP redirect chain. No computation or validation performed - directly returns the stored reference. Returns None if no redirect exists. Part of the property pattern for controlled attribute access."
      },
      "apparent_encoding": {
        "human": "Detects what character encoding (like UTF-8, ASCII, etc.) the content is likely written in by analyzing the raw data. This helps the program correctly interpret text that might be in different languages or formats. If no detection tool is available, it assumes the content is in UTF-8, the most common modern encoding standard.",
        "technical": "Property method that attempts to detect character encoding of `self.content` using the chardet library's `detect()` function, extracting the \"encoding\" key from the returned dictionary. Falls back to hardcoded \"utf-8\" string if chardet is not installed/imported. Returns a string representing the detected or default encoding name. No side effects; performs read-only detection on existing content."
      },
      "iter_content": {
        "human": "This function allows you to read large HTTP response data piece by piece instead of loading everything into memory at once. It's like reading a book page by page rather than trying to memorize the entire book. You can control how much data to read at a time, and optionally convert the raw bytes into readable text. This prevents your computer from running out of memory when downloading large files.",
        "technical": "Implements a generator that yields HTTP response data in chunks. Validates chunk_size parameter type, checks if stream was already consumed via `_content_consumed` flag. Uses `self.raw.stream()` for urllib3 objects or `self.raw.read()` for file-like objects, wrapping protocol-specific exceptions (ProtocolError, DecodeError, SSLError) into requests library exceptions. Returns either reused chunks from `self._content` or fresh stream chunks, optionally passing through `stream_decode_response_unicode()` for character decoding."
      },
      "iter_lines": {
        "human": "Reads through a large response (like from a web request) and breaks it into individual lines, delivering them one at a time. This prevents your computer from running out of memory when dealing with huge responses, since it processes small chunks instead of loading everything at once. It handles cases where lines might be split across chunks by remembering incomplete lines and combining them with the next chunk.",
        "technical": "Generator function that wraps `self.iter_content()` to yield line-by-line data from chunked response content. Maintains a `pending` buffer to handle lines split across chunk boundaries. Uses either custom `delimiter` or `splitlines()` to split chunks. Checks if last line is incomplete by comparing final characters of line and chunk, preserving incomplete lines in `pending` for concatenation with next chunk. Yields final pending content after iteration completes."
      },
      "content": {
        "human": "Retrieves the complete response body from a web request as raw bytes. It reads the data only once - if you try to access it again after it's been read, it will give you an error. This is like opening a letter: once you've read it, the content is stored so you don't need to open the envelope again.",
        "technical": "Lazy-loads response content by checking `_content` flag (False = not yet loaded). Raises RuntimeError if content was already consumed. For valid responses (status_code != 0, raw exists), iterates through response chunks via `iter_content(CONTENT_CHUNK_SIZE)` and joins them into a single bytes object. Sets `_content_consumed` flag to True and caches result in `_content` for subsequent property access. Returns None for empty/invalid responses."
      },
      "text": {
        "human": "Converts the raw response data from a web request into readable text that humans can understand. It automatically figures out what language encoding was used (like UTF-8 or Latin-1) to properly translate the bytes into characters. If the encoding can't be determined from the response headers, it makes an intelligent guess, and if all else fails, it does its best to show something readable rather than failing completely.",
        "technical": "Property that decodes `self.content` (bytes) to unicode string using encoding priority: explicit `self.encoding` from HTTP headers, fallback to `self.apparent_encoding` (auto-detected), or blind decoding. Uses `str()` constructor with `errors=\"replace\"` to handle decode failures gracefully. Catches `LookupError` (invalid encoding name) and `TypeError` (None encoding) to retry without explicit encoding. Returns empty string for empty content, otherwise returns decoded unicode string."
      },
      "json": {
        "human": "Converts a web response's content from JSON text format into usable Python data structures like dictionaries or lists. It intelligently handles different text encodings (UTF-8, UTF-16, UTF-32) that JSON might use, trying to detect the correct one automatically. If the content isn't valid JSON or can't be decoded properly, it raises an error to let you know something went wrong.",
        "technical": "Attempts to decode JSON response content with encoding detection fallback. First tries `guess_json_utf()` to detect UTF-8/16/32 encoding when no explicit encoding is set, then calls `complexjson.loads()` on the decoded bytes. Falls back to using `self.text` (with charset normalization) if UTF detection fails or encoding is already set. Wraps `JSONDecodeError` exceptions in `RequestsJSONDecodeError` to maintain consistent error handling. Passes through optional `**kwargs` to the underlying `json.loads()` call."
      },
      "links": {
        "human": "Extracts and organizes web links from an HTTP response's \"Link\" header. When a server sends multiple related URLs (like pagination links for \"next\" and \"previous\" pages), this function parses them and creates an easy-to-use dictionary where you can look up links by their relationship type (like \"next\", \"prev\", \"first\", \"last\").",
        "technical": "Retrieves the \"link\" header from response headers, passes it to `parse_header_links()` for parsing, then builds a dictionary mapping each link's \"rel\" attribute (or \"url\" if \"rel\" is missing) to its full link object. Returns empty dict if no Link header exists. Uses dictionary comprehension pattern with fallback key selection (`link.get(\"rel\") or link.get(\"url\")`)."
      },
      "raise_for_status": {
        "human": "Checks if a web request failed and raises an error if it did. When a website returns an error code (like 404 Not Found or 500 Server Error), this function creates a helpful error message that includes what went wrong and which website address caused the problem. It handles different text formats to ensure error messages display correctly regardless of how the server sent them.",
        "technical": "Validates HTTP response status codes and raises HTTPError for 4xx/5xx ranges. Decodes self.reason from bytes to string using UTF-8 with ISO-8859-1 fallback for localized server messages. Constructs error messages differentiating client errors (400-499) from server errors (500-599) with status code, reason, and URL. Raises HTTPError with formatted message and response object if status indicates failure, otherwise returns None silently."
      },
      "close": {
        "human": "Cleans up and releases a network connection when you're done using it, returning it to a shared pool so other requests can reuse it. If the connection wasn't fully read, it closes the raw connection first. This happens automatically in most cases, so you rarely need to call it yourself.",
        "technical": "Performs two-step connection cleanup: (1) If `_content_consumed` is False, explicitly closes the underlying `raw` connection object, (2) Uses `getattr` to safely check for a `release_conn` method on the raw object and calls it if present to return the connection to the pool. No return value; modifies state by closing resources and releasing pooled connections."
      },
      "generate": {
        "human": "This function reads data from a network response in small pieces (chunks) and delivers them one at a time, like streaming a video instead of downloading it all at once. It handles different types of errors that can occur during streaming (like connection problems or corrupted data) and converts them into more user-friendly error messages. Once all data has been read, it marks the content as fully consumed.",
        "technical": "Generator function that yields response content in chunks. Checks if `self.raw` has a `stream` method (urllib3 case) and uses it with `decode_content=True`, otherwise falls back to standard file-like `read()` operations. Wraps urllib3-specific exceptions (ProtocolError, DecodeError, ReadTimeoutError, SSLError) into requests library equivalents (ChunkedEncodingError, ContentDecodingError, ConnectionError, RequestsSSLError). Sets `self._content_consumed = True` flag after completion."
      }
    },
    "src/requests/sessions.py": {
      "merge_setting": {
        "human": "Combines configuration settings from two sources: individual request settings and session-wide settings. When both sources provide settings, it merges them intelligently - request settings take priority over session settings. If either setting is missing, it uses whichever one is available. For dictionary-type settings, it combines both dictionaries and removes any settings explicitly set to None.",
        "technical": "Implements three-way conditional logic: returns non-None setting if other is None, returns request_setting for non-Mapping types (prioritizing request over session), or performs dictionary merge for Mapping types. Converts both settings to key-value lists via `to_key_val_list()`, creates `dict_class` instance from session_setting, updates with request_setting (overwriting duplicates), then iterates through `merged_setting.items()` to identify and delete all None-valued keys. Returns merged dictionary or original setting based on type checks."
      },
      "merge_hooks": {
        "human": "Combines two sets of hooks (callbacks) - one from an individual request and one from a session - into a single set. It handles special cases where empty hooks from one source would accidentally erase valid hooks from the other source, ensuring that configured callbacks aren't lost during the merge process.",
        "technical": "Performs conditional merging of request_hooks and session_hooks dictionaries with special handling for empty 'response' arrays. Returns request_hooks if session_hooks is None or has empty response list, returns session_hooks if request_hooks is None or has empty response list, otherwise delegates to merge_setting() with dict_class (default OrderedDict) to perform the actual merge. Prevents edge case where empty hook dictionaries override valid session-level hooks."
      },
      "session": {
        "human": "Creates a new session object that helps manage a series of related web requests. Think of it like opening a browser tab that remembers your settings and cookies across multiple page visits. This is an older way of doing things - the library now recommends creating sessions directly using a different method.",
        "technical": "Factory function that instantiates and returns a new `Session` object. Simply wraps the `Session()` constructor call without any additional configuration or parameters. Marked as deprecated since version 1.0.0; users should directly instantiate `requests.sessions.Session` instead. Returns a Session instance with default configuration for managing HTTP request state."
      },
      "get_redirect_target": {
        "human": "Extracts the new web address (URL) from a server response when a webpage redirects you to a different location. This is like when you click a link and the website automatically sends you somewhere else - this function figures out where that \"somewhere else\" is. It handles a technical issue where the address might contain special international characters that need to be properly interpreted.",
        "technical": "Checks if response has `is_redirect` flag, then extracts 'location' header containing redirect URI. Performs character encoding correction by re-encoding from latin1 to UTF-8 via `location.encode(\"latin1\")` followed by `to_native_string(location, \"utf8\")` to handle non-ASCII characters in redirect URLs. Returns the corrected redirect URI string or None if response is not a redirect. No side effects or state modifications."
      },
      "should_strip_auth": {
        "human": "Determines whether login credentials (Authorization header) should be removed when a web request is redirected to a different URL. This protects security by removing credentials when redirecting to different servers, but keeps them when staying on the same server with minor changes like switching from http to https on standard ports. Prevents accidentally sending your login information to unintended websites.",
        "technical": "Parses old and new URLs using urlparse() to compare hostname, scheme, and port. Returns True (strip auth) if hostnames differ. Returns False for special cases: http\u2192https on standard ports (80\u2192443) or same-scheme redirects using default ports. Otherwise returns True if port or scheme changed. Uses DEFAULT_PORTS dictionary to handle implicit port numbers (None values treated as scheme defaults)."
      },
      "resolve_redirects": {
        "human": "Handles the process of following web redirects when a server responds with a \"redirect\" status code (like when a webpage has moved to a new address). It automatically follows the chain of redirects, updating URLs and request details at each step, while respecting limits on how many redirects to follow. It also manages cookies, authentication, and other request settings as it moves from one URL to the next.",
        "technical": "Generator function that iteratively follows HTTP redirects by parsing Location headers via `get_redirect_target()`. For each redirect: consumes response content, validates redirect count against `max_redirects`, normalizes URLs using `urlparse`/`urljoin`, handles relative/scheme-less URLs per RFC standards, rebuilds request method/auth/proxies, manages cookie extraction/merging via `extract_cookies_to_jar`, purges body-related headers for non-307/308 redirects, attempts body rewind for rewindable requests, and either yields prepared requests or sends them via `self.send()` based on `yield_requests` flag."
      },
      "rebuild_auth": {
        "human": "Manages login credentials when a web request gets redirected to a different website. If the redirect goes to a new host, it removes the existing login information to prevent accidentally sending your password to the wrong server. Then it checks if there are appropriate credentials available for the new destination and adds them if found.",
        "technical": "Handles authentication during HTTP redirects by conditionally stripping and reapplying auth headers. Calls `should_strip_auth()` to compare original and redirect URLs; if hosts differ, deletes the \"Authorization\" header from `prepared_request.headers`. If `trust_env` is enabled, attempts to retrieve credentials for the new URL via `get_netrc_auth()` and applies them using `prepared_request.prepare_auth()`. Modifies the request object in-place with no return value."
      },
      "rebuild_proxies": {
        "human": "Updates proxy settings when a web request gets redirected to a new URL. It checks if the new destination should use a proxy or not (based on environment settings like NO_PROXY), and adds the necessary username/password credentials to the request headers if needed. This ensures requests continue working properly through proxy servers even after being redirected.",
        "technical": "Re-evaluates proxy configuration by calling `resolve_proxies()` with current request and trust_env flag. Removes existing \"Proxy-Authorization\" header, extracts credentials from new proxy URL using `get_auth_from_url()`, and conditionally adds Basic Auth header via `_basic_auth_str()` for non-HTTPS schemes. Modifies `prepared_request.headers` in-place and returns updated proxy dictionary. Skips auth header for HTTPS to prevent credential leakage in TLS tunnels."
      },
      "rebuild_method": {
        "human": "Adjusts how a web request should be resent when a server redirects to a different page. When certain redirect codes are received (like 301, 302, or 303), the function automatically changes POST requests to GET requests to match how web browsers behave, even though this sometimes goes against official standards. This prevents errors when following redirects.",
        "technical": "Modifies the HTTP method of a prepared_request object based on response.status_code values. Implements three redirect handling rules: converts non-HEAD requests to GET for 303 (see_other), converts non-HEAD requests to GET for 302 (found), and converts POST to GET for 301 (moved). Directly mutates prepared_request.method property. Returns None; operates through side effects on the prepared_request parameter."
      },
      "__init__": {
        "human": "Sets up a new session for making web requests with sensible default settings. This is like preparing a web browser with standard configurations - it decides whether to follow redirects, how to handle security certificates, where to store cookies, and what information to send with each request. Think of it as creating a configured \"web client\" ready to communicate with websites.",
        "technical": "Initializes a Session object by setting instance attributes for HTTP request configuration. Creates default headers via `default_headers()`, initializes empty containers for auth/proxies/params/hooks, sets SSL verification to True and max redirects to `DEFAULT_REDIRECT_LIMIT` (30). Instantiates empty cookie jar using `cookiejar_from_dict({})`, creates `OrderedDict` for adapters, and mounts `HTTPAdapter()` instances for both \"https://\" and \"http://\" protocols to handle connection pooling."
      },
      "prepare_request": {
        "human": "Prepares an HTTP request for sending by combining the individual request details with the session's default settings. It handles merging cookies from multiple sources, sets up authentication credentials (including checking for stored passwords), and packages everything into a ready-to-send request object that includes all necessary headers, parameters, and data.",
        "technical": "Creates a PreparedRequest object by merging Request instance attributes with Session defaults. Converts cookie dict to CookieJar if needed, performs three-way cookie merge (empty jar \u2192 session cookies \u2192 request cookies), attempts netrc authentication if trust_env is enabled and no auth provided. Calls PreparedRequest.prepare() with merged headers (CaseInsensitiveDict), params, auth, hooks, and the merged cookies. Returns the fully prepared request object ready for transmission."
      },
      "request": {
        "human": "This function sends an HTTP request (like GET or POST) to a web server and waits for a response. It handles all the details of making web requests, including adding headers, authentication, file uploads, SSL certificates, and proxy settings. Think of it as the core function that powers web communication - when you want to fetch data from a website or send information to a server, this function does the heavy lifting.",
        "technical": "Creates a Request object with the provided HTTP method, URL, and parameters, then calls `prepare_request()` to format it for transmission. Merges environment settings (proxies, SSL verification, certificates) via `merge_environment_settings()`, combines them with timeout and redirect settings into `send_kwargs`, and dispatches the prepared request using `self.send()`. Returns a Response object containing the server's reply. The function acts as the primary request orchestrator, delegating preparation and transmission to specialized methods."
      },
      "get": {
        "human": "This function fetches a webpage or resource from the internet using a web address (URL). It's like clicking a link in your browser - you provide where you want to go, and it retrieves the content from that location. By default, it will automatically follow any redirects (like when a page has moved to a new address) to get you to the final destination.",
        "technical": "Wrapper method that performs HTTP GET requests by delegating to `self.request()` with method=\"GET\". Sets `allow_redirects=True` as default behavior via `kwargs.setdefault()`, which can be overridden by caller. Accepts arbitrary keyword arguments (**kwargs) that are passed through to the underlying `request()` method. Returns a Response object containing the server's response data."
      },
      "options": {
        "human": "Sends an OPTIONS request to a web server to ask what communication methods and features are available at a specific web address. This is like asking a website \"what can I do here?\" before actually doing anything. By default, it will automatically follow if the server redirects to a different address.",
        "technical": "Wrapper method that sends an HTTP OPTIONS request by calling `self.request()` with \"OPTIONS\" as the HTTP method. Sets `allow_redirects=True` as the default behavior using `kwargs.setdefault()`, which can be overridden by caller. Passes through all additional keyword arguments to the underlying `request()` method and returns a `requests.Response` object containing the server's response."
      },
      "head": {
        "human": "Retrieves only the header information from a web page without downloading the full content. This is useful when you want to check if a page exists, see when it was last modified, or get its size without wasting bandwidth downloading everything. By default, it won't follow redirects to other pages.",
        "technical": "Wrapper method that sends an HTTP HEAD request by calling `self.request()` with method=\"HEAD\". Sets `allow_redirects=False` as default via `kwargs.setdefault()` to prevent automatic redirect following. Accepts arbitrary keyword arguments that are passed through to the underlying `request()` method. Returns a Response object containing headers and metadata without response body."
      },
      "post": {
        "human": "This function sends information to a website or web service using the POST method, which is commonly used when submitting forms or uploading data. You can send data in two formats: regular form data or JSON (a structured data format). It's a convenient wrapper that handles the technical details of making a POST request and gives you back the server's response.",
        "technical": "Wrapper method that delegates to `self.request()` with HTTP method \"POST\" and forwards all parameters. Accepts URL as required parameter, optional `data` parameter for form/binary payloads, optional `json` parameter for JSON payloads, and passes through any additional keyword arguments to the underlying request method. Returns a `requests.Response` object containing the server's response. Part of the requests library's Session class interface."
      },
      "put": {
        "human": "This function allows you to update or replace information on a web server by sending a PUT request to a specific web address. It's like telling a website \"here's the new data I want you to store at this location.\" You provide the web address and the data you want to send, and it handles the communication with the server.",
        "technical": "Wrapper method that delegates to `self.request()` with HTTP method \"PUT\". Accepts a URL string, optional data payload (dict, tuples, bytes, or file-like object), and arbitrary keyword arguments. Passes all parameters through to the underlying `request()` method and returns the Response object. Acts as a convenience method to simplify PUT request syntax."
      },
      "patch": {
        "human": "This function allows you to update or modify existing information on a web server by sending a PATCH request to a specific web address. It's like editing a document that's already stored online - you send only the changes you want to make rather than replacing the entire document. You can include the data you want to update and any additional settings needed for the request.",
        "technical": "Wrapper method that delegates to `self.request()` with HTTP method \"PATCH\". Accepts a URL string, optional data parameter (dict, tuples, bytes, or file-like object) for the request body, and arbitrary keyword arguments passed through to the underlying request method. Returns a Response object from the requests library. Acts as a convenience method to simplify PATCH operations by pre-specifying the HTTP verb."
      },
      "delete": {
        "human": "This function allows you to delete a resource from a web server by sending a DELETE request to a specific web address (URL). It's like telling a website \"please remove this item\" - for example, deleting a user account, removing a file, or canceling a reservation. You provide the web address of what you want to delete, and it handles the communication with the server.",
        "technical": "Wrapper method that delegates to `self.request()` with HTTP method \"DELETE\" and the provided URL. Accepts arbitrary keyword arguments (`**kwargs`) which are passed through to the underlying `request()` method, allowing optional parameters like headers, authentication, or timeout settings. Returns a `requests.Response` object containing the server's response to the DELETE operation. Part of a session-based HTTP client interface."
      },
      "send": {
        "human": "Sends an HTTP request and receives the response back. It handles the complete lifecycle of making a web request: setting up connection details, sending the request through the appropriate network adapter, tracking how long it takes, managing cookies, and optionally following redirects to new URLs. It ensures the request is properly formatted and returns the final response after all redirects are complete.",
        "technical": "Validates request is PreparedRequest type, configures kwargs with session defaults (stream, verify, cert, proxies), selects appropriate adapter via get_adapter(), and invokes adapter.send(). Measures elapsed time using preferred_clock(), dispatches response hooks, extracts cookies to session jar, and conditionally resolves redirects via resolve_redirects() generator. Manages redirect history by shuffling response chain, stores _next for non-followed redirects, triggers content loading if not streaming, and returns final Response object."
      },
      "merge_environment_settings": {
        "human": "This function prepares network request settings by combining user-provided values with system environment variables and default settings. It checks if environment variables like proxy settings or SSL certificate paths should be used, then merges them with the user's preferences. This ensures requests work correctly in different environments (like corporate networks with proxies) without requiring manual configuration every time.",
        "technical": "Conditionally reads environment-based proxy settings via `get_environ_proxies()` and SSL certificate paths from `REQUESTS_CA_BUNDLE`/`CURL_CA_BUNDLE` environment variables when `self.trust_env` is True. Merges provided parameters (proxies, stream, verify, cert) with instance defaults using `merge_setting()`, following a priority order where explicit parameters override instance settings. Returns a dictionary containing the merged configuration values for use in HTTP requests."
      },
      "get_adapter": {
        "human": "This function finds the right network connection handler for a web address. It looks through a list of registered handlers (like one for \"http://\" and another for \"https://\") and picks the one that matches the beginning of the URL you're trying to access. If no handler matches your URL, it stops and reports an error saying it doesn't know how to connect to that type of address.",
        "technical": "Iterates through self.adapters dictionary (prefix-to-adapter mappings) performing case-insensitive prefix matching against the provided URL string using startswith(). Returns the first matching adapter object when url.lower() starts with a registered prefix.lower(). Raises InvalidSchema exception if no prefix matches, indicating no registered adapter can handle the URL scheme. Uses dictionary iteration order to determine adapter priority."
      },
      "close": {
        "human": "This function performs cleanup when you're done using a session. It goes through all the network connections (adapters) that were opened during the session and properly closes each one. This is like hanging up all phone lines when you're done making calls - it frees up resources and ensures nothing is left running in the background.",
        "technical": "Iterates through all adapter objects stored in the `self.adapters` dictionary using `.values()` method and calls the `.close()` method on each adapter instance. This performs cleanup of network connections/resources managed by each adapter. Returns None implicitly. Side effect: closes all active adapter connections, making the session unusable for subsequent requests."
      },
      "mount": {
        "human": "This function registers a connection adapter (a component that handles network requests) for a specific URL prefix (like \"http://\" or \"https://\"). It ensures that when multiple adapters are registered, they're organized so that more specific (longer) prefixes are checked first before more general (shorter) ones. This allows the system to match the most appropriate adapter for any given URL.",
        "technical": "Adds a prefix-adapter pair to `self.adapters` dictionary, then reorders the dictionary to maintain descending order by prefix length. Identifies all existing keys shorter than the new prefix using list comprehension with `len()` comparison, then uses `pop()` and reassignment to move those entries to the end of the dictionary. This maintains an OrderedDict-like behavior where longer prefixes appear first, enabling proper adapter matching precedence."
      },
      "__getstate__": {
        "human": "This function prepares an object to be saved or copied by collecting its important data. It goes through a list of the object's attributes (properties) and gathers their current values into a package that can be stored or transferred. This is commonly used when you need to save an object's state to a file or send it to another program.",
        "technical": "Implements Python's pickle protocol by returning a dictionary representation of the object's state. Uses dictionary comprehension to iterate over `self.__attrs__` (a predefined list of attribute names), calling `getattr(self, attr, None)` to retrieve each attribute's value (defaulting to None if missing). Returns the state dictionary which will be used during serialization/deserialization operations."
      },
      "__setstate__": {
        "human": "This function restores an object's saved state, typically when loading it from a file or database. It takes all the previously saved attributes and their values, and puts them back onto the object so it can continue working as it did before. This is commonly used when \"unpickling\" or deserializing objects in Python.",
        "technical": "Implements the pickle protocol's `__setstate__` method for custom deserialization. Iterates through the state dictionary (key-value pairs) and uses `setattr()` to dynamically assign each attribute name and value to the instance (`self`). This restores the object's internal state after unpickling. No return value; modifies object state in-place as a side effect."
      }
    },
    "src/requests/status_codes.py": {
      "_init": {
        "human": "Sets up a system where status codes (like HTTP codes) can be accessed by their names. For each code, it creates easy-to-use shortcuts so you can reference codes by their descriptive names instead of numbers. It also automatically generates documentation that lists all available codes and their associated names in a readable format.",
        "technical": "Iterates through `_codes` dictionary to dynamically set attributes on the `codes` object, mapping title strings to their numeric codes. Creates both original and uppercase versions of each title (unless starting with backslash/forward slash). Defines nested `doc()` function to format code documentation, then appends formatted list of all codes with their names to the module's `__doc__` string. Modifies global state through `setattr()` and `global __doc__` assignment."
      },
      "doc": {
        "human": "Creates a formatted documentation line that shows a numeric code and all the names associated with that code. It looks up the code in a reference list and presents the information in a bullet-point format with the names styled as code snippets. This helps display what different codes represent in a readable way.",
        "technical": "Retrieves a list of names from the `_codes` dictionary using the provided code as key, formats each name with double backticks (``name``) for markup styling, joins them with comma-space separators, and returns a formatted string in the pattern \"* {code}: {names}\". Uses list comprehension with f-strings for name formatting and string interpolation with % operator for final output."
      }
    },
    "src/requests/structures.py": {
      "__init__": {
        "human": "This is a setup function that runs when creating a new object. It allows you to give the object a name (optional) and then completes the basic setup by calling the parent class's initialization. Think of it like filling out a name tag and then completing standard registration paperwork when joining an organization.",
        "technical": "Constructor method that accepts an optional `name` parameter (defaults to None), assigns it to the instance attribute `self.name`, and invokes the parent class constructor via `super().__init__()`. Performs simple attribute initialization with no validation or transformation. No return value (standard for `__init__`). Ensures proper initialization chain in class hierarchy."
      },
      "__setitem__": {
        "human": "This function allows you to store a value with a key in a case-insensitive way. When you save something, it remembers both the original key (with its exact capitalization) and the value together. However, when looking things up later, it ignores whether letters are uppercase or lowercase, so \"Name\", \"name\", and \"NAME\" would all refer to the same stored item.",
        "technical": "Implements dictionary-style item assignment with case-insensitive key lookup. Calls `key.lower()` to normalize the key for storage indexing, then stores a tuple containing both the original key (preserving case) and the value in the `_store` dictionary. This allows case-insensitive retrieval while maintaining the original key format. Modifies internal state by updating `self._store`."
      },
      "lower_items": {
        "human": "This function provides a way to view all stored items (key-value pairs) with their keys converted to lowercase. It's useful when you need to access the data in a case-insensitive manner, ensuring all keys appear in lowercase regardless of how they were originally stored. This helps when you want consistent, lowercase key representation for display or comparison purposes.",
        "technical": "Returns a generator expression that iterates over `self._store.items()` and yields tuples of (lowercase_key, value). Accesses the internal `_store` dictionary structure where items are stored as (lowerkey, (original_key, value)) pairs, extracting `lowerkey` and `keyval[1]` (the actual value). No side effects; produces lazy iteration over transformed key-value pairs without modifying the underlying store."
      },
      "__eq__": {
        "human": "Compares two dictionary-like objects to see if they contain the same information, ignoring whether letters are uppercase or lowercase. For example, it would consider {\"Name\": \"John\"} and {\"name\": \"john\"} as equal. This allows flexible matching where capitalization differences don't matter.",
        "technical": "Implements equality comparison operator for CaseInsensitiveDict class. Converts the other operand to CaseInsensitiveDict if it's a Mapping, returns NotImplemented otherwise. Performs case-insensitive comparison by converting both objects to regular dicts using lower_items() method (which presumably lowercases keys) and comparing the resulting dictionaries. Returns boolean result of dict equality check."
      },
      "__getitem__": {
        "human": "This function allows you to access an object's properties using square bracket notation (like a dictionary), making it easier to retrieve values. If you ask for a property that doesn't exist, it simply returns None instead of causing an error. This provides a safe, forgiving way to look up information stored in the object.",
        "technical": "Implements the `__getitem__` magic method to enable dictionary-style access (`obj[key]`) on the object. Retrieves values from the instance's `__dict__` attribute using the `.get()` method with a default value of None. This allows graceful fallback behavior where non-existent keys return None rather than raising KeyError, making the object behave like a dictionary with lenient key access."
      }
    },
    "src/requests/utils.py": {
      "dict_to_sequence": {
        "human": "Converts dictionary-like objects into a format that can be easily looped through as pairs of items. If you give it a regular dictionary, it transforms it into a list of (key, value) pairs. If you give it something that's already in the right format (like a list of pairs), it just passes it through unchanged. This helps standardize different input types into one consistent format.",
        "technical": "Normalizes dictionary-like objects by checking for the `items()` method using `hasattr()`. If the object has an `items` attribute (typical of dict objects), calls `d.items()` to convert it to a dict_items view object containing (key, value) tuples. Otherwise, returns the input unchanged, allowing sequences like lists of tuples to pass through. Returns either dict_items view or the original input type."
      },
      "super_len": {
        "human": "Calculates how much data remains to be read from various types of objects (strings, files, streams). This is useful when uploading data to determine the \"Content-Length\" header for HTTP requests. It figures out the total size of the data and subtracts any portion that's already been read, giving you the remaining bytes to send.",
        "technical": "Determines remaining length of data objects by attempting multiple strategies: checks `__len__`, `.len` attribute, uses `os.fstat()` on file descriptors, or seeks to end of seekable streams. For urllib3 2.x+, encodes strings to UTF-8. Tracks current position via `.tell()` and calculates remaining bytes as `total_length - current_position`. Warns if files are opened in text mode instead of binary. Returns 0 for indeterminate lengths or negative results."
      },
      "get_netrc_auth": {
        "human": "Retrieves login credentials (username and password) for a website from your computer's netrc file, which is a special file that stores authentication information for different websites. It looks for this file in standard locations on your system, finds the credentials matching the website you're trying to access, and returns them so they can be used for automatic login. If the file doesn't exist or can't be read, it simply returns nothing instead of causing an error.",
        "technical": "Locates netrc file by checking NETRC environment variable or default locations (~/.netrc, ~/_netrc), expands paths and verifies existence. Parses URL to extract hostname using urlparse(), then calls netrc().authenticators(host) to retrieve credentials tuple. Returns (username, password) from the authenticators result, selecting non-null login value. Handles NetrcParseError, OSError, ImportError (App Engine), and AttributeError exceptions, suppressing them unless raise_errors=True. Returns None if no netrc file found or credentials unavailable."
      },
      "guess_filename": {
        "human": "Attempts to extract a filename from an object that might be a file. It looks for a \"name\" attribute on the object (like file objects have), checks if it's a valid filename string (not a special placeholder like \"<stdin>\"), and if so, returns just the filename part without any folder path. Returns nothing if the object doesn't have a usable filename.",
        "technical": "Uses `getattr()` to safely retrieve the \"name\" attribute from the input object. Validates that the name is a `basestring` (Python 2 string type) and not a special I/O descriptor (checks first/last characters aren't angle brackets). If valid, calls `os.path.basename()` to extract the filename component from a potential full path. Returns the basename string or implicitly returns `None` if validation fails."
      },
      "extract_zipped_paths": {
        "human": "This function helps access files that are stored inside ZIP archives. When you provide a path that points to a file inside a ZIP (like \"archive.zip/folder/file.txt\"), it extracts that specific file to a temporary location on your computer and gives you the new path. If the path is already valid or doesn't point to a ZIP file, it just returns the original path unchanged.",
        "technical": "Validates if path exists; if not, iteratively splits the path using os.path.split() to identify a valid ZIP archive portion and member name. Verifies archive with zipfile.is_zipfile() and checks member existence in zip_file.namelist(). Extracts the target member to tempfile.gettempdir() using atomic_open() to prevent race conditions, writing only the file (not directory structure) via zip_file.read(). Returns either the extracted temp path or original path if validation fails at any step."
      },
      "atomic_open": {
        "human": "This function provides a safe way to save files by writing to a temporary file first, then swapping it with the final file only if everything succeeds. This prevents corrupting or losing the original file if something goes wrong during writing (like a crash or power failure). If an error occurs, the temporary file is cleaned up and the original remains untouched.",
        "technical": "Context manager that implements atomic file writes using tempfile.mkstemp() to create a temporary file in the target directory. Yields a file handler opened in binary write mode for the caller to write data. On success, uses os.replace() to atomically swap the temp file with the target filename. On any exception, removes the temporary file via os.remove() and re-raises. Returns None as it's a generator-based context manager."
      },
      "from_key_val_list": {
        "human": "Converts various data structures (like lists of pairs or dictionaries) into a standardized ordered dictionary format. It acts as a safety filter that rejects simple data types (strings, numbers, etc.) that can't be meaningfully converted into key-value pairs. Returns None if given None, otherwise produces an OrderedDict that preserves the order of items.",
        "technical": "Validates input type and converts iterable key-value structures to OrderedDict. Returns None for None input. Raises ValueError for primitive types (str, bytes, bool, int) that cannot represent 2-tuples. Delegates to OrderedDict constructor for valid inputs (lists of tuples, dicts, or other iterables). Note: Function signature incorrectly shows return type as None; actually returns OrderedDict or None."
      },
      "to_key_val_list": {
        "human": "Converts different types of data structures into a standardized list of key-value pairs (tuples). It accepts dictionaries or lists of tuples and transforms them into a uniform format. This helps ensure data is in the right shape before processing, like when preparing data to send in a web request. Returns None if given None, but rejects simple values like strings or numbers that can't be converted into pairs.",
        "technical": "Normalizes input into a list of 2-tuples by handling three cases: returns None for None input, raises ValueError for scalar types (str, bytes, bool, int), and converts Mapping objects to list via .items(). For iterables already containing tuples, applies list() constructor directly. Uses isinstance() checks to determine type and appropriate conversion path. Returns list of tuples or None."
      },
      "parse_list_header": {
        "human": "Takes a comma-separated list from an HTTP header (like \"token1, token2, \"quoted value\"\") and breaks it into individual pieces. Handles the tricky case where some values are wrapped in quotes and might contain commas inside them. Automatically removes the surrounding quotes from quoted values and returns a clean list of items.",
        "technical": "Parses RFC 2068 compliant comma-separated header values into a list. Delegates initial parsing to `_parse_list_header()`, then iterates through results to detect quoted strings (items starting and ending with `\"`). For quoted items, strips outer quotes and calls `unquote_header_value()` to handle escape sequences. Appends processed items to result list and returns it. Preserves duplicates and case sensitivity."
      },
      "parse_dict_header": {
        "human": "Converts HTTP header strings containing key-value pairs (like those found in web requests) into a Python dictionary. Handles both pairs with values (foo=\"bar\") and keys without values (standalone_key). Removes quotes from values when present and properly formats the data for easy use in Python programs.",
        "technical": "Parses RFC 2068 compliant header strings by first splitting on commas via `_parse_list_header()`, then processing each item. Splits on \"=\" to separate keys from values; assigns None for keys without values. Detects quoted values by checking first/last characters for double quotes, strips them, and calls `unquote_header_value()` to handle escape sequences. Returns populated dictionary with processed key-value pairs."
      },
      "unquote_header_value": {
        "human": "Removes quotation marks from HTTP header values that were previously quoted, such as filenames in file uploads. It handles the way web browsers actually quote values (which doesn't strictly follow standards) to ensure compatibility with Internet Explorer and other browsers. Special care is taken with Windows network paths (UNC paths) to prevent breaking them during the unquoting process.",
        "technical": "Checks if value is wrapped in double quotes and strips them. For non-UNC-path cases, performs two replacements: converts escaped backslashes (`\\\\`) to single backslashes and escaped quotes (`\\\"`) to regular quotes. Returns early for UNC paths (starting with `\\\\`) when `is_filename=True` to preserve the leading double backslash. Returns the original value unchanged if not quoted. Uses string slicing and `str.replace()` for transformations."
      },
      "dict_from_cookiejar": {
        "human": "Converts a cookie jar (a collection of web cookies) into a simple dictionary format. Takes all the cookies stored in the jar and creates an easy-to-use lookup table where each cookie's name points to its value. This makes it simpler to work with cookies in your code, like checking what cookies a website has set.",
        "technical": "Iterates through a CookieJar object using dictionary comprehension to extract cookie name-value pairs. Creates and returns a dict where keys are `cookie.name` and values are `cookie.value` for each cookie in the jar. No validation or error handling; assumes the CookieJar is iterable and cookies have name/value attributes. Simple one-to-one mapping transformation."
      },
      "add_dict_to_cookiejar": {
        "human": "Takes an existing cookie storage container and adds new cookies to it from a simple dictionary of names and values. This allows you to easily insert multiple cookies at once into a cookie jar that's already being used, rather than creating a new one from scratch. It's a convenience function for merging cookie data.",
        "technical": "Delegates to `cookiejar_from_dict()` helper function, passing the input dictionary and existing CookieJar instance. Despite the docstring saying \"Returns a CookieJar\", the function actually modifies the existing `cj` parameter in-place and returns the result from `cookiejar_from_dict()`. Acts as a thin wrapper that reverses parameter order (dict first, jar second) compared to the underlying implementation."
      },
      "get_encodings_from_content": {
        "human": "Searches through HTML or XML content (like a webpage) to find what character encoding is being used. It looks for encoding information in meta tags and XML declarations, which tell computers how to properly read and display text characters. This function is deprecated and will be removed in a future version of the requests library.",
        "technical": "Compiles three regex patterns to extract charset/encoding declarations from HTML meta tags (both charset attribute and content pragma formats) and XML processing instructions. Uses case-insensitive matching (re.I flag) to find all encoding declarations in the content string. Returns a concatenated list of all matches found by the three patterns. Emits a DeprecationWarning indicating removal in requests 3.0. Note: function signature incorrectly shows return type as None when it actually returns a list."
      },
      "_parse_content_type_header": {
        "human": "Takes an HTTP Content-Type header string (like \"text/html; charset=utf-8\") and breaks it down into its main type and any additional settings. Separates the content type from its parameters (like character encoding or boundary markers), making them easy to access individually. This helps programs understand what kind of data they're receiving and how to handle it properly.",
        "technical": "Splits header string on semicolons to separate content type from parameters. Parses each parameter by finding \"=\" delimiter, extracting key-value pairs while stripping quotes, apostrophes, and whitespace. Handles parameters without values by setting them to True. Returns tuple of (content_type string, params_dict) where dictionary keys are lowercased. Uses string methods: split(), strip(), find(), and slice notation for parsing."
      },
      "get_encoding_from_headers": {
        "human": "Figures out what character encoding (like UTF-8 or ISO-8859-1) should be used to read text from a web response. It looks at the HTTP headers sent by the server, checking for explicit encoding information or making educated guesses based on the content type (like assuming UTF-8 for JSON data). This helps ensure text is displayed correctly instead of showing garbled characters.",
        "technical": "Extracts character encoding from HTTP headers dictionary by: (1) retrieving 'content-type' header, (2) parsing it via `_parse_content_type_header()` to separate media type and parameters, (3) returning charset parameter if present (stripped of quotes), (4) defaulting to 'ISO-8859-1' for text/* content types, (5) defaulting to 'utf-8' for application/json per RFC 4627, or (6) returning None if no content-type exists. Returns string encoding name or None."
      },
      "stream_decode_response_unicode": {
        "human": "Converts raw data chunks from a web response into readable text characters one piece at a time. If the response specifies a text encoding (like UTF-8), it translates the binary data into proper Unicode text. If no encoding is specified, it simply passes the data through unchanged. This allows processing large responses without loading everything into memory at once.",
        "technical": "Generator function that incrementally decodes binary chunks from an iterator using the encoding specified in response object `r`. Returns early if `r.encoding` is None, yielding raw chunks. Otherwise, creates an incremental decoder via `codecs.getincrementaldecoder()` with error replacement, decodes each chunk, and yields non-empty results. Performs final decode with `final=True` to flush any remaining buffered data."
      },
      "iter_slices": {
        "human": "Breaks a text string into smaller chunks of a specified size and returns them one at a time. If no chunk size is given (or an invalid one), it returns the entire string as one piece. This is useful when you need to process large text in manageable portions, like reading a book page by page instead of all at once.",
        "technical": "Generator function that yields successive substrings of fixed length using slice notation. Initializes position counter at 0, validates slice_length (defaults to full string length if None or \u22640), then iterates through string incrementing position by slice_length each iteration. Uses string slicing `string[pos:pos+slice_length]` to extract chunks and `len()` to determine string boundaries and default slice size."
      },
      "get_unicode_from_response": {
        "human": "Converts the raw content from a web response into readable text (Unicode). It first tries to figure out the correct character encoding from the response headers, and if that doesn't work properly, it falls back to a method that replaces any problematic characters rather than failing completely. This function is deprecated and will be removed in a future version.",
        "technical": "Extracts Unicode string from response object by attempting encoding detection via `get_encoding_from_headers()`. First tries decoding `r.content` using detected encoding, catching `UnicodeError` to track failed attempts. Falls back to decoding with `errors=\"replace\"` parameter to substitute invalid characters. Handles `TypeError` by returning raw `r.content`. Issues `DeprecationWarning` on each call indicating removal in requests 3.0."
      },
      "unquote_unreserved": {
        "human": "This function cleans up web addresses (URIs) by converting certain encoded characters back to their normal form. When you see \"%20\" in a URL, this function decides whether to convert it back to a regular character or leave it encoded. It only converts \"safe\" characters (letters, numbers, and a few symbols) while keeping special characters encoded for security and compatibility.",
        "technical": "Splits URI on \"%\" delimiter and iterates through percent-encoded sequences. For each 2-character hex code following \"%\", validates it's alphanumeric, converts to integer (base 16), then to character via chr(). Checks if character exists in UNRESERVED_SET - if yes, replaces the escape sequence with the literal character; if no, preserves the percent-encoding. Joins all parts back together and returns the selectively-unquoted string. Raises InvalidURL on malformed hex sequences."
      },
      "requote_uri": {
        "human": "Takes a web address (URI) and fixes its formatting to ensure special characters are properly encoded. This prevents errors when the address is used in web requests. If the address is already partially encoded, it handles that situation gracefully by re-encoding it correctly. Think of it like standardizing how spaces and symbols are written in a web link.",
        "technical": "Normalizes URI encoding through a two-stage process: first attempts to unquote unreserved characters via `unquote_unreserved()` then re-quotes with `quote()` using safe_with_percent characters. If InvalidURL exception occurs (indicating malformed encoding), falls back to directly quoting the raw URI with safe_without_percent (excludes '%' to avoid double-encoding existing percent signs). Returns a consistently percent-encoded string suitable for HTTP requests."
      },
      "address_in_network": {
        "human": "Checks whether a given IP address belongs to a specific network subnet. This is useful for determining if a computer's IP address is part of a particular network range, like verifying if 192.168.1.50 is within the 192.168.1.0/24 network. Returns True if the IP is in the network, False otherwise.",
        "technical": "Converts IP address and network address to 32-bit integers using `socket.inet_aton()` and `struct.unpack()`. Parses CIDR notation to extract network address and prefix bits, generates netmask via `dotted_netmask()` helper, then performs bitwise AND operations to compare the masked IP address against the masked network address. Returns boolean indicating subnet membership."
      },
      "dotted_netmask": {
        "human": "Converts a network mask from its short number format (like \"24\") into the full dotted decimal format (like \"255.255.255.0\") that's easier to read. This is commonly used in networking to show which parts of an IP address represent the network versus individual devices. For example, a mask of 24 becomes 255.255.255.0, meaning the first three numbers of an IP address identify the network.",
        "technical": "Takes an integer mask value (0-32) and converts it to dotted-decimal notation. Creates a 32-bit integer by XORing 0xFFFFFFFF with a bit-shifted value to generate the netmask pattern. Uses struct.pack(\">I\", bits) to convert the integer to a 4-byte big-endian representation, then socket.inet_ntoa() to transform those bytes into standard IPv4 dotted notation string (e.g., \"255.255.255.0\"). Returns the formatted string representation."
      },
      "is_ipv4_address": {
        "human": "Checks whether a given text string represents a valid IPv4 address (like \"192.168.1.1\"). This is useful when you need to verify that user input or data contains a properly formatted IP address before using it for network operations. Returns a simple yes/no answer about whether the format is correct.",
        "technical": "Validates IPv4 address format by attempting to convert the input string using `socket.inet_aton()`, which parses dotted-decimal notation. Catches `OSError` exceptions (raised for invalid formats) and returns `False` for invalid addresses, `True` for valid ones. Note: Type hint indicates `Any` input but function expects string; return type annotation shows `None` but actually returns `bool`."
      },
      "is_valid_cidr": {
        "human": "Checks if a text string is a valid CIDR network address (like \"192.168.1.0/24\"). CIDR is a format used to specify IP address ranges in network configurations, particularly in proxy bypass lists. The function verifies that the format is correct: it has exactly one slash, the number after the slash is between 1-32, and the part before the slash is a valid IP address.",
        "technical": "Validates CIDR notation by: (1) checking for exactly one \"/\" separator using count(), (2) parsing and validating the mask is an integer between 1-32, (3) validating the IP address portion using socket.inet_aton() which raises OSError for invalid IPs. Returns True only if all validations pass, False otherwise. Uses split() to separate IP and mask components, with try-except blocks to catch ValueError and OSError exceptions."
      },
      "set_environ": {
        "human": "This function temporarily changes a system setting (environment variable) to a new value, lets other code run with that setting, then automatically restores the original value when done. It's like borrowing a book from a library - you take it, use it, then return it to its original place. If no new value is provided, it does nothing at all.",
        "technical": "Context manager that temporarily modifies an environment variable using os.environ. Stores the original value via os.environ.get(), sets the new value if provided, yields control to the caller, then restores the previous state in the finally block. If the variable didn't exist originally, it deletes it using del; otherwise restores the old value. No-op when value parameter is None."
      },
      "should_bypass_proxies": {
        "human": "Determines whether a web request should skip using proxy servers based on configuration rules. Checks if the target URL matches any entries in a \"no_proxy\" list (which can contain IP addresses, domain names, or network ranges). If a match is found, the function indicates that proxies should be bypassed for that particular URL, allowing direct connections instead.",
        "technical": "Parses the target URL to extract hostname/port, then checks against no_proxy list from function argument or environment variables (prioritizing lowercase). For IPv4 addresses, performs CIDR network matching using `is_valid_cidr()` and `address_in_network()`; for hostnames, performs suffix matching with/without port. Falls back to system's `proxy_bypass()` function within a temporary environment context using `set_environ()`. Returns boolean indicating whether to bypass proxies."
      },
      "get_environ_proxies": {
        "human": "This function checks whether your internet connection should use proxy servers (intermediaries that route your web traffic). If the website you're trying to reach should bypass proxies based on your settings, it returns nothing. Otherwise, it fetches and returns the proxy server settings configured in your system's environment variables.",
        "technical": "Conditionally retrieves system proxy configuration based on URL and no_proxy rules. Calls `should_bypass_proxies()` to check if the target URL matches bypass patterns; if true, returns empty dict. Otherwise, invokes `getproxies()` (likely from urllib.request) to extract proxy settings from environment variables (HTTP_PROXY, HTTPS_PROXY, etc.). Returns dict mapping protocol schemes to proxy URLs or empty dict."
      },
      "select_proxy": {
        "human": "Finds the right proxy server to use when making a web request to a specific URL. It looks through a list of available proxy servers and picks the most specific match based on the URL's protocol (like http or https) and destination website. If no specific proxy is found, it falls back to a general \"all\" proxy, or returns nothing if no proxy applies.",
        "technical": "Parses the input URL using urlparse() to extract scheme and hostname. Implements a priority-based proxy selection by checking four keys in descending specificity: scheme+hostname, scheme-only, all+hostname, and \"all\". Iterates through proxy_keys list and returns the first matching proxy from the proxies dictionary. Handles edge case where hostname is None by immediately checking scheme or \"all\" proxies. Returns None if no matching proxy is found."
      },
      "resolve_proxies": {
        "human": "Figures out which proxy servers should be used when making a web request. It combines proxy settings that were explicitly provided with proxy settings from the computer's environment variables (like HTTP_PROXY). It also respects NO_PROXY rules that tell it when NOT to use a proxy for certain websites, ensuring requests are routed correctly.",
        "technical": "Merges explicitly provided proxies dict with environment-based proxy configuration. Parses request URL to extract scheme, then conditionally calls get_environ_proxies() if trust_env=True and should_bypass_proxies() returns False. Retrieves scheme-specific or 'all' proxy from environment, uses setdefault() to add to copied proxies dict without overwriting existing entries. Returns merged proxy mapping for the request's URL scheme."
      },
      "default_user_agent": {
        "human": "Creates a standardized identification string that tells web servers what software is making a request. This is like showing your ID when visiting a website - it helps servers know what kind of application is connecting to them. By default, it identifies the connection as coming from the \"python-requests\" library along with its version number.",
        "technical": "Constructs and returns a user agent string by formatting the provided name parameter (defaulting to \"python-requests\") with the module's version number using an f-string. Takes a single parameter `name` with default value \"python-requests\", accesses the module-level `__version__` variable, and returns a formatted string in the pattern \"name/version\". Note: The signature shows `name: Any` and `-> None` which are incorrect type hints - should be `str` parameter and `-> str` return type."
      },
      "default_headers": {
        "human": "Creates a standard set of HTTP headers that should be included with every web request. These headers tell the receiving server basic information like what type of content to accept, how to handle the connection, and what software is making the request. This ensures requests are properly formatted and compatible with web servers.",
        "technical": "Constructs and returns a CaseInsensitiveDict containing four default HTTP headers: User-Agent (populated by calling default_user_agent()), Accept-Encoding (from DEFAULT_ACCEPT_ENCODING constant), Accept (set to \"*/*\" for any content type), and Connection (set to \"keep-alive\" for persistent connections). Returns a case-insensitive dictionary structure from requests.structures module for header storage."
      },
      "parse_header_links": {
        "human": "Converts HTTP Link headers (which contain multiple URLs with metadata) into a structured list format that's easier to work with. Takes a raw header string containing URLs and their properties (like relationship type or content type) and breaks it down into separate dictionary entries, one for each URL and its associated information.",
        "technical": "Parses RFC-compliant Link header strings by: (1) splitting on comma-angle-bracket pattern to separate multiple links, (2) extracting URL from angle brackets and parameters from semicolon-delimited key=value pairs, (3) stripping quotes/whitespace from all components, (4) building dictionary objects with 'url' key plus parameter keys. Returns list of dictionaries. Handles malformed entries via try-except blocks that gracefully skip invalid splits."
      },
      "guess_json_utf": {
        "human": "Detects which type of Unicode encoding (UTF-8, UTF-16, or UTF-32) is used in JSON data by examining the first few bytes. JSON files always start with ASCII characters, so the function looks for special byte markers (BOMs) or counts null bytes to figure out the encoding format. This helps programs correctly read JSON files that might be saved in different text formats.",
        "technical": "Analyzes the first 4 bytes of input data to determine UTF encoding. First checks for BOM (Byte Order Mark) signatures for UTF-32, UTF-8, and UTF-16. If no BOM found, counts null bytes (_null) in the sample: 0 nulls indicates UTF-8, 2 nulls at specific positions (using slice notation [::2] and [1::2]) indicates UTF-16-BE/LE, 3 nulls indicates UTF-32-BE/LE. Returns encoding string or None if detection fails."
      },
      "prepend_scheme_if_needed": {
        "human": "Takes a web address (URL) and adds a protocol prefix (like \"http://\" or \"https://\") to it if one isn't already present. If the URL already has a protocol, it leaves it unchanged. This ensures URLs are properly formatted for web requests. It also handles special cases where the URL structure might be parsed incorrectly, maintaining backward compatibility with older behavior.",
        "technical": "Parses the input URL using `parse_url()` to extract components (scheme, auth, host, port, path, query, fragment). Handles a parsing defect by swapping netloc and path when netloc is empty. Reconstructs netloc with authentication credentials if present by joining with \"@\". Only assigns `new_scheme` if the existing scheme is None. Returns a complete URL string via `urlunparse()` with the scheme guaranteed to be present, preserving all other URL components."
      },
      "get_auth_from_url": {
        "human": "Extracts login credentials (username and password) from a web address that has them embedded in the URL. For example, if a URL contains \"http://user:pass@example.com\", this function pulls out \"user\" and \"pass\" as separate pieces. If the URL doesn't have credentials or something goes wrong, it returns empty strings for both username and password.",
        "technical": "Parses the input URL using `urlparse()` to extract authentication components, then attempts to retrieve `parsed.username` and `parsed.password`, applying `unquote()` to decode any URL-encoded characters. Returns a tuple of (username, password) strings. Catches `AttributeError` or `TypeError` exceptions (when username/password attributes are None or missing) and returns `(\"\", \"\")` as fallback. Note: Type hint indicates return type `None` but actually returns a tuple."
      },
      "check_header_validity": {
        "human": "Checks that an email or HTTP header is properly formatted and safe to use. Takes a header (which has a name and value, like \"Subject: Hello\"), unpacks it into its two parts, and validates each part to ensure it doesn't contain problematic characters like whitespace at the beginning or special control characters that could cause security issues or formatting problems.",
        "technical": "Unpacks a header tuple into name and value components, then delegates validation to `_validate_header_part()` for each component separately (passing index 0 for name, 1 for value). The function performs no return value but raises exceptions via the validation helper if invalid characters are detected. Acts as a wrapper that orchestrates header validation by decomposing the tuple and invoking part-specific validation logic."
      },
      "_validate_header_part": {
        "human": "Checks whether a piece of an HTTP header (either the header name or its value) is properly formatted and safe to use. It ensures the header part is text-based (either regular text or bytes), then verifies it doesn't contain forbidden characters like extra spaces at the beginning, special reserved characters, or line breaks that could cause security issues or protocol violations.",
        "technical": "Validates HTTP header components by first type-checking that `header_part` is str or bytes, selecting the appropriate regex validator from `_HEADER_VALIDATORS_STR` or `_HEADER_VALIDATORS_BYTE` arrays. Uses `validator.match()` to verify the header part contains no leading whitespace, reserved characters, or return characters. Raises `InvalidHeader` exception with descriptive messages for type mismatches or validation failures. The `header_validator_index` parameter (0 for name, non-0 for value) determines error message context."
      },
      "urldefragauth": {
        "human": "Takes a web address (URL) and cleans it up by removing two parts: the fragment (the part after # that jumps to a section on a page) and any username/password information that might be embedded in the URL. This creates a sanitized version of the URL that's safer to log or display publicly without exposing credentials.",
        "technical": "Parses URL into 6 components using `urlparse()`, handles edge case where netloc is empty by swapping it with path, strips authentication credentials by splitting netloc on \"@\" and taking the rightmost part (after the @), sets fragment to empty string, and reconstructs the URL using `urlunparse()`. Returns a string with authentication and fragment removed while preserving scheme, host, path, params, and query."
      },
      "rewind_body": {
        "human": "Resets a web request's body content back to the beginning so it can be read again when a redirect happens. This is necessary because when a server redirects your request to a different URL, the system needs to resend the same data, but the original data may have already been read once. If the body can't be reset (like with streaming data), it raises an error.",
        "technical": "Attempts to rewind a prepared HTTP request body by calling its `seek()` method with the stored `_body_position` offset. First checks if the body has a `seek` attribute using `getattr()` and verifies `_body_position` is an integer type. Catches `OSError` during seek operation and raises `UnrewindableBodyError` with appropriate message. Also raises `UnrewindableBodyError` if body lacks seek capability or position isn't recorded."
      },
      "proxy_bypass_registry": {
        "human": "Checks whether a specific website or server should bypass the proxy settings on a Windows computer. It reads the user's Internet settings from the Windows registry to see if proxy is enabled and if there's a list of exceptions. If the given host matches any exception pattern (like \"*.example.com\" or local addresses), it tells the system to skip using the proxy for that connection.",
        "technical": "Reads Windows registry keys from HKEY_CURRENT_USER\\Internet Settings to retrieve ProxyEnable and ProxyOverride values using winreg module. Parses semicolon-separated ProxyOverride list, handles special \"<local>\" token for non-FQDN hosts, converts wildcard patterns (* and ?) to regex equivalents, and performs case-insensitive regex matching against the host parameter. Returns True if host matches any bypass pattern, False otherwise or on registry access errors."
      },
      "proxy_bypass": {
        "human": "Determines whether a specific website or server should be accessed directly or through a proxy server. It checks your computer's proxy configuration settings to make this decision. First looks at environment variables (temporary settings), and if those aren't set, checks the Windows registry (permanent system settings) to decide if the proxy should be skipped for that particular host.",
        "technical": "Implements proxy bypass logic with two-tier fallback mechanism. Calls `getproxies_environment()` to check for environment-based proxy configuration; if present, delegates to `proxy_bypass_environment(host)`, otherwise falls back to `proxy_bypass_registry(host)` for Windows registry-based settings. Returns boolean indicating whether the given host should bypass proxy. Acts as a routing function that prioritizes environment variables over system registry configuration."
      }
    }
  },
  "module_summaries": {
    "docs/_themes/flask_theme_support.py": {
      "human": "This module provides custom syntax highlighting colors for Flask documentation. It defines a color scheme (called \"FlaskyStyle\") that determines how code examples appear in the documentation - what colors are used for keywords, strings, comments, functions, and other programming elements. This ensures Flask's documentation has a consistent, branded appearance that matches the project's visual identity when displaying code snippets.",
      "technical": "Implements FlaskyStyle class extending pygments.style.Style to define a custom Pygments syntax highlighting theme. The class contains a styles dictionary mapping pygments.token types (Keywords, Strings, Comments, Names, Operators, etc.) to color/formatting specifications. Integrates with Sphinx documentation build system to provide consistent code syntax coloring across Flask's documentation. No functions defined; operates purely through class-level style configuration consumed by Pygments rendering engine."
    },
    "docs/conf.py": {
      "human": "This module is a Sphinx documentation configuration file that defines settings for generating project documentation. It configures documentation build parameters, theme settings, project metadata, and extension options. The module imports system utilities and requests library to support dynamic configuration and potential API-based documentation features.",
      "technical": "Defines Sphinx configuration variables including `project`, `copyright`, `author`, `version`, `release`, `html_theme`, and extension lists. Imports `sys` and `os` for path manipulation (likely adding project root to sys.path), and `requests` for potential external data fetching during doc builds. Contains approximately 387 lines of configuration dictionaries, string constants, and build options that control Sphinx's documentation generation behavior."
    },
    "setup.py": {
      "human": "This is a package setup/installation configuration file for a Python project. It defines metadata about the package (name, version, author, dependencies, etc.) and instructions for how the package should be installed and distributed. The file is used by setuptools to build and install the Python package, making it available via pip or other package managers.",
      "technical": "Imports setuptools for package configuration, os and sys for system operations (likely path manipulation and Python version checks), and codecs for reading files with specific encodings (typically for reading README or version files). Defines package metadata variables and configuration dictionaries passed to setuptools.setup(). Contains 108 lines of declarative configuration including dependencies, package discovery rules, classifiers, and entry points for package distribution."
    },
    "src/requests/__init__.py": {
      "human": "This module serves as the initialization and compatibility checker for the requests library. When the requests library is loaded, this module automatically verifies that all required supporting libraries (like urllib3 for HTTP connections and chardet/charset_normalizer for character encoding detection) are installed with compatible versions. It protects users from hard-to-diagnose errors by catching version mismatches early and warning them about outdated libraries that could cause performance problems or crashes.",
      "technical": "Serves as the package entry point (__init__.py) for the requests library, performing dependency validation at import time. Implements version compatibility checks through check_compatibility() and _check_cryptography() functions that parse semantic version strings and validate against hardcoded version constraints. Depends on urllib3 (>=1.21.1), chardet (3.0.2-6.0.0) or charset_normalizer (2.0.0-4.0.0), and optionally cryptography (>=1.3.4). Uses assertions for hard failures on incompatible versions and warnings.warn() with custom RequestsDependencyWarning for soft warnings. Executes validation logic at module import time as side effects."
    },
    "src/requests/__version__.py": {
      "human": "This module serves as the version metadata file for the requests library. It defines version information and package metadata constants that are used throughout the library and for package distribution. The module provides a single source of truth for version numbers and related package information that can be imported by other modules and the setup configuration.",
      "technical": "Defines string constants for package versioning following semantic versioning conventions, likely including `__version__`, `__title__`, `__description__`, `__url__`, `__author__`, and `__license__`. These metadata constants are typically imported by the main `__init__.py` file and setup.py for package distribution. The module contains no logic or imports, serving purely as a data container for package metadata accessible via `requests.__version__`."
    },
    "src/requests/_internal_utils.py": {
      "human": "This module provides basic text handling utilities for the requests library, focusing on ensuring text is in the correct format for Python to work with. It helps convert between different text representations (like raw bytes versus readable strings) and checks whether text contains only simple English characters. These are foundational utilities that other parts of the requests library use when they need to normalize or validate text data, such as HTTP headers or URLs that must be in specific formats.",
      "technical": "Provides internal string normalization and validation utilities for the requests library. Exports two functions: `to_native_string()` for converting between bytes and native string types (handling Python 2/3 compatibility via the `compat` module's `builtin_str`), and `unicode_is_ascii()` for ASCII validation using exception-based control flow. Serves as a low-level utility layer for text processing throughout the requests codebase, particularly for HTTP protocol compliance where ASCII encoding is often required. No classes defined; purely functional module with minimal dependencies (re, compat)."
    },
    "src/requests/adapters.py": {
      "human": "This module serves as the networking engine for the requests library, managing how HTTP requests are actually sent over the internet. It handles connection pooling (reusing connections instead of creating new ones each time), SSL/TLS security for encrypted connections, certificate verification to ensure you're talking to the right server, and routing requests through proxy servers when needed. Think of it as the adapter that translates high-level \"send this request\" commands into low-level network operations, while managing resources efficiently and handling all the security details automatically.",
      "technical": "Implements two adapter classes: BaseAdapter (abstract interface) and HTTPAdapter (concrete implementation wrapping urllib3.PoolManager). HTTPAdapter provides the send() method as the primary API for executing PreparedRequest objects and returning Response objects. Manages connection pooling via init_poolmanager() and proxy_manager_for(), handles SSL/TLS configuration through cert_verify() and _urllib3_request_context(), and implements connection retrieval via get_connection_with_tls_context(). Translates urllib3 exceptions to requests-library exception types and builds Response objects from urllib3.HTTPResponse. Supports serialization through __setstate__() for session persistence."
    },
    "src/requests/api.py": {
      "human": "This module provides a simple, user-friendly interface for making HTTP requests to websites and web services. It offers convenient functions for all common web operations: retrieving data (GET), submitting forms or data (POST), updating information (PUT/PATCH), deleting resources (DELETE), and checking what operations are allowed (OPTIONS/HEAD). Instead of dealing with complex networking details, users can simply call these functions with a web address and any data they want to send, making it easy to communicate with web servers from Python programs.",
      "technical": "Implements a convenience API layer consisting of eight wrapper functions (request, get, post, put, patch, delete, options, head) that provide a simplified interface for HTTP operations. Each function delegates to the core `request()` function, which creates a temporary Session object via context manager to handle the actual HTTP communication. The module serves as the primary public API surface for one-off requests, abstracting away session management and connection cleanup. Functions accept standard parameters (url, data, json, params) and forward arbitrary kwargs to the underlying Session.request() method, returning Response objects to callers."
    },
    "src/requests/auth.py": {
      "human": "This module handles user authentication for HTTP requests, providing different ways to prove your identity to web servers. It supports Basic Authentication (simple username/password), Proxy Authentication (for connecting through proxy servers), and Digest Authentication (a more secure method that doesn't send passwords directly). The module creates the proper authentication headers that get attached to web requests, manages authentication challenges from servers, and handles retry logic when authentication initially fails.",
      "technical": "Implements four authentication classes inheriting from AuthBase: HTTPBasicAuth (Basic auth via base64-encoded credentials), HTTPProxyAuth (proxy authentication), and HTTPDigestAuth (RFC 2616 digest auth with MD5/SHA variants). Primary interface is __call__() method that modifies PreparedRequest objects by adding Authorization headers. HTTPDigestAuth uses threading.local() for thread-safe state management, implements challenge-response flow via handle_401() hook, and supports nonce tracking for replay protection. Provides _basic_auth_str() utility and hash helper functions (md5_utf8, sha_utf8, sha256_utf8, sha512_utf8) for digest computation. Integrates with requests library's hook system for handling 401 responses and redirects."
    },
    "src/requests/certs.py": {
      "human": "This module provides a bridge to SSL certificate verification by exposing the path to the CA certificate bundle. It serves as a thin wrapper around the certifi package, allowing the requests library to locate trusted root certificates for HTTPS connections. Other modules in the requests package import this to validate SSL/TLS certificates when making secure HTTP requests.",
      "technical": "Imports the certifi module and likely defines a constant or function that returns `certifi.where()`, which provides the filesystem path to the bundled CA certificate file. This module acts as an abstraction layer between requests' internal SSL verification logic and the certifi package, allowing requests to perform certificate validation without hardcoding certificate paths. Referenced by connection/adapter modules during HTTPS request initialization."
    },
    "src/requests/compat.py": {
      "human": "This module serves as a compatibility layer that helps the requests library work consistently across different Python versions and environments. It handles differences in how Python's standard libraries are organized between Python 2 and Python 3, and provides a unified way to access common functionality like cookies, collections, and character encoding detection. By centralizing these compatibility concerns, it allows the rest of the requests library to use a single, consistent interface regardless of which Python version is running.",
      "technical": "Provides compatibility shims and imports for cross-version Python support in the requests library. Imports standard library modules (urllib3, http.cookies, io, collections.abc) and re-exports them through a consistent interface. Implements `_resolve_char_detection()` to dynamically load either chardet or charset_normalizer for encoding detection with fallback logic. Acts as an abstraction layer between requests and Python's evolving standard library structure, isolating version-specific import paths. No classes defined; functions as a pure import aggregation and compatibility resolution module."
    },
    "src/requests/cookies.py": {
      "human": "This module provides comprehensive cookie management for the requests library, acting as a bridge between Python's standard cookie handling and HTTP requests/responses. It allows cookies to be extracted from server responses, stored in a jar, and automatically included in subsequent requests to the appropriate domains and paths. The module handles cookie format conversions (dictionaries, Morsel objects, Cookie objects) and provides dictionary-like operations for easy manipulation. It also manages complex scenarios like cookie conflicts across domains, persistence (saving/loading cookies), and thread-safe operations, making cookie handling seamless for HTTP client applications.",
      "technical": "The module implements `RequestsCookieJar` (extending `cookielib.CookieJar`) as the primary cookie storage container with dict-like interface methods. It provides `MockRequest` and `MockResponse` adapter classes to interface with Python's `cookielib` infrastructure. Key functions include `extract_cookies_to_jar()` for parsing Set-Cookie headers, `get_cookie_header()` for generating Cookie headers, and `cookiejar_from_dict()`/`merge_cookies()` for format conversions. The module uses `threading.RLock` for thread safety, implements `__getstate__`/`__setstate__` for serialization, and defines `CookieConflictError` for handling domain/path ambiguities. Dependencies include `cookielib`, `http.cookies`, and internal requests compatibility utilities."
    },
    "src/requests/exceptions.py": {
      "human": "This module defines all the error types that can occur when making HTTP requests using the requests library. It provides specific error classes for different failure scenarios like network connection problems, invalid URLs, timeout issues, SSL certificate errors, and JSON parsing failures. When something goes wrong during a web request, these error types help users and developers understand exactly what failed and why, making it easier to handle problems appropriately in their code.",
      "technical": "Defines a comprehensive exception hierarchy rooted in RequestException (which inherits from IOError). Provides specialized exception classes for HTTP errors (HTTPError), network issues (ConnectionError, ProxyError, SSLError), timeouts (Timeout, ConnectTimeout, ReadTimeout), URL/schema validation (URLRequired, InvalidURL, InvalidSchema), and encoding problems (ChunkedEncodingError, ContentDecodingError). Includes a custom JSONDecodeError implementation with dual inheritance from both CompatJSONDecodeError and InvalidJSONError, requiring special __init__ and __reduce__ methods to handle multiple inheritance serialization. Imports urllib3 exceptions for wrapping lower-level errors and provides warning classes for non-fatal issues."
    },
    "src/requests/help.py": {
      "human": "This module provides diagnostic and troubleshooting capabilities for the requests library. It collects and displays information about your Python environment, including which Python version you're running, what operating system you're using, and which versions of security and networking libraries are installed. When users encounter bugs or issues, this module generates a formatted report showing all relevant system details that developers need to diagnose problems. It's essentially a \"help desk\" tool that gathers technical environment information in an easy-to-share format.",
      "technical": "Implements a diagnostic information gathering system with three core functions: `_implementation()` for Python interpreter detection, `info()` for comprehensive environment metadata collection, and `main()` for JSON-formatted output. The module queries platform details via the `platform` module, inspects version attributes from optional dependencies (urllib3, OpenSSL, cryptography, idna, charset_normalizer, chardet), and handles missing modules gracefully. Returns structured dictionaries containing system platform, Python implementation details, SSL/TLS configuration, and library versions. Serves as a debugging utility invoked via command-line or programmatically to generate bug reports with complete environment snapshots."
    },
    "src/requests/hooks.py": {
      "human": "This module provides a simple event hook system that allows developers to customize how the requests library processes data at key moments. Think of it as a way to insert custom actions (like logging, modifying, or validating data) at specific points during a request's lifecycle. When an event occurs (like receiving a response), the system automatically runs any custom functions that were registered for that event, allowing each function to inspect or modify the data before passing it along.",
      "technical": "Implements a lightweight event dispatcher pattern through the `dispatch_hook()` function. Provides a simple API that accepts a hook dictionary, event key, and data payload, executing registered callbacks in sequence with chaining support. Hooks can transform data by returning modified values, with None returns preserving original data. Serves as the runtime execution layer for the requests library's hook system, enabling extension points throughout the request/response cycle without tight coupling. No class dependencies; operates as a pure functional utility module."
    },
    "src/requests/models.py": {
      "human": "This module implements the complete lifecycle of HTTP requests and responses in the requests library. It handles everything needed to send web requests - building URLs, formatting headers, managing authentication and cookies, and encoding request bodies. On the response side, it processes data received from servers, including parsing content as text or JSON, handling redirects, and managing streaming data. Essentially, it's the core engine that transforms your Python code into properly formatted HTTP requests and converts server responses back into usable Python objects.",
      "technical": "The module defines five main classes: RequestEncodingMixin and RequestHooksMixin (mixins for encoding and hooks), Request (high-level request representation), PreparedRequest (low-level HTTP-ready request), and Response (server response container). It integrates with urllib3 for connection pooling and HTTP handling, using urllib3.fields and urllib3.filepost for multipart encoding. The design follows a preparation pattern where Request objects are converted to PreparedRequest objects with fully resolved URLs, headers, and body encoding. Response objects provide multiple interfaces for content consumption (text, JSON, streaming) and include automatic encoding detection using chardet/charset_normalizer."
    },
    "src/requests/packages.py": {
      "human": "This module manages vendored package imports for the requests library, providing a compatibility layer for bundled third-party dependencies. It allows requests to use its own packaged versions of dependencies (like urllib3 and chardet) while maintaining the ability to fall back to system-installed versions. This ensures requests can function independently without external dependency conflicts.",
      "technical": "Imports `sys` and `compat` modules to manipulate Python's import system for vendored packages. Likely defines module path mappings or import hooks that redirect `requests.packages.urllib3` and `requests.packages.chardet` imports to bundled versions within the requests distribution. Serves as an import shim layer between requests core functionality and its vendored dependencies, enabling package isolation in the requests library architecture."
    },
    "src/requests/sessions.py": {
      "human": "This module provides the Session class, which manages persistent settings and state across multiple HTTP requests. It handles cookies, authentication, redirects, and connection pooling so you don't have to configure these for every request. Think of it as a web browser session that remembers your settings - when you make multiple requests to websites, the session automatically maintains cookies, follows redirects intelligently, and reuses connections for better performance. It also handles security concerns like stripping authentication credentials when redirecting to different domains.",
      "technical": "Implements two main classes: SessionRedirectMixin (handles redirect logic) and Session (main API for stateful HTTP requests). Session provides convenience methods (get, post, put, etc.) that delegate to a central request() method, which prepares requests by merging session-level and request-level settings. Uses HTTPAdapter instances mounted to URL prefixes for actual request transmission. Manages redirect chains via resolve_redirects() generator, handles authentication stripping/reapplication during redirects, and maintains cookie persistence through CookieJar integration. Implements pickle protocol for serialization and provides merge_setting/merge_hooks utilities for intelligent configuration merging."
    },
    "src/requests/status_codes.py": {
      "human": "This module provides a convenient way to work with HTTP status codes by allowing developers to reference them using descriptive names instead of remembering numeric codes. It automatically creates easy-to-use shortcuts for every status code (like \"OK\" for 200 or \"NOT_FOUND\" for 404) and generates human-readable documentation listing all available codes. This makes code more readable and self-documenting when checking or setting HTTP response statuses.",
      "technical": "Implements dynamic attribute generation on a `codes` object by iterating through a `_codes` dictionary mapping to create named references for HTTP status codes. Exposes status codes through both original and uppercase attribute names (e.g., both `codes.ok` and `codes.OK` for 200). Uses `setattr()` for runtime attribute injection and modifies module-level `__doc__` string to auto-generate API documentation. Depends on `structures` module for the underlying codes object. Provides programmatic access to status codes through attribute lookup rather than dictionary access, enabling IDE autocomplete and cleaner syntax."
    },
    "src/requests/structures.py": {
      "human": "This module provides specialized dictionary classes that handle key lookups in flexible ways. The main feature is case-insensitive storage and retrieval - you can store data with keys like \"Content-Type\" and retrieve it using \"content-type\" or any capitalization variant. This is particularly useful for handling HTTP headers where capitalization shouldn't matter (e.g., \"Accept\" vs \"accept\" should refer to the same header). It solves the problem of inconsistent capitalization in data that should be treated as equivalent.",
      "technical": "Implements two custom dictionary classes: CaseInsensitiveDict and LookupDict. CaseInsensitiveDict extends MutableMapping to provide case-insensitive key access while preserving original key casing in storage (uses `_store` with lowercased keys mapping to (original_key, value) tuples). Overrides `__setitem__`, `__getitem__`, and `__eq__` for case-insensitive operations. LookupDict provides read-only dictionary-like access with graceful None returns for missing keys. Both classes serve as data structure primitives for the requests library, primarily used for HTTP header management where RFC specifications treat header names as case-insensitive."
    },
    "src/requests/utils.py": {
      "human": "This module serves as the utility toolkit for the requests library, providing all the helper functions needed to prepare and configure HTTP requests properly. It handles the messy details of encoding data, parsing URLs and headers, managing authentication credentials from various sources (like netrc files and cookies), and determining network settings like proxies. The module also deals with platform-specific quirks (especially Windows) and ensures that user inputs are safely transformed into valid HTTP requests. Essentially, it's the behind-the-scenes workhorse that makes the requests library user-friendly by handling all the complex formatting, validation, and configuration tasks automatically.",
      "technical": "This utility module contains 43 standalone functions (no classes) that provide core infrastructure for HTTP request preparation in the requests library. It implements character encoding detection and conversion (using codecs), URL parsing and normalization (with urllib), header parsing and formatting, netrc-based authentication, cookie jar management, and proxy configuration resolution. Key dependencies include socket for network operations, tempfile for secure file handling, and platform-specific modules for Windows registry access. The module follows a functional programming pattern with pure utility functions, handles cross-platform compatibility (Unix/Windows proxy settings), and implements RFC-compliant parsing for HTTP headers, URLs, and authentication schemes while providing safe data structure manipulation and file operations."
    }
  },
  "repo_summary": {
    "human": "This is the Requests library, Python's most popular HTTP client that makes communicating with websites and web APIs simple and intuitive. It handles all the complexity of making web requests - from basic GET/POST operations to advanced features like authentication, cookie management, SSL security, and proxy routing. Developers use it to interact with web services, consume APIs, scrape websites, and automate web interactions without dealing with low-level networking code. The library provides a clean, user-friendly interface that abstracts away HTTP protocol details, connection management, and data encoding. It's designed to be \"HTTP for Humans\" - making web requests as simple as calling a function with a URL.",
    "technical": "Implements a layered HTTP client architecture built on urllib3 for connection pooling and low-level transport. Core components include: Session objects for stateful request management with persistent cookies/auth/headers, HTTPAdapter for pluggable transport with connection pooling via urllib3.PoolManager, PreparedRequest/Response model objects for request/response lifecycle, and authentication handlers (Basic/Digest/Proxy). Uses a preparation pattern where high-level Request objects are transformed into wire-ready PreparedRequest objects with resolved URLs, encoded bodies, and merged headers. Provides hook system for request/response interception, case-insensitive header storage via custom dict structures, and automatic content encoding detection using chardet/charset_normalizer. Includes comprehensive exception hierarchy, thread-safe cookie management with cookielib integration, and cross-platform proxy/certificate configuration. The API layer provides convenience functions wrapping temporary sessions for one-off requests, while Session class enables connection reuse and configuration persistence across multiple requests."
  },
  "dead_code_analysis": {
    "unreferenced_functions": [
      {
        "name": "get_connection",
        "module": "src/requests/adapters.py",
        "lineno": 472,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a deprecated but still public API method of HTTPAdapter. The docstring explicitly states it's exposed for subclassing HTTPAdapter, indicating it's part of the public interface that external users may still rely on.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly states 'only exposed for use when subclassing the HTTPAdapter'",
            "Method is deprecated but not yet removed, suggesting it's maintained for backward compatibility",
            "HTTPAdapter is a core class that users commonly subclass"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a deprecated but still public API method of HTTPAdapter. The docstring explicitly states it's exposed for subclassing HTTPAdapter, indicating it's part of the public interface that external users may still rely on.",
        "recommendation": "keep"
      },
      {
        "name": "get_type",
        "module": "src/requests/cookies.py",
        "lineno": 40,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This method implements the urllib request interface protocol. MockRequest appears to be implementing methods expected by urllib's cookie handling system, where get_type() is a standard method.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows urllib request interface pattern",
            "MockRequest class appears to implement urllib request protocol",
            "Simple getter method typical of interface implementations"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method implements the urllib request interface protocol. MockRequest appears to be implementing methods expected by urllib's cookie handling system, where get_type() is a standard method.",
        "recommendation": "keep"
      },
      {
        "name": "get_full_url",
        "module": "src/requests/cookies.py",
        "lineno": 49,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This method implements the urllib request interface protocol. It's a standard method expected by urllib's cookie handling system for determining the full URL of a request.",
          "recommendation": "keep",
          "evidence": [
            "Method name matches urllib request interface standard",
            "Complex logic suggests it's actively used by cookie handling",
            "MockRequest implements urllib request protocol methods"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method implements the urllib request interface protocol. It's a standard method expected by urllib's cookie handling system for determining the full URL of a request.",
        "recommendation": "keep"
      },
      {
        "name": "has_header",
        "module": "src/requests/cookies.py",
        "lineno": 72,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This method implements the urllib request interface protocol. It's a standard method used by urllib's cookie handling system to check for header existence.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows urllib request interface pattern",
            "Implements standard header checking protocol",
            "MockRequest serves as urllib request interface adapter"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method implements the urllib request interface protocol. It's a standard method used by urllib's cookie handling system to check for header existence.",
        "recommendation": "keep"
      },
      {
        "name": "get_header",
        "module": "src/requests/cookies.py",
        "lineno": 75,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This method implements the urllib request interface protocol. It's a standard method used by urllib's cookie handling system to retrieve header values with fallback logic.",
          "recommendation": "keep",
          "evidence": [
            "Method name matches urllib request interface standard",
            "Implements header retrieval with default value support",
            "MockRequest acts as adapter for urllib cookie handling"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method implements the urllib request interface protocol. It's a standard method used by urllib's cookie handling system to retrieve header values with fallback logic.",
        "recommendation": "keep"
      },
      {
        "name": "add_header",
        "module": "src/requests/cookies.py",
        "lineno": 78,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method implements part of a request-like interface for the cookie jar mechanism. The explicit NotImplementedError with documentation suggests it's intentionally disabled but required for interface compatibility.",
          "recommendation": "keep",
          "evidence": [
            "Part of MockRequest class that mimics urllib2 request interface",
            "Explicit NotImplementedError with clear documentation about when to re-enable"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method implements part of a request-like interface for the cookie jar mechanism. The explicit NotImplementedError with documentation suggests it's intentionally disabled but required for interface compatibility.",
        "recommendation": "keep"
      },
      {
        "name": "add_unredirected_header",
        "module": "src/requests/cookies.py",
        "lineno": 84,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This method is part of the MockRequest interface that mimics urllib2's request object for cookie handling. It's used internally by the cookie jar machinery to track headers during cookie processing.",
          "recommendation": "keep",
          "evidence": [
            "Part of MockRequest class implementing urllib2-like interface",
            "Modifies _new_headers which is used by cookie jar processing"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method is part of the MockRequest interface that mimics urllib2's request object for cookie handling. It's used internally by the cookie jar machinery to track headers during cookie processing.",
        "recommendation": "keep"
      },
      {
        "name": "list_domains",
        "module": "src/requests/cookies.py",
        "lineno": 277,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 75,
          "category": "public_api",
          "reason": "This is a utility method on RequestsCookieJar that provides useful functionality for cookie management. Even though the class isn't marked as exported, cookie jar methods are commonly used by library consumers for debugging and inspection.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented utility method with clear purpose",
            "RequestsCookieJar is a core requests component likely used externally"
          ]
        },
        "status": "false_positive",
        "confidence": 75,
        "reason": "This is a utility method on RequestsCookieJar that provides useful functionality for cookie management. Even though the class isn't marked as exported, cookie jar methods are commonly used by library consumers for debugging and inspection.",
        "recommendation": "keep"
      },
      {
        "name": "list_paths",
        "module": "src/requests/cookies.py",
        "lineno": 285,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 75,
          "category": "public_api",
          "reason": "Similar to list_domains, this is a utility method on RequestsCookieJar for inspecting cookie paths. It provides valuable functionality for users who need to examine their cookie jar contents.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented utility method with clear purpose",
            "Complements list_domains as part of cookie inspection utilities"
          ]
        },
        "status": "false_positive",
        "confidence": 75,
        "reason": "Similar to list_domains, this is a utility method on RequestsCookieJar for inspecting cookie paths. It provides valuable functionality for users who need to examine their cookie jar contents.",
        "recommendation": "keep"
      },
      {
        "name": "multiple_domains",
        "module": "src/requests/cookies.py",
        "lineno": 293,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This method provides useful functionality for determining if cookies span multiple domains, which is important for security and session management. The detailed docstring and return type annotation suggest it's intended for external use.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented with proper return type annotation",
            "Addresses common use case of checking for cross-domain cookies"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This method provides useful functionality for determining if cookies span multiple domains, which is important for security and session management. The detailed docstring and return type annotation suggest it's intended for external use.",
        "recommendation": "keep"
      },
      {
        "name": "get_dict",
        "module": "src/requests/cookies.py",
        "lineno": 306,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is part of RequestsCookieJar which extends cookielib.CookieJar and MutableMapping, making it a cookie manipulation utility. Even though the class isn't directly exported, it's likely used by users who receive Response objects with cookie jars from requests.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented method with clear public API signature and docstring",
            "Part of cookie jar functionality that users commonly need to access",
            "Extends standard library interfaces suggesting public usage patterns"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of RequestsCookieJar which extends cookielib.CookieJar and MutableMapping, making it a cookie manipulation utility. Even though the class isn't directly exported, it's likely used by users who receive Response objects with cookie jars from requests.",
        "recommendation": "keep"
      },
      {
        "name": "_find",
        "module": "src/requests/cookies.py",
        "lineno": 366,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Despite the underscore prefix, the docstring explicitly states 'Requests uses this method internally to get cookie values' and provides detailed documentation about its behavior and alternatives. This suggests it's part of the semi-public API for advanced cookie handling.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly mentions internal usage by Requests library",
            "Detailed documentation including parameter descriptions and behavior notes",
            "References related method _find_no_duplicates suggesting part of a coherent API"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Despite the underscore prefix, the docstring explicitly states 'Requests uses this method internally to get cookie values' and provides detailed documentation about its behavior and alternatives. This suggests it's part of the semi-public API for advanced cookie handling.",
        "recommendation": "keep"
      },
      {
        "name": "deregister_hook",
        "module": "src/requests/models.py",
        "lineno": 218,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is the counterpart to register_hook for managing request/response hooks. Hook systems typically require both registration and deregistration methods, and users need this functionality to clean up or modify hook configurations dynamically.",
          "recommendation": "keep",
          "evidence": [
            "Part of hook management system which is a key feature in HTTP libraries",
            "Complementary method to register_hook - both are needed for complete hook management",
            "Well-documented with clear return value semantics"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is the counterpart to register_hook for managing request/response hooks. Hook systems typically require both registration and deregistration methods, and users need this functionality to clean up or modify hook configurations dynamically.",
        "recommendation": "keep"
      },
      {
        "name": "iter_lines",
        "module": "src/requests/models.py",
        "lineno": 857,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This method is part of the Response class which is exported, making it public API. The method provides line-by-line iteration over response data, which is a common use case for processing large responses or streaming data.",
          "recommendation": "keep",
          "evidence": [
            "Response class is exported making all its methods public API",
            "Documented method for streaming/memory-efficient processing of large responses",
            "Common pattern in HTTP libraries for processing text responses line by line"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This method is part of the Response class which is exported, making it public API. The method provides line-by-line iteration over response data, which is a common use case for processing large responses or streaming data.",
        "recommendation": "keep"
      },
      {
        "name": "dict_to_sequence",
        "module": "src/requests/utils.py",
        "lineno": 127,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 60,
          "category": "genuinely_unused",
          "reason": "This utility function has a very generic name and minimal documentation. Located in utils.py, it could be either an internal helper that's genuinely unused or a utility function that's used in ways not easily detectable by static analysis.",
          "recommendation": "investigate",
          "evidence": [
            "Very simple function that converts dict-like objects to sequence format",
            "Located in utils module suggesting internal helper function",
            "Minimal documentation makes it unclear if it's part of public utilities"
          ]
        },
        "status": "uncertain",
        "confidence": 60,
        "reason": "This utility function has a very generic name and minimal documentation. Located in utils.py, it could be either an internal helper that's genuinely unused or a utility function that's used in ways not easily detectable by static analysis.",
        "recommendation": "investigate"
      },
      {
        "name": "from_key_val_list",
        "module": "src/requests/utils.py",
        "lineno": 308,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a utility function in requests library with comprehensive docstring and examples. As a library function, it's likely part of the public API for converting various data structures to OrderedDict format.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented function with docstring examples showing usage patterns",
            "Located in utils.py which typically contains public utility functions in libraries",
            "Function name suggests general-purpose data conversion utility"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a utility function in requests library with comprehensive docstring and examples. As a library function, it's likely part of the public API for converting various data structures to OrderedDict format.",
        "recommendation": "keep"
      },
      {
        "name": "parse_list_header",
        "module": "src/requests/utils.py",
        "lineno": 365,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This function parses HTTP headers according to RFC 2068 specification. In a library like requests, HTTP header parsing utilities are essential public API functions for users handling custom header processing.",
          "recommendation": "keep",
          "evidence": [
            "References RFC 2068 specification, indicating standards-compliant HTTP functionality",
            "Header parsing is core functionality for HTTP libraries",
            "Well-documented with clear purpose for handling quoted strings in HTTP headers"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This function parses HTTP headers according to RFC 2068 specification. In a library like requests, HTTP header parsing utilities are essential public API functions for users handling custom header processing.",
        "recommendation": "keep"
      },
      {
        "name": "dict_from_cookiejar",
        "module": "src/requests/utils.py",
        "lineno": 457,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a utility function for converting CookieJar objects to dictionaries. In an HTTP library like requests, cookie manipulation utilities are commonly used by external users for session management and cookie handling.",
          "recommendation": "keep",
          "evidence": [
            "Clear utility function for cookie handling, a core HTTP library feature",
            "Simple, well-documented interface with type annotations",
            "Cookie manipulation is common in HTTP client usage patterns"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a utility function for converting CookieJar objects to dictionaries. In an HTTP library like requests, cookie manipulation utilities are commonly used by external users for session management and cookie handling.",
        "recommendation": "keep"
      },
      {
        "name": "add_dict_to_cookiejar",
        "module": "src/requests/utils.py",
        "lineno": 468,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Companion function to dict_from_cookiejar for converting dictionaries back to CookieJar format. This bidirectional conversion utility is typical public API for HTTP libraries dealing with session management.",
          "recommendation": "keep",
          "evidence": [
            "Provides reverse functionality to dict_from_cookiejar for complete cookie conversion",
            "Well-documented utility function for cookie handling",
            "Uses internal cookiejar_from_dict function, suggesting it's a public wrapper"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Companion function to dict_from_cookiejar for converting dictionaries back to CookieJar format. This bidirectional conversion utility is typical public API for HTTP libraries dealing with session management.",
        "recommendation": "keep"
      },
      {
        "name": "get_encodings_from_content",
        "module": "src/requests/utils.py",
        "lineno": 479,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 95,
          "category": "deprecated",
          "reason": "This function has an explicit DeprecationWarning stating it will be removed in requests 3.0 and references issue #2266 for discussion. The warning indicates this is officially deprecated functionality.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Contains explicit DeprecationWarning about removal in requests 3.0",
            "Warning references specific GitHub issue #2266 for deprecation discussion",
            "Warning is designed to appear only once, indicating planned removal"
          ]
        },
        "status": "dead_code",
        "confidence": 95,
        "reason": "This function has an explicit DeprecationWarning stating it will be removed in requests 3.0 and references issue #2266 for discussion. The warning indicates this is officially deprecated functionality.",
        "recommendation": "safe_to_delete"
      },
      {
        "name": "get_unicode_from_response",
        "module": "src/requests/utils.py",
        "lineno": 581,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 95,
          "category": "deprecated",
          "reason": "Function explicitly warns that it will be removed in requests 3.0 and references issue #2266 for discussion. This is clearly marked deprecated code that is safe to remove.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Contains warnings.warn() indicating removal in requests 3.0",
            "References specific issue #2266 for deprecation discussion",
            "Deprecation warning suggests this functionality is being phased out"
          ]
        },
        "status": "dead_code",
        "confidence": 95,
        "reason": "Function explicitly warns that it will be removed in requests 3.0 and references issue #2266 for discussion. This is clearly marked deprecated code that is safe to remove.",
        "recommendation": "safe_to_delete"
      }
    ],
    "unused_classes": [
      {
        "name": "FlaskyStyle",
        "module": "docs/_themes/flask_theme_support.py",
        "lineno": 7,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This class is in a documentation theme support file under docs/_themes/, which is used by Sphinx documentation generation. Theme classes are typically instantiated by documentation build tools, not called directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Located in docs/_themes/ directory indicating documentation tooling",
            "Inherits from Style class suggesting it's a theme/styling component used by external tools"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This class is in a documentation theme support file under docs/_themes/, which is used by Sphinx documentation generation. Theme classes are typically instantiated by documentation build tools, not called directly in code.",
        "recommendation": "keep"
      },
      {
        "name": "BaseAdapter",
        "module": "src/requests/adapters.py",
        "lineno": 113,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a base class in the requests library's adapters module with clear documentation. Base classes in libraries are typically meant to be subclassed by users, making it part of the public API even if not directly instantiated internally.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented base class in a major library (requests)",
            "Base classes are typically part of public API for inheritance patterns"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a base class in the requests library's adapters module with clear documentation. Base classes in libraries are typically meant to be subclassed by users, making it part of the public API even if not directly instantiated internally.",
        "recommendation": "keep"
      },
      {
        "name": "AuthBase",
        "module": "src/requests/auth.py",
        "lineno": 69,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is clearly documented as a base class that all auth implementations derive from in the requests library. It's designed as an interface for users to create custom authentication handlers, making it essential public API.",
          "recommendation": "keep",
          "evidence": [
            "Explicit docstring states 'all auth implementations derive from' this class",
            "Part of requests library's authentication system public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is clearly documented as a base class that all auth implementations derive from in the requests library. It's designed as an interface for users to create custom authentication handlers, making it essential public API.",
        "recommendation": "keep"
      },
      {
        "name": "HTTPProxyAuth",
        "module": "src/requests/auth.py",
        "lineno": 99,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a concrete authentication class in the requests library with clear documentation about attaching HTTP Proxy Authentication. It's part of the public API for users who need proxy authentication functionality.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented authentication class for specific use case (proxy auth)",
            "Inherits from HTTPBasicAuth indicating it's part of auth system hierarchy"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a concrete authentication class in the requests library with clear documentation about attaching HTTP Proxy Authentication. It's part of the public API for users who need proxy authentication functionality.",
        "recommendation": "keep"
      },
      {
        "name": "HTTPDigestAuth",
        "module": "src/requests/auth.py",
        "lineno": 107,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a concrete authentication class implementing HTTP Digest Authentication in the requests library. It's clearly part of the public API for users who need digest authentication, inheriting from AuthBase as intended.",
          "recommendation": "keep",
          "evidence": [
            "Well-documented authentication class for HTTP Digest Authentication",
            "Inherits from AuthBase following the documented inheritance pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a concrete authentication class implementing HTTP Digest Authentication in the requests library. It's clearly part of the public API for users who need digest authentication, inheriting from AuthBase as intended.",
        "recommendation": "keep"
      },
      {
        "name": "RequestsWarning",
        "module": "src/requests/exceptions.py",
        "lineno": 142,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a base warning class for the requests library that users can catch or reference. Warning classes are part of the public API and don't need to be instantiated internally to be useful.",
          "recommendation": "keep",
          "evidence": [
            "Has clear docstring indicating it's the 'Base warning for Requests'",
            "Warning classes are typically part of public API for exception handling",
            "Located in exceptions.py suggesting it's meant for external use"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a base warning class for the requests library that users can catch or reference. Warning classes are part of the public API and don't need to be instantiated internally to be useful.",
        "recommendation": "keep"
      },
      {
        "name": "RequestEncodingMixin",
        "module": "src/requests/models.py",
        "lineno": 84,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a mixin class that provides encoding functionality and is likely used as a base class for other request-related classes. Mixin classes are designed to be inherited from rather than instantiated directly.",
          "recommendation": "keep",
          "evidence": [
            "Name follows mixin pattern indicating it's meant for inheritance",
            "Located in models.py suggesting it's part of the core architecture",
            "Mixin classes provide functionality through inheritance, not direct instantiation"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a mixin class that provides encoding functionality and is likely used as a base class for other request-related classes. Mixin classes are designed to be inherited from rather than instantiated directly.",
        "recommendation": "keep"
      },
      {
        "name": "RequestHooksMixin",
        "module": "src/requests/models.py",
        "lineno": 206,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a mixin class that provides hook functionality for requests. Like other mixins, it's designed to be inherited from to add hook capabilities to request classes.",
          "recommendation": "keep",
          "evidence": [
            "Name follows mixin pattern indicating it's meant for inheritance",
            "Hooks are a common pattern for extending functionality in libraries",
            "Located in models.py as part of the core request architecture"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a mixin class that provides hook functionality for requests. Like other mixins, it's designed to be inherited from to add hook capabilities to request classes.",
        "recommendation": "keep"
      },
      {
        "name": "SessionRedirectMixin",
        "module": "src/requests/sessions.py",
        "lineno": 106,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a mixin class that handles redirect functionality for sessions. It's designed to be inherited by session classes to provide redirect handling capabilities.",
          "recommendation": "keep",
          "evidence": [
            "Name follows mixin pattern indicating it's meant for inheritance",
            "Located in sessions.py suggesting it's part of session functionality",
            "Redirect handling is core functionality that would be mixed into session classes"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a mixin class that handles redirect functionality for sessions. It's designed to be inherited by session classes to provide redirect handling capabilities.",
        "recommendation": "keep"
      }
    ],
    "unused_imports": [],
    "unused_global_variables": [
      {
        "module": "src/requests/_internal_utils.py",
        "name": "HEADER_VALIDATORS",
        "lineno": 19,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "config",
          "reason": "This variable appears to be a configuration constant in an internal utils module. It's likely used for header validation functionality that may be called conditionally or by external code consuming the library.",
          "recommendation": "keep",
          "evidence": [
            "Located in _internal_utils.py suggesting it's part of internal infrastructure",
            "Name suggests it's a configuration for validation functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This variable appears to be a configuration constant in an internal utils module. It's likely used for header validation functionality that may be called conditionally or by external code consuming the library.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "DEFAULT_POOL_TIMEOUT",
        "lineno": 73,
        "assigned_to": "NoneType",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This is a default configuration constant in adapters.py, likely used as a fallback timeout value for connection pools. Such constants are often referenced conditionally or used as default parameters.",
          "recommendation": "keep",
          "evidence": [
            "Located in adapters.py which handles HTTP connection pooling",
            "Name indicates it's a default configuration value for timeouts"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a default configuration constant in adapters.py, likely used as a fallback timeout value for connection pools. Such constants are often referenced conditionally or used as default parameters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/auth.py",
        "name": "CONTENT_TYPE_FORM_URLENCODED",
        "lineno": 21,
        "assigned_to": "str",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "config",
          "reason": "This is a content-type constant in the auth module, likely used for HTTP authentication that requires form-encoded data. These constants are typically used conditionally based on authentication method.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py module dealing with HTTP authentication",
            "Standard HTTP content-type constant that would be used conditionally"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a content-type constant in the auth module, likely used for HTTP authentication that requires form-encoded data. These constants are typically used conditionally based on authentication method.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/auth.py",
        "name": "CONTENT_TYPE_MULTI_PART",
        "lineno": 22,
        "assigned_to": "str",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "config",
          "reason": "This is a content-type constant in the auth module for multipart data, likely used for specific authentication scenarios involving file uploads or complex data. These constants are used conditionally.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py module dealing with HTTP authentication",
            "Standard HTTP content-type constant for multipart data"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a content-type constant in the auth module for multipart data, likely used for specific authentication scenarios involving file uploads or complex data. These constants are used conditionally.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/compat.py",
        "name": "is_py2",
        "lineno": 52,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 95,
          "category": "deprecated",
          "reason": "This variable checks for Python 2 compatibility, but Python 2 reached end-of-life in 2020. Modern libraries no longer need to support Python 2, making this compatibility check obsolete.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Python 2 reached end-of-life in January 2020",
            "Located in compat.py which typically contains compatibility code that can become obsolete"
          ]
        },
        "status": "dead_code",
        "confidence": 95,
        "reason": "This variable checks for Python 2 compatibility, but Python 2 reached end-of-life in 2020. Modern libraries no longer need to support Python 2, making this compatibility check obsolete.",
        "recommendation": "safe_to_delete"
      },
      {
        "module": "src/requests/compat.py",
        "name": "is_py3",
        "lineno": 55,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a compatibility variable in compat.py module that likely provides Python version detection for library users. Compat modules typically export such variables for external use to handle version differences.",
          "recommendation": "keep",
          "evidence": [
            "Located in compat.py which is typically used for cross-version compatibility",
            "Python version detection variables are commonly used by library consumers"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a compatibility variable in compat.py module that likely provides Python version detection for library users. Compat modules typically export such variables for external use to handle version differences.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/compat.py",
        "name": "builtin_str",
        "lineno": 101,
        "assigned_to": "str",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a compatibility variable that normalizes string types between Python 2 and 3. Such variables are essential for libraries that need to support multiple Python versions and are typically used by external code.",
          "recommendation": "keep",
          "evidence": [
            "Part of compat.py module which provides cross-version compatibility utilities",
            "String type normalization is a common pattern for Python 2/3 compatibility"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a compatibility variable that normalizes string types between Python 2 and 3. Such variables are essential for libraries that need to support multiple Python versions and are typically used by external code.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/compat.py",
        "name": "basestring",
        "lineno": 104,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This provides Python 2's basestring type for Python 3 compatibility. It's a standard compatibility shim that external code may rely on for isinstance checks across Python versions.",
          "recommendation": "keep",
          "evidence": [
            "basestring compatibility is a well-known Python 2/3 migration pattern",
            "Typically used in isinstance() checks by external library users"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This provides Python 2's basestring type for Python 3 compatibility. It's a standard compatibility shim that external code may rely on for isinstance checks across Python versions.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/compat.py",
        "name": "numeric_types",
        "lineno": 105,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a tuple of numeric types for cross-version compatibility. Such type collections are commonly used by library consumers for isinstance checks and type validation.",
          "recommendation": "keep",
          "evidence": [
            "Type tuple variables are standard patterns in compatibility modules",
            "Numeric type checking is commonly needed by library users"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a tuple of numeric types for cross-version compatibility. Such type collections are commonly used by library consumers for isinstance checks and type validation.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/compat.py",
        "name": "integer_types",
        "lineno": 106,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Similar to numeric_types, this provides a cross-version compatible way to check for integer types. Library users commonly need such compatibility variables for type checking.",
          "recommendation": "keep",
          "evidence": [
            "Integer type compatibility is essential for Python 2/3 support",
            "Part of standard compat module pattern for type checking utilities"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Similar to numeric_types, this provides a cross-version compatible way to check for integer types. Library users commonly need such compatibility variables for type checking.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "DEFAULT_REDIRECT_LIMIT",
        "lineno": 79,
        "assigned_to": "int",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This is a configuration constant that defines the default maximum number of redirects for HTTP requests. In a library like requests, such constants are typically used internally by the library's redirect handling logic and may also be referenced by users for configuration purposes.",
          "recommendation": "keep",
          "evidence": [
            "Located in models.py which contains core request/response classes",
            "Named as a DEFAULT_ constant suggesting it's a configuration parameter",
            "Requests library needs redirect limits for HTTP redirect handling"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a configuration constant that defines the default maximum number of redirects for HTTP requests. In a library like requests, such constants are typically used internally by the library's redirect handling logic and may also be referenced by users for configuration purposes.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/utils.py",
        "name": "DEFAULT_CA_BUNDLE_PATH",
        "lineno": 64,
        "assigned_to": "certs.where",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "config",
          "reason": "This constant defines the default path to CA certificates bundle for SSL verification. In the requests library, this is essential for HTTPS certificate validation and is likely used by the SSL/TLS handling code, even if not directly called in the analyzed codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in utils.py which contains utility functions and constants",
            "CA bundle paths are critical for SSL certificate verification",
            "Requests library requires SSL certificate handling for HTTPS"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This constant defines the default path to CA certificates bundle for SSL verification. In the requests library, this is essential for HTTPS certificate validation and is likely used by the SSL/TLS handling code, even if not directly called in the analyzed codebase.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/utils.py",
        "name": "DEFAULT_PORTS",
        "lineno": 66,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This constant likely contains a mapping of protocol schemes to their default ports (e.g., http:80, https:443). This is fundamental for URL parsing and connection establishment in an HTTP library, and would be used by URL processing and connection logic.",
          "recommendation": "keep",
          "evidence": [
            "Located in utils.py alongside other utility constants",
            "Default ports are essential for HTTP/HTTPS URL handling",
            "Standard configuration data needed for proper URL resolution"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This constant likely contains a mapping of protocol schemes to their default ports (e.g., http:80, https:443). This is fundamental for URL parsing and connection establishment in an HTTP library, and would be used by URL processing and connection logic.",
        "recommendation": "keep"
      }
    ],
    "unreachable_code": [],
    "suspicious_patterns": [
      {
        "module": "src/requests/adapters.py",
        "name": "send",
        "lineno": 119,
        "pattern_type": "too_many_parameters",
        "details": "Function has 7 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is an abstract method in BaseAdapter that raises NotImplementedError. It defines the interface that concrete adapters must implement.",
          "recommendation": "keep",
          "evidence": [
            "Method raises NotImplementedError indicating it's an abstract interface method",
            "BaseAdapter is likely a base class that other adapters inherit from"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is an abstract method in BaseAdapter that raises NotImplementedError. It defines the interface that concrete adapters must implement.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "send",
        "lineno": 590,
        "pattern_type": "long_function",
        "details": "Function is very long (107 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is the concrete implementation of the send method in HTTPAdapter. HTTPAdapter is likely exported and this method is part of the public API for sending HTTP requests.",
          "recommendation": "keep",
          "evidence": [
            "Implements the abstract send method from BaseAdapter",
            "HTTPAdapter is a core component of requests library that users interact with"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is the concrete implementation of the send method in HTTPAdapter. HTTPAdapter is likely exported and this method is part of the public API for sending HTTP requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "send",
        "lineno": 590,
        "pattern_type": "too_many_parameters",
        "details": "Function has 7 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This appears to be a duplicate entry of the same HTTPAdapter.send method. It's part of the public API for the requests library.",
          "recommendation": "keep",
          "evidence": [
            "Same method as item #2, core functionality of HTTPAdapter",
            "Essential for HTTP request processing in the requests library"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a duplicate entry of the same HTTPAdapter.send method. It's part of the public API for the requests library.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/auth.py",
        "name": "build_digest_header",
        "lineno": 126,
        "pattern_type": "long_function",
        "details": "Function is very long (109 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is likely part of a digest authentication class that's exported. Digest auth is a standard HTTP authentication method that users would call directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py suggesting it's part of authentication functionality",
            "Digest authentication is a public feature of requests library"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is likely part of a digest authentication class that's exported. Digest auth is a standard HTTP authentication method that users would call directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "too_many_parameters",
        "details": "Function has 11 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This method is likely part of a Request or PreparedRequest class in models.py. These are core public API classes where users prepare requests before sending.",
          "recommendation": "keep",
          "evidence": [
            "Located in models.py which contains core request/response models",
            "Prepare methods are standard in HTTP libraries for request preparation"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method is likely part of a Request or PreparedRequest class in models.py. These are core public API classes where users prepare requests before sending.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "resolve_redirects",
        "lineno": 159,
        "pattern_type": "long_function",
        "details": "Function is very long (122 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This method is part of the Session class in the requests library, which is a core public API component. Users may override or call this method directly to customize redirect handling behavior.",
          "recommendation": "keep",
          "evidence": [
            "Method is part of Session class which is exported in requests library",
            "Redirect resolution is a core HTTP functionality that users may need to customize"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This method is part of the Session class in the requests library, which is a core public API component. Users may override or call this method directly to customize redirect handling behavior.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "resolve_redirects",
        "lineno": 159,
        "pattern_type": "too_many_parameters",
        "details": "Function has 9 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Duplicate of item #1 - this method is part of the Session class public API. Users may override or call this method directly to customize redirect handling behavior.",
          "recommendation": "keep",
          "evidence": [
            "Method is part of Session class which is exported in requests library",
            "Redirect resolution is a core HTTP functionality that users may need to customize"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Duplicate of item #1 - this method is part of the Session class public API. Users may override or call this method directly to customize redirect handling behavior.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "request",
        "lineno": 500,
        "pattern_type": "too_many_parameters",
        "details": "Function has 17 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 98,
          "category": "public_api",
          "reason": "This is the core request method of the Session class, which is the primary way users make HTTP requests in the requests library. This is definitely public API that external users call directly.",
          "recommendation": "keep",
          "evidence": [
            "Session.request() is the fundamental method for making HTTP requests",
            "Session class is exported and this method is heavily documented as public API"
          ]
        },
        "status": "false_positive",
        "confidence": 98,
        "reason": "This is the core request method of the Session class, which is the primary way users make HTTP requests in the requests library. This is definitely public API that external users call directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "__init__",
        "lineno": 116,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "__init__ methods are constructor methods that are automatically called when objects are instantiated. Even if not called directly in code, they are invoked by Python's object creation mechanism.",
          "recommendation": "keep",
          "evidence": [
            "__init__ is a special method called automatically during object instantiation",
            "Located in adapters.py which likely contains classes that users instantiate"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "__init__ methods are constructor methods that are automatically called when objects are instantiated. Even if not called directly in code, they are invoked by Python's object creation mechanism.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "__init__",
        "lineno": 178,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "__init__ methods are constructor methods that are automatically called when objects are instantiated. Even if not called directly in code, they are invoked by Python's object creation mechanism.",
          "recommendation": "keep",
          "evidence": [
            "__init__ is a special method called automatically during object instantiation",
            "Located in adapters.py which likely contains classes that users instantiate"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "__init__ methods are constructor methods that are automatically called when objects are instantiated. Even if not called directly in code, they are invoked by Python's object creation mechanism.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection_with_tls_context",
        "lineno": 423,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_connection in src/requests/adapters.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
          "recommendation": "keep",
          "evidence": [
            "Located in adapters.py which contains public adapter classes",
            "Method name suggests it's part of the connection management API that users may need to customize"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection_with_tls_context",
        "lineno": 423,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/api.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
          "recommendation": "keep",
          "evidence": [
            "Located in adapters.py which contains public adapter classes",
            "Method name suggests it's part of the connection management API that users may need to customize"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection_with_tls_context",
        "lineno": 423,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
          "recommendation": "keep",
          "evidence": [
            "Located in adapters.py which contains public adapter classes",
            "Method name suggests it's part of the connection management API that users may need to customize"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection_with_tls_context",
        "lineno": 423,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
          "recommendation": "keep",
          "evidence": [
            "Located in adapters.py which contains public adapter classes",
            "Method name suggests it's part of the connection management API that users may need to customize"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection_with_tls_context",
        "lineno": 423,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
          "recommendation": "keep",
          "evidence": [
            "Located in adapters.py which contains public adapter classes",
            "Method name suggests it's part of the connection management API that users may need to customize"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of the HTTPAdapter class in the requests library, which is a public API component. The requests library is designed for external consumption, and adapter methods like this are intended to be overridden or called by users implementing custom adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection",
        "lineno": 472,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/api.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a method in the HTTPAdapter class which is exported in the requests library. It's part of the public API that allows users to customize connection pooling behavior when subclassing adapters.",
          "recommendation": "keep",
          "evidence": [
            "HTTPAdapter is a core class in the requests library",
            "Method provides connection pooling functionality that users may override or call directly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a method in the HTTPAdapter class which is exported in the requests library. It's part of the public API that allows users to customize connection pooling behavior when subclassing adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection",
        "lineno": 472,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a method in the HTTPAdapter class which is exported in the requests library. It's part of the public API that allows users to customize connection pooling behavior when subclassing adapters.",
          "recommendation": "keep",
          "evidence": [
            "HTTPAdapter is a core class in the requests library",
            "Method provides connection pooling functionality that users may override or call directly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a method in the HTTPAdapter class which is exported in the requests library. It's part of the public API that allows users to customize connection pooling behavior when subclassing adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection",
        "lineno": 472,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a method in the HTTPAdapter class which is exported in the requests library. It's part of the public API that allows users to customize connection pooling behavior when subclassing adapters.",
          "recommendation": "keep",
          "evidence": [
            "HTTPAdapter is a core class in the requests library",
            "Method provides connection pooling functionality that users may override or call directly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a method in the HTTPAdapter class which is exported in the requests library. It's part of the public API that allows users to customize connection pooling behavior when subclassing adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "get_connection",
        "lineno": 472,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a method in the HTTPAdapter class which is exported in the requests library. It's part of the public API that allows users to customize connection pooling behavior when subclassing adapters.",
          "recommendation": "keep",
          "evidence": [
            "HTTPAdapter is a core class in the requests library",
            "Method provides connection pooling functionality that users may override or call directly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a method in the HTTPAdapter class which is exported in the requests library. It's part of the public API that allows users to customize connection pooling behavior when subclassing adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "request_url",
        "lineno": 523,
        "pattern_type": "similar_function_names",
        "details": "Similar to request in src/requests/api.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a method in the HTTPAdapter class that's part of the requests library's public API. It's used for URL construction and may be called or overridden by users implementing custom adapters.",
          "recommendation": "keep",
          "evidence": [
            "Located in HTTPAdapter which is a core exported class",
            "Provides URL handling functionality that's part of the adapter interface"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a method in the HTTPAdapter class that's part of the requests library's public API. It's used for URL construction and may be called or overridden by users implementing custom adapters.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "request_url",
        "lineno": 523,
        "pattern_type": "similar_function_names",
        "details": "Similar to request in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is likely a method in the HTTPAdapter class which is part of requests' public API. Adapters are designed to be subclassed by users who may override or call this method directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in adapters.py which contains the adapter interface",
            "Adapters are documented as extensible components in requests library"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is likely a method in the HTTPAdapter class which is part of requests' public API. Adapters are designed to be subclassed by users who may override or call this method directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/adapters.py",
        "name": "add_headers",
        "lineno": 555,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_header in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This appears to be part of the adapter interface in requests. Custom adapters may need to override or call this method to modify request headers, making it part of the extensible API.",
          "recommendation": "keep",
          "evidence": [
            "Part of the adapter system which is designed for customization",
            "Header manipulation is a common requirement for custom adapters"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This appears to be part of the adapter interface in requests. Custom adapters may need to override or call this method to modify request headers, making it part of the extensible API.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_header in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET method in requests.api module, which is the primary public interface for making HTTP GET requests. This is one of the most commonly used functions in the entire requests library.",
          "recommendation": "keep",
          "evidence": [
            "Located in api.py which contains the main public interface functions",
            "GET is a fundamental HTTP method and core functionality of requests"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET method in requests.api module, which is the primary public interface for making HTTP GET requests. This is one of the most commonly used functions in the entire requests library.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_type in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Duplicate of the GET method in requests.api module. This is the primary public interface for HTTP GET requests and is extensively used by external users of the library.",
          "recommendation": "keep",
          "evidence": [
            "Core public API function in the main api module",
            "Essential HTTP functionality that users depend on"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Duplicate of the GET method in requests.api module. This is the primary public interface for HTTP GET requests and is extensively used by external users of the library.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_host in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Another duplicate of the GET method in requests.api module. This is fundamental public API functionality that external users rely on for making HTTP GET requests.",
          "recommendation": "keep",
          "evidence": [
            "Primary entry point for GET requests in the public API",
            "Critical functionality for library users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Another duplicate of the GET method in requests.api module. This is fundamental public API functionality that external users rely on for making HTTP GET requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_origin_req_host in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET requests are the most common HTTP operation and core functionality of requests library",
            "Function would be imported and used externally as requests.get()"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_full_url in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET requests are the most common HTTP operation and core functionality of requests library",
            "Function would be imported and used externally as requests.get()"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_header in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET requests are the most common HTTP operation and core functionality of requests library",
            "Function would be imported and used externally as requests.get()"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_new_headers in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET requests are the most common HTTP operation and core functionality of requests library",
            "Function would be imported and used externally as requests.get()"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to getheaders in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET requests are the most common HTTP operation and core functionality of requests library",
            "Function would be imported and used externally as requests.get()"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET function in the requests library, which is the primary public API for making HTTP GET requests. It's exported and used by millions of external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_dict in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "requests.get() is one of the most commonly used functions in the requests library",
            "This is a library project where API functions are meant to be called externally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_policy in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "requests.get() is one of the most commonly used functions in the requests library",
            "This is a library project where API functions are meant to be called externally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_redirect_target in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "requests.get() is one of the most commonly used functions in the requests library",
            "This is a library project where API functions are meant to be called externally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_adapter in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "requests.get() is one of the most commonly used functions in the requests library",
            "This is a library project where API functions are meant to be called externally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_netrc_auth in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "requests.get() is one of the most commonly used functions in the requests library",
            "This is a library project where API functions are meant to be called externally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main requests.get() function in the requests library, which is the primary HTTP GET method exported for external users. It's a core public API function that users call directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_encodings_from_content in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET is a fundamental HTTP method that would be heavily used by library consumers",
            "Requests is a popular HTTP library where this would be a primary entry point"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_encoding_from_headers in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET is a fundamental HTTP method that would be heavily used by library consumers",
            "Requests is a popular HTTP library where this would be a primary entry point"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_unicode_from_response in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET is a fundamental HTTP method that would be heavily used by library consumers",
            "Requests is a popular HTTP library where this would be a primary entry point"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_environ_proxies in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET is a fundamental HTTP method that would be heavily used by library consumers",
            "Requests is a popular HTTP library where this would be a primary entry point"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_auth_from_url in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/api.py which contains the main public API functions",
            "GET is a fundamental HTTP method that would be heavily used by library consumers",
            "Requests is a popular HTTP library where this would be a primary entry point"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET HTTP method in the requests library API. It's a core public function that external users rely on to make HTTP GET requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/api.py",
        "name": "get",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_proxy in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET function in requests.api module, which is the primary public API entry point for making HTTP GET requests. The requests library is designed for external users to call requests.get() directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in api.py which contains the main public API functions",
            "GET is a fundamental HTTP method that external users need to access",
            "This is likely exported as requests.get() for public consumption"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET function in requests.api module, which is the primary public API entry point for making HTTP GET requests. The requests library is designed for external users to call requests.get() directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/auth.py",
        "name": "__init__",
        "lineno": 79,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is an __init__ method for an authentication class in the requests library. Constructor methods are part of the public API when the class is exported, allowing external users to instantiate authentication objects.",
          "recommendation": "keep",
          "evidence": [
            "__init__ methods are required for class instantiation by external users",
            "Authentication classes are typically part of the public API in HTTP libraries",
            "Located in auth.py suggesting it's a core authentication component"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is an __init__ method for an authentication class in the requests library. Constructor methods are part of the public API when the class is exported, allowing external users to instantiate authentication objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/auth.py",
        "name": "__init__",
        "lineno": 110,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Another __init__ method for an authentication class in the requests library. Like the previous one, this constructor is needed for external users to create instances of this authentication class.",
          "recommendation": "keep",
          "evidence": [
            "__init__ methods are essential for object instantiation",
            "Multiple auth classes suggest different authentication strategies for users",
            "Part of the authentication module which is core library functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Another __init__ method for an authentication class in the requests library. Like the previous one, this constructor is needed for external users to create instances of this authentication class.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_cookie_header",
        "lineno": 140,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This method is likely part of a cookie handling class that provides functionality for managing HTTP cookies. Cookie manipulation is a core feature that external users of the requests library would need access to.",
          "recommendation": "keep",
          "evidence": [
            "Cookie management is fundamental HTTP functionality",
            "Method name suggests it formats cookies for HTTP headers",
            "Located in cookies.py indicating it's part of the cookie handling API"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is likely part of a cookie handling class that provides functionality for managing HTTP cookies. Cookie manipulation is a core feature that external users of the requests library would need access to.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_cookie_header",
        "lineno": 140,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Same as item #4 - this appears to be a duplicate entry for the same get_cookie_header method. It's part of the public cookie handling API for external library users.",
          "recommendation": "keep",
          "evidence": [
            "Same method as previous item",
            "Cookie header generation is needed for HTTP request preparation",
            "Essential functionality for a HTTP client library"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Same as item #4 - this appears to be a duplicate entry for the same get_cookie_header method. It's part of the public cookie handling API for external library users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_cookie_header",
        "lineno": 140,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is likely a utility function in the requests library's cookie module that provides public API functionality for extracting cookie headers. The requests library is designed for external use, and cookie handling is a core feature.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library cookies module, indicating core functionality",
            "Function name suggests public API for cookie header extraction"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely a utility function in the requests library's cookie module that provides public API functionality for extracting cookie headers. The requests library is designed for external use, and cookie handling is a core feature.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "__init__",
        "lineno": 35,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is a constructor method (__init__) which is automatically called when instantiating objects. Constructor methods are fundamental Python protocol methods that don't require explicit internal calls to be considered used.",
          "recommendation": "keep",
          "evidence": [
            "__init__ is a Python magic method called automatically during object instantiation",
            "Constructor methods are essential for class functionality regardless of explicit calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a constructor method (__init__) which is automatically called when instantiating objects. Constructor methods are fundamental Python protocol methods that don't require explicit internal calls to be considered used.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_type",
        "lineno": 40,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a method in the requests library's cookie handling system. Given that requests is a public library, methods in core modules like cookies are likely part of the public API for external users.",
          "recommendation": "keep",
          "evidence": [
            "Part of requests library cookie module, indicating public API",
            "Method name suggests type retrieval functionality for external use"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a method in the requests library's cookie handling system. Given that requests is a public library, methods in core modules like cookies are likely part of the public API for external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_type",
        "lineno": 40,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a method in the requests library's cookie handling system. Given that requests is a public library, methods in core modules like cookies are likely part of the public API for external users.",
          "recommendation": "keep",
          "evidence": [
            "Part of requests library cookie module, indicating public API",
            "Method name suggests type retrieval functionality for external use"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a method in the requests library's cookie handling system. Given that requests is a public library, methods in core modules like cookies are likely part of the public API for external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_type",
        "lineno": 40,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a method in the requests library's cookie handling system. Given that requests is a public library, methods in core modules like cookies are likely part of the public API for external users.",
          "recommendation": "keep",
          "evidence": [
            "Part of requests library cookie module, indicating public API",
            "Method name suggests type retrieval functionality for external use"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a method in the requests library's cookie handling system. Given that requests is a public library, methods in core modules like cookies are likely part of the public API for external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_host",
        "lineno": 43,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery internally, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method implements urllib.request.Request interface for cookie handling",
            "Called by Python's http.cookiejar module during cookie processing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery internally, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_host",
        "lineno": 43,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery internally, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method implements urllib.request.Request interface for cookie handling",
            "Called by Python's http.cookiejar module during cookie processing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery internally, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_host",
        "lineno": 43,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery internally, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method implements urllib.request.Request interface for cookie handling",
            "Called by Python's http.cookiejar module during cookie processing"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery internally, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_origin_req_host",
        "lineno": 46,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery for origin request host validation during cookie processing.",
          "recommendation": "keep",
          "evidence": [
            "Method implements urllib.request.Request interface for cookie handling",
            "Required by Python's http.cookiejar module for security validation"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery for origin request host validation during cookie processing.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_origin_req_host",
        "lineno": 46,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery for origin request host validation during cookie processing.",
          "recommendation": "keep",
          "evidence": [
            "Method implements urllib.request.Request interface for cookie handling",
            "Required by Python's http.cookiejar module for security validation"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of a request adapter interface in the requests library, implementing the urllib.request.Request protocol. It's called by Python's cookie handling machinery for origin request host validation during cookie processing.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_origin_req_host",
        "lineno": 46,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a method that implements a protocol or interface pattern, likely mimicking urllib's request object interface. In a library like requests, such methods are often called by cookie handling mechanisms or external code expecting this interface.",
          "recommendation": "keep",
          "evidence": [
            "Located in cookies.py suggesting it's part of cookie handling infrastructure",
            "Method name follows urllib request object pattern which is commonly expected by cookie libraries"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a method that implements a protocol or interface pattern, likely mimicking urllib's request object interface. In a library like requests, such methods are often called by cookie handling mechanisms or external code expecting this interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_full_url",
        "lineno": 49,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This is likely implementing a standard interface method expected by cookie handling code or external libraries. The get_full_url method is a common pattern in HTTP libraries and is often called by cookie management systems.",
          "recommendation": "keep",
          "evidence": [
            "Part of cookie handling module which needs URL information",
            "Standard method name expected by HTTP cookie protocols"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is likely implementing a standard interface method expected by cookie handling code or external libraries. The get_full_url method is a common pattern in HTTP libraries and is often called by cookie management systems.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_full_url",
        "lineno": 49,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "Duplicate of previous item - this is likely implementing a standard interface method expected by cookie handling code or external libraries.",
          "recommendation": "keep",
          "evidence": [
            "Part of cookie handling module which needs URL information",
            "Standard method name expected by HTTP cookie protocols"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of previous item - this is likely implementing a standard interface method expected by cookie handling code or external libraries.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_full_url",
        "lineno": 49,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "Another duplicate - this is likely implementing a standard interface method expected by cookie handling code or external libraries.",
          "recommendation": "keep",
          "evidence": [
            "Part of cookie handling module which needs URL information",
            "Standard method name expected by HTTP cookie protocols"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Another duplicate - this is likely implementing a standard interface method expected by cookie handling code or external libraries.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_header",
        "lineno": 75,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This method implements a standard interface for accessing HTTP headers, which is commonly expected by cookie handling mechanisms and external code. It's part of the protocol that cookie libraries expect from request-like objects.",
          "recommendation": "keep",
          "evidence": [
            "Standard HTTP header access pattern used by cookie handling",
            "Located in cookies.py indicating it's part of cookie protocol implementation"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method implements a standard interface for accessing HTTP headers, which is commonly expected by cookie handling mechanisms and external code. It's part of the protocol that cookie libraries expect from request-like objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_header",
        "lineno": 75,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a method in the requests library's cookies module, which is a public API library. Methods in cookie handling classes are likely part of the public interface for users to manipulate HTTP headers and cookies.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library cookies module which is public API",
            "Header manipulation is core functionality that external users need"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a method in the requests library's cookies module, which is a public API library. Methods in cookie handling classes are likely part of the public interface for users to manipulate HTTP headers and cookies.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_header",
        "lineno": 75,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of item #1 - same method in requests library's cookies module. This is part of the public API for header manipulation functionality that external users depend on.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library cookies module which is public API",
            "Header manipulation is core functionality that external users need"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of item #1 - same method in requests library's cookies module. This is part of the public API for header manipulation functionality that external users depend on.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_new_headers",
        "lineno": 87,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Method in requests library cookies module for generating new headers. This is likely public API functionality that external users call to manage HTTP headers in cookie operations.",
          "recommendation": "keep",
          "evidence": [
            "Part of requests library public API",
            "Header generation is essential functionality for cookie management"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Method in requests library cookies module for generating new headers. This is likely public API functionality that external users call to manage HTTP headers in cookie operations.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_new_headers",
        "lineno": 87,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of previous item - same method in requests cookies module. This header generation functionality is part of the public API that external users rely on for cookie and header management.",
          "recommendation": "keep",
          "evidence": [
            "Part of requests library public API",
            "Header generation is essential functionality for cookie management"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of previous item - same method in requests cookies module. This header generation functionality is part of the public API that external users rely on for cookie and header management.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_new_headers",
        "lineno": 87,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Another duplicate of the get_new_headers method. Since this is in the requests library cookies module, it's part of the public API for header generation that external users need access to.",
          "recommendation": "keep",
          "evidence": [
            "Part of requests library public API",
            "Header generation is essential functionality for cookie management"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Another duplicate of the get_new_headers method. Since this is in the requests library cookies module, it's part of the public API for header generation that external users need access to.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "__init__",
        "lineno": 110,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is a constructor method (__init__) which is automatically called when instantiating a class. Constructor methods are fundamental to Python's object model and are called by the Python interpreter, not directly by user code.",
          "recommendation": "keep",
          "evidence": [
            "__init__ methods are called automatically during object instantiation",
            "This is part of Python's fundamental object protocol"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a constructor method (__init__) which is automatically called when instantiating a class. Constructor methods are fundamental to Python's object model and are called by the Python interpreter, not directly by user code.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "getheaders",
        "lineno": 120,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This method appears to be part of a cookie handling class in the requests library, which is a widely-used HTTP library. The method name follows HTTP header conventions and is likely part of the public API for external users to retrieve headers.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library, a public HTTP library",
            "Method name 'getheaders' follows standard HTTP/email header interface conventions"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method appears to be part of a cookie handling class in the requests library, which is a widely-used HTTP library. The method name follows HTTP header conventions and is likely part of the public API for external users to retrieve headers.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "getheaders",
        "lineno": 120,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Duplicate of the previous getheaders method analysis. This method is part of the requests library's public API for cookie and header management, expected to be called by external library users.",
          "recommendation": "keep",
          "evidence": [
            "Same method as previous analysis",
            "Part of requests library public interface"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Duplicate of the previous getheaders method analysis. This method is part of the requests library's public API for cookie and header management, expected to be called by external library users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "getheaders",
        "lineno": 120,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Another duplicate of the getheaders method analysis. This remains part of the public API for the requests library's cookie handling functionality.",
          "recommendation": "keep",
          "evidence": [
            "Same method as previous analyses",
            "Consistent with public API expectations for HTTP libraries"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Another duplicate of the getheaders method analysis. This remains part of the public API for the requests library's cookie handling functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_dict in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method is a standard dictionary-like interface method in Python, likely implementing the mapping protocol. It's commonly used by external code and frameworks that expect dictionary-like behavior from cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Standard dictionary protocol method name",
            "Part of Python's mapping interface that external code expects"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method is a standard dictionary-like interface method in Python, likely implementing the mapping protocol. It's commonly used by external code and frameworks that expect dictionary-like behavior from cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_policy in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Cookie classes typically implement dict-like interface with get() method",
            "Standard Python protocol method for dict-like objects",
            "Part of public API for requests library cookie handling"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_redirect_target in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Cookie classes typically implement dict-like interface with get() method",
            "Standard Python protocol method for dict-like objects",
            "Part of public API for requests library cookie handling"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_adapter in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Cookie classes typically implement dict-like interface with get() method",
            "Standard Python protocol method for dict-like objects",
            "Part of public API for requests library cookie handling"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_netrc_auth in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Cookie classes typically implement dict-like interface with get() method",
            "Standard Python protocol method for dict-like objects",
            "Part of public API for requests library cookie handling"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_encodings_from_content in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Cookie classes typically implement dict-like interface with get() method",
            "Standard Python protocol method for dict-like objects",
            "Part of public API for requests library cookie handling"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the dictionary-like interface for cookie containers. This is a standard Python protocol method that external users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_encoding_from_headers in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Located in cookies.py indicating cookie container functionality",
            "Method name 'get' is part of standard Python dict-like interface",
            "This is a library project where such interface methods are expected public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_unicode_from_response in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Located in cookies.py indicating cookie container functionality",
            "Method name 'get' is part of standard Python dict-like interface",
            "This is a library project where such interface methods are expected public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_environ_proxies in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Located in cookies.py indicating cookie container functionality",
            "Method name 'get' is part of standard Python dict-like interface",
            "This is a library project where such interface methods are expected public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_auth_from_url in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Located in cookies.py indicating cookie container functionality",
            "Method name 'get' is part of standard Python dict-like interface",
            "This is a library project where such interface methods are expected public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get",
        "lineno": 194,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_proxy in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Located in cookies.py indicating cookie container functionality",
            "Method name 'get' is part of standard Python dict-like interface",
            "This is a library project where such interface methods are expected public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the 'get' method in a cookies module, which implements the standard dictionary-like interface. The 'get' method is a fundamental dict protocol method that users expect to be available on cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "set",
        "lineno": 206,
        "pattern_type": "similar_function_names",
        "details": "Similar to set_cookie in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a method on a cookie-related class that would be exported as part of the requests library's public API. Cookie manipulation methods are commonly used by external users of the requests library.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/cookies.py which is part of the public requests library API",
            "Cookie setting functionality is a core feature that external users would need"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a method on a cookie-related class that would be exported as part of the requests library's public API. Cookie manipulation methods are commonly used by external users of the requests library.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "set",
        "lineno": 206,
        "pattern_type": "similar_function_names",
        "details": "Similar to set_environ in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of the previous set method - this appears to be a method on a cookie-related class that would be exported as part of the requests library's public API. Cookie manipulation methods are commonly used by external users.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests/cookies.py which is part of the public requests library API",
            "Cookie setting functionality is a core feature that external users would need"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of the previous set method - this appears to be a method on a cookie-related class that would be exported as part of the requests library's public API. Cookie manipulation methods are commonly used by external users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_dict",
        "lineno": 306,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This method provides dictionary access to cookie data, which is a common pattern for external users who want to work with cookies as key-value pairs. This is likely part of the public API for cookie objects.",
          "recommendation": "keep",
          "evidence": [
            "Dictionary conversion methods are standard public API patterns",
            "Users often need to convert cookie objects to dict format for serialization or manipulation"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method provides dictionary access to cookie data, which is a common pattern for external users who want to work with cookies as key-value pairs. This is likely part of the public API for cookie objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_dict",
        "lineno": 306,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Duplicate of the previous get_dict method - this provides dictionary access to cookie data, which is a common pattern for external users who want to work with cookies as key-value pairs.",
          "recommendation": "keep",
          "evidence": [
            "Dictionary conversion methods are standard public API patterns",
            "Users often need to convert cookie objects to dict format for serialization or manipulation"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Duplicate of the previous get_dict method - this provides dictionary access to cookie data, which is a common pattern for external users who want to work with cookies as key-value pairs.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "_find",
        "lineno": 366,
        "pattern_type": "similar_function_names",
        "details": "Similar to _find_no_duplicates in src/requests/cookies.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 70,
          "category": "interface_method",
          "reason": "This is a private method (indicated by underscore prefix) that likely implements internal cookie lookup functionality. It may be used internally by other cookie methods or could be genuinely unused helper code.",
          "recommendation": "investigate",
          "evidence": [
            "Private method naming convention suggests internal use",
            "Cookie finding/lookup is core functionality that would be needed internally"
          ]
        },
        "status": "uncertain",
        "confidence": 70,
        "reason": "This is a private method (indicated by underscore prefix) that likely implements internal cookie lookup functionality. It may be used internally by other cookie methods or could be genuinely unused helper code.",
        "recommendation": "investigate"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_policy",
        "lineno": 435,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method implements the cookie jar interface protocol expected by urllib3 and other HTTP libraries. It's called by the HTTP client internals to get cookie policy, not by application code directly.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows cookie jar protocol convention",
            "Located in cookies.py suggesting it's part of cookie handling interface"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method implements the cookie jar interface protocol expected by urllib3 and other HTTP libraries. It's called by the HTTP client internals to get cookie policy, not by application code directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/cookies.py",
        "name": "get_policy",
        "lineno": 435,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method implements the cookie jar interface protocol expected by urllib3 and other HTTP libraries. It's called by the HTTP client internals to get cookie policy, not by application code directly.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows cookie jar protocol convention",
            "Located in cookies.py suggesting it's part of cookie handling interface"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method implements the cookie jar interface protocol expected by urllib3 and other HTTP libraries. It's called by the HTTP client internals to get cookie policy, not by application code directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/exceptions.py",
        "name": "__init__",
        "lineno": 17,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is an __init__ method for an exception class in the requests library. Exception classes are part of the public API and their constructors are called when exceptions are raised or instantiated by users.",
          "recommendation": "keep",
          "evidence": [
            "__init__ methods are automatically called during object instantiation",
            "Exception classes in libraries are typically part of public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is an __init__ method for an exception class in the requests library. Exception classes are part of the public API and their constructors are called when exceptions are raised or instantiated by users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/exceptions.py",
        "name": "__init__",
        "lineno": 34,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is an __init__ method for an exception class in the requests library. Exception classes are part of the public API and their constructors are called when exceptions are raised or instantiated by users.",
          "recommendation": "keep",
          "evidence": [
            "__init__ methods are automatically called during object instantiation",
            "Exception classes in libraries are typically part of public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is an __init__ method for an exception class in the requests library. Exception classes are part of the public API and their constructors are called when exceptions are raised or instantiated by users.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "__init__",
        "lineno": 258,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is an __init__ method in models.py, likely for a core requests model class like Response or Request. These are fundamental public API classes that users instantiate or that are created internally by the library.",
          "recommendation": "keep",
          "evidence": [
            "__init__ methods are automatically called during object instantiation",
            "Located in models.py suggesting it's a core API class constructor"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is an __init__ method in models.py, likely for a core requests model class like Response or Request. These are fundamental public API classes that users instantiate or that are created internally by the library.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_method in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library's models.py, a core module",
            "Request preparation is a fundamental operation in HTTP client libraries",
            "Method likely exported as part of public API for external users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_url in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library's models.py, a core module",
            "Request preparation is a fundamental operation in HTTP client libraries",
            "Method likely exported as part of public API for external users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_headers in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library's models.py, a core module",
            "Request preparation is a fundamental operation in HTTP client libraries",
            "Method likely exported as part of public API for external users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_body in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library's models.py, a core module",
            "Request preparation is a fundamental operation in HTTP client libraries",
            "Method likely exported as part of public API for external users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_content_length in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in requests library's models.py, a core module",
            "Request preparation is a fundamental operation in HTTP client libraries",
            "Method likely exported as part of public API for external users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the prepare method of the Request class in the requests library, which is a core public API method. Users call this method to prepare HTTP requests, and it's fundamental to the library's functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_auth in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "The prepare method is part of the Request class which is a core public API component in the requests library. This method is used to prepare HTTP requests and is likely called by external users of the library.",
          "recommendation": "keep",
          "evidence": [
            "Located in models.py which contains core request/response classes",
            "requests library is a public library where Request classes are primary API components"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The prepare method is part of the Request class which is a core public API component in the requests library. This method is used to prepare HTTP requests and is likely called by external users of the library.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_cookies in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Same as first occurrence - this is part of the public API for the requests library. The prepare method is essential for request preparation functionality that external users rely on.",
          "recommendation": "keep",
          "evidence": [
            "Core method in requests library's public interface",
            "Essential for HTTP request preparation workflow"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Same as first occurrence - this is part of the public API for the requests library. The prepare method is essential for request preparation functionality that external users rely on.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_hooks in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Consistent with other occurrences - this is a public API method in the requests library that external users depend on for preparing HTTP requests.",
          "recommendation": "keep",
          "evidence": [
            "Part of the established public API pattern",
            "Required for proper request object functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Consistent with other occurrences - this is a public API method in the requests library that external users depend on for preparing HTTP requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 295,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_request in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Fourth occurrence of the same public API method. In a library context, multiple references to the same method signature indicate it's part of the documented public interface.",
          "recommendation": "keep",
          "evidence": [
            "Consistent public API pattern across the codebase",
            "Multiple references suggest active use in library interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Fourth occurrence of the same public API method. In a library context, multiple references to the same method signature indicate it's part of the documented public interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "__init__",
        "lineno": 334,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 99,
          "category": "interface_method",
          "reason": "__init__ methods are constructor methods that are automatically called when objects are instantiated. They are essential for object creation and are called by Python's object instantiation mechanism, not directly by user code.",
          "recommendation": "keep",
          "evidence": [
            "__init__ is a special Python method called automatically during object creation",
            "Essential for proper object initialization in any class"
          ]
        },
        "status": "false_positive",
        "confidence": 99,
        "reason": "__init__ methods are constructor methods that are automatically called when objects are instantiated. They are essential for object creation and are called by Python's object instantiation mechanism, not directly by user code.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_method in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
          "recommendation": "keep",
          "evidence": [
            "Method is part of Request class which is exported in requests library",
            "Prepare method is a standard pattern in HTTP libraries for request preparation",
            "This is the popular requests library where Request.prepare() is documented public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_url in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
          "recommendation": "keep",
          "evidence": [
            "Method is part of Request class which is exported in requests library",
            "Prepare method is a standard pattern in HTTP libraries for request preparation",
            "This is the popular requests library where Request.prepare() is documented public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_headers in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
          "recommendation": "keep",
          "evidence": [
            "Method is part of Request class which is exported in requests library",
            "Prepare method is a standard pattern in HTTP libraries for request preparation",
            "This is the popular requests library where Request.prepare() is documented public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_body in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
          "recommendation": "keep",
          "evidence": [
            "Method is part of Request class which is exported in requests library",
            "Prepare method is a standard pattern in HTTP libraries for request preparation",
            "This is the popular requests library where Request.prepare() is documented public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_content_length in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
          "recommendation": "keep",
          "evidence": [
            "Method is part of Request class which is exported in requests library",
            "Prepare method is a standard pattern in HTTP libraries for request preparation",
            "This is the popular requests library where Request.prepare() is documented public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the `prepare` method of the `Request` class in the requests library, which is a core public API method. It's used to prepare a request for sending and is part of the documented interface that external users rely on.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_auth in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "The prepare method is likely part of the Request class public API in the requests library. This method is used to prepare HTTP requests and would be called by users or internal request processing.",
          "recommendation": "keep",
          "evidence": [
            "Located in models.py which contains core request/response classes",
            "prepare is a common method name for request preparation in HTTP libraries",
            "requests is a popular library where this would be part of public API"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "The prepare method is likely part of the Request class public API in the requests library. This method is used to prepare HTTP requests and would be called by users or internal request processing.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_cookies in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Same as item #1 - this appears to be a duplicate detection of the same prepare method. The prepare method is part of the public API for request preparation.",
          "recommendation": "keep",
          "evidence": [
            "Duplicate of the same method at same location",
            "prepare method is essential for HTTP request processing",
            "Part of requests library public interface"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Same as item #1 - this appears to be a duplicate detection of the same prepare method. The prepare method is part of the public API for request preparation.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_hooks in src/requests/models.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Another duplicate detection of the same prepare method. This method is a core part of the requests library's request preparation functionality.",
          "recommendation": "keep",
          "evidence": [
            "Same method detected multiple times",
            "Core functionality for HTTP request preparation",
            "Essential part of requests library API"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Another duplicate detection of the same prepare method. This method is a core part of the requests library's request preparation functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "prepare",
        "lineno": 351,
        "pattern_type": "similar_function_names",
        "details": "Similar to prepare_request in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Fourth duplicate detection of the same prepare method. This confirms it's likely a core method that should be preserved as part of the public API.",
          "recommendation": "keep",
          "evidence": [
            "Multiple detections suggest it's an important method",
            "prepare is fundamental to HTTP request processing",
            "Part of the requests library's core functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Fourth duplicate detection of the same prepare method. This confirms it's likely a core method that should be preserved as part of the public API.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/models.py",
        "name": "__init__",
        "lineno": 658,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "__init__ is a special Python method (dunder method) that serves as the constructor. It's called automatically when creating instances and is essential for object initialization.",
          "recommendation": "keep",
          "evidence": [
            "__init__ is a Python special method called during object instantiation",
            "Located in models.py suggesting it's a constructor for a core class",
            "Constructors are never dead code as they're called by Python itself"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "__init__ is a special Python method (dunder method) that serves as the constructor. It's called automatically when creating instances and is essential for object initialization.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get_redirect_target",
        "lineno": 107,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is likely an internal utility method in the requests library's Session class used for handling HTTP redirects. The requests library is a major HTTP library where redirect handling is core functionality.",
          "recommendation": "keep",
          "evidence": [
            "Located in sessions.py which contains core Session functionality",
            "Redirect handling is fundamental HTTP client functionality that would be used internally"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely an internal utility method in the requests library's Session class used for handling HTTP redirects. The requests library is a major HTTP library where redirect handling is core functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get_redirect_target",
        "lineno": 107,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This appears to be a duplicate entry of the same method. Same analysis applies - it's an internal utility method for redirect handling in the requests library.",
          "recommendation": "keep",
          "evidence": [
            "Duplicate of item #1",
            "Same location and functionality for redirect handling"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a duplicate entry of the same method. Same analysis applies - it's an internal utility method for redirect handling in the requests library.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "__init__",
        "lineno": 390,
        "pattern_type": "similar_function_names",
        "details": "Similar to _init in src/requests/status_codes.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is the constructor method for what appears to be the Session class in requests. Constructor methods are fundamental Python protocol methods called automatically during object instantiation.",
          "recommendation": "keep",
          "evidence": [
            "__init__ is a special Python method called during object creation",
            "Session objects are core to the requests library and must be instantiable"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the constructor method for what appears to be the Session class in requests. Constructor methods are fundamental Python protocol methods called automatically during object instantiation.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get",
        "lineno": 593,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_adapter in src/requests/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the HTTP GET method implementation in the Session class, which is core public API functionality of the requests library. Users regularly call session.get() to make HTTP GET requests.",
          "recommendation": "keep",
          "evidence": [
            "HTTP GET is fundamental functionality for an HTTP client library",
            "This method would be called by external users of the requests library"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the HTTP GET method implementation in the Session class, which is core public API functionality of the requests library. Users regularly call session.get() to make HTTP GET requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get",
        "lineno": 593,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_netrc_auth in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be a duplicate entry of the same GET method. Same analysis applies - it's a core public API method for making HTTP GET requests.",
          "recommendation": "keep",
          "evidence": [
            "Duplicate of item #4",
            "Same core HTTP GET functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a duplicate entry of the same GET method. Same analysis applies - it's a core public API method for making HTTP GET requests.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get",
        "lineno": 593,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_encodings_from_content in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
          "recommendation": "keep",
          "evidence": [
            "requests is a popular HTTP library where Session.get() is a fundamental public API method",
            "The method is located in sessions.py which contains the main Session class exported to users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get",
        "lineno": 593,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_encoding_from_headers in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
          "recommendation": "keep",
          "evidence": [
            "requests is a popular HTTP library where Session.get() is a fundamental public API method",
            "The method is located in sessions.py which contains the main Session class exported to users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get",
        "lineno": 593,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_unicode_from_response in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
          "recommendation": "keep",
          "evidence": [
            "requests is a popular HTTP library where Session.get() is a fundamental public API method",
            "The method is located in sessions.py which contains the main Session class exported to users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get",
        "lineno": 593,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_environ_proxies in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
          "recommendation": "keep",
          "evidence": [
            "requests is a popular HTTP library where Session.get() is a fundamental public API method",
            "The method is located in sessions.py which contains the main Session class exported to users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get",
        "lineno": 593,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_auth_from_url in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
          "recommendation": "keep",
          "evidence": [
            "requests is a popular HTTP library where Session.get() is a fundamental public API method",
            "The method is located in sessions.py which contains the main Session class exported to users"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the core GET method in the requests library's Session class, which is the primary public API for making HTTP GET requests. External users rely on this method extensively.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get",
        "lineno": 593,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_proxy in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the main GET method of the Session class in the requests library. It's the primary way users make GET requests and is a core part of the public API.",
          "recommendation": "keep",
          "evidence": [
            "Session class is exported and this is a fundamental HTTP method",
            "requests.get() likely delegates to this method",
            "Core functionality that external users depend on"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the main GET method of the Session class in the requests library. It's the primary way users make GET requests and is a core part of the public API.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/sessions.py",
        "name": "get_adapter",
        "lineno": 781,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This method allows users to retrieve HTTP adapters for specific URL schemes. It's part of the Session's public interface for advanced users who need to customize transport behavior.",
          "recommendation": "keep",
          "evidence": [
            "Session class is part of public API",
            "Method enables adapter customization which is documented feature",
            "Used internally by Session for adapter selection"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method allows users to retrieve HTTP adapters for specific URL schemes. It's part of the Session's public interface for advanced users who need to customize transport behavior.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/status_codes.py",
        "name": "_init",
        "lineno": 109,
        "pattern_type": "similar_function_names",
        "details": "Similar to __init__ in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This appears to be a lazy initialization method for status code lookups. The underscore prefix suggests internal use, but it's likely called during module initialization or first access.",
          "recommendation": "keep",
          "evidence": [
            "Underscore prefix indicates internal method",
            "Likely part of lazy loading pattern for status codes",
            "Status codes module is imported and used throughout requests"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a lazy initialization method for status code lookups. The underscore prefix suggests internal use, but it's likely called during module initialization or first access.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/status_codes.py",
        "name": "_init",
        "lineno": 109,
        "pattern_type": "similar_function_names",
        "details": "Similar to __init__ in src/requests/structures.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This is a duplicate of item #3. Same analysis applies - likely a lazy initialization method for status code data structures.",
          "recommendation": "keep",
          "evidence": [
            "Same as previous item - internal initialization method",
            "Part of status codes module functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a duplicate of item #3. Same analysis applies - likely a lazy initialization method for status code data structures.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/structures.py",
        "name": "get",
        "lineno": 98,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_netrc_auth in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This implements the dict-like interface get() method, likely for CaseInsensitiveDict or similar structure. It's a standard Python protocol method that users expect to be available.",
          "recommendation": "keep",
          "evidence": [
            "Implements standard Python dict.get() protocol",
            "Part of dict-like interface that users rely on",
            "Called by Python internally when using dict-style access patterns"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This implements the dict-like interface get() method, likely for CaseInsensitiveDict or similar structure. It's a standard Python protocol method that users expect to be available.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/structures.py",
        "name": "get",
        "lineno": 98,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_encodings_from_content in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
          "recommendation": "keep",
          "evidence": [
            "Located in structures.py which typically contains data structure classes",
            "get() is a standard dict-like interface method expected by users",
            "This is a library project where such methods form public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/structures.py",
        "name": "get",
        "lineno": 98,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_encoding_from_headers in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
          "recommendation": "keep",
          "evidence": [
            "Located in structures.py which typically contains data structure classes",
            "get() is a standard dict-like interface method expected by users",
            "This is a library project where such methods form public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/structures.py",
        "name": "get",
        "lineno": 98,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_unicode_from_response in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
          "recommendation": "keep",
          "evidence": [
            "Located in structures.py which typically contains data structure classes",
            "get() is a standard dict-like interface method expected by users",
            "This is a library project where such methods form public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/structures.py",
        "name": "get",
        "lineno": 98,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_environ_proxies in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
          "recommendation": "keep",
          "evidence": [
            "Located in structures.py which typically contains data structure classes",
            "get() is a standard dict-like interface method expected by users",
            "This is a library project where such methods form public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/structures.py",
        "name": "get",
        "lineno": 98,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_auth_from_url in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
          "recommendation": "keep",
          "evidence": [
            "Located in structures.py which typically contains data structure classes",
            "get() is a standard dict-like interface method expected by users",
            "This is a library project where such methods form public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a get method implementing dict-like interface protocol (similar to dict.get()). Such methods are standard public API for data structures and are called by external users and Python internals.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/structures.py",
        "name": "get",
        "lineno": 98,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_proxy in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This appears to be a dictionary-like interface method implementing the standard 'get' protocol. The requests library is widely used and this method would be part of the public API for accessing structured data.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python dictionary interface pattern",
            "Located in structures.py suggesting it's part of data structure classes that users interact with",
            "Requests is a major library where such methods are expected public API"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a dictionary-like interface method implementing the standard 'get' protocol. The requests library is widely used and this method would be part of the public API for accessing structured data.",
        "recommendation": "keep"
      },
      {
        "module": "src/requests/utils.py",
        "name": "proxy_bypass_registry",
        "lineno": 77,
        "pattern_type": "similar_function_names",
        "details": "Similar to proxy_bypass in src/requests/utils.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a utility function for proxy configuration, which is a core feature of the requests library. Such utilities are typically part of the public API for advanced proxy handling scenarios.",
          "recommendation": "keep",
          "evidence": [
            "Located in utils.py indicating it's a utility function for library users",
            "Proxy handling is a major feature of requests library",
            "Registry-related functions are often used by external code for configuration"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a utility function for proxy configuration, which is a core feature of the requests library. Such utilities are typically part of the public API for advanced proxy handling scenarios.",
        "recommendation": "keep"
      }
    ],
    "summary": {
      "total_analyzed": 175,
      "confirmed_dead_code": 3,
      "false_positives": 170,
      "uncertain": 2,
      "avg_confidence": 90.26857142857143
    }
  },
  "logical_groups": {
    "Package Distribution & Setup": [
      "setup.py",
      "src/requests/__version__.py",
      "src/requests/packages.py"
    ],
    "Documentation": [
      "docs/_themes/flask_theme_support.py",
      "docs/conf.py"
    ],
    "Library Initialization & Compatibility": [
      "src/requests/__init__.py",
      "src/requests/compat.py"
    ],
    "Core HTTP Request/Response": [
      "src/requests/api.py",
      "src/requests/models.py",
      "src/requests/sessions.py"
    ],
    "Network Transport & Adapters": [
      "src/requests/adapters.py"
    ],
    "Authentication & Security": [
      "src/requests/auth.py",
      "src/requests/certs.py"
    ],
    "State Management": [
      "src/requests/cookies.py",
      "src/requests/structures.py"
    ],
    "Error Handling": [
      "src/requests/exceptions.py"
    ],
    "HTTP Standards & Conventions": [
      "src/requests/status_codes.py"
    ],
    "Utilities & Helpers": [
      "src/requests/_internal_utils.py",
      "src/requests/utils.py",
      "src/requests/hooks.py"
    ],
    "Diagnostics & Troubleshooting": [
      "src/requests/help.py"
    ]
  },
  "audio_narration": {
    "audio_file": "/Users/navyan/Desktop/LLM-Project/repospeak/audio/requests_summary.mp3",
    "script_file": "/Users/navyan/Desktop/LLM-Project/repospeak/audio/requests_audio_script.txt",
    "audio_text": "Imagine you're trying to have a conversation with a website... but you don't speak its language. That's where the Requests library comes in.\n\nThink of Requests as your personal translator and messenger for the internet. You know how when you want to order food at a restaurant in a foreign country, you might use a translator app that handles all the complicated grammar and pronunciation? Well, Requests does exactly that... but for talking to websites and web services.\n\nHere's the thing... websites communicate using something called HTTP, which stands for Hypertext Transfer Protocol. It's full of technical rules and low-level details that can make your head spin. Connection management, data encoding, security certificates... it's a lot.\n\nBut Requests takes all that complexity and wraps it up in a simple, friendly package. The creators even call it \"HTTP for Humans\" because it makes web requests as easy as calling a function with a URL. Just tell it what you want... and it handles the rest.\n\nSo what can you actually do with it? First, you can fetch information from websites... like grabbing weather data or news headlines. Next, you can send information... posting comments, uploading files, or submitting forms. And finally, you can handle all the sophisticated stuff... managing cookies, dealing with authentication systems, routing through proxies, and ensuring secure connections.\n\nDevelopers absolutely love this library. Whether they're building apps that consume APIs, automating web interactions, or scraping data from websites... Requests is their go-to tool. It's like having a Swiss Army knife for web communication... everything you need, nothing you don't, all wrapped up in an intuitive interface that just works.\n\nNo wrestling with protocols. No debugging connection issues. Just simple, clean code that gets the job done.",
    "word_count": 288,
    "estimated_duration_minutes": 1.9
  }
}