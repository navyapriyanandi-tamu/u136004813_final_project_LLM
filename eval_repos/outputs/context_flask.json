{
  "repo_name": "flask",
  "ast_results": {
    "docs/conf.py": {
      "filepath": "../flask/docs/conf.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "github_link",
          "args": [
            {
              "name": "name"
            },
            {
              "name": "rawtext"
            },
            {
              "name": "text"
            },
            {
              "name": "lineno"
            },
            {
              "name": "inliner"
            },
            {
              "name": "options"
            },
            {
              "name": "content"
            }
          ],
          "return_type": null,
          "lineno": 72,
          "decorators": [],
          "is_async": false,
          "calls": [
            "text.endswith",
            "options",
            "release",
            "words.strip",
            "packaging.version.parse",
            "reference",
            "rawtext",
            "words",
            "url",
            "app.config.release",
            "inliner.document.settings.env.app",
            "set_classes",
            "unknown.rsplit"
          ],
          "docstring": null,
          "code": "def github_link(name, rawtext, text, lineno, inliner, options=None, content=None):\n    app = inliner.document.settings.env.app\n    release = app.config.release\n    base_url = \"https://github.com/pallets/flask/tree/\"\n\n    if text.endswith(\">\"):\n        words, text = text[:-1].rsplit(\"<\", 1)\n        words = words.strip()\n    else:\n        words = None\n\n    if packaging.version.parse(release).is_devrelease:\n        url = f\"{base_url}main/{text}\"\n    else:\n        url = f\"{base_url}{release}/{text}\"\n\n    if words is None:\n        words = url\n\n    from docutils.nodes import reference\n    from docutils.parsers.rst.roles import set_classes\n\n    options = options or {}\n    set_classes(options)\n    node = reference(rawtext, words, refuri=url, **options)\n    return [node], []",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "setup",
          "args": [
            {
              "name": "app"
            }
          ],
          "return_type": null,
          "lineno": 100,
          "decorators": [],
          "is_async": false,
          "calls": [
            "github_link",
            "app.add_role"
          ],
          "docstring": null,
          "code": "def setup(app):\n    app.add_role(\"gh\", github_link)",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "packaging.version",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "pallets_sphinx_themes",
          "name": "get_version",
          "alias": null,
          "lineno": 2,
          "type": "from_import"
        },
        {
          "module": "pallets_sphinx_themes",
          "name": "ProjectLink",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "docutils.nodes",
          "name": "reference",
          "alias": null,
          "lineno": 91,
          "type": "from_import"
        },
        {
          "module": "docutils.parsers.rst.roles",
          "name": "set_classes",
          "alias": null,
          "lineno": 92,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "project",
          "assigned_to": "str",
          "lineno": 7
        },
        {
          "name": "copyright",
          "assigned_to": "str",
          "lineno": 8
        },
        {
          "name": "author",
          "assigned_to": "str",
          "lineno": 9
        },
        {
          "name": "default_role",
          "assigned_to": "str",
          "lineno": 14
        },
        {
          "name": "extensions",
          "assigned_to": null,
          "lineno": 15
        },
        {
          "name": "autodoc_member_order",
          "assigned_to": "str",
          "lineno": 23
        },
        {
          "name": "autodoc_typehints",
          "assigned_to": "str",
          "lineno": 24
        },
        {
          "name": "autodoc_preserve_defaults",
          "assigned_to": "bool",
          "lineno": 25
        },
        {
          "name": "extlinks",
          "assigned_to": null,
          "lineno": 26
        },
        {
          "name": "intersphinx_mapping",
          "assigned_to": null,
          "lineno": 31
        },
        {
          "name": "html_theme",
          "assigned_to": "str",
          "lineno": 44
        },
        {
          "name": "html_theme_options",
          "assigned_to": null,
          "lineno": 45
        },
        {
          "name": "html_context",
          "assigned_to": null,
          "lineno": 46
        },
        {
          "name": "html_sidebars",
          "assigned_to": null,
          "lineno": 55
        },
        {
          "name": "singlehtml_sidebars",
          "assigned_to": null,
          "lineno": 59
        },
        {
          "name": "html_static_path",
          "assigned_to": null,
          "lineno": 60
        },
        {
          "name": "html_favicon",
          "assigned_to": "str",
          "lineno": 61
        },
        {
          "name": "html_logo",
          "assigned_to": "str",
          "lineno": 62
        },
        {
          "name": "html_title",
          "assigned_to": null,
          "lineno": 63
        },
        {
          "name": "html_show_sourcelink",
          "assigned_to": "bool",
          "lineno": 64
        },
        {
          "name": "gettext_uuid",
          "assigned_to": "bool",
          "lineno": 66
        },
        {
          "name": "gettext_compact",
          "assigned_to": "bool",
          "lineno": 67
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "get_version",
          "ProjectLink"
        ],
        "class_instantiations": [
          "ProjectLink"
        ]
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "packaging",
            "pallets_sphinx_themes",
            "docutils"
          ]
        },
        "tech_stack": []
      },
      "line_count": 102
    },
    "examples/celery/make_celery.py": {
      "filepath": "../flask/examples/celery/make_celery.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "task_app",
          "name": "create_app",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "flask_app",
          "assigned_to": "create_app",
          "lineno": 3
        },
        {
          "name": "celery_app",
          "assigned_to": null,
          "lineno": 4
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "create_app"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "task_app"
          ]
        },
        "tech_stack": []
      },
      "line_count": 5
    },
    "examples/celery/src/task_app/__init__.py": {
      "filepath": "../flask/examples/celery/src/task_app/__init__.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "create_app",
          "args": [],
          "return_type": "Flask",
          "lineno": 7,
          "decorators": [],
          "is_async": false,
          "calls": [
            "render_template",
            "__name__",
            "app.config.from_prefixed_env",
            "app",
            "Flask",
            "app.route",
            "app.register_blueprint",
            "dict",
            "celery_init_app",
            "views.bp",
            "app.config.from_mapping"
          ],
          "docstring": null,
          "code": "def create_app() -> Flask:\n    app = Flask(__name__)\n    app.config.from_mapping(\n        CELERY=dict(\n            broker_url=\"redis://localhost\",\n            result_backend=\"redis://localhost\",\n            task_ignore_result=True,\n        ),\n    )\n    app.config.from_prefixed_env()\n    celery_init_app(app)\n\n    @app.route(\"/\")\n    def index() -> str:\n        return render_template(\"index.html\")\n\n    from . import views\n\n    app.register_blueprint(views.bp)\n    return app",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "celery_init_app",
          "args": [
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "Celery",
          "lineno": 29,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Celery",
            "kwargs",
            "celery_app.config_from_object",
            "celery_app",
            "celery_app.set_default",
            "app.app_context",
            "FlaskTask",
            "app.name",
            "self.run"
          ],
          "docstring": null,
          "code": "def celery_init_app(app: Flask) -> Celery:\n    class FlaskTask(Task):\n        def __call__(self, *args: object, **kwargs: object) -> object:\n            with app.app_context():\n                return self.run(*args, **kwargs)\n\n    celery_app = Celery(app.name, task_cls=FlaskTask)\n    celery_app.config_from_object(app.config[\"CELERY\"])\n    celery_app.set_default()\n    app.extensions[\"celery\"] = celery_app\n    return celery_app",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "index",
          "args": [],
          "return_type": "str",
          "lineno": 20,
          "decorators": [
            {
              "name": "app.route",
              "args": [
                "/"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "app.route",
            "render_template"
          ],
          "docstring": null,
          "code": "def index() -> str:\n        return render_template(\"index.html\")",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__call__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "object",
          "lineno": 31,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "self.run",
            "app.app_context"
          ],
          "docstring": null,
          "code": "def __call__(self, *args: object, **kwargs: object) -> object:\n            with app.app_context():\n                return self.run(*args, **kwargs)",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "FlaskTask",
          "methods": [
            "__call__"
          ],
          "base_classes": [
            "Task"
          ],
          "lineno": 30,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "celery",
          "name": "Celery",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "celery",
          "name": "Task",
          "alias": null,
          "lineno": 2,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "Flask",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "render_template",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "views",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "celery",
            "views"
          ],
          "web": [
            "flask"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 40
    },
    "examples/celery/src/task_app/tasks.py": {
      "filepath": "../flask/examples/celery/src/task_app/tasks.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "add",
          "args": [
            {
              "name": "a",
              "type": "int"
            },
            {
              "name": "b",
              "type": "int"
            }
          ],
          "return_type": "int",
          "lineno": 8,
          "decorators": [
            {
              "name": "shared_task",
              "args": [],
              "kwargs": {
                "ignore_result": false
              }
            }
          ],
          "is_async": false,
          "calls": [
            "shared_task"
          ],
          "docstring": null,
          "code": "def add(a: int, b: int) -> int:\n    return a + b",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "block",
          "args": [],
          "return_type": "None",
          "lineno": 13,
          "decorators": [
            {
              "name": "shared_task",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "time.sleep",
            "shared_task"
          ],
          "docstring": null,
          "code": "def block() -> None:\n    time.sleep(5)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "process",
          "args": [
            {
              "name": "self",
              "type": "Task"
            },
            {
              "name": "total",
              "type": "int"
            }
          ],
          "return_type": "object",
          "lineno": 18,
          "decorators": [
            {
              "name": "shared_task",
              "args": [],
              "kwargs": {
                "bind": true,
                "ignore_result": false
              }
            }
          ],
          "is_async": false,
          "calls": [
            "self.update_state",
            "range",
            "total",
            "time.sleep",
            "shared_task"
          ],
          "docstring": null,
          "code": "def process(self: Task, total: int) -> object:\n    for i in range(total):\n        self.update_state(state=\"PROGRESS\", meta={\"current\": i + 1, \"total\": total})\n        time.sleep(1)\n\n    return {\"current\": total, \"total\": total}",
          "line_count": 6,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "time",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "celery",
          "name": "shared_task",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "celery",
          "name": "Task",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "time"
        ],
        "third_party": {
          "other": [
            "celery"
          ]
        },
        "tech_stack": []
      },
      "line_count": 24
    },
    "examples/celery/src/task_app/views.py": {
      "filepath": "../flask/examples/celery/src/task_app/views.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "result",
          "args": [
            {
              "name": "id",
              "type": "str"
            }
          ],
          "return_type": "dict[str, object]",
          "lineno": 11,
          "decorators": [
            {
              "name": "bp.get",
              "args": [
                "/result/<id>"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "id",
            "result.get",
            "result.ready",
            "AsyncResult",
            "bp.get",
            "result.successful"
          ],
          "docstring": null,
          "code": "def result(id: str) -> dict[str, object]:\n    result = AsyncResult(id)\n    ready = result.ready()\n    return {\n        \"ready\": ready,\n        \"successful\": result.successful() if ready else None,\n        \"value\": result.get() if ready else result.result,\n    }",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "add",
          "args": [],
          "return_type": "dict[str, object]",
          "lineno": 22,
          "decorators": [
            {
              "name": "bp.post",
              "args": [
                "/add"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "bp.post",
            "request.form.get",
            "tasks.add.delay",
            "a",
            "b",
            "int"
          ],
          "docstring": null,
          "code": "def add() -> dict[str, object]:\n    a = request.form.get(\"a\", type=int)\n    b = request.form.get(\"b\", type=int)\n    result = tasks.add.delay(a, b)\n    return {\"result_id\": result.id}",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "block",
          "args": [],
          "return_type": "dict[str, object]",
          "lineno": 30,
          "decorators": [
            {
              "name": "bp.post",
              "args": [
                "/block"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "tasks.block.delay",
            "bp.post"
          ],
          "docstring": null,
          "code": "def block() -> dict[str, object]:\n    result = tasks.block.delay()\n    return {\"result_id\": result.id}",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "process",
          "args": [],
          "return_type": "dict[str, object]",
          "lineno": 36,
          "decorators": [
            {
              "name": "bp.post",
              "args": [
                "/process"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "tasks.process.delay",
            "int",
            "bp.post",
            "request.form.get"
          ],
          "docstring": null,
          "code": "def process() -> dict[str, object]:\n    result = tasks.process.delay(total=request.form.get(\"total\", type=int))\n    return {\"result_id\": result.id}",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "celery.result",
          "name": "AsyncResult",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "Blueprint",
          "alias": null,
          "lineno": 2,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "request",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "tasks",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "bp",
          "assigned_to": "Blueprint",
          "lineno": 7
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "__name__",
          "Blueprint"
        ],
        "class_instantiations": [
          "Blueprint"
        ]
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "celery",
            "tasks"
          ],
          "web": [
            "flask"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 39
    },
    "examples/javascript/js_example/__init__.py": {
      "filepath": "../flask/examples/javascript/js_example/__init__.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "flask",
          "name": "Flask",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "js_example",
          "name": "views",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "app",
          "assigned_to": "Flask",
          "lineno": 3
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "__name__",
          "Flask"
        ],
        "class_instantiations": [
          "Flask"
        ]
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "web": [
            "flask"
          ],
          "other": [
            "js_example"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 6
    },
    "examples/javascript/js_example/views.py": {
      "filepath": "../flask/examples/javascript/js_example/views.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "index",
          "args": [
            {
              "name": "js"
            }
          ],
          "return_type": null,
          "lineno": 10,
          "decorators": [
            {
              "name": "app.route",
              "args": [
                "/"
              ],
              "kwargs": {}
            },
            {
              "name": "app.route",
              "args": [
                "/<any(xhr, jquery, fetch):js>"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "app.route",
            "render_template",
            "js"
          ],
          "docstring": null,
          "code": "def index(js):\n    return render_template(f\"{js}.html\", js=js)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "add",
          "args": [],
          "return_type": null,
          "lineno": 15,
          "decorators": [
            {
              "name": "app.route",
              "args": [
                "/add"
              ],
              "kwargs": {
                "methods": [
                  "POST"
                ]
              }
            }
          ],
          "is_async": false,
          "calls": [
            "app.route",
            "jsonify",
            "request.form.get",
            "float"
          ],
          "docstring": null,
          "code": "def add():\n    a = request.form.get(\"a\", 0, type=float)\n    b = request.form.get(\"b\", 0, type=float)\n    return jsonify(result=a + b)",
          "line_count": 4,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "flask",
          "name": "jsonify",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "render_template",
          "alias": null,
          "lineno": 2,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "request",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "app",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "web": [
            "flask"
          ],
          "other": [
            "app"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 19
    },
    "examples/tutorial/flaskr/__init__.py": {
      "filepath": "../flask/examples/tutorial/flaskr/__init__.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "create_app",
          "args": [
            {
              "name": "test_config"
            }
          ],
          "return_type": null,
          "lineno": 6,
          "decorators": [],
          "is_async": false,
          "calls": [
            "blog.bp",
            "app.config.from_pyfile",
            "db.init_app",
            "test_config",
            "os.makedirs",
            "__name__",
            "app.instance_path",
            "app.add_url_rule",
            "os.path.join",
            "app",
            "Flask",
            "app.route",
            "app.register_blueprint",
            "app.config.update",
            "auth.bp",
            "app.config.from_mapping"
          ],
          "docstring": "Create and configure an instance of the Flask application.",
          "code": "def create_app(test_config=None):\n    \"\"\"Create and configure an instance of the Flask application.\"\"\"\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_mapping(\n        # a default secret that should be overridden by instance config\n        SECRET_KEY=\"dev\",\n        # store the database in the instance folder\n        DATABASE=os.path.join(app.instance_path, \"flaskr.sqlite\"),\n    )\n\n    if test_config is None:\n        # load the instance config, if it exists, when not testing\n        app.config.from_pyfile(\"config.py\", silent=True)\n    else:\n        # load the test config if passed in\n        app.config.update(test_config)\n\n    # ensure the instance folder exists\n    try:\n        os.makedirs(app.instance_path)\n    except OSError:\n        pass\n\n    @app.route(\"/hello\")\n    def hello():\n        return \"Hello, World!\"\n\n    # register the database commands\n    from . import db\n\n    db.init_app(app)\n\n    # apply the blueprints to the app\n    from . import auth\n    from . import blog\n\n    app.register_blueprint(auth.bp)\n    app.register_blueprint(blog.bp)\n\n    # make url_for('index') == url_for('blog.index')\n    # in another app, you might define a separate main index here with\n    # app.route, while giving the blog blueprint a url_prefix, but for\n    # the tutorial the blog will be the main index\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    return app",
          "line_count": 46,
          "needs_llm_summary": true
        },
        {
          "name": "hello",
          "args": [],
          "return_type": null,
          "lineno": 30,
          "decorators": [
            {
              "name": "app.route",
              "args": [
                "/hello"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "app.route"
          ],
          "docstring": null,
          "code": "def hello():\n        return \"Hello, World!\"",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "os",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "flask",
          "name": "Flask",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "db",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "auth",
          "alias": null,
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "blog",
          "alias": null,
          "lineno": 40,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os"
        ],
        "third_party": {
          "web": [
            "flask"
          ],
          "other": [
            "db",
            "auth",
            "blog"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 52
    },
    "examples/tutorial/flaskr/auth.py": {
      "filepath": "../flask/examples/tutorial/flaskr/auth.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "login_required",
          "args": [
            {
              "name": "view"
            }
          ],
          "return_type": null,
          "lineno": 19,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "url_for",
            "functools.wraps",
            "redirect",
            "view"
          ],
          "docstring": "View decorator that redirects anonymous users to the login page.",
          "code": "def login_required(view):\n    \"\"\"View decorator that redirects anonymous users to the login page.\"\"\"\n\n    @functools.wraps(view)\n    def wrapped_view(**kwargs):\n        if g.user is None:\n            return redirect(url_for(\"auth.login\"))\n\n        return view(**kwargs)\n\n    return wrapped_view",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "load_logged_in_user",
          "args": [],
          "return_type": null,
          "lineno": 33,
          "decorators": [
            {
              "name": "bp.before_app_request",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "unknown.execute",
            "session.get",
            "unknown.fetchone",
            "get_db"
          ],
          "docstring": "If a user id is stored in the session, load the user object from\nthe database into ``g.user``.",
          "code": "def load_logged_in_user():\n    \"\"\"If a user id is stored in the session, load the user object from\n    the database into ``g.user``.\"\"\"\n    user_id = session.get(\"user_id\")\n\n    if user_id is None:\n        g.user = None\n    else:\n        g.user = (\n            get_db().execute(\"SELECT * FROM user WHERE id = ?\", (user_id,)).fetchone()\n        )",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "register",
          "args": [],
          "return_type": null,
          "lineno": 47,
          "decorators": [
            {
              "name": "bp.route",
              "args": [
                "/register"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "db.commit",
            "render_template",
            "password",
            "bp.route",
            "generate_password_hash",
            "url_for",
            "redirect",
            "error",
            "db.execute",
            "flash",
            "get_db"
          ],
          "docstring": "Register a new user.\n\nValidates that the username is not already taken. Hashes the\npassword for security.",
          "code": "def register():\n    \"\"\"Register a new user.\n\n    Validates that the username is not already taken. Hashes the\n    password for security.\n    \"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n\n        if not username:\n            error = \"Username is required.\"\n        elif not password:\n            error = \"Password is required.\"\n\n        if error is None:\n            try:\n                db.execute(\n                    \"INSERT INTO user (username, password) VALUES (?, ?)\",\n                    (username, generate_password_hash(password)),\n                )\n                db.commit()\n            except db.IntegrityError:\n                # The username was already taken, which caused the\n                # commit to fail. Show a validation error.\n                error = f\"User {username} is already registered.\"\n            else:\n                # Success, go to the login page.\n                return redirect(url_for(\"auth.login\"))\n\n        flash(error)\n\n    return render_template(\"auth/register.html\")",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "login",
          "args": [],
          "return_type": null,
          "lineno": 85,
          "decorators": [
            {
              "name": "bp.route",
              "args": [
                "/login"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "render_template",
            "password",
            "session.clear",
            "bp.route",
            "unknown.fetchone",
            "check_password_hash",
            "url_for",
            "redirect",
            "error",
            "db.execute",
            "flash",
            "get_db"
          ],
          "docstring": "Log in a registered user by adding the user id to the session.",
          "code": "def login():\n    \"\"\"Log in a registered user by adding the user id to the session.\"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n        user = db.execute(\n            \"SELECT * FROM user WHERE username = ?\", (username,)\n        ).fetchone()\n\n        if user is None:\n            error = \"Incorrect username.\"\n        elif not check_password_hash(user[\"password\"], password):\n            error = \"Incorrect password.\"\n\n        if error is None:\n            # store the user id in a new session and return to the index\n            session.clear()\n            session[\"user_id\"] = user[\"id\"]\n            return redirect(url_for(\"index\"))\n\n        flash(error)\n\n    return render_template(\"auth/login.html\")",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "logout",
          "args": [],
          "return_type": null,
          "lineno": 113,
          "decorators": [
            {
              "name": "bp.route",
              "args": [
                "/logout"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "redirect",
            "url_for",
            "bp.route",
            "session.clear"
          ],
          "docstring": "Clear the current session, including the stored user id.",
          "code": "def logout():\n    \"\"\"Clear the current session, including the stored user id.\"\"\"\n    session.clear()\n    return redirect(url_for(\"index\"))",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "wrapped_view",
          "args": [],
          "return_type": null,
          "lineno": 23,
          "decorators": [
            {
              "name": "functools.wraps",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "kwargs",
            "url_for",
            "functools.wraps",
            "redirect",
            "view"
          ],
          "docstring": null,
          "code": "def wrapped_view(**kwargs):\n        if g.user is None:\n            return redirect(url_for(\"auth.login\"))\n\n        return view(**kwargs)",
          "line_count": 5,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "functools",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "flask",
          "name": "Blueprint",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "flash",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "g",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "redirect",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "render_template",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "request",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "session",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "url_for",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "werkzeug.security",
          "name": "check_password_hash",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "werkzeug.security",
          "name": "generate_password_hash",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "db",
          "name": "get_db",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "bp",
          "assigned_to": "Blueprint",
          "lineno": 16
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "__name__",
          "Blueprint"
        ],
        "class_instantiations": [
          "Blueprint"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "functools"
        ],
        "third_party": {
          "web": [
            "flask"
          ],
          "other": [
            "werkzeug",
            "db"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 117
    },
    "examples/tutorial/flaskr/blog.py": {
      "filepath": "../flask/examples/tutorial/flaskr/blog.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "index",
          "args": [],
          "return_type": null,
          "lineno": 17,
          "decorators": [
            {
              "name": "bp.route",
              "args": [
                "/"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "render_template",
            "bp.route",
            "posts",
            "unknown.fetchall",
            "db.execute",
            "get_db"
          ],
          "docstring": "Show all the posts, most recent first.",
          "code": "def index():\n    \"\"\"Show all the posts, most recent first.\"\"\"\n    db = get_db()\n    posts = db.execute(\n        \"SELECT p.id, title, body, created, author_id, username\"\n        \" FROM post p JOIN user u ON p.author_id = u.id\"\n        \" ORDER BY created DESC\"\n    ).fetchall()\n    return render_template(\"blog/index.html\", posts=posts)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "get_post",
          "args": [
            {
              "name": "id"
            },
            {
              "name": "check_author"
            }
          ],
          "return_type": null,
          "lineno": 28,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.execute",
            "abort",
            "unknown.fetchone",
            "get_db"
          ],
          "docstring": "Get a post and its author by id.\n\nChecks that the id exists and optionally that the current user is\nthe author.\n\n:param id: id of post to get\n:param check_author: require the current user to be the author\n:return: the post with author information\n:raise 404: if a post with the given id doesn't exist\n:raise 403: if the current user isn't the author",
          "code": "def get_post(id, check_author=True):\n    \"\"\"Get a post and its author by id.\n\n    Checks that the id exists and optionally that the current user is\n    the author.\n\n    :param id: id of post to get\n    :param check_author: require the current user to be the author\n    :return: the post with author information\n    :raise 404: if a post with the given id doesn't exist\n    :raise 403: if the current user isn't the author\n    \"\"\"\n    post = (\n        get_db()\n        .execute(\n            \"SELECT p.id, title, body, created, author_id, username\"\n            \" FROM post p JOIN user u ON p.author_id = u.id\"\n            \" WHERE p.id = ?\",\n            (id,),\n        )\n        .fetchone()\n    )\n\n    if post is None:\n        abort(404, f\"Post id {id} doesn't exist.\")\n\n    if check_author and post[\"author_id\"] != g.user[\"id\"]:\n        abort(403)\n\n    return post",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "create",
          "args": [],
          "return_type": null,
          "lineno": 62,
          "decorators": [
            {
              "name": "bp.route",
              "args": [
                "/create"
              ],
              "kwargs": {}
            },
            {
              "name": "login_required",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "db.commit",
            "render_template",
            "bp.route",
            "url_for",
            "redirect",
            "error",
            "db.execute",
            "flash",
            "get_db"
          ],
          "docstring": "Create a new post for the current user.",
          "code": "def create():\n    \"\"\"Create a new post for the current user.\"\"\"\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"INSERT INTO post (title, body, author_id) VALUES (?, ?, ?)\",\n                (title, body, g.user[\"id\"]),\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog/create.html\")",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "update",
          "args": [
            {
              "name": "id"
            }
          ],
          "return_type": null,
          "lineno": 88,
          "decorators": [
            {
              "name": "bp.route",
              "args": [
                "/<int:id>/update"
              ],
              "kwargs": {}
            },
            {
              "name": "login_required",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "id",
            "db.commit",
            "render_template",
            "bp.route",
            "url_for",
            "get_post",
            "redirect",
            "error",
            "db.execute",
            "flash",
            "post",
            "get_db"
          ],
          "docstring": "Update a post if the current user is the author.",
          "code": "def update(id):\n    \"\"\"Update a post if the current user is the author.\"\"\"\n    post = get_post(id)\n\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"UPDATE post SET title = ?, body = ? WHERE id = ?\", (title, body, id)\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog/update.html\", post=post)",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "delete",
          "args": [
            {
              "name": "id"
            }
          ],
          "return_type": null,
          "lineno": 115,
          "decorators": [
            {
              "name": "bp.route",
              "args": [
                "/<int:id>/delete"
              ],
              "kwargs": {}
            },
            {
              "name": "login_required",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "id",
            "db.commit",
            "bp.route",
            "url_for",
            "get_post",
            "redirect",
            "db.execute",
            "get_db"
          ],
          "docstring": "Delete a post.\n\nEnsures that the post exists and that the logged in user is the\nauthor of the post.",
          "code": "def delete(id):\n    \"\"\"Delete a post.\n\n    Ensures that the post exists and that the logged in user is the\n    author of the post.\n    \"\"\"\n    get_post(id)\n    db = get_db()\n    db.execute(\"DELETE FROM post WHERE id = ?\", (id,))\n    db.commit()\n    return redirect(url_for(\"blog.index\"))",
          "line_count": 11,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "flask",
          "name": "Blueprint",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "flash",
          "alias": null,
          "lineno": 2,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "g",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "redirect",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "render_template",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "request",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "url_for",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "abort",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "auth",
          "name": "login_required",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "db",
          "name": "get_db",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "bp",
          "assigned_to": "Blueprint",
          "lineno": 13
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "__name__",
          "Blueprint"
        ],
        "class_instantiations": [
          "Blueprint"
        ]
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "web": [
            "flask"
          ],
          "other": [
            "werkzeug",
            "auth",
            "db"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 126
    },
    "examples/tutorial/flaskr/db.py": {
      "filepath": "../flask/examples/tutorial/flaskr/db.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "get_db",
          "args": [],
          "return_type": null,
          "lineno": 9,
          "decorators": [],
          "is_async": false,
          "calls": [
            "sqlite3.Row",
            "sqlite3.PARSE_DECLTYPES",
            "sqlite3.connect"
          ],
          "docstring": "Connect to the application's configured database. The connection\nis unique for each request and will be reused if this is called\nagain.",
          "code": "def get_db():\n    \"\"\"Connect to the application's configured database. The connection\n    is unique for each request and will be reused if this is called\n    again.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            current_app.config[\"DATABASE\"], detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n\n    return g.db",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "close_db",
          "args": [
            {
              "name": "e"
            }
          ],
          "return_type": null,
          "lineno": 23,
          "decorators": [],
          "is_async": false,
          "calls": [
            "db.close",
            "g.pop"
          ],
          "docstring": "If this request connected to the database, close the\nconnection.",
          "code": "def close_db(e=None):\n    \"\"\"If this request connected to the database, close the\n    connection.\n    \"\"\"\n    db = g.pop(\"db\", None)\n\n    if db is not None:\n        db.close()",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "init_db",
          "args": [],
          "return_type": null,
          "lineno": 33,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.decode",
            "current_app.open_resource",
            "f.read",
            "db.executescript",
            "get_db"
          ],
          "docstring": "Clear existing data and create new tables.",
          "code": "def init_db():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    db = get_db()\n\n    with current_app.open_resource(\"schema.sql\") as f:\n        db.executescript(f.read().decode(\"utf8\"))",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "init_db_command",
          "args": [],
          "return_type": null,
          "lineno": 42,
          "decorators": [
            {
              "name": "click.command",
              "args": [
                "init-db"
              ],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "init_db",
            "click.command",
            "click.echo"
          ],
          "docstring": "Clear existing data and create new tables.",
          "code": "def init_db_command():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    init_db()\n    click.echo(\"Initialized the database.\")",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "init_app",
          "args": [
            {
              "name": "app"
            }
          ],
          "return_type": null,
          "lineno": 51,
          "decorators": [],
          "is_async": false,
          "calls": [
            "init_db_command",
            "app.cli.add_command",
            "app.teardown_appcontext",
            "close_db"
          ],
          "docstring": "Register database functions with the Flask app. This is called by\nthe application factory.",
          "code": "def init_app(app):\n    \"\"\"Register database functions with the Flask app. This is called by\n    the application factory.\n    \"\"\"\n    app.teardown_appcontext(close_db)\n    app.cli.add_command(init_db_command)",
          "line_count": 6,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "sqlite3",
          "alias": null,
          "lineno": 1,
          "type": "import"
        },
        {
          "module": "datetime",
          "name": "datetime",
          "alias": null,
          "lineno": 2,
          "type": "from_import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "flask",
          "name": "current_app",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "flask",
          "name": "g",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "sqlite3.register_converter",
          "v.decode",
          "datetime.fromisoformat"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "datetime",
          "sqlite3"
        ],
        "third_party": {
          "other": [
            "click"
          ],
          "web": [
            "flask"
          ]
        },
        "tech_stack": [
          "Web"
        ]
      },
      "line_count": 57
    },
    "src/flask/__init__.py": {
      "filepath": "../flask/src/flask/__init__.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "",
          "name": "json",
          "alias": "json",
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "app",
          "name": "Flask",
          "alias": "Flask",
          "lineno": 2,
          "type": "from_import"
        },
        {
          "module": "blueprints",
          "name": "Blueprint",
          "alias": "Blueprint",
          "lineno": 3,
          "type": "from_import"
        },
        {
          "module": "config",
          "name": "Config",
          "alias": "Config",
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "after_this_request",
          "alias": "after_this_request",
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "copy_current_request_context",
          "alias": "copy_current_request_context",
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "has_app_context",
          "alias": "has_app_context",
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "has_request_context",
          "alias": "has_request_context",
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "current_app",
          "alias": "current_app",
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "g",
          "alias": "g",
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "request",
          "alias": "request",
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "session",
          "alias": "session",
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "abort",
          "alias": "abort",
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "flash",
          "alias": "flash",
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_flashed_messages",
          "alias": "get_flashed_messages",
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_template_attribute",
          "alias": "get_template_attribute",
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "make_response",
          "alias": "make_response",
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "redirect",
          "alias": "redirect",
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "send_file",
          "alias": "send_file",
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "send_from_directory",
          "alias": "send_from_directory",
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "stream_with_context",
          "alias": "stream_with_context",
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "url_for",
          "alias": "url_for",
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "json",
          "name": "jsonify",
          "alias": "jsonify",
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "appcontext_popped",
          "alias": "appcontext_popped",
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "appcontext_pushed",
          "alias": "appcontext_pushed",
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "appcontext_tearing_down",
          "alias": "appcontext_tearing_down",
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "before_render_template",
          "alias": "before_render_template",
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "got_request_exception",
          "alias": "got_request_exception",
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "message_flashed",
          "alias": "message_flashed",
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "request_finished",
          "alias": "request_finished",
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "request_started",
          "alias": "request_started",
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "request_tearing_down",
          "alias": "request_tearing_down",
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "template_rendered",
          "alias": "template_rendered",
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "templating",
          "name": "render_template",
          "alias": "render_template",
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "templating",
          "name": "render_template_string",
          "alias": "render_template_string",
          "lineno": 35,
          "type": "from_import"
        },
        {
          "module": "templating",
          "name": "stream_template",
          "alias": "stream_template",
          "lineno": 36,
          "type": "from_import"
        },
        {
          "module": "templating",
          "name": "stream_template_string",
          "alias": "stream_template_string",
          "lineno": 37,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Request",
          "alias": "Request",
          "lineno": 38,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Response",
          "alias": "Response",
          "lineno": 39,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "json"
        ],
        "third_party": {
          "other": [
            "app",
            "blueprints",
            "config",
            "ctx",
            "globals",
            "helpers",
            "signals",
            "templating",
            "wrappers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 40
    },
    "src/flask/__main__.py": {
      "filepath": "../flask/src/flask/__main__.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "cli",
          "name": "main",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "main"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "cli"
          ]
        },
        "tech_stack": []
      },
      "line_count": 4
    },
    "src/flask/app.py": {
      "filepath": "../flask/src/flask/app.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_make_timedelta",
          "args": [
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 72,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "timedelta",
            "isinstance"
          ],
          "docstring": null,
          "code": "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "remove_ctx",
          "args": [
            {
              "name": "f",
              "type": "F"
            }
          ],
          "return_type": "F",
          "lineno": 84,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self",
            "kwargs",
            "isinstance",
            "AppContext",
            "wrapper",
            "update_wrapper"
          ],
          "docstring": null,
          "code": "def remove_ctx(f: F) -> F:\n    def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if args and isinstance(args[0], AppContext):\n            args = args[1:]\n\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper, f)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "add_ctx",
          "args": [
            {
              "name": "f",
              "type": "F"
            }
          ],
          "return_type": "F",
          "lineno": 96,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self",
            "kwargs",
            "isinstance",
            "app_ctx._get_current_object",
            "AppContext",
            "wrapper",
            "update_wrapper"
          ],
          "docstring": null,
          "code": "def add_ctx(f: F) -> F:\n    def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not args:\n            args = (app_ctx._get_current_object(),)\n        elif not isinstance(args[0], AppContext):\n            args = (app_ctx._get_current_object(), *args)\n\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper, f)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "wrapper",
          "args": [
            {
              "name": "self",
              "type": "Flask"
            }
          ],
          "return_type": "t.Any",
          "lineno": 85,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self",
            "isinstance",
            "kwargs",
            "AppContext"
          ],
          "docstring": null,
          "code": "def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if args and isinstance(args[0], AppContext):\n            args = args[1:]\n\n        return f(self, *args, **kwargs)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "wrapper",
          "args": [
            {
              "name": "self",
              "type": "Flask"
            }
          ],
          "return_type": "t.Any",
          "lineno": 97,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self",
            "isinstance",
            "kwargs",
            "app_ctx._get_current_object",
            "AppContext"
          ],
          "docstring": null,
          "code": "def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not args:\n            args = (app_ctx._get_current_object(),)\n        elif not isinstance(args[0], AppContext):\n            args = (app_ctx._get_current_object(), *args)\n\n        return f(self, *args, **kwargs)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__init_subclass__",
          "args": [
            {
              "name": "cls"
            }
          ],
          "return_type": "None",
          "lineno": 253,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "unknown.parameters.values",
            "remove_ctx",
            "getattr",
            "method.__name__",
            "DeprecationWarning",
            "issubclass",
            "setattr",
            "next",
            "iter",
            "AppContext",
            "inspect.isclass",
            "cls",
            "add_ctx",
            "base_method",
            "method",
            "inspect.signature",
            "param.annotation.rpartition",
            "param.annotation",
            "iter_params",
            "isinstance",
            "warnings.warn",
            "Flask"
          ],
          "docstring": null,
          "code": "def __init_subclass__(cls, **kwargs: t.Any) -> None:\n        import warnings\n\n        # These method signatures were updated to take a ctx param. Detect\n        # overridden methods in subclasses that still have the old signature.\n        # Show a deprecation warning and wrap to call with correct args.\n        for method in (\n            cls.handle_http_exception,\n            cls.handle_user_exception,\n            cls.handle_exception,\n            cls.log_exception,\n            cls.dispatch_request,\n            cls.full_dispatch_request,\n            cls.finalize_request,\n            cls.make_default_options_response,\n            cls.preprocess_request,\n            cls.process_response,\n            cls.do_teardown_request,\n            cls.do_teardown_appcontext,\n        ):\n            base_method = getattr(Flask, method.__name__)\n\n            if method is base_method:\n                # not overridden\n                continue\n\n            # get the second parameter (first is self)\n            iter_params = iter(inspect.signature(method).parameters.values())\n            next(iter_params)\n            param = next(iter_params, None)\n\n            # must have second parameter named ctx or annotated AppContext\n            if param is None or not (\n                # no annotation, match name\n                (param.annotation is inspect.Parameter.empty and param.name == \"ctx\")\n                or (\n                    # string annotation, access path ends with AppContext\n                    isinstance(param.annotation, str)\n                    and param.annotation.rpartition(\".\")[2] == \"AppContext\"\n                )\n                or (\n                    # class annotation\n                    inspect.isclass(param.annotation)\n                    and issubclass(param.annotation, AppContext)\n                )\n            ):\n                warnings.warn(\n                    f\"The '{method.__name__}' method now takes 'ctx: AppContext'\"\n                    \" as the first parameter. The old signature is deprecated\"\n                    \" and will not be supported in Flask 4.0.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n                setattr(cls, method.__name__, remove_ctx(method))\n                setattr(Flask, method.__name__, add_ctx(base_method))",
          "line_count": 55,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "import_name",
              "type": "str"
            },
            {
              "name": "static_url_path",
              "type": "Any"
            },
            {
              "name": "static_folder",
              "type": "Any"
            },
            {
              "name": "static_host",
              "type": "Any"
            },
            {
              "name": "host_matching",
              "type": "bool"
            },
            {
              "name": "subdomain_matching",
              "type": "bool"
            },
            {
              "name": "template_folder",
              "type": "Any"
            },
            {
              "name": "instance_path",
              "type": "Any"
            },
            {
              "name": "instance_relative_config",
              "type": "bool"
            },
            {
              "name": "root_path",
              "type": "Any"
            }
          ],
          "return_type": null,
          "lineno": 309,
          "decorators": [],
          "is_async": false,
          "calls": [
            "weakref.ref",
            "host_matching",
            "static_url_path",
            "root_path",
            "unknown.__init__",
            "super",
            "instance_path",
            "static_host",
            "template_folder",
            "subdomain_matching",
            "import_name",
            "cli.AppGroup",
            "unknown.send_static_file",
            "self.add_url_rule",
            "self",
            "kw",
            "static_folder",
            "instance_relative_config",
            "self.name",
            "self_ref",
            "bool"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_url_path=static_url_path,\n            static_folder=static_folder,\n            static_host=static_host,\n            host_matching=host_matching,\n            subdomain_matching=subdomain_matching,\n            template_folder=template_folder,\n            instance_path=instance_path,\n            instance_relative_config=instance_relative_config,\n            root_path=root_path,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = cli.AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert bool(static_host) == host_matching, (\n                \"Invalid static_host/host_matching combination\"\n            )\n            # Use a weakref to avoid creating a reference cycle between the app\n            # and the view function (see #3761).\n            self_ref = weakref.ref(self)\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n            )",
          "line_count": 54,
          "needs_llm_summary": true
        },
        {
          "name": "get_send_file_max_age",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 364,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "value.total_seconds",
            "value",
            "timedelta",
            "int"
          ],
          "docstring": "Used by :func:`send_file` to determine the ``max_age`` cache\nvalue for a given file path if it wasn't passed.\n\nBy default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\nthe configuration of :data:`~flask.current_app`. This defaults\nto ``None``, which tells the browser to use conditional requests\ninstead of a timed cache, which is usually preferable.\n\nNote this is a duplicate of the same method in the Flask\nclass.\n\n.. versionchanged:: 2.0\n    The default configuration is ``None`` instead of 12 hours.\n\n.. versionadded:: 0.9",
          "code": "def get_send_file_max_age(self, filename: str | None) -> int | None:\n        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n        value for a given file path if it wasn't passed.\n\n        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n        the configuration of :data:`~flask.current_app`. This defaults\n        to ``None``, which tells the browser to use conditional requests\n        instead of a timed cache, which is usually preferable.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionchanged:: 2.0\n            The default configuration is ``None`` instead of 12 hours.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        value = self.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n\n        if value is None:\n            return None\n\n        if isinstance(value, timedelta):\n            return int(value.total_seconds())\n\n        return value",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "send_static_file",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "str"
            }
          ],
          "return_type": "Response",
          "lineno": 391,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "RuntimeError",
            "max_age",
            "self.get_send_file_max_age",
            "self.static_folder",
            "t.cast",
            "filename",
            "send_from_directory"
          ],
          "docstring": "The view function used to serve files from\n:attr:`static_folder`. A route is automatically registered for\nthis view at :attr:`static_url_path` if :attr:`static_folder` is\nset.\n\nNote this is a duplicate of the same method in the Flask\nclass.\n\n.. versionadded:: 0.5",
          "code": "def send_static_file(self, filename: str) -> Response:\n        \"\"\"The view function used to serve files from\n        :attr:`static_folder`. A route is automatically registered for\n        this view at :attr:`static_url_path` if :attr:`static_folder` is\n        set.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionadded:: 0.5\n\n        \"\"\"\n        if not self.has_static_folder:\n            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n\n        # send_file only knows to call get_send_file_max_age on the app,\n        # call it here so it works for blueprints too.\n        max_age = self.get_send_file_max_age(filename)\n        return send_from_directory(\n            t.cast(str, self.static_folder), filename, max_age=max_age\n        )",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "open_resource",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "resource",
              "type": "str"
            },
            {
              "name": "mode",
              "type": "str"
            },
            {
              "name": "encoding",
              "type": "Any"
            }
          ],
          "return_type": "t.IO[t.AnyStr]",
          "lineno": 413,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.root_path",
            "ValueError",
            "open",
            "mode",
            "os.path.join",
            "encoding",
            "resource",
            "path"
          ],
          "docstring": "Open a resource file relative to :attr:`root_path` for reading.\n\nFor example, if the file ``schema.sql`` is next to the file\n``app.py`` where the ``Flask`` app is defined, it can be opened\nwith:\n\n.. code-block:: python\n\n    with app.open_resource(\"schema.sql\") as f:\n        conn.executescript(f.read())\n\n:param resource: Path to the resource relative to :attr:`root_path`.\n:param mode: Open the file in this mode. Only reading is supported,\n    valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n:param encoding: Open the file with this encoding when opening in text\n    mode. This is ignored when opening in binary mode.\n\n.. versionchanged:: 3.1\n    Added the ``encoding`` parameter.",
          "code": "def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = None\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading.\n\n        For example, if the file ``schema.sql`` is next to the file\n        ``app.py`` where the ``Flask`` app is defined, it can be opened\n        with:\n\n        .. code-block:: python\n\n            with app.open_resource(\"schema.sql\") as f:\n                conn.executescript(f.read())\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "open_instance_resource",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "resource",
              "type": "str"
            },
            {
              "name": "mode",
              "type": "str"
            },
            {
              "name": "encoding",
              "type": "Any"
            }
          ],
          "return_type": "t.IO[t.AnyStr]",
          "lineno": 446,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.instance_path",
            "open",
            "mode",
            "os.path.join",
            "encoding",
            "resource",
            "path"
          ],
          "docstring": "Open a resource file relative to the application's instance folder\n:attr:`instance_path`. Unlike :meth:`open_resource`, files in the\ninstance folder can be opened for writing.\n\n:param resource: Path to the resource relative to :attr:`instance_path`.\n:param mode: Open the file in this mode.\n:param encoding: Open the file with this encoding when opening in text\n    mode. This is ignored when opening in binary mode.\n\n.. versionchanged:: 3.1\n    Added the ``encoding`` parameter.",
          "code": "def open_instance_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to the application's instance folder\n        :attr:`instance_path`. Unlike :meth:`open_resource`, files in the\n        instance folder can be opened for writing.\n\n        :param resource: Path to the resource relative to :attr:`instance_path`.\n        :param mode: Open the file in this mode.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        path = os.path.join(self.instance_path, resource)\n\n        if \"b\" in mode:\n            return open(path, mode)\n\n        return open(path, mode, encoding=encoding)",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "create_jinja_environment",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Environment",
          "lineno": 468,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "request",
            "options",
            "get_flashed_messages",
            "self.jinja_options",
            "self.select_jinja_autoescape",
            "self.json.dumps",
            "self.jinja_environment",
            "session",
            "g",
            "dict",
            "rv.globals.update",
            "auto_reload",
            "self.debug",
            "self.url_for",
            "self.config"
          ],
          "docstring": "Create the Jinja environment based on :attr:`jinja_options`\nand the various Jinja-related methods of the app. Changing\n:attr:`jinja_options` after this will have no effect. Also adds\nFlask-related globals and filters to the environment.\n\n.. versionchanged:: 0.11\n   ``Environment.auto_reload`` set in accordance with\n   ``TEMPLATES_AUTO_RELOAD`` configuration option.\n\n.. versionadded:: 0.5",
          "code": "def create_jinja_environment(self) -> Environment:\n        \"\"\"Create the Jinja environment based on :attr:`jinja_options`\n        and the various Jinja-related methods of the app. Changing\n        :attr:`jinja_options` after this will have no effect. Also adds\n        Flask-related globals and filters to the environment.\n\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n\n        if \"auto_reload\" not in options:\n            auto_reload = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n\n            if auto_reload is None:\n                auto_reload = self.debug\n\n            options[\"auto_reload\"] = auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=self.url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.policies[\"json.dumps_function\"] = self.json.dumps\n        return rv",
          "line_count": 39,
          "needs_llm_summary": true
        },
        {
          "name": "create_url_adapter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 508,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.url_map.bind_to_environ",
            "self.url_map.bind",
            "request.trusted_hosts",
            "server_name",
            "request.environ",
            "subdomain",
            "get_host",
            "trusted_hosts"
          ],
          "docstring": "Creates a URL adapter for the given request. The URL adapter\nis created at a point where the request context is not yet set\nup so the request is passed explicitly.\n\n.. versionchanged:: 3.1\n    If :data:`SERVER_NAME` is set, it does not restrict requests to\n    only that domain, for both ``subdomain_matching`` and\n    ``host_matching``.\n\n.. versionchanged:: 1.0\n    :data:`SERVER_NAME` no longer implicitly enables subdomain\n    matching. Use :attr:`subdomain_matching` instead.\n\n.. versionchanged:: 0.9\n   This can be called outside a request when the URL adapter is created\n   for an application context.\n\n.. versionadded:: 0.6",
          "code": "def create_url_adapter(self, request: Request | None) -> MapAdapter | None:\n        \"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionchanged:: 3.1\n            If :data:`SERVER_NAME` is set, it does not restrict requests to\n            only that domain, for both ``subdomain_matching`` and\n            ``host_matching``.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n\n        .. versionchanged:: 0.9\n           This can be called outside a request when the URL adapter is created\n           for an application context.\n\n        .. versionadded:: 0.6\n        \"\"\"\n        if request is not None:\n            if (trusted_hosts := self.config[\"TRUSTED_HOSTS\"]) is not None:\n                request.trusted_hosts = trusted_hosts\n\n            # Check trusted_hosts here until bind_to_environ does.\n            request.host = get_host(request.environ, request.trusted_hosts)  # pyright: ignore\n            subdomain = None\n            server_name = self.config[\"SERVER_NAME\"]\n\n            if self.url_map.host_matching:\n                # Don't pass SERVER_NAME, otherwise it's used and the actual\n                # host is ignored, which breaks host matching.\n                server_name = None\n            elif not self.subdomain_matching:\n                # Werkzeug doesn't implement subdomain matching yet. Until then,\n                # disable it by forcing the current subdomain to the default, or\n                # the empty string.\n                subdomain = self.url_map.default_subdomain or \"\"\n\n            return self.url_map.bind_to_environ(\n                request.environ, server_name=server_name, subdomain=subdomain\n            )\n\n        # Need at least SERVER_NAME to match/build outside a request.\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n\n        return None",
          "line_count": 52,
          "needs_llm_summary": true
        },
        {
          "name": "raise_routing_exception",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request",
              "type": "Request"
            }
          ],
          "return_type": "t.NoReturn",
          "lineno": 561,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "request",
            "request.routing_exception",
            "FormDataRoutingRedirect",
            "RequestRedirect"
          ],
          "docstring": "Intercept routing exceptions and possibly do something else.\n\nIn debug mode, intercept a routing redirect and replace it with\nan error if the body will be discarded.\n\nWith modern Werkzeug this shouldn't occur, since it now uses a\n308 status which tells the browser to resend the method and\nbody.\n\n.. versionchanged:: 2.1\n    Don't intercept 307 and 308 redirects.\n\n:meta private:\n:internal:",
          "code": "def raise_routing_exception(self, request: Request) -> t.NoReturn:\n        \"\"\"Intercept routing exceptions and possibly do something else.\n\n        In debug mode, intercept a routing redirect and replace it with\n        an error if the body will be discarded.\n\n        With modern Werkzeug this shouldn't occur, since it now uses a\n        308 status which tells the browser to resend the method and\n        body.\n\n        .. versionchanged:: 2.1\n            Don't intercept 307 and 308 redirects.\n\n        :meta private:\n        :internal:\n        \"\"\"\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.routing_exception.code in {307, 308}\n            or request.method in {\"GET\", \"HEAD\", \"OPTIONS\"}\n        ):\n            raise request.routing_exception  # type: ignore[misc]\n\n        from .debughelpers import FormDataRoutingRedirect\n\n        raise FormDataRoutingRedirect(request)",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "update_template_context",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "context",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "None",
          "lineno": 589,
          "decorators": [],
          "is_async": false,
          "calls": [
            "reversed",
            "context.update",
            "func",
            "chain",
            "ctx.request.blueprints",
            "self.ensure_sync",
            "context.copy",
            "names",
            "orig_ctx"
          ],
          "docstring": "Update the template context with some commonly used variables.\nThis injects request, session, config and g into the template\ncontext as well as everything template context processors want\nto inject.  Note that the as of Flask 0.6, the original values\nin the context will not be overridden if a context processor\ndecides to return a value with the same key.\n\n:param context: the context as a dictionary that is updated in place\n                to add extra variables.",
          "code": "def update_template_context(\n        self, ctx: AppContext, context: dict[str, t.Any]\n    ) -> None:\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        names: t.Iterable[str | None] = (None,)\n\n        # A template may be rendered outside a request context.\n        if ctx.has_request:\n            names = chain(names, reversed(ctx.request.blueprints))\n\n        # The values passed to render_template take precedence. Keep a\n        # copy to re-apply after all context functions.\n        orig_ctx = context.copy()\n\n        for name in names:\n            if name in self.template_context_processors:\n                for func in self.template_context_processors[name]:\n                    context.update(self.ensure_sync(func)())\n\n        context.update(orig_ctx)",
          "line_count": 29,
          "needs_llm_summary": true
        },
        {
          "name": "make_shell_context",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 619,
          "decorators": [],
          "is_async": false,
          "calls": [
            "processor",
            "rv.update"
          ],
          "docstring": "Returns the shell context for an interactive shell for this\napplication.  This runs all the registered shell context\nprocessors.\n\n.. versionadded:: 0.11",
          "code": "def make_shell_context(self) -> dict[str, t.Any]:\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "run",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "host",
              "type": "Any"
            },
            {
              "name": "port",
              "type": "Any"
            },
            {
              "name": "debug",
              "type": "Any"
            },
            {
              "name": "load_dotenv",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 631,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "sn_host",
            "cli.load_dotenv",
            "self.config.get",
            "port",
            "options",
            "os.environ.get",
            "is_running_from_reloader",
            "debug",
            "run_simple",
            "cli.show_server_banner",
            "options.setdefault",
            "host",
            "get_load_dotenv",
            "click.secho",
            "t.cast",
            "self.debug",
            "int",
            "get_debug_flag",
            "self",
            "server_name.partition",
            "sn_port",
            "self.name",
            "load_dotenv",
            "bool"
          ],
          "docstring": "Runs the application on a local development server.\n\nDo not use ``run()`` in a production setting. It is not intended to\nmeet security and performance requirements for a production server.\nInstead, see :doc:`/deploying/index` for WSGI server recommendations.\n\nIf the :attr:`debug` flag is set the server will automatically reload\nfor code changes and show a debugger in case an exception happened.\n\nIf you want to run the application in debug mode, but disable the\ncode execution on the interactive debugger, you can pass\n``use_evalex=False`` as parameter.  This will keep the debugger's\ntraceback screen active, but disable code execution.\n\nIt is not recommended to use this function for development with\nautomatic reloading as this is badly supported.  Instead you should\nbe using the :command:`flask` command line script's ``run`` support.\n\n.. admonition:: Keep in Mind\n\n   Flask will suppress any server error with a generic error page\n   unless it is in debug mode.  As such to enable just the\n   interactive debugger without the code reloading, you have to\n   invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n   Setting ``use_debugger`` to ``True`` without being in debug mode\n   won't catch any exceptions because there won't be any to\n   catch.\n\n:param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n    have the server available externally as well. Defaults to\n    ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n    if present.\n:param port: the port of the webserver. Defaults to ``5000`` or the\n    port defined in the ``SERVER_NAME`` config variable if present.\n:param debug: if given, enable or disable debug mode. See\n    :attr:`debug`.\n:param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n    files to set environment variables. Will also change the working\n    directory to the directory containing the first file found.\n:param options: the options to be forwarded to the underlying Werkzeug\n    server. See :func:`werkzeug.serving.run_simple` for more\n    information.\n\n.. versionchanged:: 1.0\n    If installed, python-dotenv will be used to load environment\n    variables from :file:`.env` and :file:`.flaskenv` files.\n\n    The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.\n\n    Threaded mode is enabled by default.\n\n.. versionchanged:: 0.10\n    The default port is now picked from the ``SERVER_NAME``\n    variable.",
          "code": "def run(\n        self,\n        host: str | None = None,\n        port: int | None = None,\n        debug: bool | None = None,\n        load_dotenv: bool = True,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :doc:`/deploying/index` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Ignore this call so that it doesn't start another server if\n        # the 'flask run' command is used.\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            if not is_running_from_reloader():\n                click.secho(\n                    \" * Ignoring a call to 'app.run()' that would block\"\n                    \" the current 'flask' CLI command.\\n\"\n                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n                    ' \"__main__\"\\' guard.',\n                    fg=\"red\",\n                )\n\n            return\n\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n\n            # if set, env var overrides existing value\n            if \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n\n        cli.show_server_banner(self.debug, self.name)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(t.cast(str, host), port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False",
          "line_count": 122,
          "needs_llm_summary": true
        },
        {
          "name": "test_client",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "use_cookies",
              "type": "bool"
            }
          ],
          "return_type": "FlaskClient",
          "lineno": 754,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "kwargs",
            "use_cookies",
            "self.test_client_class",
            "cls",
            "self.response_class"
          ],
          "docstring": "Creates a test client for this application.  For information\nabout unit testing head over to :doc:`/testing`.\n\nNote that if you are testing for assertions or exceptions in your\napplication code, you must set ``app.testing = True`` in order for the\nexceptions to propagate to the test client.  Otherwise, the exception\nwill be handled by the application (not visible to the test client) and\nthe only indication of an AssertionError or other exception will be a\n500 status code response to the test client.  See the :attr:`testing`\nattribute.  For example::\n\n    app.testing = True\n    client = app.test_client()\n\nThe test client can be used in a ``with`` block to defer the closing down\nof the context until the end of the ``with`` block.  This is useful if\nyou want to access the context locals for testing::\n\n    with app.test_client() as c:\n        rv = c.get('/?vodka=42')\n        assert request.args['vodka'] == '42'\n\nAdditionally, you may pass optional keyword arguments that will then\nbe passed to the application's :attr:`test_client_class` constructor.\nFor example::\n\n    from flask.testing import FlaskClient\n\n    class CustomClient(FlaskClient):\n        def __init__(self, *args, **kwargs):\n            self._authentication = kwargs.pop(\"authentication\")\n            super(CustomClient,self).__init__( *args, **kwargs)\n\n    app.test_client_class = CustomClient\n    client = app.test_client(authentication='Basic ....')\n\nSee :class:`~flask.testing.FlaskClient` for more information.\n\n.. versionchanged:: 0.4\n   added support for ``with`` block usage for the client.\n\n.. versionadded:: 0.7\n   The `use_cookies` parameter was added as well as the ability\n   to override the client to be used by setting the\n   :attr:`test_client_class` attribute.\n\n.. versionchanged:: 0.11\n   Added `**kwargs` to support passing additional keyword arguments to\n   the constructor of :attr:`test_client_class`.",
          "code": "def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :doc:`/testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(  # type: ignore\n            self, self.response_class, use_cookies=use_cookies, **kwargs\n        )",
          "line_count": 57,
          "needs_llm_summary": true
        },
        {
          "name": "test_cli_runner",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "FlaskCliRunner",
          "lineno": 812,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.test_cli_runner_class",
            "kwargs",
            "self",
            "cls"
          ],
          "docstring": "Create a CLI runner for testing CLI commands.\nSee :ref:`testing-cli`.\n\nReturns an instance of :attr:`test_cli_runner_class`, by default\n:class:`~flask.testing.FlaskCliRunner`. The Flask app object is\npassed as the first argument.\n\n.. versionadded:: 1.0",
          "code": "def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:\n        \"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        cls = self.test_cli_runner_class\n\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "handle_http_exception",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "e",
              "type": "HTTPException"
            }
          ],
          "return_type": "Any",
          "lineno": 829,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "RoutingException",
            "handler",
            "ctx.request.blueprints",
            "self.ensure_sync",
            "e",
            "self._find_error_handler"
          ],
          "docstring": "Handles an HTTP exception.  By default this will invoke the\nregistered error handlers and fall back to returning the\nexception as response.\n\n.. versionchanged:: 1.0.3\n    ``RoutingException``, used internally for actions such as\n     slash redirects during routing, is not passed to error\n     handlers.\n\n.. versionchanged:: 1.0\n    Exceptions are looked up by code *and* by MRO, so\n    ``HTTPException`` subclasses can be handled with a catch-all\n    handler for the base ``HTTPException``.\n\n.. versionadded:: 0.3",
          "code": "def handle_http_exception(\n        self, ctx: AppContext, e: HTTPException\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPException`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e, ctx.request.blueprints)\n        if handler is None:\n            return e\n        return self.ensure_sync(handler)(e)",
          "line_count": 34,
          "needs_llm_summary": true
        },
        {
          "name": "handle_user_exception",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "e",
              "type": "Exception"
            }
          ],
          "return_type": "Any",
          "lineno": 864,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "self.handle_http_exception",
            "HTTPException",
            "ctx",
            "handler",
            "ctx.request.blueprints",
            "BadRequestKeyError",
            "self.ensure_sync",
            "e",
            "self._find_error_handler",
            "self.trap_http_exception"
          ],
          "docstring": "This method is called whenever an exception occurs that\nshould be handled. A special case is :class:`~werkzeug\n.exceptions.HTTPException` which is forwarded to the\n:meth:`handle_http_exception` method. This function will either\nreturn a response value or reraise the exception with the same\ntraceback.\n\n.. versionchanged:: 1.0\n    Key errors raised from request data like ``form`` show the\n    bad key in debug mode rather than a generic bad request\n    message.\n\n.. versionadded:: 0.7",
          "code": "def handle_user_exception(\n        self, ctx: AppContext, e: Exception\n    ) -> HTTPException | ft.ResponseReturnValue:\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the\n            bad key in debug mode rather than a generic bad request\n            message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        if isinstance(e, BadRequestKeyError) and (\n            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        ):\n            e.show_exception = True\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(ctx, e)\n\n        handler = self._find_error_handler(e, ctx.request.blueprints)\n\n        if handler is None:\n            raise\n\n        return self.ensure_sync(handler)(e)",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "handle_exception",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "e",
              "type": "Exception"
            }
          ],
          "return_type": "Response",
          "lineno": 896,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "InternalServerError",
            "ctx",
            "exc_info",
            "handler",
            "server_error",
            "self.ensure_sync",
            "ctx.request.blueprints",
            "self.finalize_request",
            "e",
            "self._find_error_handler",
            "got_request_exception.send",
            "self.log_exception",
            "sys.exc_info"
          ],
          "docstring": "Handle an exception that did not have an error handler\nassociated with it, or that was raised from an error handler.\nThis always causes a 500 ``InternalServerError``.\n\nAlways sends the :data:`got_request_exception` signal.\n\nIf :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug\nmode, the error will be re-raised so that the debugger can\ndisplay it. Otherwise, the original exception is logged, and\nan :exc:`~werkzeug.exceptions.InternalServerError` is returned.\n\nIf an error handler is registered for ``InternalServerError`` or\n``500``, it will be used. For consistency, the handler will\nalways receive the ``InternalServerError``. The original\nunhandled exception is available as ``e.original_exception``.\n\n.. versionchanged:: 1.1.0\n    Always passes the ``InternalServerError`` instance to the\n    handler, setting ``original_exception`` to the unhandled\n    error.\n\n.. versionchanged:: 1.1.0\n    ``after_request`` functions and other finalization is done\n    even for the default 500 response when there is no handler.\n\n.. versionadded:: 0.3",
          "code": "def handle_exception(self, ctx: AppContext, e: Exception) -> Response:\n        \"\"\"Handle an exception that did not have an error handler\n        associated with it, or that was raised from an error handler.\n        This always causes a 500 ``InternalServerError``.\n\n        Always sends the :data:`got_request_exception` signal.\n\n        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug\n        mode, the error will be re-raised so that the debugger can\n        display it. Otherwise, the original exception is logged, and\n        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.\n\n        If an error handler is registered for ``InternalServerError`` or\n        ``500``, it will be used. For consistency, the handler will\n        always receive the ``InternalServerError``. The original\n        unhandled exception is available as ``e.original_exception``.\n\n        .. versionchanged:: 1.1.0\n            Always passes the ``InternalServerError`` instance to the\n            handler, setting ``original_exception`` to the unhandled\n            error.\n\n        .. versionchanged:: 1.1.0\n            ``after_request`` functions and other finalization is done\n            even for the default 500 response when there is no handler.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_info = sys.exc_info()\n        got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)\n        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]\n\n        if propagate is None:\n            propagate = self.testing or self.debug\n\n        if propagate:\n            # Re-raise if called with an active exception, otherwise\n            # raise the passed in exception.\n            if exc_info[1] is e:\n                raise\n\n            raise e\n\n        self.log_exception(ctx, exc_info)\n        server_error: InternalServerError | ft.ResponseReturnValue\n        server_error = InternalServerError(original_exception=e)\n        handler = self._find_error_handler(server_error, ctx.request.blueprints)\n\n        if handler is not None:\n            server_error = self.ensure_sync(handler)(server_error)\n\n        return self.finalize_request(ctx, server_error, from_error_handler=True)",
          "line_count": 52,
          "needs_llm_summary": true
        },
        {
          "name": "log_exception",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "exc_info",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 949,
          "decorators": [],
          "is_async": false,
          "calls": [
            "exc_info",
            "self.logger.error"
          ],
          "docstring": "Logs an exception.  This is called by :meth:`handle_exception`\nif debugging is disabled and right before the handler is called.\nThe default implementation logs the exception as error on the\n:attr:`logger`.\n\n.. versionadded:: 0.8",
          "code": "def log_exception(\n        self,\n        ctx: AppContext,\n        exc_info: tuple[type, BaseException, TracebackType] | tuple[None, None, None],\n    ) -> None:\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error(\n            f\"Exception on {ctx.request.path} [{ctx.request.method}]\", exc_info=exc_info\n        )",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "dispatch_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            }
          ],
          "return_type": "ft.ResponseReturnValue",
          "lineno": 965,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.make_default_options_response",
            "req",
            "ctx",
            "ctx.request",
            "getattr",
            "self.ensure_sync",
            "view_args",
            "rule",
            "self.raise_routing_exception"
          ],
          "docstring": "Does the request dispatching.  Matches the URL and returns the\nreturn value of the view or error handler.  This does not have to\nbe a response object.  In order to convert the return value to a\nproper response object, call :func:`make_response`.\n\n.. versionchanged:: 0.7\n   This no longer does the exception handling, this code was\n   moved to the new :meth:`full_dispatch_request`.",
          "code": "def dispatch_request(self, ctx: AppContext) -> ft.ResponseReturnValue:\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = ctx.request\n\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule: Rule = req.url_rule  # type: ignore[assignment]\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response(ctx)\n        # otherwise dispatch to the handler for that endpoint\n        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "full_dispatch_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            }
          ],
          "return_type": "Response",
          "lineno": 991,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "ctx",
            "self.handle_user_exception",
            "self.ensure_sync",
            "self.preprocess_request",
            "request_started.send",
            "e",
            "rv",
            "self.dispatch_request",
            "self.finalize_request"
          ],
          "docstring": "Dispatches the request and on top of that performs request\npre and postprocessing as well as HTTP exception catching and\nerror handling.\n\n.. versionadded:: 0.7",
          "code": "def full_dispatch_request(self, ctx: AppContext) -> Response:\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._got_first_request = True\n\n        try:\n            request_started.send(self, _async_wrapper=self.ensure_sync)\n            rv = self.preprocess_request(ctx)\n            if rv is None:\n                rv = self.dispatch_request(ctx)\n        except Exception as e:\n            rv = self.handle_user_exception(ctx, e)\n        return self.finalize_request(ctx, rv)",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "finalize_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "rv",
              "type": "Any"
            },
            {
              "name": "from_error_handler",
              "type": "bool"
            }
          ],
          "return_type": "Response",
          "lineno": 1009,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.process_response",
            "self",
            "request_finished.send",
            "self.logger.exception",
            "ctx",
            "self.ensure_sync",
            "response",
            "rv",
            "self.make_response"
          ],
          "docstring": "Given the return value from a view function this finalizes\nthe request by converting it into a response and invoking the\npostprocessing functions.  This is invoked for both normal\nrequest dispatching as well as error handlers.\n\nBecause this means that it might be called as a result of a\nfailure a special safe mode is available which can be enabled\nwith the `from_error_handler` flag.  If enabled, failures in\nresponse processing will be logged and otherwise ignored.\n\n:internal:",
          "code": "def finalize_request(\n        self,\n        ctx: AppContext,\n        rv: ft.ResponseReturnValue | HTTPException,\n        from_error_handler: bool = False,\n    ) -> Response:\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(ctx, response)\n            request_finished.send(\n                self, _async_wrapper=self.ensure_sync, response=response\n            )\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "make_default_options_response",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            }
          ],
          "return_type": "Response",
          "lineno": 1041,
          "decorators": [],
          "is_async": false,
          "calls": [
            "rv.allow.update",
            "self.response_class",
            "methods",
            "ctx.url_adapter.allowed_methods"
          ],
          "docstring": "This method is called to create the default ``OPTIONS`` response.\nThis can be changed through subclassing to change the default\nbehavior of ``OPTIONS`` responses.\n\n.. versionadded:: 0.7",
          "code": "def make_default_options_response(self, ctx: AppContext) -> Response:\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        methods = ctx.url_adapter.allowed_methods()  # type: ignore[union-attr]\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "ensure_sync",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "func",
              "type": "t.Callable[Ellipsis, t.Any]"
            }
          ],
          "return_type": "t.Callable[Ellipsis, t.Any]",
          "lineno": 1053,
          "decorators": [],
          "is_async": false,
          "calls": [
            "func",
            "self.async_to_sync",
            "iscoroutinefunction"
          ],
          "docstring": "Ensure that the function is synchronous for WSGI workers.\nPlain ``def`` functions are returned as-is. ``async def``\nfunctions are wrapped to run and wait for the response.\n\nOverride this method to change how the app runs async views.\n\n.. versionadded:: 2.0",
          "code": "def ensure_sync(self, func: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:\n        \"\"\"Ensure that the function is synchronous for WSGI workers.\n        Plain ``def`` functions are returned as-is. ``async def``\n        functions are wrapped to run and wait for the response.\n\n        Override this method to change how the app runs async views.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        if iscoroutinefunction(func):\n            return self.async_to_sync(func)\n\n        return func",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "async_to_sync",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "func",
              "type": "t.Callable[Ellipsis, t.Coroutine[t.Any, t.Any, t.Any]]"
            }
          ],
          "return_type": "t.Callable[Ellipsis, t.Any]",
          "lineno": 1067,
          "decorators": [],
          "is_async": false,
          "calls": [
            "asgiref_async_to_sync",
            "RuntimeError",
            "func"
          ],
          "docstring": "Return a sync function that will run the coroutine function.\n\n.. code-block:: python\n\n    result = app.async_to_sync(func)(*args, **kwargs)\n\nOverride this method to change how the app converts async code\nto be synchronously callable.\n\n.. versionadded:: 2.0",
          "code": "def async_to_sync(\n        self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]]\n    ) -> t.Callable[..., t.Any]:\n        \"\"\"Return a sync function that will run the coroutine function.\n\n        .. code-block:: python\n\n            result = app.async_to_sync(func)(*args, **kwargs)\n\n        Override this method to change how the app converts async code\n        to be synchronously callable.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        try:\n            from asgiref.sync import async_to_sync as asgiref_async_to_sync\n        except ImportError:\n            raise RuntimeError(\n                \"Install Flask with the 'async' extra in order to use async views.\"\n            ) from None\n\n        return asgiref_async_to_sync(func)",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "url_for",
          "args": [
            {
              "name": "endpoint",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 1090,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_url_quote",
            "_anchor",
            "ctx.url_adapter",
            "ctx.request.blueprint",
            "ValueError",
            "error",
            "values.update",
            "endpoint",
            "RuntimeError",
            "_cv_app.get",
            "values",
            "_method",
            "url_adapter.build",
            "self.handle_url_build_error",
            "_external",
            "_scheme",
            "self.inject_url_defaults",
            "self.create_url_adapter"
          ],
          "docstring": "Generate a URL to the given endpoint with the given values.\n\nThis is called by :func:`flask.url_for`, and can be called\ndirectly as well.\n\nAn *endpoint* is the name of a URL rule, usually added with\n:meth:`@app.route() <route>`, and usually the same name as the\nview function. A route defined in a :class:`~flask.Blueprint`\nwill prepend the blueprint's name separated by a ``.`` to the\nendpoint.\n\nIn some cases, such as email messages, you want URLs to include\nthe scheme and domain, like ``https://example.com/hello``. When\nnot in an active request, URLs will be external by default, but\nthis requires setting :data:`SERVER_NAME` so Flask knows what\ndomain to use. :data:`APPLICATION_ROOT` and\n:data:`PREFERRED_URL_SCHEME` should also be configured as\nneeded. This config is only used when not in an active request.\n\nFunctions can be decorated with :meth:`url_defaults` to modify\nkeyword arguments before the URL is built.\n\nIf building fails for some reason, such as an unknown endpoint\nor incorrect values, the app's :meth:`handle_url_build_error`\nmethod is called. If that returns a string, that is returned,\notherwise a :exc:`~werkzeug.routing.BuildError` is raised.\n\n:param endpoint: The endpoint name associated with the URL to\n    generate. If this starts with a ``.``, the current blueprint\n    name (if any) will be used.\n:param _anchor: If given, append this as ``#anchor`` to the URL.\n:param _method: If given, generate the URL associated with this\n    method for the endpoint.\n:param _scheme: If given, the URL will have this scheme if it\n    is external.\n:param _external: If given, prefer the URL to be internal\n    (False) or require it to be external (True). External URLs\n    include the scheme and domain. When not in an active\n    request, URLs are external by default.\n:param values: Values to use for the variable parts of the URL\n    rule. Unknown keys are appended as query string arguments,\n    like ``?a=b&c=d``.\n\n.. versionadded:: 2.2\n    Moved from ``flask.url_for``, which calls this method.",
          "code": "def url_for(\n        self,\n        /,\n        endpoint: str,\n        *,\n        _anchor: str | None = None,\n        _method: str | None = None,\n        _scheme: str | None = None,\n        _external: bool | None = None,\n        **values: t.Any,\n    ) -> str:\n        \"\"\"Generate a URL to the given endpoint with the given values.\n\n        This is called by :func:`flask.url_for`, and can be called\n        directly as well.\n\n        An *endpoint* is the name of a URL rule, usually added with\n        :meth:`@app.route() <route>`, and usually the same name as the\n        view function. A route defined in a :class:`~flask.Blueprint`\n        will prepend the blueprint's name separated by a ``.`` to the\n        endpoint.\n\n        In some cases, such as email messages, you want URLs to include\n        the scheme and domain, like ``https://example.com/hello``. When\n        not in an active request, URLs will be external by default, but\n        this requires setting :data:`SERVER_NAME` so Flask knows what\n        domain to use. :data:`APPLICATION_ROOT` and\n        :data:`PREFERRED_URL_SCHEME` should also be configured as\n        needed. This config is only used when not in an active request.\n\n        Functions can be decorated with :meth:`url_defaults` to modify\n        keyword arguments before the URL is built.\n\n        If building fails for some reason, such as an unknown endpoint\n        or incorrect values, the app's :meth:`handle_url_build_error`\n        method is called. If that returns a string, that is returned,\n        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.\n\n        :param endpoint: The endpoint name associated with the URL to\n            generate. If this starts with a ``.``, the current blueprint\n            name (if any) will be used.\n        :param _anchor: If given, append this as ``#anchor`` to the URL.\n        :param _method: If given, generate the URL associated with this\n            method for the endpoint.\n        :param _scheme: If given, the URL will have this scheme if it\n            is external.\n        :param _external: If given, prefer the URL to be internal\n            (False) or require it to be external (True). External URLs\n            include the scheme and domain. When not in an active\n            request, URLs are external by default.\n        :param values: Values to use for the variable parts of the URL\n            rule. Unknown keys are appended as query string arguments,\n            like ``?a=b&c=d``.\n\n        .. versionadded:: 2.2\n            Moved from ``flask.url_for``, which calls this method.\n        \"\"\"\n        if (ctx := _cv_app.get(None)) is not None and ctx.has_request:\n            url_adapter = ctx.url_adapter\n            blueprint_name = ctx.request.blueprint\n\n            # If the endpoint starts with \".\" and the request matches a\n            # blueprint, the endpoint is relative to the blueprint.\n            if endpoint[:1] == \".\":\n                if blueprint_name is not None:\n                    endpoint = f\"{blueprint_name}{endpoint}\"\n                else:\n                    endpoint = endpoint[1:]\n\n            # When in a request, generate a URL without scheme and\n            # domain by default, unless a scheme is given.\n            if _external is None:\n                _external = _scheme is not None\n        else:\n            # If called by helpers.url_for, an app context is active,\n            # use its url_adapter. Otherwise, app.url_for was called\n            # directly, build an adapter.\n            if ctx is not None:\n                url_adapter = ctx.url_adapter\n            else:\n                url_adapter = self.create_url_adapter(None)\n\n            if url_adapter is None:\n                raise RuntimeError(\n                    \"Unable to build URLs outside an active request\"\n                    \" without 'SERVER_NAME' configured. Also configure\"\n                    \" 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as\"\n                    \" needed.\"\n                )\n\n            # When outside a request, generate a URL with scheme and\n            # domain by default.\n            if _external is None:\n                _external = True\n\n        # It is an error to set _scheme when _external=False, in order\n        # to avoid accidental insecure URLs.\n        if _scheme is not None and not _external:\n            raise ValueError(\"When specifying '_scheme', '_external' must be True.\")\n\n        self.inject_url_defaults(endpoint, values)\n\n        try:\n            rv = url_adapter.build(  # type: ignore[union-attr]\n                endpoint,\n                values,\n                method=_method,\n                url_scheme=_scheme,\n                force_external=_external,\n            )\n        except BuildError as error:\n            values.update(\n                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n            )\n            return self.handle_url_build_error(error, endpoint, values)\n\n        if _anchor is not None:\n            _anchor = _url_quote(_anchor, safe=\"%!#$&'()*+,/:;=?@\")\n            rv = f\"{rv}#{_anchor}\"\n\n        return rv",
          "line_count": 121,
          "needs_llm_summary": true
        },
        {
          "name": "make_response",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rv",
              "type": "ft.ResponseReturnValue"
            }
          ],
          "return_type": "Response",
          "lineno": 1212,
          "decorators": [],
          "is_async": false,
          "calls": [
            "rv.headers.update",
            "tuple",
            "TypeError",
            "len",
            "unknown.with_traceback",
            "status",
            "self.response_class.force_type",
            "Response",
            "self.json.response",
            "t.cast",
            "cabc.Iterator",
            "self.response_class",
            "isinstance",
            "headers",
            "BaseResponse",
            "request.environ",
            "type",
            "rv",
            "callable",
            "sys.exc_info"
          ],
          "docstring": "Convert the return value from a view function to an instance of\n:attr:`response_class`.\n\n:param rv: the return value from the view function. The view function\n    must return a response. Returning ``None``, or the view ending\n    without returning, is not allowed. The following types are allowed\n    for ``view_rv``:\n\n    ``str``\n        A response object is created with the string encoded to UTF-8\n        as the body.\n\n    ``bytes``\n        A response object is created with the bytes as the body.\n\n    ``dict``\n        A dictionary that will be jsonify'd before being returned.\n\n    ``list``\n        A list that will be jsonify'd before being returned.\n\n    ``generator`` or ``iterator``\n        A generator that returns ``str`` or ``bytes`` to be\n        streamed as the response.\n\n    ``tuple``\n        Either ``(body, status, headers)``, ``(body, status)``, or\n        ``(body, headers)``, where ``body`` is any of the other types\n        allowed here, ``status`` is a string or an integer, and\n        ``headers`` is a dictionary or a list of ``(key, value)``\n        tuples. If ``body`` is a :attr:`response_class` instance,\n        ``status`` overwrites the exiting value and ``headers`` are\n        extended.\n\n    :attr:`response_class`\n        The object is returned unchanged.\n\n    other :class:`~werkzeug.wrappers.Response` class\n        The object is coerced to :attr:`response_class`.\n\n    :func:`callable`\n        The function is called as a WSGI application. The result is\n        used to create a response object.\n\n.. versionchanged:: 2.2\n    A generator will be converted to a streaming response.\n    A list will be converted to a JSON response.\n\n.. versionchanged:: 1.1\n    A dict will be converted to a JSON response.\n\n.. versionchanged:: 0.9\n   Previously a tuple was interpreted as the arguments for the\n   response object.",
          "code": "def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str``\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes``\n                A response object is created with the bytes as the body.\n\n            ``dict``\n                A dictionary that will be jsonify'd before being returned.\n\n            ``list``\n                A list that will be jsonify'd before being returned.\n\n            ``generator`` or ``iterator``\n                A generator that returns ``str`` or ``bytes`` to be\n                streamed as the response.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 2.2\n            A generator will be converted to a streaming response.\n            A list will be converted to a JSON response.\n\n        .. versionchanged:: 1.1\n            A dict will be converted to a JSON response.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status: int | None = None\n        headers: HeadersValue | None = None\n\n        # unpack tuple returns\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv  # type: ignore[misc]\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv  # pyright: ignore\n                else:\n                    rv, status = rv  # type: ignore[assignment,misc]\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(\n                    rv,  # pyright: ignore\n                    status=status,\n                    headers=headers,  # type: ignore[arg-type]\n                )\n                status = headers = None\n            elif isinstance(rv, (dict, list)):\n                rv = self.json.response(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(\n                        rv,  # type: ignore[arg-type]\n                        request.environ,\n                    )\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, list, tuple with headers or status,\"\n                        \" Response instance, or WSGI callable, but it\"\n                        f\" was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2]) from None\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, list, tuple with headers or status,\"\n                    \" Response instance, or WSGI callable, but it was a\"\n                    f\" {type(rv).__name__}.\"\n                )\n\n        rv = t.cast(Response, rv)\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.update(headers)\n\n        return rv",
          "line_count": 141,
          "needs_llm_summary": true
        },
        {
          "name": "preprocess_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            }
          ],
          "return_type": "Any",
          "lineno": 1354,
          "decorators": [],
          "is_async": false,
          "calls": [
            "req.blueprints",
            "req.endpoint",
            "req.view_args",
            "ctx.request",
            "before_func",
            "self.ensure_sync",
            "url_func",
            "reversed"
          ],
          "docstring": "Called before the request is dispatched. Calls\n:attr:`url_value_preprocessors` registered with the app and the\ncurrent blueprint (if any). Then calls :attr:`before_request_funcs`\nregistered with the app and the blueprint.\n\nIf any :meth:`before_request` handler returns a non-None value, the\nvalue is handled as if it was the return value from the view, and\nfurther request handling is stopped.",
          "code": "def preprocess_request(self, ctx: AppContext) -> ft.ResponseReturnValue | None:\n        \"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"\n        req = ctx.request\n        names = (None, *reversed(req.blueprints))\n\n        for name in names:\n            if name in self.url_value_preprocessors:\n                for url_func in self.url_value_preprocessors[name]:\n                    url_func(req.endpoint, req.view_args)\n\n        for name in names:\n            if name in self.before_request_funcs:\n                for before_func in self.before_request_funcs[name]:\n                    rv = self.ensure_sync(before_func)()\n\n                    if rv is not None:\n                        return rv  # type: ignore[no-any-return]\n\n        return None",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "process_response",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "response",
              "type": "Response"
            }
          ],
          "return_type": "Response",
          "lineno": 1382,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "ctx.session",
            "self.session_interface.is_null_session",
            "func",
            "chain",
            "ctx.request.blueprints",
            "self.ensure_sync",
            "response",
            "self.session_interface.save_session",
            "reversed"
          ],
          "docstring": "Can be overridden in order to modify the response object\nbefore it's sent to the WSGI server.  By default this will\ncall all the :meth:`after_request` decorated functions.\n\n.. versionchanged:: 0.5\n   As of Flask 0.5 the functions registered for after request\n   execution are called in reverse order of registration.\n\n:param response: a :attr:`response_class` object.\n:return: a new response object or the same, has to be an\n         instance of :attr:`response_class`.",
          "code": "def process_response(self, ctx: AppContext, response: Response) -> Response:\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        for func in ctx._after_request_functions:\n            response = self.ensure_sync(func)(response)\n\n        for name in chain(ctx.request.blueprints, (None,)):\n            if name in self.after_request_funcs:\n                for func in reversed(self.after_request_funcs[name]):\n                    response = self.ensure_sync(func)(response)\n\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n\n        return response",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "do_teardown_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "exc",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 1408,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "func",
            "chain",
            "exc",
            "ctx.request.blueprints",
            "self.ensure_sync",
            "request_tearing_down.send",
            "reversed"
          ],
          "docstring": "Called after the request is dispatched and the response is finalized,\nright before the request context is popped. Called by\n:meth:`.AppContext.pop`.\n\nThis calls all functions decorated with :meth:`teardown_request`, and\n:meth:`Blueprint.teardown_request` if a blueprint handled the request.\nFinally, the :data:`request_tearing_down` signal is sent.\n\n:param exc: An unhandled exception raised while dispatching the request.\n    Passed to each teardown function.\n\n.. versionchanged:: 0.9\n    Added the ``exc`` argument.",
          "code": "def do_teardown_request(\n        self, ctx: AppContext, exc: BaseException | None = None\n    ) -> None:\n        \"\"\"Called after the request is dispatched and the response is finalized,\n        right before the request context is popped. Called by\n        :meth:`.AppContext.pop`.\n\n        This calls all functions decorated with :meth:`teardown_request`, and\n        :meth:`Blueprint.teardown_request` if a blueprint handled the request.\n        Finally, the :data:`request_tearing_down` signal is sent.\n\n        :param exc: An unhandled exception raised while dispatching the request.\n            Passed to each teardown function.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        for name in chain(ctx.request.blueprints, (None,)):\n            if name in self.teardown_request_funcs:\n                for func in reversed(self.teardown_request_funcs[name]):\n                    self.ensure_sync(func)(exc)\n\n        request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "do_teardown_appcontext",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "exc",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 1432,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "appcontext_tearing_down.send",
            "func",
            "exc",
            "self.ensure_sync",
            "self.teardown_appcontext_funcs",
            "reversed"
          ],
          "docstring": "Called right before the application context is popped. Called by\n:meth:`.AppContext.pop`.\n\nThis calls all functions decorated with :meth:`teardown_appcontext`.\nThen the :data:`appcontext_tearing_down` signal is sent.\n\n:param exc: An unhandled exception raised while the context was active.\n    Passed to each teardown function.\n\n.. versionadded:: 0.9",
          "code": "def do_teardown_appcontext(\n        self, ctx: AppContext, exc: BaseException | None = None\n    ) -> None:\n        \"\"\"Called right before the application context is popped. Called by\n        :meth:`.AppContext.pop`.\n\n        This calls all functions decorated with :meth:`teardown_appcontext`.\n        Then the :data:`appcontext_tearing_down` signal is sent.\n\n        :param exc: An unhandled exception raised while the context was active.\n            Passed to each teardown function.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        for func in reversed(self.teardown_appcontext_funcs):\n            self.ensure_sync(func)(exc)\n\n        appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "app_context",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "AppContext",
          "lineno": 1451,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "AppContext"
          ],
          "docstring": "Create an :class:`.AppContext`. When the context is pushed,\n:data:`.current_app` and :data:`.g` become available.\n\nA context is automatically pushed when handling each request, and when\nrunning any ``flask`` CLI command. Use this as a ``with`` block to\nmanually push a context outside of those situations, such as during\nsetup or testing.\n\n.. code-block:: python\n\n    with app.app_context():\n        init_db()\n\nSee :doc:`/appcontext`.\n\n.. versionadded:: 0.9",
          "code": "def app_context(self) -> AppContext:\n        \"\"\"Create an :class:`.AppContext`. When the context is pushed,\n        :data:`.current_app` and :data:`.g` become available.\n\n        A context is automatically pushed when handling each request, and when\n        running any ``flask`` CLI command. Use this as a ``with`` block to\n        manually push a context outside of those situations, such as during\n        setup or testing.\n\n        .. code-block:: python\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "request_context",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "environ",
              "type": "WSGIEnvironment"
            }
          ],
          "return_type": "AppContext",
          "lineno": 1471,
          "decorators": [],
          "is_async": false,
          "calls": [
            "AppContext.from_environ",
            "environ",
            "self"
          ],
          "docstring": "Create an :class:`.AppContext` with request information representing\nthe given WSGI environment. A context is automatically pushed when\nhandling each request. When the context is pushed, :data:`.request`,\n:data:`.session`, :data:`g:, and :data:`.current_app` become available.\n\nThis method should not be used in your own code. Creating a valid WSGI\nenviron is not trivial. Use :meth:`test_request_context` to correctly\ncreate a WSGI environ and request context instead.\n\nSee :doc:`/appcontext`.\n\n:param environ: A WSGI environment.",
          "code": "def request_context(self, environ: WSGIEnvironment) -> AppContext:\n        \"\"\"Create an :class:`.AppContext` with request information representing\n        the given WSGI environment. A context is automatically pushed when\n        handling each request. When the context is pushed, :data:`.request`,\n        :data:`.session`, :data:`g:, and :data:`.current_app` become available.\n\n        This method should not be used in your own code. Creating a valid WSGI\n        environ is not trivial. Use :meth:`test_request_context` to correctly\n        create a WSGI environ and request context instead.\n\n        See :doc:`/appcontext`.\n\n        :param environ: A WSGI environment.\n        \"\"\"\n        return AppContext.from_environ(self, environ)",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "test_request_context",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "AppContext",
          "lineno": 1487,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "kwargs",
            "self.request_context",
            "builder.close",
            "builder.get_environ",
            "environ",
            "EnvironBuilder"
          ],
          "docstring": "Create an :class:`.AppContext` with request information created from\nthe given arguments. When the context is pushed, :data:`.request`,\n:data:`.session`, :data:`g:, and :data:`.current_app` become available.\n\nThis is useful during testing to run a function that uses request data\nwithout dispatching a full request. Use this as a ``with`` block to push\na context.\n\n.. code-block:: python\n\n    with app.test_request_context(...):\n        generate_report()\n\nSee :doc:`/appcontext`.\n\nTakes the same arguments as Werkzeug's\n:class:`~werkzeug.test.EnvironBuilder`, with some defaults from\nthe application. See the linked Werkzeug docs for most of the\navailable arguments. Flask-specific behavior is listed here.\n\n:param path: URL path being requested.\n:param base_url: Base URL where the app is being served, which\n    ``path`` is relative to. If not given, built from\n    :data:`PREFERRED_URL_SCHEME`, ``subdomain``, :data:`SERVER_NAME`,\n    and :data:`APPLICATION_ROOT`.\n:param subdomain: Subdomain name to prepend to :data:`SERVER_NAME`.\n:param url_scheme: Scheme to use instead of\n    :data:`PREFERRED_URL_SCHEME`.\n:param data: The request body text or bytes,or a dict of form data.\n:param json: If given, this is serialized as JSON and passed as\n    ``data``. Also defaults ``content_type`` to\n    ``application/json``.\n:param args: Other positional arguments passed to\n    :class:`~werkzeug.test.EnvironBuilder`.\n:param kwargs: Other keyword arguments passed to\n    :class:`~werkzeug.test.EnvironBuilder`.",
          "code": "def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> AppContext:\n        \"\"\"Create an :class:`.AppContext` with request information created from\n        the given arguments. When the context is pushed, :data:`.request`,\n        :data:`.session`, :data:`g:, and :data:`.current_app` become available.\n\n        This is useful during testing to run a function that uses request data\n        without dispatching a full request. Use this as a ``with`` block to push\n        a context.\n\n        .. code-block:: python\n\n            with app.test_request_context(...):\n                generate_report()\n\n        See :doc:`/appcontext`.\n\n        Takes the same arguments as Werkzeug's\n        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n        the application. See the linked Werkzeug docs for most of the\n        available arguments. Flask-specific behavior is listed here.\n\n        :param path: URL path being requested.\n        :param base_url: Base URL where the app is being served, which\n            ``path`` is relative to. If not given, built from\n            :data:`PREFERRED_URL_SCHEME`, ``subdomain``, :data:`SERVER_NAME`,\n            and :data:`APPLICATION_ROOT`.\n        :param subdomain: Subdomain name to prepend to :data:`SERVER_NAME`.\n        :param url_scheme: Scheme to use instead of\n            :data:`PREFERRED_URL_SCHEME`.\n        :param data: The request body text or bytes,or a dict of form data.\n        :param json: If given, this is serialized as JSON and passed as\n            ``data``. Also defaults ``content_type`` to\n            ``application/json``.\n        :param args: Other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: Other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            environ = builder.get_environ()\n        finally:\n            builder.close()\n\n        return self.request_context(environ)",
          "line_count": 48,
          "needs_llm_summary": true
        },
        {
          "name": "wsgi_app",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "environ",
              "type": "WSGIEnvironment"
            },
            {
              "name": "start_response",
              "type": "StartResponse"
            }
          ],
          "return_type": "cabc.Iterable[bytes]",
          "lineno": 1536,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.handle_exception",
            "ctx.pop",
            "self.should_ignore_error",
            "self.full_dispatch_request",
            "ctx",
            "self.request_context",
            "ctx.push",
            "response",
            "environ",
            "e",
            "error",
            "start_response",
            "sys.exc_info"
          ],
          "docstring": "The actual WSGI application. This is not implemented in\n:meth:`__call__` so that middlewares can be applied without\nlosing a reference to the app object. Instead of doing this::\n\n    app = MyMiddleware(app)\n\nIt's a better idea to do this instead::\n\n    app.wsgi_app = MyMiddleware(app.wsgi_app)\n\nThen you still have the original application object around and\ncan continue to call methods on it.\n\n.. versionchanged:: 0.7\n    Teardown events for the request and app contexts are called\n    even if an unhandled error occurs. Other events may not be\n    called depending on when an error occurs during dispatch.\n\n:param environ: A WSGI environment.\n:param start_response: A callable accepting a status code,\n    a list of headers, and an optional exception context to\n    start the response.",
          "code": "def wsgi_app(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: BaseException | None = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request(ctx)\n            except Exception as e:\n                error = e\n                response = self.handle_exception(ctx, e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](ctx)\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)",
          "line_count": 47,
          "needs_llm_summary": true
        },
        {
          "name": "__call__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "environ",
              "type": "WSGIEnvironment"
            },
            {
              "name": "start_response",
              "type": "StartResponse"
            }
          ],
          "return_type": "cabc.Iterable[bytes]",
          "lineno": 1584,
          "decorators": [],
          "is_async": false,
          "calls": [
            "environ",
            "self.wsgi_app",
            "start_response"
          ],
          "docstring": "The WSGI server calls the Flask application object as the\nWSGI application. This calls :meth:`wsgi_app`, which can be\nwrapped to apply middleware.",
          "code": "def __call__(\n        self, environ: WSGIEnvironment, start_response: StartResponse\n    ) -> cabc.Iterable[bytes]:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)",
          "line_count": 8,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "Flask",
          "methods": [
            "__init_subclass__",
            "__init__",
            "get_send_file_max_age",
            "send_static_file",
            "open_resource",
            "open_instance_resource",
            "create_jinja_environment",
            "create_url_adapter",
            "raise_routing_exception",
            "update_template_context",
            "make_shell_context",
            "run",
            "test_client",
            "test_cli_runner",
            "handle_http_exception",
            "handle_user_exception",
            "handle_exception",
            "log_exception",
            "dispatch_request",
            "full_dispatch_request",
            "finalize_request",
            "make_default_options_response",
            "ensure_sync",
            "async_to_sync",
            "url_for",
            "make_response",
            "preprocess_request",
            "process_response",
            "do_teardown_request",
            "do_teardown_appcontext",
            "app_context",
            "request_context",
            "test_request_context",
            "wsgi_app",
            "__call__"
          ],
          "base_classes": [
            "App"
          ],
          "lineno": 108,
          "docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more.\n\nThe name of the package is used to resolve resources from inside the\npackage or the folder the module is contained in depending on if the\npackage parameter resolves to an actual python package (a folder with\nan :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\nFor more information about resource loading, see :func:`open_resource`.\n\nUsually you create a :class:`Flask` instance in your main module or\nin the :file:`__init__.py` file of your package like this::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n.. admonition:: About the First Parameter\n\n    The idea of the first parameter is to give Flask an idea of what\n    belongs to your application.  This name is used to find resources\n    on the filesystem, can be used by extensions to improve debugging\n    information and a lot more.\n\n    So it's important what you provide there.  If you are using a single\n    module, `__name__` is always the correct value.  If you however are\n    using a package, it's usually recommended to hardcode the name of\n    your package there.\n\n    For example if your application is defined in :file:`yourapplication/app.py`\n    you should create it with one of the two versions below::\n\n        app = Flask('yourapplication')\n        app = Flask(__name__.split('.')[0])\n\n    Why is that?  The application will work even with `__name__`, thanks\n    to how resources are looked up.  However it will make debugging more\n    painful.  Certain extensions can make assumptions based on the\n    import name of your application.  For example the Flask-SQLAlchemy\n    extension will look for the code in your application that triggered\n    an SQL query in debug mode.  If the import name is not properly set\n    up, that debugging information is lost.  (For example it would only\n    pick up SQL queries in `yourapplication.app` and not\n    `yourapplication.views.frontend`)\n\n.. versionadded:: 0.7\n   The `static_url_path`, `static_folder`, and `template_folder`\n   parameters were added.\n\n.. versionadded:: 0.8\n   The `instance_path` and `instance_relative_config` parameters were\n   added.\n\n.. versionadded:: 0.11\n   The `root_path` parameter was added.\n\n.. versionadded:: 1.0\n   The ``host_matching`` and ``static_host`` parameters were added.\n\n.. versionadded:: 1.0\n   The ``subdomain_matching`` parameter was added. Subdomain\n   matching needs to be enabled manually now. Setting\n   :data:`SERVER_NAME` does not implicitly enable it.\n\n:param import_name: the name of the application package\n:param static_url_path: can be used to specify a different path for the\n                        static files on the web.  Defaults to the name\n                        of the `static_folder` folder.\n:param static_folder: The folder with static files that is served at\n    ``static_url_path``. Relative to the application ``root_path``\n    or an absolute path. Defaults to ``'static'``.\n:param static_host: the host to use when adding the static route.\n    Defaults to None. Required when using ``host_matching=True``\n    with a ``static_folder`` configured.\n:param host_matching: set ``url_map.host_matching`` attribute.\n    Defaults to False.\n:param subdomain_matching: consider the subdomain relative to\n    :data:`SERVER_NAME` when matching routes. Defaults to False.\n:param template_folder: the folder that contains the templates that should\n                        be used by the application.  Defaults to\n                        ``'templates'`` folder in the root path of the\n                        application.\n:param instance_path: An alternative instance path for the application.\n                      By default the folder ``'instance'`` next to the\n                      package or module is assumed to be the instance\n                      path.\n:param instance_relative_config: if set to ``True`` relative filenames\n                                 for loading the config are assumed to\n                                 be relative to the instance path instead\n                                 of the application root.\n:param root_path: The path to the root of the application files.\n    This should only be set manually when it can't be detected\n    automatically, such as for namespace packages."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "inspect",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "weakref",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "datetime",
          "name": "timedelta",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "inspect",
          "name": "iscoroutinefunction",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "itertools",
          "name": "chain",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "TracebackType",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "quote",
          "alias": "_url_quote",
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 16,
          "type": "import"
        },
        {
          "module": "werkzeug.datastructures",
          "name": "Headers",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "werkzeug.datastructures",
          "name": "ImmutableDict",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "BadRequestKeyError",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "HTTPException",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "InternalServerError",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "BuildError",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "MapAdapter",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "RequestRedirect",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "RoutingException",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "Rule",
          "alias": null,
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "werkzeug.serving",
          "name": "is_running_from_reloader",
          "alias": null,
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "werkzeug.wrappers",
          "name": "Response",
          "alias": "BaseResponse",
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "werkzeug.wsgi",
          "name": "get_host",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "cli",
          "alias": null,
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "typing",
          "alias": "ft",
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "AppContext",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "_cv_app",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "app_ctx",
          "alias": null,
          "lineno": 35,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "g",
          "alias": null,
          "lineno": 36,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "request",
          "alias": null,
          "lineno": 37,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "session",
          "alias": null,
          "lineno": 38,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_debug_flag",
          "alias": null,
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_flashed_messages",
          "alias": null,
          "lineno": 40,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_load_dotenv",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "send_from_directory",
          "alias": null,
          "lineno": 42,
          "type": "from_import"
        },
        {
          "module": "sansio.app",
          "name": "App",
          "alias": null,
          "lineno": 43,
          "type": "from_import"
        },
        {
          "module": "sessions",
          "name": "SecureCookieSessionInterface",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "sessions",
          "name": "SessionInterface",
          "alias": null,
          "lineno": 45,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "appcontext_tearing_down",
          "alias": null,
          "lineno": 46,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "got_request_exception",
          "alias": null,
          "lineno": 47,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "request_finished",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "request_started",
          "alias": null,
          "lineno": 49,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "request_tearing_down",
          "alias": null,
          "lineno": 50,
          "type": "from_import"
        },
        {
          "module": "templating",
          "name": "Environment",
          "alias": null,
          "lineno": 51,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Request",
          "alias": null,
          "lineno": 52,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Response",
          "alias": null,
          "lineno": 53,
          "type": "from_import"
        },
        {
          "module": "_typeshed.wsgi",
          "name": "StartResponse",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "_typeshed.wsgi",
          "name": "WSGIEnvironment",
          "alias": null,
          "lineno": 57,
          "type": "from_import"
        },
        {
          "module": "testing",
          "name": "FlaskClient",
          "alias": null,
          "lineno": 59,
          "type": "from_import"
        },
        {
          "module": "testing",
          "name": "FlaskCliRunner",
          "alias": null,
          "lineno": 60,
          "type": "from_import"
        },
        {
          "module": "typing",
          "name": "HeadersValue",
          "alias": null,
          "lineno": 61,
          "type": "from_import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 254,
          "type": "import"
        },
        {
          "module": "debughelpers",
          "name": "FormDataRoutingRedirect",
          "alias": null,
          "lineno": 585,
          "type": "from_import"
        },
        {
          "module": "werkzeug.serving",
          "name": "run_simple",
          "alias": null,
          "lineno": 744,
          "type": "from_import"
        },
        {
          "module": "testing",
          "name": "EnvironBuilder",
          "alias": null,
          "lineno": 1525,
          "type": "from_import"
        },
        {
          "module": "testing",
          "name": "FlaskClient",
          "alias": "cls",
          "lineno": 807,
          "type": "from_import"
        },
        {
          "module": "testing",
          "name": "FlaskCliRunner",
          "alias": "cls",
          "lineno": 825,
          "type": "from_import"
        },
        {
          "module": "asgiref.sync",
          "name": "async_to_sync",
          "alias": "asgiref_async_to_sync",
          "lineno": 1082,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "T_shell_context_processor",
          "assigned_to": "t.TypeVar",
          "lineno": 63
        },
        {
          "name": "T_teardown",
          "assigned_to": "t.TypeVar",
          "lineno": 66
        },
        {
          "name": "T_template_filter",
          "assigned_to": "t.TypeVar",
          "lineno": 67
        },
        {
          "name": "T_template_global",
          "assigned_to": "t.TypeVar",
          "lineno": 68
        },
        {
          "name": "T_template_test",
          "assigned_to": "t.TypeVar",
          "lineno": 69
        },
        {
          "name": "F",
          "assigned_to": "t.TypeVar",
          "lineno": 79
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar",
          "ft.TeardownCallable",
          "ft.TemplateFilterCallable",
          "ft.TemplateTestCallable",
          "ft.ShellContextProcessorCallable",
          "ft.TemplateGlobalCallable"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing",
          "collections",
          "functools",
          "warnings",
          "os",
          "datetime",
          "itertools",
          "sys"
        ],
        "third_party": {
          "other": [
            "__future__",
            "inspect",
            "weakref",
            "types",
            "urllib",
            "click",
            "werkzeug",
            "cli",
            "ctx",
            "globals",
            "helpers",
            "sansio",
            "sessions",
            "signals",
            "templating",
            "wrappers",
            "_typeshed",
            "testing",
            "debughelpers",
            "asgiref"
          ]
        },
        "tech_stack": []
      },
      "line_count": 1592
    },
    "src/flask/blueprints.py": {
      "filepath": "../flask/src/flask/blueprints.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "import_name",
              "type": "str"
            },
            {
              "name": "static_folder",
              "type": "Any"
            },
            {
              "name": "static_url_path",
              "type": "Any"
            },
            {
              "name": "template_folder",
              "type": "Any"
            },
            {
              "name": "url_prefix",
              "type": "Any"
            },
            {
              "name": "subdomain",
              "type": "Any"
            },
            {
              "name": "url_defaults",
              "type": "Any"
            },
            {
              "name": "root_path",
              "type": "Any"
            },
            {
              "name": "cli_group",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 19,
          "decorators": [],
          "is_async": false,
          "calls": [
            "url_defaults",
            "root_path",
            "unknown.__init__",
            "static_folder",
            "super",
            "template_folder",
            "import_name",
            "cli_group",
            "self.name",
            "subdomain",
            "static_url_path",
            "AppGroup",
            "name",
            "url_prefix"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore\n    ) -> None:\n        super().__init__(\n            name,\n            import_name,\n            static_folder,\n            static_url_path,\n            template_folder,\n            url_prefix,\n            subdomain,\n            url_defaults,\n            root_path,\n            cli_group,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "get_send_file_max_age",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 55,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "value.total_seconds",
            "value",
            "timedelta",
            "int"
          ],
          "docstring": "Used by :func:`send_file` to determine the ``max_age`` cache\nvalue for a given file path if it wasn't passed.\n\nBy default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\nthe configuration of :data:`~flask.current_app`. This defaults\nto ``None``, which tells the browser to use conditional requests\ninstead of a timed cache, which is usually preferable.\n\nNote this is a duplicate of the same method in the Flask\nclass.\n\n.. versionchanged:: 2.0\n    The default configuration is ``None`` instead of 12 hours.\n\n.. versionadded:: 0.9",
          "code": "def get_send_file_max_age(self, filename: str | None) -> int | None:\n        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n        value for a given file path if it wasn't passed.\n\n        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n        the configuration of :data:`~flask.current_app`. This defaults\n        to ``None``, which tells the browser to use conditional requests\n        instead of a timed cache, which is usually preferable.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionchanged:: 2.0\n            The default configuration is ``None`` instead of 12 hours.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        value = current_app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n\n        if value is None:\n            return None\n\n        if isinstance(value, timedelta):\n            return int(value.total_seconds())\n\n        return value",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "send_static_file",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "str"
            }
          ],
          "return_type": "Response",
          "lineno": 82,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "RuntimeError",
            "max_age",
            "self.get_send_file_max_age",
            "self.static_folder",
            "t.cast",
            "filename",
            "send_from_directory"
          ],
          "docstring": "The view function used to serve files from\n:attr:`static_folder`. A route is automatically registered for\nthis view at :attr:`static_url_path` if :attr:`static_folder` is\nset.\n\nNote this is a duplicate of the same method in the Flask\nclass.\n\n.. versionadded:: 0.5",
          "code": "def send_static_file(self, filename: str) -> Response:\n        \"\"\"The view function used to serve files from\n        :attr:`static_folder`. A route is automatically registered for\n        this view at :attr:`static_url_path` if :attr:`static_folder` is\n        set.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionadded:: 0.5\n\n        \"\"\"\n        if not self.has_static_folder:\n            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n\n        # send_file only knows to call get_send_file_max_age on the app,\n        # call it here so it works for blueprints too.\n        max_age = self.get_send_file_max_age(filename)\n        return send_from_directory(\n            t.cast(str, self.static_folder), filename, max_age=max_age\n        )",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "open_resource",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "resource",
              "type": "str"
            },
            {
              "name": "mode",
              "type": "str"
            },
            {
              "name": "encoding",
              "type": "Any"
            }
          ],
          "return_type": "t.IO[t.AnyStr]",
          "lineno": 104,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.root_path",
            "ValueError",
            "open",
            "mode",
            "os.path.join",
            "encoding",
            "resource",
            "path"
          ],
          "docstring": "Open a resource file relative to :attr:`root_path` for reading. The\nblueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`\nmethod.\n\n:param resource: Path to the resource relative to :attr:`root_path`.\n:param mode: Open the file in this mode. Only reading is supported,\n    valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n:param encoding: Open the file with this encoding when opening in text\n    mode. This is ignored when opening in binary mode.\n\n.. versionchanged:: 3.1\n    Added the ``encoding`` parameter.",
          "code": "def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading. The\n        blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`\n        method.\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)",
          "line_count": 25,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "Blueprint",
          "methods": [
            "__init__",
            "get_send_file_max_age",
            "send_static_file",
            "open_resource"
          ],
          "base_classes": [
            "SansioBlueprint"
          ],
          "lineno": 18,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "datetime",
          "name": "timedelta",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "cli",
          "name": "AppGroup",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "current_app",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "send_from_directory",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "sansio.blueprints",
          "name": "Blueprint",
          "alias": "SansioBlueprint",
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "sansio.blueprints",
          "name": "BlueprintSetupState",
          "alias": "BlueprintSetupState",
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "sansio.scaffold",
          "name": "_sentinel",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Response",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os",
          "datetime",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "cli",
            "globals",
            "helpers",
            "sansio",
            "wrappers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 129
    },
    "src/flask/cli.py": {
      "filepath": "../flask/src/flask/cli.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "find_best_app",
          "args": [
            {
              "name": "module",
              "type": "ModuleType"
            }
          ],
          "return_type": "Flask",
          "lineno": 41,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "matches",
            "module.__dict__.values",
            "attr_name",
            "getattr",
            "_called_with_wrong_args",
            "Flask",
            "len",
            "module",
            "NoAppException",
            "inspect.isfunction",
            "app_factory",
            "app",
            "v"
          ],
          "docstring": "Given a module instance this tries to find the best possible\napplication in the module or raises an exception.",
          "code": "def find_best_app(module: ModuleType) -> Flask:\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in (\"app\", \"application\"):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            \"Detected multiple Flask applications in module\"\n            f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n            \" to specify the correct one.\"\n        )\n\n    # Search for app factory functions.\n    for attr_name in (\"create_app\", \"make_app\"):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = app_factory()\n\n                if isinstance(app, Flask):\n                    return app\n            except TypeError as e:\n                if not _called_with_wrong_args(app_factory):\n                    raise\n\n                raise NoAppException(\n                    f\"Detected factory '{attr_name}' in module '{module.__name__}',\"\n                    \" but could not call it without arguments. Use\"\n                    f\" '{module.__name__}:{attr_name}(args)'\"\n                    \" to specify arguments.\"\n                ) from e\n\n    raise NoAppException(\n        \"Failed to find Flask application or factory in module\"\n        f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n        \" to specify one.\"\n    )",
          "line_count": 51,
          "needs_llm_summary": true
        },
        {
          "name": "_called_with_wrong_args",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[Ellipsis, Flask]"
            }
          ],
          "return_type": "bool",
          "lineno": 94,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tb.tb_next",
            "sys.exc_info"
          ],
          "docstring": "Check whether calling a function raised a ``TypeError`` because\nthe call failed or because something in the factory raised the\nerror.\n\n:param f: The function that was called.\n:return: ``True`` if the call failed.",
          "code": "def _called_with_wrong_args(f: t.Callable[..., Flask]) -> bool:\n    \"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the factory raised the\n    error.\n\n    :param f: The function that was called.\n    :return: ``True`` if the call failed.\n    \"\"\"\n    tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is f.__code__:\n                # In the function, it was called successfully.\n                return False\n\n            tb = tb.tb_next\n\n        # Didn't reach the function.\n        return True\n    finally:\n        # Delete tb to break a circular reference.\n        # https://docs.python.org/2/library/sys.html#sys.exc_info\n        del tb",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "find_app_by_string",
          "args": [
            {
              "name": "module",
              "type": "ModuleType"
            },
            {
              "name": "app_name",
              "type": "str"
            }
          ],
          "return_type": "Flask",
          "lineno": 120,
          "decorators": [],
          "is_async": false,
          "calls": [
            "expr",
            "expr.func",
            "ast.Name",
            "getattr",
            "ast.literal_eval",
            "NoAppException",
            "expr.id",
            "module",
            "arg",
            "unknown.body",
            "inspect.isfunction",
            "name",
            "ast.Call",
            "expr.func.id",
            "app_name.strip",
            "isinstance",
            "ast.parse",
            "attr",
            "kwargs",
            "_called_with_wrong_args",
            "Flask",
            "app",
            "kw.value"
          ],
          "docstring": "Check if the given string is a variable name or a function. Call\na function to get the app instance, or return the variable directly.",
          "code": "def find_app_by_string(module: ModuleType, app_name: str) -> Flask:\n    \"\"\"Check if the given string is a variable name or a function. Call\n    a function to get the app instance, or return the variable directly.\n    \"\"\"\n    from . import Flask\n\n    # Parse app_name as a single expression to determine if it's a valid\n    # attribute name or function call.\n    try:\n        expr = ast.parse(app_name.strip(), mode=\"eval\").body\n    except SyntaxError:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        ) from None\n\n    if isinstance(expr, ast.Name):\n        name = expr.id\n        args = []\n        kwargs = {}\n    elif isinstance(expr, ast.Call):\n        # Ensure the function name is an attribute name only.\n        if not isinstance(expr.func, ast.Name):\n            raise NoAppException(\n                f\"Function reference must be a simple name: {app_name!r}.\"\n            )\n\n        name = expr.func.id\n\n        # Parse the positional and keyword arguments as literals.\n        try:\n            args = [ast.literal_eval(arg) for arg in expr.args]\n            kwargs = {\n                kw.arg: ast.literal_eval(kw.value)\n                for kw in expr.keywords\n                if kw.arg is not None\n            }\n        except ValueError:\n            # literal_eval gives cryptic error messages, show a generic\n            # message with the full expression instead.\n            raise NoAppException(\n                f\"Failed to parse arguments as literal values: {app_name!r}.\"\n            ) from None\n    else:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        )\n\n    try:\n        attr = getattr(module, name)\n    except AttributeError as e:\n        raise NoAppException(\n            f\"Failed to find attribute {name!r} in {module.__name__!r}.\"\n        ) from e\n\n    # If the attribute is a function, call it with any args and kwargs\n    # to get the real application.\n    if inspect.isfunction(attr):\n        try:\n            app = attr(*args, **kwargs)\n        except TypeError as e:\n            if not _called_with_wrong_args(attr):\n                raise\n\n            raise NoAppException(\n                f\"The factory {app_name!r} in module\"\n                f\" {module.__name__!r} could not be called with the\"\n                \" specified arguments.\"\n            ) from e\n    else:\n        app = attr\n\n    if isinstance(app, Flask):\n        return app\n\n    raise NoAppException(\n        \"A valid Flask application was not obtained from\"\n        f\" '{module.__name__}:{app_name}'.\"\n    )",
          "line_count": 78,
          "needs_llm_summary": true
        },
        {
          "name": "prepare_import",
          "args": [
            {
              "name": "path",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 200,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.path.basename",
            "os.path.exists",
            "os.path.splitext",
            "os.path.realpath",
            "os.path.join",
            "os.path.split",
            "os.path.dirname",
            "module_name.append",
            "unknown.join",
            "name",
            "sys.path.insert",
            "path",
            "fname"
          ],
          "docstring": "Given a filename this will try to calculate the python path, add it\nto the search path and return the actual module name that is expected.",
          "code": "def prepare_import(path: str) -> str:\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    path = os.path.realpath(path)\n\n    fname, ext = os.path.splitext(path)\n    if ext == \".py\":\n        path = fname\n\n    if os.path.basename(path) == \"__init__\":\n        path = os.path.dirname(path)\n\n    module_name = []\n\n    # move up until outside package structure (no __init__.py)\n    while True:\n        path, name = os.path.split(path)\n        module_name.append(name)\n\n        if not os.path.exists(os.path.join(path, \"__init__.py\")):\n            break\n\n    if sys.path[0] != path:\n        sys.path.insert(0, path)\n\n    return \".\".join(module_name[::-1])",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "locate_app",
          "args": [
            {
              "name": "module_name",
              "type": "str"
            },
            {
              "name": "app_name",
              "type": "Any"
            },
            {
              "name": "raise_if_not_found",
              "type": "t.Literal[True]"
            }
          ],
          "return_type": "Flask",
          "lineno": 230,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True\n) -> Flask: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "locate_app",
          "args": [
            {
              "name": "module_name",
              "type": "str"
            },
            {
              "name": "app_name",
              "type": "Any"
            },
            {
              "name": "raise_if_not_found",
              "type": "t.Literal[False]"
            }
          ],
          "return_type": "Any",
          "lineno": 236,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[False] = ...\n) -> Flask | None: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "locate_app",
          "args": [
            {
              "name": "module_name",
              "type": "str"
            },
            {
              "name": "app_name",
              "type": "Any"
            },
            {
              "name": "raise_if_not_found",
              "type": "bool"
            }
          ],
          "return_type": "Any",
          "lineno": 241,
          "decorators": [],
          "is_async": false,
          "calls": [
            "find_app_by_string",
            "traceback.format_exc",
            "find_best_app",
            "module",
            "module_name",
            "NoAppException",
            "__import__",
            "app_name",
            "sys.exc_info"
          ],
          "docstring": null,
          "code": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: bool = True\n) -> Flask | None:\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            ) from None\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\") from None\n        else:\n            return None\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(module)\n    else:\n        return find_app_by_string(module, app_name)",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "get_version",
          "args": [
            {
              "name": "ctx",
              "type": "click.Context"
            },
            {
              "name": "param",
              "type": "click.Parameter"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "None",
          "lineno": 267,
          "decorators": [],
          "is_async": false,
          "calls": [
            "click.echo",
            "ctx.exit",
            "importlib.metadata.version",
            "platform.python_version",
            "ctx.color"
          ],
          "docstring": null,
          "code": "def get_version(ctx: click.Context, param: click.Parameter, value: t.Any) -> None:\n    if not value or ctx.resilient_parsing:\n        return\n\n    flask_version = importlib.metadata.version(\"flask\")\n    werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    click.echo(\n        f\"Python {platform.python_version()}\\n\"\n        f\"Flask {flask_version}\\n\"\n        f\"Werkzeug {werkzeug_version}\",\n        color=ctx.color,\n    )\n    ctx.exit()",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "with_appcontext",
          "args": [
            {
              "name": "f",
              "type": "F"
            }
          ],
          "return_type": "F",
          "lineno": 380,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "kwargs",
            "ScriptInfo",
            "app.app_context",
            "unknown.load_app",
            "ctx.invoke",
            "update_wrapper",
            "ctx.ensure_object",
            "ctx.with_resource",
            "decorator"
          ],
          "docstring": "Wraps a callback so that it's guaranteed to be executed with the\nscript's application context.\n\nCustom commands (and their options) registered under ``app.cli`` or\n``blueprint.cli`` will always have an app context available, this\ndecorator is not required in that case.\n\n.. versionchanged:: 2.2\n    The app context is active for subcommands as well as the\n    decorated callback. The app context is always available to\n    ``app.cli`` command and parameter callbacks.",
          "code": "def with_appcontext(f: F) -> F:\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.\n\n    Custom commands (and their options) registered under ``app.cli`` or\n    ``blueprint.cli`` will always have an app context available, this\n    decorator is not required in that case.\n\n    .. versionchanged:: 2.2\n        The app context is active for subcommands as well as the\n        decorated callback. The app context is always available to\n        ``app.cli`` command and parameter callbacks.\n    \"\"\"\n\n    @click.pass_context\n    def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not current_app:\n            app = ctx.ensure_object(ScriptInfo).load_app()\n            ctx.with_resource(app.app_context())\n\n        return ctx.invoke(f, *args, **kwargs)\n\n    return update_wrapper(decorator, f)",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "_set_app",
          "args": [
            {
              "name": "ctx",
              "type": "click.Context"
            },
            {
              "name": "param",
              "type": "click.Option"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 440,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "ctx.ensure_object",
            "ScriptInfo"
          ],
          "docstring": null,
          "code": "def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n    if value is None:\n        return None\n\n    info = ctx.ensure_object(ScriptInfo)\n    info.app_import_path = value\n    return value",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_set_debug",
          "args": [
            {
              "name": "ctx",
              "type": "click.Context"
            },
            {
              "name": "param",
              "type": "click.Option"
            },
            {
              "name": "value",
              "type": "bool"
            }
          ],
          "return_type": "Any",
          "lineno": 468,
          "decorators": [],
          "is_async": false,
          "calls": [
            "param.name",
            "ctx.get_parameter_source"
          ],
          "docstring": null,
          "code": "def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:\n    # If the flag isn't provided, it will default to False. Don't use\n    # that, let debug be set by env in that case.\n    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]\n\n    if source is not None and source in (\n        ParameterSource.DEFAULT,\n        ParameterSource.DEFAULT_MAP,\n    ):\n        return None\n\n    # Set with env var instead of ScriptInfo.load so that it can be\n    # accessed early during a factory function.\n    os.environ[\"FLASK_DEBUG\"] = \"1\" if value else \"0\"\n    return value",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "_env_file_callback",
          "args": [
            {
              "name": "ctx",
              "type": "click.Context"
            },
            {
              "name": "param",
              "type": "click.Option"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 493,
          "decorators": [],
          "is_async": false,
          "calls": [
            "click.BadParameter",
            "ctx",
            "param",
            "value",
            "ctx.obj.load_dotenv_defaults",
            "load_dotenv"
          ],
          "docstring": null,
          "code": "def _env_file_callback(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> str | None:\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        # Only show an error if a value was passed, otherwise we still want to\n        # call load_dotenv and show a message without exiting.\n        if value is not None:\n            raise click.BadParameter(\n                \"python-dotenv must be installed to load an env file.\",\n                ctx=ctx,\n                param=param,\n            ) from None\n\n    # Load if a value was passed, or we want to load default files, or both.\n    if value is not None or ctx.obj.load_dotenv_defaults:\n        load_dotenv(value, load_defaults=ctx.obj.load_dotenv_defaults)\n\n    return value",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "_path_is_ancestor",
          "args": [
            {
              "name": "path",
              "type": "str"
            },
            {
              "name": "other",
              "type": "str"
            }
          ],
          "return_type": "bool",
          "lineno": 691,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.sep",
            "os.path.join",
            "unknown.lstrip",
            "len",
            "path"
          ],
          "docstring": "Take ``other`` and remove the length of ``path`` from it. Then join it\nto ``path``. If it is the original value, ``path`` is an ancestor of\n``other``.",
          "code": "def _path_is_ancestor(path: str, other: str) -> bool:\n    \"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n    to ``path``. If it is the original value, ``path`` is an ancestor of\n    ``other``.\"\"\"\n    return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "load_dotenv",
          "args": [
            {
              "name": "path",
              "type": "Any"
            },
            {
              "name": "load_defaults",
              "type": "bool"
            }
          ],
          "return_type": "bool",
          "lineno": 698,
          "decorators": [],
          "is_async": false,
          "calls": [
            "dotenv.find_dotenv",
            "data.items",
            "data",
            "default_path",
            "value",
            "click.secho",
            "dotenv.dotenv_values",
            "default_name",
            "os.path.isfile",
            "bool",
            "path"
          ],
          "docstring": "Load \"dotenv\" files to set environment variables. A given path takes\nprecedence over ``.env``, which takes precedence over ``.flaskenv``. After\nloading and combining these files, values are only set if the key is not\nalready set in ``os.environ``.\n\nThis is a no-op if `python-dotenv`_ is not installed.\n\n.. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n:param path: Load the file at this location.\n:param load_defaults: Search for and load the default ``.flaskenv`` and\n    ``.env`` files.\n:return: ``True`` if at least one env var was loaded.\n\n.. versionchanged:: 3.1\n    Added the ``load_defaults`` parameter. A given path takes precedence\n    over default files.\n\n.. versionchanged:: 2.0\n    The current directory is not changed to the location of the\n    loaded file.\n\n.. versionchanged:: 2.0\n    When loading the env files, set the default encoding to UTF-8.\n\n.. versionchanged:: 1.1.0\n    Returns ``False`` when python-dotenv is not installed, or when\n    the given path isn't a file.\n\n.. versionadded:: 1.0",
          "code": "def load_dotenv(\n    path: str | os.PathLike[str] | None = None, load_defaults: bool = True\n) -> bool:\n    \"\"\"Load \"dotenv\" files to set environment variables. A given path takes\n    precedence over ``.env``, which takes precedence over ``.flaskenv``. After\n    loading and combining these files, values are only set if the key is not\n    already set in ``os.environ``.\n\n    This is a no-op if `python-dotenv`_ is not installed.\n\n    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n    :param path: Load the file at this location.\n    :param load_defaults: Search for and load the default ``.flaskenv`` and\n        ``.env`` files.\n    :return: ``True`` if at least one env var was loaded.\n\n    .. versionchanged:: 3.1\n        Added the ``load_defaults`` parameter. A given path takes precedence\n        over default files.\n\n    .. versionchanged:: 2.0\n        The current directory is not changed to the location of the\n        loaded file.\n\n    .. versionchanged:: 2.0\n        When loading the env files, set the default encoding to UTF-8.\n\n    .. versionchanged:: 1.1.0\n        Returns ``False`` when python-dotenv is not installed, or when\n        the given path isn't a file.\n\n    .. versionadded:: 1.0\n    \"\"\"\n    try:\n        import dotenv\n    except ImportError:\n        if path or os.path.isfile(\".env\") or os.path.isfile(\".flaskenv\"):\n            click.secho(\n                \" * Tip: There are .env files present. Install python-dotenv\"\n                \" to use them.\",\n                fg=\"yellow\",\n                err=True,\n            )\n\n        return False\n\n    data: dict[str, str | None] = {}\n\n    if load_defaults:\n        for default_name in (\".flaskenv\", \".env\"):\n            if not (default_path := dotenv.find_dotenv(default_name, usecwd=True)):\n                continue\n\n            data |= dotenv.dotenv_values(default_path, encoding=\"utf-8\")\n\n    if path is not None and os.path.isfile(path):\n        data |= dotenv.dotenv_values(path, encoding=\"utf-8\")\n\n    for key, value in data.items():\n        if key in os.environ or value is None:\n            continue\n\n        os.environ[key] = value\n\n    return bool(data)",
          "line_count": 66,
          "needs_llm_summary": true
        },
        {
          "name": "show_server_banner",
          "args": [
            {
              "name": "debug",
              "type": "bool"
            },
            {
              "name": "app_import_path",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 766,
          "decorators": [],
          "is_async": false,
          "calls": [
            "is_running_from_reloader",
            "click.echo"
          ],
          "docstring": "Show extra startup messages the first time the server is run,\nignoring the reloader.",
          "code": "def show_server_banner(debug: bool, app_import_path: str | None) -> None:\n    \"\"\"Show extra startup messages the first time the server is run,\n    ignoring the reloader.\n    \"\"\"\n    if is_running_from_reloader():\n        return\n\n    if app_import_path is not None:\n        click.echo(f\" * Serving Flask app '{app_import_path}'\")\n\n    if debug is not None:\n        click.echo(f\" * Debug mode: {'on' if debug else 'off'}\")",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "_validate_key",
          "args": [
            {
              "name": "ctx",
              "type": "click.Context"
            },
            {
              "name": "param",
              "type": "click.Parameter"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 828,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "cert",
            "click.BadParameter",
            "ctx",
            "ctx.params.get",
            "param",
            "ssl.SSLContext"
          ],
          "docstring": "The ``--key`` option must be specified when ``--cert`` is a file.\nModifies the ``cert`` param to be a ``(cert, key)`` pair if needed.",
          "code": "def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get(\"cert\")\n    is_adhoc = cert == \"adhoc\"\n\n    try:\n        import ssl\n    except ImportError:\n        is_context = False\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n            )\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key\" is not used.',\n                ctx,\n                param,\n            )\n\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n\n        ctx.params[\"cert\"] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter('Required when using \"--cert\".', ctx, param)\n\n    return value",
          "line_count": 37,
          "needs_llm_summary": true
        },
        {
          "name": "run_command",
          "args": [
            {
              "name": "info",
              "type": "ScriptInfo"
            },
            {
              "name": "host",
              "type": "str"
            },
            {
              "name": "port",
              "type": "int"
            },
            {
              "name": "reload",
              "type": "bool"
            },
            {
              "name": "debugger",
              "type": "bool"
            },
            {
              "name": "with_threads",
              "type": "bool"
            },
            {
              "name": "cert",
              "type": "Any"
            },
            {
              "name": "extra_files",
              "type": "Any"
            },
            {
              "name": "exclude_patterns",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 935,
          "decorators": [
            {
              "name": "click.command",
              "args": [
                "run"
              ],
              "kwargs": {
                "short_help": "Run a development server."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--host",
                "-h"
              ],
              "kwargs": {
                "default": "127.0.0.1",
                "help": "The interface to bind to."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--port",
                "-p"
              ],
              "kwargs": {
                "default": 5000,
                "help": "The port to bind to."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--cert"
              ],
              "kwargs": {
                "help": "Specify a certificate file to use HTTPS.",
                "is_eager": true
              }
            },
            {
              "name": "click.option",
              "args": [
                "--key"
              ],
              "kwargs": {
                "expose_value": false,
                "help": "The key file to use when specifying a certificate."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--reload/--no-reload"
              ],
              "kwargs": {
                "default": null,
                "help": "Enable or disable the reloader. By default the reloader is active if debug is enabled."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--debugger/--no-debugger"
              ],
              "kwargs": {
                "default": null,
                "help": "Enable or disable the debugger. By default the debugger is active if debug is enabled."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--with-threads/--without-threads"
              ],
              "kwargs": {
                "default": true,
                "help": "Enable or disable multithreading."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--extra-files"
              ],
              "kwargs": {
                "default": null
              }
            },
            {
              "name": "click.option",
              "args": [
                "--exclude-patterns"
              ],
              "kwargs": {
                "default": null
              }
            },
            {
              "name": "pass_script_info",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "click.option",
            "debugger",
            "port",
            "click.command",
            "show_server_banner",
            "is_running_from_reloader",
            "debug",
            "e",
            "traceback.print_exc",
            "info.load_app",
            "exclude_patterns",
            "run_simple",
            "host",
            "with_threads",
            "CertParamType",
            "extra_files",
            "get_debug_flag",
            "click.Path",
            "cert",
            "SeparatedPathType",
            "reload",
            "info.app_import_path",
            "app",
            "_validate_key"
          ],
          "docstring": "Run a local development server.\n\nThis server is for development purposes only. It does not provide\nthe stability, security, or performance of production WSGI servers.\n\nThe reloader and debugger are enabled by default with the '--debug'\noption.",
          "code": "def run_command(\n    info: ScriptInfo,\n    host: str,\n    port: int,\n    reload: bool,\n    debugger: bool,\n    with_threads: bool,\n    cert: ssl.SSLContext | tuple[str, str | None] | t.Literal[\"adhoc\"] | None,\n    extra_files: list[str] | None,\n    exclude_patterns: list[str] | None,\n) -> None:\n    \"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default with the '--debug'\n    option.\n    \"\"\"\n    try:\n        app: WSGIApplication = info.load_app()  # pyright: ignore\n    except Exception as e:\n        if is_running_from_reloader():\n            # When reloading, print out the error immediately, but raise\n            # it later so the debugger or server can handle it.\n            traceback.print_exc()\n            err = e\n\n            def app(\n                environ: WSGIEnvironment, start_response: StartResponse\n            ) -> cabc.Iterable[bytes]:\n                raise err from None\n\n        else:\n            # When not reloading, raise the error immediately so the\n            # command fails.\n            raise e from None\n\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(debug, info.app_import_path)\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=cert,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )",
          "line_count": 59,
          "needs_llm_summary": true
        },
        {
          "name": "shell_command",
          "args": [],
          "return_type": "None",
          "lineno": 1001,
          "decorators": [
            {
              "name": "click.command",
              "args": [
                "shell"
              ],
              "kwargs": {
                "short_help": "Run a shell in the app context."
              }
            },
            {
              "name": "with_appcontext",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "getattr",
            "interactive_hook",
            "os.path.isfile",
            "banner",
            "click.command",
            "os.environ.get",
            "open",
            "sys",
            "ctx.update",
            "ctx",
            "eval",
            "Completer",
            "code.interact",
            "unknown.complete",
            "startup",
            "readline.set_completer",
            "current_app.make_shell_context",
            "compile",
            "f.read"
          ],
          "docstring": "Run an interactive Python shell in the context of a given\nFlask application.  The application will populate the default\nnamespace of this shell according to its configuration.\n\nThis is useful for executing small snippets of management code\nwithout having to manually configure the application.",
          "code": "def shell_command() -> None:\n    \"\"\"Run an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to its configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configure the application.\n    \"\"\"\n    import code\n\n    banner = (\n        f\"Python {sys.version} on {sys.platform}\\n\"\n        f\"App: {current_app.import_name}\\n\"\n        f\"Instance: {current_app.instance_path}\"\n    )\n    ctx: dict[str, t.Any] = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get(\"PYTHONSTARTUP\")\n    if startup and os.path.isfile(startup):\n        with open(startup) as f:\n            eval(compile(f.read(), startup, \"exec\"), ctx)\n\n    ctx.update(current_app.make_shell_context())\n\n    # Site, customize, or startup script can set a hook to call when\n    # entering interactive mode. The default one sets up readline with\n    # tab and history completion.\n    interactive_hook = getattr(sys, \"__interactivehook__\", None)\n\n    if interactive_hook is not None:\n        try:\n            import readline\n            from rlcompleter import Completer\n        except ImportError:\n            pass\n        else:\n            # rlcompleter uses __main__.__dict__ by default, which is\n            # flask.__main__. Use the shell context instead.\n            readline.set_completer(Completer(ctx).complete)\n\n        interactive_hook()\n\n    code.interact(banner=banner, local=ctx)",
          "line_count": 45,
          "needs_llm_summary": true
        },
        {
          "name": "routes_command",
          "args": [
            {
              "name": "sort",
              "type": "str"
            },
            {
              "name": "all_methods",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 1061,
          "decorators": [
            {
              "name": "click.command",
              "args": [
                "routes"
              ],
              "kwargs": {
                "short_help": "Show the routes for the app."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--sort",
                "-s"
              ],
              "kwargs": {
                "default": "endpoint",
                "help": "Method to sort routes by. 'match' is the order that Flask will match routes when dispatching a request."
              }
            },
            {
              "name": "click.option",
              "args": [
                "--all-methods"
              ],
              "kwargs": {
                "is_flag": true,
                "help": "Show HEAD and OPTIONS methods."
              }
            },
            {
              "name": "with_appcontext",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "row.append",
            "template.format",
            "rows.append",
            "click.option",
            "row",
            "sorts.append",
            "click.Choice",
            "sort",
            "len",
            "unknown.join",
            "list",
            "set",
            "click.command",
            "current_app.url_map.iter_rules",
            "itemgetter",
            "range",
            "any",
            "sorted",
            "sorts.index",
            "enumerate",
            "current_app.url_map.host_matching",
            "headers.append",
            "rows.insert",
            "widths",
            "max",
            "headers",
            "rows.sort",
            "click.echo",
            "rule.rule"
          ],
          "docstring": "Show all registered routes with endpoints and methods.",
          "code": "def routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n    host_matching = current_app.url_map.host_matching\n    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)\n    rows = []\n\n    for rule in rules:\n        row = [\n            rule.endpoint,\n            \", \".join(sorted((rule.methods or set()) - ignored_methods)),\n        ]\n\n        if has_domain:\n            row.append((rule.host if host_matching else rule.subdomain) or \"\")\n\n        row.append(rule.rule)\n        rows.append(row)\n\n    headers = [\"Endpoint\", \"Methods\"]\n    sorts = [\"endpoint\", \"methods\"]\n\n    if has_domain:\n        headers.append(\"Host\" if host_matching else \"Subdomain\")\n        sorts.append(\"domain\")\n\n    headers.append(\"Rule\")\n    sorts.append(\"rule\")\n\n    try:\n        rows.sort(key=itemgetter(sorts.index(sort)))\n    except ValueError:\n        pass\n\n    rows.insert(0, headers)\n    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]\n    rows.insert(1, [\"-\" * w for w in widths])\n    template = \"  \".join(f\"{{{i}:<{w}}}\" for i, w in enumerate(widths))\n\n    for row in rows:\n        click.echo(template.format(*row))",
          "line_count": 47,
          "needs_llm_summary": true
        },
        {
          "name": "main",
          "args": [],
          "return_type": "None",
          "lineno": 1122,
          "decorators": [],
          "is_async": false,
          "calls": [
            "cli.main"
          ],
          "docstring": null,
          "code": "def main() -> None:\n    cli.main()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app_import_path",
              "type": "Any"
            },
            {
              "name": "create_app",
              "type": "Any"
            },
            {
              "name": "set_debug_flag",
              "type": "bool"
            },
            {
              "name": "load_dotenv_defaults",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 305,
          "decorators": [],
          "is_async": false,
          "calls": [
            "set_debug_flag",
            "get_load_dotenv",
            "create_app",
            "app_import_path",
            "load_dotenv_defaults"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        app_import_path: str | None = None,\n        create_app: t.Callable[..., Flask] | None = None,\n        set_debug_flag: bool = True,\n        load_dotenv_defaults: bool = True,\n    ) -> None:\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data: dict[t.Any, t.Any] = {}\n        self.set_debug_flag = set_debug_flag\n\n        self.load_dotenv_defaults = get_load_dotenv(load_dotenv_defaults)\n        \"\"\"Whether default ``.flaskenv`` and ``.env`` files should be loaded.\n\n        ``ScriptInfo`` doesn't load anything, this is for reference when doing\n        the load elsewhere during processing.\n\n        .. versionadded:: 3.1\n        \"\"\"\n\n        self._loaded_app: Flask | None = None",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "load_app",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Flask",
          "lineno": 333,
          "decorators": [],
          "is_async": false,
          "calls": [
            "locate_app",
            "prepare_import",
            "app",
            "self.app_import_path",
            "import_name",
            "re.split",
            "self.create_app",
            "NoAppException",
            "name",
            "get_debug_flag",
            "path"
          ],
          "docstring": "Loads the Flask app (if not yet loaded) and returns it.  Calling\nthis multiple times will just result in the already loaded app to\nbe returned.",
          "code": "def load_app(self) -> Flask:\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        if self._loaded_app is not None:\n            return self._loaded_app\n        app: Flask | None = None\n        if self.create_app is not None:\n            app = self.create_app()\n        else:\n            if self.app_import_path:\n                path, name = (\n                    re.split(r\":(?![\\\\/])\", self.app_import_path, maxsplit=1) + [None]\n                )[:2]\n                import_name = prepare_import(path)\n                app = locate_app(import_name, name)\n            else:\n                for path in (\"wsgi.py\", \"app.py\"):\n                    import_name = prepare_import(path)\n                    app = locate_app(import_name, None, raise_if_not_found=False)\n\n                    if app is not None:\n                        break\n\n        if app is None:\n            raise NoAppException(\n                \"Could not locate a Flask application. Use the\"\n                \" 'flask --app' option, 'FLASK_APP' environment\"\n                \" variable, or a 'wsgi.py' or 'app.py' file in the\"\n                \" current directory.\"\n            )\n\n        if self.set_debug_flag:\n            # Update the app's debug flag through the descriptor so that\n            # other values repopulate as well.\n            app.debug = get_debug_flag()\n\n        self._loaded_app = app\n        return app",
          "line_count": 40,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [],
          "return_type": "t.Any",
          "lineno": 395,
          "decorators": [
            {
              "name": "click.pass_context",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "kwargs",
            "ScriptInfo",
            "app.app_context",
            "unknown.load_app",
            "ctx.invoke",
            "ctx.ensure_object",
            "ctx.with_resource"
          ],
          "docstring": null,
          "code": "def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not current_app:\n            app = ctx.ensure_object(ScriptInfo).load_app()\n            ctx.with_resource(app.app_context())\n\n        return ctx.invoke(f, *args, **kwargs)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "command",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Callable[Any, click.Command]",
          "lineno": 413,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "unknown.command",
            "kwargs",
            "self",
            "super",
            "kwargs.pop",
            "AppGroup",
            "with_appcontext"
          ],
          "docstring": "This works exactly like the method of the same name on a regular\n:class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\nunless it's disabled by passing ``with_appcontext=False``.",
          "code": "def command(  # type: ignore[override]\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop(\"with_appcontext\", True)\n\n        def decorator(f: t.Callable[..., t.Any]) -> click.Command:\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]\n\n        return decorator",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "group",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Callable[Any, click.Group]",
          "lineno": 429,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "super",
            "kwargs.setdefault",
            "unknown.group",
            "AppGroup"
          ],
          "docstring": "This works exactly like the method of the same name on a regular\n:class:`click.Group` but it defaults the group class to\n:class:`AppGroup`.",
          "code": "def group(  # type: ignore[override]\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault(\"cls\", AppGroup)\n        return super().group(*args, **kwargs)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "add_default_commands",
              "type": "bool"
            },
            {
              "name": "create_app",
              "type": "Any"
            },
            {
              "name": "add_version_option",
              "type": "bool"
            },
            {
              "name": "load_dotenv",
              "type": "bool"
            },
            {
              "name": "set_debug_flag",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 563,
          "decorators": [],
          "is_async": false,
          "calls": [
            "set_debug_flag",
            "params",
            "params.extend",
            "self.add_command",
            "list",
            "extra.pop",
            "unknown.__init__",
            "super",
            "unknown.setdefault",
            "load_dotenv",
            "params.append",
            "extra",
            "routes_command",
            "create_app",
            "version_option",
            "shell_command",
            "run_command"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        add_default_commands: bool = True,\n        create_app: t.Callable[..., Flask] | None = None,\n        add_version_option: bool = True,\n        load_dotenv: bool = True,\n        set_debug_flag: bool = True,\n        **extra: t.Any,\n    ) -> None:\n        params: list[click.Parameter] = list(extra.pop(\"params\", None) or ())\n        # Processing is done with option callbacks instead of a group\n        # callback. This allows users to make a custom group callback\n        # without losing the behavior. --env-file must come first so\n        # that it is eagerly evaluated before --app.\n        params.extend((_env_file_option, _app_option, _debug_option))\n\n        if add_version_option:\n            params.append(version_option)\n\n        if \"context_settings\" not in extra:\n            extra[\"context_settings\"] = {}\n\n        extra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"FLASK\")\n\n        super().__init__(params=params, **extra)\n\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n        self.set_debug_flag = set_debug_flag\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False",
          "line_count": 36,
          "needs_llm_summary": true
        },
        {
          "name": "_load_plugin_commands",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 600,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ep.load",
            "self.add_command",
            "ep.name",
            "importlib.metadata.entry_points"
          ],
          "docstring": null,
          "code": "def _load_plugin_commands(self) -> None:\n        if self._loaded_plugin_commands:\n            return\n\n        for ep in importlib.metadata.entry_points(group=\"flask.commands\"):\n            self.add_command(ep.load(), ep.name)\n\n        self._loaded_plugin_commands = True",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "get_command",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "click.Context"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "Any",
          "lineno": 609,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ScriptInfo",
            "app.app_context",
            "e.format_message",
            "ctx",
            "unknown.get_command",
            "self._load_plugin_commands",
            "app.cli.get_command",
            "super",
            "current_app._get_current_object",
            "click.secho",
            "info.load_app",
            "name",
            "ctx.ensure_object",
            "ctx.with_resource"
          ],
          "docstring": null,
          "code": "def get_command(self, ctx: click.Context, name: str) -> click.Command | None:\n        self._load_plugin_commands()\n        # Look up built-in and plugin commands, which should be\n        # available even if the app fails to load.\n        rv = super().get_command(ctx, name)\n\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Look up commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            app = info.load_app()\n        except NoAppException as e:\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n            return None\n\n        # Push an app context for the loaded app unless it is already\n        # active somehow. This makes the context available to parameter\n        # and command callbacks without needing @with_appcontext.\n        if not current_app or current_app._get_current_object() is not app:\n            ctx.with_resource(app.app_context())\n\n        return app.cli.get_command(ctx, name)",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "list_commands",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "click.Context"
            }
          ],
          "return_type": "list[str]",
          "lineno": 636,
          "decorators": [],
          "is_async": false,
          "calls": [
            "set",
            "ScriptInfo",
            "rv.update",
            "e.format_message",
            "ctx",
            "super",
            "self._load_plugin_commands",
            "unknown.list_commands",
            "traceback.format_exc",
            "sorted",
            "click.secho",
            "info.load_app",
            "rv",
            "ctx.ensure_object",
            "unknown.cli.list_commands"
          ],
          "docstring": null,
          "code": "def list_commands(self, ctx: click.Context) -> list[str]:\n        self._load_plugin_commands()\n        # Start with the built-in and plugin commands.\n        rv = set(super().list_commands(ctx))\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Add commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except NoAppException as e:\n            # When an app couldn't be loaded, show the error message\n            # without the traceback.\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n        except Exception:\n            # When any other errors occurred during loading, show the\n            # full traceback.\n            click.secho(f\"{traceback.format_exc()}\\n\", err=True, fg=\"red\")\n\n        return sorted(rv)",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "make_context",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "info_name",
              "type": "Any"
            },
            {
              "name": "args",
              "type": "list[str]"
            },
            {
              "name": "parent",
              "type": "Any"
            }
          ],
          "return_type": "click.Context",
          "lineno": 657,
          "decorators": [],
          "is_async": false,
          "calls": [
            "args",
            "ScriptInfo",
            "info_name",
            "unknown.make_context",
            "super",
            "self.load_dotenv",
            "parent",
            "extra",
            "self.create_app",
            "self.set_debug_flag"
          ],
          "docstring": null,
          "code": "def make_context(\n        self,\n        info_name: str | None,\n        args: list[str],\n        parent: click.Context | None = None,\n        **extra: t.Any,\n    ) -> click.Context:\n        # Set a flag to tell app.run to become a no-op. If app.run was\n        # not in a __name__ == __main__ guard, it would start the server\n        # when importing, blocking whatever command is being called.\n        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n\n        if \"obj\" not in extra and \"obj\" not in self.context_settings:\n            extra[\"obj\"] = ScriptInfo(\n                create_app=self.create_app,\n                set_debug_flag=self.set_debug_flag,\n                load_dotenv_defaults=self.load_dotenv,\n            )\n\n        return super().make_context(info_name, args, parent=parent, **extra)",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "parse_args",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "ctx",
              "type": "click.Context"
            },
            {
              "name": "args",
              "type": "list[str]"
            }
          ],
          "return_type": "list[str]",
          "lineno": 678,
          "decorators": [],
          "is_async": false,
          "calls": [
            "args",
            "_app_option.handle_parse_result",
            "_env_file_option.handle_parse_result",
            "ctx",
            "super",
            "len",
            "self.get_help_option_names",
            "unknown.parse_args"
          ],
          "docstring": null,
          "code": "def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:\n        if (not args and self.no_args_is_help) or (\n            len(args) == 1 and args[0] in self.get_help_option_names(ctx)\n        ):\n            # Attempt to load --env-file and --app early in case they\n            # were given as env vars. Otherwise no_args_is_help will not\n            # see commands from app.cli.\n            _env_file_option.handle_parse_result(ctx, {}, [])\n            _app_option.handle_parse_result(ctx, {}, [])\n\n        return super().parse_args(ctx, args)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 788,
          "decorators": [],
          "is_async": false,
          "calls": [
            "click.Path"
          ],
          "docstring": null,
          "code": "def __init__(self) -> None:\n        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 791,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "unknown.lower",
            "self.path_type",
            "click.BadParameter",
            "ctx",
            "import_string",
            "param",
            "value",
            "obj",
            "click.STRING",
            "ssl.SSLContext"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None\n    ) -> t.Any:\n        try:\n            import ssl\n        except ImportError:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            ) from None\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    ) from None\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise",
          "line_count": 35,
          "needs_llm_summary": true
        },
        {
          "name": "convert",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            },
            {
              "name": "param",
              "type": "Any"
            },
            {
              "name": "ctx",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 873,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super_convert",
            "ctx",
            "super",
            "param",
            "item",
            "self.split_envvar_value",
            "value",
            "unknown.convert"
          ],
          "docstring": null,
          "code": "def convert(\n        self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None\n    ) -> t.Any:\n        items = self.split_envvar_value(value)\n        # can't call no-arg super() inside list comprehension until Python 3.12\n        super_convert = super().convert\n        return [super_convert(item, param, ctx) for item in items]",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "t.Callable[Ellipsis, t.Any]"
            }
          ],
          "return_type": "click.Command",
          "lineno": 422,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "unknown.command",
            "kwargs",
            "self",
            "super",
            "AppGroup",
            "with_appcontext"
          ],
          "docstring": null,
          "code": "def decorator(f: t.Callable[..., t.Any]) -> click.Command:\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return super(AppGroup, self).command(*args, **kwargs)(f)",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "app",
          "args": [
            {
              "name": "environ",
              "type": "WSGIEnvironment"
            },
            {
              "name": "start_response",
              "type": "StartResponse"
            }
          ],
          "return_type": "cabc.Iterable[bytes]",
          "lineno": 963,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def app(\n                environ: WSGIEnvironment, start_response: StartResponse\n            ) -> cabc.Iterable[bytes]:\n                raise err from None",
          "line_count": 4,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "NoAppException",
          "methods": [],
          "base_classes": [
            "click.UsageError"
          ],
          "lineno": 37,
          "docstring": "Raised if an application cannot be found or loaded."
        },
        {
          "name": "ScriptInfo",
          "methods": [
            "__init__",
            "load_app"
          ],
          "base_classes": [],
          "lineno": 293,
          "docstring": "Helper object to deal with Flask applications.  This is usually not\nnecessary to interface with as it's used internally in the dispatching\nto click.  In future versions of Flask this object will most likely play\na bigger role.  Typically it's created automatically by the\n:class:`FlaskGroup` but you can also manually create it and pass it\nonwards as click object.\n\n.. versionchanged:: 3.1\n    Added the ``load_dotenv_defaults`` parameter and attribute."
        },
        {
          "name": "AppGroup",
          "methods": [
            "command",
            "group"
          ],
          "base_classes": [
            "click.Group"
          ],
          "lineno": 405,
          "docstring": "This works similar to a regular click :class:`~click.Group` but it\nchanges the behavior of the :meth:`command` decorator so that it\nautomatically wraps the functions in :func:`with_appcontext`.\n\nNot to be confused with :class:`FlaskGroup`."
        },
        {
          "name": "FlaskGroup",
          "methods": [
            "__init__",
            "_load_plugin_commands",
            "get_command",
            "list_commands",
            "make_context",
            "parse_args"
          ],
          "base_classes": [
            "AppGroup"
          ],
          "lineno": 531,
          "docstring": "Special subclass of the :class:`AppGroup` group that supports\nloading more commands from the configured Flask app.  Normally a\ndeveloper does not have to interface with this class but there are\nsome very advanced use cases for which it makes sense to create an\ninstance of this. see :ref:`custom-scripts`.\n\n:param add_default_commands: if this is True then the default run and\n    shell commands will be added.\n:param add_version_option: adds the ``--version`` option.\n:param create_app: an optional callback that is passed the script info and\n    returns the loaded app.\n:param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n    files to set environment variables. Will also change the working\n    directory to the directory containing the first file found.\n:param set_debug_flag: Set the app's debug flag.\n\n.. versionchanged:: 3.1\n    ``-e path`` takes precedence over default ``.env`` and ``.flaskenv`` files.\n\n.. versionchanged:: 2.2\n    Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.\n\n.. versionchanged:: 2.2\n    An app context is pushed when running ``app.cli`` commands, so\n    ``@with_appcontext`` is no longer required for those commands.\n\n.. versionchanged:: 1.0\n    If installed, python-dotenv will be used to load environment variables\n    from :file:`.env` and :file:`.flaskenv` files."
        },
        {
          "name": "CertParamType",
          "methods": [
            "__init__",
            "convert"
          ],
          "base_classes": [
            "click.ParamType"
          ],
          "lineno": 780,
          "docstring": "Click option type for the ``--cert`` option. Allows either an\nexisting file, the string ``'adhoc'``, or an import for a\n:class:`~ssl.SSLContext` object."
        },
        {
          "name": "SeparatedPathType",
          "methods": [
            "convert"
          ],
          "base_classes": [
            "click.Path"
          ],
          "lineno": 867,
          "docstring": "Click option type that accepts a list of values separated by the\nOS's path separator (``:``, ``;`` on Windows). Each value is\nvalidated as a :class:`click.Path` type."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "ast",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "importlib.metadata",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "inspect",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "platform",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "re",
          "alias": null,
          "lineno": 9,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 10,
          "type": "import"
        },
        {
          "module": "traceback",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 12,
          "type": "import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "operator",
          "name": "itemgetter",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "ModuleType",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "click",
          "alias": null,
          "lineno": 17,
          "type": "import"
        },
        {
          "module": "click.core",
          "name": "ParameterSource",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "werkzeug",
          "name": "run_simple",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "werkzeug.serving",
          "name": "is_running_from_reloader",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "werkzeug.utils",
          "name": "import_string",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "current_app",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_debug_flag",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_load_dotenv",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "ssl",
          "alias": null,
          "lineno": 28,
          "type": "import"
        },
        {
          "module": "_typeshed.wsgi",
          "name": "StartResponse",
          "alias": null,
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "_typeshed.wsgi",
          "name": "WSGIApplication",
          "alias": null,
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "_typeshed.wsgi",
          "name": "WSGIEnvironment",
          "alias": null,
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "app",
          "name": "Flask",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "Flask",
          "alias": null,
          "lineno": 45,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "Flask",
          "alias": null,
          "lineno": 124,
          "type": "from_import"
        },
        {
          "module": "code",
          "alias": null,
          "lineno": 1009,
          "type": "import"
        },
        {
          "module": "dotenv",
          "alias": null,
          "lineno": 497,
          "type": "import"
        },
        {
          "module": "dotenv",
          "alias": null,
          "lineno": 733,
          "type": "import"
        },
        {
          "module": "ssl",
          "alias": null,
          "lineno": 836,
          "type": "import"
        },
        {
          "module": "ssl",
          "alias": null,
          "lineno": 795,
          "type": "import"
        },
        {
          "module": "readline",
          "alias": null,
          "lineno": 1034,
          "type": "import"
        },
        {
          "module": "rlcompleter",
          "name": "Completer",
          "alias": null,
          "lineno": 1035,
          "type": "from_import"
        },
        {
          "module": "cryptography",
          "alias": null,
          "lineno": 810,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "version_option",
          "assigned_to": "click.Option",
          "lineno": 283
        },
        {
          "name": "pass_script_info",
          "assigned_to": "click.make_pass_decorator",
          "lineno": 375
        },
        {
          "name": "F",
          "assigned_to": "t.TypeVar",
          "lineno": 377
        },
        {
          "name": "_app_option",
          "assigned_to": "click.Option",
          "lineno": 453
        },
        {
          "name": "_debug_option",
          "assigned_to": "click.Option",
          "lineno": 485
        },
        {
          "name": "_env_file_option",
          "assigned_to": "click.Option",
          "lineno": 517
        },
        {
          "name": "cli",
          "assigned_to": "FlaskGroup",
          "lineno": 1110
        }
      ],
      "is_entry_point": true,
      "main_block_calls": [
        "main"
      ],
      "module_level_calls": {
        "function_calls": [
          "_env_file_callback",
          "click.Path",
          "_set_app",
          "ScriptInfo",
          "click.make_pass_decorator",
          "t.TypeVar",
          "click.Option",
          "run_command.params.insert",
          "_set_debug",
          "_debug_option",
          "get_version",
          "main",
          "FlaskGroup"
        ],
        "class_instantiations": [
          "FlaskGroup"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "typing",
          "re",
          "collections",
          "functools",
          "os",
          "sys"
        ],
        "third_party": {
          "other": [
            "__future__",
            "ast",
            "importlib",
            "inspect",
            "platform",
            "traceback",
            "operator",
            "types",
            "click",
            "werkzeug",
            "globals",
            "helpers",
            "ssl",
            "_typeshed",
            "app",
            "Flask",
            "code",
            "readline",
            "rlcompleter",
            "cryptography"
          ],
          "config": [
            "dotenv"
          ]
        },
        "tech_stack": [
          "Config"
        ]
      },
      "line_count": 1128
    },
    "src/flask/config.py": {
      "filepath": "../flask/src/flask/config.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "get_converter",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 23,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "get_converter"
          ],
          "docstring": null,
          "code": "def __init__(\n        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None\n    ) -> None:\n        self.__name__ = name\n        self.get_converter = get_converter",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__get__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "None"
            },
            {
              "name": "owner",
              "type": "None"
            }
          ],
          "return_type": "te.Self",
          "lineno": 30,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __get__(self, obj: None, owner: None) -> te.Self: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "__get__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "App"
            },
            {
              "name": "owner",
              "type": "type[App]"
            }
          ],
          "return_type": "T",
          "lineno": 33,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __get__(self, obj: App, owner: type[App]) -> T: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "__get__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "Any"
            },
            {
              "name": "owner",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 35,
          "decorators": [],
          "is_async": false,
          "calls": [
            "rv",
            "self.get_converter"
          ],
          "docstring": null,
          "code": "def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:\n        if obj is None:\n            return self\n\n        rv = obj.config[self.__name__]\n\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n\n        return rv",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "__set__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "App"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "None",
          "lineno": 46,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value"
          ],
          "docstring": null,
          "code": "def __set__(self, obj: App, value: t.Any) -> None:\n        obj.config[self.__name__] = value",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "root_path",
              "type": "Any"
            },
            {
              "name": "defaults",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 94,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "super",
            "root_path"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        root_path: str | os.PathLike[str],\n        defaults: dict[str, t.Any] | None = None,\n    ) -> None:\n        super().__init__(defaults or {})\n        self.root_path = root_path",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "from_envvar",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "variable_name",
              "type": "str"
            },
            {
              "name": "silent",
              "type": "bool"
            }
          ],
          "return_type": "bool",
          "lineno": 102,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.from_pyfile",
            "os.environ.get",
            "silent",
            "RuntimeError",
            "rv",
            "variable_name"
          ],
          "docstring": "Loads a configuration from an environment variable pointing to\na configuration file.  This is basically just a shortcut with nicer\nerror messages for this line of code::\n\n    app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n:param variable_name: name of the environment variable\n:param silent: set to ``True`` if you want silent failure for missing\n               files.\n:return: ``True`` if the file was loaded successfully.",
          "code": "def from_envvar(self, variable_name: str, silent: bool = False) -> bool:\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                f\"The environment variable {variable_name!r} is not set\"\n                \" and as such configuration could not be loaded. Set\"\n                \" this variable and make it point to a configuration\"\n                \" file\"\n            )\n        return self.from_pyfile(rv, silent=silent)",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "from_prefixed_env",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "prefix",
              "type": "str"
            }
          ],
          "return_type": "bool",
          "lineno": 126,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "prefix",
            "key.removeprefix",
            "loads",
            "key.startswith",
            "value",
            "sorted",
            "key.split",
            "os.environ"
          ],
          "docstring": "Load any environment variables that start with ``FLASK_``,\ndropping the prefix from the env key for the config key. Values\nare passed through a loading function to attempt to convert them\nto more specific types than strings.\n\nKeys are loaded in :func:`sorted` order.\n\nThe default loading function attempts to parse values as any\nvalid JSON type, including dicts and lists.\n\nSpecific items in nested dicts can be set by separating the\nkeys with double underscores (``__``). If an intermediate key\ndoesn't exist, it will be initialized to an empty dict.\n\n:param prefix: Load env vars that start with this prefix,\n    separated with an underscore (``_``).\n:param loads: Pass each string value to this function and use\n    the returned value as the config value. If any error is\n    raised it is ignored and the value remains a string. The\n    default is :func:`json.loads`.\n\n.. versionadded:: 2.1",
          "code": "def from_prefixed_env(\n        self, prefix: str = \"FLASK\", *, loads: t.Callable[[str], t.Any] = json.loads\n    ) -> bool:\n        \"\"\"Load any environment variables that start with ``FLASK_``,\n        dropping the prefix from the env key for the config key. Values\n        are passed through a loading function to attempt to convert them\n        to more specific types than strings.\n\n        Keys are loaded in :func:`sorted` order.\n\n        The default loading function attempts to parse values as any\n        valid JSON type, including dicts and lists.\n\n        Specific items in nested dicts can be set by separating the\n        keys with double underscores (``__``). If an intermediate key\n        doesn't exist, it will be initialized to an empty dict.\n\n        :param prefix: Load env vars that start with this prefix,\n            separated with an underscore (``_``).\n        :param loads: Pass each string value to this function and use\n            the returned value as the config value. If any error is\n            raised it is ignored and the value remains a string. The\n            default is :func:`json.loads`.\n\n        .. versionadded:: 2.1\n        \"\"\"\n        prefix = f\"{prefix}_\"\n\n        for key in sorted(os.environ):\n            if not key.startswith(prefix):\n                continue\n\n            value = os.environ[key]\n            key = key.removeprefix(prefix)\n\n            try:\n                value = loads(value)\n            except Exception:\n                # Keep the value as a string if loading failed.\n                pass\n\n            if \"__\" not in key:\n                # A non-nested key, set directly.\n                self[key] = value\n                continue\n\n            # Traverse nested dictionaries with keys separated by \"__\".\n            current = self\n            *parts, tail = key.split(\"__\")\n\n            for part in parts:\n                # If an intermediate dict does not exist, create it.\n                if part not in current:\n                    current[part] = {}\n\n                current = current[part]\n\n            current[tail] = value\n\n        return True",
          "line_count": 60,
          "needs_llm_summary": true
        },
        {
          "name": "from_pyfile",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "Any"
            },
            {
              "name": "silent",
              "type": "bool"
            }
          ],
          "return_type": "bool",
          "lineno": 187,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.root_path",
            "open",
            "d",
            "compile",
            "os.path.join",
            "d.__dict__",
            "types.ModuleType",
            "self.from_object",
            "filename",
            "exec",
            "config_file.read"
          ],
          "docstring": "Updates the values in the config from a Python file.  This function\nbehaves as if the file was imported as module with the\n:meth:`from_object` function.\n\n:param filename: the filename of the config.  This can either be an\n                 absolute filename or a filename relative to the\n                 root path.\n:param silent: set to ``True`` if you want silent failure for missing\n               files.\n:return: ``True`` if the file was loaded successfully.\n\n.. versionadded:: 0.7\n   `silent` parameter.",
          "code": "def from_pyfile(\n        self, filename: str | os.PathLike[str], silent: bool = False\n    ) -> bool:\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType(\"config\")\n        d.__file__ = filename\n        try:\n            with open(filename, mode=\"rb\") as config_file:\n                exec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):\n                return False\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n        self.from_object(d)\n        return True",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "from_object",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 218,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "str",
            "import_string",
            "getattr",
            "obj",
            "dir",
            "key.isupper",
            "key"
          ],
          "docstring": "Updates the values from the given object.  An object can be of one\nof the following two types:\n\n-   a string: in this case the object with that name will be imported\n-   an actual object reference: that object is used directly\n\nObjects are usually either modules or classes. :meth:`from_object`\nloads only the uppercase attributes of the module/class. A ``dict``\nobject will not work with :meth:`from_object` because the keys of a\n``dict`` are not attributes of the ``dict`` class.\n\nExample of module-based configuration::\n\n    app.config.from_object('yourapplication.default_config')\n    from yourapplication import default_config\n    app.config.from_object(default_config)\n\nNothing is done to the object before loading. If the object is a\nclass and has ``@property`` attributes, it needs to be\ninstantiated before being passed to this method.\n\nYou should not use this function to load the actual configuration but\nrather configuration defaults.  The actual config should be loaded\nwith :meth:`from_pyfile` and ideally from a location not within the\npackage because the package might be installed system wide.\n\nSee :ref:`config-dev-prod` for an example of class-based configuration\nusing :meth:`from_object`.\n\n:param obj: an import name or object",
          "code": "def from_object(self, obj: object | str) -> None:\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, str):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)",
          "line_count": 37,
          "needs_llm_summary": true
        },
        {
          "name": "from_file",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "Any"
            },
            {
              "name": "load",
              "type": "t.Callable[Any, t.Mapping[str, t.Any]]"
            },
            {
              "name": "silent",
              "type": "bool"
            },
            {
              "name": "text",
              "type": "bool"
            }
          ],
          "return_type": "bool",
          "lineno": 256,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self.root_path",
            "load",
            "self.from_mapping",
            "open",
            "os.path.join",
            "obj",
            "filename"
          ],
          "docstring": "Update the values in the config from a file that is loaded\nusing the ``load`` parameter. The loaded data is passed to the\n:meth:`from_mapping` method.\n\n.. code-block:: python\n\n    import json\n    app.config.from_file(\"config.json\", load=json.load)\n\n    import tomllib\n    app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n\n:param filename: The path to the data file. This can be an\n    absolute path or relative to the config root path.\n:param load: A callable that takes a file handle and returns a\n    mapping of loaded data from the file.\n:type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n    implements a ``read`` method.\n:param silent: Ignore the file if it doesn't exist.\n:param text: Open the file in text or binary mode.\n:return: ``True`` if the file was loaded successfully.\n\n.. versionchanged:: 2.3\n    The ``text`` parameter was added.\n\n.. versionadded:: 2.0",
          "code": "def from_file(\n        self,\n        filename: str | os.PathLike[str],\n        load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],\n        silent: bool = False,\n        text: bool = True,\n    ) -> bool:\n        \"\"\"Update the values in the config from a file that is loaded\n        using the ``load`` parameter. The loaded data is passed to the\n        :meth:`from_mapping` method.\n\n        .. code-block:: python\n\n            import json\n            app.config.from_file(\"config.json\", load=json.load)\n\n            import tomllib\n            app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n\n        :param filename: The path to the data file. This can be an\n            absolute path or relative to the config root path.\n        :param load: A callable that takes a file handle and returns a\n            mapping of loaded data from the file.\n        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n            implements a ``read`` method.\n        :param silent: Ignore the file if it doesn't exist.\n        :param text: Open the file in text or binary mode.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionchanged:: 2.3\n            The ``text`` parameter was added.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename, \"r\" if text else \"rb\") as f:\n                obj = load(f)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n\n        return self.from_mapping(obj)",
          "line_count": 47,
          "needs_llm_summary": true
        },
        {
          "name": "from_mapping",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "mapping",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 304,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "mappings.items",
            "mapping",
            "value",
            "mappings.update",
            "key.isupper"
          ],
          "docstring": "Updates the config like :meth:`update` ignoring items with\nnon-upper keys.\n\n:return: Always returns ``True``.\n\n.. versionadded:: 0.11",
          "code": "def from_mapping(\n        self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any\n    ) -> bool:\n        \"\"\"Updates the config like :meth:`update` ignoring items with\n        non-upper keys.\n\n        :return: Always returns ``True``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings: dict[str, t.Any] = {}\n        if mapping is not None:\n            mappings.update(mapping)\n        mappings.update(kwargs)\n        for key, value in mappings.items():\n            if key.isupper():\n                self[key] = value\n        return True",
          "line_count": 18,
          "needs_llm_summary": true
        },
        {
          "name": "get_namespace",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "namespace",
              "type": "str"
            },
            {
              "name": "lowercase",
              "type": "bool"
            },
            {
              "name": "trim_namespace",
              "type": "bool"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 323,
          "decorators": [],
          "is_async": false,
          "calls": [
            "k",
            "k.startswith",
            "key.lower",
            "self.items",
            "len",
            "namespace",
            "v"
          ],
          "docstring": "Returns a dictionary containing a subset of configuration options\nthat match the specified namespace/prefix. Example usage::\n\n    app.config['IMAGE_STORE_TYPE'] = 'fs'\n    app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n    app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n    image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\nThe resulting dictionary `image_store_config` would look like::\n\n    {\n        'type': 'fs',\n        'path': '/var/app/images',\n        'base_url': 'http://img.website.com'\n    }\n\nThis is often useful when configuration options map directly to\nkeyword arguments in functions or class constructors.\n\n:param namespace: a configuration namespace\n:param lowercase: a flag indicating if the keys of the resulting\n                  dictionary should be lowercase\n:param trim_namespace: a flag indicating if the keys of the resulting\n                  dictionary should not include the namespace\n\n.. versionadded:: 0.11",
          "code": "def get_namespace(\n        self, namespace: str, lowercase: bool = True, trim_namespace: bool = True\n    ) -> dict[str, t.Any]:\n        \"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '/var/app/images',\n                'base_url': 'http://img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {}\n        for k, v in self.items():\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace) :]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 366,
          "decorators": [],
          "is_async": false,
          "calls": [
            "type",
            "self",
            "dict.__repr__"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {dict.__repr__(self)}>\"",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "ConfigAttribute",
          "methods": [
            "__init__",
            "__get__",
            "__get__",
            "__get__",
            "__set__"
          ],
          "base_classes": [
            "unknown"
          ],
          "lineno": 20,
          "docstring": "Makes an attribute forward to the config"
        },
        {
          "name": "Config",
          "methods": [
            "__init__",
            "from_envvar",
            "from_prefixed_env",
            "from_pyfile",
            "from_object",
            "from_file",
            "from_mapping",
            "get_namespace",
            "__repr__"
          ],
          "base_classes": [
            "dict"
          ],
          "lineno": 50,
          "docstring": "Works exactly like a dict but provides ways to fill it from files\nor special dictionaries.  There are two common patterns to populate the\nconfig.\n\nEither you can fill the config from a config file::\n\n    app.config.from_pyfile('yourconfig.cfg')\n\nOr alternatively you can define the configuration options in the\nmodule that calls :meth:`from_object` or provide an import path to\na module that should be loaded.  It is also possible to tell it to\nuse the same module and with that provide the configuration values\njust before the call::\n\n    DEBUG = True\n    SECRET_KEY = 'development key'\n    app.config.from_object(__name__)\n\nIn both cases (loading from any Python file or loading from modules),\nonly uppercase keys are added to the config.  This makes it possible to use\nlowercase values in the config file for temporary values that are not added\nto the config or to define the config keys in the same file that implements\nthe application.\n\nProbably the most interesting way to load configurations is from an\nenvironment variable pointing to a file::\n\n    app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\nIn this case before launching the application you have to set this\nenvironment variable to the file you want to use.  On Linux and OS X\nuse the export statement::\n\n    export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n\nOn windows use `set` instead.\n\n:param root_path: path to which files are read relative from.  When the\n                  config object is created by the application, this is\n                  the application's :attr:`~flask.Flask.root_path`.\n:param defaults: an optional dictionary of default values"
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "errno",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "json",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "types",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "werkzeug.utils",
          "name": "import_string",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "typing_extensions",
          "alias": "te",
          "lineno": 12,
          "type": "import"
        },
        {
          "module": "sansio.app",
          "name": "App",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "T",
          "assigned_to": "t.TypeVar",
          "lineno": 17
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os",
          "typing",
          "json"
        ],
        "third_party": {
          "other": [
            "__future__",
            "errno",
            "types",
            "werkzeug",
            "typing_extensions",
            "sansio"
          ]
        },
        "tech_stack": []
      },
      "line_count": 368
    },
    "src/flask/ctx.py": {
      "filepath": "../flask/src/flask/ctx.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "after_this_request",
          "args": [
            {
              "name": "f",
              "type": "ft.AfterRequestCallable[t.Any]"
            }
          ],
          "return_type": "ft.AfterRequestCallable[t.Any]",
          "lineno": 117,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_cv_app.get",
            "ctx._after_request_functions.append",
            "f",
            "RuntimeError"
          ],
          "docstring": "Decorate a function to run after the current request. The behavior is the\nsame as :meth:`.Flask.after_request`, except it only applies to the current\nrequest, rather than every request. Therefore, it must be used within a\nrequest context, rather than during setup.\n\n.. code-block:: python\n\n    @app.route(\"/\")\n    def index():\n        @after_this_request\n        def add_header(response):\n            response.headers[\"X-Foo\"] = \"Parachute\"\n            return response\n\n        return \"Hello, World!\"\n\n.. versionadded:: 0.9",
          "code": "def after_this_request(\n    f: ft.AfterRequestCallable[t.Any],\n) -> ft.AfterRequestCallable[t.Any]:\n    \"\"\"Decorate a function to run after the current request. The behavior is the\n    same as :meth:`.Flask.after_request`, except it only applies to the current\n    request, rather than every request. Therefore, it must be used within a\n    request context, rather than during setup.\n\n    .. code-block:: python\n\n        @app.route(\"/\")\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers[\"X-Foo\"] = \"Parachute\"\n                return response\n\n            return \"Hello, World!\"\n\n    .. versionadded:: 0.9\n    \"\"\"\n    ctx = _cv_app.get(None)\n\n    if ctx is None or not ctx.has_request:\n        raise RuntimeError(\n            \"'after_this_request' can only be used when a request\"\n            \" context is active, such as in a view function.\"\n        )\n\n    ctx._after_request_functions.append(f)\n    return f",
          "line_count": 31,
          "needs_llm_summary": true
        },
        {
          "name": "copy_current_request_context",
          "args": [
            {
              "name": "f",
              "type": "F"
            }
          ],
          "return_type": "F",
          "lineno": 153,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "kwargs",
            "ctx.app.ensure_sync",
            "ctx.copy",
            "RuntimeError",
            "_cv_app.get",
            "wrapper",
            "update_wrapper"
          ],
          "docstring": "Decorate a function to run inside the current request context. This can\nbe used when starting a background task, otherwise it will not see the app\nand request objects that were active in the parent.\n\n.. warning::\n\n    Due to the following caveats, it is often safer (and simpler) to pass\n    the data you need when starting the task, rather than using this and\n    relying on the context objects.\n\nIn order to avoid execution switching partially though reading data, either\nread the request body (access ``form``, ``json``, ``data``, etc) before\nstarting the task, or use a lock. This can be an issue when using threading,\nbut shouldn't be an issue when using greenlet/gevent or asyncio.\n\nIf the task will access ``session``, be sure to do so in the parent as well\nso that the ``Vary: cookie`` header will be set. Modifying ``session`` in\nthe task should be avoided, as it may execute after the response cookie has\nalready been written.\n\n.. code-block:: python\n\n    import gevent\n    from flask import copy_current_request_context\n\n    @app.route('/')\n    def index():\n        @copy_current_request_context\n        def do_some_work():\n            # do some work here, it can access flask.request or\n            # flask.session like you would otherwise in the view function.\n            ...\n        gevent.spawn(do_some_work)\n        return 'Regular response'\n\n.. versionadded:: 0.10",
          "code": "def copy_current_request_context(f: F) -> F:\n    \"\"\"Decorate a function to run inside the current request context. This can\n    be used when starting a background task, otherwise it will not see the app\n    and request objects that were active in the parent.\n\n    .. warning::\n\n        Due to the following caveats, it is often safer (and simpler) to pass\n        the data you need when starting the task, rather than using this and\n        relying on the context objects.\n\n    In order to avoid execution switching partially though reading data, either\n    read the request body (access ``form``, ``json``, ``data``, etc) before\n    starting the task, or use a lock. This can be an issue when using threading,\n    but shouldn't be an issue when using greenlet/gevent or asyncio.\n\n    If the task will access ``session``, be sure to do so in the parent as well\n    so that the ``Vary: cookie`` header will be set. Modifying ``session`` in\n    the task should be avoided, as it may execute after the response cookie has\n    already been written.\n\n    .. code-block:: python\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    ctx = _cv_app.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'copy_current_request_context' can only be used when a\"\n            \" request context is active, such as in a view function.\"\n        )\n\n    ctx = ctx.copy()\n\n    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)",
          "line_count": 53,
          "needs_llm_summary": true
        },
        {
          "name": "has_request_context",
          "args": [],
          "return_type": "bool",
          "lineno": 208,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_cv_app.get"
          ],
          "docstring": "Test if an app context is active and if it has request information.\n\n.. code-block:: python\n\n    from flask import has_request_context, request\n\n    if has_request_context():\n        remote_addr = request.remote_addr\n\nIf a request context is active, the :data:`.request` and :data:`.session`\ncontext proxies will available and ``True``, otherwise ``False``. You can\nuse that to test the data you use, rather than using this function.\n\n.. code-block:: python\n\n    from flask import request\n\n    if request:\n        remote_addr = request.remote_addr\n\n.. versionadded:: 0.7",
          "code": "def has_request_context() -> bool:\n    \"\"\"Test if an app context is active and if it has request information.\n\n    .. code-block:: python\n\n        from flask import has_request_context, request\n\n        if has_request_context():\n            remote_addr = request.remote_addr\n\n    If a request context is active, the :data:`.request` and :data:`.session`\n    context proxies will available and ``True``, otherwise ``False``. You can\n    use that to test the data you use, rather than using this function.\n\n    .. code-block:: python\n\n        from flask import request\n\n        if request:\n            remote_addr = request.remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return (ctx := _cv_app.get(None)) is not None and ctx.has_request",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "has_app_context",
          "args": [],
          "return_type": "bool",
          "lineno": 234,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_cv_app.get"
          ],
          "docstring": "Test if an app context is active. Unlike :func:`has_request_context`\nthis can be true outside a request, such as in a CLI command.\n\n.. code-block:: python\n\n    from flask import has_app_context, g\n\n    if has_app_context():\n        g.cached_data = ...\n\nIf an app context is active, the :data:`.g` and :data:`.current_app` context\nproxies will available and ``True``, otherwise ``False``. You can use that\nto test the data you use, rather than using this function.\n\n    from flask import g\n\n    if g:\n        g.cached_data = ...\n\n.. versionadded:: 0.9",
          "code": "def has_app_context() -> bool:\n    \"\"\"Test if an app context is active. Unlike :func:`has_request_context`\n    this can be true outside a request, such as in a CLI command.\n\n    .. code-block:: python\n\n        from flask import has_app_context, g\n\n        if has_app_context():\n            g.cached_data = ...\n\n    If an app context is active, the :data:`.g` and :data:`.current_app` context\n    proxies will available and ``True``, otherwise ``False``. You can use that\n    to test the data you use, rather than using this function.\n\n        from flask import g\n\n        if g:\n            g.cached_data = ...\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 504,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "DeprecationWarning",
            "AttributeError",
            "warnings.warn"
          ],
          "docstring": null,
          "code": "def __getattr__(name: str) -> t.Any:\n    import warnings\n\n    if name == \"RequestContext\":\n        warnings.warn(\n            \"'RequestContext' has merged with 'AppContext', and will be removed\"\n            \" in Flask 4.0. Use 'AppContext' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return AppContext\n\n    raise AttributeError(name)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 52,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "AttributeError"
          ],
          "docstring": null,
          "code": "def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__setattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "None",
          "lineno": 58,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value"
          ],
          "docstring": null,
          "code": "def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__delattr__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 61,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "AttributeError"
          ],
          "docstring": null,
          "code": "def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "get",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "default",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 67,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.__dict__.get",
            "default",
            "name"
          ],
          "docstring": "Get an attribute by name, or a default value. Like\n:meth:`dict.get`.\n\n:param name: Name of attribute to get.\n:param default: Value to return if the attribute is not present.\n\n.. versionadded:: 0.10",
          "code": "def get(self, name: str, default: t.Any | None = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__.get(name, default)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "pop",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "default",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 78,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "default",
            "self.__dict__.pop"
          ],
          "docstring": "Get and remove an attribute by name. Like :meth:`dict.pop`.\n\n:param name: Name of attribute to pop.\n:param default: Value to return if the attribute is not present,\n    instead of raising a ``KeyError``.\n\n.. versionadded:: 0.11",
          "code": "def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:\n        \"\"\"Get and remove an attribute by name. Like :meth:`dict.pop`.\n\n        :param name: Name of attribute to pop.\n        :param default: Value to return if the attribute is not present,\n            instead of raising a ``KeyError``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "setdefault",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "default",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 92,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.__dict__.setdefault",
            "name",
            "default"
          ],
          "docstring": "Get the value of an attribute if it is present, otherwise\nset and return a default value. Like :meth:`dict.setdefault`.\n\n:param name: Name of attribute to get.\n:param default: Value to set and return if the attribute is not\n    present.\n\n.. versionadded:: 0.11",
          "code": "def setdefault(self, name: str, default: t.Any = None) -> t.Any:\n        \"\"\"Get the value of an attribute if it is present, otherwise\n        set and return a default value. Like :meth:`dict.setdefault`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to set and return if the attribute is not\n            present.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.__dict__.setdefault(name, default)",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "__contains__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "item",
              "type": "str"
            }
          ],
          "return_type": "bool",
          "lineno": 104,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __contains__(self, item: str) -> bool:\n        return item in self.__dict__",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__iter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Iterator[str]",
          "lineno": 107,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.__dict__",
            "iter"
          ],
          "docstring": null,
          "code": "def __iter__(self) -> t.Iterator[str]:\n        return iter(self.__dict__)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 110,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_cv_app.get",
            "self",
            "object.__repr__"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        ctx = _cv_app.get(None)\n        if ctx is not None:\n            return f\"<flask.g of '{ctx.app.name}'>\"\n        return object.__repr__(self)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "wrapper",
          "args": [],
          "return_type": "t.Any",
          "lineno": 201,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "kwargs",
            "ctx.app.ensure_sync"
          ],
          "docstring": null,
          "code": "def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "None",
          "lineno": 299,
          "decorators": [],
          "is_async": false,
          "calls": [
            "e",
            "app.app_ctx_globals_class",
            "app",
            "app.create_url_adapter",
            "self._request"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        app: Flask,\n        *,\n        request: Request | None = None,\n        session: SessionMixin | None = None,\n    ) -> None:\n        self.app = app\n        \"\"\"The application represented by this context. Accessed through\n        :data:`.current_app`.\n        \"\"\"\n\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        \"\"\"The global data for this context. Accessed through :data:`.g`.\"\"\"\n\n        self.url_adapter: MapAdapter | None = None\n        \"\"\"The URL adapter bound to the request, or the app if not in a request.\n        May be ``None`` if binding failed.\n        \"\"\"\n\n        self._request: Request | None = request\n        self._session: SessionMixin | None = session\n        self._flashes: list[tuple[str, str]] | None = None\n        self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []\n\n        try:\n            self.url_adapter = app.create_url_adapter(self._request)\n        except HTTPException as e:\n            if self._request is not None:\n                self._request.routing_exception = e\n\n        self._cv_token: contextvars.Token[AppContext] | None = None\n        \"\"\"The previous state to restore when popping.\"\"\"\n\n        self._push_count: int = 0\n        \"\"\"Track nested pushes of this context. Cleanup will only run once the\n        original push has been popped.\n        \"\"\"",
          "line_count": 38,
          "needs_llm_summary": true
        },
        {
          "name": "from_environ",
          "args": [],
          "return_type": "te.Self",
          "lineno": 339,
          "decorators": [
            {
              "name": "classmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "app.json",
            "request",
            "environ",
            "app.request_class",
            "cls",
            "app"
          ],
          "docstring": "Create an app context with request data from the given WSGI environ.\n\n:param app: The application this context represents.\n:param environ: The request data this context represents.",
          "code": "def from_environ(cls, app: Flask, environ: WSGIEnvironment, /) -> te.Self:\n        \"\"\"Create an app context with request data from the given WSGI environ.\n\n        :param app: The application this context represents.\n        :param environ: The request data this context represents.\n        \"\"\"\n        request = app.request_class(environ)\n        request.json_module = app.json\n        return cls(app, request=request)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "has_request",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 350,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "True if this context was created with request data.",
          "code": "def has_request(self) -> bool:\n        \"\"\"True if this context was created with request data.\"\"\"\n        return self._request is not None",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "copy",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "te.Self",
          "lineno": 354,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._session",
            "self.app",
            "self.__class__",
            "self._request"
          ],
          "docstring": "Create a new context with the same data objects as this context. See\n:func:`.copy_current_request_context`.\n\n.. versionchanged:: 1.1\n    The current session data is used instead of reloading the original data.\n\n.. versionadded:: 0.10",
          "code": "def copy(self) -> te.Self:\n        \"\"\"Create a new context with the same data objects as this context. See\n        :func:`.copy_current_request_context`.\n\n        .. versionchanged:: 1.1\n            The current session data is used instead of reloading the original data.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__class__(\n            self.app,\n            request=self._request,\n            session=self._session,\n        )",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "request",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Request",
          "lineno": 370,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "RuntimeError"
          ],
          "docstring": "The request object associated with this context. Accessed through\n:data:`.request`. Only available in request contexts, otherwise raises\n:exc:`RuntimeError`.",
          "code": "def request(self) -> Request:\n        \"\"\"The request object associated with this context. Accessed through\n        :data:`.request`. Only available in request contexts, otherwise raises\n        :exc:`RuntimeError`.\n        \"\"\"\n        if self._request is None:\n            raise RuntimeError(\"There is no request in this context.\")\n\n        return self._request",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "session",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "SessionMixin",
          "lineno": 381,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.app.session_interface",
            "self.request",
            "RuntimeError",
            "self.app",
            "si.open_session",
            "si.make_null_session"
          ],
          "docstring": "The session object associated with this context. Accessed through\n:data:`.session`. Only available in request contexts, otherwise raises\n:exc:`RuntimeError`.",
          "code": "def session(self) -> SessionMixin:\n        \"\"\"The session object associated with this context. Accessed through\n        :data:`.session`. Only available in request contexts, otherwise raises\n        :exc:`RuntimeError`.\n        \"\"\"\n        if self._request is None:\n            raise RuntimeError(\"There is no request in this context.\")\n\n        if self._session is None:\n            si = self.app.session_interface\n            self._session = si.open_session(self.app, self.request)\n\n            if self._session is None:\n                self._session = si.make_null_session(self.app)\n\n        return self._session",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "match_request",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 398,
          "decorators": [],
          "is_async": false,
          "calls": [
            "result",
            "e",
            "self.url_adapter.match"
          ],
          "docstring": "Apply routing to the current request, storing either the matched\nendpoint and args, or a routing exception.",
          "code": "def match_request(self) -> None:\n        \"\"\"Apply routing to the current request, storing either the matched\n        endpoint and args, or a routing exception.\n        \"\"\"\n        try:\n            result = self.url_adapter.match(return_rule=True)  # type: ignore[union-attr]\n        except HTTPException as e:\n            self._request.routing_exception = e  # type: ignore[union-attr]\n        else:\n            self._request.url_rule, self._request.view_args = result",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "push",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 409,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "appcontext_pushed.send",
            "self.match_request",
            "self.app",
            "_cv_app.set",
            "self.app.ensure_sync"
          ],
          "docstring": "Push this context so that it is the active context. If this is a\nrequest context, calls :meth:`match_request` to perform routing with\nthe context active.\n\nTypically, this is not used directly. Instead, use a ``with`` block\nto manage the context.\n\nIn some situations, such as streaming or testing, the context may be\npushed multiple times. It will only trigger matching and signals if it\nis not currently pushed.",
          "code": "def push(self) -> None:\n        \"\"\"Push this context so that it is the active context. If this is a\n        request context, calls :meth:`match_request` to perform routing with\n        the context active.\n\n        Typically, this is not used directly. Instead, use a ``with`` block\n        to manage the context.\n\n        In some situations, such as streaming or testing, the context may be\n        pushed multiple times. It will only trigger matching and signals if it\n        is not currently pushed.\n        \"\"\"\n        self._push_count += 1\n\n        if self._cv_token is not None:\n            return\n\n        self._cv_token = _cv_app.set(self)\n        appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)\n\n        if self._request is not None and self.url_adapter is not None:\n            self.match_request()",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "pop",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 432,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._request.close",
            "self",
            "self.app.do_teardown_appcontext",
            "self._cv_token",
            "self.app.do_teardown_request",
            "exc",
            "RuntimeError",
            "_cv_app.get",
            "self.app",
            "self.app.ensure_sync",
            "appcontext_popped.send",
            "_cv_app.reset"
          ],
          "docstring": "Pop this context so that it is no longer the active context. Then\ncall teardown functions and signals.\n\nTypically, this is not used directly. Instead, use a ``with`` block\nto manage the context.\n\nThis context must currently be the active context, otherwise a\n:exc:`RuntimeError` is raised. In some situations, such as streaming or\ntesting, the context may have been pushed multiple times. It will only\ntrigger cleanup once it has been popped as many times as it was pushed.\nUntil then, it will remain the active context.\n\n:param exc: An unhandled exception that was raised while the context was\n    active. Passed to teardown functions.\n\n.. versionchanged:: 0.9\n    Added the ``exc`` argument.",
          "code": "def pop(self, exc: BaseException | None = None) -> None:\n        \"\"\"Pop this context so that it is no longer the active context. Then\n        call teardown functions and signals.\n\n        Typically, this is not used directly. Instead, use a ``with`` block\n        to manage the context.\n\n        This context must currently be the active context, otherwise a\n        :exc:`RuntimeError` is raised. In some situations, such as streaming or\n        testing, the context may have been pushed multiple times. It will only\n        trigger cleanup once it has been popped as many times as it was pushed.\n        Until then, it will remain the active context.\n\n        :param exc: An unhandled exception that was raised while the context was\n            active. Passed to teardown functions.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        if self._cv_token is None:\n            raise RuntimeError(f\"Cannot pop this context ({self!r}), it is not pushed.\")\n\n        ctx = _cv_app.get(None)\n\n        if ctx is None or self._cv_token is None:\n            raise RuntimeError(\n                f\"Cannot pop this context ({self!r}), there is no active context.\"\n            )\n\n        if ctx is not self:\n            raise RuntimeError(\n                f\"Cannot pop this context ({self!r}), it is not the active\"\n                f\" context ({ctx!r}).\"\n            )\n\n        self._push_count -= 1\n\n        if self._push_count > 0:\n            return\n\n        try:\n            if self._request is not None:\n                self.app.do_teardown_request(self, exc)\n                self._request.close()\n        finally:\n            self.app.do_teardown_appcontext(self, exc)\n            _cv_app.reset(self._cv_token)\n            self._cv_token = None\n            appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)",
          "line_count": 49,
          "needs_llm_summary": true
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "te.Self",
          "lineno": 482,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.push"
          ],
          "docstring": null,
          "code": "def __enter__(self) -> te.Self:\n        self.push()\n        return self",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc_type",
              "type": "Any"
            },
            {
              "name": "exc_value",
              "type": "Any"
            },
            {
              "name": "tb",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 486,
          "decorators": [],
          "is_async": false,
          "calls": [
            "exc_value",
            "self.pop"
          ],
          "docstring": null,
          "code": "def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.pop(exc_value)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 494,
          "decorators": [],
          "is_async": false,
          "calls": [
            "id",
            "self",
            "type"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        if self._request is not None:\n            return (\n                f\"<{type(self).__name__} {id(self)} of {self.app.name},\"\n                f\" {self.request.method} {self.request.url!r}>\"\n            )\n\n        return f\"<{type(self).__name__} {id(self)} of {self.app.name}>\"",
          "line_count": 8,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "_AppCtxGlobals",
          "methods": [
            "__getattr__",
            "__setattr__",
            "__delattr__",
            "get",
            "pop",
            "setdefault",
            "__contains__",
            "__iter__",
            "__repr__"
          ],
          "base_classes": [],
          "lineno": 29,
          "docstring": "A plain object. Used as a namespace for storing data during an\napplication context.\n\nCreating an app context automatically creates this object, which is\nmade available as the :data:`.g` proxy.\n\n.. describe:: 'key' in g\n\n    Check whether an attribute is present.\n\n    .. versionadded:: 0.10\n\n.. describe:: iter(g)\n\n    Return an iterator over the attribute names.\n\n    .. versionadded:: 0.10"
        },
        {
          "name": "AppContext",
          "methods": [
            "__init__",
            "from_environ",
            "has_request",
            "copy",
            "request",
            "session",
            "match_request",
            "push",
            "pop",
            "__enter__",
            "__exit__",
            "__repr__"
          ],
          "base_classes": [],
          "lineno": 259,
          "docstring": "An app context contains information about an app, and about the request\nwhen handling a request. A context is pushed at the beginning of each\nrequest and CLI command, and popped at the end. The context is referred to\nas a \"request context\" if it has request information, and an \"app context\"\nif not.\n\nDo not use this class directly. Use :meth:`.Flask.app_context` to create an\napp context if needed during setup, and :meth:`.Flask.test_request_context`\nto create a request context if needed during tests.\n\nWhen the context is popped, it will evaluate all the teardown functions\nregistered with :meth:`~flask.Flask.teardown_request` (if handling a\nrequest) then :meth:`.Flask.teardown_appcontext`.\n\nWhen using the interactive debugger, the context will be restored so\n``request`` is still accessible. Similarly, the test client can preserve the\ncontext after the request ends. However, teardown functions may already have\nclosed some resources such as database connections, and will run again when\nthe restored context is popped.\n\n:param app: The application this context represents.\n:param request: The request data this context represents.\n:param session: The session data this context represents. If not given,\n    loaded from the request on first access.\n\n.. versionchanged:: 3.2\n    Merged with ``RequestContext``. The ``RequestContext`` alias will be\n    removed in Flask 4.0.\n\n.. versionchanged:: 3.2\n    A combined app and request context is pushed for every request and CLI\n    command, rather than trying to detect if an app context is already\n    pushed.\n\n.. versionchanged:: 3.2\n    The session is loaded the first time it is accessed, rather than when\n    the context is pushed."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "contextvars",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "TracebackType",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "HTTPException",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "MapAdapter",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "typing",
          "alias": "ft",
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "_cv_app",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "appcontext_popped",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "appcontext_pushed",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "typing_extensions",
          "alias": "te",
          "lineno": 17,
          "type": "import"
        },
        {
          "module": "_typeshed.wsgi",
          "name": "WSGIEnvironment",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "app",
          "name": "Flask",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "sessions",
          "name": "SessionMixin",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Request",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 505,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "_sentinel",
          "assigned_to": "object",
          "lineno": 26
        },
        {
          "name": "F",
          "assigned_to": "t.TypeVar",
          "lineno": 150
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar",
          "object"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "warnings",
          "functools",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "contextvars",
            "types",
            "werkzeug",
            "globals",
            "signals",
            "typing_extensions",
            "_typeshed",
            "app",
            "sessions",
            "wrappers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 517
    },
    "src/flask/debughelpers.py": {
      "filepath": "../flask/src/flask/debughelpers.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "attach_enctype_error_multidict",
          "args": [
            {
              "name": "request",
              "type": "Request"
            }
          ],
          "return_type": "None",
          "lineno": 81,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__getitem__",
            "request",
            "unknown.with_traceback",
            "request.files.__class__",
            "super",
            "key",
            "e.__traceback__",
            "DebugFilesKeyError",
            "newcls",
            "oldcls.__module__",
            "oldcls.__name__"
          ],
          "docstring": "Patch ``request.files.__getitem__`` to raise a descriptive error\nabout ``enctype=multipart/form-data``.\n\n:param request: The request to patch.\n:meta private:",
          "code": "def attach_enctype_error_multidict(request: Request) -> None:\n    \"\"\"Patch ``request.files.__getitem__`` to raise a descriptive error\n    about ``enctype=multipart/form-data``.\n\n    :param request: The request to patch.\n    :meta private:\n    \"\"\"\n    oldcls = request.files.__class__\n\n    class newcls(oldcls):  # type: ignore[valid-type, misc]\n        def __getitem__(self, key: str) -> t.Any:\n            try:\n                return super().__getitem__(key)\n            except KeyError as e:\n                if key not in request.form:\n                    raise\n\n                raise DebugFilesKeyError(request, key).with_traceback(\n                    e.__traceback__\n                ) from None\n\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "_dump_loader_info",
          "args": [
            {
              "name": "loader",
              "type": "BaseLoader"
            }
          ],
          "return_type": "t.Iterator[str]",
          "lineno": 107,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "str",
            "all",
            "loader",
            "key.startswith",
            "x",
            "value",
            "loader.__dict__.items",
            "sorted",
            "type"
          ],
          "docstring": null,
          "code": "def _dump_loader_info(loader: BaseLoader) -> t.Iterator[str]:\n    yield f\"class: {type(loader).__module__}.{type(loader).__name__}\"\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith(\"_\"):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, str) for x in value):\n                continue\n            yield f\"{key}:\"\n            for item in value:\n                yield f\"  - {item}\"\n            continue\n        elif not isinstance(value, (str, int, float, bool)):\n            continue\n        yield f\"{key}: {value!r}\"",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "explain_template_loading_attempts",
          "args": [
            {
              "name": "app",
              "type": "App"
            },
            {
              "name": "template",
              "type": "str"
            },
            {
              "name": "attempts",
              "type": "list[tuple[BaseLoader, Scaffold, Any]]"
            }
          ],
          "return_type": "None",
          "lineno": 124,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "ctx.request.blueprint",
            "App",
            "info.append",
            "_dump_loader_info",
            "loader",
            "enumerate",
            "srcobj",
            "info",
            "_cv_app.get",
            "repr",
            "Blueprint",
            "unknown.join",
            "attempts",
            "app.logger.info"
          ],
          "docstring": "This should help developers understand what failed",
          "code": "def explain_template_loading_attempts(\n    app: App,\n    template: str,\n    attempts: list[\n        tuple[\n            BaseLoader,\n            Scaffold,\n            tuple[str, str | None, t.Callable[[], bool] | None] | None,\n        ]\n    ],\n) -> None:\n    \"\"\"This should help developers understand what failed\"\"\"\n    info = [f\"Locating template {template!r}:\"]\n    total_found = 0\n    blueprint = None\n\n    if (ctx := _cv_app.get(None)) is not None and ctx.has_request:\n        blueprint = ctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, App):\n            src_info = f\"application {srcobj.import_name!r}\"\n        elif isinstance(srcobj, Blueprint):\n            src_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f\"{idx + 1:5}: trying loader of {src_info}\")\n\n        for line in _dump_loader_info(loader):\n            info.append(f\"       {line}\")\n\n        if triple is None:\n            detail = \"no match\"\n        else:\n            detail = f\"found ({triple[1] or '<string>'!r})\"\n            total_found += 1\n        info.append(f\"       -> {detail}\")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(\"Error: the template could not be found.\")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(\"Warning: multiple loaders returned a match for the template.\")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            \"  The template was looked up from an endpoint that belongs\"\n            f\" to the blueprint {blueprint!r}.\"\n        )\n        info.append(\"  Maybe you did not place a template in the right folder?\")\n        info.append(\"  See https://flask.palletsprojects.com/blueprints/#templates\")\n\n    app.logger.info(\"\\n\".join(info))",
          "line_count": 56,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request",
              "type": "Request"
            },
            {
              "name": "key",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 28,
          "decorators": [],
          "is_async": false,
          "calls": [
            "x",
            "repr",
            "request.form.getlist",
            "buf",
            "unknown.join",
            "buf.append",
            "key"
          ],
          "docstring": null,
          "code": "def __init__(self, request: Request, key: str) -> None:\n        form_matches = request.form.getlist(key)\n        buf = [\n            f\"You tried to access the file {key!r} in the request.files\"\n            \" dictionary but it does not exist. The mimetype for the\"\n            f\" request is {request.mimetype!r} instead of\"\n            \" 'multipart/form-data' which means that no file contents\"\n            \" were transmitted. To fix this error you should provide\"\n            ' enctype=\"multipart/form-data\" in your form.'\n        ]\n        if form_matches:\n            names = \", \".join(repr(x) for x in form_matches)\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                f\"This was submitted: {names}\"\n            )\n        self.msg = \"\".join(buf)",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "__str__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 46,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def __str__(self) -> str:\n        return self.msg",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "request",
              "type": "Request"
            }
          ],
          "return_type": "None",
          "lineno": 57,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "exc.new_url.partition",
            "unknown.__init__",
            "super",
            "exc",
            "request.routing_exception",
            "buf",
            "unknown.join",
            "RequestRedirect",
            "buf.append"
          ],
          "docstring": null,
          "code": "def __init__(self, request: Request) -> None:\n        exc = request.routing_exception\n        assert isinstance(exc, RequestRedirect)\n        buf = [\n            f\"A request was sent to '{request.url}', but routing issued\"\n            f\" a redirect to the canonical URL '{exc.new_url}'.\"\n        ]\n\n        if f\"{request.base_url}/\" == exc.new_url.partition(\"?\")[0]:\n            buf.append(\n                \" The URL was defined with a trailing slash. Flask\"\n                \" will redirect to the URL with a trailing slash if it\"\n                \" was accessed without one.\"\n            )\n\n        buf.append(\n            \" Send requests to the canonical URL, or use 307 or 308 for\"\n            \" routing redirects. Otherwise, browsers will drop form\"\n            \" data.\\n\\n\"\n            \"This exception is only raised in debug mode.\"\n        )\n        super().__init__(\"\".join(buf))",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "__getitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 91,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__getitem__",
            "request",
            "super",
            "key",
            "e.__traceback__",
            "DebugFilesKeyError",
            "unknown.with_traceback"
          ],
          "docstring": null,
          "code": "def __getitem__(self, key: str) -> t.Any:\n            try:\n                return super().__getitem__(key)\n            except KeyError as e:\n                if key not in request.form:\n                    raise\n\n                raise DebugFilesKeyError(request, key).with_traceback(\n                    e.__traceback__\n                ) from None",
          "line_count": 10,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "UnexpectedUnicodeError",
          "methods": [],
          "base_classes": [
            "AssertionError",
            "UnicodeError"
          ],
          "lineno": 17,
          "docstring": "Raised in places where we want some better error reporting for\nunexpected unicode or binary data."
        },
        {
          "name": "DebugFilesKeyError",
          "methods": [
            "__init__",
            "__str__"
          ],
          "base_classes": [
            "KeyError",
            "AssertionError"
          ],
          "lineno": 23,
          "docstring": "Raised from request.files during debugging.  The idea is that it can\nprovide a better error message than just a generic KeyError/BadRequest."
        },
        {
          "name": "FormDataRoutingRedirect",
          "methods": [
            "__init__"
          ],
          "base_classes": [
            "AssertionError"
          ],
          "lineno": 50,
          "docstring": "This exception is raised in debug mode if a routing redirect\nwould cause the browser to drop the method or body. This happens\nwhen method is not GET, HEAD or OPTIONS and the status code is not\n307 or 308."
        },
        {
          "name": "newcls",
          "methods": [
            "__getitem__"
          ],
          "base_classes": [
            "oldcls"
          ],
          "lineno": 90,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "jinja2.loaders",
          "name": "BaseLoader",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "RequestRedirect",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "blueprints",
          "name": "Blueprint",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "_cv_app",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "sansio.app",
          "name": "App",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "sansio.scaffold",
          "name": "Scaffold",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Request",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "jinja2",
            "werkzeug",
            "blueprints",
            "globals",
            "sansio",
            "wrappers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 180
    },
    "src/flask/globals.py": {
      "filepath": "../flask/src/flask/globals.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "__getattr__",
          "args": [
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 65,
          "decorators": [],
          "is_async": false,
          "calls": [
            "name",
            "DeprecationWarning",
            "AttributeError",
            "warnings.warn"
          ],
          "docstring": null,
          "code": "def __getattr__(name: str) -> t.Any:\n    import warnings\n\n    if name == \"request_ctx\":\n        warnings.warn(\n            \"'request_ctx' has merged with 'app_ctx', and will be removed\"\n            \" in Flask 4.0. Use 'app_ctx' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return app_ctx\n\n    raise AttributeError(name)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "_get_current_object",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "T",
          "lineno": 18,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def _get_current_object(self) -> T: ...",
          "line_count": 1,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "ProxyMixin",
          "methods": [
            "_get_current_object"
          ],
          "base_classes": [
            "unknown"
          ],
          "lineno": 17,
          "docstring": null
        },
        {
          "name": "FlaskProxy",
          "methods": [],
          "base_classes": [
            "unknown",
            "Flask"
          ],
          "lineno": 22,
          "docstring": null
        },
        {
          "name": "AppContextProxy",
          "methods": [],
          "base_classes": [
            "unknown",
            "AppContext"
          ],
          "lineno": 24,
          "docstring": null
        },
        {
          "name": "_AppCtxGlobalsProxy",
          "methods": [],
          "base_classes": [
            "unknown",
            "_AppCtxGlobals"
          ],
          "lineno": 26,
          "docstring": null
        },
        {
          "name": "RequestProxy",
          "methods": [],
          "base_classes": [
            "unknown",
            "Request"
          ],
          "lineno": 28,
          "docstring": null
        },
        {
          "name": "SessionMixinProxy",
          "methods": [],
          "base_classes": [
            "unknown",
            "SessionMixin"
          ],
          "lineno": 30,
          "docstring": null
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "contextvars",
          "name": "ContextVar",
          "alias": null,
          "lineno": 4,
          "type": "from_import"
        },
        {
          "module": "werkzeug.local",
          "name": "LocalProxy",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "app",
          "name": "Flask",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "_AppCtxGlobals",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "AppContext",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "sessions",
          "name": "SessionMixin",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Request",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "warnings",
          "alias": null,
          "lineno": 66,
          "type": "import"
        }
      ],
      "variables": [
        {
          "name": "_no_app_msg",
          "assigned_to": "str",
          "lineno": 33
        },
        {
          "name": "_no_req_msg",
          "assigned_to": "str",
          "lineno": 51
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "_cv_app",
          "_no_app_msg",
          "t.TypeVar",
          "_no_req_msg",
          "ContextVar",
          "LocalProxy"
        ],
        "class_instantiations": [
          "ContextVar",
          "LocalProxy"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "warnings",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "contextvars",
            "werkzeug",
            "app",
            "ctx",
            "sessions",
            "wrappers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 78
    },
    "src/flask/helpers.py": {
      "filepath": "../flask/src/flask/helpers.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "get_debug_flag",
          "args": [],
          "return_type": "bool",
          "lineno": 27,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.environ.get",
            "val.lower",
            "bool"
          ],
          "docstring": "Get whether debug mode should be enabled for the app, indicated by the\n:envvar:`FLASK_DEBUG` environment variable. The default is ``False``.",
          "code": "def get_debug_flag() -> bool:\n    \"\"\"Get whether debug mode should be enabled for the app, indicated by the\n    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.\n    \"\"\"\n    val = os.environ.get(\"FLASK_DEBUG\")\n    return bool(val and val.lower() not in {\"0\", \"false\", \"no\"})",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "get_load_dotenv",
          "args": [
            {
              "name": "default",
              "type": "bool"
            }
          ],
          "return_type": "bool",
          "lineno": 35,
          "decorators": [],
          "is_async": false,
          "calls": [
            "os.environ.get",
            "val.lower"
          ],
          "docstring": "Get whether the user has disabled loading default dotenv files by\nsetting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\nthe files.\n\n:param default: What to return if the env var isn't set.",
          "code": "def get_load_dotenv(default: bool = True) -> bool:\n    \"\"\"Get whether the user has disabled loading default dotenv files by\n    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n    the files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"\n    val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "stream_with_context",
          "args": [
            {
              "name": "generator_or_function",
              "type": "t.Iterator[t.AnyStr]"
            }
          ],
          "return_type": "t.Iterator[t.AnyStr]",
          "lineno": 51,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr],\n) -> t.Iterator[t.AnyStr]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "stream_with_context",
          "args": [
            {
              "name": "generator_or_function",
              "type": "t.Callable[Ellipsis, t.Iterator[t.AnyStr]]"
            }
          ],
          "return_type": "t.Callable[Any, t.Iterator[t.AnyStr]]",
          "lineno": 57,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def stream_with_context(\n    generator_or_function: t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "stream_with_context",
          "args": [
            {
              "name": "generator_or_function",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 62,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "decorator",
            "stream_with_context",
            "gen",
            "generator",
            "hasattr",
            "generator_or_function",
            "RuntimeError",
            "gen.close",
            "_cv_app.get",
            "update_wrapper",
            "next",
            "wrapped_g",
            "iter"
          ],
          "docstring": "Wrap a response generator function so that it runs inside the current\nrequest context. This keeps :data:`.request`, :data:`.session`, and :data:`.g`\navailable, even though at the point the generator runs the request context\nwill typically have ended.\n\nUse it as a decorator on a generator function:\n\n.. code-block:: python\n\n    from flask import stream_with_context, request, Response\n\n    @app.get(\"/stream\")\n    def streamed_response():\n        @stream_with_context\n        def generate():\n            yield \"Hello \"\n            yield request.args[\"name\"]\n            yield \"!\"\n\n        return Response(generate())\n\nOr use it as a wrapper around a created generator:\n\n.. code-block:: python\n\n    from flask import stream_with_context, request, Response\n\n    @app.get(\"/stream\")\n    def streamed_response():\n        def generate():\n            yield \"Hello \"\n            yield request.args[\"name\"]\n            yield \"!\"\n\n        return Response(stream_with_context(generate()))\n\n.. versionadded:: 0.9",
          "code": "def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Wrap a response generator function so that it runs inside the current\n    request context. This keeps :data:`.request`, :data:`.session`, and :data:`.g`\n    available, even though at the point the generator runs the request context\n    will typically have ended.\n\n    Use it as a decorator on a generator function:\n\n    .. code-block:: python\n\n        from flask import stream_with_context, request, Response\n\n        @app.get(\"/stream\")\n        def streamed_response():\n            @stream_with_context\n            def generate():\n                yield \"Hello \"\n                yield request.args[\"name\"]\n                yield \"!\"\n\n            return Response(generate())\n\n    Or use it as a wrapper around a created generator:\n\n    .. code-block:: python\n\n        from flask import stream_with_context, request, Response\n\n        @app.get(\"/stream\")\n        def streamed_response():\n            def generate():\n                yield \"Hello \"\n                yield request.args[\"name\"]\n                yield \"!\"\n\n            return Response(stream_with_context(generate()))\n\n    .. versionadded:: 0.9\n    \"\"\"\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr]:\n        if (ctx := _cv_app.get(None)) is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n\n        with ctx:\n            yield None  # type: ignore[misc]\n\n            try:\n                yield from gen\n            finally:\n                # Clean up in case the user wrapped a WSGI iterator.\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # Execute the generator to the sentinel value. This captures the current\n    # context and pushes it to preserve it. Further iteration will yield from\n    # the original iterator.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g",
          "line_count": 74,
          "needs_llm_summary": true
        },
        {
          "name": "make_response",
          "args": [],
          "return_type": "Response",
          "lineno": 138,
          "decorators": [],
          "is_async": false,
          "calls": [
            "args",
            "current_app.response_class",
            "len",
            "current_app.make_response"
          ],
          "docstring": "Sometimes it is necessary to set additional headers in a view.  Because\nviews do not have to return response objects but can return a value that\nis converted into a response object by Flask itself, it becomes tricky to\nadd headers to it.  This function can be called instead of using a return\nand you will get a response object which you can use to attach headers.\n\nIf view looked like this and you want to add a new header::\n\n    def index():\n        return render_template('index.html', foo=42)\n\nYou can now do something like this::\n\n    def index():\n        response = make_response(render_template('index.html', foo=42))\n        response.headers['X-Parachutes'] = 'parachutes are cool'\n        return response\n\nThis function accepts the very same arguments you can return from a\nview function.  This for example creates a response with a 404 error\ncode::\n\n    response = make_response(render_template('not_found.html'), 404)\n\nThe other use case of this function is to force the return value of a\nview function into a response which is helpful with view\ndecorators::\n\n    response = make_response(view_function())\n    response.headers['X-Parachutes'] = 'parachutes are cool'\n\nInternally this function does the following things:\n\n-   if no arguments are passed, it creates a new response argument\n-   if one argument is passed, :meth:`flask.Flask.make_response`\n    is invoked with it.\n-   if more than one argument is passed, the arguments are passed\n    to the :meth:`flask.Flask.make_response` function as tuple.\n\n.. versionadded:: 0.6",
          "code": "def make_response(*args: t.Any) -> Response:\n    \"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n    views do not have to return response objects but can return a value that\n    is converted into a response object by Flask itself, it becomes tricky to\n    add headers to it.  This function can be called instead of using a return\n    and you will get a response object which you can use to attach headers.\n\n    If view looked like this and you want to add a new header::\n\n        def index():\n            return render_template('index.html', foo=42)\n\n    You can now do something like this::\n\n        def index():\n            response = make_response(render_template('index.html', foo=42))\n            response.headers['X-Parachutes'] = 'parachutes are cool'\n            return response\n\n    This function accepts the very same arguments you can return from a\n    view function.  This for example creates a response with a 404 error\n    code::\n\n        response = make_response(render_template('not_found.html'), 404)\n\n    The other use case of this function is to force the return value of a\n    view function into a response which is helpful with view\n    decorators::\n\n        response = make_response(view_function())\n        response.headers['X-Parachutes'] = 'parachutes are cool'\n\n    Internally this function does the following things:\n\n    -   if no arguments are passed, it creates a new response argument\n    -   if one argument is passed, :meth:`flask.Flask.make_response`\n        is invoked with it.\n    -   if more than one argument is passed, the arguments are passed\n        to the :meth:`flask.Flask.make_response` function as tuple.\n\n    .. versionadded:: 0.6\n    \"\"\"\n    if not args:\n        return current_app.response_class()\n    if len(args) == 1:\n        args = args[0]\n    return current_app.make_response(args)",
          "line_count": 47,
          "needs_llm_summary": true
        },
        {
          "name": "url_for",
          "args": [
            {
              "name": "endpoint",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 187,
          "decorators": [],
          "is_async": false,
          "calls": [
            "current_app.url_for",
            "_anchor",
            "endpoint",
            "_method",
            "values",
            "_external",
            "_scheme"
          ],
          "docstring": "Generate a URL to the given endpoint with the given values.\n\nThis requires an active request or application context, and calls\n:meth:`current_app.url_for() <flask.Flask.url_for>`. See that method\nfor full documentation.\n\n:param endpoint: The endpoint name associated with the URL to\n    generate. If this starts with a ``.``, the current blueprint\n    name (if any) will be used.\n:param _anchor: If given, append this as ``#anchor`` to the URL.\n:param _method: If given, generate the URL associated with this\n    method for the endpoint.\n:param _scheme: If given, the URL will have this scheme if it is\n    external.\n:param _external: If given, prefer the URL to be internal (False) or\n    require it to be external (True). External URLs include the\n    scheme and domain. When not in an active request, URLs are\n    external by default.\n:param values: Values to use for the variable parts of the URL rule.\n    Unknown keys are appended as query string arguments, like\n    ``?a=b&c=d``.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.url_for``, allowing an app to override the\n    behavior.\n\n.. versionchanged:: 0.10\n   The ``_scheme`` parameter was added.\n\n.. versionchanged:: 0.9\n   The ``_anchor`` and ``_method`` parameters were added.\n\n.. versionchanged:: 0.9\n   Calls ``app.handle_url_build_error`` on build errors.",
          "code": "def url_for(\n    endpoint: str,\n    *,\n    _anchor: str | None = None,\n    _method: str | None = None,\n    _scheme: str | None = None,\n    _external: bool | None = None,\n    **values: t.Any,\n) -> str:\n    \"\"\"Generate a URL to the given endpoint with the given values.\n\n    This requires an active request or application context, and calls\n    :meth:`current_app.url_for() <flask.Flask.url_for>`. See that method\n    for full documentation.\n\n    :param endpoint: The endpoint name associated with the URL to\n        generate. If this starts with a ``.``, the current blueprint\n        name (if any) will be used.\n    :param _anchor: If given, append this as ``#anchor`` to the URL.\n    :param _method: If given, generate the URL associated with this\n        method for the endpoint.\n    :param _scheme: If given, the URL will have this scheme if it is\n        external.\n    :param _external: If given, prefer the URL to be internal (False) or\n        require it to be external (True). External URLs include the\n        scheme and domain. When not in an active request, URLs are\n        external by default.\n    :param values: Values to use for the variable parts of the URL rule.\n        Unknown keys are appended as query string arguments, like\n        ``?a=b&c=d``.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.url_for``, allowing an app to override the\n        behavior.\n\n    .. versionchanged:: 0.10\n       The ``_scheme`` parameter was added.\n\n    .. versionchanged:: 0.9\n       The ``_anchor`` and ``_method`` parameters were added.\n\n    .. versionchanged:: 0.9\n       Calls ``app.handle_url_build_error`` on build errors.\n    \"\"\"\n    return current_app.url_for(\n        endpoint,\n        _anchor=_anchor,\n        _method=_method,\n        _scheme=_scheme,\n        _external=_external,\n        **values,\n    )",
          "line_count": 52,
          "needs_llm_summary": true
        },
        {
          "name": "redirect",
          "args": [
            {
              "name": "location",
              "type": "str"
            },
            {
              "name": "code",
              "type": "int"
            },
            {
              "name": "Response",
              "type": "Any"
            }
          ],
          "return_type": "BaseResponse",
          "lineno": 241,
          "decorators": [],
          "is_async": false,
          "calls": [
            "Response",
            "code",
            "ctx.app.redirect",
            "_wz_redirect",
            "_cv_app.get",
            "location"
          ],
          "docstring": "Create a redirect response object.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`~flask.Flask.redirect` method, otherwise it will use\n:func:`werkzeug.utils.redirect`.\n\n:param location: The URL to redirect to.\n:param code: The status code for the redirect.\n:param Response: The response class to use. Not used when\n    ``current_app`` is active, which uses ``app.response_class``.\n\n.. versionadded:: 2.2\n    Calls ``current_app.redirect`` if available instead of always\n    using Werkzeug's default ``redirect``.",
          "code": "def redirect(\n    location: str, code: int = 302, Response: type[BaseResponse] | None = None\n) -> BaseResponse:\n    \"\"\"Create a redirect response object.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`~flask.Flask.redirect` method, otherwise it will use\n    :func:`werkzeug.utils.redirect`.\n\n    :param location: The URL to redirect to.\n    :param code: The status code for the redirect.\n    :param Response: The response class to use. Not used when\n        ``current_app`` is active, which uses ``app.response_class``.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.redirect`` if available instead of always\n        using Werkzeug's default ``redirect``.\n    \"\"\"\n    if (ctx := _cv_app.get(None)) is not None:\n        return ctx.app.redirect(location, code=code)\n\n    return _wz_redirect(location, code=code, Response=Response)",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "abort",
          "args": [
            {
              "name": "code",
              "type": "Any"
            }
          ],
          "return_type": "t.NoReturn",
          "lineno": 265,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "_wz_abort",
            "code",
            "ctx.app.aborter",
            "_cv_app.get"
          ],
          "docstring": "Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\nstatus code.\n\nIf :data:`~flask.current_app` is available, it will call its\n:attr:`~flask.Flask.aborter` object, otherwise it will use\n:func:`werkzeug.exceptions.abort`.\n\n:param code: The status code for the exception, which must be\n    registered in ``app.aborter``.\n:param args: Passed to the exception.\n:param kwargs: Passed to the exception.\n\n.. versionadded:: 2.2\n    Calls ``current_app.aborter`` if available instead of always\n    using Werkzeug's default ``abort``.",
          "code": "def abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n    \"\"\"Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\n    status code.\n\n    If :data:`~flask.current_app` is available, it will call its\n    :attr:`~flask.Flask.aborter` object, otherwise it will use\n    :func:`werkzeug.exceptions.abort`.\n\n    :param code: The status code for the exception, which must be\n        registered in ``app.aborter``.\n    :param args: Passed to the exception.\n    :param kwargs: Passed to the exception.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.aborter`` if available instead of always\n        using Werkzeug's default ``abort``.\n    \"\"\"\n    if (ctx := _cv_app.get(None)) is not None:\n        ctx.app.aborter(code, *args, **kwargs)\n\n    _wz_abort(code, *args, **kwargs)",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "get_template_attribute",
          "args": [
            {
              "name": "template_name",
              "type": "str"
            },
            {
              "name": "attribute",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 288,
          "decorators": [],
          "is_async": false,
          "calls": [
            "attribute",
            "template_name",
            "getattr",
            "unknown.module",
            "current_app.jinja_env.get_template"
          ],
          "docstring": "Loads a macro (or variable) a template exports.  This can be used to\ninvoke a macro from within Python code.  If you for example have a\ntemplate named :file:`_cider.html` with the following contents:\n\n.. sourcecode:: html+jinja\n\n   {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n\nYou can access this from Python code like this::\n\n    hello = get_template_attribute('_cider.html', 'hello')\n    return hello('World')\n\n.. versionadded:: 0.2\n\n:param template_name: the name of the template\n:param attribute: the name of the variable of macro to access",
          "code": "def get_template_attribute(template_name: str, attribute: str) -> t.Any:\n    \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n    invoke a macro from within Python code.  If you for example have a\n    template named :file:`_cider.html` with the following contents:\n\n    .. sourcecode:: html+jinja\n\n       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n\n    You can access this from Python code like this::\n\n        hello = get_template_attribute('_cider.html', 'hello')\n        return hello('World')\n\n    .. versionadded:: 0.2\n\n    :param template_name: the name of the template\n    :param attribute: the name of the variable of macro to access\n    \"\"\"\n    return getattr(current_app.jinja_env.get_template(template_name).module, attribute)",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "flash",
          "args": [
            {
              "name": "message",
              "type": "str"
            },
            {
              "name": "category",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 310,
          "decorators": [],
          "is_async": false,
          "calls": [
            "message",
            "category",
            "app.ensure_sync",
            "message_flashed.send",
            "current_app._get_current_object",
            "session.get",
            "flashes",
            "app",
            "flashes.append"
          ],
          "docstring": "Flashes a message to the next request.  In order to remove the\nflashed message from the session and to display it to the user,\nthe template has to call :func:`get_flashed_messages`.\n\n.. versionchanged:: 0.3\n   `category` parameter added.\n\n:param message: the message to be flashed.\n:param category: the category for the message.  The following values\n                 are recommended: ``'message'`` for any kind of message,\n                 ``'error'`` for errors, ``'info'`` for information\n                 messages and ``'warning'`` for warnings.  However any\n                 kind of string can be used as category.",
          "code": "def flash(message: str, category: str = \"message\") -> None:\n    \"\"\"Flashes a message to the next request.  In order to remove the\n    flashed message from the session and to display it to the user,\n    the template has to call :func:`get_flashed_messages`.\n\n    .. versionchanged:: 0.3\n       `category` parameter added.\n\n    :param message: the message to be flashed.\n    :param category: the category for the message.  The following values\n                     are recommended: ``'message'`` for any kind of message,\n                     ``'error'`` for errors, ``'info'`` for information\n                     messages and ``'warning'`` for warnings.  However any\n                     kind of string can be used as category.\n    \"\"\"\n    # Original implementation:\n    #\n    #     session.setdefault('_flashes', []).append((category, message))\n    #\n    # This assumed that changes made to mutable structures in the session are\n    # always in sync with the session object, which is not true for session\n    # implementations that use external storage for keeping their keys/values.\n    flashes = session.get(\"_flashes\", [])\n    flashes.append((category, message))\n    session[\"_flashes\"] = flashes\n    app = current_app._get_current_object()\n    message_flashed.send(\n        app,\n        _async_wrapper=app.ensure_sync,\n        message=message,\n        category=category,\n    )",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "get_flashed_messages",
          "args": [
            {
              "name": "with_categories",
              "type": "bool"
            },
            {
              "name": "category_filter",
              "type": "t.Iterable[str]"
            }
          ],
          "return_type": "Any",
          "lineno": 344,
          "decorators": [],
          "is_async": false,
          "calls": [
            "filter",
            "flashes",
            "app_ctx._flashes",
            "list",
            "session.pop"
          ],
          "docstring": "Pulls all flashed messages from the session and returns them.\nFurther calls in the same request to the function will return\nthe same messages.  By default just the messages are returned,\nbut when `with_categories` is set to ``True``, the return value will\nbe a list of tuples in the form ``(category, message)`` instead.\n\nFilter the flashed messages to one or more categories by providing those\ncategories in `category_filter`.  This allows rendering categories in\nseparate html blocks.  The `with_categories` and `category_filter`\narguments are distinct:\n\n* `with_categories` controls whether categories are returned with message\n  text (``True`` gives a tuple, where ``False`` gives just the message text).\n* `category_filter` filters the messages down to only those matching the\n  provided categories.\n\nSee :doc:`/patterns/flashing` for examples.\n\n.. versionchanged:: 0.3\n   `with_categories` parameter added.\n\n.. versionchanged:: 0.9\n    `category_filter` parameter added.\n\n:param with_categories: set to ``True`` to also receive categories.\n:param category_filter: filter of categories to limit return values.  Only\n                        categories in the list will be returned.",
          "code": "def get_flashed_messages(\n    with_categories: bool = False, category_filter: t.Iterable[str] = ()\n) -> list[str] | list[tuple[str, str]]:\n    \"\"\"Pulls all flashed messages from the session and returns them.\n    Further calls in the same request to the function will return\n    the same messages.  By default just the messages are returned,\n    but when `with_categories` is set to ``True``, the return value will\n    be a list of tuples in the form ``(category, message)`` instead.\n\n    Filter the flashed messages to one or more categories by providing those\n    categories in `category_filter`.  This allows rendering categories in\n    separate html blocks.  The `with_categories` and `category_filter`\n    arguments are distinct:\n\n    * `with_categories` controls whether categories are returned with message\n      text (``True`` gives a tuple, where ``False`` gives just the message text).\n    * `category_filter` filters the messages down to only those matching the\n      provided categories.\n\n    See :doc:`/patterns/flashing` for examples.\n\n    .. versionchanged:: 0.3\n       `with_categories` parameter added.\n\n    .. versionchanged:: 0.9\n        `category_filter` parameter added.\n\n    :param with_categories: set to ``True`` to also receive categories.\n    :param category_filter: filter of categories to limit return values.  Only\n                            categories in the list will be returned.\n    \"\"\"\n    flashes = app_ctx._flashes\n    if flashes is None:\n        flashes = session.pop(\"_flashes\") if \"_flashes\" in session else []\n        app_ctx._flashes = flashes\n    if category_filter:\n        flashes = list(filter(lambda f: f[0] in category_filter, flashes))\n    if not with_categories:\n        return [x[1] for x in flashes]\n    return flashes",
          "line_count": 40,
          "needs_llm_summary": true
        },
        {
          "name": "_prepare_send_file_kwargs",
          "args": [],
          "return_type": "dict[str, t.Any]",
          "lineno": 386,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs.get",
            "kwargs.update",
            "app_ctx._get_current_object",
            "ctx.app.get_send_file_max_age",
            "ctx.app.response_class",
            "ctx.request.environ",
            "ctx.app.root_path"
          ],
          "docstring": null,
          "code": "def _prepare_send_file_kwargs(**kwargs: t.Any) -> dict[str, t.Any]:\n    ctx = app_ctx._get_current_object()\n\n    if kwargs.get(\"max_age\") is None:\n        kwargs[\"max_age\"] = ctx.app.get_send_file_max_age\n\n    kwargs.update(\n        environ=ctx.request.environ,\n        use_x_sendfile=ctx.app.config[\"USE_X_SENDFILE\"],\n        response_class=ctx.app.response_class,\n        _root_path=ctx.app.root_path,\n    )\n    return kwargs",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "send_file",
          "args": [
            {
              "name": "path_or_file",
              "type": "Any"
            },
            {
              "name": "mimetype",
              "type": "Any"
            },
            {
              "name": "as_attachment",
              "type": "bool"
            },
            {
              "name": "download_name",
              "type": "Any"
            },
            {
              "name": "conditional",
              "type": "bool"
            },
            {
              "name": "etag",
              "type": "Any"
            },
            {
              "name": "last_modified",
              "type": "Any"
            },
            {
              "name": "max_age",
              "type": "Any"
            }
          ],
          "return_type": "Response",
          "lineno": 401,
          "decorators": [],
          "is_async": false,
          "calls": [
            "last_modified",
            "download_name",
            "max_age",
            "conditional",
            "as_attachment",
            "werkzeug.utils.send_file",
            "path_or_file",
            "request.environ",
            "_prepare_send_file_kwargs",
            "mimetype",
            "etag"
          ],
          "docstring": "Send the contents of a file to the client.\n\nThe first argument can be a file path or a file-like object. Paths\nare preferred in most cases because Werkzeug can manage the file and\nget extra information from the path. Passing a file-like object\nrequires that the file is opened in binary mode, and is mostly\nuseful when building a file in memory with :class:`io.BytesIO`.\n\nNever pass file paths provided by a user. The path is assumed to be\ntrusted, so a user could craft a path to access a file you didn't\nintend. Use :func:`send_from_directory` to safely serve\nuser-requested paths from within a directory.\n\nIf the WSGI server sets a ``file_wrapper`` in ``environ``, it is\nused, otherwise Werkzeug's built-in wrapper is used. Alternatively,\nif the HTTP server supports ``X-Sendfile``, configuring Flask with\n``USE_X_SENDFILE = True`` will tell the server to send the given\npath, which is much more efficient than reading it in Python.\n\n:param path_or_file: The path to the file to send, relative to the\n    current working directory if a relative path is given.\n    Alternatively, a file-like object opened in binary mode. Make\n    sure the file pointer is seeked to the start of the data.\n:param mimetype: The MIME type to send for the file. If not\n    provided, it will try to detect it from the file name.\n:param as_attachment: Indicate to a browser that it should offer to\n    save the file instead of displaying it.\n:param download_name: The default name browsers will use when saving\n    the file. Defaults to the passed file name.\n:param conditional: Enable conditional and range responses based on\n    request headers. Requires passing a file path and ``environ``.\n:param etag: Calculate an ETag for the file, which requires passing\n    a file path. Can also be a string to use instead.\n:param last_modified: The last modified time to send for the file,\n    in seconds. If not provided, it will try to detect it from the\n    file path.\n:param max_age: How long the client should cache the file, in\n    seconds. If set, ``Cache-Control`` will be ``public``, otherwise\n    it will be ``no-cache`` to prefer conditional caching.\n\n.. versionchanged:: 2.0\n    ``download_name`` replaces the ``attachment_filename``\n    parameter. If ``as_attachment=False``, it is passed with\n    ``Content-Disposition: inline`` instead.\n\n.. versionchanged:: 2.0\n    ``max_age`` replaces the ``cache_timeout`` parameter.\n    ``conditional`` is enabled and ``max_age`` is not set by\n    default.\n\n.. versionchanged:: 2.0\n    ``etag`` replaces the ``add_etags`` parameter. It can be a\n    string to use instead of generating one.\n\n.. versionchanged:: 2.0\n    Passing a file-like object that inherits from\n    :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n    than sending an empty file.\n\n.. versionadded:: 2.0\n    Moved the implementation to Werkzeug. This is now a wrapper to\n    pass some Flask-specific arguments.\n\n.. versionchanged:: 1.1\n    ``filename`` may be a :class:`~os.PathLike` object.\n\n.. versionchanged:: 1.1\n    Passing a :class:`~io.BytesIO` object supports range requests.\n\n.. versionchanged:: 1.0.3\n    Filenames are encoded with ASCII instead of Latin-1 for broader\n    compatibility with WSGI servers.\n\n.. versionchanged:: 1.0\n    UTF-8 filenames as specified in :rfc:`2231` are supported.\n\n.. versionchanged:: 0.12\n    The filename is no longer automatically inferred from file\n    objects. If you want to use automatic MIME and etag support,\n    pass a filename via ``filename_or_fp`` or\n    ``attachment_filename``.\n\n.. versionchanged:: 0.12\n    ``attachment_filename`` is preferred over ``filename`` for MIME\n    detection.\n\n.. versionchanged:: 0.9\n    ``cache_timeout`` defaults to\n    :meth:`Flask.get_send_file_max_age`.\n\n.. versionchanged:: 0.7\n    MIME guessing and etag support for file-like objects was\n    removed because it was unreliable. Pass a filename if you are\n    able to, otherwise attach an etag yourself.\n\n.. versionchanged:: 0.5\n    The ``add_etags``, ``cache_timeout`` and ``conditional``\n    parameters were added. The default behavior is to add etags.\n\n.. versionadded:: 0.2",
          "code": "def send_file(\n    path_or_file: os.PathLike[t.AnyStr] | str | t.IO[bytes],\n    mimetype: str | None = None,\n    as_attachment: bool = False,\n    download_name: str | None = None,\n    conditional: bool = True,\n    etag: bool | str = True,\n    last_modified: datetime | int | float | None = None,\n    max_age: None | (int | t.Callable[[str | None], int | None]) = None,\n) -> Response:\n    \"\"\"Send the contents of a file to the client.\n\n    The first argument can be a file path or a file-like object. Paths\n    are preferred in most cases because Werkzeug can manage the file and\n    get extra information from the path. Passing a file-like object\n    requires that the file is opened in binary mode, and is mostly\n    useful when building a file in memory with :class:`io.BytesIO`.\n\n    Never pass file paths provided by a user. The path is assumed to be\n    trusted, so a user could craft a path to access a file you didn't\n    intend. Use :func:`send_from_directory` to safely serve\n    user-requested paths from within a directory.\n\n    If the WSGI server sets a ``file_wrapper`` in ``environ``, it is\n    used, otherwise Werkzeug's built-in wrapper is used. Alternatively,\n    if the HTTP server supports ``X-Sendfile``, configuring Flask with\n    ``USE_X_SENDFILE = True`` will tell the server to send the given\n    path, which is much more efficient than reading it in Python.\n\n    :param path_or_file: The path to the file to send, relative to the\n        current working directory if a relative path is given.\n        Alternatively, a file-like object opened in binary mode. Make\n        sure the file pointer is seeked to the start of the data.\n    :param mimetype: The MIME type to send for the file. If not\n        provided, it will try to detect it from the file name.\n    :param as_attachment: Indicate to a browser that it should offer to\n        save the file instead of displaying it.\n    :param download_name: The default name browsers will use when saving\n        the file. Defaults to the passed file name.\n    :param conditional: Enable conditional and range responses based on\n        request headers. Requires passing a file path and ``environ``.\n    :param etag: Calculate an ETag for the file, which requires passing\n        a file path. Can also be a string to use instead.\n    :param last_modified: The last modified time to send for the file,\n        in seconds. If not provided, it will try to detect it from the\n        file path.\n    :param max_age: How long the client should cache the file, in\n        seconds. If set, ``Cache-Control`` will be ``public``, otherwise\n        it will be ``no-cache`` to prefer conditional caching.\n\n    .. versionchanged:: 2.0\n        ``download_name`` replaces the ``attachment_filename``\n        parameter. If ``as_attachment=False``, it is passed with\n        ``Content-Disposition: inline`` instead.\n\n    .. versionchanged:: 2.0\n        ``max_age`` replaces the ``cache_timeout`` parameter.\n        ``conditional`` is enabled and ``max_age`` is not set by\n        default.\n\n    .. versionchanged:: 2.0\n        ``etag`` replaces the ``add_etags`` parameter. It can be a\n        string to use instead of generating one.\n\n    .. versionchanged:: 2.0\n        Passing a file-like object that inherits from\n        :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n        than sending an empty file.\n\n    .. versionadded:: 2.0\n        Moved the implementation to Werkzeug. This is now a wrapper to\n        pass some Flask-specific arguments.\n\n    .. versionchanged:: 1.1\n        ``filename`` may be a :class:`~os.PathLike` object.\n\n    .. versionchanged:: 1.1\n        Passing a :class:`~io.BytesIO` object supports range requests.\n\n    .. versionchanged:: 1.0.3\n        Filenames are encoded with ASCII instead of Latin-1 for broader\n        compatibility with WSGI servers.\n\n    .. versionchanged:: 1.0\n        UTF-8 filenames as specified in :rfc:`2231` are supported.\n\n    .. versionchanged:: 0.12\n        The filename is no longer automatically inferred from file\n        objects. If you want to use automatic MIME and etag support,\n        pass a filename via ``filename_or_fp`` or\n        ``attachment_filename``.\n\n    .. versionchanged:: 0.12\n        ``attachment_filename`` is preferred over ``filename`` for MIME\n        detection.\n\n    .. versionchanged:: 0.9\n        ``cache_timeout`` defaults to\n        :meth:`Flask.get_send_file_max_age`.\n\n    .. versionchanged:: 0.7\n        MIME guessing and etag support for file-like objects was\n        removed because it was unreliable. Pass a filename if you are\n        able to, otherwise attach an etag yourself.\n\n    .. versionchanged:: 0.5\n        The ``add_etags``, ``cache_timeout`` and ``conditional``\n        parameters were added. The default behavior is to add etags.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return werkzeug.utils.send_file(  # type: ignore[return-value]\n        **_prepare_send_file_kwargs(\n            path_or_file=path_or_file,\n            environ=request.environ,\n            mimetype=mimetype,\n            as_attachment=as_attachment,\n            download_name=download_name,\n            conditional=conditional,\n            etag=etag,\n            last_modified=last_modified,\n            max_age=max_age,\n        )\n    )",
          "line_count": 124,
          "needs_llm_summary": true
        },
        {
          "name": "send_from_directory",
          "args": [
            {
              "name": "directory",
              "type": "Any"
            },
            {
              "name": "path",
              "type": "Any"
            }
          ],
          "return_type": "Response",
          "lineno": 527,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "directory",
            "_prepare_send_file_kwargs",
            "werkzeug.utils.send_from_directory",
            "path"
          ],
          "docstring": "Send a file from within a directory using :func:`send_file`.\n\n.. code-block:: python\n\n    @app.route(\"/uploads/<path:name>\")\n    def download_file(name):\n        return send_from_directory(\n            app.config['UPLOAD_FOLDER'], name, as_attachment=True\n        )\n\nThis is a secure way to serve files from a folder, such as static\nfiles or uploads. Uses :func:`~werkzeug.security.safe_join` to\nensure the path coming from the client is not maliciously crafted to\npoint outside the specified directory.\n\nIf the final path does not point to an existing regular file,\nraises a 404 :exc:`~werkzeug.exceptions.NotFound` error.\n\n:param directory: The directory that ``path`` must be located under,\n    relative to the current application's root path. This *must not*\n    be a value provided by the client, otherwise it becomes insecure.\n:param path: The path to the file to send, relative to\n    ``directory``.\n:param kwargs: Arguments to pass to :func:`send_file`.\n\n.. versionchanged:: 2.0\n    ``path`` replaces the ``filename`` parameter.\n\n.. versionadded:: 2.0\n    Moved the implementation to Werkzeug. This is now a wrapper to\n    pass some Flask-specific arguments.\n\n.. versionadded:: 0.5",
          "code": "def send_from_directory(\n    directory: os.PathLike[str] | str,\n    path: os.PathLike[str] | str,\n    **kwargs: t.Any,\n) -> Response:\n    \"\"\"Send a file from within a directory using :func:`send_file`.\n\n    .. code-block:: python\n\n        @app.route(\"/uploads/<path:name>\")\n        def download_file(name):\n            return send_from_directory(\n                app.config['UPLOAD_FOLDER'], name, as_attachment=True\n            )\n\n    This is a secure way to serve files from a folder, such as static\n    files or uploads. Uses :func:`~werkzeug.security.safe_join` to\n    ensure the path coming from the client is not maliciously crafted to\n    point outside the specified directory.\n\n    If the final path does not point to an existing regular file,\n    raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.\n\n    :param directory: The directory that ``path`` must be located under,\n        relative to the current application's root path. This *must not*\n        be a value provided by the client, otherwise it becomes insecure.\n    :param path: The path to the file to send, relative to\n        ``directory``.\n    :param kwargs: Arguments to pass to :func:`send_file`.\n\n    .. versionchanged:: 2.0\n        ``path`` replaces the ``filename`` parameter.\n\n    .. versionadded:: 2.0\n        Moved the implementation to Werkzeug. This is now a wrapper to\n        pass some Flask-specific arguments.\n\n    .. versionadded:: 0.5\n    \"\"\"\n    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]\n        directory, path, **_prepare_send_file_kwargs(**kwargs)\n    )",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "get_root_path",
          "args": [
            {
              "name": "import_name",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 571,
          "decorators": [],
          "is_async": false,
          "calls": [
            "mod",
            "sys.modules.get",
            "__import__",
            "loader",
            "os.path.abspath",
            "hasattr",
            "getattr",
            "RuntimeError",
            "import_name",
            "os.getcwd",
            "filepath",
            "os.path.dirname",
            "mod.__file__",
            "importlib.util.find_spec",
            "spec.loader",
            "loader.get_filename"
          ],
          "docstring": "Find the root path of a package, or the path that contains a\nmodule. If it cannot be found, returns the current working\ndirectory.\n\nNot to be confused with the value returned by :func:`find_package`.\n\n:meta private:",
          "code": "def get_root_path(import_name: str) -> str:\n    \"\"\"Find the root path of a package, or the path that contains a\n    module. If it cannot be found, returns the current working\n    directory.\n\n    Not to be confused with the value returned by :func:`find_package`.\n\n    :meta private:\n    \"\"\"\n    # Module already imported and has a file attribute. Use that first.\n    mod = sys.modules.get(import_name)\n\n    if mod is not None and hasattr(mod, \"__file__\") and mod.__file__ is not None:\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    try:\n        spec = importlib.util.find_spec(import_name)\n\n        if spec is None:\n            raise ValueError\n    except (ImportError, ValueError):\n        loader = None\n    else:\n        loader = spec.loader\n\n    # Loader does not exist or we're referring to an unloaded main\n    # module or a main module without path (interactive sessions), go\n    # with the current working directory.\n    if loader is None:\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)  # pyright: ignore\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a file path it might be because it is a\n        # namespace package. In this case pick the root path from the\n        # first module that is contained in the package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided module\"\n                f\" {import_name!r}. This can happen because the module\"\n                \" came from an import hook that does not provide file\"\n                \" name information or because it's a namespace package.\"\n                \" In this case the root path needs to be explicitly\"\n                \" provided.\"\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))",
          "line_count": 55,
          "needs_llm_summary": true
        },
        {
          "name": "_split_blueprint_path",
          "args": [
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "list[str]",
          "lineno": 629,
          "decorators": [
            {
              "name": "cache",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "name.rpartition",
            "_split_blueprint_path",
            "out.extend"
          ],
          "docstring": null,
          "code": "def _split_blueprint_path(name: str) -> list[str]:\n    out: list[str] = [name]\n\n    if \".\" in name:\n        out.extend(_split_blueprint_path(name.rpartition(\".\")[0]))\n\n    return out",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "generator",
          "args": [],
          "return_type": "t.Iterator[t.AnyStr]",
          "lineno": 113,
          "decorators": [],
          "is_async": false,
          "calls": [
            "gen",
            "hasattr",
            "RuntimeError",
            "gen.close",
            "_cv_app.get"
          ],
          "docstring": null,
          "code": "def generator() -> t.Iterator[t.AnyStr]:\n        if (ctx := _cv_app.get(None)) is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n\n        with ctx:\n            yield None  # type: ignore[misc]\n\n            try:\n                yield from gen\n            finally:\n                # Clean up in case the user wrapped a WSGI iterator.\n                if hasattr(gen, \"close\"):\n                    gen.close()",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [],
          "return_type": "t.Any",
          "lineno": 107,
          "decorators": [],
          "is_async": false,
          "calls": [
            "gen",
            "kwargs",
            "stream_with_context",
            "generator_or_function"
          ],
          "docstring": null,
          "code": "def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "importlib.util",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "datetime",
          "name": "datetime",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "functools",
          "name": "cache",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "werkzeug.utils",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "abort",
          "alias": "_wz_abort",
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "werkzeug.utils",
          "name": "redirect",
          "alias": "_wz_redirect",
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "werkzeug.wrappers",
          "name": "Response",
          "alias": "BaseResponse",
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "_cv_app",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "app_ctx",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "current_app",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "request",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "session",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "message_flashed",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Response",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing",
          "functools",
          "os",
          "datetime",
          "sys"
        ],
        "third_party": {
          "other": [
            "__future__",
            "importlib",
            "werkzeug",
            "globals",
            "signals",
            "wrappers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 636
    },
    "src/flask/json/__init__.py": {
      "filepath": "../flask/src/flask/json/__init__.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "dumps",
          "args": [
            {
              "name": "obj",
              "type": "t.Any"
            }
          ],
          "return_type": "str",
          "lineno": 13,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "_json.dumps",
            "kwargs.setdefault",
            "obj",
            "current_app.json.dumps",
            "_default"
          ],
          "docstring": "Serialize data as JSON.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\nmethod, otherwise it will use :func:`json.dumps`.\n\n:param obj: The data to serialize.\n:param kwargs: Arguments passed to the ``dumps`` implementation.\n\n.. versionchanged:: 2.3\n    The ``app`` parameter was removed.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.dumps``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.0.2\n    :class:`decimal.Decimal` is supported by converting to a string.\n\n.. versionchanged:: 2.0\n    ``encoding`` will be removed in Flask 2.1.\n\n.. versionchanged:: 1.0.3\n    ``app`` can be passed directly, rather than requiring an app\n    context for configuration.",
          "code": "def dumps(obj: t.Any, **kwargs: t.Any) -> str:\n    \"\"\"Serialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\n    method, otherwise it will use :func:`json.dumps`.\n\n    :param obj: The data to serialize.\n    :param kwargs: Arguments passed to the ``dumps`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dumps``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.dumps(obj, **kwargs)\n\n    kwargs.setdefault(\"default\", _default)\n    return _json.dumps(obj, **kwargs)",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "dump",
          "args": [
            {
              "name": "obj",
              "type": "t.Any"
            },
            {
              "name": "fp",
              "type": "t.IO[str]"
            }
          ],
          "return_type": "None",
          "lineno": 47,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "current_app.json.dump",
            "kwargs.setdefault",
            "obj",
            "_default",
            "fp",
            "_json.dump"
          ],
          "docstring": "Serialize data as JSON and write to a file.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\nmethod, otherwise it will use :func:`json.dump`.\n\n:param obj: The data to serialize.\n:param fp: A file opened for writing text. Should use the UTF-8\n    encoding to be valid JSON.\n:param kwargs: Arguments passed to the ``dump`` implementation.\n\n.. versionchanged:: 2.3\n    The ``app`` parameter was removed.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.dump``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.0\n    Writing to a binary file, and the ``encoding`` argument, will be\n    removed in Flask 2.1.",
          "code": "def dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n    \"\"\"Serialize data as JSON and write to a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\n    method, otherwise it will use :func:`json.dump`.\n\n    :param obj: The data to serialize.\n    :param fp: A file opened for writing text. Should use the UTF-8\n        encoding to be valid JSON.\n    :param kwargs: Arguments passed to the ``dump`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dump``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        Writing to a binary file, and the ``encoding`` argument, will be\n        removed in Flask 2.1.\n    \"\"\"\n    if current_app:\n        current_app.json.dump(obj, fp, **kwargs)\n    else:\n        kwargs.setdefault(\"default\", _default)\n        _json.dump(obj, fp, **kwargs)",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "loads",
          "args": [
            {
              "name": "s",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 77,
          "decorators": [],
          "is_async": false,
          "calls": [
            "s",
            "_json.loads",
            "kwargs",
            "current_app.json.loads"
          ],
          "docstring": "Deserialize data as JSON.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`\nmethod, otherwise it will use :func:`json.loads`.\n\n:param s: Text or UTF-8 bytes.\n:param kwargs: Arguments passed to the ``loads`` implementation.\n\n.. versionchanged:: 2.3\n    The ``app`` parameter was removed.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.loads``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.0\n    ``encoding`` will be removed in Flask 2.1. The data must be a\n    string or UTF-8 bytes.\n\n.. versionchanged:: 1.0.3\n    ``app`` can be passed directly, rather than requiring an app\n    context for configuration.",
          "code": "def loads(s: str | bytes, **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`\n    method, otherwise it will use :func:`json.loads`.\n\n    :param s: Text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``loads`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.loads``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The data must be a\n        string or UTF-8 bytes.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.loads(s, **kwargs)\n\n    return _json.loads(s, **kwargs)",
          "line_count": 29,
          "needs_llm_summary": true
        },
        {
          "name": "load",
          "args": [
            {
              "name": "fp",
              "type": "t.IO[t.AnyStr]"
            }
          ],
          "return_type": "t.Any",
          "lineno": 108,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "fp",
            "_json.load",
            "current_app.json.load"
          ],
          "docstring": "Deserialize data as JSON read from a file.\n\nIf :data:`~flask.current_app` is available, it will use its\n:meth:`app.json.load() <flask.json.provider.JSONProvider.load>`\nmethod, otherwise it will use :func:`json.load`.\n\n:param fp: A file opened for reading text or UTF-8 bytes.\n:param kwargs: Arguments passed to the ``load`` implementation.\n\n.. versionchanged:: 2.3\n    The ``app`` parameter was removed.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.load``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.2\n    The ``app`` parameter will be removed in Flask 2.3.\n\n.. versionchanged:: 2.0\n    ``encoding`` will be removed in Flask 2.1. The file must be text\n    mode, or binary mode with UTF-8 bytes.",
          "code": "def load(fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON read from a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.load() <flask.json.provider.JSONProvider.load>`\n    method, otherwise it will use :func:`json.load`.\n\n    :param fp: A file opened for reading text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``load`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.load``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.2\n        The ``app`` parameter will be removed in Flask 2.3.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The file must be text\n        mode, or binary mode with UTF-8 bytes.\n    \"\"\"\n    if current_app:\n        return current_app.json.load(fp, **kwargs)\n\n    return _json.load(fp, **kwargs)",
          "line_count": 28,
          "needs_llm_summary": true
        },
        {
          "name": "jsonify",
          "args": [],
          "return_type": "Response",
          "lineno": 138,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "current_app.json.response"
          ],
          "docstring": "Serialize the given arguments as JSON, and return a\n:class:`~flask.Response` object with the ``application/json``\nmimetype. A dict or list returned from a view will be converted to a\nJSON response automatically without needing to call this.\n\nThis requires an active app context, and calls\n:meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.\n\nIn debug mode, the output is formatted with indentation to make it\neasier to read. This may also be controlled by the provider.\n\nEither positional or keyword arguments can be given, not both.\nIf no arguments are given, ``None`` is serialized.\n\n:param args: A single value to serialize, or multiple values to\n    treat as a list to serialize.\n:param kwargs: Treat as a dict to serialize.\n\n.. versionchanged:: 2.2\n    Calls ``current_app.json.response``, allowing an app to override\n    the behavior.\n\n.. versionchanged:: 2.0.2\n    :class:`decimal.Decimal` is supported by converting to a string.\n\n.. versionchanged:: 0.11\n    Added support for serializing top-level arrays. This was a\n    security risk in ancient browsers. See :ref:`security-json`.\n\n.. versionadded:: 0.2",
          "code": "def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:\n    \"\"\"Serialize the given arguments as JSON, and return a\n    :class:`~flask.Response` object with the ``application/json``\n    mimetype. A dict or list returned from a view will be converted to a\n    JSON response automatically without needing to call this.\n\n    This requires an active app context, and calls\n    :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.\n\n    In debug mode, the output is formatted with indentation to make it\n    easier to read. This may also be controlled by the provider.\n\n    Either positional or keyword arguments can be given, not both.\n    If no arguments are given, ``None`` is serialized.\n\n    :param args: A single value to serialize, or multiple values to\n        treat as a list to serialize.\n    :param kwargs: Treat as a dict to serialize.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.response``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 0.11\n        Added support for serializing top-level arrays. This was a\n        security risk in ancient browsers. See :ref:`security-json`.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return current_app.json.response(*args, **kwargs)",
          "line_count": 33,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "json",
          "alias": "_json",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "globals",
          "name": "current_app",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "provider",
          "name": "_default",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Response",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing",
          "json"
        ],
        "third_party": {
          "other": [
            "__future__",
            "globals",
            "provider",
            "wrappers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 171
    },
    "src/flask/json/provider.py": {
      "filepath": "../flask/src/flask/json/provider.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_default",
          "args": [
            {
              "name": "o",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 108,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "str",
            "dataclasses.is_dataclass",
            "TypeError",
            "o.__html__",
            "hasattr",
            "o",
            "http_date",
            "date",
            "type",
            "dataclasses.asdict"
          ],
          "docstring": null,
          "code": "def _default(o: t.Any) -> t.Any:\n    if isinstance(o, date):\n        return http_date(o)\n\n    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n        return str(o)\n\n    if dataclasses and dataclasses.is_dataclass(o):\n        return dataclasses.asdict(o)  # type: ignore[arg-type]\n\n    if hasattr(o, \"__html__\"):\n        return str(o.__html__())\n\n    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "App"
            }
          ],
          "return_type": "None",
          "lineno": 38,
          "decorators": [],
          "is_async": false,
          "calls": [
            "app",
            "weakref.proxy"
          ],
          "docstring": null,
          "code": "def __init__(self, app: App) -> None:\n        self._app: App = weakref.proxy(app)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "dumps",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "t.Any"
            }
          ],
          "return_type": "str",
          "lineno": 41,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Serialize data as JSON.\n\n:param obj: The data to serialize.\n:param kwargs: May be passed to the underlying JSON library.",
          "code": "def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON.\n\n        :param obj: The data to serialize.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "dump",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "t.Any"
            },
            {
              "name": "fp",
              "type": "t.IO[str]"
            }
          ],
          "return_type": "None",
          "lineno": 49,
          "decorators": [],
          "is_async": false,
          "calls": [
            "obj",
            "fp.write",
            "self.dumps",
            "kwargs"
          ],
          "docstring": "Serialize data as JSON and write to a file.\n\n:param obj: The data to serialize.\n:param fp: A file opened for writing text. Should use the UTF-8\n    encoding to be valid JSON.\n:param kwargs: May be passed to the underlying JSON library.",
          "code": "def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n        \"\"\"Serialize data as JSON and write to a file.\n\n        :param obj: The data to serialize.\n        :param fp: A file opened for writing text. Should use the UTF-8\n            encoding to be valid JSON.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        fp.write(self.dumps(obj, **kwargs))",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "loads",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "s",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 59,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Deserialize data as JSON.\n\n:param s: Text or UTF-8 bytes.\n:param kwargs: May be passed to the underlying JSON library.",
          "code": "def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "load",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "fp",
              "type": "t.IO[t.AnyStr]"
            }
          ],
          "return_type": "t.Any",
          "lineno": 67,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "self.loads",
            "fp.read"
          ],
          "docstring": "Deserialize data as JSON read from a file.\n\n:param fp: A file opened for reading text or UTF-8 bytes.\n:param kwargs: May be passed to the underlying JSON library.",
          "code": "def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON read from a file.\n\n        :param fp: A file opened for reading text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        return self.loads(fp.read(), **kwargs)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_prepare_response_obj",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "args",
              "type": "tuple[t.Any, Ellipsis]"
            },
            {
              "name": "kwargs",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "t.Any",
          "lineno": 75,
          "decorators": [],
          "is_async": false,
          "calls": [
            "args",
            "len",
            "TypeError"
          ],
          "docstring": null,
          "code": "def _prepare_response_obj(\n        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n    ) -> t.Any:\n        if args and kwargs:\n            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n\n        if not args and not kwargs:\n            return None\n\n        if len(args) == 1:\n            return args[0]\n\n        return args or kwargs",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "response",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Response",
          "lineno": 89,
          "decorators": [],
          "is_async": false,
          "calls": [
            "args",
            "kwargs",
            "obj",
            "self._app.response_class",
            "self.dumps",
            "self._prepare_response_obj"
          ],
          "docstring": "Serialize the given arguments as JSON, and return a\n:class:`~flask.Response` object with the ``application/json``\nmimetype.\n\nThe :func:`~flask.json.jsonify` function calls this method for\nthe current application.\n\nEither positional or keyword arguments can be given, not both.\nIf no arguments are given, ``None`` is serialized.\n\n:param args: A single value to serialize, or multiple values to\n    treat as a list to serialize.\n:param kwargs: Treat as a dict to serialize.",
          "code": "def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n        \"\"\"Serialize the given arguments as JSON, and return a\n        :class:`~flask.Response` object with the ``application/json``\n        mimetype.\n\n        The :func:`~flask.json.jsonify` function calls this method for\n        the current application.\n\n        Either positional or keyword arguments can be given, not both.\n        If no arguments are given, ``None`` is serialized.\n\n        :param args: A single value to serialize, or multiple values to\n            treat as a list to serialize.\n        :param kwargs: Treat as a dict to serialize.\n        \"\"\"\n        obj = self._prepare_response_obj(args, kwargs)\n        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "dumps",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "t.Any"
            }
          ],
          "return_type": "str",
          "lineno": 166,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "self.ensure_ascii",
            "self.sort_keys",
            "self.default",
            "kwargs.setdefault",
            "obj",
            "json.dumps"
          ],
          "docstring": "Serialize data as JSON to a string.\n\nKeyword arguments are passed to :func:`json.dumps`. Sets some\nparameter defaults from the :attr:`default`,\n:attr:`ensure_ascii`, and :attr:`sort_keys` attributes.\n\n:param obj: The data to serialize.\n:param kwargs: Passed to :func:`json.dumps`.",
          "code": "def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON to a string.\n\n        Keyword arguments are passed to :func:`json.dumps`. Sets some\n        parameter defaults from the :attr:`default`,\n        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.\n\n        :param obj: The data to serialize.\n        :param kwargs: Passed to :func:`json.dumps`.\n        \"\"\"\n        kwargs.setdefault(\"default\", self.default)\n        kwargs.setdefault(\"ensure_ascii\", self.ensure_ascii)\n        kwargs.setdefault(\"sort_keys\", self.sort_keys)\n        return json.dumps(obj, **kwargs)",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "loads",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "s",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 181,
          "decorators": [],
          "is_async": false,
          "calls": [
            "s",
            "kwargs",
            "json.loads"
          ],
          "docstring": "Deserialize data as JSON from a string or bytes.\n\n:param s: Text or UTF-8 bytes.\n:param kwargs: Passed to :func:`json.loads`.",
          "code": "def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON from a string or bytes.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: Passed to :func:`json.loads`.\n        \"\"\"\n        return json.loads(s, **kwargs)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "response",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Response",
          "lineno": 189,
          "decorators": [],
          "is_async": false,
          "calls": [
            "args",
            "kwargs",
            "dump_args.setdefault",
            "obj",
            "self._app.response_class",
            "self.mimetype",
            "dump_args",
            "self.dumps",
            "self._prepare_response_obj"
          ],
          "docstring": "Serialize the given arguments as JSON, and return a\n:class:`~flask.Response` object with it. The response mimetype\nwill be \"application/json\" and can be changed with\n:attr:`mimetype`.\n\nIf :attr:`compact` is ``False`` or debug mode is enabled, the\noutput will be formatted to be easier to read.\n\nEither positional or keyword arguments can be given, not both.\nIf no arguments are given, ``None`` is serialized.\n\n:param args: A single value to serialize, or multiple values to\n    treat as a list to serialize.\n:param kwargs: Treat as a dict to serialize.",
          "code": "def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n        \"\"\"Serialize the given arguments as JSON, and return a\n        :class:`~flask.Response` object with it. The response mimetype\n        will be \"application/json\" and can be changed with\n        :attr:`mimetype`.\n\n        If :attr:`compact` is ``False`` or debug mode is enabled, the\n        output will be formatted to be easier to read.\n\n        Either positional or keyword arguments can be given, not both.\n        If no arguments are given, ``None`` is serialized.\n\n        :param args: A single value to serialize, or multiple values to\n            treat as a list to serialize.\n        :param kwargs: Treat as a dict to serialize.\n        \"\"\"\n        obj = self._prepare_response_obj(args, kwargs)\n        dump_args: dict[str, t.Any] = {}\n\n        if (self.compact is None and self._app.debug) or self.compact is False:\n            dump_args.setdefault(\"indent\", 2)\n        else:\n            dump_args.setdefault(\"separators\", (\",\", \":\"))\n\n        return self._app.response_class(\n            f\"{self.dumps(obj, **dump_args)}\\n\", mimetype=self.mimetype\n        )",
          "line_count": 27,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "JSONProvider",
          "methods": [
            "__init__",
            "dumps",
            "dump",
            "loads",
            "load",
            "_prepare_response_obj",
            "response"
          ],
          "base_classes": [],
          "lineno": 19,
          "docstring": "A standard set of JSON operations for an application. Subclasses\nof this can be used to customize JSON behavior or use different\nJSON libraries.\n\nTo implement a provider for a specific library, subclass this base\nclass and implement at least :meth:`dumps` and :meth:`loads`. All\nother methods have default implementations.\n\nTo use a different provider, either subclass ``Flask`` and set\n:attr:`~flask.Flask.json_provider_class` to a provider class, or set\n:attr:`app.json <flask.Flask.json>` to an instance of the class.\n\n:param app: An application instance. This will be stored as a\n    :class:`weakref.proxy` on the :attr:`_app` attribute.\n\n.. versionadded:: 2.2"
        },
        {
          "name": "DefaultJSONProvider",
          "methods": [
            "dumps",
            "loads",
            "response"
          ],
          "base_classes": [
            "JSONProvider"
          ],
          "lineno": 124,
          "docstring": "Provide JSON operations using Python's built-in :mod:`json`\nlibrary. Serializes the following additional data types:\n\n-   :class:`datetime.datetime` and :class:`datetime.date` are\n    serialized to :rfc:`822` strings. This is the same as the HTTP\n    date format.\n-   :class:`uuid.UUID` is serialized to a string.\n-   :class:`dataclasses.dataclass` is passed to\n    :func:`dataclasses.asdict`.\n-   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n    method) will call the ``__html__`` method to get a string."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "dataclasses",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "decimal",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "json",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "uuid",
          "alias": null,
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "weakref",
          "alias": null,
          "lineno": 8,
          "type": "import"
        },
        {
          "module": "datetime",
          "name": "date",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "werkzeug.http",
          "name": "http_date",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "werkzeug.sansio.response",
          "name": "Response",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "sansio.app",
          "name": "App",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "datetime",
          "dataclasses",
          "typing",
          "json"
        ],
        "third_party": {
          "other": [
            "__future__",
            "decimal",
            "uuid",
            "weakref",
            "werkzeug",
            "sansio"
          ]
        },
        "tech_stack": []
      },
      "line_count": 216
    },
    "src/flask/json/tag.py": {
      "filepath": "../flask/src/flask/json/tag.py",
      "module_docstring": "Tagged JSON\n~~~~~~~~~~~\n\nA compact representation for lossless serialization of non-standard JSON\ntypes. :class:`~flask.sessions.SecureCookieSessionInterface` uses this\nto serialize the session data, but it may be useful in other places. It\ncan be extended to support other types.\n\n.. autoclass:: TaggedJSONSerializer\n    :members:\n\n.. autoclass:: JSONTag\n    :members:\n\nLet's see an example that adds support for\n:class:`~collections.OrderedDict`. Dicts don't have an order in JSON, so\nto handle this we will dump the items as a list of ``[key, value]``\npairs. Subclass :class:`JSONTag` and give it the new key ``' od'`` to\nidentify the type. The session serializer processes dicts first, so\ninsert the new tag at the front of the order since ``OrderedDict`` must\nbe processed before ``dict``.\n\n.. code-block:: python\n\n    from flask.json.tag import JSONTag\n\n    class TagOrderedDict(JSONTag):\n        __slots__ = ('serializer',)\n        key = ' od'\n\n        def check(self, value):\n            return isinstance(value, OrderedDict)\n\n        def to_json(self, value):\n            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]\n\n        def to_python(self, value):\n            return OrderedDict(value)\n\n    app.session_interface.serializer.register(TagOrderedDict, index=0)",
      "functions": [
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "serializer",
              "type": "TaggedJSONSerializer"
            }
          ],
          "return_type": "None",
          "lineno": 69,
          "decorators": [],
          "is_async": false,
          "calls": [
            "serializer"
          ],
          "docstring": "Create a tagger for the given serializer.",
          "code": "def __init__(self, serializer: TaggedJSONSerializer) -> None:\n        \"\"\"Create a tagger for the given serializer.\"\"\"\n        self.serializer = serializer",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 73,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Check if the given value should be tagged by this tag.",
          "code": "def check(self, value: t.Any) -> bool:\n        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n        raise NotImplementedError",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 77,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Convert the Python object to an object that is a valid JSON type.\nThe tag will be added later.",
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "to_python",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 82,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Convert the JSON representation back to the correct type. The tag\nwill already be removed.",
          "code": "def to_python(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "tag",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "dict[str, t.Any]",
          "lineno": 87,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "self.to_json"
          ],
          "docstring": "Convert the value to a valid JSON type and add the tag structure\naround it.",
          "code": "def tag(self, value: t.Any) -> dict[str, t.Any]:\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 103,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "value",
            "dict",
            "len",
            "next",
            "iter"
          ],
          "docstring": null,
          "code": "def check(self, value: t.Any) -> bool:\n        return (\n            isinstance(value, dict)\n            and len(value) == 1\n            and next(iter(value)) in self.serializer.tags\n        )",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 110,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "self.serializer.tag",
            "next",
            "iter"
          ],
          "docstring": null,
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "to_python",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 114,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "next",
            "iter"
          ],
          "docstring": null,
          "code": "def to_python(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {key[:-2]: value[key]}",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 122,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "isinstance",
            "dict"
          ],
          "docstring": null,
          "code": "def check(self, value: t.Any) -> bool:\n        return isinstance(value, dict)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 125,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.serializer.tag",
            "value.items",
            "v"
          ],
          "docstring": null,
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 137,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "isinstance",
            "tuple"
          ],
          "docstring": null,
          "code": "def check(self, value: t.Any) -> bool:\n        return isinstance(value, tuple)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 140,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.serializer.tag",
            "item"
          ],
          "docstring": null,
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_python",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 143,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "tuple"
          ],
          "docstring": null,
          "code": "def to_python(self, value: t.Any) -> t.Any:\n        return tuple(value)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 150,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "isinstance",
            "list"
          ],
          "docstring": null,
          "code": "def check(self, value: t.Any) -> bool:\n        return isinstance(value, list)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 153,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.serializer.tag",
            "item"
          ],
          "docstring": null,
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 163,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "isinstance",
            "bytes"
          ],
          "docstring": null,
          "code": "def check(self, value: t.Any) -> bool:\n        return isinstance(value, bytes)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 166,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "b64encode",
            "unknown.decode"
          ],
          "docstring": null,
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        return b64encode(value).decode(\"ascii\")",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_python",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 169,
          "decorators": [],
          "is_async": false,
          "calls": [
            "b64decode",
            "value"
          ],
          "docstring": null,
          "code": "def to_python(self, value: t.Any) -> t.Any:\n        return b64decode(value)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 181,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "callable",
            "getattr"
          ],
          "docstring": null,
          "code": "def check(self, value: t.Any) -> bool:\n        return callable(getattr(value, \"__html__\", None))",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 184,
          "decorators": [],
          "is_async": false,
          "calls": [
            "str",
            "value.__html__"
          ],
          "docstring": null,
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        return str(value.__html__())",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_python",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 187,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "Markup"
          ],
          "docstring": null,
          "code": "def to_python(self, value: t.Any) -> t.Any:\n        return Markup(value)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 195,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "isinstance",
            "UUID"
          ],
          "docstring": null,
          "code": "def check(self, value: t.Any) -> bool:\n        return isinstance(value, UUID)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 198,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        return value.hex",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_python",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 201,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "UUID"
          ],
          "docstring": null,
          "code": "def to_python(self, value: t.Any) -> t.Any:\n        return UUID(value)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "check",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "bool",
          "lineno": 209,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "isinstance",
            "datetime"
          ],
          "docstring": null,
          "code": "def check(self, value: t.Any) -> bool:\n        return isinstance(value, datetime)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_json",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 212,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "http_date"
          ],
          "docstring": null,
          "code": "def to_json(self, value: t.Any) -> t.Any:\n        return http_date(value)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "to_python",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 215,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "parse_date"
          ],
          "docstring": null,
          "code": "def to_python(self, value: t.Any) -> t.Any:\n        return parse_date(value)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 249,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.register",
            "cls"
          ],
          "docstring": null,
          "code": "def __init__(self) -> None:\n        self.tags: dict[str, JSONTag] = {}\n        self.order: list[JSONTag] = []\n\n        for cls in self.default_tags:\n            self.register(cls)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "register",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "tag_class",
              "type": "type[JSONTag]"
            },
            {
              "name": "force",
              "type": "bool"
            },
            {
              "name": "index",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 256,
          "decorators": [],
          "is_async": false,
          "calls": [
            "tag.key",
            "self",
            "tag",
            "self.order.append",
            "index",
            "self.order.insert",
            "KeyError",
            "tag_class"
          ],
          "docstring": "Register a new tag with this serializer.\n\n:param tag_class: tag class to register. Will be instantiated with this\n    serializer instance.\n:param force: overwrite an existing tag. If false (default), a\n    :exc:`KeyError` is raised.\n:param index: index to insert the new tag in the tag order. Useful when\n    the new tag is a special case of an existing tag. If ``None``\n    (default), the tag is appended to the end of the order.\n\n:raise KeyError: if the tag key is already registered and ``force`` is\n    not true.",
          "code": "def register(\n        self,\n        tag_class: type[JSONTag],\n        force: bool = False,\n        index: int | None = None,\n    ) -> None:\n        \"\"\"Register a new tag with this serializer.\n\n        :param tag_class: tag class to register. Will be instantiated with this\n            serializer instance.\n        :param force: overwrite an existing tag. If false (default), a\n            :exc:`KeyError` is raised.\n        :param index: index to insert the new tag in the tag order. Useful when\n            the new tag is a special case of an existing tag. If ``None``\n            (default), the tag is appended to the end of the order.\n\n        :raise KeyError: if the tag key is already registered and ``force`` is\n            not true.\n        \"\"\"\n        tag = tag_class(self)\n        key = tag.key\n\n        if key:\n            if not force and key in self.tags:\n                raise KeyError(f\"Tag '{key}' is already registered.\")\n\n            self.tags[key] = tag\n\n        if index is None:\n            self.order.append(tag)\n        else:\n            self.order.insert(index, tag)",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "tag",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 289,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "tag.tag",
            "tag.check"
          ],
          "docstring": "Convert a value to a tagged representation if necessary.",
          "code": "def tag(self, value: t.Any) -> t.Any:\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "untag",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "t.Any",
          "lineno": 297,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.to_python",
            "value",
            "len",
            "next",
            "iter"
          ],
          "docstring": "Convert a tagged representation back to the original type.",
          "code": "def untag(self, value: dict[str, t.Any]) -> t.Any:\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "_untag_scan",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 309,
          "decorators": [],
          "is_async": false,
          "calls": [
            "isinstance",
            "item",
            "value.items",
            "value",
            "dict",
            "self.untag",
            "list",
            "self._untag_scan",
            "v"
          ],
          "docstring": null,
          "code": "def _untag_scan(self, value: t.Any) -> t.Any:\n        if isinstance(value, dict):\n            # untag each item recursively\n            value = {k: self._untag_scan(v) for k, v in value.items()}\n            # untag the dict itself\n            value = self.untag(value)\n        elif isinstance(value, list):\n            # untag each item recursively\n            value = [self._untag_scan(item) for item in value]\n\n        return value",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "dumps",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "t.Any"
            }
          ],
          "return_type": "str",
          "lineno": 321,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "self.tag",
            "dumps"
          ],
          "docstring": "Tag the value and dump it to a compact JSON string.",
          "code": "def dumps(self, value: t.Any) -> str:\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(\",\", \":\"))",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "loads",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 325,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "loads",
            "self._untag_scan"
          ],
          "docstring": "Load data from a JSON string and deserialized any tagged objects.",
          "code": "def loads(self, value: str) -> t.Any:\n        \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n        return self._untag_scan(loads(value))",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "JSONTag",
          "methods": [
            "__init__",
            "check",
            "to_json",
            "to_python",
            "tag"
          ],
          "base_classes": [],
          "lineno": 60,
          "docstring": "Base class for defining type tags for :class:`TaggedJSONSerializer`."
        },
        {
          "name": "TagDict",
          "methods": [
            "check",
            "to_json",
            "to_python"
          ],
          "base_classes": [
            "JSONTag"
          ],
          "lineno": 93,
          "docstring": "Tag for 1-item dicts whose only key matches a registered tag.\n\nInternally, the dict key is suffixed with `__`, and the suffix is removed\nwhen deserializing."
        },
        {
          "name": "PassDict",
          "methods": [
            "check",
            "to_json"
          ],
          "base_classes": [
            "JSONTag"
          ],
          "lineno": 119,
          "docstring": null
        },
        {
          "name": "TagTuple",
          "methods": [
            "check",
            "to_json",
            "to_python"
          ],
          "base_classes": [
            "JSONTag"
          ],
          "lineno": 133,
          "docstring": null
        },
        {
          "name": "PassList",
          "methods": [
            "check",
            "to_json"
          ],
          "base_classes": [
            "JSONTag"
          ],
          "lineno": 147,
          "docstring": null
        },
        {
          "name": "TagBytes",
          "methods": [
            "check",
            "to_json",
            "to_python"
          ],
          "base_classes": [
            "JSONTag"
          ],
          "lineno": 159,
          "docstring": null
        },
        {
          "name": "TagMarkup",
          "methods": [
            "check",
            "to_json",
            "to_python"
          ],
          "base_classes": [
            "JSONTag"
          ],
          "lineno": 173,
          "docstring": "Serialize anything matching the :class:`~markupsafe.Markup` API by\nhaving a ``__html__`` method to the result of that method. Always\ndeserializes to an instance of :class:`~markupsafe.Markup`."
        },
        {
          "name": "TagUUID",
          "methods": [
            "check",
            "to_json",
            "to_python"
          ],
          "base_classes": [
            "JSONTag"
          ],
          "lineno": 191,
          "docstring": null
        },
        {
          "name": "TagDateTime",
          "methods": [
            "check",
            "to_json",
            "to_python"
          ],
          "base_classes": [
            "JSONTag"
          ],
          "lineno": 205,
          "docstring": null
        },
        {
          "name": "TaggedJSONSerializer",
          "methods": [
            "__init__",
            "register",
            "tag",
            "untag",
            "_untag_scan",
            "dumps",
            "loads"
          ],
          "base_classes": [],
          "lineno": 219,
          "docstring": "Serializer that uses a tag system to compactly represent objects that\nare not JSON types. Passed as the intermediate serializer to\n:class:`itsdangerous.Serializer`.\n\nThe following extra types are supported:\n\n* :class:`dict`\n* :class:`tuple`\n* :class:`bytes`\n* :class:`~markupsafe.Markup`\n* :class:`~uuid.UUID`\n* :class:`~datetime.datetime`"
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 44,
          "type": "from_import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 46,
          "type": "import"
        },
        {
          "module": "base64",
          "name": "b64decode",
          "alias": null,
          "lineno": 47,
          "type": "from_import"
        },
        {
          "module": "base64",
          "name": "b64encode",
          "alias": null,
          "lineno": 48,
          "type": "from_import"
        },
        {
          "module": "datetime",
          "name": "datetime",
          "alias": null,
          "lineno": 49,
          "type": "from_import"
        },
        {
          "module": "uuid",
          "name": "UUID",
          "alias": null,
          "lineno": 50,
          "type": "from_import"
        },
        {
          "module": "markupsafe",
          "name": "Markup",
          "alias": null,
          "lineno": 52,
          "type": "from_import"
        },
        {
          "module": "werkzeug.http",
          "name": "http_date",
          "alias": null,
          "lineno": 53,
          "type": "from_import"
        },
        {
          "module": "werkzeug.http",
          "name": "parse_date",
          "alias": null,
          "lineno": 54,
          "type": "from_import"
        },
        {
          "module": "json",
          "name": "dumps",
          "alias": null,
          "lineno": 56,
          "type": "from_import"
        },
        {
          "module": "json",
          "name": "loads",
          "alias": null,
          "lineno": 57,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "datetime",
          "typing",
          "json"
        ],
        "third_party": {
          "other": [
            "__future__",
            "base64",
            "uuid",
            "markupsafe",
            "werkzeug"
          ]
        },
        "tech_stack": []
      },
      "line_count": 328
    },
    "src/flask/logging.py": {
      "filepath": "../flask/src/flask/logging.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "wsgi_errors_stream",
          "args": [],
          "return_type": "t.TextIO",
          "lineno": 16,
          "decorators": [
            {
              "name": "LocalProxy",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "Find the most appropriate error stream for the application. If a request\nis active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\nIf you configure your own :class:`logging.StreamHandler`, you may want to\nuse this for the stream. If you are using file or dict configuration and\ncan't import this directly, you can refer to it as\n``ext://flask.logging.wsgi_errors_stream``.",
          "code": "def wsgi_errors_stream() -> t.TextIO:\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    if request:\n        return request.environ[\"wsgi.errors\"]  # type: ignore[no-any-return]\n\n    return sys.stderr",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "has_level_handler",
          "args": [
            {
              "name": "logger",
              "type": "logging.Logger"
            }
          ],
          "return_type": "bool",
          "lineno": 31,
          "decorators": [],
          "is_async": false,
          "calls": [
            "logger.getEffectiveLevel",
            "any",
            "current.parent",
            "logger"
          ],
          "docstring": "Check if there is a handler in the logging chain that will handle the\ngiven logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.",
          "code": "def has_level_handler(logger: logging.Logger) -> bool:\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent  # type: ignore\n\n    return False",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "create_logger",
          "args": [
            {
              "name": "app",
              "type": "App"
            }
          ],
          "return_type": "logging.Logger",
          "lineno": 58,
          "decorators": [],
          "is_async": false,
          "calls": [
            "has_level_handler",
            "logging.getLogger",
            "logging.DEBUG",
            "app.name",
            "logger.addHandler",
            "default_handler",
            "logger.setLevel",
            "logger"
          ],
          "docstring": "Get the Flask app's logger and configure it if needed.\n\nThe logger name will be the same as\n:attr:`app.import_name <flask.Flask.name>`.\n\nWhen :attr:`~flask.Flask.debug` is enabled, set the logger level to\n:data:`logging.DEBUG` if it is not set.\n\nIf there is no handler for the logger's effective level, add a\n:class:`~logging.StreamHandler` for\n:func:`~flask.logging.wsgi_errors_stream` with a basic format.",
          "code": "def create_logger(app: App) -> logging.Logger:\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger",
          "line_count": 22,
          "needs_llm_summary": true
        }
      ],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "logging",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "werkzeug.local",
          "name": "LocalProxy",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "request",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "sansio.app",
          "name": "App",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "default_handler",
          "assigned_to": "logging.StreamHandler",
          "lineno": 52
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "wsgi_errors_stream",
          "logging.StreamHandler",
          "default_handler.setFormatter",
          "logging.Formatter"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "sys",
          "logging",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "werkzeug",
            "globals",
            "sansio"
          ]
        },
        "tech_stack": []
      },
      "line_count": 80
    },
    "src/flask/sansio/app.py": {
      "filepath": "../flask/src/flask/sansio/app.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_make_timedelta",
          "args": [
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 52,
          "decorators": [],
          "is_async": false,
          "calls": [
            "value",
            "timedelta",
            "isinstance"
          ],
          "docstring": null,
          "code": "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "import_name",
              "type": "str"
            },
            {
              "name": "static_url_path",
              "type": "Any"
            },
            {
              "name": "static_folder",
              "type": "Any"
            },
            {
              "name": "static_host",
              "type": "Any"
            },
            {
              "name": "host_matching",
              "type": "bool"
            },
            {
              "name": "subdomain_matching",
              "type": "bool"
            },
            {
              "name": "template_folder",
              "type": "Any"
            },
            {
              "name": "instance_path",
              "type": "Any"
            },
            {
              "name": "instance_relative_config",
              "type": "bool"
            },
            {
              "name": "root_path",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 279,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ValueError",
            "host_matching",
            "static_url_path",
            "self.make_aborter",
            "root_path",
            "unknown.__init__",
            "super",
            "instance_path",
            "self.make_config",
            "template_folder",
            "subdomain_matching",
            "import_name",
            "self",
            "static_folder",
            "os.path.isabs",
            "instance_relative_config",
            "self.auto_find_instance_path",
            "self.json_provider_class",
            "self.url_map_class"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike[str] | None = \"static\",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike[str] | None = \"templates\",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ) -> None:\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        \"\"\"Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python's built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        \"\"\"\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict[str, t.Any] = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False",
          "line_count": 130,
          "needs_llm_summary": true
        },
        {
          "name": "_check_setup_finished",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f_name",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 410,
          "decorators": [],
          "is_async": false,
          "calls": [
            "AssertionError"
          ],
          "docstring": null,
          "code": "def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "name",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 423,
          "decorators": [
            {
              "name": "cached_property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "os.path.splitext",
            "os.path.basename",
            "fn",
            "getattr"
          ],
          "docstring": "The name of the application.  This is usually the import name\nwith the difference that it's guessed from the run file if the\nimport name is main.  This name is used as a display name when\nFlask needs the name of the application.  It can be set and overridden\nto change the value.\n\n.. versionadded:: 0.8",
          "code": "def name(self) -> str:\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn: str | None = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "logger",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "logging.Logger",
          "lineno": 440,
          "decorators": [
            {
              "name": "cached_property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self",
            "create_logger"
          ],
          "docstring": "A standard Python :class:`~logging.Logger` for the app, with\nthe same name as :attr:`name`.\n\nIn debug mode, the logger's :attr:`~logging.Logger.level` will\nbe set to :data:`~logging.DEBUG`.\n\nIf there are no handlers configured, a default handler will be\nadded. See :doc:`/logging` for more information.\n\n.. versionchanged:: 1.1.0\n    The logger takes the same name as :attr:`name` rather than\n    hard-coding ``\"flask.app\"``.\n\n.. versionchanged:: 1.0.0\n    Behavior was simplified. The logger is always named\n    ``\"flask.app\"``. The level is only set during configuration,\n    it doesn't check ``app.debug`` each time. Only one format is\n    used, not different ones depending on ``app.debug``. No\n    handlers are removed, and a handler is only added if no\n    handlers are already configured.\n\n.. versionadded:: 0.3",
          "code": "def logger(self) -> logging.Logger:\n        \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n        the same name as :attr:`name`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will\n        be set to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be\n        added. See :doc:`/logging` for more information.\n\n        .. versionchanged:: 1.1.0\n            The logger takes the same name as :attr:`name` rather than\n            hard-coding ``\"flask.app\"``.\n\n        .. versionchanged:: 1.0.0\n            Behavior was simplified. The logger is always named\n            ``\"flask.app\"``. The level is only set during configuration,\n            it doesn't check ``app.debug`` each time. Only one format is\n            used, not different ones depending on ``app.debug``. No\n            handlers are removed, and a handler is only added if no\n            handlers are already configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "jinja_env",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Environment",
          "lineno": 467,
          "decorators": [
            {
              "name": "cached_property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.create_jinja_environment"
          ],
          "docstring": "The Jinja environment used to load templates.\n\nThe environment is created the first time this property is\naccessed. Changing :attr:`jinja_options` after that will have no\neffect.",
          "code": "def jinja_env(self) -> Environment:\n        \"\"\"The Jinja environment used to load templates.\n\n        The environment is created the first time this property is\n        accessed. Changing :attr:`jinja_options` after that will have no\n        effect.\n        \"\"\"\n        return self.create_jinja_environment()",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "create_jinja_environment",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Environment",
          "lineno": 476,
          "decorators": [],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": null,
          "code": "def create_jinja_environment(self) -> Environment:\n        raise NotImplementedError()",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "make_config",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "instance_relative",
              "type": "bool"
            }
          ],
          "return_type": "Config",
          "lineno": 479,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.root_path",
            "self.instance_path",
            "root_path",
            "self.config_class",
            "defaults",
            "self.default_config",
            "dict",
            "get_debug_flag"
          ],
          "docstring": "Used to create the config attribute by the Flask constructor.\nThe `instance_relative` parameter is passed in from the constructor\nof Flask (there named `instance_relative_config`) and indicates if\nthe config should be relative to the instance path or the root path\nof the application.\n\n.. versionadded:: 0.8",
          "code": "def make_config(self, instance_relative: bool = False) -> Config:\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "make_aborter",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Aborter",
          "lineno": 495,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.aborter_class"
          ],
          "docstring": "Create the object to assign to :attr:`aborter`. That object\nis called by :func:`flask.abort` to raise HTTP errors, and can\nbe called directly as well.\n\nBy default, this creates an instance of :attr:`aborter_class`,\nwhich defaults to :class:`werkzeug.exceptions.Aborter`.\n\n.. versionadded:: 2.2",
          "code": "def make_aborter(self) -> Aborter:\n        \"\"\"Create the object to assign to :attr:`aborter`. That object\n        is called by :func:`flask.abort` to raise HTTP errors, and can\n        be called directly as well.\n\n        By default, this creates an instance of :attr:`aborter_class`,\n        which defaults to :class:`werkzeug.exceptions.Aborter`.\n\n        .. versionadded:: 2.2\n        \"\"\"\n        return self.aborter_class()",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "auto_find_instance_path",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 507,
          "decorators": [],
          "is_async": false,
          "calls": [
            "prefix",
            "package_path",
            "find_package",
            "self.import_name",
            "os.path.join"
          ],
          "docstring": "Tries to locate the instance path if it was not provided to the\nconstructor of the application class.  It will basically calculate\nthe path to a folder named ``instance`` next to your main file or\nthe package.\n\n.. versionadded:: 0.8",
          "code": "def auto_find_instance_path(self) -> str:\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, \"instance\")\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "create_global_jinja_loader",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "DispatchingJinjaLoader",
          "lineno": 520,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "DispatchingJinjaLoader"
          ],
          "docstring": "Creates the loader for the Jinja environment.  Can be used to\noverride just the loader and keeping the rest unchanged.  It's\ndiscouraged to override this function.  Instead one should override\nthe :meth:`jinja_loader` function instead.\n\nThe global loader dispatches between the loaders of the application\nand the individual blueprints.\n\n.. versionadded:: 0.7",
          "code": "def create_global_jinja_loader(self) -> DispatchingJinjaLoader:\n        \"\"\"Creates the loader for the Jinja environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "select_jinja_autoescape",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "filename",
              "type": "str"
            }
          ],
          "return_type": "bool",
          "lineno": 533,
          "decorators": [],
          "is_async": false,
          "calls": [
            "filename.endswith"
          ],
          "docstring": "Returns ``True`` if autoescaping should be active for the given\ntemplate name. If no template name is given, returns `True`.\n\n.. versionchanged:: 2.2\n    Autoescaping is now enabled by default for ``.svg`` files.\n\n.. versionadded:: 0.5",
          "code": "def select_jinja_autoescape(self, filename: str) -> bool:\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionchanged:: 2.2\n            Autoescaping is now enabled by default for ``.svg`` files.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\", \".svg\"))",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "debug",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 547,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "Whether debug mode is enabled. When using ``flask run`` to start the\ndevelopment server, an interactive debugger will be shown for unhandled\nexceptions, and the server will be reloaded when code changes. This maps to the\n:data:`DEBUG` config key. It may not behave as expected if set late.\n\n**Do not enable debug mode when deploying in production.**\n\nDefault: ``False``",
          "code": "def debug(self) -> bool:\n        \"\"\"Whether debug mode is enabled. When using ``flask run`` to start the\n        development server, an interactive debugger will be shown for unhandled\n        exceptions, and the server will be reloaded when code changes. This maps to the\n        :data:`DEBUG` config key. It may not behave as expected if set late.\n\n        **Do not enable debug mode when deploying in production.**\n\n        Default: ``False``\n        \"\"\"\n        return self.config[\"DEBUG\"]",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "debug",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 560,
          "decorators": [
            {
              "name": "debug.setter",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "value"
          ],
          "docstring": null,
          "code": "def debug(self, value: bool) -> None:\n        self.config[\"DEBUG\"] = value\n\n        if self.config[\"TEMPLATES_AUTO_RELOAD\"] is None:\n            self.jinja_env.auto_reload = value",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "register_blueprint",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "blueprint",
              "type": "Blueprint"
            }
          ],
          "return_type": "None",
          "lineno": 567,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self",
            "blueprint.register",
            "options"
          ],
          "docstring": "Register a :class:`~flask.Blueprint` on the application. Keyword\narguments passed to this method will override the defaults set on the\nblueprint.\n\nCalls the blueprint's :meth:`~flask.Blueprint.register` method after\nrecording the blueprint in the application's :attr:`blueprints`.\n\n:param blueprint: The blueprint to register.\n:param url_prefix: Blueprint routes will be prefixed with this.\n:param subdomain: Blueprint routes will match on this subdomain.\n:param url_defaults: Blueprint routes will use these default values for\n    view arguments.\n:param options: Additional keyword arguments are passed to\n    :class:`~flask.blueprints.BlueprintSetupState`. They can be\n    accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n.. versionchanged:: 2.0.1\n    The ``name`` option can be used to change the (pre-dotted)\n    name the blueprint is registered with. This allows the same\n    blueprint to be registered multiple times with unique names\n    for ``url_for``.\n\n.. versionadded:: 0.7",
          "code": "def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        blueprint.register(self, options)",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "iter_blueprints",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.ValuesView[Blueprint]",
          "lineno": 594,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.blueprints.values"
          ],
          "docstring": "Iterates over all blueprints by the order they were registered.\n\n.. versionadded:: 0.11",
          "code": "def iter_blueprints(self) -> t.ValuesView[Blueprint]:\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.blueprints.values()",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "add_url_rule",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            },
            {
              "name": "endpoint",
              "type": "Any"
            },
            {
              "name": "view_func",
              "type": "Any"
            },
            {
              "name": "provide_automatic_options",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 602,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "str",
            "TypeError",
            "endpoint",
            "getattr",
            "methods",
            "set",
            "options",
            "AssertionError",
            "self.url_rule_class",
            "required_methods.add",
            "self.view_functions.get",
            "self.url_map.add",
            "_endpoint_from_view_func",
            "view_func",
            "rule",
            "options.pop",
            "item.upper",
            "isinstance",
            "rule_obj",
            "provide_automatic_options"
          ],
          "docstring": null,
          "code": "def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n\n        # Methods that should always be added\n        required_methods: set[str] = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods and self.config[\"PROVIDE_AUTOMATIC_OPTIONS\"]:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule_obj = self.url_rule_class(rule, methods=methods, **options)\n        rule_obj.provide_automatic_options = provide_automatic_options  # type: ignore[attr-defined]\n\n        self.url_map.add(rule_obj)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func",
          "line_count": 57,
          "needs_llm_summary": true
        },
        {
          "name": "template_filter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "T_template_filter"
            }
          ],
          "return_type": "T_template_filter",
          "lineno": 661,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def template_filter(self, name: T_template_filter) -> T_template_filter: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "template_filter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, T_template_filter]",
          "lineno": 663,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def template_filter(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "template_filter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 667,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "callable",
            "self.add_template_filter"
          ],
          "docstring": "Decorate a function to register it as a custom Jinja filter. The name\nis optional. The decorator may be used without parentheses.\n\n.. code-block:: python\n\n    @app.template_filter(\"reverse\")\n    def reverse_filter(s):\n        return reversed(s)\n\nThe :meth:`add_template_filter` method may be used to register a\nfunction later rather than decorating.\n\n:param name: The name to register the filter as. If not given, uses the\n    function's name.",
          "code": "def template_filter(\n        self, name: T_template_filter | str | None = None\n    ) -> T_template_filter | t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"Decorate a function to register it as a custom Jinja filter. The name\n        is optional. The decorator may be used without parentheses.\n\n        .. code-block:: python\n\n            @app.template_filter(\"reverse\")\n            def reverse_filter(s):\n                return reversed(s)\n\n        The :meth:`add_template_filter` method may be used to register a\n        function later rather than decorating.\n\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n        \"\"\"\n        if callable(name):\n            self.add_template_filter(name)\n            return name\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_template_filter(f, name=name)\n            return f\n\n        return decorator",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "add_template_filter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "ft.TemplateFilterCallable"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 696,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f"
          ],
          "docstring": "Register a function to use as a custom Jinja filter.\n\nThe :meth:`template_filter` decorator can be used to register a function\nby decorating instead.\n\n:param f: The function to register.\n:param name: The name to register the filter as. If not given, uses the\n    function's name.",
          "code": "def add_template_filter(\n        self, f: ft.TemplateFilterCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja filter.\n\n        The :meth:`template_filter` decorator can be used to register a function\n        by decorating instead.\n\n        :param f: The function to register.\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "template_test",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "T_template_test"
            }
          ],
          "return_type": "T_template_test",
          "lineno": 711,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def template_test(self, name: T_template_test) -> T_template_test: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "template_test",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, T_template_test]",
          "lineno": 713,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def template_test(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_test], T_template_test]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "template_test",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 717,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "self.add_template_test",
            "callable"
          ],
          "docstring": "Decorate a function to register it as a custom Jinja test. The name\nis optional. The decorator may be used without parentheses.\n\n.. code-block:: python\n\n    @app.template_test(\"prime\")\n    def is_prime_test(n):\n        if n == 2:\n            return True\n        for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n            if n % i == 0:\n                return False\n      return True\n\nThe :meth:`add_template_test` method may be used to register a function\nlater rather than decorating.\n\n:param name: The name to register the filter as. If not given, uses the\n    function's name.\n\n.. versionadded:: 0.10",
          "code": "def template_test(\n        self, name: T_template_test | str | None = None\n    ) -> T_template_test | t.Callable[[T_template_test], T_template_test]:\n        \"\"\"Decorate a function to register it as a custom Jinja test. The name\n        is optional. The decorator may be used without parentheses.\n\n        .. code-block:: python\n\n            @app.template_test(\"prime\")\n            def is_prime_test(n):\n                if n == 2:\n                    return True\n                for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                    if n % i == 0:\n                        return False\n              return True\n\n        The :meth:`add_template_test` method may be used to register a function\n        later rather than decorating.\n\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if callable(name):\n            self.add_template_test(name)\n            return name\n\n        def decorator(f: T_template_test) -> T_template_test:\n            self.add_template_test(f, name=name)\n            return f\n\n        return decorator",
          "line_count": 34,
          "needs_llm_summary": true
        },
        {
          "name": "add_template_test",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "ft.TemplateTestCallable"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 753,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f"
          ],
          "docstring": "Register a function to use as a custom Jinja test.\n\nThe :meth:`template_test` decorator can be used to register a function\nby decorating instead.\n\n:param f: The function to register.\n:param name: The name to register the test as. If not given, uses the\n    function's name.\n\n.. versionadded:: 0.10",
          "code": "def add_template_test(\n        self, f: ft.TemplateTestCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja test.\n\n        The :meth:`template_test` decorator can be used to register a function\n        by decorating instead.\n\n        :param f: The function to register.\n        :param name: The name to register the test as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "template_global",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "T_template_global"
            }
          ],
          "return_type": "T_template_global",
          "lineno": 770,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def template_global(self, name: T_template_global) -> T_template_global: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "template_global",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, T_template_global]",
          "lineno": 772,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def template_global(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_global], T_template_global]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "template_global",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 776,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "self.add_template_global",
            "callable"
          ],
          "docstring": "Decorate a function to register it as a custom Jinja global. The name\nis optional. The decorator may be used without parentheses.\n\n.. code-block:: python\n\n    @app.template_global\n    def double(n):\n        return 2 * n\n\nThe :meth:`add_template_global` method may be used to register a\nfunction later rather than decorating.\n\n:param name: The name to register the global as. If not given, uses the\n    function's name.\n\n.. versionadded:: 0.10",
          "code": "def template_global(\n        self, name: T_template_global | str | None = None\n    ) -> T_template_global | t.Callable[[T_template_global], T_template_global]:\n        \"\"\"Decorate a function to register it as a custom Jinja global. The name\n        is optional. The decorator may be used without parentheses.\n\n        .. code-block:: python\n\n            @app.template_global\n            def double(n):\n                return 2 * n\n\n        The :meth:`add_template_global` method may be used to register a\n        function later rather than decorating.\n\n        :param name: The name to register the global as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if callable(name):\n            self.add_template_global(name)\n            return name\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_template_global(f, name=name)\n            return f\n\n        return decorator",
          "line_count": 29,
          "needs_llm_summary": true
        },
        {
          "name": "add_template_global",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "ft.TemplateGlobalCallable"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 807,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f"
          ],
          "docstring": "Register a function to use as a custom Jinja global.\n\nThe :meth:`template_global` decorator can be used to register a function\nby decorating instead.\n\n:param f: The function to register.\n:param name: The name to register the global as. If not given, uses the\n    function's name.\n\n.. versionadded:: 0.10",
          "code": "def add_template_global(\n        self, f: ft.TemplateGlobalCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja global.\n\n        The :meth:`template_global` decorator can be used to register a function\n        by decorating instead.\n\n        :param f: The function to register.\n        :param name: The name to register the global as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "teardown_appcontext",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_teardown"
            }
          ],
          "return_type": "T_teardown",
          "lineno": 824,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "self.teardown_appcontext_funcs.append"
          ],
          "docstring": "Registers a function to be called when the app context is popped. The\ncontext is popped at the end of a request, CLI command, or manual ``with``\nblock.\n\n.. code-block:: python\n\n    with app.app_context():\n        ...\n\nWhen the ``with`` block exits (or ``ctx.pop()`` is called), the\nteardown functions are called just before the app context is\nmade inactive.\n\nWhen a teardown function was called because of an unhandled\nexception it will be passed an error object. If an\n:meth:`errorhandler` is registered, it will handle the exception\nand the teardown will not receive it.\n\nTeardown functions must avoid raising exceptions. If they\nexecute code that might fail they must surround that code with a\n``try``/``except`` block and log any errors.\n\nThe return values of teardown functions are ignored.\n\n.. versionadded:: 0.9",
          "code": "def teardown_appcontext(self, f: T_teardown) -> T_teardown:\n        \"\"\"Registers a function to be called when the app context is popped. The\n        context is popped at the end of a request, CLI command, or manual ``with``\n        block.\n\n        .. code-block:: python\n\n            with app.app_context():\n                ...\n\n        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n        teardown functions are called just before the app context is\n        made inactive.\n\n        When a teardown function was called because of an unhandled\n        exception it will be passed an error object. If an\n        :meth:`errorhandler` is registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f",
          "line_count": 29,
          "needs_llm_summary": true
        },
        {
          "name": "shell_context_processor",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_shell_context_processor"
            }
          ],
          "return_type": "T_shell_context_processor",
          "lineno": 855,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "self.shell_context_processors.append"
          ],
          "docstring": "Registers a shell context processor function.\n\n.. versionadded:: 0.11",
          "code": "def shell_context_processor(\n        self, f: T_shell_context_processor\n    ) -> T_shell_context_processor:\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "_find_error_handler",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "e",
              "type": "Exception"
            },
            {
              "name": "blueprints",
              "type": "list[str]"
            }
          ],
          "return_type": "Any",
          "lineno": 865,
          "decorators": [],
          "is_async": false,
          "calls": [
            "type",
            "e",
            "handler_map.get",
            "cls",
            "self._get_exc_class_and_code"
          ],
          "docstring": "Return a registered error handler for an exception in this order:\nblueprint handler for a specific code, app handler for a specific code,\nblueprint handler for an exception class, app handler for an exception\nclass, or ``None`` if a suitable handler is not found.",
          "code": "def _find_error_handler(\n        self, e: Exception, blueprints: list[str]\n    ) -> ft.ErrorHandlerCallable | None:\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        names = (*blueprints, None)\n\n        for c in (code, None) if code is not None else (None,):\n            for name in names:\n                handler_map = self.error_handler_spec[name][c]\n\n                if not handler_map:\n                    continue\n\n                for cls in exc_class.__mro__:\n                    handler = handler_map.get(cls)\n\n                    if handler is not None:\n                        return handler\n        return None",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "trap_http_exception",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "e",
              "type": "Exception"
            }
          ],
          "return_type": "bool",
          "lineno": 890,
          "decorators": [],
          "is_async": false,
          "calls": [
            "BadRequestKeyError",
            "isinstance",
            "e",
            "BadRequest"
          ],
          "docstring": "Checks if an HTTP exception should be trapped or not.  By default\nthis will return ``False`` for all exceptions except for a bad request\nkey error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\nalso returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\nThis is called for all HTTP exceptions raised by a view function.\nIf it returns ``True`` for any exception the error handler for this\nexception is not called and it shows up as regular exception in the\ntraceback.  This is helpful for debugging implicitly raised HTTP\nexceptions.\n\n.. versionchanged:: 1.0\n    Bad request errors are not trapped by default in debug mode.\n\n.. versionadded:: 0.8",
          "code": "def trap_http_exception(self, e: Exception) -> bool:\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False",
          "line_count": 34,
          "needs_llm_summary": true
        },
        {
          "name": "should_ignore_error",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "error",
              "type": "Any"
            }
          ],
          "return_type": "bool",
          "lineno": 925,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "This is called to figure out if an error should be ignored\nor not as far as the teardown system is concerned.  If this\nfunction returns ``True`` then the teardown handlers will not be\npassed the error.\n\n.. versionadded:: 0.10",
          "code": "def should_ignore_error(self, error: BaseException | None) -> bool:\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "redirect",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "location",
              "type": "str"
            },
            {
              "name": "code",
              "type": "int"
            }
          ],
          "return_type": "BaseResponse",
          "lineno": 935,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_wz_redirect",
            "code",
            "location",
            "self.response_class"
          ],
          "docstring": "Create a redirect response object.\n\nThis is called by :func:`flask.redirect`, and can be called\ndirectly as well.\n\n:param location: The URL to redirect to.\n:param code: The status code for the redirect.\n\n.. versionadded:: 2.2\n    Moved from ``flask.redirect``, which calls this method.",
          "code": "def redirect(self, location: str, code: int = 302) -> BaseResponse:\n        \"\"\"Create a redirect response object.\n\n        This is called by :func:`flask.redirect`, and can be called\n        directly as well.\n\n        :param location: The URL to redirect to.\n        :param code: The status code for the redirect.\n\n        .. versionadded:: 2.2\n            Moved from ``flask.redirect``, which calls this method.\n        \"\"\"\n        return _wz_redirect(\n            location,\n            code=code,\n            Response=self.response_class,  # type: ignore[arg-type]\n        )",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "inject_url_defaults",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "endpoint",
              "type": "str"
            },
            {
              "name": "values",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "None",
          "lineno": 953,
          "decorators": [],
          "is_async": false,
          "calls": [
            "func",
            "chain",
            "endpoint",
            "names",
            "values",
            "endpoint.rpartition",
            "_split_blueprint_path",
            "reversed"
          ],
          "docstring": "Injects the URL defaults for the given endpoint directly into\nthe values dictionary passed.  This is used internally and\nautomatically called on URL building.\n\n.. versionadded:: 0.7",
          "code": "def inject_url_defaults(self, endpoint: str, values: dict[str, t.Any]) -> None:\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        names: t.Iterable[str | None] = (None,)\n\n        # url_for may be called outside a request context, parse the\n        # passed endpoint instead of using request.blueprints.\n        if \".\" in endpoint:\n            names = chain(\n                names, reversed(_split_blueprint_path(endpoint.rpartition(\".\")[0]))\n            )\n\n        for name in names:\n            if name in self.url_default_functions:\n                for func in self.url_default_functions[name]:\n                    func(endpoint, values)",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "handle_url_build_error",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "error",
              "type": "BuildError"
            },
            {
              "name": "endpoint",
              "type": "str"
            },
            {
              "name": "values",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "str",
          "lineno": 974,
          "decorators": [],
          "is_async": false,
          "calls": [
            "endpoint",
            "handler",
            "values",
            "e",
            "error",
            "sys.exc_info"
          ],
          "docstring": "Called by :meth:`.url_for` if a\n:exc:`~werkzeug.routing.BuildError` was raised. If this returns\na value, it will be returned by ``url_for``, otherwise the error\nwill be re-raised.\n\nEach function in :attr:`url_build_error_handlers` is called with\n``error``, ``endpoint`` and ``values``. If a function returns\n``None`` or raises a ``BuildError``, it is skipped. Otherwise,\nits return value is returned by ``url_for``.\n\n:param error: The active ``BuildError`` being handled.\n:param endpoint: The endpoint being built.\n:param values: The keyword arguments passed to ``url_for``.",
          "code": "def handle_url_build_error(\n        self, error: BuildError, endpoint: str, values: dict[str, t.Any]\n    ) -> str:\n        \"\"\"Called by :meth:`.url_for` if a\n        :exc:`~werkzeug.routing.BuildError` was raised. If this returns\n        a value, it will be returned by ``url_for``, otherwise the error\n        will be re-raised.\n\n        Each function in :attr:`url_build_error_handlers` is called with\n        ``error``, ``endpoint`` and ``values``. If a function returns\n        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,\n        its return value is returned by ``url_for``.\n\n        :param error: The active ``BuildError`` being handled.\n        :param endpoint: The endpoint being built.\n        :param values: The keyword arguments passed to ``url_for``.\n        \"\"\"\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                # make error available outside except block\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n\n        # Re-raise if called with an active exception, otherwise raise\n        # the passed in exception.\n        if error is sys.exc_info()[1]:\n            raise\n\n        raise error",
          "line_count": 33,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_template_filter"
            }
          ],
          "return_type": "T_template_filter",
          "lineno": 689,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "self.add_template_filter"
          ],
          "docstring": null,
          "code": "def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_template_filter(f, name=name)\n            return f",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_template_test"
            }
          ],
          "return_type": "T_template_test",
          "lineno": 746,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "self.add_template_test"
          ],
          "docstring": null,
          "code": "def decorator(f: T_template_test) -> T_template_test:\n            self.add_template_test(f, name=name)\n            return f",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_template_global"
            }
          ],
          "return_type": "T_template_global",
          "lineno": 800,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "self.add_template_global"
          ],
          "docstring": null,
          "code": "def decorator(f: T_template_global) -> T_template_global:\n            self.add_template_global(f, name=name)\n            return f",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "App",
          "methods": [
            "__init__",
            "_check_setup_finished",
            "name",
            "logger",
            "jinja_env",
            "create_jinja_environment",
            "make_config",
            "make_aborter",
            "auto_find_instance_path",
            "create_global_jinja_loader",
            "select_jinja_autoescape",
            "debug",
            "debug",
            "register_blueprint",
            "iter_blueprints",
            "add_url_rule",
            "template_filter",
            "template_filter",
            "template_filter",
            "add_template_filter",
            "template_test",
            "template_test",
            "template_test",
            "add_template_test",
            "template_global",
            "template_global",
            "template_global",
            "add_template_global",
            "teardown_appcontext",
            "shell_context_processor",
            "_find_error_handler",
            "trap_http_exception",
            "should_ignore_error",
            "redirect",
            "inject_url_defaults",
            "handle_url_build_error"
          ],
          "base_classes": [
            "Scaffold"
          ],
          "lineno": 59,
          "docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more.\n\nThe name of the package is used to resolve resources from inside the\npackage or the folder the module is contained in depending on if the\npackage parameter resolves to an actual python package (a folder with\nan :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\nFor more information about resource loading, see :func:`open_resource`.\n\nUsually you create a :class:`Flask` instance in your main module or\nin the :file:`__init__.py` file of your package like this::\n\n    from flask import Flask\n    app = Flask(__name__)\n\n.. admonition:: About the First Parameter\n\n    The idea of the first parameter is to give Flask an idea of what\n    belongs to your application.  This name is used to find resources\n    on the filesystem, can be used by extensions to improve debugging\n    information and a lot more.\n\n    So it's important what you provide there.  If you are using a single\n    module, `__name__` is always the correct value.  If you however are\n    using a package, it's usually recommended to hardcode the name of\n    your package there.\n\n    For example if your application is defined in :file:`yourapplication/app.py`\n    you should create it with one of the two versions below::\n\n        app = Flask('yourapplication')\n        app = Flask(__name__.split('.')[0])\n\n    Why is that?  The application will work even with `__name__`, thanks\n    to how resources are looked up.  However it will make debugging more\n    painful.  Certain extensions can make assumptions based on the\n    import name of your application.  For example the Flask-SQLAlchemy\n    extension will look for the code in your application that triggered\n    an SQL query in debug mode.  If the import name is not properly set\n    up, that debugging information is lost.  (For example it would only\n    pick up SQL queries in `yourapplication.app` and not\n    `yourapplication.views.frontend`)\n\n.. versionadded:: 0.7\n   The `static_url_path`, `static_folder`, and `template_folder`\n   parameters were added.\n\n.. versionadded:: 0.8\n   The `instance_path` and `instance_relative_config` parameters were\n   added.\n\n.. versionadded:: 0.11\n   The `root_path` parameter was added.\n\n.. versionadded:: 1.0\n   The ``host_matching`` and ``static_host`` parameters were added.\n\n.. versionadded:: 1.0\n   The ``subdomain_matching`` parameter was added. Subdomain\n   matching needs to be enabled manually now. Setting\n   :data:`SERVER_NAME` does not implicitly enable it.\n\n:param import_name: the name of the application package\n:param static_url_path: can be used to specify a different path for the\n                        static files on the web.  Defaults to the name\n                        of the `static_folder` folder.\n:param static_folder: The folder with static files that is served at\n    ``static_url_path``. Relative to the application ``root_path``\n    or an absolute path. Defaults to ``'static'``.\n:param static_host: the host to use when adding the static route.\n    Defaults to None. Required when using ``host_matching=True``\n    with a ``static_folder`` configured.\n:param host_matching: set ``url_map.host_matching`` attribute.\n    Defaults to False.\n:param subdomain_matching: consider the subdomain relative to\n    :data:`SERVER_NAME` when matching routes. Defaults to False.\n:param template_folder: the folder that contains the templates that should\n                        be used by the application.  Defaults to\n                        ``'templates'`` folder in the root path of the\n                        application.\n:param instance_path: An alternative instance path for the application.\n                      By default the folder ``'instance'`` next to the\n                      package or module is assumed to be the instance\n                      path.\n:param instance_relative_config: if set to ``True`` relative filenames\n                                 for loading the config are assumed to\n                                 be relative to the instance path instead\n                                 of the application root.\n:param root_path: The path to the root of the application files.\n    This should only be set manually when it can't be detected\n    automatically, such as for namespace packages."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "logging",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "datetime",
          "name": "timedelta",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "itertools",
          "name": "chain",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "Aborter",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "BadRequest",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "BadRequestKeyError",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "BuildError",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "Map",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "Rule",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "werkzeug.sansio.response",
          "name": "Response",
          "alias": null,
          "lineno": 16,
          "type": "from_import"
        },
        {
          "module": "werkzeug.utils",
          "name": "cached_property",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "werkzeug.utils",
          "name": "redirect",
          "alias": "_wz_redirect",
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "typing",
          "alias": "ft",
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "config",
          "name": "Config",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "config",
          "name": "ConfigAttribute",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "_AppCtxGlobals",
          "alias": null,
          "lineno": 23,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "_split_blueprint_path",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_debug_flag",
          "alias": null,
          "lineno": 25,
          "type": "from_import"
        },
        {
          "module": "json.provider",
          "name": "DefaultJSONProvider",
          "alias": null,
          "lineno": 26,
          "type": "from_import"
        },
        {
          "module": "json.provider",
          "name": "JSONProvider",
          "alias": null,
          "lineno": 27,
          "type": "from_import"
        },
        {
          "module": "logging",
          "name": "create_logger",
          "alias": null,
          "lineno": 28,
          "type": "from_import"
        },
        {
          "module": "templating",
          "name": "DispatchingJinjaLoader",
          "alias": null,
          "lineno": 29,
          "type": "from_import"
        },
        {
          "module": "templating",
          "name": "Environment",
          "alias": null,
          "lineno": 30,
          "type": "from_import"
        },
        {
          "module": "scaffold",
          "name": "_endpoint_from_view_func",
          "alias": null,
          "lineno": 31,
          "type": "from_import"
        },
        {
          "module": "scaffold",
          "name": "find_package",
          "alias": null,
          "lineno": 32,
          "type": "from_import"
        },
        {
          "module": "scaffold",
          "name": "Scaffold",
          "alias": null,
          "lineno": 33,
          "type": "from_import"
        },
        {
          "module": "scaffold",
          "name": "setupmethod",
          "alias": null,
          "lineno": 34,
          "type": "from_import"
        },
        {
          "module": "werkzeug.wrappers",
          "name": "Response",
          "alias": "BaseResponse",
          "lineno": 37,
          "type": "from_import"
        },
        {
          "module": "testing",
          "name": "FlaskClient",
          "alias": null,
          "lineno": 39,
          "type": "from_import"
        },
        {
          "module": "testing",
          "name": "FlaskCliRunner",
          "alias": null,
          "lineno": 40,
          "type": "from_import"
        },
        {
          "module": "blueprints",
          "name": "Blueprint",
          "alias": null,
          "lineno": 41,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "T_shell_context_processor",
          "assigned_to": "t.TypeVar",
          "lineno": 43
        },
        {
          "name": "T_teardown",
          "assigned_to": "t.TypeVar",
          "lineno": 46
        },
        {
          "name": "T_template_filter",
          "assigned_to": "t.TypeVar",
          "lineno": 47
        },
        {
          "name": "T_template_global",
          "assigned_to": "t.TypeVar",
          "lineno": 48
        },
        {
          "name": "T_template_test",
          "assigned_to": "t.TypeVar",
          "lineno": 49
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar",
          "ft.TeardownCallable",
          "ft.TemplateFilterCallable",
          "ft.TemplateTestCallable",
          "ft.ShellContextProcessorCallable",
          "ft.TemplateGlobalCallable"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing",
          "logging",
          "json",
          "os",
          "datetime",
          "itertools",
          "sys"
        ],
        "third_party": {
          "other": [
            "__future__",
            "werkzeug",
            "config",
            "ctx",
            "helpers",
            "templating",
            "scaffold",
            "testing",
            "blueprints"
          ]
        },
        "tech_stack": []
      },
      "line_count": 1007
    },
    "src/flask/sansio/blueprints.py": {
      "filepath": "../flask/src/flask/sansio/blueprints.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "blueprint",
              "type": "Blueprint"
            },
            {
              "name": "app",
              "type": "App"
            },
            {
              "name": "options",
              "type": "t.Any"
            },
            {
              "name": "first_registration",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 41,
          "decorators": [],
          "is_async": false,
          "calls": [
            "options",
            "blueprint",
            "self.options.get",
            "self.blueprint.url_prefix",
            "self.blueprint.subdomain",
            "dict",
            "subdomain",
            "first_registration",
            "self.blueprint.url_values_defaults",
            "self.url_defaults.update",
            "blueprint.name",
            "app",
            "url_prefix"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        blueprint: Blueprint,\n        app: App,\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))",
          "line_count": 45,
          "needs_llm_summary": true
        },
        {
          "name": "add_url_rule",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            },
            {
              "name": "endpoint",
              "type": "Any"
            },
            {
              "name": "view_func",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 87,
          "decorators": [],
          "is_async": false,
          "calls": [
            "options",
            "rule.lstrip",
            "options.setdefault",
            "_endpoint_from_view_func",
            "self.subdomain",
            "self.url_defaults",
            "view_func",
            "defaults",
            "unknown.lstrip",
            "rule",
            "dict",
            "options.pop",
            "unknown.join",
            "self.url_prefix",
            "self.url_prefix.rstrip",
            "self.app.add_url_rule"
          ],
          "docstring": "A helper method to register a rule (and optionally a view function)\nto the application.  The endpoint is automatically prefixed with the\nblueprint's name.",
          "code": "def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix is not None:\n            if rule:\n                rule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\n            else:\n                rule = self.url_prefix\n        options.setdefault(\"subdomain\", self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "str"
            },
            {
              "name": "import_name",
              "type": "str"
            },
            {
              "name": "static_folder",
              "type": "Any"
            },
            {
              "name": "static_url_path",
              "type": "Any"
            },
            {
              "name": "template_folder",
              "type": "Any"
            },
            {
              "name": "url_prefix",
              "type": "Any"
            },
            {
              "name": "subdomain",
              "type": "Any"
            },
            {
              "name": "url_defaults",
              "type": "Any"
            },
            {
              "name": "root_path",
              "type": "Any"
            },
            {
              "name": "cli_group",
              "type": "Any"
            }
          ],
          "return_type": null,
          "lineno": 174,
          "decorators": [],
          "is_async": false,
          "calls": [
            "url_defaults",
            "ValueError",
            "root_path",
            "unknown.__init__",
            "static_folder",
            "super",
            "template_folder",
            "import_name",
            "cli_group",
            "subdomain",
            "static_url_path",
            "name",
            "url_prefix"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore[assignment]\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if not name:\n            raise ValueError(\"'name' may not be empty.\")\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: list[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: list[tuple[Blueprint, dict[str, t.Any]]] = []",
          "line_count": 38,
          "needs_llm_summary": true
        },
        {
          "name": "_check_setup_finished",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f_name",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 213,
          "decorators": [],
          "is_async": false,
          "calls": [
            "AssertionError"
          ],
          "docstring": null,
          "code": "def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "record",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "func",
              "type": "DeferredSetupFunction"
            }
          ],
          "return_type": "None",
          "lineno": 224,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.deferred_functions.append",
            "func"
          ],
          "docstring": "Registers a function that is called when the blueprint is\nregistered on the application.  This function is called with the\nstate as argument as returned by the :meth:`make_setup_state`\nmethod.",
          "code": "def record(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        self.deferred_functions.append(func)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "record_once",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "func",
              "type": "DeferredSetupFunction"
            }
          ],
          "return_type": "None",
          "lineno": 233,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "state",
            "func",
            "wrapper",
            "update_wrapper",
            "self.record"
          ],
          "docstring": "Works like :meth:`record` but wraps the function in another\nfunction that will ensure the function is only called once.  If the\nblueprint is registered a second time on the application, the\nfunction passed is not called.",
          "code": "def record_once(self, func: DeferredSetupFunction) -> None:\n        \"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"\n\n        def wrapper(state: BlueprintSetupState) -> None:\n            if state.first_registration:\n                func(state)\n\n        self.record(update_wrapper(wrapper, func))",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "make_setup_state",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "App"
            },
            {
              "name": "options",
              "type": "dict[str, t.Any]"
            },
            {
              "name": "first_registration",
              "type": "bool"
            }
          ],
          "return_type": "BlueprintSetupState",
          "lineno": 246,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "options",
            "first_registration",
            "BlueprintSetupState",
            "app"
          ],
          "docstring": "Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\nobject that is later passed to the register callback functions.\nSubclasses can override this to return a subclass of the setup state.",
          "code": "def make_setup_state(\n        self, app: App, options: dict[str, t.Any], first_registration: bool = False\n    ) -> BlueprintSetupState:\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "register_blueprint",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "blueprint",
              "type": "Blueprint"
            }
          ],
          "return_type": "None",
          "lineno": 256,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self._blueprints.append",
            "ValueError"
          ],
          "docstring": "Register a :class:`~flask.Blueprint` on this blueprint. Keyword\narguments passed to this method will override the defaults set\non the blueprint.\n\n.. versionchanged:: 2.0.1\n    The ``name`` option can be used to change the (pre-dotted)\n    name the blueprint is registered with. This allows the same\n    blueprint to be registered multiple times with unique names\n    for ``url_for``.\n\n.. versionadded:: 2.0",
          "code": "def register_blueprint(self, blueprint: Blueprint, **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n        arguments passed to this method will override the defaults set\n        on the blueprint.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        if blueprint is self:\n            raise ValueError(\"Cannot register a blueprint on itself\")\n        self._blueprints.append((blueprint, options))",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "register",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "App"
            },
            {
              "name": "options",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "None",
          "lineno": 273,
          "decorators": [],
          "is_async": false,
          "calls": [
            "deferred",
            "bp_url_prefix.lstrip",
            "options.get",
            "ValueError",
            "app.cli.commands.update",
            "self.make_setup_state",
            "state.subdomain",
            "options",
            "bp_url_prefix",
            "any",
            "self._merge_blueprint_funcs",
            "unknown.lstrip",
            "state.url_prefix.rstrip",
            "blueprint.url_prefix",
            "name",
            "blueprint.register",
            "cli_resolved_group",
            "app.cli.add_command",
            "state",
            "self.send_static_file",
            "self.cli",
            "self.cli.commands",
            "blueprint.subdomain",
            "self.cli_group",
            "app.blueprints.values",
            "self",
            "first_bp_registration",
            "state.add_url_rule",
            "bp_subdomain",
            "state.url_prefix",
            "self.name",
            "bp_options.copy",
            "bp_options.get",
            "bp_options",
            "app"
          ],
          "docstring": "Called by :meth:`Flask.register_blueprint` to register all\nviews and callbacks registered on the blueprint with the\napplication. Creates a :class:`.BlueprintSetupState` and calls\neach :meth:`record` callback with it.\n\n:param app: The application this blueprint is being registered\n    with.\n:param options: Keyword arguments forwarded from\n    :meth:`~Flask.register_blueprint`.\n\n.. versionchanged:: 2.3\n    Nested blueprints now correctly apply subdomains.\n\n.. versionchanged:: 2.1\n    Registering the same blueprint with the same name multiple\n    times is an error.\n\n.. versionchanged:: 2.0.1\n    Nested blueprints are registered with their dotted name.\n    This allows different blueprints with the same name to be\n    nested at different locations.\n\n.. versionchanged:: 2.0.1\n    The ``name`` option can be used to change the (pre-dotted)\n    name the blueprint is registered with. This allows the same\n    blueprint to be registered multiple times with unique names\n    for ``url_for``.",
          "code": "def register(self, app: App, options: dict[str, t.Any]) -> None:\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n        views and callbacks registered on the blueprint with the\n        application. Creates a :class:`.BlueprintSetupState` and calls\n        each :meth:`record` callback with it.\n\n        :param app: The application this blueprint is being registered\n            with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n\n        .. versionchanged:: 2.3\n            Nested blueprints now correctly apply subdomains.\n\n        .. versionchanged:: 2.1\n            Registering the same blueprint with the same name multiple\n            times is an error.\n\n        .. versionchanged:: 2.0.1\n            Nested blueprints are registered with their dotted name.\n            This allows different blueprints with the same name to be\n            nested at different locations.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n        \"\"\"\n        name_prefix = options.get(\"name_prefix\", \"\")\n        self_name = options.get(\"name\", self.name)\n        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n\n        if name in app.blueprints:\n            bp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\n            existing_at = f\" '{name}'\" if self_name != name else \"\"\n\n            raise ValueError(\n                f\"The name '{self_name}' is already registered for\"\n                f\" {bp_desc} blueprint{existing_at}. Use 'name=' to\"\n                f\" provide a unique name.\"\n            )\n\n        first_bp_registration = not any(bp is self for bp in app.blueprints.values())\n        first_name_registration = name not in app.blueprints\n\n        app.blueprints[name] = self\n        self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_bp_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                view_func=self.send_static_file,  # type: ignore[attr-defined]\n                endpoint=\"static\",\n            )\n\n        # Merge blueprint data into parent.\n        if first_bp_registration or first_name_registration:\n            self._merge_blueprint_funcs(app, name)\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n\n        if self.cli.commands:\n            if cli_resolved_group is None:\n                app.cli.commands.update(self.cli.commands)\n            elif cli_resolved_group is _sentinel:\n                self.cli.name = name\n                app.cli.add_command(self.cli)\n            else:\n                self.cli.name = cli_resolved_group\n                app.cli.add_command(self.cli)\n\n        for blueprint, bp_options in self._blueprints:\n            bp_options = bp_options.copy()\n            bp_url_prefix = bp_options.get(\"url_prefix\")\n            bp_subdomain = bp_options.get(\"subdomain\")\n\n            if bp_subdomain is None:\n                bp_subdomain = blueprint.subdomain\n\n            if state.subdomain is not None and bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\n            elif bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain\n            elif state.subdomain is not None:\n                bp_options[\"subdomain\"] = state.subdomain\n\n            if bp_url_prefix is None:\n                bp_url_prefix = blueprint.url_prefix\n\n            if state.url_prefix is not None and bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = (\n                    state.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n                )\n            elif bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = bp_url_prefix\n            elif state.url_prefix is not None:\n                bp_options[\"url_prefix\"] = state.url_prefix\n\n            bp_options[\"name_prefix\"] = name\n            blueprint.register(app, bp_options)",
          "line_count": 105,
          "needs_llm_summary": true
        },
        {
          "name": "_merge_blueprint_funcs",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "App"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 379,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.url_default_functions",
            "self.after_request_funcs",
            "app.template_context_processors",
            "app.teardown_request_funcs",
            "value.items",
            "app.before_request_funcs",
            "self.view_functions.items",
            "bp_dict.items",
            "app.after_request_funcs",
            "self.error_handler_spec.items",
            "defaultdict",
            "code_values.items",
            "self.teardown_request_funcs",
            "self.template_context_processors",
            "self.before_request_funcs",
            "app.url_default_functions",
            "extend",
            "func",
            "self.url_value_preprocessors",
            "value",
            "dict",
            "values",
            "app.url_value_preprocessors",
            "unknown.extend"
          ],
          "docstring": null,
          "code": "def _merge_blueprint_funcs(self, app: App, name: str) -> None:\n        def extend(\n            bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],\n            parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],\n        ) -> None:\n            for key, values in bp_dict.items():\n                key = name if key is None else f\"{name}.{key}\"\n                parent_dict[key].extend(values)\n\n        for key, value in self.error_handler_spec.items():\n            key = name if key is None else f\"{name}.{key}\"\n            value = defaultdict(\n                dict,\n                {\n                    code: {exc_class: func for exc_class, func in code_values.items()}\n                    for code, code_values in value.items()\n                },\n            )\n            app.error_handler_spec[key] = value\n\n        for endpoint, func in self.view_functions.items():\n            app.view_functions[endpoint] = func\n\n        extend(self.before_request_funcs, app.before_request_funcs)\n        extend(self.after_request_funcs, app.after_request_funcs)\n        extend(\n            self.teardown_request_funcs,\n            app.teardown_request_funcs,\n        )\n        extend(self.url_default_functions, app.url_default_functions)\n        extend(self.url_value_preprocessors, app.url_value_preprocessors)\n        extend(self.template_context_processors, app.template_context_processors)",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "add_url_rule",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            },
            {
              "name": "endpoint",
              "type": "Any"
            },
            {
              "name": "view_func",
              "type": "Any"
            },
            {
              "name": "provide_automatic_options",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 413,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "options",
            "ValueError",
            "endpoint",
            "hasattr",
            "view_func",
            "s.add_url_rule",
            "rule",
            "self.record",
            "provide_automatic_options"
          ],
          "docstring": "Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\nfull documentation.\n\nThe URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\nused with :func:`url_for`, is prefixed with the blueprint's name.",
          "code": "def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\n        full documentation.\n\n        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\n        used with :func:`url_for`, is prefixed with the blueprint's name.\n        \"\"\"\n        if endpoint and \".\" in endpoint:\n            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n\n        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n\n        self.record(\n            lambda s: s.add_url_rule(\n                rule,\n                endpoint,\n                view_func,\n                provide_automatic_options=provide_automatic_options,\n                **options,\n            )\n        )",
          "line_count": 29,
          "needs_llm_summary": true
        },
        {
          "name": "app_template_filter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "T_template_filter"
            }
          ],
          "return_type": "T_template_filter",
          "lineno": 444,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def app_template_filter(self, name: T_template_filter) -> T_template_filter: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "app_template_filter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, T_template_filter]",
          "lineno": 446,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def app_template_filter(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "app_template_filter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 450,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "callable",
            "self.add_app_template_filter"
          ],
          "docstring": "Decorate a function to register it as a custom Jinja filter. The name\nis optional. The decorator may be used without parentheses.\n\nThe :meth:`add_app_template_filter` method may be used to register a\nfunction later rather than decorating.\n\nThe filter is available in all templates, not only those under this\nblueprint. Equivalent to :meth:`.Flask.template_filter`.\n\n:param name: The name to register the filter as. If not given, uses the\n    function's name.",
          "code": "def app_template_filter(\n        self, name: T_template_filter | str | None = None\n    ) -> T_template_filter | t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"Decorate a function to register it as a custom Jinja filter. The name\n        is optional. The decorator may be used without parentheses.\n\n        The :meth:`add_app_template_filter` method may be used to register a\n        function later rather than decorating.\n\n        The filter is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.template_filter`.\n\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n        \"\"\"\n        if callable(name):\n            self.add_app_template_filter(name)\n            return name\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_app_template_filter(f, name=name)\n            return f\n\n        return decorator",
          "line_count": 24,
          "needs_llm_summary": true
        },
        {
          "name": "add_app_template_filter",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "ft.TemplateFilterCallable"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 476,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "state.app.add_template_filter",
            "register_template_filter",
            "self.record_once",
            "name"
          ],
          "docstring": "Register a function to use as a custom Jinja filter.\n\nThe :meth:`app_template_filter` decorator can be used to register a\nfunction by decorating instead.\n\nThe filter is available in all templates, not only those under this\nblueprint. Equivalent to :meth:`.Flask.add_template_filter`.\n\n:param f: The function to register.\n:param name: The name to register the filter as. If not given, uses the\n    function's name.",
          "code": "def add_app_template_filter(\n        self, f: ft.TemplateFilterCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja filter.\n\n        The :meth:`app_template_filter` decorator can be used to register a\n        function by decorating instead.\n\n        The filter is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.add_template_filter`.\n\n        :param f: The function to register.\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n        \"\"\"\n\n        def register_template_filter(state: BlueprintSetupState) -> None:\n            state.app.add_template_filter(f, name=name)\n\n        self.record_once(register_template_filter)",
          "line_count": 20,
          "needs_llm_summary": true
        },
        {
          "name": "app_template_test",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "T_template_test"
            }
          ],
          "return_type": "T_template_test",
          "lineno": 498,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def app_template_test(self, name: T_template_test) -> T_template_test: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "app_template_test",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, T_template_test]",
          "lineno": 500,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def app_template_test(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_test], T_template_test]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "app_template_test",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 504,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "callable",
            "self.add_app_template_test"
          ],
          "docstring": "Decorate a function to register it as a custom Jinja test. The name\nis optional. The decorator may be used without parentheses.\n\nThe :meth:`add_app_template_test` method may be used to register a\nfunction later rather than decorating.\n\nThe test is available in all templates, not only those under this\nblueprint. Equivalent to :meth:`.Flask.template_test`.\n\n:param name: The name to register the filter as. If not given, uses the\n    function's name.\n\n.. versionadded:: 0.10",
          "code": "def app_template_test(\n        self, name: T_template_test | str | None = None\n    ) -> T_template_test | t.Callable[[T_template_test], T_template_test]:\n        \"\"\"Decorate a function to register it as a custom Jinja test. The name\n        is optional. The decorator may be used without parentheses.\n\n        The :meth:`add_app_template_test` method may be used to register a\n        function later rather than decorating.\n\n        The test is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.template_test`.\n\n        :param name: The name to register the filter as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if callable(name):\n            self.add_app_template_test(name)\n            return name\n\n        def decorator(f: T_template_test) -> T_template_test:\n            self.add_app_template_test(f, name=name)\n            return f\n\n        return decorator",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "add_app_template_test",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "ft.TemplateTestCallable"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 532,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "register_template_test",
            "self.record_once",
            "name",
            "state.app.add_template_test"
          ],
          "docstring": "Register a function to use as a custom Jinja test.\n\nThe :meth:`app_template_test` decorator can be used to register a\nfunction by decorating instead.\n\nThe test is available in all templates, not only those under this\nblueprint. Equivalent to :meth:`.Flask.add_template_test`.\n\n:param f: The function to register.\n:param name: The name to register the test as. If not given, uses the\n    function's name.\n\n.. versionadded:: 0.10",
          "code": "def add_app_template_test(\n        self, f: ft.TemplateTestCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja test.\n\n        The :meth:`app_template_test` decorator can be used to register a\n        function by decorating instead.\n\n        The test is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.add_template_test`.\n\n        :param f: The function to register.\n        :param name: The name to register the test as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n\n        def register_template_test(state: BlueprintSetupState) -> None:\n            state.app.add_template_test(f, name=name)\n\n        self.record_once(register_template_test)",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "app_template_global",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "T_template_global"
            }
          ],
          "return_type": "T_template_global",
          "lineno": 556,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def app_template_global(self, name: T_template_global) -> T_template_global: ...",
          "line_count": 1,
          "needs_llm_summary": false
        },
        {
          "name": "app_template_global",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, T_template_global]",
          "lineno": 558,
          "decorators": [
            {
              "name": "t.overload",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def app_template_global(\n        self, name: str | None = None\n    ) -> t.Callable[[T_template_global], T_template_global]: ...",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "app_template_global",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "Any",
          "lineno": 562,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.add_app_template_global",
            "name",
            "callable",
            "f"
          ],
          "docstring": "Decorate a function to register it as a custom Jinja global. The name\nis optional. The decorator may be used without parentheses.\n\nThe :meth:`add_app_template_global` method may be used to register a\nfunction later rather than decorating.\n\nThe global is available in all templates, not only those under this\nblueprint. Equivalent to :meth:`.Flask.template_global`.\n\n:param name: The name to register the global as. If not given, uses the\n    function's name.\n\n.. versionadded:: 0.10",
          "code": "def app_template_global(\n        self, name: T_template_global | str | None = None\n    ) -> T_template_global | t.Callable[[T_template_global], T_template_global]:\n        \"\"\"Decorate a function to register it as a custom Jinja global. The name\n        is optional. The decorator may be used without parentheses.\n\n        The :meth:`add_app_template_global` method may be used to register a\n        function later rather than decorating.\n\n        The global is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.template_global`.\n\n        :param name: The name to register the global as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if callable(name):\n            self.add_app_template_global(name)\n            return name\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_app_template_global(f, name=name)\n            return f\n\n        return decorator",
          "line_count": 26,
          "needs_llm_summary": true
        },
        {
          "name": "add_app_template_global",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "ft.TemplateGlobalCallable"
            },
            {
              "name": "name",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 590,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "register_template_global",
            "f",
            "state.app.add_template_global",
            "self.record_once",
            "name"
          ],
          "docstring": "Register a function to use as a custom Jinja global.\n\nThe :meth:`app_template_global` decorator can be used to register a function\nby decorating instead.\n\nThe global is available in all templates, not only those under this\nblueprint. Equivalent to :meth:`.Flask.add_template_global`.\n\n:param f: The function to register.\n:param name: The name to register the global as. If not given, uses the\n    function's name.\n\n.. versionadded:: 0.10",
          "code": "def add_app_template_global(\n        self, f: ft.TemplateGlobalCallable, name: str | None = None\n    ) -> None:\n        \"\"\"Register a function to use as a custom Jinja global.\n\n        The :meth:`app_template_global` decorator can be used to register a function\n        by decorating instead.\n\n        The global is available in all templates, not only those under this\n        blueprint. Equivalent to :meth:`.Flask.add_template_global`.\n\n        :param f: The function to register.\n        :param name: The name to register the global as. If not given, uses the\n            function's name.\n\n        .. versionadded:: 0.10\n        \"\"\"\n\n        def register_template_global(state: BlueprintSetupState) -> None:\n            state.app.add_template_global(f, name=name)\n\n        self.record_once(register_template_global)",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "before_app_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_before_request"
            }
          ],
          "return_type": "T_before_request",
          "lineno": 614,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append",
            "self.record_once",
            "s.app.before_request_funcs.setdefault"
          ],
          "docstring": "Like :meth:`before_request`, but before every request, not only those handled\nby the blueprint. Equivalent to :meth:`.Flask.before_request`.",
          "code": "def before_app_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Like :meth:`before_request`, but before every request, not only those handled\n        by the blueprint. Equivalent to :meth:`.Flask.before_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)\n        )\n        return f",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "after_app_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_after_request"
            }
          ],
          "return_type": "T_after_request",
          "lineno": 624,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "s.app.after_request_funcs.setdefault",
            "unknown.append",
            "self.record_once"
          ],
          "docstring": "Like :meth:`after_request`, but after every request, not only those handled\nby the blueprint. Equivalent to :meth:`.Flask.after_request`.",
          "code": "def after_app_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Like :meth:`after_request`, but after every request, not only those handled\n        by the blueprint. Equivalent to :meth:`.Flask.after_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)\n        )\n        return f",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "teardown_app_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_teardown"
            }
          ],
          "return_type": "T_teardown",
          "lineno": 634,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append",
            "self.record_once",
            "s.app.teardown_request_funcs.setdefault"
          ],
          "docstring": "Like :meth:`teardown_request`, but after every request, not only those\nhandled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.",
          "code": "def teardown_app_request(self, f: T_teardown) -> T_teardown:\n        \"\"\"Like :meth:`teardown_request`, but after every request, not only those\n        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)\n        )\n        return f",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "app_context_processor",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_template_context_processor"
            }
          ],
          "return_type": "T_template_context_processor",
          "lineno": 644,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append",
            "self.record_once",
            "s.app.template_context_processors.setdefault"
          ],
          "docstring": "Like :meth:`context_processor`, but for templates rendered by every view, not\nonly by the blueprint. Equivalent to :meth:`.Flask.context_processor`.",
          "code": "def app_context_processor(\n        self, f: T_template_context_processor\n    ) -> T_template_context_processor:\n        \"\"\"Like :meth:`context_processor`, but for templates rendered by every view, not\n        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)\n        )\n        return f",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "app_errorhandler",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "code",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, T_error_handler]",
          "lineno": 656,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "code",
            "from_blueprint",
            "state.app.errorhandler",
            "self.record_once"
          ],
          "docstring": "Like :meth:`errorhandler`, but for every request, not only those handled by\nthe blueprint. Equivalent to :meth:`.Flask.errorhandler`.",
          "code": "def app_errorhandler(\n        self, code: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n        \"\"\"Like :meth:`errorhandler`, but for every request, not only those handled by\n        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.\n        \"\"\"\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            def from_blueprint(state: BlueprintSetupState) -> None:\n                state.app.errorhandler(code)(f)\n\n            self.record_once(from_blueprint)\n            return f\n\n        return decorator",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "app_url_value_preprocessor",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_url_value_preprocessor"
            }
          ],
          "return_type": "T_url_value_preprocessor",
          "lineno": 673,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append",
            "self.record_once",
            "s.app.url_value_preprocessors.setdefault"
          ],
          "docstring": "Like :meth:`url_value_preprocessor`, but for every request, not only those\nhandled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.",
          "code": "def app_url_value_preprocessor(\n        self, f: T_url_value_preprocessor\n    ) -> T_url_value_preprocessor:\n        \"\"\"Like :meth:`url_value_preprocessor`, but for every request, not only those\n        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)\n        )\n        return f",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "app_url_defaults",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_url_defaults"
            }
          ],
          "return_type": "T_url_defaults",
          "lineno": 685,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append",
            "s.app.url_default_functions.setdefault",
            "self.record_once"
          ],
          "docstring": "Like :meth:`url_defaults`, but for every request, not only those handled by\nthe blueprint. Equivalent to :meth:`.Flask.url_defaults`.",
          "code": "def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:\n        \"\"\"Like :meth:`url_defaults`, but for every request, not only those handled by\n        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n        )\n        return f",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "wrapper",
          "args": [
            {
              "name": "state",
              "type": "BlueprintSetupState"
            }
          ],
          "return_type": "None",
          "lineno": 240,
          "decorators": [],
          "is_async": false,
          "calls": [
            "func",
            "state"
          ],
          "docstring": null,
          "code": "def wrapper(state: BlueprintSetupState) -> None:\n            if state.first_registration:\n                func(state)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "extend",
          "args": [
            {
              "name": "bp_dict",
              "type": "dict[ft.AppOrBlueprintKey, list[t.Any]]"
            },
            {
              "name": "parent_dict",
              "type": "dict[ft.AppOrBlueprintKey, list[t.Any]]"
            }
          ],
          "return_type": "None",
          "lineno": 380,
          "decorators": [],
          "is_async": false,
          "calls": [
            "values",
            "bp_dict.items",
            "unknown.extend"
          ],
          "docstring": null,
          "code": "def extend(\n            bp_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],\n            parent_dict: dict[ft.AppOrBlueprintKey, list[t.Any]],\n        ) -> None:\n            for key, values in bp_dict.items():\n                key = name if key is None else f\"{name}.{key}\"\n                parent_dict[key].extend(values)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_template_filter"
            }
          ],
          "return_type": "T_template_filter",
          "lineno": 469,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "self.add_app_template_filter"
          ],
          "docstring": null,
          "code": "def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_app_template_filter(f, name=name)\n            return f",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "register_template_filter",
          "args": [
            {
              "name": "state",
              "type": "BlueprintSetupState"
            }
          ],
          "return_type": "None",
          "lineno": 492,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "state.app.add_template_filter"
          ],
          "docstring": null,
          "code": "def register_template_filter(state: BlueprintSetupState) -> None:\n            state.app.add_template_filter(f, name=name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_template_test"
            }
          ],
          "return_type": "T_template_test",
          "lineno": 525,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "self.add_app_template_test"
          ],
          "docstring": null,
          "code": "def decorator(f: T_template_test) -> T_template_test:\n            self.add_app_template_test(f, name=name)\n            return f",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "register_template_test",
          "args": [
            {
              "name": "state",
              "type": "BlueprintSetupState"
            }
          ],
          "return_type": "None",
          "lineno": 550,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "name",
            "state.app.add_template_test"
          ],
          "docstring": null,
          "code": "def register_template_test(state: BlueprintSetupState) -> None:\n            state.app.add_template_test(f, name=name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_template_global"
            }
          ],
          "return_type": "T_template_global",
          "lineno": 583,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self.add_app_template_global",
            "name"
          ],
          "docstring": null,
          "code": "def decorator(f: T_template_global) -> T_template_global:\n            self.add_app_template_global(f, name=name)\n            return f",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "register_template_global",
          "args": [
            {
              "name": "state",
              "type": "BlueprintSetupState"
            }
          ],
          "return_type": "None",
          "lineno": 608,
          "decorators": [],
          "is_async": false,
          "calls": [
            "state.app.add_template_global",
            "name",
            "f"
          ],
          "docstring": null,
          "code": "def register_template_global(state: BlueprintSetupState) -> None:\n            state.app.add_template_global(f, name=name)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_error_handler"
            }
          ],
          "return_type": "T_error_handler",
          "lineno": 663,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "code",
            "from_blueprint",
            "state.app.errorhandler",
            "self.record_once"
          ],
          "docstring": null,
          "code": "def decorator(f: T_error_handler) -> T_error_handler:\n            def from_blueprint(state: BlueprintSetupState) -> None:\n                state.app.errorhandler(code)(f)\n\n            self.record_once(from_blueprint)\n            return f",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "from_blueprint",
          "args": [
            {
              "name": "state",
              "type": "BlueprintSetupState"
            }
          ],
          "return_type": "None",
          "lineno": 664,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "state.app.errorhandler",
            "code"
          ],
          "docstring": null,
          "code": "def from_blueprint(state: BlueprintSetupState) -> None:\n                state.app.errorhandler(code)(f)",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "BlueprintSetupState",
          "methods": [
            "__init__",
            "add_url_rule"
          ],
          "base_classes": [],
          "lineno": 34,
          "docstring": "Temporary holder object for registering a blueprint with the\napplication.  An instance of this class is created by the\n:meth:`~flask.Blueprint.make_setup_state` method and later passed\nto all register callback functions."
        },
        {
          "name": "Blueprint",
          "methods": [
            "__init__",
            "_check_setup_finished",
            "record",
            "record_once",
            "make_setup_state",
            "register_blueprint",
            "register",
            "_merge_blueprint_funcs",
            "add_url_rule",
            "app_template_filter",
            "app_template_filter",
            "app_template_filter",
            "add_app_template_filter",
            "app_template_test",
            "app_template_test",
            "app_template_test",
            "add_app_template_test",
            "app_template_global",
            "app_template_global",
            "app_template_global",
            "add_app_template_global",
            "before_app_request",
            "after_app_request",
            "teardown_app_request",
            "app_context_processor",
            "app_errorhandler",
            "app_url_value_preprocessor",
            "app_url_defaults"
          ],
          "base_classes": [
            "Scaffold"
          ],
          "lineno": 119,
          "docstring": "Represents a blueprint, a collection of routes and other\napp-related functions that can be registered on a real application\nlater.\n\nA blueprint is an object that allows defining application functions\nwithout requiring an application object ahead of time. It uses the\nsame decorators as :class:`~flask.Flask`, but defers the need for an\napplication by recording them for later registration.\n\nDecorating a function with a blueprint creates a deferred function\nthat is called with :class:`~flask.blueprints.BlueprintSetupState`\nwhen the blueprint is registered on an application.\n\nSee :doc:`/blueprints` for more information.\n\n:param name: The name of the blueprint. Will be prepended to each\n    endpoint name.\n:param import_name: The name of the blueprint package, usually\n    ``__name__``. This helps locate the ``root_path`` for the\n    blueprint.\n:param static_folder: A folder with static files that should be\n    served by the blueprint's static route. The path is relative to\n    the blueprint's root path. Blueprint static files are disabled\n    by default.\n:param static_url_path: The url to serve static files from.\n    Defaults to ``static_folder``. If the blueprint does not have\n    a ``url_prefix``, the app's static route will take precedence,\n    and the blueprint's static files won't be accessible.\n:param template_folder: A folder with templates that should be added\n    to the app's template search path. The path is relative to the\n    blueprint's root path. Blueprint templates are disabled by\n    default. Blueprint templates have a lower precedence than those\n    in the app's templates folder.\n:param url_prefix: A path to prepend to all of the blueprint's URLs,\n    to make them distinct from the rest of the app's routes.\n:param subdomain: A subdomain that blueprint routes will match on by\n    default.\n:param url_defaults: A dict of default values that blueprint routes\n    will receive by default.\n:param root_path: By default, the blueprint will automatically set\n    this based on ``import_name``. In certain situations this\n    automatic detection can fail, so the path can be specified\n    manually instead.\n\n.. versionchanged:: 1.1.0\n    Blueprints have a ``cli`` group to register nested CLI commands.\n    The ``cli_group`` parameter controls the name of the group under\n    the ``flask`` command.\n\n.. versionadded:: 0.7"
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "collections",
          "name": "defaultdict",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "typing",
          "alias": "ft",
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "scaffold",
          "name": "_endpoint_from_view_func",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "scaffold",
          "name": "_sentinel",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "scaffold",
          "name": "Scaffold",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "scaffold",
          "name": "setupmethod",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "app",
          "name": "App",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "DeferredSetupFunction",
          "assigned_to": null,
          "lineno": 17
        },
        {
          "name": "T_after_request",
          "assigned_to": "t.TypeVar",
          "lineno": 18
        },
        {
          "name": "T_before_request",
          "assigned_to": "t.TypeVar",
          "lineno": 19
        },
        {
          "name": "T_error_handler",
          "assigned_to": "t.TypeVar",
          "lineno": 20
        },
        {
          "name": "T_teardown",
          "assigned_to": "t.TypeVar",
          "lineno": 21
        },
        {
          "name": "T_template_context_processor",
          "assigned_to": "t.TypeVar",
          "lineno": 22
        },
        {
          "name": "T_template_filter",
          "assigned_to": "t.TypeVar",
          "lineno": 25
        },
        {
          "name": "T_template_global",
          "assigned_to": "t.TypeVar",
          "lineno": 26
        },
        {
          "name": "T_template_test",
          "assigned_to": "t.TypeVar",
          "lineno": 27
        },
        {
          "name": "T_url_defaults",
          "assigned_to": "t.TypeVar",
          "lineno": 28
        },
        {
          "name": "T_url_value_preprocessor",
          "assigned_to": "t.TypeVar",
          "lineno": 29
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "ft.TemplateContextProcessorCallable",
          "ft.URLValuePreprocessorCallable",
          "t.TypeVar",
          "ft.TeardownCallable",
          "ft.ErrorHandlerCallable",
          "ft.BeforeRequestCallable",
          "ft.TemplateFilterCallable",
          "ft.TemplateTestCallable",
          "ft.URLDefaultCallable",
          "ft.TemplateGlobalCallable"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "os",
          "functools",
          "typing",
          "collections"
        ],
        "third_party": {
          "other": [
            "__future__",
            "scaffold",
            "app"
          ]
        },
        "tech_stack": []
      },
      "line_count": 693
    },
    "src/flask/sansio/scaffold.py": {
      "filepath": "../flask/src/flask/sansio/scaffold.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "setupmethod",
          "args": [
            {
              "name": "f",
              "type": "F"
            }
          ],
          "return_type": "F",
          "lineno": 42,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self",
            "kwargs",
            "F",
            "t.cast",
            "f.__name__",
            "self._check_setup_finished",
            "update_wrapper",
            "f_name",
            "wrapper_func"
          ],
          "docstring": null,
          "code": "def setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "_endpoint_from_view_func",
          "args": [
            {
              "name": "view_func",
              "type": "ft.RouteCallable"
            }
          ],
          "return_type": "str",
          "lineno": 701,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Internal helper that returns the default endpoint for a given\nfunction.  This always is the function name.",
          "code": "def _endpoint_from_view_func(view_func: ft.RouteCallable) -> str:\n    \"\"\"Internal helper that returns the default endpoint for a given\n    function.  This always is the function name.\n    \"\"\"\n    assert view_func is not None, \"expected view func if endpoint is not provided.\"\n    return view_func.__name__",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "_find_package_path",
          "args": [
            {
              "name": "import_name",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 709,
          "decorators": [],
          "is_async": false,
          "calls": [
            "next",
            "ValueError",
            "search_location",
            "import_name.partition",
            "root_mod_name",
            "os.path.commonpath",
            "package_spec.submodule_search_locations",
            "import_name",
            "os.getcwd",
            "pathlib.Path",
            "os.path.dirname",
            "root_spec.origin",
            "location",
            "importlib.util.find_spec",
            "package_path.is_relative_to"
          ],
          "docstring": "Find the path that contains the package or module.",
          "code": "def _find_package_path(import_name: str) -> str:\n    \"\"\"Find the path that contains the package or module.\"\"\"\n    root_mod_name, _, _ = import_name.partition(\".\")\n\n    try:\n        root_spec = importlib.util.find_spec(root_mod_name)\n\n        if root_spec is None:\n            raise ValueError(\"not found\")\n    except (ImportError, ValueError):\n        # ImportError: the machinery told us it does not exist\n        # ValueError:\n        #    - the module name was invalid\n        #    - the module name is __main__\n        #    - we raised `ValueError` due to `root_spec` being `None`\n        return os.getcwd()\n\n    if root_spec.submodule_search_locations:\n        if root_spec.origin is None or root_spec.origin == \"namespace\":\n            # namespace package\n            package_spec = importlib.util.find_spec(import_name)\n\n            if package_spec is not None and package_spec.submodule_search_locations:\n                # Pick the path in the namespace that contains the submodule.\n                package_path = pathlib.Path(\n                    os.path.commonpath(package_spec.submodule_search_locations)\n                )\n                search_location = next(\n                    location\n                    for location in root_spec.submodule_search_locations\n                    if package_path.is_relative_to(location)\n                )\n            else:\n                # Pick the first path.\n                search_location = root_spec.submodule_search_locations[0]\n\n            return os.path.dirname(search_location)\n        else:\n            # package with __init__.py\n            return os.path.dirname(os.path.dirname(root_spec.origin))\n    else:\n        # module\n        return os.path.dirname(root_spec.origin)",
          "line_count": 43,
          "needs_llm_summary": true
        },
        {
          "name": "find_package",
          "args": [
            {
              "name": "import_name",
              "type": "str"
            }
          ],
          "return_type": "tuple[Any, str]",
          "lineno": 754,
          "decorators": [],
          "is_async": false,
          "calls": [
            "folder.lower",
            "unknown.lower",
            "pathlib.PurePath",
            "os.path.basename",
            "unknown.is_relative_to",
            "package_path",
            "_find_package_path",
            "os.path.abspath",
            "os.path.split",
            "import_name",
            "site_folder.lower",
            "parent",
            "os.path.dirname",
            "sys.prefix",
            "py_prefix",
            "site_parent"
          ],
          "docstring": "Find the prefix that a package is installed under, and the path\nthat it would be imported from.\n\nThe prefix is the directory containing the standard directory\nhierarchy (lib, bin, etc.). If the package is not installed to the\nsystem (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n``None`` is returned.\n\nThe path is the entry in :attr:`sys.path` that contains the package\nfor import. If the package is not installed, it's assumed that the\npackage was imported from the current working directory.",
          "code": "def find_package(import_name: str) -> tuple[str | None, str]:\n    \"\"\"Find the prefix that a package is installed under, and the path\n    that it would be imported from.\n\n    The prefix is the directory containing the standard directory\n    hierarchy (lib, bin, etc.). If the package is not installed to the\n    system (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n    ``None`` is returned.\n\n    The path is the entry in :attr:`sys.path` that contains the package\n    for import. If the package is not installed, it's assumed that the\n    package was imported from the current working directory.\n    \"\"\"\n    package_path = _find_package_path(import_name)\n    py_prefix = os.path.abspath(sys.prefix)\n\n    # installed to the system\n    if pathlib.PurePath(package_path).is_relative_to(py_prefix):\n        return py_prefix, package_path\n\n    site_parent, site_folder = os.path.split(package_path)\n\n    # installed to a virtualenv\n    if site_folder.lower() == \"site-packages\":\n        parent, folder = os.path.split(site_parent)\n\n        # Windows (prefix/lib/site-packages)\n        if folder.lower() == \"lib\":\n            return parent, package_path\n\n        # Unix (prefix/lib/pythonX.Y/site-packages)\n        if os.path.basename(parent).lower() == \"lib\":\n            return os.path.dirname(parent), package_path\n\n        # something else (prefix/site-packages)\n        return site_parent, package_path\n\n    # not installed\n    return None, package_path",
          "line_count": 39,
          "needs_llm_summary": true
        },
        {
          "name": "wrapper_func",
          "args": [
            {
              "name": "self",
              "type": "Scaffold"
            }
          ],
          "return_type": "t.Any",
          "lineno": 45,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self",
            "kwargs",
            "self._check_setup_finished",
            "f_name"
          ],
          "docstring": null,
          "code": "def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "import_name",
              "type": "str"
            },
            {
              "name": "static_folder",
              "type": "Any"
            },
            {
              "name": "static_url_path",
              "type": "Any"
            },
            {
              "name": "template_folder",
              "type": "Any"
            },
            {
              "name": "root_path",
              "type": "Any"
            }
          ],
          "return_type": null,
          "lineno": 75,
          "decorators": [],
          "is_async": false,
          "calls": [
            "get_root_path",
            "root_path",
            "static_folder",
            "self.import_name",
            "template_folder",
            "import_name",
            "dict",
            "static_url_path",
            "list",
            "defaultdict"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        root_path: str | None = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n        self.static_folder = static_folder\n        self.static_url_path = static_url_path\n\n        #: The path to the templates folder, relative to\n        #: :attr:`root_path`, to add to the template loader. ``None`` if\n        #: templates should not be added.\n        self.template_folder = template_folder\n\n        if root_path is None:\n            root_path = get_root_path(self.import_name)\n\n        #: Absolute path to the package on the filesystem. Used to look\n        #: up resources contained in the package.\n        self.root_path = root_path\n\n        #: A dictionary mapping endpoint names to view functions.\n        #:\n        #: To register a view function, use the :meth:`route` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.view_functions: dict[str, ft.RouteCallable] = {}\n\n        #: A data structure of registered error handlers, in the format\n        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is\n        #: the name of a blueprint the handlers are active for, or\n        #: ``None`` for all requests. The ``code`` key is the HTTP\n        #: status code for ``HTTPException``, or ``None`` for\n        #: other exceptions. The innermost dictionary maps exception\n        #: classes to handler functions.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.error_handler_spec: dict[\n            ft.AppOrBlueprintKey,\n            dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]],\n        ] = defaultdict(lambda: defaultdict(dict))\n\n        #: A data structure of functions to call at the beginning of\n        #: each request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`before_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.before_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`after_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.after_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.AfterRequestCallable[t.Any]]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request even if an exception is raised, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`teardown_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.teardown_request_funcs: dict[\n            ft.AppOrBlueprintKey, list[ft.TeardownCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to pass extra context\n        #: values when rendering templates, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`context_processor`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.template_context_processors: dict[\n            ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]\n        ] = defaultdict(list, {None: [_default_template_ctx_processor]})\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments passed to the view function, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the\n        #: :meth:`url_value_preprocessor` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_value_preprocessors: dict[\n            ft.AppOrBlueprintKey,\n            list[ft.URLValuePreprocessorCallable],\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments when generating URLs, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`url_defaults`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_default_functions: dict[\n            ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]\n        ] = defaultdict(list)",
          "line_count": 141,
          "needs_llm_summary": true
        },
        {
          "name": "__repr__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "lineno": 217,
          "decorators": [],
          "is_async": false,
          "calls": [
            "type",
            "self"
          ],
          "docstring": null,
          "code": "def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self.name!r}>\"",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "_check_setup_finished",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f_name",
              "type": "str"
            }
          ],
          "return_type": "None",
          "lineno": 220,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def _check_setup_finished(self, f_name: str) -> None:\n        raise NotImplementedError",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "static_folder",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 224,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.root_path",
            "self._static_folder",
            "os.path.join"
          ],
          "docstring": "The absolute path to the configured static folder. ``None``\nif no static folder is set.",
          "code": "def static_folder(self) -> str | None:\n        \"\"\"The absolute path to the configured static folder. ``None``\n        if no static folder is set.\n        \"\"\"\n        if self._static_folder is not None:\n            return os.path.join(self.root_path, self._static_folder)\n        else:\n            return None",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "static_folder",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 234,
          "decorators": [
            {
              "name": "static_folder.setter",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "value",
            "unknown.rstrip",
            "os.fspath"
          ],
          "docstring": null,
          "code": "def static_folder(self, value: str | os.PathLike[str] | None) -> None:\n        if value is not None:\n            value = os.fspath(value).rstrip(r\"\\/\")\n\n        self._static_folder = value",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "has_static_folder",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 241,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "``True`` if :attr:`static_folder` is set.\n\n.. versionadded:: 0.5",
          "code": "def has_static_folder(self) -> bool:\n        \"\"\"``True`` if :attr:`static_folder` is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        return self.static_folder is not None",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "static_url_path",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 249,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "os.path.basename",
            "unknown.rstrip",
            "self.static_folder"
          ],
          "docstring": "The URL prefix that the static route will be accessible from.\n\nIf it was not configured during init, it is derived from\n:attr:`static_folder`.",
          "code": "def static_url_path(self) -> str | None:\n        \"\"\"The URL prefix that the static route will be accessible from.\n\n        If it was not configured during init, it is derived from\n        :attr:`static_folder`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "static_url_path",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 265,
          "decorators": [
            {
              "name": "static_url_path.setter",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "value",
            "value.rstrip"
          ],
          "docstring": null,
          "code": "def static_url_path(self, value: str | None) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "jinja_loader",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 272,
          "decorators": [
            {
              "name": "cached_property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.root_path",
            "FileSystemLoader",
            "self.template_folder",
            "os.path.join"
          ],
          "docstring": "The Jinja loader for this object's templates. By default this\nis a class :class:`jinja2.loaders.FileSystemLoader` to\n:attr:`template_folder` if it is set.\n\n.. versionadded:: 0.5",
          "code": "def jinja_loader(self) -> BaseLoader | None:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "_method_route",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "method",
              "type": "str"
            },
            {
              "name": "rule",
              "type": "str"
            },
            {
              "name": "options",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "t.Callable[Any, T_route]",
          "lineno": 284,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.route",
            "options",
            "rule",
            "TypeError"
          ],
          "docstring": null,
          "code": "def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict[str, t.Any],\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "get",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            }
          ],
          "return_type": "t.Callable[Any, T_route]",
          "lineno": 296,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "options",
            "rule",
            "self._method_route"
          ],
          "docstring": "Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n.. versionadded:: 2.0",
          "code": "def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "post",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            }
          ],
          "return_type": "t.Callable[Any, T_route]",
          "lineno": 304,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "options",
            "rule",
            "self._method_route"
          ],
          "docstring": "Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n.. versionadded:: 2.0",
          "code": "def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "put",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            }
          ],
          "return_type": "t.Callable[Any, T_route]",
          "lineno": 312,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "options",
            "rule",
            "self._method_route"
          ],
          "docstring": "Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n.. versionadded:: 2.0",
          "code": "def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PUT\", rule, options)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "delete",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            }
          ],
          "return_type": "t.Callable[Any, T_route]",
          "lineno": 320,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "options",
            "rule",
            "self._method_route"
          ],
          "docstring": "Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n.. versionadded:: 2.0",
          "code": "def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "patch",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            }
          ],
          "return_type": "t.Callable[Any, T_route]",
          "lineno": 328,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "options",
            "rule",
            "self._method_route"
          ],
          "docstring": "Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n.. versionadded:: 2.0",
          "code": "def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "route",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            }
          ],
          "return_type": "t.Callable[Any, T_route]",
          "lineno": 336,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "options",
            "endpoint",
            "rule",
            "options.pop",
            "self.add_url_rule"
          ],
          "docstring": "Decorate a view function to register it with the given URL\nrule and options. Calls :meth:`add_url_rule`, which has more\ndetails about the implementation.\n\n.. code-block:: python\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello, World!\"\n\nSee :ref:`url-route-registrations`.\n\nThe endpoint name for the route defaults to the name of the view\nfunction if the ``endpoint`` parameter isn't passed.\n\nThe ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n``OPTIONS`` are added automatically.\n\n:param rule: The URL rule string.\n:param options: Extra options passed to the\n    :class:`~werkzeug.routing.Rule` object.",
          "code": "def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"Hello, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator",
          "line_count": 30,
          "needs_llm_summary": true
        },
        {
          "name": "add_url_rule",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "rule",
              "type": "str"
            },
            {
              "name": "endpoint",
              "type": "Any"
            },
            {
              "name": "view_func",
              "type": "Any"
            },
            {
              "name": "provide_automatic_options",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 368,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "Register a rule for routing incoming requests and building\nURLs. The :meth:`route` decorator is a shortcut to call this\nwith the ``view_func`` argument. These are equivalent:\n\n.. code-block:: python\n\n    @app.route(\"/\")\n    def index():\n        ...\n\n.. code-block:: python\n\n    def index():\n        ...\n\n    app.add_url_rule(\"/\", view_func=index)\n\nSee :ref:`url-route-registrations`.\n\nThe endpoint name for the route defaults to the name of the view\nfunction if the ``endpoint`` parameter isn't passed. An error\nwill be raised if a function has already been registered for the\nendpoint.\n\nThe ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\nalways added automatically, and ``OPTIONS`` is added\nautomatically by default.\n\n``view_func`` does not necessarily need to be passed, but if the\nrule should participate in routing an endpoint name must be\nassociated with a view function at some point with the\n:meth:`endpoint` decorator.\n\n.. code-block:: python\n\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    @app.endpoint(\"index\")\n    def index():\n        ...\n\nIf ``view_func`` has a ``required_methods`` attribute, those\nmethods are added to the passed and automatic methods. If it\nhas a ``provide_automatic_methods`` attribute, it is used as the\ndefault if the parameter is not passed.\n\n:param rule: The URL rule string.\n:param endpoint: The endpoint name to associate with the rule\n    and view function. Used when routing and building URLs.\n    Defaults to ``view_func.__name__``.\n:param view_func: The view function to associate with the\n    endpoint name.\n:param provide_automatic_options: Add the ``OPTIONS`` method and\n    respond to ``OPTIONS`` requests automatically.\n:param options: Extra options passed to the\n    :class:`~werkzeug.routing.Rule` object.",
          "code": "def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and building\n        URLs. The :meth:`route` decorator is a shortcut to call this\n        with the ``view_func`` argument. These are equivalent:\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                ...\n\n        .. code-block:: python\n\n            def index():\n                ...\n\n            app.add_url_rule(\"/\", view_func=index)\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed. An error\n        will be raised if a function has already been registered for the\n        endpoint.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n        always added automatically, and ``OPTIONS`` is added\n        automatically by default.\n\n        ``view_func`` does not necessarily need to be passed, but if the\n        rule should participate in routing an endpoint name must be\n        associated with a view function at some point with the\n        :meth:`endpoint` decorator.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/\", endpoint=\"index\")\n\n            @app.endpoint(\"index\")\n            def index():\n                ...\n\n        If ``view_func`` has a ``required_methods`` attribute, those\n        methods are added to the passed and automatic methods. If it\n        has a ``provide_automatic_methods`` attribute, it is used as the\n        default if the parameter is not passed.\n\n        :param rule: The URL rule string.\n        :param endpoint: The endpoint name to associate with the rule\n            and view function. Used when routing and building URLs.\n            Defaults to ``view_func.__name__``.\n        :param view_func: The view function to associate with the\n            endpoint name.\n        :param provide_automatic_options: Add the ``OPTIONS`` method and\n            respond to ``OPTIONS`` requests automatically.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError",
          "line_count": 66,
          "needs_llm_summary": true
        },
        {
          "name": "endpoint",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "endpoint",
              "type": "str"
            }
          ],
          "return_type": "t.Callable[Any, F]",
          "lineno": 436,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f"
          ],
          "docstring": "Decorate a view function to register it for the given\nendpoint. Used if a rule is added without a ``view_func`` with\n:meth:`add_url_rule`.\n\n.. code-block:: python\n\n    app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n    @app.endpoint(\"example\")\n    def example():\n        ...\n\n:param endpoint: The endpoint name to associate with the view\n    function.",
          "code": "def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator",
          "line_count": 22,
          "needs_llm_summary": true
        },
        {
          "name": "before_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_before_request"
            }
          ],
          "return_type": "T_before_request",
          "lineno": 460,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append",
            "self.before_request_funcs.setdefault"
          ],
          "docstring": "Register a function to run before each request.\n\nFor example, this can be used to open a database connection, or\nto load the logged in user from the session.\n\n.. code-block:: python\n\n    @app.before_request\n    def load_user():\n        if \"user_id\" in session:\n            g.user = db.session.get(session[\"user_id\"])\n\nThe function will be called without any arguments. If it returns\na non-``None`` value, the value is handled as if it was the\nreturn value from the view, and further request handling is\nstopped.\n\nThis is available on both app and blueprint objects. When used on an app, this\nexecutes before every request. When used on a blueprint, this executes before\nevery request that the blueprint handles. To register with a blueprint and\nexecute before every request, use :meth:`.Blueprint.before_app_request`.",
          "code": "def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user from the session.\n\n        .. code-block:: python\n\n            @app.before_request\n            def load_user():\n                if \"user_id\" in session:\n                    g.user = db.session.get(session[\"user_id\"])\n\n        The function will be called without any arguments. If it returns\n        a non-``None`` value, the value is handled as if it was the\n        return value from the view, and further request handling is\n        stopped.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes before every request. When used on a blueprint, this executes before\n        every request that the blueprint handles. To register with a blueprint and\n        execute before every request, use :meth:`.Blueprint.before_app_request`.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f",
          "line_count": 25,
          "needs_llm_summary": true
        },
        {
          "name": "after_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_after_request"
            }
          ],
          "return_type": "T_after_request",
          "lineno": 487,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append",
            "self.after_request_funcs.setdefault"
          ],
          "docstring": "Register a function to run after each request to this object.\n\nThe function is called with the response object, and must return\na response object. This allows the functions to modify or\nreplace the response before it is sent.\n\nIf a function raises an exception, any remaining\n``after_request`` functions will not be called. Therefore, this\nshould not be used for actions that must execute, such as to\nclose resources. Use :meth:`teardown_request` for that.\n\nThis is available on both app and blueprint objects. When used on an app, this\nexecutes after every request. When used on a blueprint, this executes after\nevery request that the blueprint handles. To register with a blueprint and\nexecute after every request, use :meth:`.Blueprint.after_app_request`.",
          "code": "def after_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Register a function to run after each request to this object.\n\n        The function is called with the response object, and must return\n        a response object. This allows the functions to modify or\n        replace the response before it is sent.\n\n        If a function raises an exception, any remaining\n        ``after_request`` functions will not be called. Therefore, this\n        should not be used for actions that must execute, such as to\n        close resources. Use :meth:`teardown_request` for that.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes after every request. When used on a blueprint, this executes after\n        every request that the blueprint handles. To register with a blueprint and\n        execute after every request, use :meth:`.Blueprint.after_app_request`.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "teardown_request",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_teardown"
            }
          ],
          "return_type": "T_teardown",
          "lineno": 508,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "self.teardown_request_funcs.setdefault",
            "unknown.append"
          ],
          "docstring": "Register a function to be called when the request context is\npopped. Typically, this happens at the end of each request, but\ncontexts may be pushed manually during testing.\n\n.. code-block:: python\n\n    with app.test_request_context():\n        ...\n\nWhen the ``with`` block exits (or ``ctx.pop()`` is called), the\nteardown functions are called just before the request context is\nmade inactive.\n\nWhen a teardown function was called because of an unhandled\nexception it will be passed an error object. If an\n:meth:`errorhandler` is registered, it will handle the exception\nand the teardown will not receive it.\n\nTeardown functions must avoid raising exceptions. If they\nexecute code that might fail they must surround that code with a\n``try``/``except`` block and log any errors.\n\nThe return values of teardown functions are ignored.\n\nThis is available on both app and blueprint objects. When used on an app, this\nexecutes after every request. When used on a blueprint, this executes after\nevery request that the blueprint handles. To register with a blueprint and\nexecute after every request, use :meth:`.Blueprint.teardown_app_request`.",
          "code": "def teardown_request(self, f: T_teardown) -> T_teardown:\n        \"\"\"Register a function to be called when the request context is\n        popped. Typically, this happens at the end of each request, but\n        contexts may be pushed manually during testing.\n\n        .. code-block:: python\n\n            with app.test_request_context():\n                ...\n\n        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n        teardown functions are called just before the request context is\n        made inactive.\n\n        When a teardown function was called because of an unhandled\n        exception it will be passed an error object. If an\n        :meth:`errorhandler` is registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes after every request. When used on a blueprint, this executes after\n        every request that the blueprint handles. To register with a blueprint and\n        execute after every request, use :meth:`.Blueprint.teardown_app_request`.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f",
          "line_count": 32,
          "needs_llm_summary": true
        },
        {
          "name": "context_processor",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_template_context_processor"
            }
          ],
          "return_type": "T_template_context_processor",
          "lineno": 542,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append"
          ],
          "docstring": "Registers a template context processor function. These functions run before\nrendering a template. The keys of the returned dict are added as variables\navailable in the template.\n\nThis is available on both app and blueprint objects. When used on an app, this\nis called for every rendered template. When used on a blueprint, this is called\nfor templates rendered from the blueprint's views. To register with a blueprint\nand affect every template, use :meth:`.Blueprint.app_context_processor`.",
          "code": "def context_processor(\n        self,\n        f: T_template_context_processor,\n    ) -> T_template_context_processor:\n        \"\"\"Registers a template context processor function. These functions run before\n        rendering a template. The keys of the returned dict are added as variables\n        available in the template.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every rendered template. When used on a blueprint, this is called\n        for templates rendered from the blueprint's views. To register with a blueprint\n        and affect every template, use :meth:`.Blueprint.app_context_processor`.\n        \"\"\"\n        self.template_context_processors[None].append(f)\n        return f",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "url_value_preprocessor",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_url_value_preprocessor"
            }
          ],
          "return_type": "T_url_value_preprocessor",
          "lineno": 559,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append"
          ],
          "docstring": "Register a URL value preprocessor function for all view\nfunctions in the application. These functions will be called before the\n:meth:`before_request` functions.\n\nThe function can modify the values captured from the matched url before\nthey are passed to the view. For example, this can be used to pop a\ncommon language code value and place it in ``g`` rather than pass it to\nevery view.\n\nThe function is passed the endpoint name and values dict. The return\nvalue is ignored.\n\nThis is available on both app and blueprint objects. When used on an app, this\nis called for every request. When used on a blueprint, this is called for\nrequests that the blueprint handles. To register with a blueprint and affect\nevery request, use :meth:`.Blueprint.app_url_value_preprocessor`.",
          "code": "def url_value_preprocessor(\n        self,\n        f: T_url_value_preprocessor,\n    ) -> T_url_value_preprocessor:\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every request. When used on a blueprint, this is called for\n        requests that the blueprint handles. To register with a blueprint and affect\n        every request, use :meth:`.Blueprint.app_url_value_preprocessor`.\n        \"\"\"\n        self.url_value_preprocessors[None].append(f)\n        return f",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "url_defaults",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "f",
              "type": "T_url_defaults"
            }
          ],
          "return_type": "T_url_defaults",
          "lineno": 584,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "unknown.append"
          ],
          "docstring": "Callback function for URL defaults for all view functions of the\napplication.  It's called with the endpoint and values and should\nupdate the values passed in place.\n\nThis is available on both app and blueprint objects. When used on an app, this\nis called for every request. When used on a blueprint, this is called for\nrequests that the blueprint handles. To register with a blueprint and affect\nevery request, use :meth:`.Blueprint.app_url_defaults`.",
          "code": "def url_defaults(self, f: T_url_defaults) -> T_url_defaults:\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every request. When used on a blueprint, this is called for\n        requests that the blueprint handles. To register with a blueprint and affect\n        every request, use :meth:`.Blueprint.app_url_defaults`.\n        \"\"\"\n        self.url_default_functions[None].append(f)\n        return f",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "errorhandler",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "code_or_exception",
              "type": "Any"
            }
          ],
          "return_type": "t.Callable[Any, T_error_handler]",
          "lineno": 598,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "self.register_error_handler",
            "code_or_exception"
          ],
          "docstring": "Register a function to handle errors by code or exception class.\n\nA decorator that is used to register a function given an\nerror code.  Example::\n\n    @app.errorhandler(404)\n    def page_not_found(error):\n        return 'This page does not exist', 404\n\nYou can also register handlers for arbitrary exceptions::\n\n    @app.errorhandler(DatabaseError)\n    def special_exception_handler(error):\n        return 'Database connection failed', 500\n\nThis is available on both app and blueprint objects. When used on an app, this\ncan handle errors from every request. When used on a blueprint, this can handle\nerrors from requests that the blueprint handles. To register with a blueprint\nand affect every request, use :meth:`.Blueprint.app_errorhandler`.\n\n.. versionadded:: 0.7\n    Use :meth:`register_error_handler` instead of modifying\n    :attr:`error_handler_spec` directly, for application wide error\n    handlers.\n\n.. versionadded:: 0.7\n   One can now additionally also register custom exception types\n   that do not necessarily have to be a subclass of the\n   :class:`~werkzeug.exceptions.HTTPException` class.\n\n:param code_or_exception: the code as integer for the handler, or\n                          an arbitrary exception",
          "code": "def errorhandler(\n        self, code_or_exception: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        This is available on both app and blueprint objects. When used on an app, this\n        can handle errors from every request. When used on a blueprint, this can handle\n        errors from requests that the blueprint handles. To register with a blueprint\n        and affect every request, use :meth:`.Blueprint.app_errorhandler`.\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            self.register_error_handler(code_or_exception, f)\n            return f\n\n        return decorator",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "register_error_handler",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "code_or_exception",
              "type": "Any"
            },
            {
              "name": "f",
              "type": "ft.ErrorHandlerCallable"
            }
          ],
          "return_type": "None",
          "lineno": 642,
          "decorators": [
            {
              "name": "setupmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "f",
            "code_or_exception",
            "self._get_exc_class_and_code"
          ],
          "docstring": "Alternative error attach function to the :meth:`errorhandler`\ndecorator that is more straightforward to use for non decorator\nusage.\n\n.. versionadded:: 0.7",
          "code": "def register_error_handler(\n        self,\n        code_or_exception: type[Exception] | int,\n        f: ft.ErrorHandlerCallable,\n    ) -> None:\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        self.error_handler_spec[None][code][exc_class] = f",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "_get_exc_class_and_code",
          "args": [
            {
              "name": "exc_class_or_code",
              "type": "Any"
            }
          ],
          "return_type": "tuple[type[Exception], Any]",
          "lineno": 657,
          "decorators": [
            {
              "name": "staticmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "isinstance",
            "ValueError",
            "TypeError",
            "HTTPException",
            "exc_class",
            "exc_class_or_code",
            "issubclass",
            "int",
            "Exception"
          ],
          "docstring": "Get the exception class being handled. For HTTP status codes\nor ``HTTPException`` subclasses, return both the exception and\nstatus code.\n\n:param exc_class_or_code: Any exception class, or an HTTP status\n    code as an integer.",
          "code": "def _get_exc_class_and_code(\n        exc_class_or_code: type[Exception] | int,\n    ) -> tuple[type[Exception], int | None]:\n        \"\"\"Get the exception class being handled. For HTTP status codes\n        or ``HTTPException`` subclasses, return both the exception and\n        status code.\n\n        :param exc_class_or_code: Any exception class, or an HTTP status\n            code as an integer.\n        \"\"\"\n        exc_class: type[Exception]\n\n        if isinstance(exc_class_or_code, int):\n            try:\n                exc_class = default_exceptions[exc_class_or_code]\n            except KeyError:\n                raise ValueError(\n                    f\"'{exc_class_or_code}' is not a recognized HTTP\"\n                    \" error code. Use a subclass of HTTPException with\"\n                    \" that code instead.\"\n                ) from None\n        else:\n            exc_class = exc_class_or_code\n\n        if isinstance(exc_class, Exception):\n            raise TypeError(\n                f\"{exc_class!r} is an instance, not a class. Handlers\"\n                \" can only be registered for Exception classes or HTTP\"\n                \" error codes.\"\n            )\n\n        if not issubclass(exc_class, Exception):\n            raise ValueError(\n                f\"'{exc_class.__name__}' is not a subclass of Exception.\"\n                \" Handlers can only be registered for Exception classes\"\n                \" or HTTP error codes.\"\n            )\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None",
          "line_count": 42,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_route"
            }
          ],
          "return_type": "T_route",
          "lineno": 360,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "options",
            "endpoint",
            "rule",
            "options.pop",
            "self.add_url_rule"
          ],
          "docstring": null,
          "code": "def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f",
          "line_count": 4,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "F"
            }
          ],
          "return_type": "F",
          "lineno": 453,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f"
          ],
          "docstring": null,
          "code": "def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "decorator",
          "args": [
            {
              "name": "f",
              "type": "T_error_handler"
            }
          ],
          "return_type": "T_error_handler",
          "lineno": 635,
          "decorators": [],
          "is_async": false,
          "calls": [
            "f",
            "self.register_error_handler",
            "code_or_exception"
          ],
          "docstring": null,
          "code": "def decorator(f: T_error_handler) -> T_error_handler:\n            self.register_error_handler(code_or_exception, f)\n            return f",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "Scaffold",
          "methods": [
            "__init__",
            "__repr__",
            "_check_setup_finished",
            "static_folder",
            "static_folder",
            "has_static_folder",
            "static_url_path",
            "static_url_path",
            "jinja_loader",
            "_method_route",
            "get",
            "post",
            "put",
            "delete",
            "patch",
            "route",
            "add_url_rule",
            "endpoint",
            "before_request",
            "after_request",
            "teardown_request",
            "context_processor",
            "url_value_preprocessor",
            "url_defaults",
            "errorhandler",
            "register_error_handler",
            "_get_exc_class_and_code"
          ],
          "base_classes": [],
          "lineno": 52,
          "docstring": "Common behavior shared between :class:`~flask.Flask` and\n:class:`~flask.blueprints.Blueprint`.\n\n:param import_name: The import name of the module where this object\n    is defined. Usually :attr:`__name__` should be used.\n:param static_folder: Path to a folder of static files to serve.\n    If this is set, a static route will be added.\n:param static_url_path: URL prefix for the static route.\n:param template_folder: Path to a folder containing template files.\n    for rendering. If this is set, a Jinja loader will be added.\n:param root_path: The path that static, template, and resource files\n    are relative to. Typically not set, it is discovered based on\n    the ``import_name``.\n\n.. versionadded:: 2.0"
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "importlib.util",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "os",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "pathlib",
          "alias": null,
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "sys",
          "alias": null,
          "lineno": 6,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 7,
          "type": "import"
        },
        {
          "module": "collections",
          "name": "defaultdict",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "functools",
          "name": "update_wrapper",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "jinja2",
          "name": "BaseLoader",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "jinja2",
          "name": "FileSystemLoader",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "default_exceptions",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "HTTPException",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "werkzeug.utils",
          "name": "cached_property",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "typing",
          "alias": "ft",
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "get_root_path",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "templating",
          "name": "_default_template_ctx_processor",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "click",
          "name": "Group",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "_sentinel",
          "assigned_to": "object",
          "lineno": 25
        },
        {
          "name": "F",
          "assigned_to": "t.TypeVar",
          "lineno": 27
        },
        {
          "name": "T_after_request",
          "assigned_to": "t.TypeVar",
          "lineno": 28
        },
        {
          "name": "T_before_request",
          "assigned_to": "t.TypeVar",
          "lineno": 29
        },
        {
          "name": "T_error_handler",
          "assigned_to": "t.TypeVar",
          "lineno": 30
        },
        {
          "name": "T_teardown",
          "assigned_to": "t.TypeVar",
          "lineno": 31
        },
        {
          "name": "T_template_context_processor",
          "assigned_to": "t.TypeVar",
          "lineno": 32
        },
        {
          "name": "T_url_defaults",
          "assigned_to": "t.TypeVar",
          "lineno": 35
        },
        {
          "name": "T_url_value_preprocessor",
          "assigned_to": "t.TypeVar",
          "lineno": 36
        },
        {
          "name": "T_route",
          "assigned_to": "t.TypeVar",
          "lineno": 39
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "ft.TemplateContextProcessorCallable",
          "ft.URLValuePreprocessorCallable",
          "t.TypeVar",
          "ft.TeardownCallable",
          "ft.ErrorHandlerCallable",
          "ft.BeforeRequestCallable",
          "ft.RouteCallable",
          "ft.URLDefaultCallable",
          "object"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "pathlib",
          "typing",
          "collections",
          "functools",
          "os",
          "sys"
        ],
        "third_party": {
          "other": [
            "__future__",
            "importlib",
            "jinja2",
            "werkzeug",
            "helpers",
            "templating",
            "click"
          ]
        },
        "tech_stack": []
      },
      "line_count": 793
    },
    "src/flask/sessions.py": {
      "filepath": "../flask/src/flask/sessions.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_lazy_sha1",
          "args": [
            {
              "name": "string",
              "type": "bytes"
            }
          ],
          "return_type": "t.Any",
          "lineno": 290,
          "decorators": [],
          "is_async": false,
          "calls": [
            "string",
            "hashlib.sha1"
          ],
          "docstring": "Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include\nSHA-1, in which case the import and use as a default would fail before the\ndeveloper can configure something else.",
          "code": "def _lazy_sha1(string: bytes = b\"\") -> t.Any:\n    \"\"\"Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include\n    SHA-1, in which case the import and use as a default would fail before the\n    developer can configure something else.\n    \"\"\"\n    return hashlib.sha1(string)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "permanent",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "bool",
          "lineno": 28,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.get"
          ],
          "docstring": "This reflects the ``'_permanent'`` key in the dict.",
          "code": "def permanent(self) -> bool:\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "permanent",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "bool"
            }
          ],
          "return_type": "None",
          "lineno": 33,
          "decorators": [
            {
              "name": "permanent.setter",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "value",
            "bool"
          ],
          "docstring": null,
          "code": "def permanent(self, value: bool) -> None:\n        self[\"_permanent\"] = bool(value)",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "initial",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 74,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "super",
            "initial",
            "on_update"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None,\n    ) -> None:\n        def on_update(self: te.Self) -> None:\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "__getitem__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key",
              "type": "str"
            }
          ],
          "return_type": "t.Any",
          "lineno": 84,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__getitem__",
            "super",
            "key"
          ],
          "docstring": null,
          "code": "def __getitem__(self, key: str) -> t.Any:\n        self.accessed = True\n        return super().__getitem__(key)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "get",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key",
              "type": "str"
            },
            {
              "name": "default",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 88,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.get",
            "default",
            "super",
            "key"
          ],
          "docstring": null,
          "code": "def get(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().get(key, default)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "setdefault",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "key",
              "type": "str"
            },
            {
              "name": "default",
              "type": "t.Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 92,
          "decorators": [],
          "is_async": false,
          "calls": [
            "default",
            "unknown.setdefault",
            "super",
            "key"
          ],
          "docstring": null,
          "code": "def setdefault(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().setdefault(key, default)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "_fail",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.NoReturn",
          "lineno": 103,
          "decorators": [],
          "is_async": false,
          "calls": [
            "RuntimeError"
          ],
          "docstring": null,
          "code": "def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "make_null_session",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "NullSession",
          "lineno": 164,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.null_session_class"
          ],
          "docstring": "Creates a null session which acts as a replacement object if the\nreal session support could not be loaded due to a configuration\nerror.  This mainly aids the user experience because the job of the\nnull session is to still support lookup without complaining but\nmodifications are answered with a helpful error message of what\nfailed.\n\nThis creates an instance of :attr:`null_session_class` by default.",
          "code": "def make_null_session(self, app: Flask) -> NullSession:\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "is_null_session",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "object"
            }
          ],
          "return_type": "bool",
          "lineno": 176,
          "decorators": [],
          "is_async": false,
          "calls": [
            "obj",
            "isinstance",
            "self.null_session_class"
          ],
          "docstring": "Checks if a given object is a null session.  Null sessions are\nnot asked to be saved.\n\nThis checks if the object is an instance of :attr:`null_session_class`\nby default.",
          "code": "def is_null_session(self, obj: object) -> bool:\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "get_cookie_name",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "str",
          "lineno": 185,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "The name of the session cookie. Uses``app.config[\"SESSION_COOKIE_NAME\"]``.",
          "code": "def get_cookie_name(self, app: Flask) -> str:\n        \"\"\"The name of the session cookie. Uses``app.config[\"SESSION_COOKIE_NAME\"]``.\"\"\"\n        return app.config[\"SESSION_COOKIE_NAME\"]",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "get_cookie_domain",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "Any",
          "lineno": 189,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "The value of the ``Domain`` parameter on the session cookie. If not set,\nbrowsers will only send the cookie to the exact domain it was set from.\nOtherwise, they will send it to any subdomain of the given value as well.\n\nUses the :data:`SESSION_COOKIE_DOMAIN` config.\n\n.. versionchanged:: 2.3\n    Not set by default, does not fall back to ``SERVER_NAME``.",
          "code": "def get_cookie_domain(self, app: Flask) -> str | None:\n        \"\"\"The value of the ``Domain`` parameter on the session cookie. If not set,\n        browsers will only send the cookie to the exact domain it was set from.\n        Otherwise, they will send it to any subdomain of the given value as well.\n\n        Uses the :data:`SESSION_COOKIE_DOMAIN` config.\n\n        .. versionchanged:: 2.3\n            Not set by default, does not fall back to ``SERVER_NAME``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_DOMAIN\"]",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "get_cookie_path",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "str",
          "lineno": 201,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Returns the path for which the cookie should be valid.  The\ndefault implementation uses the value from the ``SESSION_COOKIE_PATH``\nconfig var if it's set, and falls back to ``APPLICATION_ROOT`` or\nuses ``/`` if it's ``None``.",
          "code": "def get_cookie_path(self, app: Flask) -> str:\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "get_cookie_httponly",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "bool",
          "lineno": 209,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Returns True if the session cookie should be httponly.  This\ncurrently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\nconfig var.",
          "code": "def get_cookie_httponly(self, app: Flask) -> bool:\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "get_cookie_secure",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "bool",
          "lineno": 216,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Returns True if the cookie should be secure.  This currently\njust returns the value of the ``SESSION_COOKIE_SECURE`` setting.",
          "code": "def get_cookie_secure(self, app: Flask) -> bool:\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "get_cookie_samesite",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "Any",
          "lineno": 222,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n``SameSite`` attribute. This currently just returns the value of\nthe :data:`SESSION_COOKIE_SAMESITE` setting.",
          "code": "def get_cookie_samesite(self, app: Flask) -> str | None:\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "get_cookie_partitioned",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "bool",
          "lineno": 229,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Returns True if the cookie should be partitioned. By default, uses\nthe value of :data:`SESSION_COOKIE_PARTITIONED`.\n\n.. versionadded:: 3.1",
          "code": "def get_cookie_partitioned(self, app: Flask) -> bool:\n        \"\"\"Returns True if the cookie should be partitioned. By default, uses\n        the value of :data:`SESSION_COOKIE_PARTITIONED`.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PARTITIONED\"]",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "get_expiration_time",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            },
            {
              "name": "session",
              "type": "SessionMixin"
            }
          ],
          "return_type": "Any",
          "lineno": 237,
          "decorators": [],
          "is_async": false,
          "calls": [
            "datetime.now",
            "timezone.utc"
          ],
          "docstring": "A helper method that returns an expiration date for the session\nor ``None`` if the session is linked to the browser session.  The\ndefault implementation returns now + the permanent session\nlifetime configured on the application.",
          "code": "def get_expiration_time(self, app: Flask, session: SessionMixin) -> datetime | None:\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.now(timezone.utc) + app.permanent_session_lifetime\n        return None",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "should_set_cookie",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            },
            {
              "name": "session",
              "type": "SessionMixin"
            }
          ],
          "return_type": "bool",
          "lineno": 247,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": "Used by session backends to determine if a ``Set-Cookie`` header\nshould be set for this session cookie for this response. If the session\nhas been modified, the cookie is set. If the session is permanent and\nthe ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\nalways set.\n\nThis check is usually skipped if the session was deleted.\n\n.. versionadded:: 0.11",
          "code": "def should_set_cookie(self, app: Flask, session: SessionMixin) -> bool:\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "open_session",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            },
            {
              "name": "request",
              "type": "Request"
            }
          ],
          "return_type": "Any",
          "lineno": 263,
          "decorators": [],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": "This is called at the beginning of each request, after\npushing the request context, before matching the URL.\n\nThis must return an object which implements a dictionary-like\ninterface as well as the :class:`SessionMixin` interface.\n\nThis will return ``None`` to indicate that loading failed in\nsome way that is not immediately an error. The request\ncontext will fall back to using :meth:`make_null_session`\nin this case.",
          "code": "def open_session(self, app: Flask, request: Request) -> SessionMixin | None:\n        \"\"\"This is called at the beginning of each request, after\n        pushing the request context, before matching the URL.\n\n        This must return an object which implements a dictionary-like\n        interface as well as the :class:`SessionMixin` interface.\n\n        This will return ``None`` to indicate that loading failed in\n        some way that is not immediately an error. The request\n        context will fall back to using :meth:`make_null_session`\n        in this case.\n        \"\"\"\n        raise NotImplementedError()",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "save_session",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            },
            {
              "name": "session",
              "type": "SessionMixin"
            },
            {
              "name": "response",
              "type": "Response"
            }
          ],
          "return_type": "None",
          "lineno": 277,
          "decorators": [],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": "This is called at the end of each request, after generating\na response, before removing the request context. It is skipped\nif :meth:`is_null_session` returns ``True``.",
          "code": "def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        \"\"\"This is called at the end of each request, after generating\n        a response, before removing the request context. It is skipped\n        if :meth:`is_null_session` returns ``True``.\n        \"\"\"\n        raise NotImplementedError()",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "get_signing_serializer",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "Any",
          "lineno": 317,
          "decorators": [],
          "is_async": false,
          "calls": [
            "keys",
            "keys.extend",
            "URLSafeTimedSerializer",
            "self.salt",
            "app.secret_key",
            "fallbacks",
            "keys.append",
            "self.serializer"
          ],
          "docstring": null,
          "code": "def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:\n        if not app.secret_key:\n            return None\n\n        keys: list[str | bytes] = []\n\n        if fallbacks := app.config[\"SECRET_KEY_FALLBACKS\"]:\n            keys.extend(fallbacks)\n\n        keys.append(app.secret_key)  # itsdangerous expects current key at top\n        return URLSafeTimedSerializer(\n            keys,  # type: ignore[arg-type]\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs={\n                \"key_derivation\": self.key_derivation,\n                \"digest_method\": self.digest_method,\n            },\n        )",
          "line_count": 19,
          "needs_llm_summary": true
        },
        {
          "name": "open_session",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            },
            {
              "name": "request",
              "type": "Request"
            }
          ],
          "return_type": "Any",
          "lineno": 337,
          "decorators": [],
          "is_async": false,
          "calls": [
            "s.loads",
            "request.cookies.get",
            "val",
            "data",
            "self.get_cookie_name",
            "self.session_class",
            "max_age",
            "self.get_signing_serializer",
            "app.permanent_session_lifetime.total_seconds",
            "int",
            "app"
          ],
          "docstring": null,
          "code": "def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = int(app.permanent_session_lifetime.total_seconds())\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "save_session",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            },
            {
              "name": "session",
              "type": "SessionMixin"
            },
            {
              "name": "response",
              "type": "Response"
            }
          ],
          "return_type": "None",
          "lineno": 351,
          "decorators": [],
          "is_async": false,
          "calls": [
            "samesite",
            "self.should_set_cookie",
            "partitioned",
            "expires",
            "self.get_cookie_path",
            "httponly",
            "session",
            "secure",
            "self.get_cookie_partitioned",
            "name",
            "response.vary.add",
            "response.set_cookie",
            "self.get_expiration_time",
            "self.get_cookie_name",
            "unknown.dumps",
            "self.get_signing_serializer",
            "self.get_cookie_secure",
            "self.get_cookie_samesite",
            "domain",
            "self.get_cookie_httponly",
            "self.get_cookie_domain",
            "val",
            "response.delete_cookie",
            "dict",
            "app",
            "path"
          ],
          "docstring": null,
          "code": "def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n        secure = self.get_cookie_secure(app)\n        partitioned = self.get_cookie_partitioned(app)\n        samesite = self.get_cookie_samesite(app)\n        httponly = self.get_cookie_httponly(app)\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    name,\n                    domain=domain,\n                    path=path,\n                    secure=secure,\n                    partitioned=partitioned,\n                    samesite=samesite,\n                    httponly=httponly,\n                )\n                response.vary.add(\"Cookie\")\n\n            return\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            partitioned=partitioned,\n            samesite=samesite,\n        )\n        response.vary.add(\"Cookie\")",
          "line_count": 49,
          "needs_llm_summary": true
        },
        {
          "name": "on_update",
          "args": [
            {
              "name": "self",
              "type": "te.Self"
            }
          ],
          "return_type": "None",
          "lineno": 78,
          "decorators": [],
          "is_async": false,
          "calls": [],
          "docstring": null,
          "code": "def on_update(self: te.Self) -> None:\n            self.modified = True\n            self.accessed = True",
          "line_count": 3,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "SessionMixin",
          "methods": [
            "permanent",
            "permanent"
          ],
          "base_classes": [
            "unknown"
          ],
          "lineno": 24,
          "docstring": "Expands a basic dictionary with session attributes."
        },
        {
          "name": "SecureCookieSession",
          "methods": [
            "__init__",
            "__getitem__",
            "get",
            "setdefault"
          ],
          "base_classes": [
            "unknown",
            "SessionMixin"
          ],
          "lineno": 52,
          "docstring": "Base class for sessions based on signed cookies.\n\nThis session backend will set the :attr:`modified` and\n:attr:`accessed` attributes. It cannot reliably track whether a\nsession is new (vs. empty), so :attr:`new` remains hard coded to\n``False``."
        },
        {
          "name": "NullSession",
          "methods": [
            "_fail"
          ],
          "base_classes": [
            "SecureCookieSession"
          ],
          "lineno": 97,
          "docstring": "Class used to generate nicer error messages if sessions are not\navailable.  Will still allow read-only access to the empty session\nbut fail on setting."
        },
        {
          "name": "SessionInterface",
          "methods": [
            "make_null_session",
            "is_null_session",
            "get_cookie_name",
            "get_cookie_domain",
            "get_cookie_path",
            "get_cookie_httponly",
            "get_cookie_secure",
            "get_cookie_samesite",
            "get_cookie_partitioned",
            "get_expiration_time",
            "should_set_cookie",
            "open_session",
            "save_session"
          ],
          "base_classes": [],
          "lineno": 114,
          "docstring": "The basic interface you have to implement in order to replace the\ndefault session interface which uses werkzeug's securecookie\nimplementation.  The only methods you have to implement are\n:meth:`open_session` and :meth:`save_session`, the others have\nuseful defaults which you don't need to change.\n\nThe session object returned by the :meth:`open_session` method has to\nprovide a dictionary like interface plus the properties and methods\nfrom the :class:`SessionMixin`.  We recommend just subclassing a dict\nand adding that mixin::\n\n    class Session(dict, SessionMixin):\n        pass\n\nIf :meth:`open_session` returns ``None`` Flask will call into\n:meth:`make_null_session` to create a session that acts as replacement\nif the session support cannot work because some requirement is not\nfulfilled.  The default :class:`NullSession` class that is created\nwill complain that the secret key was not set.\n\nTo replace the session interface on an application all you have to do\nis to assign :attr:`flask.Flask.session_interface`::\n\n    app = Flask(__name__)\n    app.session_interface = MySessionInterface()\n\nMultiple requests with the same session may be sent and handled\nconcurrently. When implementing a new session interface, consider\nwhether reads or writes to the backing store must be synchronized.\nThere is no guarantee on the order in which the session for each\nrequest is opened or saved, it will occur in the order that requests\nbegin and end processing.\n\n.. versionadded:: 0.8"
        },
        {
          "name": "SecureCookieSessionInterface",
          "methods": [
            "get_signing_serializer",
            "open_session",
            "save_session"
          ],
          "base_classes": [
            "SessionInterface"
          ],
          "lineno": 298,
          "docstring": "The default session interface that stores sessions in signed cookies\nthrough the :mod:`itsdangerous` module."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "c",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "hashlib",
          "alias": null,
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 5,
          "type": "import"
        },
        {
          "module": "collections.abc",
          "name": "MutableMapping",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "datetime",
          "name": "datetime",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "datetime",
          "name": "timezone",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "itsdangerous",
          "name": "BadSignature",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "itsdangerous",
          "name": "URLSafeTimedSerializer",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "werkzeug.datastructures",
          "name": "CallbackDict",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "json.tag",
          "name": "TaggedJSONSerializer",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "typing_extensions",
          "alias": "te",
          "lineno": 17,
          "type": "import"
        },
        {
          "module": "app",
          "name": "Flask",
          "alias": null,
          "lineno": 19,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Request",
          "alias": null,
          "lineno": 20,
          "type": "from_import"
        },
        {
          "module": "wrappers",
          "name": "Response",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "session_json_serializer",
          "assigned_to": "TaggedJSONSerializer",
          "lineno": 287
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "TaggedJSONSerializer"
        ],
        "class_instantiations": [
          "TaggedJSONSerializer"
        ]
      },
      "dependency_classification": {
        "stdlib": [
          "datetime",
          "json",
          "typing",
          "collections"
        ],
        "third_party": {
          "other": [
            "__future__",
            "hashlib",
            "itsdangerous",
            "werkzeug",
            "typing_extensions",
            "app",
            "wrappers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 400
    },
    "src/flask/signals.py": {
      "filepath": "../flask/src/flask/signals.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "blinker",
          "name": "Namespace",
          "alias": null,
          "lineno": 3,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "_signals",
          "assigned_to": "Namespace",
          "lineno": 6
        },
        {
          "name": "template_rendered",
          "assigned_to": "_signals.signal",
          "lineno": 8
        },
        {
          "name": "before_render_template",
          "assigned_to": "_signals.signal",
          "lineno": 9
        },
        {
          "name": "request_started",
          "assigned_to": "_signals.signal",
          "lineno": 10
        },
        {
          "name": "request_finished",
          "assigned_to": "_signals.signal",
          "lineno": 11
        },
        {
          "name": "request_tearing_down",
          "assigned_to": "_signals.signal",
          "lineno": 12
        },
        {
          "name": "got_request_exception",
          "assigned_to": "_signals.signal",
          "lineno": 13
        },
        {
          "name": "appcontext_tearing_down",
          "assigned_to": "_signals.signal",
          "lineno": 14
        },
        {
          "name": "appcontext_pushed",
          "assigned_to": "_signals.signal",
          "lineno": 15
        },
        {
          "name": "appcontext_popped",
          "assigned_to": "_signals.signal",
          "lineno": 16
        },
        {
          "name": "message_flashed",
          "assigned_to": "_signals.signal",
          "lineno": 17
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "_signals.signal",
          "Namespace"
        ],
        "class_instantiations": [
          "Namespace"
        ]
      },
      "dependency_classification": {
        "stdlib": [],
        "third_party": {
          "other": [
            "__future__",
            "blinker"
          ]
        },
        "tech_stack": []
      },
      "line_count": 18
    },
    "src/flask/templating.py": {
      "filepath": "../flask/src/flask/templating.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_default_template_ctx_processor",
          "args": [],
          "return_type": "dict[str, t.Any]",
          "lineno": 21,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.session",
            "app_ctx._get_current_object",
            "ctx.request"
          ],
          "docstring": "Default template context processor.  Injects `request`,\n`session` and `g`.",
          "code": "def _default_template_ctx_processor() -> dict[str, t.Any]:\n    \"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    rv: dict[str, t.Any] = {\"g\": ctx.g}\n\n    if ctx.has_request:\n        rv[\"request\"] = ctx.request\n        rv[\"session\"] = ctx.session\n\n    return rv",
          "line_count": 12,
          "needs_llm_summary": true
        },
        {
          "name": "_render",
          "args": [
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "template",
              "type": "Template"
            },
            {
              "name": "context",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "str",
          "lineno": 122,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.app",
            "template_rendered.send",
            "before_render_template.send",
            "ctx",
            "app.ensure_sync",
            "template",
            "app.update_template_context",
            "app",
            "template.render",
            "context"
          ],
          "docstring": null,
          "code": "def _render(ctx: AppContext, template: Template, context: dict[str, t.Any]) -> str:\n    app = ctx.app\n    app.update_template_context(ctx, context)\n    before_render_template.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n    rv = template.render(context)\n    template_rendered.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n    return rv",
          "line_count": 11,
          "needs_llm_summary": true
        },
        {
          "name": "render_template",
          "args": [
            {
              "name": "template_name_or_list",
              "type": "Any"
            }
          ],
          "return_type": "str",
          "lineno": 135,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx",
            "app_ctx._get_current_object",
            "template_name_or_list",
            "template",
            "ctx.app.jinja_env.get_or_select_template",
            "_render",
            "context"
          ],
          "docstring": "Render a template by name with the given context.\n\n:param template_name_or_list: The name of the template to render. If\n    a list is given, the first name to exist will be rendered.\n:param context: The variables to make available in the template.",
          "code": "def render_template(\n    template_name_or_list: str | Template | list[str | Template],\n    **context: t.Any,\n) -> str:\n    \"\"\"Render a template by name with the given context.\n\n    :param template_name_or_list: The name of the template to render. If\n        a list is given, the first name to exist will be rendered.\n    :param context: The variables to make available in the template.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.get_or_select_template(template_name_or_list)\n    return _render(ctx, template, context)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "render_template_string",
          "args": [
            {
              "name": "source",
              "type": "str"
            }
          ],
          "return_type": "str",
          "lineno": 150,
          "decorators": [],
          "is_async": false,
          "calls": [
            "app_ctx._get_current_object",
            "ctx",
            "template",
            "ctx.app.jinja_env.from_string",
            "source",
            "_render",
            "context"
          ],
          "docstring": "Render a template from the given source string with the given\ncontext.\n\n:param source: The source code of the template to render.\n:param context: The variables to make available in the template.",
          "code": "def render_template_string(source: str, **context: t.Any) -> str:\n    \"\"\"Render a template from the given source string with the given\n    context.\n\n    :param source: The source code of the template to render.\n    :param context: The variables to make available in the template.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.from_string(source)\n    return _render(ctx, template, context)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "_stream",
          "args": [
            {
              "name": "ctx",
              "type": "AppContext"
            },
            {
              "name": "template",
              "type": "Template"
            },
            {
              "name": "context",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "t.Iterator[str]",
          "lineno": 162,
          "decorators": [],
          "is_async": false,
          "calls": [
            "ctx.app",
            "template_rendered.send",
            "template.generate",
            "before_render_template.send",
            "ctx",
            "app.ensure_sync",
            "template",
            "generate",
            "app.update_template_context",
            "app",
            "stream_with_context",
            "context"
          ],
          "docstring": null,
          "code": "def _stream(\n    ctx: AppContext, template: Template, context: dict[str, t.Any]\n) -> t.Iterator[str]:\n    app = ctx.app\n    app.update_template_context(ctx, context)\n    before_render_template.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n\n    def generate() -> t.Iterator[str]:\n        yield from template.generate(context)\n        template_rendered.send(\n            app, _async_wrapper=app.ensure_sync, template=template, context=context\n        )\n\n    return stream_with_context(generate())",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "stream_template",
          "args": [
            {
              "name": "template_name_or_list",
              "type": "Any"
            }
          ],
          "return_type": "t.Iterator[str]",
          "lineno": 180,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_stream",
            "app_ctx._get_current_object",
            "template_name_or_list",
            "ctx",
            "ctx.app.jinja_env.get_or_select_template",
            "template",
            "context"
          ],
          "docstring": "Render a template by name with the given context as a stream.\nThis returns an iterator of strings, which can be used as a\nstreaming response from a view.\n\n:param template_name_or_list: The name of the template to render. If\n    a list is given, the first name to exist will be rendered.\n:param context: The variables to make available in the template.\n\n.. versionadded:: 2.2",
          "code": "def stream_template(\n    template_name_or_list: str | Template | list[str | Template],\n    **context: t.Any,\n) -> t.Iterator[str]:\n    \"\"\"Render a template by name with the given context as a stream.\n    This returns an iterator of strings, which can be used as a\n    streaming response from a view.\n\n    :param template_name_or_list: The name of the template to render. If\n        a list is given, the first name to exist will be rendered.\n    :param context: The variables to make available in the template.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.get_or_select_template(template_name_or_list)\n    return _stream(ctx, template, context)",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "stream_template_string",
          "args": [
            {
              "name": "source",
              "type": "str"
            }
          ],
          "return_type": "t.Iterator[str]",
          "lineno": 199,
          "decorators": [],
          "is_async": false,
          "calls": [
            "_stream",
            "app_ctx._get_current_object",
            "ctx",
            "ctx.app.jinja_env.from_string",
            "source",
            "template",
            "context"
          ],
          "docstring": "Render a template from the given source string with the given\ncontext as a stream. This returns an iterator of strings, which can\nbe used as a streaming response from a view.\n\n:param source: The source code of the template to render.\n:param context: The variables to make available in the template.\n\n.. versionadded:: 2.2",
          "code": "def stream_template_string(source: str, **context: t.Any) -> t.Iterator[str]:\n    \"\"\"Render a template from the given source string with the given\n    context as a stream. This returns an iterator of strings, which can\n    be used as a streaming response from a view.\n\n    :param source: The source code of the template to render.\n    :param context: The variables to make available in the template.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.from_string(source)\n    return _stream(ctx, template, context)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "App"
            }
          ],
          "return_type": "None",
          "lineno": 41,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "options",
            "app",
            "app.create_global_jinja_loader",
            "BaseEnvironment.__init__"
          ],
          "docstring": null,
          "code": "def __init__(self, app: App, **options: t.Any) -> None:\n        if \"loader\" not in options:\n            options[\"loader\"] = app.create_global_jinja_loader()\n        BaseEnvironment.__init__(self, **options)\n        self.app = app",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "App"
            }
          ],
          "return_type": "None",
          "lineno": 53,
          "decorators": [],
          "is_async": false,
          "calls": [
            "app"
          ],
          "docstring": null,
          "code": "def __init__(self, app: App) -> None:\n        self.app = app",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "get_source",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "environment",
              "type": "BaseEnvironment"
            },
            {
              "name": "template",
              "type": "str"
            }
          ],
          "return_type": "tuple[str, Any, Any]",
          "lineno": 56,
          "decorators": [],
          "is_async": false,
          "calls": [
            "environment",
            "template",
            "self._get_source_explained",
            "self._get_source_fast"
          ],
          "docstring": null,
          "code": "def get_source(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return self._get_source_fast(environment, template)",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "_get_source_explained",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "environment",
              "type": "BaseEnvironment"
            },
            {
              "name": "template",
              "type": "str"
            }
          ],
          "return_type": "tuple[str, Any, Any]",
          "lineno": 63,
          "decorators": [],
          "is_async": false,
          "calls": [
            "loader.get_source",
            "self._iter_loaders",
            "environment",
            "self.app",
            "attempts.append",
            "explain_template_loading_attempts",
            "rv",
            "attempts",
            "TemplateNotFound",
            "template"
          ],
          "docstring": null,
          "code": "def _get_source_explained(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        attempts = []\n        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None\n        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)",
          "line_count": 23,
          "needs_llm_summary": true
        },
        {
          "name": "_get_source_fast",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "environment",
              "type": "BaseEnvironment"
            },
            {
              "name": "template",
              "type": "str"
            }
          ],
          "return_type": "tuple[str, Any, Any]",
          "lineno": 87,
          "decorators": [],
          "is_async": false,
          "calls": [
            "loader.get_source",
            "self._iter_loaders",
            "environment",
            "TemplateNotFound",
            "template"
          ],
          "docstring": null,
          "code": "def _get_source_fast(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        for _srcobj, loader in self._iter_loaders(template):\n            try:\n                return loader.get_source(environment, template)\n            except TemplateNotFound:\n                continue\n        raise TemplateNotFound(template)",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "_iter_loaders",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "template",
              "type": "str"
            }
          ],
          "return_type": "t.Iterator[tuple[Scaffold, BaseLoader]]",
          "lineno": 97,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.app.iter_blueprints",
            "blueprint.jinja_loader",
            "self.app.jinja_loader"
          ],
          "docstring": null,
          "code": "def _iter_loaders(self, template: str) -> t.Iterator[tuple[Scaffold, BaseLoader]]:\n        loader = self.app.jinja_loader\n        if loader is not None:\n            yield self.app, loader\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                yield blueprint, loader",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "list_templates",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "list[str]",
          "lineno": 107,
          "decorators": [],
          "is_async": false,
          "calls": [
            "set",
            "self.app.jinja_loader",
            "self.app.iter_blueprints",
            "loader.list_templates",
            "result.add",
            "result",
            "list",
            "result.update",
            "blueprint.jinja_loader",
            "template"
          ],
          "docstring": null,
          "code": "def list_templates(self) -> list[str]:\n        result = set()\n        loader = self.app.jinja_loader\n        if loader is not None:\n            result.update(loader.list_templates())\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                for template in loader.list_templates():\n                    result.add(template)\n\n        return list(result)",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "generate",
          "args": [],
          "return_type": "t.Iterator[str]",
          "lineno": 171,
          "decorators": [],
          "is_async": false,
          "calls": [
            "template_rendered.send",
            "template.generate",
            "app.ensure_sync",
            "app",
            "template",
            "context"
          ],
          "docstring": null,
          "code": "def generate() -> t.Iterator[str]:\n        yield from template.generate(context)\n        template_rendered.send(\n            app, _async_wrapper=app.ensure_sync, template=template, context=context\n        )",
          "line_count": 5,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "Environment",
          "methods": [
            "__init__"
          ],
          "base_classes": [
            "BaseEnvironment"
          ],
          "lineno": 35,
          "docstring": "Works like a regular Jinja environment but has some additional\nknowledge of how Flask's blueprint works so that it can prepend the\nname of the blueprint to referenced templates if necessary."
        },
        {
          "name": "DispatchingJinjaLoader",
          "methods": [
            "__init__",
            "get_source",
            "_get_source_explained",
            "_get_source_fast",
            "_iter_loaders",
            "list_templates"
          ],
          "base_classes": [
            "BaseLoader"
          ],
          "lineno": 48,
          "docstring": "A loader that looks for templates in the application and all\nthe blueprint folders."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "jinja2",
          "name": "BaseLoader",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "jinja2",
          "name": "Environment",
          "alias": "BaseEnvironment",
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "jinja2",
          "name": "Template",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "jinja2",
          "name": "TemplateNotFound",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "ctx",
          "name": "AppContext",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "app_ctx",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "stream_with_context",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "before_render_template",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "signals",
          "name": "template_rendered",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "sansio.app",
          "name": "App",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "sansio.scaffold",
          "name": "Scaffold",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "debughelpers",
          "name": "explain_template_loading_attempts",
          "alias": null,
          "lineno": 79,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "jinja2",
            "ctx",
            "globals",
            "helpers",
            "signals",
            "sansio",
            "debughelpers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 212
    },
    "src/flask/testing.py": {
      "filepath": "../flask/src/flask/testing.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "_get_werkzeug_version",
          "args": [],
          "return_type": "str",
          "lineno": 100,
          "decorators": [],
          "is_async": false,
          "calls": [
            "importlib.metadata.version"
          ],
          "docstring": null,
          "code": "def _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            },
            {
              "name": "path",
              "type": "str"
            },
            {
              "name": "base_url",
              "type": "Any"
            },
            {
              "name": "subdomain",
              "type": "Any"
            },
            {
              "name": "url_scheme",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 49,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "unknown.__init__",
            "bool",
            "super",
            "base_url",
            "url.path",
            "app.config.get",
            "app_root.lstrip",
            "app",
            "urlsplit",
            "path"
          ],
          "docstring": null,
          "code": "def __init__(\n        self,\n        app: Flask,\n        path: str = \"/\",\n        base_url: str | None = None,\n        subdomain: str | None = None,\n        url_scheme: str | None = None,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        assert not (base_url or subdomain or url_scheme) or (\n            base_url is not None\n        ) != bool(subdomain or url_scheme), (\n            'Cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n        )\n\n        if base_url is None:\n            http_host = app.config.get(\"SERVER_NAME\") or \"localhost\"\n            app_root = app.config[\"APPLICATION_ROOT\"]\n\n            if subdomain:\n                http_host = f\"{subdomain}.{http_host}\"\n\n            if url_scheme is None:\n                url_scheme = app.config[\"PREFERRED_URL_SCHEME\"]\n\n            url = urlsplit(path)\n            base_url = (\n                f\"{url.scheme or url_scheme}://{url.netloc or http_host}\"\n                f\"/{app_root.lstrip('/')}\"\n            )\n            path = url.path\n\n            if url.query:\n                path = f\"{path}?{url.query}\"\n\n        self.app = app\n        super().__init__(path, base_url, *args, **kwargs)",
          "line_count": 38,
          "needs_llm_summary": true
        },
        {
          "name": "json_dumps",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "obj",
              "type": "t.Any"
            }
          ],
          "return_type": "str",
          "lineno": 88,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self.app.json.dumps",
            "kwargs",
            "obj"
          ],
          "docstring": "Serialize ``obj`` to a JSON-formatted string.\n\nThe serialization will be configured according to the config associated\nwith this EnvironBuilder's ``app``.",
          "code": "def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize ``obj`` to a JSON-formatted string.\n\n        The serialization will be configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        return self.app.json.dumps(obj, **kwargs)",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 125,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "ExitStack",
            "_get_werkzeug_version",
            "unknown.__init__",
            "super"
          ],
          "docstring": null,
          "code": "def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.preserve_context = False\n        self._new_contexts: list[t.ContextManager[t.Any]] = []\n        self._context_stack = ExitStack()\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"Werkzeug/{_get_werkzeug_version()}\",\n        }",
          "line_count": 9,
          "needs_llm_summary": true
        },
        {
          "name": "session_transaction",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "t.Iterator[SessionMixin]",
          "lineno": 136,
          "decorators": [
            {
              "name": "contextmanager",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "TypeError",
            "ctx.request.path",
            "ctx.request",
            "app.session_interface.is_null_session",
            "app.session_interface.save_session",
            "sess",
            "ctx.request.environ",
            "self.application",
            "resp",
            "app.session_interface.open_session",
            "resp.headers.getlist",
            "app.test_request_context",
            "app.response_class",
            "self._add_cookies_to_wsgi",
            "RuntimeError",
            "self._update_cookies_from_response",
            "kwargs",
            "ctx.request.host.partition",
            "app"
          ],
          "docstring": "When used in combination with a ``with`` statement this opens a\nsession transaction.  This can be used to modify the session that\nthe test client uses.  Once the ``with`` block is left the session is\nstored back.\n\n::\n\n    with client.session_transaction() as session:\n        session['value'] = 42\n\nInternally this is implemented by going through a temporary test\nrequest context and since session handling could depend on\nrequest variables this function accepts the same arguments as\n:meth:`~flask.Flask.test_request_context` which are directly\npassed through.",
          "code": "def session_transaction(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Iterator[SessionMixin]:\n        \"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n        request variables this function accepts the same arguments as\n        :meth:`~flask.Flask.test_request_context` which are directly\n        passed through.\n        \"\"\"\n        if self._cookies is None:\n            raise TypeError(\n                \"Cookies are disabled. Create a client with 'use_cookies=True'.\"\n            )\n\n        app = self.application\n        ctx = app.test_request_context(*args, **kwargs)\n        self._add_cookies_to_wsgi(ctx.request.environ)\n\n        with ctx:\n            sess = app.session_interface.open_session(app, ctx.request)\n\n        if sess is None:\n            raise RuntimeError(\"Session backend did not open a session.\")\n\n        yield sess\n        resp = app.response_class()\n\n        if app.session_interface.is_null_session(sess):\n            return\n\n        with ctx:\n            app.session_interface.save_session(app, sess, resp)\n\n        self._update_cookies_from_response(\n            ctx.request.host.partition(\":\")[0],\n            ctx.request.path,\n            resp.headers.getlist(\"Set-Cookie\"),\n        )",
          "line_count": 48,
          "needs_llm_summary": true
        },
        {
          "name": "_copy_environ",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "other",
              "type": "WSGIEnvironment"
            }
          ],
          "return_type": "WSGIEnvironment",
          "lineno": 185,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._new_contexts.append"
          ],
          "docstring": null,
          "code": "def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:\n        out = {**self.environ_base, **other}\n\n        if self.preserve_context:\n            out[\"werkzeug.debug.preserve_context\"] = self._new_contexts.append\n\n        return out",
          "line_count": 7,
          "needs_llm_summary": true
        },
        {
          "name": "_request_from_builder_args",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "args",
              "type": "tuple[t.Any, Ellipsis]"
            },
            {
              "name": "kwargs",
              "type": "dict[str, t.Any]"
            }
          ],
          "return_type": "BaseRequest",
          "lineno": 193,
          "decorators": [],
          "is_async": false,
          "calls": [
            "builder.get_request",
            "kwargs",
            "self.application",
            "kwargs.get",
            "builder.close",
            "self._copy_environ",
            "EnvironBuilder"
          ],
          "docstring": null,
          "code": "def _request_from_builder_args(\n        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n    ) -> BaseRequest:\n        kwargs[\"environ_base\"] = self._copy_environ(kwargs.get(\"environ_base\", {}))\n        builder = EnvironBuilder(self.application, *args, **kwargs)\n\n        try:\n            return builder.get_request()\n        finally:\n            builder.close()",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "open",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "TestResponse",
          "lineno": 204,
          "decorators": [],
          "is_async": false,
          "calls": [
            "follow_redirects",
            "self._context_stack.enter_context",
            "request",
            "self.application",
            "super",
            "self._request_from_builder_args",
            "builder.get_request",
            "copy",
            "self._new_contexts.clear",
            "buffered",
            "cm",
            "unknown.get_request",
            "self._context_stack.close",
            "args",
            "isinstance",
            "kwargs",
            "self.application.json",
            "EnvironBuilder.from_environ",
            "self._copy_environ",
            "werkzeug.test.EnvironBuilder",
            "dict",
            "unknown.open",
            "request.environ"
          ],
          "docstring": null,
          "code": "def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        if args and isinstance(\n            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)\n        ):\n            if isinstance(args[0], werkzeug.test.EnvironBuilder):\n                builder = copy(args[0])\n                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]\n                request = builder.get_request()\n            elif isinstance(args[0], dict):\n                request = EnvironBuilder.from_environ(\n                    args[0], app=self.application, environ_base=self._copy_environ({})\n                ).get_request()\n            else:\n                # isinstance(args[0], BaseRequest)\n                request = copy(args[0])\n                request.environ = self._copy_environ(request.environ)\n        else:\n            # request is None\n            request = self._request_from_builder_args(args, kwargs)\n\n        # Pop any previously preserved contexts. This prevents contexts\n        # from being preserved across redirects or multiple requests\n        # within a single block.\n        self._context_stack.close()\n\n        response = super().open(\n            request,\n            buffered=buffered,\n            follow_redirects=follow_redirects,\n        )\n        response.json_module = self.application.json  # type: ignore[assignment]\n\n        # Re-push contexts that were preserved during the request.\n        for cm in self._new_contexts:\n            self._context_stack.enter_context(cm)\n\n        self._new_contexts.clear()\n        return response",
          "line_count": 44,
          "needs_llm_summary": true
        },
        {
          "name": "__enter__",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "FlaskClient",
          "lineno": 249,
          "decorators": [],
          "is_async": false,
          "calls": [
            "RuntimeError"
          ],
          "docstring": null,
          "code": "def __enter__(self) -> FlaskClient:\n        if self.preserve_context:\n            raise RuntimeError(\"Cannot nest client invocations\")\n        self.preserve_context = True\n        return self",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "__exit__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "exc_type",
              "type": "Any"
            },
            {
              "name": "exc_value",
              "type": "Any"
            },
            {
              "name": "tb",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 255,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self._context_stack.close"
          ],
          "docstring": null,
          "code": "def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.preserve_context = False\n        self._context_stack.close()",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "__init__",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "app",
              "type": "Flask"
            }
          ],
          "return_type": "None",
          "lineno": 271,
          "decorators": [],
          "is_async": false,
          "calls": [
            "unknown.__init__",
            "kwargs",
            "super",
            "app"
          ],
          "docstring": null,
          "code": "def __init__(self, app: Flask, **kwargs: t.Any) -> None:\n        self.app = app\n        super().__init__(**kwargs)",
          "line_count": 3,
          "needs_llm_summary": true
        },
        {
          "name": "invoke",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "cli",
              "type": "t.Any"
            },
            {
              "name": "args",
              "type": "t.Any"
            }
          ],
          "return_type": "Result",
          "lineno": 275,
          "decorators": [],
          "is_async": false,
          "calls": [
            "args",
            "kwargs",
            "unknown.invoke",
            "ScriptInfo",
            "super",
            "self.app.cli",
            "cli"
          ],
          "docstring": "Invokes a CLI command in an isolated environment. See\n:meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\nfull method documentation. See :ref:`testing-cli` for examples.\n\nIf the ``obj`` argument is not given, passes an instance of\n:class:`~flask.cli.ScriptInfo` that knows how to load the Flask\napp being tested.\n\n:param cli: Command object to invoke. Default is the app's\n    :attr:`~flask.app.Flask.cli` group.\n:param args: List of strings to invoke the command with.\n\n:return: a :class:`~click.testing.Result` object.",
          "code": "def invoke(  # type: ignore\n        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n    ) -> Result:\n        \"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"\n        if cli is None:\n            cli = self.app.cli\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)",
          "line_count": 24,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "EnvironBuilder",
          "methods": [
            "__init__",
            "json_dumps"
          ],
          "base_classes": [
            "werkzeug.test.EnvironBuilder"
          ],
          "lineno": 27,
          "docstring": "An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the\napplication.\n\n:param app: The Flask application to configure the environment from.\n:param path: URL path being requested.\n:param base_url: Base URL where the app is being served, which\n    ``path`` is relative to. If not given, built from\n    :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n    :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n:param subdomain: Subdomain name to append to :data:`SERVER_NAME`.\n:param url_scheme: Scheme to use instead of\n    :data:`PREFERRED_URL_SCHEME`.\n:param json: If given, this is serialized as JSON and passed as\n    ``data``. Also defaults ``content_type`` to\n    ``application/json``.\n:param args: other positional arguments passed to\n    :class:`~werkzeug.test.EnvironBuilder`.\n:param kwargs: other keyword arguments passed to\n    :class:`~werkzeug.test.EnvironBuilder`."
        },
        {
          "name": "FlaskClient",
          "methods": [
            "__init__",
            "session_transaction",
            "_copy_environ",
            "_request_from_builder_args",
            "open",
            "__enter__",
            "__exit__"
          ],
          "base_classes": [
            "Client"
          ],
          "lineno": 109,
          "docstring": "Works like a regular Werkzeug test client, with additional behavior for\nFlask. Can defer the cleanup of the request context until the end of a\n``with`` block. For general information about how to use this class refer to\n:class:`werkzeug.test.Client`.\n\n.. versionchanged:: 0.12\n   `app.test_client()` includes preset default environment, which can be\n   set after instantiation of the `app.test_client()` object in\n   `client.environ_base`.\n\nBasic usage is outlined in the :doc:`/testing` chapter."
        },
        {
          "name": "FlaskCliRunner",
          "methods": [
            "__init__",
            "invoke"
          ],
          "base_classes": [
            "CliRunner"
          ],
          "lineno": 265,
          "docstring": "A :class:`~click.testing.CliRunner` for testing a Flask app's\nCLI commands. Typically created using\n:meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "importlib.metadata",
          "alias": null,
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "contextlib",
          "name": "contextmanager",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "contextlib",
          "name": "ExitStack",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "copy",
          "name": "copy",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "types",
          "name": "TracebackType",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "urllib.parse",
          "name": "urlsplit",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        },
        {
          "module": "werkzeug.test",
          "alias": null,
          "lineno": 11,
          "type": "import"
        },
        {
          "module": "click.testing",
          "name": "CliRunner",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "click.testing",
          "name": "Result",
          "alias": null,
          "lineno": 13,
          "type": "from_import"
        },
        {
          "module": "werkzeug.test",
          "name": "Client",
          "alias": null,
          "lineno": 14,
          "type": "from_import"
        },
        {
          "module": "werkzeug.wrappers",
          "name": "Request",
          "alias": "BaseRequest",
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "cli",
          "name": "ScriptInfo",
          "alias": null,
          "lineno": 17,
          "type": "from_import"
        },
        {
          "module": "sessions",
          "name": "SessionMixin",
          "alias": null,
          "lineno": 18,
          "type": "from_import"
        },
        {
          "module": "_typeshed.wsgi",
          "name": "WSGIEnvironment",
          "alias": null,
          "lineno": 21,
          "type": "from_import"
        },
        {
          "module": "werkzeug.test",
          "name": "TestResponse",
          "alias": null,
          "lineno": 22,
          "type": "from_import"
        },
        {
          "module": "app",
          "name": "Flask",
          "alias": null,
          "lineno": 24,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "_werkzeug_version",
          "assigned_to": "str",
          "lineno": 97
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "copy",
          "contextlib",
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "importlib",
            "types",
            "urllib",
            "werkzeug",
            "click",
            "cli",
            "sessions",
            "_typeshed",
            "app"
          ]
        },
        "tech_stack": []
      },
      "line_count": 299
    },
    "src/flask/typing.py": {
      "filepath": "../flask/src/flask/typing.py",
      "module_docstring": null,
      "functions": [],
      "classes": [],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "collections.abc",
          "alias": "cabc",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 4,
          "type": "import"
        },
        {
          "module": "_typeshed.wsgi",
          "name": "WSGIApplication",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "werkzeug.datastructures",
          "name": "Headers",
          "alias": null,
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "werkzeug.sansio.response",
          "name": "Response",
          "alias": null,
          "lineno": 9,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "ResponseValue",
          "assigned_to": null,
          "lineno": 12
        },
        {
          "name": "HeaderValue",
          "assigned_to": null,
          "lineno": 26
        },
        {
          "name": "HeadersValue",
          "assigned_to": null,
          "lineno": 29
        },
        {
          "name": "ResponseReturnValue",
          "assigned_to": null,
          "lineno": 36
        },
        {
          "name": "ResponseClass",
          "assigned_to": "t.TypeVar",
          "lineno": 47
        },
        {
          "name": "AppOrBlueprintKey",
          "assigned_to": null,
          "lineno": 49
        },
        {
          "name": "AfterRequestCallable",
          "assigned_to": null,
          "lineno": 50
        },
        {
          "name": "BeforeFirstRequestCallable",
          "assigned_to": null,
          "lineno": 54
        },
        {
          "name": "BeforeRequestCallable",
          "assigned_to": null,
          "lineno": 55
        },
        {
          "name": "ShellContextProcessorCallable",
          "assigned_to": null,
          "lineno": 59
        },
        {
          "name": "TeardownCallable",
          "assigned_to": null,
          "lineno": 60
        },
        {
          "name": "TemplateContextProcessorCallable",
          "assigned_to": null,
          "lineno": 64
        },
        {
          "name": "TemplateFilterCallable",
          "assigned_to": null,
          "lineno": 67
        },
        {
          "name": "TemplateGlobalCallable",
          "assigned_to": null,
          "lineno": 68
        },
        {
          "name": "TemplateTestCallable",
          "assigned_to": null,
          "lineno": 69
        },
        {
          "name": "URLDefaultCallable",
          "assigned_to": null,
          "lineno": 70
        },
        {
          "name": "URLValuePreprocessorCallable",
          "assigned_to": null,
          "lineno": 71
        },
        {
          "name": "ErrorHandlerCallable",
          "assigned_to": null,
          "lineno": 79
        },
        {
          "name": "RouteCallable",
          "assigned_to": null,
          "lineno": 84
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "t.TypeVar"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing",
          "collections"
        ],
        "third_party": {
          "other": [
            "__future__",
            "_typeshed",
            "werkzeug"
          ]
        },
        "tech_stack": []
      },
      "line_count": 88
    },
    "src/flask/views.py": {
      "filepath": "../flask/src/flask/views.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "dispatch_request",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "ft.ResponseReturnValue",
          "lineno": 78,
          "decorators": [],
          "is_async": false,
          "calls": [
            "NotImplementedError"
          ],
          "docstring": "The actual view function behavior. Subclasses must override\nthis and return a valid response. Any variables from the URL\nrule are passed as keyword arguments.",
          "code": "def dispatch_request(self) -> ft.ResponseReturnValue:\n        \"\"\"The actual view function behavior. Subclasses must override\n        this and return a valid response. Any variables from the URL\n        rule are passed as keyword arguments.\n        \"\"\"\n        raise NotImplementedError()",
          "line_count": 6,
          "needs_llm_summary": true
        },
        {
          "name": "as_view",
          "args": [
            {
              "name": "cls"
            },
            {
              "name": "name",
              "type": "str"
            }
          ],
          "return_type": "ft.RouteCallable",
          "lineno": 86,
          "decorators": [
            {
              "name": "classmethod",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "current_app.ensure_sync",
            "kwargs",
            "cls.__module__",
            "cls.methods",
            "class_kwargs",
            "cls.__doc__",
            "cls",
            "name",
            "view.view_class",
            "view",
            "cls.provide_automatic_options",
            "self.dispatch_request",
            "decorator"
          ],
          "docstring": "Convert the class into a view function that can be registered\nfor a route.\n\nBy default, the generated view will create a new instance of the\nview class for every request and call its\n:meth:`dispatch_request` method. If the view class sets\n:attr:`init_every_request` to ``False``, the same instance will\nbe used for every request.\n\nExcept for ``name``, all other arguments passed to this method\nare forwarded to the view class ``__init__`` method.\n\n.. versionchanged:: 2.2\n    Added the ``init_every_request`` class attribute.",
          "code": "def as_view(\n        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any\n    ) -> ft.RouteCallable:\n        \"\"\"Convert the class into a view function that can be registered\n        for a route.\n\n        By default, the generated view will create a new instance of the\n        view class for every request and call its\n        :meth:`dispatch_request` method. If the view class sets\n        :attr:`init_every_request` to ``False``, the same instance will\n        be used for every request.\n\n        Except for ``name``, all other arguments passed to this method\n        are forwarded to the view class ``__init__`` method.\n\n        .. versionchanged:: 2.2\n            Added the ``init_every_request`` class attribute.\n        \"\"\"\n        if cls.init_every_request:\n\n            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                self = view.view_class(  # type: ignore[attr-defined]\n                    *class_args, **class_kwargs\n                )\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]\n\n        else:\n            self = cls(*class_args, **class_kwargs)  # pyright: ignore\n\n            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]\n\n        if cls.decorators:\n            view.__name__ = name\n            view.__module__ = cls.__module__\n            for decorator in cls.decorators:\n                view = decorator(view)\n\n        # We attach the view class to the view function for two reasons:\n        # first of all it allows us to easily figure out what class-based\n        # view this thing came from, secondly it's also used for instantiating\n        # the view class so you can actually replace it with something else\n        # for testing purposes and debugging.\n        view.view_class = cls  # type: ignore\n        view.__name__ = name\n        view.__doc__ = cls.__doc__\n        view.__module__ = cls.__module__\n        view.methods = cls.methods  # type: ignore\n        view.provide_automatic_options = cls.provide_automatic_options  # type: ignore\n        return view",
          "line_count": 50,
          "needs_llm_summary": true
        },
        {
          "name": "__init_subclass__",
          "args": [
            {
              "name": "cls"
            }
          ],
          "return_type": "None",
          "lineno": 165,
          "decorators": [],
          "is_async": false,
          "calls": [
            "kwargs",
            "methods.update",
            "set",
            "base.methods",
            "super",
            "methods.add",
            "hasattr",
            "getattr",
            "methods",
            "key.upper",
            "unknown.__init_subclass__",
            "cls",
            "base",
            "key"
          ],
          "docstring": null,
          "code": "def __init_subclass__(cls, **kwargs: t.Any) -> None:\n        super().__init_subclass__(**kwargs)\n\n        if \"methods\" not in cls.__dict__:\n            methods = set()\n\n            for base in cls.__bases__:\n                if getattr(base, \"methods\", None):\n                    methods.update(base.methods)  # type: ignore[attr-defined]\n\n            for key in http_method_funcs:\n                if hasattr(cls, key):\n                    methods.add(key.upper())\n\n            if methods:\n                cls.methods = methods",
          "line_count": 16,
          "needs_llm_summary": true
        },
        {
          "name": "dispatch_request",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "ft.ResponseReturnValue",
          "lineno": 182,
          "decorators": [],
          "is_async": false,
          "calls": [
            "current_app.ensure_sync",
            "self",
            "request.method.lower",
            "kwargs",
            "getattr",
            "meth"
          ],
          "docstring": null,
          "code": "def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n        meth = getattr(self, request.method.lower(), None)\n\n        # If the request method is HEAD and we don't have a handler for it\n        # retry with GET.\n        if meth is None and request.method == \"HEAD\":\n            meth = getattr(self, \"get\", None)\n\n        assert meth is not None, f\"Unimplemented method {request.method!r}\"\n        return current_app.ensure_sync(meth)(**kwargs)",
          "line_count": 10,
          "needs_llm_summary": true
        },
        {
          "name": "view",
          "args": [],
          "return_type": "ft.ResponseReturnValue",
          "lineno": 106,
          "decorators": [],
          "is_async": false,
          "calls": [
            "current_app.ensure_sync",
            "kwargs",
            "class_kwargs",
            "view.view_class",
            "self.dispatch_request"
          ],
          "docstring": null,
          "code": "def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                self = view.view_class(  # type: ignore[attr-defined]\n                    *class_args, **class_kwargs\n                )\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs)",
          "line_count": 5,
          "needs_llm_summary": true
        },
        {
          "name": "view",
          "args": [],
          "return_type": "ft.ResponseReturnValue",
          "lineno": 115,
          "decorators": [],
          "is_async": false,
          "calls": [
            "current_app.ensure_sync",
            "kwargs",
            "self.dispatch_request"
          ],
          "docstring": null,
          "code": "def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs)",
          "line_count": 2,
          "needs_llm_summary": false
        }
      ],
      "classes": [
        {
          "name": "View",
          "methods": [
            "dispatch_request",
            "as_view"
          ],
          "base_classes": [],
          "lineno": 16,
          "docstring": "Subclass this class and override :meth:`dispatch_request` to\ncreate a generic class-based view. Call :meth:`as_view` to create a\nview function that creates an instance of the class with the given\narguments and calls its ``dispatch_request`` method with any URL\nvariables.\n\nSee :doc:`views` for a detailed guide.\n\n.. code-block:: python\n\n    class Hello(View):\n        init_every_request = False\n\n        def dispatch_request(self, name):\n            return f\"Hello, {name}!\"\n\n    app.add_url_rule(\n        \"/hello/<name>\", view_func=Hello.as_view(\"hello\")\n    )\n\nSet :attr:`methods` on the class to change what methods the view\naccepts.\n\nSet :attr:`decorators` on the class to apply a list of decorators to\nthe generated view function. Decorators applied to the class itself\nwill not be applied to the generated view function!\n\nSet :attr:`init_every_request` to ``False`` for efficiency, unless\nyou need to store request-global data on ``self``."
        },
        {
          "name": "MethodView",
          "methods": [
            "__init_subclass__",
            "dispatch_request"
          ],
          "base_classes": [
            "View"
          ],
          "lineno": 138,
          "docstring": "Dispatches request methods to the corresponding instance methods.\nFor example, if you implement a ``get`` method, it will be used to\nhandle ``GET`` requests.\n\nThis can be useful for defining a REST API.\n\n:attr:`methods` is automatically set based on the methods defined on\nthe class.\n\nSee :doc:`views` for a detailed guide.\n\n.. code-block:: python\n\n    class CounterAPI(MethodView):\n        def get(self):\n            return str(session.get(\"counter\", 0))\n\n        def post(self):\n            session[\"counter\"] = session.get(\"counter\", 0) + 1\n            return redirect(url_for(\"counter\"))\n\n    app.add_url_rule(\n        \"/counter\", view_func=CounterAPI.as_view(\"counter\")\n    )"
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "",
          "name": "typing",
          "alias": "ft",
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "current_app",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "request",
          "alias": null,
          "lineno": 7,
          "type": "from_import"
        }
      ],
      "variables": [
        {
          "name": "F",
          "assigned_to": "t.TypeVar",
          "lineno": 9
        },
        {
          "name": "http_method_funcs",
          "assigned_to": "frozenset",
          "lineno": 11
        }
      ],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [
          "frozenset",
          "t.TypeVar"
        ],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing"
        ],
        "third_party": {
          "other": [
            "__future__",
            "globals"
          ]
        },
        "tech_stack": []
      },
      "line_count": 192
    },
    "src/flask/wrappers.py": {
      "filepath": "../flask/src/flask/wrappers.py",
      "module_docstring": null,
      "functions": [
        {
          "name": "max_content_length",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 60,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "super"
          ],
          "docstring": "The maximum number of bytes that will be read during this request. If\nthis limit is exceeded, a 413 :exc:`~werkzeug.exceptions.RequestEntityTooLarge`\nerror is raised. If it is set to ``None``, no limit is enforced at the\nFlask application level. However, if it is ``None`` and the request has\nno ``Content-Length`` header and the WSGI server does not indicate that\nit terminates the stream, then no data is read to avoid an infinite\nstream.\n\nEach request defaults to the :data:`MAX_CONTENT_LENGTH` config, which\ndefaults to ``None``. It can be set on a specific ``request`` to apply\nthe limit to that specific view. This should be set appropriately based\non an application's or view's specific needs.\n\n.. versionchanged:: 3.1\n    This can be set per-request.\n\n.. versionchanged:: 0.6\n    This is configurable through Flask config.",
          "code": "def max_content_length(self) -> int | None:\n        \"\"\"The maximum number of bytes that will be read during this request. If\n        this limit is exceeded, a 413 :exc:`~werkzeug.exceptions.RequestEntityTooLarge`\n        error is raised. If it is set to ``None``, no limit is enforced at the\n        Flask application level. However, if it is ``None`` and the request has\n        no ``Content-Length`` header and the WSGI server does not indicate that\n        it terminates the stream, then no data is read to avoid an infinite\n        stream.\n\n        Each request defaults to the :data:`MAX_CONTENT_LENGTH` config, which\n        defaults to ``None``. It can be set on a specific ``request`` to apply\n        the limit to that specific view. This should be set appropriately based\n        on an application's or view's specific needs.\n\n        .. versionchanged:: 3.1\n            This can be set per-request.\n\n        .. versionchanged:: 0.6\n            This is configurable through Flask config.\n        \"\"\"\n        if self._max_content_length is not None:\n            return self._max_content_length\n\n        if not current_app:\n            return super().max_content_length\n\n        return current_app.config[\"MAX_CONTENT_LENGTH\"]",
          "line_count": 27,
          "needs_llm_summary": true
        },
        {
          "name": "max_content_length",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 89,
          "decorators": [
            {
              "name": "max_content_length.setter",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "value"
          ],
          "docstring": null,
          "code": "def max_content_length(self, value: int | None) -> None:\n        self._max_content_length = value",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "max_form_memory_size",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 93,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "super"
          ],
          "docstring": "The maximum size in bytes any non-file form field may be in a\n``multipart/form-data`` body. If this limit is exceeded, a 413\n:exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it\nis set to ``None``, no limit is enforced at the Flask application level.\n\nEach request defaults to the :data:`MAX_FORM_MEMORY_SIZE` config, which\ndefaults to ``500_000``. It can be set on a specific ``request`` to\napply the limit to that specific view. This should be set appropriately\nbased on an application's or view's specific needs.\n\n.. versionchanged:: 3.1\n    This is configurable through Flask config.",
          "code": "def max_form_memory_size(self) -> int | None:\n        \"\"\"The maximum size in bytes any non-file form field may be in a\n        ``multipart/form-data`` body. If this limit is exceeded, a 413\n        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it\n        is set to ``None``, no limit is enforced at the Flask application level.\n\n        Each request defaults to the :data:`MAX_FORM_MEMORY_SIZE` config, which\n        defaults to ``500_000``. It can be set on a specific ``request`` to\n        apply the limit to that specific view. This should be set appropriately\n        based on an application's or view's specific needs.\n\n        .. versionchanged:: 3.1\n            This is configurable through Flask config.\n        \"\"\"\n        if self._max_form_memory_size is not None:\n            return self._max_form_memory_size\n\n        if not current_app:\n            return super().max_form_memory_size\n\n        return current_app.config[\"MAX_FORM_MEMORY_SIZE\"]",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "max_form_memory_size",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 116,
          "decorators": [
            {
              "name": "max_form_memory_size.setter",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "value"
          ],
          "docstring": null,
          "code": "def max_form_memory_size(self, value: int | None) -> None:\n        self._max_form_memory_size = value",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "max_form_parts",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 120,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "super"
          ],
          "docstring": "The maximum number of fields that may be present in a\n``multipart/form-data`` body. If this limit is exceeded, a 413\n:exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it\nis set to ``None``, no limit is enforced at the Flask application level.\n\nEach request defaults to the :data:`MAX_FORM_PARTS` config, which\ndefaults to ``1_000``. It can be set on a specific ``request`` to apply\nthe limit to that specific view. This should be set appropriately based\non an application's or view's specific needs.\n\n.. versionchanged:: 3.1\n    This is configurable through Flask config.",
          "code": "def max_form_parts(self) -> int | None:\n        \"\"\"The maximum number of fields that may be present in a\n        ``multipart/form-data`` body. If this limit is exceeded, a 413\n        :exc:`~werkzeug.exceptions.RequestEntityTooLarge` error is raised. If it\n        is set to ``None``, no limit is enforced at the Flask application level.\n\n        Each request defaults to the :data:`MAX_FORM_PARTS` config, which\n        defaults to ``1_000``. It can be set on a specific ``request`` to apply\n        the limit to that specific view. This should be set appropriately based\n        on an application's or view's specific needs.\n\n        .. versionchanged:: 3.1\n            This is configurable through Flask config.\n        \"\"\"\n        if self._max_form_parts is not None:\n            return self._max_form_parts\n\n        if not current_app:\n            return super().max_form_parts\n\n        return current_app.config[\"MAX_FORM_PARTS\"]",
          "line_count": 21,
          "needs_llm_summary": true
        },
        {
          "name": "max_form_parts",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "value",
              "type": "Any"
            }
          ],
          "return_type": "None",
          "lineno": 143,
          "decorators": [
            {
              "name": "max_form_parts.setter",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "value"
          ],
          "docstring": null,
          "code": "def max_form_parts(self, value: int | None) -> None:\n        self._max_form_parts = value",
          "line_count": 2,
          "needs_llm_summary": false
        },
        {
          "name": "endpoint",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 147,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [],
          "docstring": "The endpoint that matched the request URL.\n\nThis will be ``None`` if matching failed or has not been\nperformed yet.\n\nThis in combination with :attr:`view_args` can be used to\nreconstruct the same URL or a modified URL.",
          "code": "def endpoint(self) -> str | None:\n        \"\"\"The endpoint that matched the request URL.\n\n        This will be ``None`` if matching failed or has not been\n        performed yet.\n\n        This in combination with :attr:`view_args` can be used to\n        reconstruct the same URL or a modified URL.\n        \"\"\"\n        if self.url_rule is not None:\n            return self.url_rule.endpoint  # type: ignore[no-any-return]\n\n        return None",
          "line_count": 13,
          "needs_llm_summary": true
        },
        {
          "name": "blueprint",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "Any",
          "lineno": 162,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "self.endpoint",
            "endpoint.rpartition"
          ],
          "docstring": "The registered name of the current blueprint.\n\nThis will be ``None`` if the endpoint is not part of a\nblueprint, or if URL matching failed or has not been performed\nyet.\n\nThis does not necessarily match the name the blueprint was\ncreated with. It may have been nested, or registered with a\ndifferent name.",
          "code": "def blueprint(self) -> str | None:\n        \"\"\"The registered name of the current blueprint.\n\n        This will be ``None`` if the endpoint is not part of a\n        blueprint, or if URL matching failed or has not been performed\n        yet.\n\n        This does not necessarily match the name the blueprint was\n        created with. It may have been nested, or registered with a\n        different name.\n        \"\"\"\n        endpoint = self.endpoint\n\n        if endpoint is not None and \".\" in endpoint:\n            return endpoint.rpartition(\".\")[0]\n\n        return None",
          "line_count": 17,
          "needs_llm_summary": true
        },
        {
          "name": "blueprints",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "list[str]",
          "lineno": 181,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "name",
            "_split_blueprint_path",
            "self.blueprint"
          ],
          "docstring": "The registered names of the current blueprint upwards through\nparent blueprints.\n\nThis will be an empty list if there is no current blueprint, or\nif URL matching failed.\n\n.. versionadded:: 2.0.1",
          "code": "def blueprints(self) -> list[str]:\n        \"\"\"The registered names of the current blueprint upwards through\n        parent blueprints.\n\n        This will be an empty list if there is no current blueprint, or\n        if URL matching failed.\n\n        .. versionadded:: 2.0.1\n        \"\"\"\n        name = self.blueprint\n\n        if name is None:\n            return []\n\n        return _split_blueprint_path(name)",
          "line_count": 15,
          "needs_llm_summary": true
        },
        {
          "name": "_load_form_data",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "None",
          "lineno": 197,
          "decorators": [],
          "is_async": false,
          "calls": [
            "self",
            "attach_enctype_error_multidict",
            "unknown._load_form_data",
            "super"
          ],
          "docstring": null,
          "code": "def _load_form_data(self) -> None:\n        super()._load_form_data()\n\n        # In debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        if (\n            current_app\n            and current_app.debug\n            and self.mimetype != \"multipart/form-data\"\n            and not self.files\n        ):\n            from .debughelpers import attach_enctype_error_multidict\n\n            attach_enctype_error_multidict(self)",
          "line_count": 14,
          "needs_llm_summary": true
        },
        {
          "name": "on_json_loading_failed",
          "args": [
            {
              "name": "self"
            },
            {
              "name": "e",
              "type": "Any"
            }
          ],
          "return_type": "t.Any",
          "lineno": 212,
          "decorators": [],
          "is_async": false,
          "calls": [
            "super",
            "unknown.on_json_loading_failed",
            "e",
            "BadRequest"
          ],
          "docstring": null,
          "code": "def on_json_loading_failed(self, e: ValueError | None) -> t.Any:\n        try:\n            return super().on_json_loading_failed(e)\n        except BadRequest as ebr:\n            if current_app and current_app.debug:\n                raise\n\n            raise BadRequest() from ebr",
          "line_count": 8,
          "needs_llm_summary": true
        },
        {
          "name": "max_cookie_size",
          "args": [
            {
              "name": "self"
            }
          ],
          "return_type": "int",
          "lineno": 247,
          "decorators": [
            {
              "name": "property",
              "args": [],
              "kwargs": {}
            }
          ],
          "is_async": false,
          "calls": [
            "super"
          ],
          "docstring": "Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n\nSee :attr:`~werkzeug.wrappers.Response.max_cookie_size` in\nWerkzeug's docs.",
          "code": "def max_cookie_size(self) -> int:  # type: ignore\n        \"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n\n        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in\n        Werkzeug's docs.\n        \"\"\"\n        if current_app:\n            return current_app.config[\"MAX_COOKIE_SIZE\"]  # type: ignore[no-any-return]\n\n        # return Werkzeug's default when not in an app context\n        return super().max_cookie_size",
          "line_count": 11,
          "needs_llm_summary": true
        }
      ],
      "classes": [
        {
          "name": "Request",
          "methods": [
            "max_content_length",
            "max_content_length",
            "max_form_memory_size",
            "max_form_memory_size",
            "max_form_parts",
            "max_form_parts",
            "endpoint",
            "blueprint",
            "blueprints",
            "_load_form_data",
            "on_json_loading_failed"
          ],
          "base_classes": [
            "RequestBase"
          ],
          "lineno": 18,
          "docstring": "The request object used by default in Flask.  Remembers the\nmatched endpoint and view arguments.\n\nIt is what ends up as :class:`~flask.request`.  If you want to replace\nthe request object used you can subclass this and set\n:attr:`~flask.Flask.request_class` to your subclass.\n\nThe request object is a :class:`~werkzeug.wrappers.Request` subclass and\nprovides all of the attributes Werkzeug defines plus a few Flask\nspecific ones."
        },
        {
          "name": "Response",
          "methods": [
            "max_cookie_size"
          ],
          "base_classes": [
            "ResponseBase"
          ],
          "lineno": 222,
          "docstring": "The response object that is used by default in Flask.  Works like the\nresponse object from Werkzeug but is set to have an HTML mimetype by\ndefault.  Quite often you don't have to create this object yourself because\n:meth:`~flask.Flask.make_response` will take care of that for you.\n\nIf you want to replace the response object used you can subclass this and\nset :attr:`~flask.Flask.response_class` to your subclass.\n\n.. versionchanged:: 1.0\n    JSON support is added to the response, like the request. This is useful\n    when testing to get the test client response data as JSON.\n\n.. versionchanged:: 1.0\n\n    Added :attr:`max_cookie_size`."
        }
      ],
      "imports": [
        {
          "module": "__future__",
          "name": "annotations",
          "alias": null,
          "lineno": 1,
          "type": "from_import"
        },
        {
          "module": "typing",
          "alias": "t",
          "lineno": 3,
          "type": "import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "BadRequest",
          "alias": null,
          "lineno": 5,
          "type": "from_import"
        },
        {
          "module": "werkzeug.exceptions",
          "name": "HTTPException",
          "alias": null,
          "lineno": 6,
          "type": "from_import"
        },
        {
          "module": "werkzeug.wrappers",
          "name": "Request",
          "alias": "RequestBase",
          "lineno": 7,
          "type": "from_import"
        },
        {
          "module": "werkzeug.wrappers",
          "name": "Response",
          "alias": "ResponseBase",
          "lineno": 8,
          "type": "from_import"
        },
        {
          "module": "",
          "name": "json",
          "alias": null,
          "lineno": 10,
          "type": "from_import"
        },
        {
          "module": "globals",
          "name": "current_app",
          "alias": null,
          "lineno": 11,
          "type": "from_import"
        },
        {
          "module": "helpers",
          "name": "_split_blueprint_path",
          "alias": null,
          "lineno": 12,
          "type": "from_import"
        },
        {
          "module": "werkzeug.routing",
          "name": "Rule",
          "alias": null,
          "lineno": 15,
          "type": "from_import"
        },
        {
          "module": "debughelpers",
          "name": "attach_enctype_error_multidict",
          "alias": null,
          "lineno": 208,
          "type": "from_import"
        }
      ],
      "variables": [],
      "is_entry_point": false,
      "main_block_calls": [],
      "module_level_calls": {
        "function_calls": [],
        "class_instantiations": []
      },
      "dependency_classification": {
        "stdlib": [
          "typing",
          "json"
        ],
        "third_party": {
          "other": [
            "__future__",
            "werkzeug",
            "globals",
            "helpers",
            "debughelpers"
          ]
        },
        "tech_stack": []
      },
      "line_count": 258
    },
    "__analysis_summary__": {
      "total_modules": 34,
      "total_functions": 281,
      "total_classes": 52,
      "dead_code_candidates": {
        "unreferenced_functions": [
          {
            "name": "setup",
            "module": "docs/conf.py",
            "lineno": 100
          },
          {
            "name": "block",
            "module": "examples/celery/src/task_app/tasks.py",
            "lineno": 13
          },
          {
            "name": "process",
            "module": "examples/celery/src/task_app/tasks.py",
            "lineno": 18
          },
          {
            "name": "block",
            "module": "examples/celery/src/task_app/views.py",
            "lineno": 30
          },
          {
            "name": "process",
            "module": "examples/celery/src/task_app/views.py",
            "lineno": 36
          },
          {
            "name": "login_required",
            "module": "examples/tutorial/flaskr/auth.py",
            "lineno": 19
          },
          {
            "name": "load_logged_in_user",
            "module": "examples/tutorial/flaskr/auth.py",
            "lineno": 33
          },
          {
            "name": "_make_timedelta",
            "module": "src/flask/app.py",
            "lineno": 72
          },
          {
            "name": "open_instance_resource",
            "module": "src/flask/app.py",
            "lineno": 446
          },
          {
            "name": "test_client",
            "module": "src/flask/app.py",
            "lineno": 754
          },
          {
            "name": "test_cli_runner",
            "module": "src/flask/app.py",
            "lineno": 812
          },
          {
            "name": "_path_is_ancestor",
            "module": "src/flask/cli.py",
            "lineno": 691
          },
          {
            "name": "from_envvar",
            "module": "src/flask/config.py",
            "lineno": 102
          },
          {
            "name": "from_file",
            "module": "src/flask/config.py",
            "lineno": 256
          },
          {
            "name": "get_namespace",
            "module": "src/flask/config.py",
            "lineno": 323
          },
          {
            "name": "_make_timedelta",
            "module": "src/flask/sansio/app.py",
            "lineno": 52
          },
          {
            "name": "template_filter",
            "module": "src/flask/sansio/app.py",
            "lineno": 661
          },
          {
            "name": "template_filter",
            "module": "src/flask/sansio/app.py",
            "lineno": 663
          },
          {
            "name": "template_filter",
            "module": "src/flask/sansio/app.py",
            "lineno": 667
          },
          {
            "name": "template_test",
            "module": "src/flask/sansio/app.py",
            "lineno": 711
          },
          {
            "name": "template_test",
            "module": "src/flask/sansio/app.py",
            "lineno": 713
          },
          {
            "name": "template_test",
            "module": "src/flask/sansio/app.py",
            "lineno": 717
          },
          {
            "name": "template_global",
            "module": "src/flask/sansio/app.py",
            "lineno": 770
          },
          {
            "name": "template_global",
            "module": "src/flask/sansio/app.py",
            "lineno": 772
          },
          {
            "name": "template_global",
            "module": "src/flask/sansio/app.py",
            "lineno": 776
          },
          {
            "name": "shell_context_processor",
            "module": "src/flask/sansio/app.py",
            "lineno": 855
          },
          {
            "name": "app_template_filter",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 444
          },
          {
            "name": "app_template_filter",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 446
          },
          {
            "name": "app_template_filter",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 450
          },
          {
            "name": "app_template_test",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 498
          },
          {
            "name": "app_template_test",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 500
          },
          {
            "name": "app_template_test",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 504
          },
          {
            "name": "app_template_global",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 556
          },
          {
            "name": "app_template_global",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 558
          },
          {
            "name": "app_template_global",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 562
          },
          {
            "name": "before_app_request",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 614
          },
          {
            "name": "after_app_request",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 624
          },
          {
            "name": "teardown_app_request",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 634
          },
          {
            "name": "app_context_processor",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 644
          },
          {
            "name": "app_errorhandler",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 656
          },
          {
            "name": "app_url_value_preprocessor",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 673
          },
          {
            "name": "app_url_defaults",
            "module": "src/flask/sansio/blueprints.py",
            "lineno": 685
          },
          {
            "name": "setupmethod",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 42
          },
          {
            "name": "put",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 312
          },
          {
            "name": "delete",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 320
          },
          {
            "name": "patch",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 328
          },
          {
            "name": "before_request",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 460
          },
          {
            "name": "after_request",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 487
          },
          {
            "name": "teardown_request",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 508
          },
          {
            "name": "context_processor",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 542
          },
          {
            "name": "url_value_preprocessor",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 559
          },
          {
            "name": "_lazy_sha1",
            "module": "src/flask/sessions.py",
            "lineno": 290
          },
          {
            "name": "permanent",
            "module": "src/flask/sessions.py",
            "lineno": 33
          },
          {
            "name": "_fail",
            "module": "src/flask/sessions.py",
            "lineno": 103
          },
          {
            "name": "_default_template_ctx_processor",
            "module": "src/flask/templating.py",
            "lineno": 21
          },
          {
            "name": "json_dumps",
            "module": "src/flask/testing.py",
            "lineno": 88
          },
          {
            "name": "session_transaction",
            "module": "src/flask/testing.py",
            "lineno": 136
          },
          {
            "name": "max_content_length",
            "module": "src/flask/wrappers.py",
            "lineno": 89
          },
          {
            "name": "max_form_memory_size",
            "module": "src/flask/wrappers.py",
            "lineno": 116
          },
          {
            "name": "max_form_parts",
            "module": "src/flask/wrappers.py",
            "lineno": 143
          }
        ],
        "unused_classes": [
          {
            "name": "ConfigAttribute",
            "module": "src/flask/config.py",
            "lineno": 20
          },
          {
            "name": "_AppCtxGlobals",
            "module": "src/flask/ctx.py",
            "lineno": 29
          },
          {
            "name": "UnexpectedUnicodeError",
            "module": "src/flask/debughelpers.py",
            "lineno": 17
          },
          {
            "name": "ProxyMixin",
            "module": "src/flask/globals.py",
            "lineno": 17
          },
          {
            "name": "FlaskProxy",
            "module": "src/flask/globals.py",
            "lineno": 22
          },
          {
            "name": "AppContextProxy",
            "module": "src/flask/globals.py",
            "lineno": 24
          },
          {
            "name": "_AppCtxGlobalsProxy",
            "module": "src/flask/globals.py",
            "lineno": 26
          },
          {
            "name": "RequestProxy",
            "module": "src/flask/globals.py",
            "lineno": 28
          },
          {
            "name": "SessionMixinProxy",
            "module": "src/flask/globals.py",
            "lineno": 30
          },
          {
            "name": "JSONProvider",
            "module": "src/flask/json/provider.py",
            "lineno": 19
          },
          {
            "name": "DefaultJSONProvider",
            "module": "src/flask/json/provider.py",
            "lineno": 124
          },
          {
            "name": "JSONTag",
            "module": "src/flask/json/tag.py",
            "lineno": 60
          },
          {
            "name": "TagDict",
            "module": "src/flask/json/tag.py",
            "lineno": 93
          },
          {
            "name": "PassDict",
            "module": "src/flask/json/tag.py",
            "lineno": 119
          },
          {
            "name": "TagTuple",
            "module": "src/flask/json/tag.py",
            "lineno": 133
          },
          {
            "name": "PassList",
            "module": "src/flask/json/tag.py",
            "lineno": 147
          },
          {
            "name": "TagBytes",
            "module": "src/flask/json/tag.py",
            "lineno": 159
          },
          {
            "name": "TagMarkup",
            "module": "src/flask/json/tag.py",
            "lineno": 173
          },
          {
            "name": "TagUUID",
            "module": "src/flask/json/tag.py",
            "lineno": 191
          },
          {
            "name": "TagDateTime",
            "module": "src/flask/json/tag.py",
            "lineno": 205
          },
          {
            "name": "Scaffold",
            "module": "src/flask/sansio/scaffold.py",
            "lineno": 52
          },
          {
            "name": "SessionMixin",
            "module": "src/flask/sessions.py",
            "lineno": 24
          },
          {
            "name": "SecureCookieSession",
            "module": "src/flask/sessions.py",
            "lineno": 52
          },
          {
            "name": "NullSession",
            "module": "src/flask/sessions.py",
            "lineno": 97
          },
          {
            "name": "SessionInterface",
            "module": "src/flask/sessions.py",
            "lineno": 114
          },
          {
            "name": "SecureCookieSessionInterface",
            "module": "src/flask/sessions.py",
            "lineno": 298
          },
          {
            "name": "Environment",
            "module": "src/flask/templating.py",
            "lineno": 35
          },
          {
            "name": "FlaskClient",
            "module": "src/flask/testing.py",
            "lineno": 109
          },
          {
            "name": "FlaskCliRunner",
            "module": "src/flask/testing.py",
            "lineno": 265
          },
          {
            "name": "View",
            "module": "src/flask/views.py",
            "lineno": 16
          },
          {
            "name": "MethodView",
            "module": "src/flask/views.py",
            "lineno": 138
          }
        ],
        "unused_imports": [
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "import_statement": "import auth",
            "lineno": 10,
            "imported_module": "auth",
            "symbols": [
              "login_required"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import types",
            "lineno": 13,
            "imported_module": "types",
            "symbols": [
              "TracebackType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import werkzeug.datastructures",
            "lineno": 17,
            "imported_module": "werkzeug.datastructures",
            "symbols": [
              "Headers"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import werkzeug.datastructures",
            "lineno": 18,
            "imported_module": "werkzeug.datastructures",
            "symbols": [
              "ImmutableDict"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import werkzeug.routing",
            "lineno": 22,
            "imported_module": "werkzeug.routing",
            "symbols": [
              "BuildError"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import werkzeug.routing",
            "lineno": 23,
            "imported_module": "werkzeug.routing",
            "symbols": [
              "MapAdapter"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import werkzeug.routing",
            "lineno": 26,
            "imported_module": "werkzeug.routing",
            "symbols": [
              "Rule"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import sessions",
            "lineno": 44,
            "imported_module": "sessions",
            "symbols": [
              "SecureCookieSessionInterface"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import sessions",
            "lineno": 45,
            "imported_module": "sessions",
            "symbols": [
              "SessionInterface"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/app.py",
            "import_statement": "import typing",
            "lineno": 61,
            "imported_module": "typing",
            "symbols": [
              "HeadersValue"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/blueprints.py",
            "import_statement": "import sansio.blueprints",
            "lineno": 11,
            "imported_module": "sansio.blueprints",
            "symbols": [
              "BlueprintSetupState"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/blueprints.py",
            "import_statement": "import sansio.scaffold",
            "lineno": 12,
            "imported_module": "sansio.scaffold",
            "symbols": [
              "_sentinel"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/cli.py",
            "import_statement": "import click.core",
            "lineno": 18,
            "imported_module": "click.core",
            "symbols": [
              "ParameterSource"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/cli.py",
            "import_statement": "import _typeshed.wsgi",
            "lineno": 31,
            "imported_module": "_typeshed.wsgi",
            "symbols": [
              "WSGIApplication"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/cli.py",
            "import_statement": "import cryptography",
            "lineno": 810,
            "imported_module": "cryptography",
            "symbols": [
              "cryptography"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/config.py",
            "import_statement": "import errno",
            "lineno": 3,
            "imported_module": "errno",
            "symbols": [
              "errno"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/ctx.py",
            "import_statement": "import contextvars",
            "lineno": 3,
            "imported_module": "contextvars",
            "symbols": [
              "contextvars"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/ctx.py",
            "import_statement": "import types",
            "lineno": 6,
            "imported_module": "types",
            "symbols": [
              "TracebackType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/ctx.py",
            "import_statement": "import werkzeug.exceptions",
            "lineno": 8,
            "imported_module": "werkzeug.exceptions",
            "symbols": [
              "HTTPException"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/ctx.py",
            "import_statement": "import werkzeug.routing",
            "lineno": 9,
            "imported_module": "werkzeug.routing",
            "symbols": [
              "MapAdapter"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/ctx.py",
            "import_statement": "import _typeshed.wsgi",
            "lineno": 18,
            "imported_module": "_typeshed.wsgi",
            "symbols": [
              "WSGIEnvironment"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/helpers.py",
            "import_statement": "import datetime",
            "lineno": 7,
            "imported_module": "datetime",
            "symbols": [
              "datetime"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/helpers.py",
            "import_statement": "import functools",
            "lineno": 8,
            "imported_module": "functools",
            "symbols": [
              "cache"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/json/provider.py",
            "import_statement": "import decimal",
            "lineno": 4,
            "imported_module": "decimal",
            "symbols": [
              "decimal"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/json/provider.py",
            "import_statement": "import uuid",
            "lineno": 7,
            "imported_module": "uuid",
            "symbols": [
              "uuid"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/logging.py",
            "import_statement": "import sys",
            "lineno": 4,
            "imported_module": "sys",
            "symbols": [
              "sys"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/logging.py",
            "import_statement": "import werkzeug.local",
            "lineno": 7,
            "imported_module": "werkzeug.local",
            "symbols": [
              "LocalProxy"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import werkzeug.routing",
            "lineno": 14,
            "imported_module": "werkzeug.routing",
            "symbols": [
              "Map"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import werkzeug.routing",
            "lineno": 15,
            "imported_module": "werkzeug.routing",
            "symbols": [
              "Rule"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import werkzeug.utils",
            "lineno": 17,
            "imported_module": "werkzeug.utils",
            "symbols": [
              "cached_property"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import config",
            "lineno": 22,
            "imported_module": "config",
            "symbols": [
              "ConfigAttribute"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import ctx",
            "lineno": 23,
            "imported_module": "ctx",
            "symbols": [
              "_AppCtxGlobals"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import json.provider",
            "lineno": 26,
            "imported_module": "json.provider",
            "symbols": [
              "DefaultJSONProvider"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import json.provider",
            "lineno": 27,
            "imported_module": "json.provider",
            "symbols": [
              "JSONProvider"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import scaffold",
            "lineno": 34,
            "imported_module": "scaffold",
            "symbols": [
              "setupmethod"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import testing",
            "lineno": 39,
            "imported_module": "testing",
            "symbols": [
              "FlaskClient"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/app.py",
            "import_statement": "import testing",
            "lineno": 40,
            "imported_module": "testing",
            "symbols": [
              "FlaskCliRunner"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "import_statement": "import scaffold",
            "lineno": 10,
            "imported_module": "scaffold",
            "symbols": [
              "_sentinel"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "import_statement": "import scaffold",
            "lineno": 12,
            "imported_module": "scaffold",
            "symbols": [
              "setupmethod"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "import_statement": "import jinja2",
            "lineno": 11,
            "imported_module": "jinja2",
            "symbols": [
              "BaseLoader"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "import_statement": "import werkzeug.exceptions",
            "lineno": 13,
            "imported_module": "werkzeug.exceptions",
            "symbols": [
              "default_exceptions"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "import_statement": "import werkzeug.utils",
            "lineno": 15,
            "imported_module": "werkzeug.utils",
            "symbols": [
              "cached_property"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "import_statement": "import templating",
            "lineno": 19,
            "imported_module": "templating",
            "symbols": [
              "_default_template_ctx_processor"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "import_statement": "import click",
            "lineno": 22,
            "imported_module": "click",
            "symbols": [
              "Group"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sessions.py",
            "import_statement": "import collections.abc",
            "lineno": 6,
            "imported_module": "collections.abc",
            "symbols": [
              "MutableMapping"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sessions.py",
            "import_statement": "import itsdangerous",
            "lineno": 10,
            "imported_module": "itsdangerous",
            "symbols": [
              "BadSignature"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/sessions.py",
            "import_statement": "import werkzeug.datastructures",
            "lineno": 12,
            "imported_module": "werkzeug.datastructures",
            "symbols": [
              "CallbackDict"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/testing.py",
            "import_statement": "import contextlib",
            "lineno": 5,
            "imported_module": "contextlib",
            "symbols": [
              "contextmanager"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/testing.py",
            "import_statement": "import types",
            "lineno": 8,
            "imported_module": "types",
            "symbols": [
              "TracebackType"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/typing.py",
            "import_statement": "import collections.abc",
            "lineno": 3,
            "imported_module": "collections.abc",
            "symbols": [
              "cabc"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/typing.py",
            "import_statement": "import _typeshed.wsgi",
            "lineno": 7,
            "imported_module": "_typeshed.wsgi",
            "symbols": [
              "WSGIApplication"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/typing.py",
            "import_statement": "import werkzeug.datastructures",
            "lineno": 8,
            "imported_module": "werkzeug.datastructures",
            "symbols": [
              "Headers"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/wrappers.py",
            "import_statement": "import werkzeug.exceptions",
            "lineno": 6,
            "imported_module": "werkzeug.exceptions",
            "symbols": [
              "HTTPException"
            ],
            "needs_llm": false
          },
          {
            "module": "src/flask/wrappers.py",
            "import_statement": "import werkzeug.routing",
            "lineno": 15,
            "imported_module": "werkzeug.routing",
            "symbols": [
              "Rule"
            ],
            "needs_llm": false
          }
        ],
        "unused_global_variables": [
          {
            "module": "examples/celery/make_celery.py",
            "name": "celery_app",
            "lineno": 4,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/__init__.py",
            "name": "app",
            "lineno": 3,
            "assigned_to": "Flask",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "T_shell_context_processor",
            "lineno": 63,
            "assigned_to": "t.TypeVar",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "T_teardown",
            "lineno": 66,
            "assigned_to": "t.TypeVar",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "T_template_filter",
            "lineno": 67,
            "assigned_to": "t.TypeVar",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "T_template_global",
            "lineno": 68,
            "assigned_to": "t.TypeVar",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "T_template_test",
            "lineno": 69,
            "assigned_to": "t.TypeVar",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "_sentinel",
            "lineno": 25,
            "assigned_to": "object",
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "AppOrBlueprintKey",
            "lineno": 49,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "AfterRequestCallable",
            "lineno": 50,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "BeforeFirstRequestCallable",
            "lineno": 54,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "BeforeRequestCallable",
            "lineno": 55,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "ShellContextProcessorCallable",
            "lineno": 59,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "TeardownCallable",
            "lineno": 60,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "TemplateContextProcessorCallable",
            "lineno": 64,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "TemplateFilterCallable",
            "lineno": 67,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "TemplateGlobalCallable",
            "lineno": 68,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "TemplateTestCallable",
            "lineno": 69,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "URLDefaultCallable",
            "lineno": 70,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "URLValuePreprocessorCallable",
            "lineno": 71,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "ErrorHandlerCallable",
            "lineno": 79,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/typing.py",
            "name": "RouteCallable",
            "lineno": 84,
            "assigned_to": null,
            "needs_llm": true
          },
          {
            "module": "src/flask/views.py",
            "name": "F",
            "lineno": 9,
            "assigned_to": "t.TypeVar",
            "needs_llm": true
          }
        ],
        "unreachable_code": [],
        "suspicious_patterns": [
          {
            "module": "docs/conf.py",
            "name": "github_link",
            "lineno": 72,
            "pattern_type": "too_many_parameters",
            "details": "Function has 7 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "run",
            "lineno": 631,
            "pattern_type": "long_function",
            "details": "Function is very long (122 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "url_for",
            "lineno": 1090,
            "pattern_type": "long_function",
            "details": "Function is very long (121 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "make_response",
            "lineno": 1212,
            "pattern_type": "long_function",
            "details": "Function is very long (141 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "run_command",
            "lineno": 935,
            "pattern_type": "too_many_parameters",
            "details": "Function has 9 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "send_file",
            "lineno": 401,
            "pattern_type": "long_function",
            "details": "Function is very long (124 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "send_file",
            "lineno": 401,
            "pattern_type": "too_many_parameters",
            "details": "Function has 8 parameters - consider parameter object",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "name": "register",
            "lineno": 273,
            "pattern_type": "long_function",
            "details": "Function is very long (105 lines) - consider refactoring",
            "needs_llm": true
          },
          {
            "module": "docs/conf.py",
            "name": "setup",
            "lineno": 100,
            "pattern_type": "similar_function_names",
            "details": "Similar to setupmethod in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/__init__.py",
            "name": "create_app",
            "lineno": 7,
            "pattern_type": "similar_function_names",
            "details": "Similar to create in examples/tutorial/flaskr/blog.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_ctx in src/flask/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_filter in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_test in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_global in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "add",
            "lineno": 8,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/tasks.py",
            "name": "process",
            "lineno": 18,
            "pattern_type": "similar_function_names",
            "details": "Similar to process_response in src/flask/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_ctx in src/flask/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_filter in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_test in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_global in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "add",
            "lineno": 22,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/celery/src/task_app/views.py",
            "name": "process",
            "lineno": 36,
            "pattern_type": "similar_function_names",
            "details": "Similar to process_response in src/flask/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_ctx in src/flask/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_filter in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_test in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_template_global in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/javascript/js_example/views.py",
            "name": "add",
            "lineno": 15,
            "pattern_type": "similar_function_names",
            "details": "Similar to add_url_rule in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/__init__.py",
            "name": "create_app",
            "lineno": 6,
            "pattern_type": "similar_function_names",
            "details": "Similar to create in examples/tutorial/flaskr/blog.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "login_required",
            "lineno": 19,
            "pattern_type": "similar_function_names",
            "details": "Similar to login in examples/tutorial/flaskr/auth.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "load_logged_in_user",
            "lineno": 33,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/__init__.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "load_logged_in_user",
            "lineno": 33,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "register",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_blueprint in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "register",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_blueprint in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "register",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "register",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "register",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/auth.py",
            "name": "register",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_error_handler in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "get_post",
            "lineno": 28,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "get_post",
            "lineno": 28,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "get_post",
            "lineno": 28,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "create",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to create_jinja_environment in src/flask/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "create",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to create_url_adapter in src/flask/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "create",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to create_logger in src/flask/logging.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "create",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to create_jinja_environment in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "create",
            "lineno": 62,
            "pattern_type": "similar_function_names",
            "details": "Similar to create_global_jinja_loader in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/blog.py",
            "name": "update",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to update_template_context in src/flask/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/db.py",
            "name": "get_db",
            "lineno": 9,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/db.py",
            "name": "get_db",
            "lineno": 9,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/db.py",
            "name": "get_db",
            "lineno": 9,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "examples/tutorial/flaskr/db.py",
            "name": "init_db",
            "lineno": 33,
            "pattern_type": "similar_function_names",
            "details": "Similar to init_db_command in examples/tutorial/flaskr/db.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "wrapper",
            "lineno": 85,
            "pattern_type": "similar_function_names",
            "details": "Similar to wrapper_func in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "wrapper",
            "lineno": 97,
            "pattern_type": "similar_function_names",
            "details": "Similar to wrapper_func in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "get_send_file_max_age",
            "lineno": 364,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "get_send_file_max_age",
            "lineno": 364,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "get_send_file_max_age",
            "lineno": 364,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "open_resource",
            "lineno": 413,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "open_instance_resource",
            "lineno": 446,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "run",
            "lineno": 631,
            "pattern_type": "similar_function_names",
            "details": "Similar to run_command in src/flask/cli.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "app_context",
            "lineno": 1451,
            "pattern_type": "similar_function_names",
            "details": "Similar to app in src/flask/cli.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "app_context",
            "lineno": 1451,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_context_processor in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/app.py",
            "name": "request_context",
            "lineno": 1471,
            "pattern_type": "similar_function_names",
            "details": "Similar to request in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/blueprints.py",
            "name": "get_send_file_max_age",
            "lineno": 55,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/blueprints.py",
            "name": "get_send_file_max_age",
            "lineno": 55,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/blueprints.py",
            "name": "get_send_file_max_age",
            "lineno": 55,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/blueprints.py",
            "name": "open_resource",
            "lineno": 104,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "get_version",
            "lineno": 267,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "get_version",
            "lineno": 267,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "get_version",
            "lineno": 267,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "load_dotenv",
            "lineno": 698,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/__init__.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "load_dotenv",
            "lineno": 698,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "routes_command",
            "lineno": 1061,
            "pattern_type": "similar_function_names",
            "details": "Similar to route in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "load_app",
            "lineno": 333,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/__init__.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "load_app",
            "lineno": 333,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "get_command",
            "lineno": 609,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "get_command",
            "lineno": 609,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "get_command",
            "lineno": 609,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_context_processor in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_errorhandler in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_url_value_preprocessor in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/cli.py",
            "name": "app",
            "lineno": 963,
            "pattern_type": "similar_function_names",
            "details": "Similar to app_url_defaults in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 30,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 30,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 30,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 33,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 33,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 33,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 35,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 35,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "__get__",
            "lineno": 35,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "get_namespace",
            "lineno": 323,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "get_namespace",
            "lineno": 323,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/config.py",
            "name": "get_namespace",
            "lineno": 323,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "copy_current_request_context",
            "lineno": 153,
            "pattern_type": "similar_function_names",
            "details": "Similar to copy in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "has_request_context",
            "lineno": 208,
            "pattern_type": "similar_function_names",
            "details": "Similar to has_request in src/flask/ctx.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_debug_flag in src/flask/helpers.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_load_dotenv in src/flask/helpers.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_template_attribute in src/flask/helpers.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_flashed_messages in src/flask/helpers.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_root_path in src/flask/helpers.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_name in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_domain in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_path in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_httponly in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_secure in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_samesite in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_partitioned in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_expiration_time in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_signing_serializer in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "get",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_source in src/flask/templating.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "wrapper",
            "lineno": 201,
            "pattern_type": "similar_function_names",
            "details": "Similar to wrapper_func in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/ctx.py",
            "name": "session",
            "lineno": 381,
            "pattern_type": "similar_function_names",
            "details": "Similar to session_transaction in src/flask/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_debug_flag",
            "lineno": 27,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_debug_flag",
            "lineno": 27,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_load_dotenv",
            "lineno": 35,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_load_dotenv",
            "lineno": 35,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_template_attribute",
            "lineno": 288,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_template_attribute",
            "lineno": 288,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_flashed_messages",
            "lineno": 344,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_flashed_messages",
            "lineno": 344,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_root_path",
            "lineno": 571,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/helpers.py",
            "name": "get_root_path",
            "lineno": 571,
            "pattern_type": "similar_function_names",
            "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "dumps",
            "lineno": 13,
            "pattern_type": "similar_function_names",
            "details": "Similar to dump in src/flask/json/__init__.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "dumps",
            "lineno": 13,
            "pattern_type": "similar_function_names",
            "details": "Similar to dump in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "dump",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to dumps in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "dump",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to dumps in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "dump",
            "lineno": 47,
            "pattern_type": "similar_function_names",
            "details": "Similar to dumps in src/flask/json/tag.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "loads",
            "lineno": 77,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/__init__.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "loads",
            "lineno": 77,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "load",
            "lineno": 108,
            "pattern_type": "similar_function_names",
            "details": "Similar to loads in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "load",
            "lineno": 108,
            "pattern_type": "similar_function_names",
            "details": "Similar to loads in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/__init__.py",
            "name": "load",
            "lineno": 108,
            "pattern_type": "similar_function_names",
            "details": "Similar to loads in src/flask/json/tag.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/provider.py",
            "name": "_default",
            "lineno": 108,
            "pattern_type": "similar_function_names",
            "details": "Similar to _default_template_ctx_processor in src/flask/templating.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/provider.py",
            "name": "dumps",
            "lineno": 41,
            "pattern_type": "similar_function_names",
            "details": "Similar to dump in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/provider.py",
            "name": "dump",
            "lineno": 49,
            "pattern_type": "similar_function_names",
            "details": "Similar to dumps in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/provider.py",
            "name": "dump",
            "lineno": 49,
            "pattern_type": "similar_function_names",
            "details": "Similar to dumps in src/flask/json/tag.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/provider.py",
            "name": "loads",
            "lineno": 59,
            "pattern_type": "similar_function_names",
            "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/provider.py",
            "name": "load",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to loads in src/flask/json/provider.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/provider.py",
            "name": "load",
            "lineno": 67,
            "pattern_type": "similar_function_names",
            "details": "Similar to loads in src/flask/json/tag.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/tag.py",
            "name": "register",
            "lineno": 256,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_blueprint in src/flask/sansio/app.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/tag.py",
            "name": "register",
            "lineno": 256,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_blueprint in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/tag.py",
            "name": "register",
            "lineno": 256,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/tag.py",
            "name": "register",
            "lineno": 256,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/tag.py",
            "name": "register",
            "lineno": 256,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/json/tag.py",
            "name": "register",
            "lineno": 256,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_error_handler in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/app.py",
            "name": "register_blueprint",
            "lineno": 567,
            "pattern_type": "similar_function_names",
            "details": "Similar to register in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "name": "record",
            "lineno": 224,
            "pattern_type": "similar_function_names",
            "details": "Similar to record_once in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "name": "register_blueprint",
            "lineno": 256,
            "pattern_type": "similar_function_names",
            "details": "Similar to register in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "name": "register",
            "lineno": 273,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "name": "register",
            "lineno": 273,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "name": "register",
            "lineno": 273,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "name": "register",
            "lineno": 273,
            "pattern_type": "similar_function_names",
            "details": "Similar to register_error_handler in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/blueprints.py",
            "name": "wrapper",
            "lineno": 240,
            "pattern_type": "similar_function_names",
            "details": "Similar to wrapper_func in src/flask/sansio/scaffold.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_name in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_domain in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_path in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_httponly in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_secure in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_samesite in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_partitioned in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_expiration_time in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_signing_serializer in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sansio/scaffold.py",
            "name": "get",
            "lineno": 296,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_source in src/flask/templating.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_name in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_domain in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_path in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_httponly in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_secure in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_samesite in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_cookie_partitioned in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_expiration_time in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_signing_serializer in src/flask/sessions.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "get",
            "lineno": 88,
            "pattern_type": "similar_function_names",
            "details": "Similar to get_source in src/flask/templating.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "open_session",
            "lineno": 263,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/sessions.py",
            "name": "open_session",
            "lineno": 337,
            "pattern_type": "similar_function_names",
            "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/templating.py",
            "name": "render_template",
            "lineno": 135,
            "pattern_type": "similar_function_names",
            "details": "Similar to render_template_string in src/flask/templating.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/templating.py",
            "name": "stream_template",
            "lineno": 180,
            "pattern_type": "similar_function_names",
            "details": "Similar to stream_template_string in src/flask/templating.py - possible duplicate logic",
            "needs_llm": true
          },
          {
            "module": "src/flask/wrappers.py",
            "name": "blueprint",
            "lineno": 162,
            "pattern_type": "similar_function_names",
            "details": "Similar to blueprints in src/flask/wrappers.py - possible duplicate logic",
            "needs_llm": true
          }
        ]
      }
    }
  },
  "function_summaries": {
    "docs/conf.py": {
      "github_link": {
        "human": "Creates clickable links in documentation that point to specific files or folders in the Flask GitHub repository. The link automatically adjusts to point to either the current release version or the main development branch depending on whether you're viewing documentation for a stable release or a development version. You can optionally customize the link text that users see.",
        "technical": "Implements a Sphinx/docutils custom role that generates reference nodes linking to Flask's GitHub repository. Parses optional custom link text using rsplit on \"<\" delimiter, determines target URL by checking if current release is a dev version (using packaging.version.parse), constructs GitHub tree URLs accordingly (main branch vs release tag), and returns a docutils reference node with the computed URL. Takes standard docutils role parameters and returns tuple of node list and empty messages list."
      }
    },
    "examples/celery/src/task_app/__init__.py": {
      "create_app": {
        "human": "Creates and sets up a web application that can handle background tasks. It configures the app to use Redis (a data storage system) for managing work that happens behind the scenes, sets up a homepage, and connects additional features from other parts of the codebase. This is the main starting point that brings all pieces of the web application together.",
        "technical": "Factory function that instantiates a Flask application with Celery integration for asynchronous task processing. Configures Celery with Redis broker/backend via `from_mapping()`, overrides with environment variables via `from_prefixed_env()`, initializes Celery with `celery_init_app()`, registers a root route rendering index.html, imports and registers a views blueprint, and returns the configured Flask app instance."
      },
      "celery_init_app": {
        "human": "Sets up a background task system (Celery) for a Flask web application. This allows the web app to handle time-consuming jobs (like sending emails or processing data) in the background without making users wait. It ensures these background tasks can access the same application settings and database connections that the main web app uses.",
        "technical": "Initializes a Celery instance integrated with Flask by creating a custom FlaskTask class that wraps task execution within Flask's app_context(). Creates Celery app with Flask's name and custom task class, loads configuration from app.config[\"CELERY\"], sets it as default, stores reference in app.extensions[\"celery\"], and returns the configured Celery instance. The app_context wrapper ensures tasks have access to Flask's request-scoped resources."
      },
      "__call__": {
        "human": "This function makes an object behave like it can be called as if it were a regular function. When called, it ensures that the actual work happens within the proper application environment (context), which is necessary for the operation to access application resources and settings correctly.",
        "technical": "Implements the `__call__` magic method to make instances callable. Wraps the execution of `self.run(*args, **kwargs)` within Flask's `app.app_context()` context manager, ensuring application context is available during execution. Forwards all positional and keyword arguments to the `run` method and returns its result. The context manager handles proper setup/teardown of Flask application state."
      }
    },
    "examples/celery/src/task_app/tasks.py": {
      "process": {
        "human": "This function simulates a long-running task that tracks its progress step-by-step. It counts from 1 to a specified total number, pausing for one second at each step, and reports how far along it is. This is typically used for background jobs where you want to show users a progress bar or percentage complete, like processing a batch of items or running a lengthy calculation.",
        "technical": "Celery shared task that iterates from 0 to `total`, calling `self.update_state()` at each iteration to publish progress metadata (current count and total) with \"PROGRESS\" state. Includes 1-second sleep per iteration via `time.sleep(1)` to simulate work. Returns a dictionary containing final current and total values upon completion. Uses Celery's Task instance methods for state management in distributed task queues."
      }
    },
    "examples/celery/src/task_app/views.py": {
      "result": {
        "human": "Checks the status of a background task that was started earlier. When you start a long-running job, you get an ID number. This function takes that ID and tells you whether the job is finished yet, whether it completed successfully, and what the result is if it's done. If the job is still running, it shows you the current state instead of the final result.",
        "technical": "Retrieves status of a Celery asynchronous task using AsyncResult with the provided task ID. Calls `ready()` to check completion status, conditionally calls `successful()` only if task is complete, and returns either the final value via `get()` or the intermediate result object. Returns a dictionary with three keys: ready (boolean), successful (boolean or None), and value (task result or result object). Decorated with `bp.get` indicating it's a GET endpoint in a Flask/Blueprint API."
      },
      "add": {
        "human": "This function receives two numbers from a web form submission and schedules them to be added together in the background. Instead of calculating the sum immediately, it hands off the work to a task queue and gives back a tracking ID so you can check on the result later. This allows the web page to respond quickly without waiting for the calculation to finish.",
        "technical": "Flask POST endpoint that extracts two integer parameters ('a' and 'b') from form data using `request.form.get()`, then dispatches an asynchronous Celery task via `tasks.add.delay()`. Returns a JSON dictionary containing the Celery task ID for result retrieval. Uses the `@bp.post` decorator for route registration. No validation or error handling for missing/invalid inputs."
      },
      "block": {
        "human": "This function starts a blocking operation in the background and immediately returns a tracking ID. It's like submitting a long-running task to a queue and getting a receipt number you can use later to check on its status or retrieve results. The actual work happens separately, so the user doesn't have to wait for it to complete.",
        "technical": "HTTP POST endpoint that asynchronously dispatches a Celery task (`tasks.block.delay()`) and returns a JSON response containing the task's unique identifier. Uses the `bp.post` decorator to register as a POST route. Returns a dictionary with a single key `result_id` mapped to the Celery AsyncResult ID, enabling clients to poll or retrieve task status/results later."
      },
      "process": {
        "human": "This function receives a request to start a background processing task. When someone submits a form with a \"total\" number, it kicks off that task to run separately (without making the user wait) and immediately gives back a tracking ID so they can check on the task's progress later.",
        "technical": "Flask POST endpoint that extracts an integer \"total\" parameter from form data using `request.form.get()`, dispatches an asynchronous Celery task via `tasks.process.delay()`, and returns a JSON response containing the Celery task's result ID. Uses the `bp.post` decorator for route registration. No error handling for missing/invalid form data."
      }
    },
    "examples/javascript/js_example/views.py": {
      "add": {
        "human": "This function provides a simple calculator feature that adds two numbers together. When someone submits two numbers through a web form, it receives them, performs the addition, and sends back the result. If no numbers are provided, it treats missing values as zero. This is typically used as part of a web application where users need to perform basic arithmetic.",
        "technical": "Flask route handler that extracts two form parameters 'a' and 'b' using request.form.get() with default value 0 and type coercion to float. Performs addition operation on the extracted values and returns the sum as JSON response via jsonify() with key 'result'. Uses the @app.route decorator to map this function to a URL endpoint. No error handling for invalid float conversions."
      }
    },
    "examples/tutorial/flaskr/__init__.py": {
      "create_app": {
        "human": "Sets up and configures a Flask web application for a blog platform. It establishes default settings like security keys and database location, creates necessary folders, and connects different parts of the application (authentication, blog posts, database) so they work together. Also creates a simple test page that says \"Hello, World!\" to verify the app is running.",
        "technical": "Instantiates Flask app with instance-relative config, sets default SECRET_KEY and SQLite DATABASE path. Conditionally loads config from file or test_config parameter. Creates instance directory with os.makedirs. Initializes database via db.init_app(), registers auth and blog blueprints, defines /hello route, and maps root URL \"/\" to blog.index endpoint. Returns configured Flask application object ready for deployment."
      }
    },
    "examples/tutorial/flaskr/auth.py": {
      "login_required": {
        "human": "This is a security gate that protects certain pages of a website from being accessed by visitors who haven't logged in. When someone tries to view a protected page without being logged in, it automatically sends them to the login page instead. It's like a bouncer at a club checking if you're on the guest list before letting you in.",
        "technical": "Implements a decorator pattern using functools.wraps to preserve the original view function's metadata. Checks the global `g.user` object for authentication status; if None (not authenticated), returns a redirect response to \"auth.login\" route via url_for. If authenticated, passes through all keyword arguments to the original view function and returns its result. Returns the wrapped function for use as a decorator."
      },
      "load_logged_in_user": {
        "human": "This function checks if someone is currently logged into the website by looking for their user ID in the session data. If a user is logged in, it retrieves their complete profile information from the database and makes it available throughout the application. If no one is logged in, it simply marks that no user is present. This runs automatically before handling any page request.",
        "technical": "Decorated with `@bp.before_app_request` to execute before each request. Retrieves `user_id` from Flask session using `session.get()`. If user_id exists, queries the database via `get_db().execute()` with parameterized SQL to fetch the user row by ID, storing the result in `g.user`. If no user_id, sets `g.user` to None. Uses Flask's `g` object to store user data for request-scoped access across the application."
      },
      "register": {
        "human": "This function handles new user account creation on a website. When someone fills out a registration form with a username and password, it checks that both fields are filled in and that the username isn't already taken by someone else. If everything looks good, it saves the new account to the database with an encrypted password for security, then sends the user to the login page.",
        "technical": "Flask route handler that processes GET/POST requests for user registration. On POST, extracts form data, validates username/password presence, then attempts database insertion with hashed password via `generate_password_hash()`. Catches `IntegrityError` to detect duplicate usernames. On success, redirects to login route; on validation failure, uses `flash()` to display error message. Returns rendered registration template for GET requests or after validation errors."
      },
      "login": {
        "human": "This function handles the login process for a website. When someone submits their username and password, it checks if the account exists and if the password is correct. If everything matches, it logs the user in by remembering their identity for the rest of their visit. If something's wrong (wrong username or password), it shows an error message and displays the login page again.",
        "technical": "Handles both GET and POST requests for user authentication. On POST, extracts credentials from form data, queries SQLite database for matching username, validates password using check_password_hash against stored hash. On success, clears existing session, stores user_id in session cookie, and redirects to index. On failure, uses flash() to display error message. Returns rendered login template for GET requests or validation failures."
      },
      "logout": {
        "human": "Logs a user out of the application by ending their current session. When someone clicks \"logout,\" this function removes all their stored login information and sends them back to the home page. It's the equivalent of signing out of a website - clearing your authentication so you're no longer recognized as logged in.",
        "technical": "Flask route handler that terminates user session by calling session.clear() to remove all session data (including user_id and authentication tokens). Returns HTTP redirect response to the \"index\" route using Flask's url_for() helper. Side effect: destroys server-side session state. No parameters accepted, returns redirect Response object."
      },
      "wrapped_view": {
        "human": "This function acts as a security checkpoint that protects certain pages from unauthorized access. When someone tries to access a protected page, it first checks if they're logged in. If they're not logged in, it sends them to the login page instead. If they are logged in, it lets them proceed to the page they requested.",
        "technical": "Authentication wrapper that checks `g.user` for current user session state. If `g.user` is `None`, performs redirect to \"auth.login\" route using Flask's `url_for()` and `redirect()`. Otherwise, passes all keyword arguments through to the wrapped `view` function and returns its result. Implements decorator pattern for route protection in Flask applications."
      }
    },
    "examples/tutorial/flaskr/blog.py": {
      "index": {
        "human": "This function displays the blog's homepage, showing all blog posts that have been written. It retrieves every post from the database along with information about who wrote each one, arranges them with the newest posts appearing first, and then displays them on a webpage. This is typically what visitors see when they first arrive at the blog.",
        "technical": "Retrieves database connection via get_db(), executes SQL JOIN query combining post and user tables to fetch post details (id, title, body, created, author_id) with author usernames, ordered by creation date descending. Returns rendered Jinja2 template 'blog/index.html' with posts collection passed as context variable. Decorated with bp.route making it a Flask view function for the blog index endpoint."
      },
      "get_post": {
        "human": "Retrieves a blog post from the database so it can be displayed or edited. It looks up the post by its ID number and makes sure the post actually exists. If requested, it also verifies that the person trying to access the post is the one who wrote it, preventing unauthorized users from editing someone else's content.",
        "technical": "Executes SQL JOIN query to fetch post data with author information from database using parameterized query with post ID. Returns a database row object containing post fields (id, title, body, created, author_id, username). Performs two validation checks: aborts with 404 if post doesn't exist, aborts with 403 if check_author is True and current user (from g.user) doesn't match post's author_id. Uses Flask's get_db() for database connection and abort() for HTTP error responses."
      },
      "create": {
        "human": "This function allows users to create and publish new blog posts. When someone fills out a form with a title and content, it saves that information to the database and shows it on the blog. If they forget to add a title, it reminds them with an error message. If they just visit the page without submitting anything, it shows them the empty form to fill out.",
        "technical": "Handles both GET and POST requests for blog post creation. On POST, extracts title and body from form data, validates title presence, and if valid, inserts a new record into the post table with the current user's ID from g.user. Commits the transaction and redirects to blog index. On GET or validation failure, renders the create.html template. Uses flash() for error messaging and get_db() for database access."
      },
      "update": {
        "human": "This function allows a blog post author to edit their existing post. When someone visits the edit page, they see a form with the current post content. When they submit changes to the title or body, the function validates that a title exists, saves the updates to the database, and redirects them back to the main blog page. If the title is missing, it shows an error message instead.",
        "technical": "Handles both GET and POST requests for post editing. On GET, retrieves post via `get_post(id)` and renders update form. On POST, extracts title/body from `request.form`, validates title presence, then executes SQL UPDATE statement with parameterized query to modify post record. Commits transaction via `db.commit()`, flashes validation errors if present, and redirects to blog index on success. Uses Flask's `flash()` for error messaging and `redirect(url_for())` for navigation."
      },
      "delete": {
        "human": "This function allows a user to permanently remove one of their blog posts. When someone clicks \"delete\" on a post, this function first checks that the post exists and belongs to them (through get_post), then removes it from the database and sends them back to the main blog page. It's a protected action that requires the user to be logged in.",
        "technical": "Executes a DELETE operation on the post table after validating post existence and ownership via get_post(id). Retrieves database connection through get_db(), runs parameterized SQL DELETE query with post ID, commits the transaction to persist changes, and returns HTTP redirect to blog index route. Decorated with @login_required for authentication and @bp.route for URL mapping."
      }
    },
    "examples/tutorial/flaskr/db.py": {
      "get_db": {
        "human": "This function provides access to the application's database. It creates a database connection the first time it's called during a web request, and then reuses that same connection if called again within the same request. This saves time and resources by avoiding multiple connections. The database results are returned in a format that's easy to work with (like a dictionary).",
        "technical": "Implements lazy database connection initialization using Flask's `g` object for request-scoped storage. Checks if connection exists in `g.db`; if not, creates SQLite connection using `DATABASE` config with `PARSE_DECLTYPES` for automatic type conversion. Sets `row_factory` to `sqlite3.Row` to enable dict-like column access by name. Returns the connection object (either newly created or cached from `g`)."
      },
      "close_db": {
        "human": "Cleans up the database connection when a web request is finished. This function checks if the current request opened a database connection, and if so, properly closes it to free up resources. It's like making sure you turn off the lights and lock the door when leaving a room - it prevents resource leaks and ensures the database isn't left with unnecessary open connections.",
        "technical": "Retrieves and removes the \"db\" object from Flask's request-scoped `g` object using `g.pop()`, which returns None if no database connection exists. If a database connection was found (db is not None), calls `db.close()` to terminate the connection. Typically registered as a Flask teardown handler to ensure database connections are properly closed after each request, regardless of whether the request succeeded or raised an exception."
      },
      "init_db": {
        "human": "Resets the database to a fresh state by wiping out all existing data and recreating the database structure from scratch. This is typically used when setting up the application for the first time or when you need to start over with a clean database. It reads the database design from a file and applies it to create empty tables.",
        "technical": "Obtains database connection via get_db(), opens schema.sql file from application resources using current_app.open_resource(), reads the SQL file content, decodes it from UTF-8 bytes to string, and executes the SQL script using db.executescript(). This drops existing tables and recreates the database schema. Returns None but has side effect of modifying database state."
      },
      "init_db_command": {
        "human": "This is a command-line tool that sets up a fresh database for the application. When you run this command, it wipes out any existing data and creates brand new, empty database tables. After completing the setup, it displays a confirmation message letting you know the database is ready to use.",
        "technical": "CLI command decorated with `@click.command` that orchestrates database initialization by calling `init_db()` to clear existing data and recreate table schemas. After database operations complete, uses `click.echo()` to output success confirmation to stdout. Returns None; primary side effect is database state modification. Designed for Flask application setup workflows."
      },
      "init_app": {
        "human": "Sets up the database system when the Flask web application starts. It ensures two things happen: first, the database connection is properly closed when the app shuts down or finishes handling a request, and second, it adds a command-line tool that lets developers initialize the database from the terminal.",
        "technical": "Registers database lifecycle hooks and CLI commands with the Flask application instance. Attaches `close_db` function to the teardown_appcontext event to ensure database connections are cleaned up after each request context ends. Adds `init_db_command` to Flask's CLI interface, making it available as a command-line utility for database initialization. No return value; modifies app state through side effects."
      }
    },
    "src/flask/app.py": {
      "_make_timedelta": {
        "human": "Converts time duration values into a standardized format. If you provide a number, it treats it as seconds and converts it to a proper time duration object. If you already have a time duration or nothing at all, it leaves it unchanged. This ensures time values are in a consistent format that the program can work with.",
        "technical": "Type converter function that normalizes timedelta inputs. Accepts timedelta, int, or None types. Returns input unchanged if already a timedelta object or None. For integer inputs, wraps the value in timedelta(seconds=value) to convert seconds to a timedelta object. Uses isinstance() for type checking and returns timedelta | None."
      },
      "remove_ctx": {
        "human": "This function removes an unnecessary AppContext parameter from method calls if it's accidentally passed in. It's like a filter that cleans up function arguments before they're processed. This helps Flask framework methods work correctly even when they receive extra context information they don't need, preventing errors from mismatched parameters.",
        "technical": "A decorator that wraps Flask instance methods to intercept and filter arguments. Checks if the first positional argument is an AppContext instance using isinstance(), and if so, removes it by slicing args[1:]. Calls the original function with the filtered arguments and preserves the original function's metadata using update_wrapper(). Returns the wrapper function with type hint F maintained for type checking."
      },
      "add_ctx": {
        "human": "This is a decorator that automatically adds context information to a function call. When a Flask method is called without providing the necessary application context, this decorator automatically inserts the current application context as the first argument. This ensures the function always has the context it needs to work properly, even if the caller forgot to provide it.",
        "technical": "A decorator that wraps Flask instance methods to inject AppContext as the first argument. Checks if args is empty or if first arg is not an AppContext instance, then prepends the current app context via `app_ctx._get_current_object()`. Returns the original function `f` with modified arguments. Uses `update_wrapper` to preserve function metadata. Returns type F (generic function type)."
      },
      "wrapper": {
        "human": "This function ensures that whenever a Flask method is called, it always has access to the application context (the environment where the Flask app is running). If the method is called without the context, it automatically adds it. This prevents errors when trying to access app-related information during method execution.",
        "technical": "Decorator wrapper that injects Flask's AppContext as the first argument after `self` if not already present. Checks if `args` is empty or if first arg isn't an AppContext instance, then prepends `app_ctx._get_current_object()` to the arguments tuple. Finally calls the wrapped function `f` with the modified arguments, ensuring AppContext is always available to the decorated method."
      },
      "__init_subclass__": {
        "human": "This function runs automatically when someone creates a new subclass of Flask. It checks if the subclass has updated certain methods to use a new parameter format (adding a \"ctx\" parameter). If methods are using the old format without this parameter, it shows a warning message that the old way is outdated and will stop working in Flask version 4.0, then automatically adjusts the methods to work correctly.",
        "technical": "Iterates through 12 Flask methods (handle_http_exception, dispatch_request, etc.) checking if they're overridden in the subclass. For each override, uses inspect.signature() to examine the second parameter, validating it's named \"ctx\" or annotated as AppContext through string matching, name checking, or issubclass() verification. If validation fails, emits DeprecationWarning and wraps methods using remove_ctx()/add_ctx() via setattr() to maintain backward compatibility while migrating to new ctx-aware signatures."
      },
      "__init__": {
        "human": "Sets up a web application by configuring its basic settings like where to find static files (images, CSS) and HTML templates. It also creates a command-line interface so developers can run commands to manage the app. If static files are configured, it automatically creates a web route that allows browsers to request and download those files from the server.",
        "technical": "Initializes a Flask application by calling parent class constructor with routing and path configuration parameters. Creates a CLI command group (`cli.AppGroup()`) for Flask commands. Conditionally registers a static file route using `add_url_rule()` if `has_static_folder` is true, with validation that `static_host` and `host_matching` are compatible. Uses `weakref.ref()` to avoid circular references between app and the static file view function (`send_static_file`)."
      },
      "get_send_file_max_age": {
        "human": "Determines how long a web browser should cache a file before checking if it has been updated. By default, it tells browsers to always check for updates rather than storing the file for a fixed time period. This helps ensure users see the most current version of files while still allowing for efficient caching when configured.",
        "technical": "Retrieves the `SEND_FILE_MAX_AGE_DEFAULT` configuration value and normalizes it to an integer or None. Returns None if config is None (enables conditional requests). If value is a `timedelta` object, converts it to integer seconds via `total_seconds()`. Otherwise returns the raw integer value. Used by Flask's `send_file()` to set HTTP cache-control max-age headers."
      },
      "send_static_file": {
        "human": "Serves static files (like images, CSS, or JavaScript files) from a designated folder to website visitors. When someone requests a static file, this function locates it in the static folder and sends it back to their browser. It also ensures the static folder is properly configured before attempting to serve any files, preventing errors.",
        "technical": "Validates that `static_folder` is configured, raising `RuntimeError` if not. Retrieves cache duration via `get_send_file_max_age()` for the requested filename. Delegates actual file serving to `send_from_directory()`, passing the static folder path (cast to string), filename, and max_age parameter. Returns a Response object containing the requested static file with appropriate caching headers."
      },
      "open_resource": {
        "human": "Opens and reads files that are stored alongside your application code. It's like a safe way to access resource files (like database scripts or configuration files) that are packaged with your app, ensuring you can only read them, not accidentally modify or delete them. The function finds the file relative to your app's main folder and opens it for you.",
        "technical": "Validates that mode is read-only ('r', 'rt', or 'rb'), raises ValueError otherwise. Constructs absolute file path by joining self.root_path with the resource parameter using os.path.join(). Opens file in binary mode without encoding parameter, or text mode with encoding parameter based on mode value. Returns file handle (t.IO[t.AnyStr]) for context manager usage."
      },
      "open_instance_resource": {
        "human": "Opens a file located in the application's special \"instance\" folder, which is a designated area for storing application-specific data. Unlike other resource files, these files can be opened for both reading and writing. You can specify whether to open the file in text or binary mode, and for text files, you can choose the character encoding (like UTF-8).",
        "technical": "Constructs absolute file path by joining `self.instance_path` with the provided resource path using `os.path.join()`. Checks if binary mode is requested by detecting 'b' in the mode string. Opens file in binary mode without encoding parameter if binary, otherwise opens in text mode with the specified encoding (defaults to 'utf-8'). Returns file handle as IO stream (either text or binary type)."
      },
      "create_jinja_environment": {
        "human": "Sets up the template rendering system for a Flask web application. It configures how HTML templates will be processed, including safety features to prevent code injection, whether templates should automatically reload during development, and makes common web functions (like URL generation and flash messages) available to all templates.",
        "technical": "Instantiates a Jinja2 Environment by merging `self.jinja_options` with defaults: sets `autoescape` to `self.select_jinja_autoescape` if unspecified, configures `auto_reload` based on `TEMPLATES_AUTO_RELOAD` config (falling back to `self.debug`). Creates environment via `self.jinja_environment()`, injects Flask globals (`url_for`, `get_flashed_messages`, `config`, `request`, `session`, `g`) into `rv.globals`, sets JSON serialization policy to `self.json.dumps`, and returns the configured Environment instance."
      },
      "create_url_adapter": {
        "human": "Creates a routing adapter that matches incoming web requests to the correct URL patterns in the application. It handles different scenarios: when processing an actual web request, it uses the request's information; when working outside a request context, it uses the application's configured server settings. This is essential for the web framework to know which part of your code should handle each incoming request.",
        "technical": "Binds the application's URL map to either a request environment or server configuration. For requests, configures trusted hosts via `get_host()`, determines subdomain handling based on `subdomain_matching` and `host_matching` flags, then calls `bind_to_environ()`. For non-request contexts (application-only), calls `bind()` with SERVER_NAME, APPLICATION_ROOT, and PREFERRED_URL_SCHEME config values. Returns a MapAdapter for URL matching/building, or None if SERVER_NAME is unavailable outside request context."
      },
      "raise_routing_exception": {
        "human": "This function handles errors that occur when the web application tries to route a user's request to the wrong URL. In development mode, if the user submitted form data and the app tries to redirect them (which would lose their data), it shows a special error message instead of silently discarding their information. In production mode, it just performs the redirect normally.",
        "technical": "Raises the routing exception stored in `request.routing_exception`. In debug mode, intercepts `RequestRedirect` exceptions (except 307/308 status codes) for non-safe HTTP methods (POST, PUT, etc.) and raises a `FormDataRoutingRedirect` error instead to warn developers about potential form data loss. Otherwise, re-raises the original routing exception. Always raises an exception (NoReturn type), never returns normally."
      },
      "update_template_context": {
        "human": "Prepares the variables that will be available when rendering a web page template. It first adds standard Flask variables (like request and session info), then runs any custom functions that want to add more variables, and finally ensures that any variables explicitly passed by the developer take priority over everything else. This creates the final set of data that the template can use.",
        "technical": "Modifies context dict in-place by running template_context_processors for None and all active blueprint names (in reverse order). Preserves original context values by copying them before processor execution, then re-applies them at the end to ensure user-provided values override processor outputs. Uses chain() and reversed() to build processor execution order, wraps async processors with ensure_sync(), and only processes blueprints if ctx.has_request is True."
      },
      "make_shell_context": {
        "human": "Prepares a workspace environment for developers who want to interact with the application through a command-line shell. It gathers all the tools and objects (like the app itself and request context) that developers might need when testing or debugging interactively, making them readily available without having to import them manually.",
        "technical": "Creates and returns a dictionary containing shell context variables for interactive Python sessions. Initializes the context with `app` (self reference) and `g` (global object), then iterates through registered `shell_context_processors` callbacks, merging their returned dictionaries into the context using `rv.update()`. Returns the aggregated dictionary of all available objects for the shell environment."
      },
      "run": {
        "human": "Starts a local web server to run your Flask application during development. It handles configuration like which address and port to use, whether to enable debugging features, and loads environment settings from files. This is meant only for testing your app locally - not for running a real website that users access.",
        "technical": "Configures and launches Werkzeug development server via `run_simple()`. Resolves host/port from parameters, SERVER_NAME config, or defaults (127.0.0.1:5000). Loads environment variables from .env/.flaskenv files if enabled. Sets debug mode from parameter, FLASK_DEBUG env var, or existing config. Prevents execution when called from Flask CLI. Configures reloader, debugger, and threading options before starting server. Resets `_got_first_request` flag on shutdown."
      },
      "test_client": {
        "human": "Creates a special testing version of the application that lets developers test their web application without running a real server. It's like a practice version that simulates how users would interact with the app, allowing developers to check if everything works correctly before deploying to real users. You can optionally enable cookie handling and customize the test client's behavior.",
        "technical": "Factory method that instantiates and returns a FlaskClient (or custom subclass) for testing Flask applications. Retrieves the test client class from `self.test_client_class` (defaults to `FlaskClient` if None), then instantiates it by passing the Flask app instance (`self`), response class (`self.response_class`), the `use_cookies` boolean flag, and any additional keyword arguments. Returns the configured client object that wraps the WSGI application for test request simulation."
      },
      "test_cli_runner": {
        "human": "Creates a special testing tool that lets developers test command-line commands for their Flask web application. It's like a practice environment where you can run CLI commands and check if they work correctly without affecting the real application. If no custom testing tool is specified, it uses Flask's built-in default testing tool.",
        "technical": "Factory method that instantiates and returns a CLI test runner object. Retrieves the runner class from `self.test_cli_runner_class` attribute, falling back to importing `FlaskCliRunner` from `.testing` module if None. Passes the Flask app instance (`self`) as first argument to the runner constructor along with any additional keyword arguments, enabling CLI command testing in isolation."
      },
      "handle_http_exception": {
        "human": "When a web application encounters an HTTP error (like a 404 Not Found or 500 Server Error), this function decides how to handle it. It first checks if the error is a special internal type that shouldn't be processed. If a custom error handler has been registered for this type of error, it runs that handler. Otherwise, it simply returns the error as-is to be shown to the user.",
        "technical": "Processes HTTPException objects through a three-stage filter: (1) returns exceptions without error codes unchanged, (2) bypasses RoutingException instances used for internal routing actions, (3) searches for registered error handlers via `_find_error_handler()` using the exception type and request blueprint context. If a handler exists, invokes it synchronously via `ensure_sync()` wrapper, otherwise returns the raw exception. Returns either the original HTTPException or the handler's ResponseReturnValue."
      },
      "handle_user_exception": {
        "human": "This function handles errors that occur during a web request. When something goes wrong, it decides whether to show detailed error information (in debug mode), pass the error to a specialized handler, or find a custom error handler that the developer registered. If no custom handler exists, it lets the error bubble up; otherwise, it runs the custom handler to generate an appropriate response for the user.",
        "technical": "Processes exceptions during request handling with three main paths: (1) enables detailed display for BadRequestKeyError when in debug/trap mode, (2) delegates HTTPException instances to handle_http_exception unless trapped, (3) searches for registered error handlers via _find_error_handler using exception type and blueprint context. If no handler found, re-raises exception; otherwise executes handler synchronously via ensure_sync and returns response. Returns either HTTPException or ResponseReturnValue type."
      },
      "handle_exception": {
        "human": "This function handles errors that occur in a web application when no specific error handler was set up for them. It decides whether to show the full error details (useful during development) or log the error and show a generic \"500 Internal Server Error\" page to users. It ensures the application can recover gracefully from unexpected problems and notify monitoring systems that something went wrong.",
        "technical": "Captures exception info via `sys.exc_info()`, sends `got_request_exception` signal, then checks `PROPAGATE_EXCEPTIONS` config (or testing/debug flags) to either re-raise the exception or handle it. Wraps the original exception in `InternalServerError`, searches for a registered 500 error handler via `_find_error_handler()`, invokes it if found, and returns the response through `finalize_request()`. Logs the exception details before creating the error response."
      },
      "log_exception": {
        "human": "Records error information when something goes wrong in the application. When an error occurs while handling a web request, this function writes a message to the application's error log showing which webpage was being accessed and what type of request was being made (like GET or POST). This helps developers troubleshoot problems by keeping a record of what went wrong and where.",
        "technical": "Logs exceptions to the application's logger at ERROR level. Extracts the request path and HTTP method from the AppContext object and formats them into an error message. Passes the exc_info tuple (containing exception type, instance, and traceback) to logger.error() for full stack trace logging. Called by handle_exception() when debug mode is disabled, before the exception handler executes."
      },
      "dispatch_request": {
        "human": "Routes an incoming web request to the correct handler function that should process it. First checks if there were any problems finding the right route, then handles special cases like OPTIONS requests automatically, and finally calls the appropriate handler function with the URL parameters extracted from the request.",
        "technical": "Dispatches HTTP requests by: (1) checking `req.routing_exception` and raising if present, (2) handling OPTIONS method automatically via `make_default_options_response()` if rule provides automatic options, (3) retrieving the view function from `self.view_functions` dict using `rule.endpoint` as key, (4) calling the view function with `view_args` dict unpacked as kwargs after wrapping with `ensure_sync()`. Returns the raw view function result (not yet converted to Response object)."
      },
      "full_dispatch_request": {
        "human": "This function handles the complete lifecycle of processing a web request. It coordinates the entire flow from when a request arrives until a response is ready to send back. It runs any pre-processing tasks, routes the request to the appropriate handler, catches any errors that occur, and performs final cleanup before returning the response to the user.",
        "technical": "Orchestrates the full request-response cycle by: (1) setting first request flag, (2) sending request_started signal, (3) calling preprocess_request() for middleware hooks, (4) invoking dispatch_request() to route to view function if preprocessing returns None, (5) catching all exceptions via handle_user_exception(), and (6) calling finalize_request() to apply response processing. Returns a Response object. Uses try-except to ensure exceptions are properly handled through the framework's error handling pipeline."
      },
      "finalize_request": {
        "human": "This function takes the result from a webpage view (like data or HTML) and converts it into a proper response that can be sent back to the user's browser. It also runs any cleanup tasks and notifies other parts of the application that the request is complete. If something goes wrong during this process and we're already handling an error, it logs the problem instead of crashing the entire application.",
        "technical": "Converts view function return value `rv` into a Response object via `make_response()`, then applies response processing middleware through `process_response()`. Sends `request_finished` signal to notify listeners. Implements safe mode when `from_error_handler=True` - catches exceptions during response processing and logs them via `self.logger.exception()` instead of propagating, preventing cascading failures. Returns the finalized Response object for delivery to the client."
      },
      "make_default_options_response": {
        "human": "Creates a standard response when someone asks a web server \"what actions can I perform on this page?\" (an OPTIONS request). It looks up what operations are allowed for the requested web address (like GET, POST, DELETE) and packages that information into a response that tells the requester what they're permitted to do.",
        "technical": "Generates default HTTP OPTIONS response by querying the URL adapter for allowed HTTP methods on the current route, instantiates a Response object using the application's response class, populates the response's Allow header with the retrieved methods via `rv.allow.update()`, and returns the configured response object. Takes AppContext containing the url_adapter as input."
      },
      "ensure_sync": {
        "human": "This function makes sure that any function can work in a traditional web server environment that doesn't support modern asynchronous code. If you give it a regular function, it passes it through unchanged. If you give it an async function (one that runs concurrently), it wraps it so it can run in a standard synchronous environment by waiting for its completion.",
        "technical": "Checks if the input function is a coroutine using `iscoroutinefunction()`. If true, wraps it with `self.async_to_sync()` to convert async execution to blocking synchronous execution. If false (regular function), returns the original function unchanged. This enables WSGI applications to handle both sync and async view functions uniformly by normalizing them to synchronous callables."
      },
      "async_to_sync": {
        "human": "Converts an asynchronous function (one that runs in the background) into a regular synchronous function (one that runs immediately and waits for completion). This allows Flask applications to use modern async Python code even when the rest of the application expects traditional blocking functions. If the required conversion library isn't installed, it tells the user they need to install Flask with async support.",
        "technical": "Wraps a coroutine function using asgiref's `async_to_sync` adapter to make it callable from synchronous code. Attempts to import `asgiref.sync.async_to_sync`, raising a RuntimeError with installation instructions if the dependency is missing. Returns the wrapped function that will execute the coroutine and block until completion. Takes a callable returning a Coroutine and returns a callable returning Any."
      },
      "url_for": {
        "human": "Generates a web URL for a specific page or function in your Flask application. It figures out whether to create a simple path (like \"/hello\") or a full URL with domain (like \"https://example.com/hello\") based on whether you're handling a web request or generating links outside of one (like in emails). It also handles blueprint prefixes and adds query parameters or anchors to the URL.",
        "technical": "Builds URLs using Werkzeug's URL adapter by resolving endpoint names (handling blueprint-relative \".\" prefix), determining internal vs external URL generation based on request context, and injecting URL defaults. Calls `url_adapter.build()` with endpoint, values, method, scheme, and external flag. Catches BuildError and delegates to `handle_url_build_error()`. Appends URL-quoted anchor fragment if provided. Returns external URLs by default outside request context (requires SERVER_NAME config), internal URLs during requests unless scheme specified."
      },
      "make_response": {
        "human": "Converts whatever a web view function returns into a proper HTTP response object that can be sent to the browser. Handles many different return types (strings, JSON data, tuples with status codes, etc.) and normalizes them all into a standard response format. If the view returns something invalid or nothing at all, it raises helpful error messages explaining what went wrong.",
        "technical": "Normalizes view function return values into Response instances by: 1) unpacking tuples to extract body/status/headers, 2) validating rv is not None, 3) converting str/bytes/iterators via response_class constructor, 4) JSONifying dicts/lists via self.json.response(), 5) coercing BaseResponse/callables using force_type(), 6) applying extracted status and headers to final Response object. Raises TypeError with detailed messages for invalid return types."
      },
      "preprocess_request": {
        "human": "Runs preliminary checks and setup tasks before handling a web request. First, it processes URL parameters through registered preprocessors that can modify or validate them. Then, it runs \"before request\" handlers that can perform authentication, logging, or other preparatory work. If any handler decides the request shouldn't proceed (by returning a response), processing stops immediately and that response is used instead of continuing to the actual page handler.",
        "technical": "Executes two-phase preprocessing pipeline for Flask requests: (1) iterates through url_value_preprocessors for app and blueprints (in reverse order) to modify req.endpoint and req.view_args in-place, (2) executes before_request_funcs for app and blueprints, wrapping each with ensure_sync() for async compatibility. Returns early with non-None response from any before_request handler, short-circuiting normal request dispatch. Processes blueprint chain from innermost to outermost via reversed(req.blueprints), with app-level (None) handlers executed first."
      },
      "process_response": {
        "human": "This function finalizes a web response before sending it back to the user's browser. It gives the application a chance to make last-minute modifications to the response by running any cleanup or modification functions that were registered earlier. It also ensures that any user session data (like login status or shopping cart) is properly saved before the response is sent.",
        "technical": "Processes a Response object through a two-stage pipeline: (1) executes context-specific after_request_functions, (2) executes registered after_request_funcs for each blueprint in the request chain plus global handlers, in reverse registration order. All handlers are wrapped with ensure_sync() for async compatibility. Finally, persists session data via session_interface.save_session() if the session is not null. Returns the modified Response object."
      },
      "do_teardown_request": {
        "human": "Performs cleanup operations after a web request has been completed and the response sent to the user. It runs all registered cleanup functions (like closing database connections or releasing resources) in the reverse order they were registered, ensuring proper shutdown. This happens right before the application forgets about this particular request, giving each part of the application a chance to clean up after itself.",
        "technical": "Iterates through blueprint names from the request context plus None (for app-level handlers), executes teardown functions in reverse registration order via `reversed()` and `ensure_sync()` wrapper. Chains blueprint-specific and app-level teardown handlers using `chain()`, passing the exception object to each. Finally sends `request_tearing_down` signal with async wrapper. Returns None but has side effects of executing all teardown callbacks and broadcasting teardown signal."
      },
      "do_teardown_appcontext": {
        "human": "Performs cleanup operations when an application is shutting down or finishing its work. It runs all registered cleanup functions in reverse order (last registered runs first), then notifies other parts of the system that cleanup is happening. If an error occurred during the application's operation, it passes that error information to the cleanup functions so they can handle it appropriately.",
        "technical": "Executes teardown callbacks registered via `@teardown_appcontext` decorator in reverse order using `reversed()` on `self.teardown_appcontext_funcs`. Wraps each callback with `self.ensure_sync()` to handle async/sync compatibility, passing the exception parameter. After all callbacks complete, sends `appcontext_tearing_down` signal with the exception and sync wrapper. Returns None; side effect is execution of cleanup functions and signal emission."
      },
      "app_context": {
        "human": "Creates a special workspace environment for a Flask web application. This environment makes the application and its shared data accessible to your code. It's like opening a workspace where you can perform setup tasks (like initializing a database) or run tests outside of normal web request handling. You use it with Python's \"with\" statement to temporarily activate this workspace.",
        "technical": "Factory method that instantiates and returns an AppContext object, passing the current Flask application instance (self) as a parameter. The returned AppContext is a context manager that, when entered, makes current_app and g proxies available in the local context stack. Simple wrapper with no side effects - actual context activation occurs when the returned AppContext is pushed via __enter__ method."
      },
      "request_context": {
        "human": "Creates a container that holds information about an incoming web request from a user's browser. This container makes request details (like what page was requested, user session data, and app settings) accessible throughout the application while handling that specific request. It's an internal method that developers shouldn't call directly - there's a safer testing version available instead.",
        "technical": "Factory method that wraps a WSGI environment dictionary into an AppContext object by delegating to `AppContext.from_environ()`. Takes raw WSGI environ data and the app instance (self), returns an AppContext that encapsulates request-scoped data. This is a thin wrapper/convenience method - the actual context creation logic resides in the AppContext class. No side effects occur until the returned context is explicitly pushed onto the context stack."
      },
      "test_request_context": {
        "human": "Creates a fake web request environment for testing purposes, allowing you to test code that needs request data (like form submissions or URL parameters) without actually running a web server or making real HTTP requests. This lets developers verify their code works correctly in isolation during automated tests.",
        "technical": "Constructs a test request context by instantiating EnvironBuilder with provided arguments, calling get_environ() to generate a WSGI environ dictionary, ensuring cleanup via builder.close() in a try-finally block, then passing the environ to self.request_context() which returns an AppContext. The function acts as a wrapper that converts Werkzeug's EnvironBuilder output into Flask's request context object."
      },
      "wsgi_app": {
        "human": "This is the core function that handles incoming web requests in a Flask application. When someone visits a website, this function receives their request, processes it through the application's routes and logic, handles any errors that occur, and sends back the appropriate response. It also ensures proper cleanup happens even if something goes wrong during request processing.",
        "technical": "Creates a request context from the WSGI environ, pushes it onto the context stack, and dispatches the request via `full_dispatch_request()`. Catches exceptions and routes them to `handle_exception()` for error handling. Returns a WSGI-compliant response by calling the response object with environ and start_response. The finally block ensures context cleanup via `ctx.pop()`, preserves context for debugging if needed, and filters errors through `should_ignore_error()` before teardown."
      },
      "__call__": {
        "human": "This function makes a Flask application work with web servers. When a web server receives an HTTP request (like someone visiting a website), it calls this function to hand off the request to Flask. The function acts as the main entry point that allows Flask to receive and process web requests, then send back responses.",
        "technical": "Implements the WSGI callable interface by accepting `environ` (request environment dictionary) and `start_response` (callback for HTTP headers) parameters. Delegates all processing to `self.wsgi_app()` method, acting as a thin wrapper that enables middleware wrapping at the `wsgi_app` level while maintaining WSGI compliance. Returns an iterable of bytes representing the HTTP response body."
      }
    },
    "src/flask/blueprints.py": {
      "__init__": {
        "human": "Sets up a new blueprint component for a web application. A blueprint is like a template or module that contains related web pages, commands, and resources (like images or HTML templates). It organizes these pieces together under a single name so they can be easily added to the main application. Also creates a command-line interface group that lets developers run special commands for this blueprint.",
        "technical": "Initializes a Blueprint object by calling parent class constructor with all configuration parameters (name, import paths, static/template folders, URL settings). Creates an AppGroup instance for CLI command registration and assigns it to self.cli. Sets the CLI group's name attribute to match the blueprint's name for potential integration with external CLI tools. All parameters are passed through to super().__init__() without modification."
      },
      "get_send_file_max_age": {
        "human": "Determines how long a web browser should cache a file before checking if it has been updated. By default, it tells browsers to always check with the server rather than assuming the file hasn't changed, which helps ensure users see the most current version of files. This setting can be customized through the application's configuration.",
        "technical": "Retrieves the `SEND_FILE_MAX_AGE_DEFAULT` configuration value from Flask's current_app config. Returns `None` if not configured (triggering conditional requests). If the value is a `timedelta` object, converts it to integer seconds using `total_seconds()`. Otherwise returns the raw integer value. Used internally by Flask's `send_file()` function to set HTTP cache-control headers."
      },
      "send_static_file": {
        "human": "Serves static files (like images, CSS, or JavaScript files) from a designated folder to website visitors. When someone requests a static file, this function locates it in the static folder and sends it back to their browser. It also sets how long the browser should cache the file before requesting it again.",
        "technical": "Validates that `static_folder` is configured, raising `RuntimeError` if not. Calls `get_send_file_max_age()` to determine cache duration for the requested file. Delegates actual file serving to `send_from_directory()`, passing the static folder path (cast to string), filename, and max_age parameter. Returns a Response object containing the file content with appropriate headers."
      },
      "open_resource": {
        "human": "Opens and reads files that are stored alongside the application code (like templates, configuration files, or data files). It finds the file by combining the application's base folder with the file name you provide. Only allows reading files, not writing or modifying them, to protect the application's resources from accidental changes.",
        "technical": "Validates mode parameter against allowed read-only values {'r', 'rt', 'rb'}, then constructs absolute file path using os.path.join() with self.root_path and resource parameter. Opens file in binary mode without encoding if mode is 'rb', otherwise opens in text mode with specified encoding parameter (defaults to 'utf-8'). Returns file handle typed as t.IO[t.AnyStr]. Raises ValueError for invalid modes."
      }
    },
    "src/flask/cli.py": {
      "find_best_app": {
        "human": "Searches through a Python module to automatically locate a Flask web application so it can be run. It looks in common places where developers typically store their app (like variables named \"app\" or \"application\"), checks for factory functions that create apps, and provides helpful error messages if it finds multiple apps or can't find any. This saves developers from having to manually specify which app to run.",
        "technical": "Implements a three-tier discovery strategy: (1) checks module attributes \"app\" and \"application\" for Flask instances, (2) scans all module.__dict__.values() for Flask instances (raising NoAppException if multiple found), (3) attempts to call factory functions \"create_app\" or \"make_app\" with no arguments using inspect.isfunction() validation. Uses _called_with_wrong_args() to distinguish between TypeError from missing required parameters versus other errors. Returns first valid Flask instance found or raises NoAppException with context-specific guidance."
      },
      "_called_with_wrong_args": {
        "human": "When a function call fails with a TypeError, this determines whether the error happened because you passed the wrong arguments to the function, or because the function itself ran but encountered a TypeError while doing its work. It helps distinguish between \"you called it wrong\" versus \"it ran but broke internally.\"",
        "technical": "Inspects the current exception's traceback using `sys.exc_info()[2]` and walks through each frame via `tb.tb_next`. Compares each frame's code object (`tb.tb_frame.f_code`) against the target function's code object (`f.__code__`). Returns `False` if the function's code was reached (indicating successful call but internal error), `True` if not reached (indicating call signature mismatch). Explicitly deletes traceback reference in finally block to prevent circular reference memory leak."
      },
      "find_app_by_string": {
        "human": "This function finds and retrieves a Flask web application from a Python module by looking up either a variable name or a function name. If it's a function (called a \"factory\"), it calls that function with any provided arguments to create the app. If it's just a variable, it returns it directly. This allows flexible ways to specify how to get a Flask app instance from a module.",
        "technical": "Parses the app_name string using ast.parse() to determine if it's a simple name (ast.Name) or function call (ast.Call). Extracts function arguments via ast.literal_eval() for literal values. Uses getattr() to retrieve the attribute from the module, then inspect.isfunction() to check if it needs calling. Validates the result is a Flask instance before returning, raising NoAppException for any parsing, lookup, or type validation failures throughout the process."
      },
      "prepare_import": {
        "human": "Converts a file path into a proper Python module name that can be imported. It figures out where a Python package starts by looking for `__init__.py` files, adds that location to Python's search path so the module can be found, and returns the correct dotted module name (like \"package.subpackage.module\") that you would use in an import statement.",
        "technical": "Normalizes the input path with `os.path.realpath()`, strips `.py` extension and handles `__init__.py` files. Traverses upward through directory hierarchy using `os.path.split()` in a loop, collecting directory names until no `__init__.py` exists (package boundary). Modifies `sys.path` by inserting the package root at index 0. Returns the reversed, dot-joined module path components as the importable module name."
      },
      "locate_app": {
        "human": "Finds and loads a Flask web application from a Python file. You give it the name of a Python file (module) and optionally the name of the app inside it, and it will locate and return that application. If the file doesn't exist or can't be loaded, it either reports an error or quietly returns nothing, depending on your preference.",
        "technical": "Imports a Python module by name using `__import__()`, then retrieves the Flask app instance either by searching for the best candidate via `find_best_app()` (when app_name is None) or by locating a specific named app via `find_app_by_string()`. Implements sophisticated ImportError handling that distinguishes between missing modules (depth 1) and errors within the module (depth > 1) by inspecting traceback depth. Raises `NoAppException` with contextual error messages or returns None based on `raise_if_not_found` flag."
      },
      "get_version": {
        "human": "Displays version information for the application and its dependencies when requested by the user (typically through a --version flag). Shows which version of Python is running, along with the Flask web framework and Werkzeug library versions. After displaying this information, the program exits immediately since the user just wanted to check versions, not run the actual application.",
        "technical": "Click callback function that retrieves version metadata using importlib.metadata.version() for Flask and Werkzeug packages, and platform.python_version() for Python runtime. Guards execution with value check and resilient_parsing flag. Formats and outputs version string via click.echo() with context color settings, then terminates execution with ctx.exit(). Returns None but has side effect of program termination when triggered."
      },
      "with_appcontext": {
        "human": "This function wraps other functions to ensure they run within a Flask application's context. Think of it as making sure a function has access to all the application's settings and resources when it runs. It's particularly useful for command-line scripts that need to interact with a Flask web application but aren't running as part of the normal web server.",
        "technical": "Decorator that wraps a callback function with Click's `@pass_context` to ensure Flask app context availability. Checks if `current_app` exists; if not, retrieves the app via `ScriptInfo.load_app()` and registers its context using `ctx.with_resource(app.app_context())`. Invokes the original function with `ctx.invoke()` passing through all arguments, then returns the wrapped function via `update_wrapper()` to preserve metadata."
      },
      "_set_app": {
        "human": "This function helps configure which application should be used when running Flask commands. When you specify an app to work with, it stores that information so other parts of the system know which app you want to interact with. If no app is specified, it simply does nothing and returns.",
        "technical": "Click callback function that stores the Flask application import path in the ScriptInfo context object. Takes a string value representing the app import path, retrieves or creates a ScriptInfo object via ctx.ensure_object(), assigns the value to info.app_import_path, and returns the original value. Returns None early if no value is provided, avoiding unnecessary context operations."
      },
      "_set_debug": {
        "human": "This function handles the debug mode setting for a Flask application. It checks whether the user explicitly provided a debug flag or if it's just using a default value. If the user didn't explicitly set it, the function does nothing and lets the environment handle it. If the user did set it, the function saves that choice to an environment variable so Flask knows whether to run in debug mode or not.",
        "technical": "Click callback that conditionally sets the FLASK_DEBUG environment variable based on parameter source. Uses `ctx.get_parameter_source()` to determine if the value came from DEFAULT or DEFAULT_MAP sources, returning None in those cases to defer to environment configuration. For explicitly provided values (command-line or env var), sets `os.environ[\"FLASK_DEBUG\"]` to \"1\" or \"0\" and returns the boolean value. This allows early access to debug settings during Flask factory function execution."
      },
      "_env_file_callback": {
        "human": "This function handles loading environment variables from a .env file when a command-line option is used. It checks if the required library (python-dotenv) is installed before attempting to load the file. If the library is missing and the user tried to specify a file, it shows an error message. Otherwise, it loads environment variables from either the specified file or default locations.",
        "technical": "Click callback function that validates python-dotenv availability and conditionally loads environment variables. Attempts to import dotenv module, raising click.BadParameter if import fails and value is provided. Calls load_dotenv() with the specified file path and load_defaults flag from ctx.obj when either value is not None or load_dotenv_defaults is True. Returns the original value parameter unchanged for Click's option processing chain."
      },
      "_path_is_ancestor": {
        "human": "Checks whether one file path is a parent directory of another file path. For example, it verifies if \"/home/user\" is an ancestor of \"/home/user/documents/file.txt\". This helps determine hierarchical relationships between folders and files in a file system.",
        "technical": "Validates path ancestry by slicing `other` from position `len(path)` onward, stripping leading path separators with `lstrip(os.sep)`, then rejoining to `path` using `os.path.join()`. Returns True if the reconstructed path equals the original `other` string, confirming `path` is an ancestor. Uses string manipulation and `os.sep` for cross-platform separator handling."
      },
      "load_dotenv": {
        "human": "This function loads configuration settings from special files (like `.env` and `.flaskenv`) into your application's environment. It's useful for storing sensitive information like passwords or API keys outside your code. The function checks if the necessary library is installed, reads the configuration files in a specific order of priority, and only adds settings that aren't already defined in your system.",
        "technical": "Attempts to import `python-dotenv` library, returning False with a warning if unavailable. When `load_defaults=True`, loads `.flaskenv` then `.env` using `dotenv.find_dotenv()` and `dotenv.dotenv_values()`. Merges data from optional custom path file (highest precedence). Iterates through combined key-value pairs and sets them in `os.environ` only if key doesn't already exist. Returns True if any environment variables were loaded, False otherwise."
      },
      "show_server_banner": {
        "human": "Displays startup information messages when a Flask web server first starts up, showing which application is running and whether debug mode is turned on or off. It only shows these messages once during the initial startup, not when the server automatically restarts itself after code changes (which would create duplicate messages).",
        "technical": "Conditionally prints Flask server startup information using click.echo(). First checks is_running_from_reloader() to skip execution during auto-reload cycles. If app_import_path is provided, displays the Flask app path. If debug parameter is not None, displays debug mode status as \"on\" or \"off\". Returns None; side effect is console output via click.echo()."
      },
      "_validate_key": {
        "human": "This function validates that SSL certificate and key options are used correctly together when setting up secure HTTPS connections. It ensures that when you provide a certificate file, you also provide the matching private key file, and prevents invalid combinations like using a key with auto-generated certificates or pre-configured SSL contexts. It helps catch configuration mistakes before the server tries to start.",
        "technical": "Click callback validator that enforces mutual dependency between `--cert` and `--key` parameters. Retrieves cert value from ctx.params, checks if it's \"adhoc\", SSLContext, or file path. Raises click.BadParameter for invalid combinations (key with adhoc/SSLContext, key without cert, cert file without key). When both are valid, modifies ctx.params[\"cert\"] to tuple (cert, key). Returns the key value unchanged while performing side effects on context params."
      },
      "run_command": {
        "human": "Starts a local web server for testing and developing your web application on your computer. It loads your application and runs it so you can view it in a browser. If there are errors loading the application, it handles them differently depending on whether the server is restarting itself or starting fresh. The server includes helpful debugging tools that turn on automatically in development mode.",
        "technical": "Loads WSGI application via `info.load_app()` with error handling that differs based on reloader state (prints traceback and creates error-raising stub app if reloading, raises immediately otherwise). Determines debug mode via `get_debug_flag()` and uses it to set default reload/debugger values. Calls `run_simple()` from Werkzeug with configured host, port, threading, SSL context, and file watching parameters to start the development server."
      },
      "shell_command": {
        "human": "Launches an interactive Python command-line shell that's already connected to your Flask web application. This lets developers quickly test code, inspect data, or run commands against the live application without writing separate scripts. It's like opening a Python console that already has your app loaded and ready to use, with helpful features like command history and auto-completion.",
        "technical": "Initializes a Python REPL using `code.interact()` with a custom namespace populated by `current_app.make_shell_context()`. Executes PYTHONSTARTUP script if present via `eval(compile())`. Configures readline tab-completion by replacing default `__main__.__dict__` with shell context dict. Invokes `sys.__interactivehook__` to enable readline features. Displays banner showing Python version, Flask app name, and instance path. Decorated with `@click.command` and `@with_appcontext` for Flask CLI integration."
      },
      "routes_command": {
        "human": "Displays a formatted table showing all the web pages and API endpoints available in your Flask application. It lists where each endpoint is located (its URL path), what actions it supports (like GET or POST), and what function handles it. You can choose how to sort the table and whether to show technical HTTP methods that are usually hidden.",
        "technical": "Retrieves all URL rules from Flask's `current_app.url_map`, filters HTTP methods based on `all_methods` flag (excluding HEAD/OPTIONS by default), and builds a table with endpoint names, methods, optional domain/subdomain, and URL patterns. Sorts rows using `itemgetter` on the specified column index, calculates column widths dynamically, inserts header and separator rows, then formats and outputs each row using `click.echo` with a computed template string."
      },
      "__init__": {
        "human": "Sets up a Flask command-line interface (CLI) tool that helps developers run and manage their Flask web applications from the terminal. It configures essential options like which app to run, debug mode, and environment settings. Optionally adds common commands like \"run\" (to start the server), \"shell\" (to open an interactive console), and \"routes\" (to view URL mappings). This makes it easy for developers to interact with their Flask apps without writing custom scripts.",
        "technical": "Initializes a Click command group for Flask CLI by extending the parent class with Flask-specific parameters (_env_file_option, _app_option, _debug_option, and optionally version_option). Sets auto_envvar_prefix to \"FLASK\" in context_settings for automatic environment variable binding. Stores create_app callable, load_dotenv, and set_debug_flag as instance attributes. Conditionally registers three default commands (run_command, shell_command, routes_command) via add_command(). Initializes _loaded_plugin_commands flag to False for lazy plugin loading."
      },
      "load_app": {
        "human": "This function finds and loads your Flask web application so it can run. It first checks if the app is already loaded to avoid loading it twice. If not, it tries three ways to find your app: using a factory function you provided, looking at a specific file path you specified, or automatically searching for common files like 'wsgi.py' or 'app.py'. If it can't find an app anywhere, it tells you how to fix the problem.",
        "technical": "Implements lazy-loading singleton pattern for Flask app initialization with caching via `_loaded_app`. Attempts three loading strategies in order: (1) calls `create_app()` factory if provided, (2) parses `app_import_path` using regex to split module:attribute format then imports via `prepare_import()`/`locate_app()`, (3) falls back to auto-discovery by probing 'wsgi.py' and 'app.py'. Raises `NoAppException` if all strategies fail. Optionally applies debug flag via `get_debug_flag()` before caching and returning the Flask instance."
      },
      "decorator": {
        "human": "This function wraps a command function to prepare it for use in a Flask application's command-line interface. It optionally ensures the command runs within the Flask application's context (so it can access the database, configuration, etc.), then registers it as a Click command that can be executed from the terminal.",
        "technical": "Inner decorator function that conditionally wraps the input function `f` with `with_appcontext()` if `wrap_for_ctx` is True, ensuring Flask application context availability. Calls the parent class (AppGroup) `command()` method with captured `*args` and `**kwargs` to register the function as a Click command. Returns a `click.Command` object representing the decorated CLI command."
      },
      "command": {
        "human": "This function creates a decorator that registers command-line commands for a Flask application. It automatically ensures that commands run within the Flask application's context (so they can access the database, configuration, etc.), unless you specifically tell it not to. This solves the problem of commands needing access to Flask's application resources.",
        "technical": "Overrides Click's Group.command() method to return a decorator that optionally wraps command callbacks with `with_appcontext()`. Extracts `with_appcontext` kwarg (defaults to True), conditionally wraps the callback function `f` to provide Flask app context, then delegates to parent class's command() method with remaining args/kwargs. Returns a decorator function that produces a click.Command instance."
      },
      "group": {
        "human": "Creates a way to organize related commands together into a group, similar to how folders organize files. When you create a command group, this function automatically uses Flask's special group type (AppGroup) instead of the basic Click group type, unless you specifically ask for something different. This makes it easier to build command-line tools that work well with Flask applications.",
        "technical": "Overrides the parent class's `group()` method to inject a default `cls` parameter. Uses `kwargs.setdefault(\"cls\", AppGroup)` to set the group class to `AppGroup` only if not already specified, then delegates to the parent implementation via `super().group(*args, **kwargs)`. Returns a decorator callable that wraps functions into Click command groups. Accepts arbitrary positional and keyword arguments for flexibility in group configuration."
      },
      "_load_plugin_commands": {
        "human": "Loads additional commands into a Flask application from external plugins. This allows third-party packages to extend Flask's command-line interface with their own custom commands. It only runs once (using a flag to prevent duplicate loading) and automatically discovers any plugins that have registered Flask commands.",
        "technical": "Uses importlib.metadata.entry_points() to discover plugins registered under the \"flask.commands\" group. For each entry point found, calls ep.load() to import the command object and ep.name to get its name, then registers it via self.add_command(). Guards against repeated execution with self._loaded_plugin_commands boolean flag. Modifies instance state by adding commands to the command registry."
      },
      "get_command": {
        "human": "Looks up and retrieves a command by name from multiple sources in a specific order. First checks built-in and plugin commands that are always available. If not found, tries to load the application and search its custom commands. If the application fails to load, displays an error message and continues gracefully. This allows the command-line tool to work even when the main application has problems.",
        "technical": "Implements Click command resolution with fallback hierarchy: calls `_load_plugin_commands()`, then `super().get_command()` for built-in/plugin commands. If not found, uses `ScriptInfo.load_app()` to load Flask app, catching `NoAppException` to handle failures. Establishes app context via `ctx.with_resource(app.app_context())` if no current app is active, ensuring context availability for callbacks. Returns command from `app.cli.get_command()` or None if not found/app load failed."
      },
      "list_commands": {
        "human": "Collects and displays all available commands that can be run in a Flask application. It gathers commands from three sources: built-in commands, plugin commands, and commands defined in the Flask app itself. If the app fails to load, it shows an error message but continues working, ensuring users can still see other available commands.",
        "technical": "Aggregates CLI commands from multiple sources into a sorted list. Calls `_load_plugin_commands()` and `super().list_commands(ctx)` for built-in/plugin commands, then attempts `info.load_app().cli.list_commands(ctx)` to retrieve app-specific commands. Handles `NoAppException` by displaying formatted error message and generic exceptions by printing full traceback via `click.secho()`. Returns sorted set of all discovered command names as a list."
      },
      "make_context": {
        "human": "Prepares the environment and settings needed before running Flask command-line commands. It prevents the Flask development server from accidentally starting when you're just trying to run other commands, and sets up a special information object that contains important Flask app configuration. Think of it as setting up the workspace before you start working.",
        "technical": "Overrides Click's context creation to inject Flask-specific behavior. Sets `FLASK_RUN_FROM_CLI` environment variable to prevent `app.run()` from blocking CLI commands. Creates and injects a `ScriptInfo` object into the context's `obj` parameter if not already present, passing `create_app`, `set_debug_flag`, and `load_dotenv` callbacks. Delegates to parent class's `make_context()` to complete standard Click context initialization and returns the resulting Context object."
      },
      "parse_args": {
        "human": "This function processes command-line arguments for a Flask application. When the user runs the command without any arguments (or only with a help flag), it first tries to load configuration from environment variables and application settings. This ensures that any commands defined in the application are visible when showing help information, even if they weren't specified on the command line.",
        "technical": "Overrides Click's parse_args method to handle early option processing. Checks if args is empty (with no_args_is_help enabled) or contains only help flags. If true, preemptively calls handle_parse_result on _env_file_option and _app_option to load configuration from environment variables before help display. Finally delegates to parent class's parse_args method and returns the parsed argument list."
      },
      "convert": {
        "human": "This function takes a single value (like a text string from an environment variable) and splits it into multiple separate pieces, then processes each piece individually. It's used when you need to handle multiple values that were provided together as one combined input, converting each piece into the proper format before returning them all as a list.",
        "technical": "Overrides the convert method in a Click parameter type class. Splits the input value into multiple items using `split_envvar_value()`, then applies the parent class's `convert()` method to each item individually via list comprehension. Returns a list of converted values. Uses a workaround to call `super().convert` outside the list comprehension for Python <3.12 compatibility. Passes through the Click parameter and context objects to maintain the conversion chain."
      },
      "app": {
        "human": "This function is designed to intentionally fail and report an error whenever it's called. It acts as a placeholder that raises a previously captured error, essentially re-throwing an exception that occurred elsewhere. This is typically used when you want to defer error handling or propagate an error through a web application interface.",
        "technical": "WSGI application callable that unconditionally raises an exception (`err`) with suppressed context (`from None`). Takes standard WSGI parameters (environ dictionary and start_response callable) but never uses them. Returns type hint indicates it should yield bytes, but execution never reaches a return due to the immediate raise. The `err` variable must be defined in an outer scope."
      }
    },
    "src/flask/config.py": {
      "__init__": {
        "human": "Sets up a new object that needs to know where files are stored on the computer and what default settings to use. It's like creating a filing system where you specify the main folder location and any standard preferences you want to apply. The object inherits capabilities from a parent class and remembers the folder path for later use.",
        "technical": "Initializes an instance by calling parent class constructor with a defaults dictionary (empty dict if None provided), then stores the root_path attribute. Takes root_path as str or PathLike object and optional defaults dict. Uses super().__init__() to initialize parent class with defaults parameter. Sets instance variable self.root_path for subsequent file system operations. No return value; modifies instance state only."
      },
      "__get__": {
        "human": "This is a descriptor that retrieves configuration values from an application's settings. When you access a configuration property, it looks up the value by name and optionally transforms it into a different format before returning it. If accessed on the class itself (not an instance), it returns the descriptor object for introspection.",
        "technical": "Implements the descriptor protocol's `__get__` method. Returns `self` when accessed on the class (obj is None). For instance access, retrieves the value from `obj.config` dictionary using the descriptor's `__name__` as key. Applies optional transformation via `self.get_converter()` if configured. Returns the raw or converted configuration value with type hint `T`, or `te.Self` for class-level access."
      },
      "from_envvar": {
        "human": "This function helps load application settings from a configuration file by reading the file path from an environment variable. Instead of manually checking if the environment variable exists and handling errors, this function does it automatically. If the environment variable isn't set, it either fails quietly or shows a helpful error message explaining what went wrong and how to fix it.",
        "technical": "Retrieves the value of the specified environment variable using `os.environ.get()`. If the variable is unset and `silent=False`, raises a `RuntimeError` with a descriptive message; if `silent=True`, returns `False`. When the variable exists, delegates to `self.from_pyfile()` passing the environment variable's value as the file path and forwarding the `silent` parameter. Returns a boolean indicating successful configuration loading."
      },
      "from_prefixed_env": {
        "human": "Loads configuration settings from environment variables that start with a specific prefix (like \"FLASK_\"). It automatically removes the prefix and tries to convert text values into appropriate data types (numbers, lists, etc.). It also supports nested settings by using double underscores in variable names, so \"FLASK_DATABASE__HOST\" becomes a nested configuration structure.",
        "technical": "Iterates through sorted environment variables, filters by prefix, and removes prefix from keys. Attempts JSON parsing via `loads()` function on each value, falling back to string on error. Handles nested dictionary creation by splitting keys on \"__\" delimiter and traversing/creating intermediate dicts as needed. Directly assigns non-nested keys to self (dict-like config object). Returns True unconditionally after processing all matching env vars."
      },
      "from_pyfile": {
        "human": "Loads configuration settings from a Python file into the application's configuration. The file can be specified using either a full path or a path relative to the application's root folder. If the file doesn't exist, it can either raise an error or silently fail depending on your preference. This allows you to keep configuration settings in separate Python files that can be easily edited.",
        "technical": "Resolves the filename relative to `self.root_path`, creates a temporary module object using `types.ModuleType`, reads and compiles the Python file content, then executes it in the module's namespace using `exec()`. Catches `OSError` exceptions for missing/invalid files, returning `False` if `silent=True`, otherwise re-raises with enhanced error message. Finally calls `self.from_object(d)` to update config from the executed module and returns `True` on success."
      },
      "from_object": {
        "human": "Loads configuration settings from a Python module or class into the application's configuration. You can provide either the name of a module (as text) or the actual module/class object itself. It automatically picks up any settings that are written in ALL CAPS and adds them to the configuration. This is typically used to load default settings when an application starts up.",
        "technical": "Accepts either a string (import path) or object reference as input. If string, uses `import_string()` to dynamically import the module/class. Iterates through all attributes using `dir(obj)`, filters for uppercase-named attributes via `key.isupper()`, and copies their values into the config dictionary using `getattr()` and `self[key]` assignment. Modifies the config object in-place (no return value). Only processes uppercase attributes, ignoring all lowercase/mixed-case names."
      },
      "from_file": {
        "human": "Loads configuration settings from a file (like JSON or TOML) into the application's config. You point it to a file, tell it how to read that file format, and it updates the configuration with whatever settings are in the file. If the file doesn't exist, it can either fail or silently ignore it depending on your preference.",
        "technical": "Constructs absolute file path by joining filename with root_path, opens file in text or binary mode based on `text` parameter, passes file handle to the `load` callable to parse contents into a mapping, then delegates to `from_mapping()` to update config. Catches OSError for missing/invalid files\u2014returns False if `silent=True` and errno is ENOENT/EISDIR, otherwise re-raises with enhanced error message. Returns boolean indicating success."
      },
      "from_mapping": {
        "human": "This function updates configuration settings by accepting key-value pairs from either a dictionary or keyword arguments. It filters the settings to only accept keys that are written in all uppercase letters (like \"DEBUG\" or \"PORT\"), ignoring any lowercase or mixed-case keys. This ensures only valid configuration constants are added to the config object.",
        "technical": "Merges a mapping parameter and kwargs into a single dictionary, then iterates through key-value pairs using `.items()`. Applies a filter using `.isupper()` to only update `self[key]` for uppercase keys, effectively treating the instance as a dict-like object. Combines optional positional mapping with keyword arguments for flexible input. Always returns `True` to indicate completion regardless of how many items were actually updated."
      },
      "get_namespace": {
        "human": "Filters configuration settings to find only those that start with a specific prefix (like \"IMAGE_STORE_\"), then creates a simplified dictionary with just those settings. Optionally removes the prefix from the keys and converts them to lowercase, making it easier to pass configuration values directly to functions that need them without the full prefix names.",
        "technical": "Iterates through all key-value pairs via `self.items()`, filtering entries where keys match the namespace prefix using `startswith()`. For matching entries, optionally strips the namespace prefix using slice notation `k[len(namespace):]` and converts keys to lowercase via `key.lower()` based on boolean flags. Returns a new dictionary containing the filtered and transformed configuration subset without modifying the original configuration object."
      }
    },
    "src/flask/ctx.py": {
      "after_this_request": {
        "human": "Allows you to register a function that will run after the current web request finishes, but only for that specific request. This is useful when you need to modify the response (like adding headers) based on what happened during that particular request. It must be used inside a request handler, not during application setup, otherwise it will raise an error.",
        "technical": "Decorator that appends a callback function to the current request context's `_after_request_functions` list. Retrieves the active application context via `_cv_app.get()`, validates that a request context exists by checking `ctx.has_request`, and raises `RuntimeError` if called outside a request context. Returns the original function unmodified, making it a registration decorator rather than a wrapper. The registered function will be invoked during response finalization for only the current request."
      },
      "copy_current_request_context": {
        "human": "This decorator allows background tasks (like threads or async jobs) to access Flask's request information that was available when the task was created. Without it, background tasks can't see things like the current web request, user session, or app settings. It's useful when you need to spin off work in the background but still need access to the original request's data.",
        "technical": "Captures the current Flask request context using `_cv_app.get()`, creates a copy via `ctx.copy()`, and returns a wrapper function that executes the decorated function within that preserved context using a `with` statement. Raises `RuntimeError` if called outside an active request context. Uses `ctx.app.ensure_sync()` to guarantee synchronous execution and `update_wrapper()` to preserve the original function's metadata."
      },
      "has_request_context": {
        "human": "Checks whether your Flask application is currently handling an incoming web request. This is useful when you have code that might run in different situations (during a request or outside of one, like in background tasks) and you need to know if request-specific information like the user's IP address is available before trying to access it.",
        "technical": "Returns a boolean indicating if a Flask request context is active. Uses walrus operator to retrieve the current app context from `_cv_app` context variable via `.get(None)`, then checks if that context exists and has the `has_request` attribute set to True. Returns False if no app context exists or if the context has no active request. No side effects."
      },
      "has_app_context": {
        "human": "Checks whether your Flask application's context is currently active and available for use. This is useful when you need to verify if you can safely access application-level resources like configuration or the global `g` object. It works both during web requests and in other scenarios like command-line tools, helping you avoid errors when trying to use Flask features that require an active application.",
        "technical": "Returns a boolean by checking if the context variable `_cv_app` contains a non-None value using `_cv_app.get(None)`. Queries Flask's internal context-local storage mechanism (likely a ContextVar) to determine if an application context has been pushed onto the stack. Returns `True` if an app context exists, `False` otherwise. No side effects - purely a read-only state check of Flask's context management system."
      },
      "__getattr__": {
        "human": "This function allows you to access an object's attributes using dot notation (like `object.attribute_name`). When you try to access an attribute that doesn't exist through normal means, this function steps in to look for it in the object's internal storage dictionary. If the attribute isn't found there either, it tells you the attribute doesn't exist by raising an error.",
        "technical": "Implements custom attribute access by overriding `__getattr__` magic method. Attempts to retrieve the requested attribute from the instance's `__dict__` dictionary. Catches `KeyError` exceptions and converts them to `AttributeError` with the attribute name, suppressing the original exception chain using `from None`. Returns the attribute value if found, otherwise raises `AttributeError` to maintain standard Python attribute access behavior."
      },
      "__delattr__": {
        "human": "Removes an attribute (a piece of data attached to an object) when you use the `del` command on it. For example, if you have an object with a \"name\" property and you want to delete that property, this function handles that deletion. If you try to delete something that doesn't exist, it tells you there's an error.",
        "technical": "Implements the special method for attribute deletion via `del obj.attribute` syntax. Attempts to remove the named key from the instance's `__dict__` dictionary. Catches `KeyError` exceptions when the attribute doesn't exist and re-raises as `AttributeError` with the attribute name, suppressing the original exception chain with `from None`. Returns `None` on successful deletion."
      },
      "get": {
        "human": "Retrieves a stored attribute from an object by its name, similar to looking up a value in a dictionary. If the attribute doesn't exist, it returns a backup value you specify instead of causing an error. This provides a safe way to access object properties that might not always be present.",
        "technical": "Directly accesses the object's internal `__dict__` dictionary using the `.get()` method with the provided attribute name and default value. Returns the attribute value if it exists in the instance dictionary, otherwise returns the default parameter (None if not specified). Simple pass-through wrapper that provides dict-like access semantics to object attributes without raising AttributeError."
      },
      "pop": {
        "human": "Removes this context from being the active one and runs cleanup operations. It's like closing a workspace - you can only close the workspace that's currently open, and if you opened it multiple times, you need to close it the same number of times. When finally closed, it cleans up resources like closing requests and notifying other parts of the application that the context is done.",
        "technical": "Validates this context is currently active via `_cv_app.get()` and `_cv_token`, then decrements `_push_count`. Only performs actual cleanup when count reaches zero: calls `do_teardown_request()` on the request object, closes the request with `_request.close()`, executes `do_teardown_appcontext()`, resets the context variable token via `_cv_app.reset()`, and sends `appcontext_popped` signal. Raises `RuntimeError` if context isn't pushed or isn't the active one."
      },
      "setdefault": {
        "human": "This function retrieves a stored attribute value by name, but if that attribute doesn't exist yet, it automatically creates it with a default value you provide and returns that default. It's like checking if something is in storage, and if not, putting it there first before giving it to you. This prevents errors when trying to access attributes that might not exist yet.",
        "technical": "Delegates directly to Python's built-in `dict.setdefault()` method on the object's `__dict__` attribute dictionary. Takes an attribute name string and optional default value, returning the existing value if the attribute exists or setting and returning the default value if it doesn't. Modifies object state as a side effect by adding the attribute to `__dict__` when it's missing. Single-line implementation that wraps standard dictionary behavior for attribute access."
      },
      "__repr__": {
        "human": "Creates a text description of this object that shows what it represents. If there's an active web request, it includes details about which website and what type of request (like GET or POST). If there's no request, it just shows basic identification information. This is useful for debugging to quickly see what the object is doing.",
        "technical": "Implements the `__repr__` special method to return a string representation of the object. Conditionally checks if `_request` attribute exists; if present, formats a string containing the class name via `type(self).__name__`, object ID via `id(self)`, app name, HTTP method, and request URL. If no request exists, returns a simpler format with just class name, object ID, and app name. Returns a formatted f-string in both cases."
      },
      "wrapper": {
        "human": "This function acts as a protective wrapper that ensures another function runs in the correct environment. It temporarily activates a specific context (like switching to a particular workspace), runs the wrapped function with whatever inputs were provided, and then cleans up. This is commonly used in web applications to ensure functions have access to the right settings and data.",
        "technical": "Context manager wrapper that activates a context object (`ctx`) and executes function `f` through `ctx.app.ensure_sync()`. Accepts arbitrary positional and keyword arguments via `*args` and `**kwargs`, forwarding them to the wrapped function. The `ensure_sync` call converts async functions to sync if needed. Returns whatever the wrapped function returns. Typically used in Flask/Quart-like frameworks for request context management."
      },
      "__init__": {
        "human": "Sets up a new application context for a Flask web application, which is like creating a workspace that holds important information while handling web requests. It prepares storage areas for global data, URL routing, and tracks things like flash messages. If something goes wrong while setting up URL routing, it saves that error for later handling instead of crashing immediately.",
        "technical": "Initializes Flask's AppContext by storing the Flask app instance, instantiating the globals object via `app.app_ctx_globals_class()`, and initializing instance variables for request, session, flashes, and after-request callbacks. Attempts to create a URL adapter using `app.create_url_adapter()`, catching HTTPException and storing it in `request.routing_exception` if binding fails. Sets up context management variables (`_cv_token`, `_push_count`) for tracking context stack state during push/pop operations."
      },
      "from_environ": {
        "human": "Creates a request context for a Flask web application from raw web server data. This is like translating the incoming web request information into a format that Flask can work with internally. It packages up both the application and the specific request details so Flask can process the incoming web request properly.",
        "technical": "Factory classmethod that instantiates a request context from WSGI environ dict. Creates a Flask Request object using `app.request_class(environ)`, configures its JSON module to match the app's JSON handler, then returns a new instance of the context class (cls) initialized with both the app and request objects. Bridges WSGI-level data to Flask's request handling layer."
      },
      "has_request": {
        "human": "Checks whether this context object was set up with information from an incoming web request. This is useful for determining if the current operation is handling a user's web request or running in some other mode (like a background task or command-line script). Returns a simple yes/no answer.",
        "technical": "Property method that returns a boolean indicating whether the instance's `_request` attribute contains a value. Performs a None-check on the private `_request` attribute and returns True if a request object exists, False otherwise. No side effects or external calls - pure state inspection of the instance variable."
      },
      "copy": {
        "human": "Creates a duplicate copy of the current context that shares the same underlying data. This is useful when you need to work with the same request and session information in a different part of your application, like when passing context between threads or background tasks. The copy maintains references to the original request and session data rather than creating entirely new ones.",
        "technical": "Instantiates a new context object of the same class using the constructor pattern `self.__class__()`, passing three arguments: the Flask application instance (`self.app`), the current request object (`self._request`), and the current session object (`self._session`). Returns a new context instance that references the same underlying data objects without deep copying them. The method preserves the current session state rather than reloading original session data."
      },
      "request": {
        "human": "This function provides safe access to the current web request information when your application is handling an incoming request. It acts as a gatekeeper that prevents errors by checking if a request actually exists before giving you access to it. If you try to access request information when no request is being processed (like during startup), it stops you with a clear error message instead of causing a crash.",
        "technical": "Property method that returns the Request object stored in `self._request` after validating it exists. Performs null-check on the internal `_request` attribute and raises RuntimeError with descriptive message if None, preventing access outside valid request contexts. Returns the Request object directly when available, providing controlled access to request-scoped data within the context manager pattern."
      },
      "session": {
        "human": "Retrieves the user's session data (like login status, shopping cart, preferences) for the current web request. If no session exists yet, it creates one using the application's session system. This allows the web application to remember information about users as they navigate between pages. It prevents access when there's no active web request happening.",
        "technical": "Property method that lazily initializes and returns a SessionMixin object. Guards against access outside request context by checking `_request`. Uses cached `_session` or calls `session_interface.open_session()` to create session from app and request. Falls back to `make_null_session()` if session creation fails. Implements lazy loading pattern with instance-level caching via `_session` attribute."
      },
      "match_request": {
        "human": "This function figures out which part of the web application should handle an incoming web request by matching the requested URL to the application's defined routes. It's like a receptionist directing visitors to the right department - it looks at where the user is trying to go and determines which function should respond. If the URL doesn't match any known routes, it records that error instead.",
        "technical": "Calls `self.url_adapter.match(return_rule=True)` to perform URL routing on the current request. On success, unpacks the result tuple into `self._request.url_rule` (the matched route) and `self._request.view_args` (extracted URL parameters). On HTTPException, stores the exception in `self._request.routing_exception`. All operations mutate the `_request` object's attributes as side effects; returns None."
      },
      "push": {
        "human": "Makes this context the \"active\" one so the application knows which request or operation it's currently handling. It's like raising your hand in class to show you're the one speaking. If this context represents an incoming web request, it also figures out which URL route should handle it. The function keeps track of how many times it's been activated to avoid doing unnecessary work when activated multiple times.",
        "technical": "Increments `_push_count` to track activation depth. On first push (when `_cv_token` is None), sets the context as active via `_cv_app.set()`, stores the token, and sends `appcontext_pushed` signal. If this is a request context (both `_request` and `url_adapter` exist), calls `match_request()` to perform URL routing. Subsequent pushes increment the counter but skip initialization. Returns None with side effects of modifying instance state and triggering signals."
      },
      "__enter__": {
        "human": "This function sets up the object for use in a \"with\" statement (context manager). When you start a \"with\" block, this function activates by pushing the current state onto a stack, allowing you to safely enter a new context. It prepares the object for temporary use and ensures you can return to the previous state later.",
        "technical": "Implements the context manager protocol's entry method (`__enter__`). Calls `self.push()` to save current state to an internal stack, then returns `self` to bind the object to the \"with\" statement's target variable. Return type annotation `te.Self` indicates it returns the instance itself. No parameters beyond `self`; side effect is state modification via `push()`."
      },
      "__exit__": {
        "human": "This function handles cleanup when exiting a context (like when leaving a \"with\" block in Python). It ensures that any error that occurred gets properly processed and removed from an internal tracking system. Think of it as closing a door behind you and making sure any problems that happened inside are properly logged before you leave.",
        "technical": "Context manager exit method that implements the `__exit__` protocol for Python's `with` statement. Receives exception information (type, value, traceback) from the runtime and passes the exception value to `self.pop()` for cleanup/removal from an internal stack or collection. Returns `None`, allowing any exception to propagate normally rather than suppressing it."
      }
    },
    "src/flask/debughelpers.py": {
      "attach_enctype_error_multidict": {
        "human": "Improves error messages when developers try to access uploaded files but forget to set the correct form encoding. When a file field is accessed but the form wasn't configured properly, it provides a helpful error message explaining that `enctype=multipart/form-data` is needed, rather than showing a confusing generic error.",
        "technical": "Dynamically subclasses `request.files`'s class and overrides `__getitem__` to intercept KeyError exceptions. When a key exists in `request.form` but not in `request.files`, raises a custom `DebugFilesKeyError` with preserved traceback instead of generic KeyError. Preserves original class metadata (`__name__`, `__module__`) and replaces the instance's `__class__` attribute in-place to patch behavior without affecting other instances."
      },
      "_dump_loader_info": {
        "human": "This function creates a readable text report about a data loader object. It extracts and formats information about the loader's type and its configuration settings, filtering out internal details and organizing lists in a clean, indented format. Think of it as generating a summary card that shows what kind of loader it is and how it's configured.",
        "technical": "Generates formatted string output describing a BaseLoader instance by yielding its fully-qualified class name, then iterating through its `__dict__` attributes. Filters out private attributes (starting with \"_\") and non-serializable types, keeping only str/int/float/bool primitives and lists/tuples of strings. Lists are formatted with YAML-style indentation (\"- item\"), while scalar values use repr() formatting. Returns an iterator of formatted strings suitable for debugging or logging."
      },
      "explain_template_loading_attempts": {
        "human": "Helps developers debug why a template file couldn't be loaded by showing where the system looked for it. When template loading fails (or finds multiple matches), it logs a detailed report showing each location checked, which folders were searched, and whether the template was found. If you're working with Flask blueprints, it provides extra hints about common mistakes with template folder placement.",
        "technical": "Iterates through template loading attempts (loader, source object, result triple), formats diagnostic information about each loader's search paths via `_dump_loader_info()`, and tracks match count. Detects anomalies (zero or multiple matches), retrieves current blueprint context from `_cv_app.get()`, appends blueprint-specific guidance when issues detected, and outputs complete diagnostic report via `app.logger.info()`. Returns None; side effect is logging structured debugging information."
      },
      "__init__": {
        "human": "This is an error message constructor that explains why a web request failed due to a URL redirect issue. It creates a helpful error message telling developers that they accessed a URL incorrectly (like missing a trailing slash) and that their web framework automatically redirected them to the correct URL. The message warns that this redirect behavior can cause problems with form submissions in web browsers.",
        "technical": "Initializes an exception by extracting a `RequestRedirect` from `request.routing_exception`, then constructs a multi-part error message in a buffer list. Compares `request.base_url` with the redirect target using `partition(\"?\")[0]` to detect trailing slash issues. Conditionally appends additional context about Flask's trailing slash behavior. Joins all buffer segments and passes the complete message to the parent exception class via `super().__init__()`."
      },
      "__getitem__": {
        "human": "This function retrieves a file from uploaded form data, but provides better error messages when something goes wrong. When you try to access a file that doesn't exist, it checks whether the problem is that the file is missing or if you're looking in the wrong place (form data vs. file uploads). It helps developers understand why they can't access an uploaded file.",
        "technical": "Overrides dictionary-style access (`[]` operator) by calling parent class `__getitem__`. On KeyError, checks if the key exists in `request.form` - if so, raises a custom `DebugFilesKeyError` with the original traceback preserved via `with_traceback()` and `from None` to suppress exception chaining. Otherwise, re-raises the original KeyError. Returns the value associated with the key if found."
      }
    },
    "src/flask/globals.py": {
      "__getattr__": {
        "human": "This function handles requests for outdated attribute names in Flask. When code tries to access the old \"request_ctx\" attribute, it shows a warning message explaining that this name is deprecated and will be removed in Flask 4.0, then redirects to use \"app_ctx\" instead. For any other unknown attribute names, it raises an error.",
        "technical": "Module-level `__getattr__` implementation that intercepts attribute access. Checks if requested attribute is \"request_ctx\" and issues a DeprecationWarning via warnings.warn with stacklevel=2, then returns the app_ctx object as a fallback. For all other attribute names, raises AttributeError. Provides backward compatibility during Flask's transition from request_ctx to app_ctx."
      }
    },
    "src/flask/helpers.py": {
      "get_debug_flag": {
        "human": "Checks if the application should run in debug mode by looking at a special setting called FLASK_DEBUG. Debug mode is turned ON only if this setting exists and is set to something like \"true\" or \"yes\" or \"1\". If the setting doesn't exist or is set to \"false\", \"no\", or \"0\", debug mode stays OFF (which is the safer default).",
        "technical": "Retrieves the FLASK_DEBUG environment variable using os.environ.get(). Performs case-insensitive string comparison by converting the value to lowercase and checking if it's NOT in the set {\"0\", \"false\", \"no\"}. Returns a boolean: True if the variable exists and contains a truthy value, False if the variable is absent or contains an explicitly falsy string. Uses short-circuit evaluation (val and ...) to handle None values safely."
      },
      "get_load_dotenv": {
        "human": "Checks if the user wants to skip loading environment variable files (dotenv files) when starting a Flask application. By default, Flask loads these files, but users can set an environment variable called FLASK_SKIP_DOTENV to prevent this. The function returns True if dotenv files should be loaded, False if they should be skipped.",
        "technical": "Reads the FLASK_SKIP_DOTENV environment variable using os.environ.get(). Returns the provided default parameter (True by default) if the variable is unset. If set, converts the value to lowercase and checks if it matches \"0\", \"false\", or \"no\" - returning True for these values (meaning load dotenv), False otherwise. Implements inverted logic where the env var name suggests skipping but function returns whether to load."
      },
      "stream_with_context": {
        "human": "Allows streaming responses (like large files or real-time data) to access Flask request information even after the original request has ended. Normally, when streaming data back to a user, the request context disappears, but this function preserves it so you can still access things like request parameters, session data, and global variables throughout the entire streaming process.",
        "technical": "Wraps generators or generator functions to execute within a captured request context. Uses `_cv_app.get()` to retrieve the current context, then yields within a `with ctx:` block to maintain it. Handles both decorator usage (returns wrapped function via `update_wrapper`) and direct generator wrapping (returns iterator). Pre-executes generator to sentinel `None` value to capture context before actual iteration begins. Includes cleanup via `gen.close()` for WSGI iterator compatibility."
      },
      "make_response": {
        "human": "Converts various types of return values from Flask view functions into proper Response objects that can have headers and other properties modified. This is useful when you need to add custom headers or modify a response before returning it, since Flask normally handles the conversion automatically. Without this function, it would be difficult to customize responses that come from template rendering or other view return values.",
        "technical": "Normalizes variable arguments into a Flask Response object by delegating to `current_app.make_response()`. Handles three cases: no arguments returns empty `current_app.response_class()` instance; single argument passes it directly to `current_app.make_response()`; multiple arguments unwraps the first element from the args tuple before passing to `current_app.make_response()`. Acts as a convenience wrapper around Flask's internal response creation mechanism."
      },
      "url_for": {
        "human": "Creates a web link (URL) to a specific page or function in your Flask web application. You provide the name of the page you want to link to, and it builds the complete web address for you. Can also add extra parts like query parameters (?key=value), anchors (#section), and control whether the link includes the full domain name or just the path.",
        "technical": "Wrapper function that delegates URL generation to `current_app.url_for()` method, passing through all parameters. Accepts endpoint name (with optional blueprint prefix via dot notation), URL modifiers (_anchor, _method, _scheme, _external), and variable keyword arguments for URL rule variables and query parameters. Requires active Flask application or request context. Returns fully constructed URL string based on application's routing configuration."
      },
      "redirect": {
        "human": "Creates a web page redirect that sends users from one URL to another. When a user visits a page, this function generates a response that tells their browser to automatically navigate to a different location. It's like putting up a sign that says \"this page has moved to a new address\" and automatically taking visitors there.",
        "technical": "Checks if Flask application context exists via `_cv_app.get()`. If context is available, delegates to `ctx.app.redirect()` to use Flask's configured redirect method. Otherwise, falls back to Werkzeug's `_wz_redirect()` utility function. Returns a `BaseResponse` object with HTTP redirect status code (default 302). The Response parameter is only used in the Werkzeug fallback path, as Flask uses its own response class."
      },
      "abort": {
        "human": "This function stops the normal flow of a web application and immediately returns an error page to the user (like a 404 \"Not Found\" or 500 \"Server Error\"). It's used when something goes wrong and you need to tell the user about the problem right away. The function smartly uses Flask's custom error handler if available, otherwise falls back to a basic error system.",
        "technical": "Raises an HTTPException by first attempting to use the current Flask app's custom aborter object (retrieved via `_cv_app.get()` context variable), and if no app context exists, falls back to Werkzeug's default `_wz_abort()` function. Accepts an HTTP status code (int or BaseResponse), plus variadic args/kwargs that are forwarded to the exception constructor. Returns `t.NoReturn` type hint indicating the function never returns normally (always raises)."
      },
      "get_template_attribute": {
        "human": "Retrieves a specific macro or variable that was defined inside a Jinja template file so you can use it directly in your Python code. This bridges the gap between template definitions and Python logic, allowing you to reuse template macros (like reusable functions) without rendering the entire template. For example, you can extract a \"hello\" macro from a template and call it like a regular Python function.",
        "technical": "Loads a Jinja template by name using the current Flask app's Jinja environment, accesses its module representation (which contains all exported template variables and macros as attributes), and returns the requested attribute using getattr(). Returns the raw macro/variable object that can be invoked directly from Python. Relies on current_app.jinja_env.get_template() for template loading and the Jinja module interface for attribute access."
      },
      "flash": {
        "human": "Stores a message that will be displayed to the user on their next page load, commonly used for showing notifications like \"Login successful\" or \"Error: Invalid input\". The message is saved temporarily in the user's session and can be categorized (e.g., as an error, warning, or info message) to control how it appears visually. After storing the message, it notifies other parts of the application that a flash message was created.",
        "technical": "Retrieves the `_flashes` list from the session, appends a tuple of (category, message) to it, and explicitly reassigns it back to session to ensure persistence with external session storage. Sends a `message_flashed` signal using Flask's signal system with the current app object and an async wrapper. Uses `current_app._get_current_object()` to get the actual app instance rather than a proxy. Returns None but has side effects of modifying session state and triggering signal handlers."
      },
      "get_flashed_messages": {
        "human": "Retrieves notification messages that were temporarily stored for the user (like success confirmations or error alerts) and removes them from storage so they only appear once. You can choose to get just the messages or include their types (like \"error\" or \"success\"), and optionally filter to show only specific types of messages.",
        "technical": "Lazily loads flashed messages from session storage on first call, caching them in `app_ctx._flashes` for subsequent requests. Pops `_flashes` key from session to ensure one-time retrieval. Optionally filters messages by category using lambda filter. Returns either list of message strings (default) or list of (category, message) tuples based on `with_categories` flag. Uses list comprehension `[x[1] for x in flashes]` to extract message text when categories not needed."
      },
      "_prepare_send_file_kwargs": {
        "human": "Prepares the necessary settings and configuration needed to send a file to a user's web browser. It gathers information from the application like how long the browser should cache the file, what type of response to send, and where to find files on the server. This ensures files are sent correctly with all the right settings applied.",
        "technical": "Retrieves the current Flask application context and populates kwargs dictionary with file-sending parameters. Sets `max_age` from `get_send_file_max_age` if not provided, then updates kwargs with request environment, X-Sendfile configuration flag, response class, and application root path. Returns the enriched kwargs dict for use by send_file operations. No side effects beyond dictionary manipulation."
      },
      "send_file": {
        "human": "Sends a file from the server to the user's browser, either for display or download. Handles all the technical details of file delivery including setting the correct file type, enabling browser caching, and supporting features like resumable downloads. Acts as a convenient wrapper that prepares Flask-specific settings before handing off the actual file transmission to the underlying web framework.",
        "technical": "Flask wrapper function that delegates to `werkzeug.utils.send_file` after preparing Flask-specific parameters via `_prepare_send_file_kwargs`. Accepts file paths or binary file objects, extracts `request.environ` from Flask's request context, and passes through configuration for MIME type detection, Content-Disposition headers, conditional/range requests, ETags, last-modified timestamps, and cache control. Returns a Response object containing the file data with appropriate HTTP headers."
      },
      "send_from_directory": {
        "human": "Safely serves a file from a specific folder on the server to the user's browser. It's designed to prevent security issues where a malicious user might try to access files outside the intended folder (like system files). If the requested file doesn't exist, it returns a \"not found\" error. Commonly used for serving uploaded files or static content in web applications.",
        "technical": "Flask wrapper around Werkzeug's send_from_directory that adds Flask-specific argument processing. Takes a trusted directory path and user-provided file path, passes kwargs through _prepare_send_file_kwargs() for Flask-specific transformations, then delegates to werkzeug.utils.send_from_directory which handles path validation via safe_join and file transmission. Returns a Response object containing the file content with appropriate headers."
      },
      "get_root_path": {
        "human": "Finds the folder location where a Python module or package lives on your computer. It first checks if the module is already loaded in memory, then tries to locate it through Python's import system. If it can't find the location, it just returns your current working folder as a fallback.",
        "technical": "Attempts three strategies to resolve module root path: (1) checks sys.modules cache for already-imported module and extracts dirname from __file__, (2) uses importlib.util.find_spec() to get loader and calls get_filename(), (3) falls back to __import__() and extracts __file__ from sys.modules. Returns os.path.dirname(os.path.abspath(filepath)) of the resolved file path, or os.getcwd() if loader is None. Raises RuntimeError for namespace packages without file information."
      },
      "_split_blueprint_path": {
        "human": "Breaks down a hierarchical blueprint name (like \"parent.child.grandchild\") into all its component parts. For example, if you give it \"a.b.c\", it returns a list containing \"a.b.c\", \"a.b\", and \"a\" - essentially showing the full path and all parent levels. This helps navigate nested blueprint structures by providing every level of the hierarchy.",
        "technical": "Recursively splits a dot-separated blueprint path string into all prefix components. Uses `rpartition(\".\")` to separate the rightmost segment, then recursively calls itself on the left portion. Returns a list starting with the full name, followed by progressively shorter parent paths. Decorated with `@cache` to memoize results and avoid redundant recursive computations for the same input strings."
      },
      "generator": {
        "human": "This function wraps another generator to ensure it runs within an active web request context. It's used when you need to stream data (like large files or real-time updates) to a user while maintaining access to request-specific information. If there's no active request, it stops and reports an error. When finished, it properly cleans up any resources the wrapped generator was using.",
        "technical": "Retrieves the current application context from `_cv_app` ContextVar and raises RuntimeError if none exists. Executes within the context manager, yields None initially (likely for protocol reasons), then delegates to the wrapped `gen` iterator using `yield from`. In the finally block, calls `gen.close()` if the attribute exists to properly cleanup WSGI iterators. Returns an iterator that preserves request context throughout streaming operations."
      },
      "decorator": {
        "human": "This function wraps another function or generator to make it work properly within a web request context. It ensures that when you're streaming data (like sending chunks of a large file or real-time updates) to a user's browser, the streaming process maintains awareness of the current web request's settings and state throughout the entire operation.",
        "technical": "A decorator wrapper that calls `generator_or_function` with all passed arguments to obtain a generator object, then wraps it with `stream_with_context()` to preserve Flask's request context during streaming operations. Returns a context-aware generator that can safely access request-scoped variables throughout its execution. Enables streaming responses while maintaining access to Flask's g, request, and session objects."
      }
    },
    "src/flask/json/__init__.py": {
      "dumps": {
        "human": "Converts Python data (like dictionaries, lists, numbers) into JSON text format that can be saved to files or sent over the internet. If running inside a Flask web application, it uses the app's custom JSON settings; otherwise, it uses Python's standard JSON converter with special handling for certain data types like decimals.",
        "technical": "Conditionally delegates JSON serialization based on Flask application context availability. If `current_app` exists, invokes `current_app.json.dumps()` to leverage app-specific JSON configuration. Otherwise, falls back to standard library `_json.dumps()` with `_default` function as the default serializer (via `kwargs.setdefault`) to handle non-standard types. Returns serialized JSON string. Accepts arbitrary keyword arguments passed through to underlying dumps implementation."
      },
      "dump": {
        "human": "Saves data to a file in JSON format. If the function is being used within a Flask web application, it uses Flask's custom JSON settings (which might handle special data types). If not in a Flask app, it uses Python's standard JSON saving with a fallback handler for data types that aren't normally JSON-compatible.",
        "technical": "Conditionally delegates JSON serialization based on Flask context availability. If `current_app` exists, invokes `current_app.json.dump()` with all kwargs passed through. Otherwise, falls back to standard library `json.dump()` with `_default` function set as the default serializer via `kwargs.setdefault()`. Writes serialized output directly to the provided file handle `fp`. No return value; performs file I/O side effect."
      },
      "loads": {
        "human": "Converts JSON text (like data from a web API or file) back into Python objects that your program can work with. It's the opposite of converting Python data to JSON - this reads JSON and turns it back into lists, dictionaries, numbers, etc. If running inside a Flask web application, it uses the app's custom JSON settings; otherwise, it uses Python's standard JSON converter.",
        "technical": "Deserializes JSON strings or UTF-8 bytes into Python objects using conditional routing. Checks if `current_app` (Flask application context) exists; if present, delegates to `current_app.json.loads()` to allow app-specific JSON handling overrides. Otherwise, falls back to standard library `_json.loads()`. Forwards all keyword arguments to the underlying loads implementation. Returns deserialized Python object (dict, list, str, int, float, bool, or None)."
      },
      "load": {
        "human": "Reads JSON data from a file and converts it into Python objects (like dictionaries, lists, etc.). It's a wrapper that checks if you're using Flask's web framework - if you are, it uses Flask's custom JSON reader which might have special settings; otherwise, it uses Python's standard JSON reader. This allows Flask applications to customize how JSON files are processed.",
        "technical": "Conditionally delegates JSON deserialization based on Flask application context. Checks `current_app` availability and routes to `current_app.json.load()` if present (enabling Flask's JSONProvider customization), otherwise falls back to standard library `_json.load()`. Accepts file pointer `fp` (text or UTF-8 binary mode) and forwards arbitrary kwargs to the underlying load implementation. Returns deserialized Python object (dict, list, etc.) from JSON file content."
      },
      "jsonify": {
        "human": "Converts Python data (like dictionaries, lists, or other values) into JSON format and packages it as a web response that browsers can understand. This is used when a web application needs to send data back to the user's browser in a standardized format. It handles the technical details of formatting and setting the correct content type automatically.",
        "technical": "Delegates JSON serialization and Response creation to `current_app.json.response()`, passing through all positional and keyword arguments unchanged. Acts as a thin wrapper that requires an active Flask application context. Returns a Flask Response object with `application/json` mimetype. The actual serialization logic, debug formatting, and response construction are handled by the application's configured JSONProvider."
      }
    },
    "src/flask/json/provider.py": {
      "_default": {
        "human": "Converts special Python objects into formats that can be saved as JSON text. Handles common types like dates, decimals, UUIDs, and custom objects that know how to display themselves as HTML. If it encounters an object type it doesn't know how to convert, it reports an error explaining that the object can't be turned into JSON.",
        "technical": "Custom JSON serializer fallback handler that converts non-standard types to JSON-compatible formats. Processes dates via http_date(), converts Decimal/UUID to strings, transforms dataclasses to dictionaries using dataclasses.asdict(), and serializes objects with __html__ methods to strings. Raises TypeError with descriptive message for unsupported types. Typically used as the 'default' parameter in json.dumps()."
      },
      "dumps": {
        "human": "Converts Python data (like dictionaries, lists, or numbers) into a JSON text string that can be saved to a file or sent over the internet. It uses the class's preferred settings for how the JSON should be formatted (like whether to sort keys alphabetically or handle special characters), but allows you to override these settings if needed.",
        "technical": "Wraps `json.dumps()` with configurable defaults from instance attributes. Sets three default kwargs using `setdefault()`: `default` (custom serializer), `ensure_ascii` (ASCII encoding flag), and `sort_keys` (key sorting flag). Passes the object and merged kwargs to `json.dumps()` and returns the resulting JSON string. Allows caller to override any defaults via kwargs."
      },
      "dump": {
        "human": "Takes any data (like a dictionary, list, or other Python objects) and saves it to a file in JSON format. This is useful when you want to store data in a text file that can be easily read by other programs or shared with others. The file must already be opened for writing before calling this function.",
        "technical": "Wrapper method that serializes a Python object to JSON and writes it to a file stream. Calls `self.dumps()` to convert the object to a JSON string (passing through any kwargs to the underlying JSON library), then writes the resulting string to the file pointer using `fp.write()`. No return value; performs side effect of writing to the file stream. Expects fp to be a text-mode file handle with UTF-8 encoding."
      },
      "loads": {
        "human": "Converts JSON-formatted text (either as a regular string or as bytes) back into Python data structures like dictionaries, lists, or other objects. This is useful when you receive JSON data from a file, web API, or database and need to work with it as normal Python objects in your program.",
        "technical": "Thin wrapper around Python's standard `json.loads()` function that accepts either string or bytes input. Decodes the JSON-formatted input parameter `s` and returns the corresponding Python object (dict, list, str, int, etc.). Passes through any additional keyword arguments directly to the underlying `json.loads()` call, allowing customization of parsing behavior (e.g., custom decoders, parse_float handlers)."
      },
      "load": {
        "human": "Reads JSON data from an open file and converts it into Python objects (like dictionaries, lists, etc.). This is a convenience function that handles the common task of loading structured data that was previously saved in JSON format. It's like opening a document and automatically understanding its contents.",
        "technical": "Wrapper method that reads entire file content via `fp.read()` and delegates JSON deserialization to `self.loads()`. Accepts file-like object with text or UTF-8 bytes, passes through any additional keyword arguments to the underlying JSON parser. Returns deserialized Python object (dict, list, str, int, etc.). Single-pass operation that loads full file content into memory before parsing."
      },
      "_prepare_response_obj": {
        "human": "This function prepares data that will be sent as a JSON response. It takes input that could be provided in two different ways (as a list of values or as named parameters) and converts it into a single, consistent format. It ensures the caller doesn't accidentally provide data in both ways at once, which would be confusing. If no data is provided, it returns nothing.",
        "technical": "Validates and normalizes arguments for a JSON response method by enforcing mutual exclusivity between positional args and kwargs (raises TypeError if both provided). Returns None for empty input, unwraps single-element tuples to return the bare value, or returns the non-empty collection (args tuple or kwargs dict). Performs input validation and data structure simplification to standardize the response payload format."
      },
      "response": {
        "human": "Converts Python data (like dictionaries, lists, or simple values) into a JSON-formatted web response that can be sent back to a user's browser or API client. It automatically makes the JSON output pretty and readable when the application is in debug mode, or compact to save space in production mode.",
        "technical": "Prepares response object via `_prepare_response_obj()`, then serializes it to JSON using `self.dumps()` with formatting controlled by `compact` attribute and app debug mode. When debug=True or compact=False, adds 2-space indentation; otherwise uses minimal separators. Returns Flask Response object with JSON string (plus trailing newline) and \"application/json\" mimetype. Handles both positional args (as list) and kwargs (as dict)."
      }
    },
    "src/flask/json/tag.py": {
      "__init__": {
        "human": "Sets up a new tag management system by creating two empty storage containers: one for looking up tags by name and another for keeping tags in order. Then automatically loads a set of pre-defined default tags into the system so they're ready to use right away.",
        "technical": "Initializes instance with two data structures: `self.tags` dict mapping string keys to JSONTag objects, and `self.order` list maintaining JSONTag sequence. Iterates through `self.default_tags` class attribute, calling `self.register(cls)` for each tag class to populate both structures. No return value; modifies instance state as side effect."
      },
      "check": {
        "human": "Verifies whether a given value is a special tagged dictionary used by a serialization system. It checks if the value is a single-entry dictionary where the key matches one of the known serialization tags. This acts as a validation gate to identify values that need special serialization handling.",
        "technical": "Performs three-condition validation: (1) checks if value is a dict using isinstance(), (2) verifies dict has exactly one key-value pair via len(), and (3) confirms the single key exists in self.serializer.tags by extracting it with next(iter(value)). Returns boolean True only when all conditions pass. Uses short-circuit evaluation for performance optimization."
      },
      "to_json": {
        "human": "Converts a dictionary-like object into a JSON-compatible format by processing its values. Since JSON requires all dictionary keys to be strings, this function leaves the keys unchanged but transforms each value through a tagging system. This prepares complex Python data structures to be safely saved or transmitted as JSON.",
        "technical": "Dictionary comprehension that iterates over key-value pairs using `value.items()`, preserving keys as-is while applying `self.serializer.tag(v)` to each value. Returns a new dictionary with tagged values. Part of a serialization system where the serializer adds type metadata to values for later deserialization. No side effects; pure transformation function."
      },
      "to_python": {
        "human": "Takes a dictionary-like object and transforms it by extracting its first key, removing the last two characters from that key, and creating a new dictionary with this shortened key and its corresponding value. This appears to convert some kind of encoded or suffixed key format into a cleaner format.",
        "technical": "Extracts the first key from the input value using `next(iter(value))`, slices off the last two characters from that key using `key[:-2]`, and returns a new dictionary mapping the truncated key to the original value associated with the full key. Assumes value is dict-like and iterable with at least one key-value pair. Returns a single-entry dictionary."
      },
      "tag": {
        "human": "Takes any value and checks if it needs special formatting or conversion. Goes through a list of possible conversion rules in order, and if the value matches a rule, it applies that conversion. If no special conversion is needed, the value is returned unchanged. This is useful for preparing data to be stored or transmitted in a specific format.",
        "technical": "Iterates through `self.order` (a collection of tag objects) and calls `tag.check(value)` on each to test if the value matches that tag's criteria. On first match, calls `tag.tag(value)` to transform the value and returns immediately. If no tag matches after iterating through all tags, returns the original value unmodified. Implements a chain-of-responsibility pattern for value transformation."
      },
      "register": {
        "human": "Adds a new type of data tag to a JSON serializer's registry so it can handle custom data types. You can choose whether to replace an existing tag with the same name or raise an error. You can also specify where in the processing order the new tag should be placed, which matters when multiple tags could handle the same data.",
        "technical": "Instantiates the provided tag_class with self as argument, extracts its key property, and registers it in self.tags dictionary. Raises KeyError if key already exists unless force=True. Adds tag instance to self.order list either via append() if index is None, or insert(index) to place it at a specific position in the tag processing sequence. Handles optional keys (skips registration if key is falsy)."
      },
      "untag": {
        "human": "This function takes data that has been specially marked or \"tagged\" with type information and converts it back to its original form. It checks if the data has exactly one tag marker, looks up whether that marker is recognized, and if so, transforms the tagged data back into the actual object type it represents. If the data doesn't match the expected tagged format or uses an unknown tag, it simply returns the data unchanged.",
        "technical": "Validates that the input dictionary contains exactly one key-value pair, extracts the key using `next(iter(value))`, and checks if it exists in `self.tags` registry. If the key is registered, calls the corresponding tag handler's `to_python()` method with the associated value to deserialize the tagged representation. Returns the original dictionary unchanged if it has multiple keys or if the single key is not a registered tag. Implements deserialization logic for a tagged value system."
      },
      "_untag_scan": {
        "human": "Removes special tags or markers from data structures by scanning through them. If the data is a dictionary or list, it looks inside each part and removes tags from those parts too, working its way from the innermost items outward. This cleaning process ensures all nested data gets properly untagged, not just the top level.",
        "technical": "Recursively traverses a data structure to remove tags using depth-first processing. For dictionaries, recursively calls `_untag_scan` on all values, then applies `self.untag()` to the dict itself. For lists, recursively processes each element. Returns the untagged value, with non-dict/list types passed through unchanged. Implements post-order traversal where children are processed before parents."
      },
      "dumps": {
        "human": "Converts a Python value into a compact JSON text string, but first applies special \"tagging\" to mark or transform the value in some way. This is useful when you need to save data as JSON text while preserving extra information about the data type or structure that regular JSON doesn't support.",
        "technical": "Calls `self.tag(value)` to transform/annotate the input value, then serializes the tagged result to JSON using `dumps()` with compact formatting (no whitespace: `separators=(\",\", \":\")`). Returns a string representation. The `tag` method likely adds metadata or type information before JSON serialization, and the external `dumps` function is presumably `json.dumps` from the standard library."
      },
      "loads": {
        "human": "Takes text that's formatted as JSON (a common data format) and converts it back into usable Python data. Additionally, it recognizes and processes any special \"tagged\" objects that were marked in a custom way, restoring them to their original form. This is useful when you need to save complex data structures and then load them back exactly as they were.",
        "technical": "Deserializes a JSON string into Python objects using the standard `loads()` function, then post-processes the result through `_untag_scan()` to convert custom tagged objects back to their original types. The function acts as a wrapper that adds custom deserialization logic on top of standard JSON parsing. Returns the fully deserialized Python object with all tagged objects restored."
      }
    },
    "src/flask/logging.py": {
      "wsgi_errors_stream": {
        "human": "Provides a smart error logging destination that adapts to the current situation. When the application is handling a web request, errors go to the web server's error stream. When no request is being processed (like during startup), errors go to the standard error output. This ensures error messages always reach the right place.",
        "technical": "Returns a TextIO stream for error logging by checking if a Flask request context exists. If `request` is truthy, extracts and returns `request.environ[\"wsgi.errors\"]` (the WSGI server's error stream). Otherwise, falls back to `sys.stderr`. Decorated with LocalProxy to make it context-aware. No side effects; purely returns the appropriate stream reference based on request context availability."
      },
      "has_level_handler": {
        "human": "Checks whether a logger is actually configured to output messages at its current logging level. This prevents situations where you think logging is enabled, but no handler is set up to actually capture and display those log messages. It walks up the logger hierarchy (parent loggers) to see if any handler along the chain will process the logs.",
        "technical": "Retrieves the logger's effective level via `getEffectiveLevel()`, then traverses the logger hierarchy from the given logger to its parents. At each level, checks if any handler has a level low enough (`handler.level <= level`) to process messages. Stops traversal if `propagate` is False. Returns True if a suitable handler is found anywhere in the chain, False otherwise. No side effects."
      },
      "create_logger": {
        "human": "Creates and sets up a logging system for a Flask web application so it can record messages about what's happening. If the app is in debug mode, it makes the logger more verbose to capture detailed information. If no output destination exists for the logs, it adds a default one that writes to the standard error stream so messages aren't lost.",
        "technical": "Retrieves or creates a logger instance using `logging.getLogger()` with the app's name. Conditionally sets logger level to `logging.DEBUG` if `app.debug` is True and no level is currently set. Checks via `has_level_handler()` if the logger has an appropriate handler for its effective level; if not, attaches `default_handler` (a pre-configured StreamHandler). Returns the configured logger instance with potential side effects of modifying logger state."
      }
    },
    "src/flask/sansio/app.py": {
      "_make_timedelta": {
        "human": "Converts time values into a standardized format for measuring durations. If you give it a number, it treats that number as seconds and converts it to a proper time duration object. If you already give it a time duration or nothing at all, it simply passes it through unchanged. This ensures the function always works with the same type of time measurement.",
        "technical": "Type converter that normalizes input to `timedelta` objects. Accepts `timedelta`, `int`, or `None` as input. Returns input unchanged if already `timedelta` or `None`. For integer values, wraps them in `timedelta(seconds=value)` constructor, treating the integer as seconds. Uses `isinstance()` for type checking. No side effects; pure transformation function."
      },
      "__init__": {
        "human": "Sets up a new web application instance by configuring all the essential components needed to run a Flask web server. It establishes where files are stored (templates, static files, instance data), how URLs are handled, and creates empty containers for features like blueprints and extensions that will be added later. Think of it as preparing a workspace with all the necessary folders and tools before starting to build a website.",
        "technical": "Initializes Flask application by calling parent constructor with import_name, static/template folders, and root_path. Validates and sets instance_path (must be absolute), creates config object via make_config(), initializes aborter and JSON provider instances. Sets up empty collections for url_build_error_handlers, teardown_appcontext_funcs, shell_context_processors, blueprints dict, and extensions dict. Creates url_map with host_matching parameter and sets subdomain_matching flag. Initializes _got_first_request tracking flag to False."
      },
      "_check_setup_finished": {
        "human": "This function acts as a safety guard that prevents you from changing the application's configuration after it has already started serving requests. It's like trying to change the rules of a game after it has already begun - the function stops you and explains that setup must be done before the application starts handling requests, otherwise changes won't work properly across all parts of the application.",
        "technical": "Validates that setup/configuration methods are not called after the application has processed its first request by checking the `_got_first_request` flag. Raises an `AssertionError` with a detailed message including the attempted setup method name (`f_name`) if called post-initialization. Acts as a guard clause to enforce that all application configuration (imports, decorators, route registrations) occurs during the setup phase before request handling begins."
      },
      "name": {
        "human": "Gets a user-friendly display name for the Flask application. When you run a Python script directly (instead of importing it as a module), it figures out the actual script filename to use as the name instead of showing the generic \"__main__\". This makes it easier to identify which application is running in logs and error messages.",
        "technical": "Returns the application's import name, with special handling for direct script execution. Checks if `import_name == \"__main__\"`, then retrieves the `__file__` attribute from `sys.modules[\"__main__\"]`. If found, extracts the base filename without extension using `os.path.basename()` and `os.path.splitext()[0]`. Falls back to returning `import_name` directly for normal module imports. Decorated with `@cached_property` for performance optimization."
      },
      "logger": {
        "human": "Provides access to a logging system that records messages and events from the application. This is like a journal that keeps track of what the app is doing, which is especially useful for debugging problems. The logger automatically adjusts its detail level based on whether the app is in debug mode and ensures there's always a way to output log messages.",
        "technical": "A cached property that lazily instantiates and returns a `logging.Logger` instance by delegating to `create_logger(self)`. The `@cached_property` decorator ensures the logger is created only once and reused on subsequent accesses. The actual logger configuration (naming, debug level setting, handler setup) is handled by the `create_logger()` function, not within this property method itself. Returns a standard Python Logger object."
      },
      "jinja_env": {
        "human": "Provides access to the template rendering system that converts template files into actual web pages. It sets up the environment once when first needed and keeps reusing it. Think of it as preparing a workspace for creating dynamic web content - once it's set up, it stays ready for use throughout the application's lifetime.",
        "technical": "Lazy-loaded property (via `@cached_property` decorator) that returns a Jinja2 Environment instance by delegating to `self.create_jinja_environment()`. The caching ensures the environment is instantiated only once on first access, with subsequent calls returning the cached instance. This prevents reconfiguration after initialization and optimizes performance by avoiding repeated environment creation."
      },
      "make_config": {
        "human": "Creates a configuration object for a Flask web application. It determines where to look for configuration files - either in the application's main folder or in a separate instance folder (useful for keeping sensitive settings separate). It also sets up some default settings, including whether the app should run in debug mode, which helps developers see detailed error messages.",
        "technical": "Instantiates a Config object with appropriate root_path based on instance_relative flag (uses self.instance_path if True, self.root_path if False). Copies self.default_config into a defaults dictionary, overrides the DEBUG key with value from get_debug_flag(), then passes root_path and defaults to self.config_class constructor. Returns the configured Config instance for use by Flask application."
      },
      "make_aborter": {
        "human": "Creates a helper object that handles error responses when something goes wrong in a web application. This object is responsible for generating proper HTTP error pages (like \"404 Not Found\" or \"500 Server Error\") when the application needs to stop processing and show an error to the user.",
        "technical": "Factory method that instantiates and returns an Aborter object by calling `self.aborter_class()`. The aborter_class attribute defaults to `werkzeug.exceptions.Aborter`. Returns an Aborter instance used by Flask's abort() function to raise HTTP exceptions. No parameters required; simply invokes the constructor of the configured aborter class."
      },
      "auto_find_instance_path": {
        "human": "Automatically figures out where to store application-specific data files when the user hasn't specified a location. It looks for a folder called \"instance\" near your application's main file. If your app is installed as a package, it creates a dedicated folder in a standard system location instead. This gives your application a safe place to store configuration files, databases, or other data that shouldn't be in the main code folder.",
        "technical": "Calls `find_package()` with `self.import_name` to determine if the application is a package or standalone module, returning a tuple of (prefix, package_path). If prefix is None (not an installed package), returns path joining package_path with \"instance\" subdirectory. Otherwise, constructs path using prefix joined with \"var\" and \"{app_name}-instance\" for system-wide installations. Returns string path without creating directories or checking existence."
      },
      "create_global_jinja_loader": {
        "human": "Creates a centralized template loader that knows how to find and load HTML/template files from different parts of a web application. This allows the application to organize templates in multiple locations (main app and plugins/blueprints) while having one unified system to access them all. It's the foundation piece that makes the template rendering system work across the entire application.",
        "technical": "Instantiates and returns a DispatchingJinjaLoader object, passing `self` (the Flask application instance) as the constructor argument. The DispatchingJinjaLoader acts as a routing mechanism that delegates template loading requests to appropriate loaders registered for the main application and individual blueprints. This is a factory method that provides the root loader for Flask's Jinja2 templating environment."
      },
      "select_jinja_autoescape": {
        "human": "Determines whether a web template file should automatically protect against security vulnerabilities by escaping special characters. When given a filename, it checks if the file is a web page or markup document (like HTML or XML files). If it is, the function enables automatic security protections; otherwise, it leaves the content as-is. This helps prevent malicious code injection attacks on websites.",
        "technical": "Checks if a given filename has a web markup extension (.html, .htm, .xml, .xhtml, .svg) using string.endswith() method with a tuple of extensions. Returns True if the filename matches any of these extensions or if filename is None, otherwise returns False. Used by Jinja2 templating engine to determine whether to enable HTML autoescaping for XSS protection. No side effects; pure boolean decision function."
      },
      "debug": {
        "human": "This function turns debug mode on or off for a web application. When you enable debug mode, it helps developers see errors and problems more clearly. It also automatically makes the application reload template files when they change, so developers can see their updates immediately without restarting the server.",
        "technical": "Property setter that updates the application's DEBUG configuration flag. Sets `self.config[\"DEBUG\"]` to the provided boolean value. Conditionally enables Jinja2 template auto-reloading (`self.jinja_env.auto_reload`) to match the debug state, but only if `TEMPLATES_AUTO_RELOAD` hasn't been explicitly configured (is None). This creates a default behavior where debug mode controls template reloading unless overridden."
      },
      "register_blueprint": {
        "human": "Adds a blueprint (a modular component containing routes and views) to the Flask application, making its functionality available. This allows developers to organize their web application into separate, reusable pieces that can be plugged into the main app. You can customize how the blueprint integrates by providing options like URL prefixes or subdomains.",
        "technical": "Delegates blueprint registration to the blueprint's own `register()` method, passing the application instance (`self`) and any keyword arguments as options. The function acts as a thin wrapper that provides the setupmethod decorator behavior. The actual registration logic (recording in `self.blueprints`, processing url_prefix, subdomain, etc.) is handled by `blueprint.register()`, not in this function's code body."
      },
      "iter_blueprints": {
        "human": "Provides a way to look through all the blueprints (modular components) that have been added to the application. Returns them in the same order they were originally registered, allowing you to see or work with each blueprint one at a time. This is useful when you need to inspect or process all the application's components sequentially.",
        "technical": "Returns a ValuesView containing all Blueprint objects stored in the `self.blueprints` dictionary. Calls the `.values()` method on the blueprints dictionary to retrieve only the Blueprint instances (not the keys). The ValuesView maintains insertion order (Python 3.7+) and provides a memory-efficient iterator over the blueprint collection without copying the data. No filtering, transformation, or side effects occur."
      },
      "add_url_rule": {
        "human": "Registers a URL route in a web application, connecting a web address (like \"/home\") to the function that should handle requests to that address. It figures out which HTTP methods (GET, POST, etc.) are allowed, automatically adds OPTIONS support if needed, and ensures that each endpoint name is unique so there are no conflicts between different routes.",
        "technical": "Registers URL routing rules by creating a url_rule_class instance with normalized HTTP methods (converted to uppercase set), merging required_methods from view_func attributes. Determines endpoint name via _endpoint_from_view_func if not provided. Conditionally enables automatic OPTIONS handling based on view_func attributes or config. Adds rule_obj to url_map and stores view_func in view_functions dict after validating no endpoint collision exists. Raises TypeError for string methods or AssertionError for duplicate endpoints."
      },
      "template_filter": {
        "human": "This function allows developers to register custom filters that can be used in Jinja templates (the templating system used in Flask web applications). It works as a decorator that can be applied to functions, either with or without specifying a custom name. If no name is provided, it uses the function's own name. This makes it easy to add custom text processing or formatting capabilities to templates.",
        "technical": "Implements a flexible decorator pattern that handles two usage modes: direct decoration (when `name` is callable) and parameterized decoration (when `name` is a string or None). In direct mode, immediately calls `self.add_template_filter(name)` and returns the function. In parameterized mode, returns a decorator closure that calls `self.add_template_filter(f, name=name)`. Both paths preserve the original function and delegate actual registration to `add_template_filter()`. Marked with `@setupmethod` decorator for Flask's setup-time validation."
      },
      "add_template_filter": {
        "human": "Registers a custom function so it can be used as a filter inside Jinja templates (the templating system used for generating HTML pages). This allows developers to add their own text transformation or formatting functions that can be applied directly in templates. If no custom name is provided, it uses the function's original name as the filter name.",
        "technical": "Adds a callable function to the Jinja environment's filters dictionary (`self.jinja_env.filters`). Uses the provided `name` parameter as the dictionary key, falling back to `f.__name__` if name is None. The function `f` is stored as-is without wrapping or modification. Modifies application state by mutating the shared Jinja environment's filter registry. Marked with `@setupmethod` decorator indicating it should be called during application setup phase."
      },
      "template_test": {
        "human": "This function allows developers to register custom test functions that can be used in Jinja templates (the templating engine). It works as a decorator that you place above a function to make it available for testing conditions in templates. You can optionally give the test a custom name, or it will use the function's own name. It's flexible enough to be used with or without parentheses when decorating.",
        "technical": "Implements a decorator pattern with dual-mode operation: accepts either a callable directly (no-parentheses usage) or returns a decorator function (with-parentheses usage). When a callable is passed directly, immediately calls `self.add_template_test(name)` and returns the function. Otherwise, returns an inner `decorator` function that captures the optional `name` parameter and calls `self.add_template_test(f, name=name)`. Uses `callable()` check to distinguish between the two invocation modes. Returns the original function unmodified to allow decorator chaining."
      },
      "add_template_test": {
        "human": "Allows you to add custom test functions to your Jinja templates. For example, if you want to check if a value \"is_premium\" or \"is_valid\" in your templates, this function registers your custom checking logic under a specific name. If you don't provide a name, it uses the function's own name automatically.",
        "technical": "Registers a callable function as a custom Jinja2 test by adding it to the `self.jinja_env.tests` dictionary. Takes a function `f` and optional `name` parameter, using `name or f.__name__` as the dictionary key. Directly modifies the Jinja environment's test registry, enabling the test to be used in template expressions with the `is` operator (e.g., `{% if value is custom_test %}`)."
      },
      "template_global": {
        "human": "This function allows developers to register custom functions that can be used directly in HTML templates (Jinja templates). It works as a decorator that you place above a function to make it available globally in all templates. You can use it with or without specifying a custom name - if no name is given, it uses the function's original name.",
        "technical": "Implements a flexible decorator pattern that handles two invocation styles: direct decoration (`@app.template_global`) when `name` is callable, or parameterized decoration (`@app.template_global()` or `@app.template_global(\"custom_name\")`) when `name` is a string or None. Delegates actual registration to `self.add_template_global()` method. Returns either the original function (preserving it unchanged) or a decorator function that performs registration and returns the function, enabling method chaining."
      },
      "add_template_global": {
        "human": "This function allows you to add custom functions to your Jinja templates so they can be called from anywhere in your HTML/template files. It's like creating a helper function that becomes available globally across all your templates. You can optionally give it a custom name, otherwise it uses the function's original name. This is useful when you want to reuse the same logic across multiple templates.",
        "technical": "Registers a callable function into the Jinja environment's global namespace by adding it to `self.jinja_env.globals` dictionary. Uses the provided `name` parameter as the key, falling back to `f.__name__` if name is None. The function is marked with `@setupmethod` decorator, indicating it should be called during application setup phase. Creates a direct reference to the function object, making it accessible in all Jinja template contexts without requiring import or context injection."
      },
      "teardown_appcontext": {
        "human": "This function allows you to register cleanup tasks that should run when your application finishes processing a request or command. It's like setting up a \"before closing\" routine - for example, closing database connections or saving files. You provide a function, and the system remembers to call it automatically at the right time during shutdown.",
        "technical": "A decorator function that registers teardown callbacks by appending the provided function `f` to the `self.teardown_appcontext_funcs` list. Returns the original function unmodified, enabling use as a decorator. The registered function will be invoked with an optional error parameter when the application context is popped. Marked with `@setupmethod` decorator to indicate it's a configuration method."
      },
      "shell_context_processor": {
        "human": "This function allows developers to register custom functions that will make additional variables or objects available in the interactive shell environment. It's like adding shortcuts or tools that will be automatically available whenever someone opens the application's shell for debugging or testing, making it easier to work with the application interactively.",
        "technical": "Decorator method that registers a shell context processor function by appending it to the `self.shell_context_processors` list. Takes a callable `f` as input, adds it to the processors collection, and returns the same function unmodified, enabling use as a decorator. The registered functions will later be invoked to populate the shell namespace with custom objects/variables when the shell is initialized."
      },
      "_find_error_handler": {
        "human": "Searches through registered error handlers to find the best match for handling an exception that just occurred. It looks in a specific priority order: first checking blueprint-specific handlers, then app-wide handlers, trying exact error codes before falling back to general exception types. Returns the most appropriate handler function to deal with the error, or nothing if no suitable handler exists.",
        "technical": "Extracts exception class and HTTP code via `_get_exc_class_and_code()`, then iterates through blueprints list plus None (app-level). For each code (specific then None fallback), searches `error_handler_spec` dictionary using exception's MRO (Method Resolution Order) to find handlers for parent classes. Returns first matching `ft.ErrorHandlerCallable` or None. Priority: blueprint+code \u2192 app+code \u2192 blueprint+class \u2192 app+class."
      },
      "trap_http_exception": {
        "human": "Determines whether HTTP errors should be shown as full debugging exceptions with tracebacks instead of being handled by custom error handlers. This helps developers see exactly where and why HTTP errors occur during development. The function checks configuration settings to decide if errors like \"bad request\" should display detailed debugging information or be handled normally.",
        "technical": "Returns boolean indicating if HTTP exception should bypass error handlers. First checks `TRAP_HTTP_EXCEPTIONS` config (returns True if set). Then evaluates `TRAP_BAD_REQUEST_ERRORS` config: if None and in debug mode, traps `BadRequestKeyError` instances; if True, traps all `BadRequest` instances using `isinstance()` checks. Returns False by default to allow normal error handler processing."
      },
      "should_ignore_error": {
        "human": "This function decides whether an error that occurs during program cleanup should be hidden from the cleanup handlers. Currently, it's set up to never ignore any errors - all errors will be passed to the cleanup system. This acts as a filter that could be customized in subclasses to skip certain types of errors during teardown.",
        "technical": "Instance method that takes a BaseException or None as input and returns a boolean indicating whether the teardown system should ignore the error. The current implementation unconditionally returns False, meaning all errors are propagated to teardown handlers. This is a hook method designed to be overridden in subclasses to implement custom error filtering logic based on error type or other criteria."
      },
      "redirect": {
        "human": "Creates a web response that automatically sends visitors to a different web page. When someone tries to access one URL, this function generates the instructions needed to redirect their browser to another URL. It's like putting up a sign that says \"this page has moved to a new address\" and automatically taking visitors there.",
        "technical": "Delegates to Werkzeug's `_wz_redirect` function to create an HTTP redirect response. Passes the target location URL, HTTP status code (defaults to 302 for temporary redirect), and the application's custom response class. Returns a BaseResponse object configured with appropriate redirect headers. Acts as a thin wrapper that integrates Werkzeug's redirect functionality with Flask's response class system."
      },
      "inject_url_defaults": {
        "human": "This function fills in default values for URL parameters when building web links. For example, if your website always needs a language code in URLs, this ensures it gets added automatically even if you forget to specify it. It works hierarchically, applying defaults from the main application first, then from any nested blueprint sections in the URL path.",
        "technical": "Modifies the `values` dictionary in-place by calling registered URL default functions. Parses the endpoint string to extract blueprint hierarchy using `rpartition(\".\")` and `_split_blueprint_path`, then iterates through blueprint names in reverse order (from outermost to innermost). For each blueprint level (including None for app-level), executes all registered default functions from `self.url_default_functions[name]`, passing endpoint and values to each function for mutation."
      },
      "handle_url_build_error": {
        "human": "When the system fails to build a URL (like when creating a link to a page), this function gives registered error handlers a chance to fix the problem or provide an alternative URL. It tries each handler in order until one successfully returns a valid URL. If no handler can fix the issue, it reports the original error back to the user.",
        "technical": "Iterates through registered handlers in `self.url_build_error_handlers`, calling each with the BuildError, endpoint, and values dict. Catches and updates BuildError exceptions to continue iteration, returns immediately on first non-None handler result. Uses `sys.exc_info()[1]` to check if the error is currently active in the exception context, then either re-raises the active exception or explicitly raises the stored error object."
      },
      "decorator": {
        "human": "This is a helper function that registers another function to be available in all templates. When you use this as a decorator (with the @ symbol), it marks a function so it can be called from within any template file, making it globally accessible across your template system.",
        "technical": "A decorator function that registers the wrapped function `f` as a template global by calling `self.add_template_global(f, name=name)`. Takes a function of type `T_template_global` as input, performs the registration side effect, and returns the original function unmodified, allowing it to be used both as a decorator and preserving the original function reference."
      }
    },
    "src/flask/sansio/blueprints.py": {
      "__init__": {
        "human": "Sets up a new blueprint (a modular component) for a web application. It validates that the blueprint has a proper name (not empty and without dots), then stores configuration like URL paths, subdomains, and template locations. This allows developers to organize their web application into reusable, self-contained sections that can be plugged into the main application.",
        "technical": "Initializes a Blueprint object by calling parent class constructor with static/template folder paths and import settings. Validates name parameter is non-empty and contains no dots, raising ValueError otherwise. Sets instance attributes for name, url_prefix, subdomain, url_defaults (defaulting to empty dict), cli_group, and initializes empty lists for deferred_functions and _blueprints to track nested blueprints and delayed setup operations."
      },
      "add_url_rule": {
        "human": "This function allows you to register a web page URL with a blueprint in a Flask web application. It's like adding a new route or address that users can visit in your website. The function ensures that the names you use don't contain dots (which would cause conflicts), and it queues up the URL registration to happen later when the blueprint is actually attached to the main application.",
        "technical": "Validates that neither `endpoint` nor `view_func.__name__` contain dot characters (raises ValueError if found). Uses `self.record()` to defer the actual URL rule registration via a lambda that calls `s.add_url_rule()` with all provided parameters. This deferred execution pattern allows blueprints to register routes before being attached to a Flask app instance. The `@setupmethod` decorator indicates this modifies blueprint configuration during setup phase."
      },
      "_check_setup_finished": {
        "human": "This function acts as a safety guard that prevents you from making changes to a blueprint after it has already been put into use. It's like trying to modify a building's blueprint after construction has started - the function stops you and explains that any changes won't be applied properly because the blueprint is already in use. It ensures all setup work must be completed before the blueprint is registered.",
        "technical": "Validates that setup methods cannot be called after a blueprint has been registered by checking the `_got_registered_once` flag. Raises an `AssertionError` with a detailed message including the setup method name (`f_name`) and blueprint name (`self.name`) if the flag is True. Acts as a guard clause for blueprint configuration methods to enforce setup-before-registration ordering and prevent inconsistent state."
      },
      "record": {
        "human": "Saves a function to be executed later when a blueprint gets connected to the main application. Think of it like adding an item to a to-do list - the function isn't run immediately, but is stored away to be called at the right moment during the blueprint setup process.",
        "technical": "Appends a DeferredSetupFunction to the self.deferred_functions list for delayed execution. The function is stored but not invoked; actual execution occurs during blueprint registration when make_setup_state provides the state argument. Uses simple list append operation with no return value. Decorated with @setupmethod to mark it as a blueprint configuration method."
      },
      "record_once": {
        "human": "Registers a setup function with a blueprint that should only run the first time the blueprint is added to an application. If you try to register the same blueprint multiple times, this ensures the setup function only executes once during the initial registration, preventing duplicate setup operations.",
        "technical": "Creates a wrapper function that checks `state.first_registration` before executing the provided `func`. Uses `update_wrapper` to preserve the original function's metadata, then passes the wrapper to `self.record()` for registration. The wrapper receives a `BlueprintSetupState` object and conditionally invokes `func(state)` only on first registration, effectively implementing idempotent blueprint setup."
      },
      "make_setup_state": {
        "human": "Creates a configuration package that holds all the settings and information needed when registering a blueprint (a modular component) with a Flask web application. This package bundles together the blueprint, the app, user options, and whether this is the first time the blueprint is being registered, making it easy to pass this information to setup functions.",
        "technical": "Factory method that instantiates and returns a BlueprintSetupState object by passing four parameters: self (the blueprint instance), the Flask app instance, a dictionary of registration options, and a boolean flag indicating first registration. Acts as a customization point where subclasses can override to return specialized setup state objects. No side effects; pure object construction and return."
      },
      "register_blueprint": {
        "human": "Allows you to nest one blueprint inside another blueprint in a Flask web application. This is like organizing your website's pages into folders within folders - you can group related features together hierarchically. It prevents you from accidentally registering a blueprint to itself (which would cause problems) and remembers any custom settings you want to apply.",
        "technical": "Validates that the blueprint being registered is not self-referential (raises ValueError if so), then appends a tuple of (blueprint, options) to the internal _blueprints list. The options dict allows overriding blueprint defaults. This creates a parent-child blueprint relationship that will be processed during app registration. The @setupmethod decorator indicates this must be called during setup phase before the app runs."
      },
      "register": {
        "human": "Registers a blueprint (a modular component) with a Flask web application, making all its routes, views, and commands available to the app. It handles naming conflicts, merges the blueprint's functionality into the main app, sets up static file serving, and recursively registers any nested blueprints. This allows developers to organize large applications into reusable, self-contained modules.",
        "technical": "Validates blueprint name uniqueness, creates BlueprintSetupState, and registers the blueprint in app.blueprints dict. Adds static file route if needed, merges blueprint functions via _merge_blueprint_funcs(), executes deferred callbacks, and integrates CLI commands. For nested blueprints, recursively calls register() while propagating and combining url_prefix and subdomain options from parent to child. Raises ValueError on duplicate registration attempts."
      },
      "_merge_blueprint_funcs": {
        "human": "This function merges a blueprint's registered functions and handlers into the main application. When you create a blueprint (a modular component) in Flask with its own routes and handlers, this function copies all those pieces into the main app so they actually work. It ensures the blueprint's functionality becomes part of the complete application, prefixing blueprint names to keep everything organized.",
        "technical": "Merges blueprint-registered callbacks and handlers into the parent Flask app's dictionaries. Copies error_handler_spec with nested defaultdict structure, preserving exception class mappings. Directly assigns view_functions by endpoint. Uses internal extend() helper to merge before_request_funcs, after_request_funcs, teardown_request_funcs, url_default_functions, url_value_preprocessors, and template_context_processors, prefixing keys with blueprint name to maintain namespace separation. Modifies app dictionaries in-place with no return value."
      },
      "app_template_filter": {
        "human": "This function allows developers to create custom filters for Jinja templates (the templating system used in Flask web applications). It can be used as a decorator on a function to automatically register that function as a filter that can be used in HTML templates throughout the entire application. The decorator is flexible - you can use it with or without parentheses, and optionally specify a custom name for the filter.",
        "technical": "Implements a flexible decorator pattern that handles two usage modes: direct decoration (when a callable is passed) or parameterized decoration (when a name string or None is passed). In direct mode, immediately calls `self.add_app_template_filter(name)` and returns the function. In parameterized mode, returns a decorator closure that calls `self.add_app_template_filter(f, name=name)` with the wrapped function. Uses `callable()` check to distinguish between the two invocation patterns."
      },
      "add_app_template_filter": {
        "human": "Registers a custom filter function that can be used in Jinja templates throughout the entire Flask application. This allows developers to add their own data formatting or transformation functions (like custom date formats or text manipulations) that can be called directly within HTML templates. The filter becomes available globally across all templates, not just those in the current blueprint.",
        "technical": "Creates a deferred registration callback `register_template_filter` that wraps `state.app.add_template_filter(f, name=name)` and schedules it via `self.record_once()`. This ensures the filter registration happens once during blueprint setup rather than immediately. Uses the setupmethod decorator to validate it's called during configuration phase. The deferred execution pattern allows blueprint-level registration to propagate to the Flask app instance when the blueprint is registered."
      },
      "app_template_test": {
        "human": "This function allows developers to register custom test functions that can be used in Jinja templates (the templating system used by Flask web applications). It works as a decorator that you can apply to any function, making that function available as a test in all templates across the entire application. You can optionally specify a custom name for the test, or it will use the function's original name.",
        "technical": "Implements a flexible decorator pattern that handles both `@app_template_test` and `@app_template_test(name=\"custom\")` syntax by checking if the first argument is callable. If called without parentheses (name is callable), directly registers the function via `self.add_app_template_test()` and returns it. Otherwise, returns a decorator closure that captures the name parameter and registers the function when applied. Returns either the original function or a decorator callable depending on invocation style."
      },
      "add_app_template_test": {
        "human": "Registers a custom test function that can be used in Jinja templates throughout the entire application. This allows developers to add their own conditional checks (like \"is_even\" or \"is_valid_email\") that can be used in template files to control what content gets displayed. The test becomes available globally across all templates, not just in one specific section of the app.",
        "technical": "Creates a deferred registration callback that wraps the provided test function `f` and schedules it for execution when the blueprint is registered with the Flask app. Uses `self.record_once()` to ensure the inner `register_template_test` function runs exactly once during blueprint setup, which then calls `state.app.add_template_test()` to register the test globally on the Flask application instance. The `name` parameter defaults to the function's `__name__` if not provided."
      },
      "app_template_global": {
        "human": "This function allows developers to make their custom Python functions available inside HTML templates (using Jinja). It works as a decorator that you can attach to any function, making that function callable from any template in the entire application. You can optionally specify a custom name for how the function appears in templates, or it will use the function's original name.",
        "technical": "Implements a flexible decorator pattern that accepts either a callable directly or returns a decorator function. When called with a function (detected via `callable(name)`), it immediately registers it via `self.add_app_template_global(name)`. When called with a string or None, it returns a decorator closure that captures the name parameter and registers the decorated function with `self.add_app_template_global(f, name=name)`. Returns the original function unmodified to allow decorator chaining."
      },
      "add_app_template_global": {
        "human": "Allows you to add a custom function that can be used inside any HTML template in your web application. This is useful when you want to make a specific calculation or data transformation available to all your web pages. The function becomes globally accessible across the entire application, not just within a specific section (blueprint).",
        "technical": "Defers registration of a Jinja2 template global function until blueprint setup by creating a closure `register_template_global` that calls `state.app.add_template_global(f, name=name)`. Uses `self.record_once()` to ensure the registration callback executes exactly once during blueprint registration with the Flask app. The `name` parameter defaults to the function's `__name__` if not provided (handled by the underlying Flask method)."
      },
      "before_app_request": {
        "human": "Registers a function to run automatically before every single request that comes to the entire web application, not just requests handled by this specific blueprint. This is useful when you need to perform setup tasks (like checking user authentication or logging) that should happen for all requests across the whole application, regardless of which part handles them.",
        "technical": "Decorator that registers a before-request handler at the Flask application level rather than blueprint level. Uses `record_once()` to defer registration until blueprint is registered with app, then adds the function `f` to `app.before_request_funcs[None]` (the None key indicates app-wide handlers). Returns the original function unmodified, allowing decorator chaining. The lambda ensures the handler is added to the global before_request list only once during blueprint registration."
      },
      "after_app_request": {
        "human": "Registers a function that will run after every single request to the entire web application, not just requests handled by this specific blueprint. This is useful when you need to perform cleanup tasks or modify responses globally across the whole application, like adding security headers or logging information that should apply everywhere.",
        "technical": "Decorator that registers a callback function to Flask's global after_request_funcs dictionary with None as the key (indicating app-wide scope). Uses record_once() to defer registration until blueprint is registered with the app, then appends the callback to the app's after-request handler list via setdefault(None, []).append(f). Returns the original function unmodified to support decorator syntax."
      },
      "teardown_app_request": {
        "human": "Registers a cleanup function that runs after every request to the entire Flask application, not just requests handled by this specific blueprint. This is useful when you need to perform cleanup tasks (like closing database connections or clearing temporary data) that should happen application-wide, regardless of which part of the app handled the request.",
        "technical": "Decorator that registers a teardown function to Flask's global teardown_request_funcs dictionary with None as the key (indicating app-level scope). Uses self.record_once() to ensure the registration lambda executes only once during blueprint registration. The lambda retrieves/creates the teardown list via setdefault(None, []) and appends the decorated function f. Returns the original function unmodified, allowing decorator chaining."
      },
      "app_context_processor": {
        "human": "Registers a function that adds extra variables to all templates across the entire application, not just within a specific section (blueprint). This is useful when you want certain data (like user info, site settings, or utility functions) to be automatically available in every template without having to pass it manually each time.",
        "technical": "Decorator that registers a template context processor function at the application level by recording a deferred operation via `record_once()`. Uses a lambda to append the function `f` to `app.template_context_processors[None]` (where `None` key indicates app-level, not blueprint-specific). Returns the original function unmodified, allowing decorator usage. The `setdefault(None, [])` ensures the list exists before appending."
      },
      "app_errorhandler": {
        "human": "This function allows you to register a custom error handler that will catch errors across your entire web application, not just within a specific section (blueprint). When an error occurs anywhere in the app, your custom handler will be called to deal with it. It's like setting up a safety net that covers the whole application instead of just one part.",
        "technical": "Returns a decorator that registers an error handler at the Flask application level rather than blueprint level. Uses `self.record_once()` to defer registration until blueprint setup, at which point it calls `state.app.errorhandler(code)(f)` to register the handler function `f` with the parent Flask app. The decorator pattern preserves the original function while adding registration side effects during blueprint initialization."
      },
      "app_url_value_preprocessor": {
        "human": "Registers a function that will process URL parameters for every incoming request across the entire application, not just requests handled by this specific blueprint. This allows you to modify or validate URL values (like converting IDs or checking permissions) globally before any route handler runs. It's a way to set up application-wide preprocessing of URL data.",
        "technical": "Decorator that registers a URL value preprocessor function at the Flask application level (not blueprint level) by calling `self.record_once()` with a lambda that appends the function `f` to `app.url_value_preprocessors[None]`. Uses `setdefault(None, [])` to ensure the list exists before appending. Returns the original function unmodified, allowing decorator chaining. The `@setupmethod` decorator ensures proper registration timing during blueprint setup."
      },
      "app_url_defaults": {
        "human": "Registers a function that will automatically add default values to URLs throughout the entire application, not just within a specific section (blueprint). This is useful when you want certain URL parameters to be automatically included everywhere in your web application, like a language preference or theme setting that should appear in all links.",
        "technical": "Decorator that registers a URL defaults function at the application level by calling `self.record_once()` with a lambda that appends the function `f` to `app.url_default_functions[None]`. Uses `setdefault(None, [])` to initialize an empty list if the key doesn't exist. Returns the original function unmodified, allowing it to be used as a decorator. The `record_once` ensures registration happens only once during blueprint registration."
      },
      "wrapper": {
        "human": "This function acts as a gatekeeper that runs another function only during the first time a blueprint is being registered. It checks if this is the initial setup, and if so, allows the wrapped function to execute. This prevents certain setup operations from running multiple times when they should only happen once.",
        "technical": "Conditional wrapper that executes `func(state)` only when `state.first_registration` evaluates to True. Takes a `BlueprintSetupState` object as input, checks its `first_registration` boolean attribute, and delegates to the wrapped function `func` with the same state parameter. Returns None. Implements a one-time execution pattern for blueprint initialization logic."
      },
      "extend": {
        "human": "Merges lists of items from a blueprint dictionary into a parent dictionary, organizing them by key names. When copying items, it creates hierarchical names by combining a parent name with each key (like \"parent.child\"). This helps organize configuration or registration data from child components into a parent structure while maintaining proper naming.",
        "technical": "Iterates through bp_dict items and extends corresponding lists in parent_dict. Transforms keys by prefixing with a `name` variable (from outer scope): None keys become `name`, other keys become `name.key`. Uses list.extend() to append all values from bp_dict[key] to parent_dict[transformed_key]. Modifies parent_dict in-place (returns None). Assumes parent_dict keys already exist with list values."
      },
      "decorator": {
        "human": "This function registers an error handler for a web application blueprint. When an error occurs in the application (like a 404 or 500 error), this decorator ensures that a specific function will be called to handle that error. It's like setting up a safety net that catches errors and decides how to respond to them, but it waits until the blueprint is actually connected to the main application before activating.",
        "technical": "A decorator that defers error handler registration until blueprint setup. Creates a `from_blueprint` callback that registers the wrapped function `f` as an error handler for a specific error `code` via `state.app.errorhandler(code)(f)`. Uses `self.record_once()` to ensure the registration callback executes only once during blueprint registration. Returns the original function `f` unmodified, making it a transparent decorator that only adds side effects."
      }
    },
    "src/flask/sansio/scaffold.py": {
      "setupmethod": {
        "human": "This is a decorator that protects certain methods from being called after a setup phase has completed. It acts like a safety lock that prevents you from making configuration changes once the system has already been initialized and is running. When someone tries to call a protected method too late, it will check if setup is still allowed and either proceed or raise an error.",
        "technical": "A decorator function that wraps methods with a setup validation check. Creates a wrapper that calls `self._check_setup_finished(f_name)` before executing the original function `f`. Uses `update_wrapper` to preserve the original function's metadata (name, docstring, etc.) and `t.cast(F, ...)` to maintain type hints. Returns the wrapped function with the same signature as the input, enabling it to be used as a method decorator on Scaffold classes."
      },
      "_endpoint_from_view_func": {
        "human": "Takes a function that handles web requests and generates a simple name for it that can be used to identify or reference that function later. If no function is provided, it stops and reports an error. The name it creates is just the original function's name, making it easy to track which function handles which web address.",
        "technical": "Extracts the `__name__` attribute from a callable view function to use as a default endpoint identifier. Performs assertion check to ensure `view_func` is not None before accessing its name attribute. Returns a string containing the function's name. Used internally for routing systems where endpoint names need to be automatically derived from view function names when not explicitly provided."
      },
      "_find_package_path": {
        "human": "Finds the folder on your computer that contains a Python package or module you want to use. When you give it a package name (like \"flask.app\"), it figures out where those files are stored on your hard drive. If it can't find the package, it just returns your current working folder as a fallback.",
        "technical": "Extracts root module name via partition(), uses importlib.util.find_spec() to locate module spec, then returns appropriate directory path based on module type. Handles three cases: namespace packages (uses commonpath() and is_relative_to() to find correct search location), regular packages with __init__.py (returns parent of origin directory), and standalone modules (returns origin directory). Falls back to os.getcwd() on ImportError/ValueError."
      },
      "find_package": {
        "human": "Figures out where a Python package is physically installed on your computer and which folder Python uses to import it from. It checks if the package is installed in the main Python installation, in a virtual environment's site-packages folder, or just being run from the current directory. This helps applications understand their installation context and locate their files correctly.",
        "technical": "Calls `_find_package_path()` to get the package location, then uses `pathlib.PurePath.is_relative_to()` to check if it's under `sys.prefix`. If not, parses the path with `os.path.split()` to detect \"site-packages\" folders and traverses parent directories to identify virtualenv prefixes on Windows (prefix/lib/site-packages) vs Unix (prefix/lib/pythonX.Y/site-packages) layouts. Returns tuple of (installation_prefix, package_path) where prefix is None if package isn't in a standard installation location."
      },
      "wrapper_func": {
        "human": "This is a safety wrapper that checks if initial setup is complete before allowing a function to run. It acts like a gatekeeper, making sure the system is properly configured before executing the requested operation. If setup isn't finished, it prevents the function from running to avoid errors or inconsistent behavior.",
        "technical": "Decorator wrapper function that intercepts method calls on Scaffold instances. Invokes `_check_setup_finished()` with the wrapped function's name to validate setup state before execution. Forwards all positional and keyword arguments to the original function `f` and returns its result unchanged. Provides runtime validation to enforce setup ordering constraints."
      },
      "__init__": {
        "human": "Sets up the foundation for a web application or blueprint by organizing where files are stored and creating empty containers for different types of functions. It establishes the basic structure needed to handle web requests, including where to find templates and static files, and prepares places to store functions that will run before, during, and after handling web requests.",
        "technical": "Initializes a Flask-like scaffold object by storing import_name, computing root_path via get_root_path(), and setting static/template folder paths. Creates seven internal data structures: view_functions dict for route handlers, error_handler_spec nested dict for exception handlers, and five defaultdict(list) structures for request lifecycle hooks (before_request, after_request, teardown_request, url_value_preprocessors, url_default_functions) plus template_context_processors initialized with a default processor. All structures use scope-based keys for blueprint/app-level registration."
      },
      "static_folder": {
        "human": "This function sets the location of the folder where static files (like images, CSS, or JavaScript files) are stored for a web application. It cleans up the folder path by removing any trailing slashes to ensure consistency. If no folder is specified (None), it simply stores that empty value.",
        "technical": "A setter method that normalizes and stores a static folder path. Converts the input to a filesystem path string using `os.fspath()`, strips trailing forward/backward slashes with `rstrip(r\"\\/\")`, and assigns the result to the private attribute `self._static_folder`. Handles None values by bypassing normalization. No return value; modifies instance state only."
      },
      "has_static_folder": {
        "human": "Checks whether the application has a designated folder for storing static files (like images, CSS, or JavaScript files). This is useful for determining if the application is configured to serve static content to users. Returns a simple yes/no answer based on whether a static folder location has been set up.",
        "technical": "Property method that performs a null check on the `self.static_folder` attribute. Returns `True` if `static_folder` has been assigned a value (any truthy value including a path string), or `False` if it remains `None`. No function calls or complex operations\u2014simply evaluates the truthiness of the attribute through comparison with `None`."
      },
      "static_url_path": {
        "human": "This function sets the URL path where static files (like images, CSS, or JavaScript) can be accessed on a website. It cleans up the path by removing any trailing slashes to ensure consistency. If no path is provided, it simply stores that \"no path\" setting. This helps maintain a standardized way to reference static resources across the application.",
        "technical": "Property setter method that assigns a static URL path value to the instance variable `_static_url_path`. Performs string normalization by calling `rstrip(\"/\")` to remove trailing slashes from non-None values before storage. Accepts `str | None` type and handles None values by storing them directly without modification. No return value; modifies instance state as side effect."
      },
      "jinja_loader": {
        "human": "Creates a template loader that tells the application where to find its HTML template files. If a template folder has been configured, it sets up a file reader that knows how to locate and load templates from that specific folder. If no template folder is configured, it returns nothing, indicating templates aren't available.",
        "technical": "Cached property that instantiates a Jinja2 FileSystemLoader when template_folder attribute exists, combining root_path and template_folder using os.path.join to create absolute template directory path. Returns None if template_folder is not set. Uses @cached_property decorator to compute the loader once and cache the result. Returns BaseLoader | None type."
      },
      "_method_route": {
        "human": "Creates a decorator for registering URL routes that respond to a specific HTTP method (like GET or POST). It's a helper that simplifies route creation by automatically setting the HTTP method, while preventing conflicts if someone tries to manually specify methods. This makes it easier to create method-specific endpoints in a web application.",
        "technical": "Validates that 'methods' key is not present in options dict, raising TypeError if found. Delegates to self.route() by passing the rule string, wrapping the method parameter in a list as the 'methods' argument, and unpacking remaining options. Returns a callable decorator that accepts and returns a route handler function (T_route type). Serves as internal implementation for HTTP method-specific decorators like @app.get() or @app.post()."
      },
      "get": {
        "human": "This function provides a convenient way to register a web page or endpoint that only responds to GET requests (when someone visits a URL in their browser). Instead of having to specify that you want GET requests every time, this shortcut does it automatically, making the code cleaner and easier to write.",
        "technical": "Delegates to the internal `_method_route()` helper method, passing \"GET\" as the HTTP method, the URL rule string, and any additional keyword arguments. Returns a decorator function (Callable) that can be applied to route handler functions. The `@setupmethod` decorator indicates this modifies application configuration during setup phase. Type hints show it accepts a route handler of type T_route and returns the same type."
      },
      "post": {
        "human": "This function provides a convenient way to register a web page handler that only responds to POST requests (when users submit forms or send data to the server). Instead of manually specifying that you want POST requests, this shortcut does it automatically, making the code cleaner and easier to read.",
        "technical": "Decorator method that delegates to `_method_route()` with \"POST\" as the HTTP method parameter, along with the URL rule and any additional options. Returns a callable decorator that wraps route handler functions. The `@setupmethod` decorator indicates this configures routing during application setup. Passes through `rule` (URL pattern) and `**options` (keyword arguments) to the internal routing mechanism."
      },
      "put": {
        "human": "This function provides a convenient way to register a web endpoint that only accepts PUT requests (typically used for updating existing resources). Instead of manually specifying the HTTP method each time, developers can use this shortcut to quickly set up a PUT endpoint by just providing the URL path.",
        "technical": "Decorator method that wraps `_method_route()` with \"PUT\" as the HTTP method parameter. Takes a URL rule string and optional keyword arguments, returning a callable decorator that can be applied to view functions. The `@setupmethod` decorator indicates this configures routing during application setup. Delegates actual route registration to the internal `_method_route()` helper method."
      },
      "delete": {
        "human": "This function provides a convenient way to register a web endpoint that responds to DELETE requests (typically used for removing resources). Instead of manually specifying that you want to handle DELETE operations, this shortcut does it automatically. It's like creating a labeled button that says \"this handles deletions\" for your web application.",
        "technical": "Decorator method that delegates to `_method_route()` with \"DELETE\" as the HTTP method parameter, along with the URL rule and any additional options. Returns a callable decorator that can be applied to view functions to register them as DELETE endpoint handlers. The `@setupmethod` decorator indicates this can only be called during application setup phase before request handling begins."
      },
      "patch": {
        "human": "This function provides a convenient way to register a web endpoint that responds specifically to PATCH requests (used for partially updating resources). Instead of manually specifying the HTTP method each time, developers can use this shortcut to quickly set up a PATCH endpoint by just providing the URL path. It's a time-saving helper that makes code cleaner and more readable.",
        "technical": "Decorator method that delegates to `_method_route()` with \"PATCH\" as the HTTP method parameter, along with the provided rule (URL pattern) and any additional options. Returns a callable decorator that wraps route handler functions. The `@setupmethod` decorator indicates this configures routing during application setup. Passes through all keyword arguments to the underlying routing mechanism unchanged."
      },
      "route": {
        "human": "This is a decorator that connects URL paths (like \"/home\" or \"/about\") to the functions that should run when users visit those pages. It's like creating a map that tells the web application \"when someone goes to this address, run this piece of code.\" It makes it easy to set up website routes by simply adding @app.route(\"/path\") above your function.",
        "technical": "Returns a decorator function that registers view functions to URL rules. Extracts the optional 'endpoint' parameter from options dict, then calls self.add_url_rule() with the rule string, endpoint, view function, and remaining options. The decorator returns the original function unmodified, enabling chaining. Acts as a wrapper around add_url_rule() to provide decorator syntax for route registration."
      },
      "add_url_rule": {
        "human": "Registers a URL path (like \"/home\" or \"/about\") in a web application and connects it to a function that handles requests to that path. This is how you tell the application \"when someone visits this URL, run this specific code.\" It's the core mechanism for defining what happens when users navigate to different pages on your website.",
        "technical": "This is an abstract method (raises NotImplementedError) that defines the interface for URL route registration in Flask-like frameworks. When implemented, it would: accept a URL rule string and optional endpoint name/view function, handle endpoint-to-view-function mapping with collision detection, process HTTP methods (defaulting to GET, auto-adding HEAD/OPTIONS), merge any required_methods from view_func attributes, and register the rule with the underlying routing system (likely Werkzeug's Rule class)."
      },
      "endpoint": {
        "human": "This function allows you to connect a view function (the code that handles a web request) to a specific endpoint name after you've already created the URL route. It's useful when you want to define the URL path first and attach the actual handler function later, keeping your code organized and flexible.",
        "technical": "Returns a decorator function that registers a view function in the `self.view_functions` dictionary using the provided endpoint string as the key. The decorator stores the function reference and returns it unmodified, enabling deferred binding of view functions to endpoints previously registered via `add_url_rule`. Side effect: mutates the `view_functions` dict on the Flask/Blueprint instance."
      },
      "before_request": {
        "human": "This function allows you to register a custom function that will automatically run before handling any incoming web request. It's commonly used for setup tasks like checking if a user is logged in, opening database connections, or loading user data. The registered function can optionally stop the request early by returning a value, which will be sent back to the user instead of continuing to the normal page handler.",
        "technical": "A decorator function that registers a callback in the `before_request_funcs` dictionary under the `None` key (representing all routes). Uses `setdefault(None, [])` to initialize an empty list if the key doesn't exist, then appends the function `f` to this list. Returns the original function unmodified, enabling decorator syntax. The `@setupmethod` decorator indicates this modifies application configuration during setup phase."
      },
      "after_request": {
        "human": "Allows you to register a custom function that will automatically run after each web request is processed. This is useful when you need to modify the response before sending it back to the user, such as adding custom headers or logging information. The registered function receives the response, can change it, and must return the modified response.",
        "technical": "Decorator method that registers a callback function to execute after request processing. Stores the function `f` in `self.after_request_funcs` dictionary using `None` as key (indicating global scope) and appends to a list via `setdefault(None, []).append(f)`. Returns the original function unmodified, enabling use as a decorator. The registered callback must accept a response object parameter and return a response object."
      },
      "teardown_request": {
        "human": "This function allows you to register cleanup tasks that should run after each web request is finished. Think of it like setting up automatic cleanup crew that tidies up after each customer leaves - it ensures resources are properly released and temporary data is cleared when a request completes, whether it succeeded or failed.",
        "technical": "Decorator function that registers a teardown callback by appending it to `self.teardown_request_funcs` dictionary under the `None` key (representing no specific blueprint). Uses `setdefault(None, [])` to initialize an empty list if the key doesn't exist, then appends the function `f` to that list. Returns the original function unchanged, enabling decorator usage. The registered callbacks are later invoked when the request context is popped."
      },
      "context_processor": {
        "human": "Registers a function that will automatically run before any template is displayed on a website. The function can add extra information (like user data or settings) that the template can use when showing content to visitors. It's like setting up default information that every page can access without having to pass it manually each time.",
        "technical": "Decorator method that registers a template context processor function by appending it to `self.template_context_processors[None]` list. Uses the `None` key to indicate global scope (all endpoints). Returns the original function unchanged, enabling use as a decorator. The registered function will be called during template rendering, with its returned dict merged into the template context variables."
      },
      "url_value_preprocessor": {
        "human": "Registers a function that can modify URL parameters before they reach your web pages. This is useful when you want to extract common information from URLs (like language preferences) and store it separately, so you don't have to handle it in every individual page. The registered function runs automatically for every matching request.",
        "technical": "Decorator method that appends a preprocessor function to `self.url_value_preprocessors[None]` list and returns the original function unchanged. The preprocessor receives endpoint name and URL values dict, allowing modification of captured URL parameters before view execution. Runs after URL matching but before `before_request` handlers. Uses `None` as key to apply globally to all endpoints within the app/blueprint scope."
      },
      "url_defaults": {
        "human": "Registers a callback function that provides default values for URL generation throughout the application. When you create URLs in your app, this function automatically fills in common parameters (like language preference or user ID) so you don't have to specify them every time. It acts as a decorator that you place above your callback function to activate this automatic URL parameter filling.",
        "technical": "Decorator function that registers a callback to `self.url_default_functions[None]` list by appending the provided function `f`. Returns the original function unmodified, enabling decorator usage with `@url_defaults`. The registered callback will be invoked during URL building to inject default parameter values. Uses `None` as the key to indicate global scope (all endpoints), distinguishing from endpoint-specific defaults."
      },
      "errorhandler": {
        "human": "This is a decorator that lets you specify custom error pages or responses for your web application. When something goes wrong (like a 404 page not found or a database error), instead of showing a generic error, you can define exactly what message or page users should see. It works like a registration system where you tell the app \"when this error happens, run this function.\"",
        "technical": "Returns a decorator function that registers error handlers by calling `self.register_error_handler()` with the provided HTTP status code (int) or exception class and the decorated handler function. The decorator pattern allows using `@app.errorhandler(code_or_exception)` syntax. The inner decorator function receives the handler, registers it via the internal registration method, and returns the original handler unchanged, enabling function chaining."
      },
      "register_error_handler": {
        "human": "Registers a custom function to handle errors that occur in your web application. When a specific type of error happens (like a 404 \"page not found\" or a 500 \"server error\"), this tells the application which function should run to deal with it. It's like setting up an automatic response plan for when things go wrong.",
        "technical": "Stores an error handler function in the application's error_handler_spec dictionary structure. Calls _get_exc_class_and_code() to parse the input into an exception class and HTTP status code, then maps the handler function to that specific error type using a nested dictionary lookup [None][code][exc_class]. Marked with @setupmethod decorator indicating it's used during application configuration phase."
      },
      "_get_exc_class_and_code": {
        "human": "This function takes either an error code number (like 404 for \"Not Found\") or an exception class and converts it into a standardized format that the system can work with. It validates that the input is correct, converts error code numbers into their corresponding exception classes, and extracts the status code if it's an HTTP-related error. This ensures error handlers are registered properly regardless of whether you specify errors by number or by class name.",
        "technical": "Normalizes exception handler registration by accepting either an integer HTTP status code or Exception subclass. For integers, looks up the corresponding exception in `default_exceptions` dict, raising ValueError if not found. Validates input isn't an instance (TypeError) and is an Exception subclass (ValueError). Returns tuple of (exception_class, status_code) where status_code is extracted from HTTPException.code attribute or None for non-HTTP exceptions. Uses isinstance/issubclass for type checking."
      },
      "decorator": {
        "human": "This is a decorator function that registers custom error handling functions for specific error types or HTTP status codes. When you use this decorator on a function, it tells the system \"whenever this particular error happens, use this function to handle it.\" The decorated function remains unchanged and can still be used normally.",
        "technical": "A decorator factory implementation that registers error handlers by calling `self.register_error_handler()` with a predefined `code_or_exception` (from outer scope) and the decorated function `f`. Returns the original function unmodified, allowing it to be used as both a decorator and preserving the original function reference. The `code_or_exception` parameter is captured from the enclosing scope, making this an inner function of a larger error handler registration mechanism."
      }
    },
    "src/flask/sessions.py": {
      "_lazy_sha1": {
        "human": "Creates a SHA-1 hash generator for the given data, but delays actually loading the SHA-1 algorithm until the moment it's called. This is important for systems with strict security settings (FIPS mode) that might have SHA-1 disabled - it gives developers a chance to configure an alternative hashing method before the program crashes.",
        "technical": "Wraps `hashlib.sha1()` call in a function to defer import-time execution until runtime. Accepts optional bytes parameter (defaults to empty bytes), passes it directly to `hashlib.sha1()`, and returns the resulting hash object. This lazy evaluation pattern prevents ImportError on FIPS-compliant systems where SHA-1 may be unavailable, allowing runtime configuration of alternative hash functions before SHA-1 access is attempted."
      },
      "permanent": {
        "human": "Checks whether something has been marked as \"permanent\" or not. This is like looking up a flag that indicates if an item should be kept forever or can be removed later. If the permanent flag hasn't been set, it assumes the item is not permanent and returns False.",
        "technical": "Property getter that retrieves the boolean value associated with the '_permanent' key from the underlying dictionary-like object. Calls self.get() with '_permanent' as the key and False as the default value, returning False if the key doesn't exist. No side effects; performs read-only dictionary access."
      },
      "__init__": {
        "human": "Sets up a special dictionary-like object that can track when it has been changed or looked at. When you first create this object, you can optionally give it some starting data (like key-value pairs). The object automatically marks itself as \"modified\" and \"accessed\" whenever its contents are updated, helping keep track of whether the data has been touched.",
        "technical": "Initializes a tracking-enabled mapping object by calling parent class constructor with optional initial data (accepts Mapping, Iterable of tuples, or None). Defines and passes an `on_update` callback that sets both `self.modified` and `self.accessed` flags to True whenever the object is mutated. The callback uses `te.Self` type hint for proper self-referencing. Delegates actual initialization logic to superclass via `super().__init__(initial, on_update)`."
      },
      "__getitem__": {
        "human": "This function retrieves a value from a collection (like getting an item from a dictionary or list) while keeping track that someone has accessed it. It's like a monitored storage box that records when someone opens it to take something out, then proceeds to give them what they requested.",
        "technical": "Overrides the `__getitem__` magic method to add access tracking functionality. Sets the instance attribute `self.accessed` to `True` as a side effect before delegating to the parent class's `__getitem__` implementation via `super()`. Returns whatever the parent class's `__getitem__` method returns for the given key. This is a wrapper pattern that adds state tracking to dictionary/sequence access operations."
      },
      "get": {
        "human": "This function retrieves a value from a dictionary-like storage using a key, just like looking up a word in a dictionary. It also keeps track that someone accessed the storage by setting a flag. If the key doesn't exist, it returns a backup value (default) instead of causing an error.",
        "technical": "Overrides the standard dictionary `get()` method to add access tracking functionality. Sets `self.accessed` flag to `True` as a side effect, then delegates to parent class's `get()` method via `super().get(key, default)` to retrieve the value. Returns the value associated with `key` if it exists, otherwise returns `default` (None if not specified). Maintains standard dict.get() behavior while adding state tracking."
      },
      "setdefault": {
        "human": "This function retrieves a value from a dictionary-like object using a key, but if that key doesn't exist, it creates it with a default value you provide. It also marks that someone has looked at or used this object by setting an \"accessed\" flag to True. Think of it like checking a settings menu - it remembers that you opened it and ensures every setting has a value.",
        "technical": "Overrides the standard dictionary `setdefault` method to add access tracking functionality. Sets the `self.accessed` flag to `True` before delegating to the parent class's `setdefault` implementation via `super()`. Returns either the existing value for the given key or sets and returns the provided default value if the key doesn't exist. Maintains standard dict behavior while adding side effect of tracking access state."
      },
      "_fail": {
        "human": "This function is a safety guard that stops the application when someone tries to use session features without proper security setup. It alerts developers that they forgot to configure a secret key, which is essential for keeping user session data secure. The function intentionally crashes the application with a helpful error message explaining what needs to be fixed.",
        "technical": "Raises a RuntimeError unconditionally when invoked, accepting any arguments (*args, **kwargs) but ignoring them. Returns t.NoReturn type hint indicating the function never returns normally. Serves as a placeholder method that replaces session operations when Flask's secret_key is not configured, preventing insecure session usage at runtime."
      },
      "make_null_session": {
        "human": "Creates a backup session object that's used when the normal session system fails to load properly. This backup allows users to read session data without errors, but if they try to change anything, it shows a helpful error message explaining what went wrong. It's a safety feature that keeps the application running even when session configuration has problems.",
        "technical": "Factory method that instantiates and returns a NullSession object by calling `self.null_session_class()`. Takes a Flask app parameter (unused in implementation) and returns a NullSession instance. The NullSession acts as a null object pattern implementation, providing read-only access while blocking modifications. No side effects or complex operations - simply delegates to the configured null session class constructor."
      },
      "is_null_session": {
        "human": "Determines whether a session object should be treated as \"null\" - meaning it's a special type of session that doesn't need to be saved or persisted. This is useful for identifying temporary or read-only sessions that shouldn't trigger save operations, helping the application avoid unnecessary work for sessions that don't need to be stored.",
        "technical": "Performs a type check using `isinstance()` to verify if the provided object matches the class stored in `self.null_session_class`. Returns a boolean: `True` if the object is an instance of the null session class, `False` otherwise. No side effects - pure validation method that only reads instance attributes."
      },
      "get_cookie_name": {
        "human": "Retrieves the name that will be used for the session cookie in a web application. This is like looking up what label the application uses to identify user sessions when they visit the website. The name is stored in the application's configuration settings and this function simply fetches it.",
        "technical": "Accesses Flask application's configuration dictionary to retrieve the SESSION_COOKIE_NAME value and returns it as a string. Acts as a simple getter method that provides read-only access to the configured session cookie name. No validation, transformation, or side effects - pure configuration value retrieval from app.config dictionary."
      },
      "get_cookie_domain": {
        "human": "Retrieves the domain setting that controls where session cookies can be sent. This determines whether a cookie set on your website will only work on that exact domain (like \"example.com\") or also on all its subdomains (like \"shop.example.com\" and \"blog.example.com\"). It reads this setting from the application's configuration.",
        "technical": "Accesses and returns the `SESSION_COOKIE_DOMAIN` value from the Flask app's config dictionary. Returns either a string containing the domain name or None if not configured. No validation or transformation is performed - it's a simple config value accessor. The return type is `str | None`, though the signature shows `Any`. No side effects or external calls."
      },
      "get_cookie_path": {
        "human": "Determines the web path where a session cookie should be active on a website. This controls which pages can access the cookie - for example, whether it works across the entire site or just specific sections. It checks the application's settings to find the appropriate path, defaulting to the site root if nothing specific is configured.",
        "technical": "Retrieves cookie path configuration from Flask app's config dictionary by checking `SESSION_COOKIE_PATH` first, then falling back to `APPLICATION_ROOT` using Python's `or` operator for short-circuit evaluation. Returns a string representing the URL path scope. Note: The code differs from docstring - it doesn't explicitly handle `None` case with `/` fallback, relying instead on Flask's config defaults."
      },
      "get_cookie_httponly": {
        "human": "Checks whether the session cookie should be protected from JavaScript access in a web application. This is a security feature that helps prevent malicious scripts from stealing user session information. The function simply looks up this security setting from the application's configuration and returns whether it's enabled or not.",
        "technical": "Retrieves the boolean value of the `SESSION_COOKIE_HTTPONLY` configuration key from the Flask application's config dictionary. Returns True if the HttpOnly flag should be set on session cookies (preventing client-side JavaScript access), False otherwise. This is a simple getter method with no validation, side effects, or data transformation\u2014it directly accesses and returns the config value."
      },
      "get_cookie_secure": {
        "human": "Checks whether session cookies should be sent only over secure (HTTPS) connections. This is a security feature that helps protect user session data from being intercepted on unsecured networks. The function looks up the security setting configured for the application and returns whether secure-only mode is enabled.",
        "technical": "Retrieves the boolean value of `SESSION_COOKIE_SECURE` from the Flask application's configuration dictionary. Acts as a simple accessor method that returns the configuration value directly without any transformation or validation. Returns `True` if cookies should have the secure flag set, `False` otherwise. No side effects or external dependencies beyond Flask's config system."
      },
      "get_cookie_samesite": {
        "human": "Retrieves the security setting that controls how cookies are shared across different websites. This setting helps protect user privacy by determining whether cookies should be sent when someone clicks a link from another site. It simply looks up and returns the configured value that the application administrator has set.",
        "technical": "Accesses Flask application's configuration dictionary to retrieve the `SESSION_COOKIE_SAMESITE` setting value. Returns a string (`'Strict'`, `'Lax'`, or `None`) that specifies the SameSite cookie attribute behavior. Direct dictionary lookup with no validation, transformation, or side effects. The return type annotation indicates `str | None` despite the signature showing `Any`."
      },
      "get_cookie_partitioned": {
        "human": "Checks whether session cookies should be marked as \"partitioned\" in the web application. Partitioned cookies are a security feature that prevents cookies from being shared across different websites. This function simply looks up the application's configuration setting to determine if this security feature should be enabled for session cookies.",
        "technical": "Retrieves the boolean configuration value `SESSION_COOKIE_PARTITIONED` from the Flask application's config dictionary and returns it directly. This is a simple getter method that accesses `app.config` with no validation, transformation, or side effects. The return value determines whether the `Partitioned` attribute will be set on session cookies during cookie creation."
      },
      "get_expiration_time": {
        "human": "Determines when a user's session should expire and end. If the session is set to be \"permanent\" (meaning it should last beyond just the current browser visit), it calculates an expiration time by adding a configured duration to the current time. If the session is temporary and tied to the browser being open, it returns nothing to indicate no specific expiration.",
        "technical": "Checks the `session.permanent` boolean flag to determine session type. For permanent sessions, returns a timezone-aware datetime object by adding `app.permanent_session_lifetime` (a timedelta) to the current UTC time obtained via `datetime.now(timezone.utc)`. For non-permanent sessions, returns `None` to indicate browser-session-only lifetime. Return type is `datetime | None`."
      },
      "should_set_cookie": {
        "human": "Decides whether the website needs to send back a cookie to remember the user's session information. It says \"yes\" in two situations: either the session data has changed during this visit, or the session is set to be long-lasting and the website is configured to refresh the cookie with every page request. This helps maintain user login states and preferences.",
        "technical": "Returns a boolean indicating if a Set-Cookie header should be included in the HTTP response. Evaluates two conditions using logical OR: (1) checks `session.modified` flag to detect if session data changed, (2) checks both `session.permanent` attribute AND Flask's `SESSION_REFRESH_EACH_REQUEST` config value. Returns True if either condition is met, triggering cookie transmission to client."
      },
      "open_session": {
        "human": "Opens and retrieves a user's session when they visit the website. It looks for a secure cookie stored in their browser, checks if it's valid and not expired, and loads their session data (like login status or shopping cart). If the cookie is missing, tampered with, or expired, it creates a fresh empty session instead.",
        "technical": "Retrieves signing serializer and session cookie name from Flask app config. Extracts cookie value from request, deserializes it using `s.loads()` with max_age validation based on `app.permanent_session_lifetime`. Returns `session_class` instance populated with deserialized data on success. Catches `BadSignature` exceptions (invalid/tampered cookies) and returns empty session. Returns None if serializer unavailable, empty session if no cookie present."
      },
      "save_session": {
        "human": "Saves the user's session data to a browser cookie when they visit a website. If the user's session is empty or has been cleared, it removes the cookie from their browser. If there's session data to save, it packages it securely and sends it back to the browser with appropriate security settings like expiration time and access restrictions.",
        "technical": "Retrieves cookie configuration (name, domain, path, security flags) from Flask app, then handles three cases: (1) adds \"Vary: Cookie\" header if session was accessed, (2) deletes cookie via response.delete_cookie() if session is empty but modified, (3) serializes session dict using signing serializer and sets cookie via response.set_cookie() with all security parameters (httponly, secure, samesite, partitioned, expires). Returns early if session is empty/unmodified or should_set_cookie() returns False."
      },
      "get_signing_serializer": {
        "human": "Creates a secure signing tool that can encrypt and verify data (like session cookies or tokens) for a Flask web application. It supports using backup secret keys so that if you change your main secret key, old signed data can still be verified. Returns nothing if no secret key is configured, preventing the app from accidentally using insecure signing.",
        "technical": "Constructs a URLSafeTimedSerializer for cryptographic signing operations in Flask. Builds a key list by first adding fallback keys from SECRET_KEY_FALLBACKS config, then appending the current app.secret_key (itsdangerous requires current key last). Returns None if no secret_key exists. Initializes serializer with instance's salt, serializer, key_derivation, and digest_method parameters. Returns URLSafeTimedSerializer instance or None."
      },
      "on_update": {
        "human": "This function marks an object as having been changed and accessed. It's like updating a \"last modified\" flag when someone edits a document - it records that the data has been both viewed and altered. This tracking helps the system know which objects have been touched and need attention.",
        "technical": "Sets two boolean instance attributes on the object: `self.modified` to `True` indicating the object's state has changed, and `self.accessed` to `True` indicating the object has been read or interacted with. This is a callback/hook method typically invoked by property setters or update operations to maintain object state metadata. No return value; operates purely through side effects on instance state."
      }
    },
    "src/flask/templating.py": {
      "_default_template_ctx_processor": {
        "human": "This function prepares a set of common variables that should be available in every web page template. It ensures that templates can always access the application's global settings (g), and when handling a web request, it also makes the request details and user session data available. This saves developers from manually passing these frequently-needed variables to every template.",
        "technical": "Retrieves the current Flask application context object and initializes a dictionary with the global 'g' object. Conditionally checks if a request context exists via `ctx.has_request`, and if true, adds the request and session objects to the return dictionary. Returns a dict containing 'g' (always), plus 'request' and 'session' (only during active HTTP requests), which Flask automatically injects into template rendering contexts."
      },
      "_render": {
        "human": "This function takes a template (like an HTML page with placeholders) and fills it in with actual data to create the final output. It's like a mail-merge operation - you have a template letter and a list of names, and this combines them. Before and after filling in the template, it notifies other parts of the application so they can add their own data or track what's happening.",
        "technical": "Orchestrates template rendering in a Flask application by: (1) updating the template context with app-level variables via `app.update_template_context()`, (2) sending `before_render_template` signal to allow pre-render hooks, (3) executing `template.render(context)` to generate the string output, (4) sending `template_rendered` signal for post-render hooks. All signals use `app.ensure_sync` wrapper for async compatibility. Returns the rendered string."
      },
      "render_template": {
        "human": "Takes a template file name (like \"homepage.html\") and fills it with dynamic data to create a complete HTML page. It's like a mail-merge for web pages - you provide the template and the data, and it combines them into the final output that users see in their browser.",
        "technical": "Retrieves the current Flask application context, uses Jinja2's `get_or_select_template()` to load the template (selecting first available if list provided), then delegates to `_render()` helper to process the template with provided keyword arguments as context variables. Returns the rendered string output. Accepts either single template name/object or list of templates for fallback selection."
      },
      "render_template_string": {
        "human": "Takes a template written as a text string (instead of a file) and fills it in with provided data to create a final rendered output. This is useful when you need to generate dynamic content on-the-fly, like creating personalized messages or HTML pages where the template itself is stored in a database or generated programmatically rather than saved as a separate file.",
        "technical": "Retrieves the current Flask application context, converts the source string into a Jinja2 template object using `jinja_env.from_string()`, then delegates to `_render()` helper function to process the template with the provided context variables. Returns the rendered string output. Operates within Flask's application context stack and uses Jinja2's template engine for variable substitution and template logic execution."
      },
      "_stream": {
        "human": "Renders a web template (like an HTML page) piece by piece instead of all at once, allowing the server to start sending content to the user's browser before the entire page is ready. This is useful for pages that take time to generate, as users can see content appearing progressively rather than waiting for everything to complete.",
        "technical": "Implements streaming template rendering in Flask by: (1) updating template context via `app.update_template_context()`, (2) sending `before_render_template` signal, (3) creating a generator that yields template chunks from `template.generate()`, (4) sending `template_rendered` signal after generation completes, and (5) wrapping the generator with `stream_with_context()` to preserve request context throughout the streaming process. Returns an iterator of string chunks."
      },
      "stream_template": {
        "human": "This function prepares a web page template for streaming delivery to the user's browser. Instead of waiting for the entire page to be ready before sending it, this allows the page to be sent piece by piece as it's being generated. This makes websites feel faster and more responsive, especially for pages that take time to build.",
        "technical": "Retrieves the current Flask application context, resolves the template name (or selects first available from list) using Jinja2's `get_or_select_template()`, then delegates to `_stream()` helper which returns an iterator yielding rendered template chunks as strings. Takes template identifier (string, Template object, or list) and keyword arguments as template context variables. Returns iterator suitable for Flask streaming responses without loading entire rendered output into memory."
      },
      "stream_template_string": {
        "human": "Takes a template written as a text string (instead of a file) and converts it into a stream of text chunks that can be sent piece-by-piece to a web browser. This is useful when you want to show content to users progressively as it's being generated, rather than waiting for everything to finish before displaying anything.",
        "technical": "Retrieves the current Flask application context, compiles the source string into a Jinja2 template object using `jinja_env.from_string()`, then delegates to `_stream()` helper function which returns an iterator yielding rendered template chunks. Accepts template variables via `**context` kwargs. Returns `t.Iterator[str]` for streaming HTTP responses without loading entire rendered output into memory."
      },
      "__init__": {
        "human": "Sets up a template rendering environment for a web application. This is like preparing a workspace where the application can create web pages from templates. If no template loader is specified, it automatically creates a default one that knows where to find the application's templates. It then connects this environment to the application so they can work together.",
        "technical": "Initializes a Jinja2 Environment subclass for an App instance. Checks if 'loader' exists in options kwargs; if absent, calls `app.create_global_jinja_loader()` to generate default template loader. Invokes parent `BaseEnvironment.__init__()` with all options to configure Jinja2 environment. Stores reference to App instance in `self.app` for bidirectional access between environment and application."
      },
      "get_source": {
        "human": "This function retrieves the source code of a template file. It has two modes: a detailed \"explained\" mode that provides extra information about how the template was found (useful for debugging), and a fast mode for normal operation. The mode is controlled by a configuration setting that determines whether template loading should be explained or not.",
        "technical": "Conditionally routes template source retrieval based on the `EXPLAIN_TEMPLATE_LOADING` config flag. When true, calls `_get_source_explained()` which likely returns additional debugging metadata; otherwise calls `_get_source_fast()` for optimized retrieval. Returns a 3-tuple containing the template source string, an optional filename/path, and an optional callable for checking template freshness. Acts as a dispatcher method delegating to internal implementation methods."
      },
      "_get_source_explained": {
        "human": "Searches through multiple possible locations to find a template file (like an HTML page), keeping track of where it looked and whether it found the file in each place. If it finds the template, it returns information about where it was found. If it can't find the template anywhere, it shows a helpful error message explaining all the places it checked before giving up.",
        "technical": "Iterates through available template loaders via `_iter_loaders()`, attempting `loader.get_source()` on each until successful. Collects all attempts (loader, source object, result) in a list regardless of success/failure. Calls `explain_template_loading_attempts()` to log debugging information about the search process. Returns the first successful tuple (source, filename, uptodate callable) or raises `TemplateNotFound` if all loaders fail."
      },
      "_get_source_fast": {
        "human": "Searches through multiple template storage locations to find and load a specific template file. It tries each location one by one until it finds the template, similar to how you might check different folders on your computer to find a document. If the template isn't found anywhere, it reports an error saying the template doesn't exist.",
        "technical": "Iterates through available template loaders via `_iter_loaders()`, attempting `loader.get_source()` on each until successful. Catches `TemplateNotFound` exceptions to continue searching through remaining loaders. Returns a 3-tuple containing template source string, optional filename, and optional reload check callable. Raises `TemplateNotFound` if all loaders fail to locate the template."
      },
      "_iter_loaders": {
        "human": "This function searches through a web application and all its registered components (blueprints) to find template loaders. It collects all the available template loaders that can be used to find and load HTML templates. This allows the application to check multiple locations when looking for a specific template file, starting with the main application and then checking each registered component.",
        "technical": "Generator function that yields tuples of (Scaffold, BaseLoader) pairs by iterating through available Jinja2 template loaders. First checks if `self.app.jinja_loader` exists and yields it with the app instance. Then iterates through `self.app.iter_blueprints()`, checking each blueprint's `jinja_loader` attribute and yielding non-None loaders. Returns an iterator of scaffold-loader pairs for template resolution in Flask applications."
      },
      "list_templates": {
        "human": "Collects and returns a complete list of all available template names that can be used in the application. It gathers templates from both the main application and any additional modules (blueprints) that might have their own templates, ensuring no duplicates appear in the final list.",
        "technical": "Aggregates template names from multiple Jinja2 loaders into a deduplicated set. First collects templates from `self.app.jinja_loader`, then iterates through all blueprints via `self.app.iter_blueprints()` to gather templates from each `blueprint.jinja_loader`. Uses a set to automatically handle duplicates, then converts to list before returning. Returns empty list if no loaders are configured."
      },
      "generate": {
        "human": "This function generates content from a template (like filling in a form with data) and then notifies the application that the template has been rendered. It's like a two-step process: first create the output piece by piece, then tell the system \"I'm done creating this content\" so other parts of the application can react to it.",
        "technical": "Generator function that yields template-rendered strings by delegating to `template.generate(context)`, then sends a `template_rendered` signal with the app, template, and context as parameters. Uses `app.ensure_sync` wrapper for async compatibility. Returns an iterator of strings representing the rendered template output. Side effect: triggers signal handlers listening to template_rendered events."
      }
    },
    "src/flask/testing.py": {
      "_get_werkzeug_version": {
        "human": "Retrieves and remembers the version number of the Werkzeug library installed on the system. The first time it's called, it looks up the version and stores it for future use. Subsequent calls simply return the stored version without looking it up again, making it faster.",
        "technical": "Implements lazy initialization pattern with global caching for Werkzeug version string. On first invocation, queries `importlib.metadata.version(\"werkzeug\")` to retrieve the installed package version and caches it in the global `_werkzeug_version` variable. Subsequent calls return the cached value directly, avoiding repeated metadata lookups. Returns version as string."
      },
      "__init__": {
        "human": "This is a setup function that creates a new object and connects it to a Flask web application. It stores a reference to the Flask app so the object can interact with it later, then completes any additional setup needed by calling the parent class's initialization. Think of it as preparing a new component to work within a Flask website.",
        "technical": "Constructor method that initializes an instance by storing the Flask application object as an instance attribute (`self.app`) and invoking the parent class constructor via `super().__init__()` with any additional keyword arguments passed through. Enables the class to maintain a reference to the Flask app context while delegating remaining initialization logic to the parent class. No return value (returns None implicitly)."
      },
      "json_dumps": {
        "human": "Converts a Python object (like a dictionary or list) into a JSON text string. This is useful when you need to save data to a file, send it over the internet, or store it in a format that other programs can read. It uses the application's specific settings to control how the conversion happens.",
        "technical": "Delegates JSON serialization to the application's configured JSON encoder by calling `self.app.json.dumps()`. Passes through the input object and any additional keyword arguments to the underlying serialization method. Returns a JSON-formatted string representation of the object. Acts as a wrapper that ensures JSON serialization uses the EnvironBuilder's associated Flask application configuration."
      },
      "session_transaction": {
        "human": "Allows you to temporarily access and modify the test client's session data during testing. You use it in a \"with\" block to make changes to session values (like login state or user preferences), and when the block ends, those changes are automatically saved back to the test client's session for use in subsequent test requests.",
        "technical": "Context manager that creates a temporary test request context, opens the session using the app's session_interface, yields it for modification, then saves it back. Validates cookies are enabled, adds existing cookies to the request environment via _add_cookies_to_wsgi, and after yielding updates the client's cookie jar by parsing Set-Cookie headers from the response. Skips save operation if session_interface returns a null session."
      },
      "_copy_environ": {
        "human": "Creates a customized copy of web request environment settings by combining default settings with specific request data. If context preservation is enabled (useful for debugging), it adds a special hook that tracks debugging contexts. This allows the system to maintain consistent environment settings across different requests while optionally keeping track of debugging information.",
        "technical": "Merges `self.environ_base` dictionary with the `other` WSGIEnvironment parameter using dictionary unpacking, with `other` taking precedence. When `self.preserve_context` is True, injects a `werkzeug.debug.preserve_context` key mapped to the `append` method of `self._new_contexts` list, enabling context tracking. Returns the merged WSGIEnvironment dictionary without modifying the original inputs."
      },
      "_request_from_builder_args": {
        "human": "Creates a test request object from provided arguments, which is used for simulating HTTP requests in a testing environment. It takes whatever request parameters you want to test with (like URL, headers, form data) and builds a proper request object that can be used to test how your web application responds, making sure to clean up resources when done.",
        "technical": "Constructs a BaseRequest object using EnvironBuilder by: (1) copying and merging the test client's base environment with any provided environ_base via _copy_environ(), (2) instantiating EnvironBuilder with the application and all passed args/kwargs, (3) calling builder.get_request() to generate the request object, and (4) ensuring builder.close() executes in a finally block to release resources. Returns the constructed BaseRequest for test client operations."
      },
      "open": {
        "human": "This function simulates making a web request to test a web application, similar to how a browser would interact with a website. It accepts different ways of describing the request (like a URL or request details), sends it to the application, and returns the response. It also manages the application's internal state between requests, cleaning up old context and preserving new context as needed for proper testing.",
        "technical": "Accepts request input as EnvironBuilder, dict, BaseRequest, or builder args/kwargs, normalizing them into a Request object with copied environment. Closes previous context stack to prevent context leakage across requests, then delegates to parent's open() method with buffered/follow_redirects options. Sets response.json_module from application config, re-pushes any contexts preserved during request processing via _context_stack.enter_context(), clears _new_contexts list, and returns TestResponse object."
      },
      "__enter__": {
        "human": "This function prepares a Flask test client for use in a \"with\" statement block. It ensures that only one test client context can be active at a time - if you try to use multiple nested test clients, it will stop you with an error. It marks the client as \"in use\" and then gives you access to it for testing your Flask application.",
        "technical": "Implements the context manager entry protocol (`__enter__`) for FlaskClient. Checks if `preserve_context` is already True and raises RuntimeError to prevent nested context invocations. Sets `self.preserve_context = True` to maintain request context after requests complete. Returns `self` (the FlaskClient instance) for use within the with-block. This enables `with app.test_client() as client:` syntax."
      },
      "__exit__": {
        "human": "This function performs cleanup when exiting a context manager (used with Python's \"with\" statement). It ensures that any temporary context is not preserved after the block ends and properly closes the internal context stack. Think of it like closing a door and turning off the lights when leaving a room.",
        "technical": "Implements the context manager exit protocol (`__exit__` method). Sets the `preserve_context` flag to False to prevent context retention, then calls `_context_stack.close()` to clean up the internal context stack. Accepts standard exception parameters (exc_type, exc_value, tb) but doesn't handle exceptions (returns None implicitly). No exception suppression occurs."
      },
      "invoke": {
        "human": "This function runs Flask command-line commands in a test environment, making it easy to test CLI features of your Flask application. It automatically sets up the necessary context so the command can access your Flask app during testing. If you don't specify which command to run, it uses your app's default command-line interface. This is primarily used when writing automated tests for Flask CLI commands.",
        "technical": "Wraps Click's CliRunner.invoke() method with Flask-specific defaults. Sets `cli` to `self.app.cli` if not provided, and injects a `ScriptInfo` object with app factory lambda into kwargs['obj'] if missing. Delegates to parent class's invoke() method via super(), passing the resolved CLI command, args, and enhanced kwargs. Returns a Click Result object containing command execution output and exit code."
      }
    },
    "src/flask/views.py": {
      "dispatch_request": {
        "human": "Routes incoming web requests to the appropriate handler method based on the type of request (GET, POST, etc.). If someone makes a HEAD request but there's no specific handler for it, the function automatically tries to use the GET handler instead. This is a common pattern in web applications where HEAD requests should behave like GET requests but without returning the body content.",
        "technical": "Dynamically dispatches HTTP requests to corresponding class methods by converting request.method to lowercase and using getattr() to retrieve the method. Implements HEAD-to-GET fallback when HEAD method handler is missing. Asserts method existence to prevent unimplemented method errors. Wraps the retrieved method with current_app.ensure_sync() to handle async/sync compatibility, then invokes it with provided kwargs and returns the ResponseReturnValue."
      },
      "as_view": {
        "human": "Converts a class-based view into a regular function that web frameworks can use as a route handler. It decides whether to create a fresh instance of the view class for each web request or reuse the same instance across all requests. This allows developers to write views as classes (which can be more organized) while still working with frameworks that expect simple functions.",
        "technical": "Creates a closure `view()` that either instantiates the class per-request (if `init_every_request=True`) or once upfront, then calls `dispatch_request()` via `current_app.ensure_sync()`. Applies any decorators from `cls.decorators` to the view function. Attaches metadata (view_class, methods, provide_automatic_options, __name__, __doc__, __module__) to the returned function for introspection and testing. Returns a `RouteCallable` compatible with Flask's routing system."
      },
      "__init_subclass__": {
        "human": "This function automatically runs when someone creates a new class that inherits from this one. It figures out which HTTP methods (like GET, POST, DELETE) the new class can handle by looking at what functions it has defined. It collects these methods from parent classes too, so child classes inherit their parents' capabilities. This saves developers from manually listing which HTTP methods each class supports.",
        "technical": "A `__init_subclass__` hook that auto-populates the `methods` class attribute by scanning for HTTP method handlers. First collects methods from all base classes via `base.methods`. Then iterates through `http_method_funcs` list, checking if each method name exists as an attribute using `hasattr()`, and adds uppercase method names (GET, POST, etc.) to a set. Only assigns `cls.methods` if the set is non-empty. Calls `super().__init_subclass__(**kwargs)` to maintain MRO chain."
      },
      "view": {
        "human": "This function acts as a bridge that handles incoming web requests for class-based views. When a user visits a webpage, this function creates an instance of the appropriate view class and tells it to process the request. It's like a receptionist that directs visitors to the right department and ensures their request gets handled properly.",
        "technical": "Factory function that instantiates a view class (accessed via `view.view_class` attribute) with provided arguments, then invokes its `dispatch_request` method to handle the HTTP request. Uses `current_app.ensure_sync` to guarantee synchronous execution in async contexts. Passes through kwargs to the dispatch method and returns a Flask response object (`ft.ResponseReturnValue`). Typically used as the callable returned by Flask's `View.as_view()` class method."
      }
    },
    "src/flask/wrappers.py": {
      "max_content_length": {
        "human": "Controls how much data the application will accept in an incoming request before rejecting it. This prevents users from overwhelming the server by uploading extremely large files or sending massive amounts of data. The limit can be set globally for the entire application or customized for individual requests based on specific needs.",
        "technical": "Property getter that returns the maximum content length in bytes with a three-tier fallback: (1) returns instance-level `_max_content_length` if set, (2) falls back to parent class implementation via `super()` if no Flask app context exists, (3) otherwise retrieves value from Flask app config `MAX_CONTENT_LENGTH`. Returns `int | None` where `None` means no limit enforced at Flask level."
      },
      "max_form_memory_size": {
        "human": "Controls the maximum allowed size for form fields (like text boxes) when users submit data to a web application. If someone tries to submit a form field larger than this limit, the server rejects it with an error. The limit can be customized per application or left unlimited, helping protect the server from being overwhelmed by excessively large form submissions.",
        "technical": "Property getter that returns the maximum form field size limit with three-tier fallback logic: (1) returns instance-level `_max_form_memory_size` if set, (2) falls back to parent class implementation via `super()` if no Flask app context exists, (3) otherwise retrieves value from Flask app config `MAX_FORM_MEMORY_SIZE` (default 500,000 bytes). Returns `int | None` where `None` indicates no limit enforcement."
      },
      "max_form_parts": {
        "human": "Controls how many form fields can be submitted at once when users upload data through web forms. This prevents someone from overwhelming the server by sending forms with thousands of fields. The limit can be customized for the entire application or for specific pages, and defaults to 1,000 fields if not set.",
        "technical": "Property getter that returns the maximum allowed multipart form fields with three-tier fallback logic: (1) returns instance-level `_max_form_parts` if set, (2) delegates to parent class `super().max_form_parts` if no Flask app context exists, (3) otherwise retrieves value from Flask app config `MAX_FORM_PARTS`. Returns `int | None` where `None` means unlimited fields."
      },
      "endpoint": {
        "human": "Retrieves the name of the function or view that should handle the current web request. This is like a label that identifies which part of your application should respond to a specific URL. Returns nothing (None) if the system hasn't figured out where to send the request yet, or if it couldn't find a matching destination.",
        "technical": "Property getter that returns the endpoint string from the associated URL rule object. Checks if `self.url_rule` exists and extracts its `endpoint` attribute, otherwise returns `None`. The endpoint is a string identifier used in Flask-like frameworks for URL routing and reverse URL generation when combined with view_args. No computation or side effects\u2014pure attribute access with null safety."
      },
      "blueprint": {
        "human": "Extracts the name of the blueprint (a component grouping in web applications) that the current request is being handled by. If the request isn't associated with any blueprint or hasn't been matched to a route yet, it returns nothing. This helps identify which section of the application is processing the current request.",
        "technical": "Property method that retrieves the blueprint name by parsing `self.endpoint` string. Uses `rpartition(\".\")` to split the endpoint at the last dot separator, returning the left portion as the blueprint name. Returns `None` if endpoint is not set or contains no dot separator. The endpoint format is expected to be \"blueprint_name.view_function_name\"."
      },
      "blueprints": {
        "human": "Returns a list of blueprint names showing the hierarchy from the current blueprint up through all its parent blueprints. If the application isn't currently processing a request within a blueprint (or if the URL didn't match any route), it returns an empty list. This helps track which organizational sections of the web application are handling the current request.",
        "technical": "Property method that retrieves the current blueprint name via `self.blueprint`, returns empty list if None, otherwise passes the name to `_split_blueprint_path()` helper function which parses the blueprint hierarchy string and returns it as a list of strings. The splitting function handles nested blueprint notation (likely dot-separated paths) to extract parent-child relationships in the blueprint registration tree."
      },
      "_load_form_data": {
        "human": "Loads form data from a web request and adds helpful debugging features. When the application is in debug mode and the form wasn't submitted correctly (wrong format), it enhances error messages to help developers understand what went wrong with their form submission, specifically pointing out encoding issues.",
        "technical": "Calls parent class's `_load_form_data()` to perform standard form parsing. In debug mode, conditionally applies `attach_enctype_error_multidict()` to enhance the `files` multidict when: app is in debug mode, mimetype is not \"multipart/form-data\", and no files were parsed. This wrapper provides more informative KeyError messages for common form encoding mistakes. No return value; modifies request object state in-place."
      },
      "on_json_loading_failed": {
        "human": "Handles errors that occur when the application fails to read or process JSON data (like from a web request). If the application is in debug mode, it shows the full error details to help developers troubleshoot. In production mode, it hides the detailed error information and shows a generic \"bad request\" message to protect sensitive system information from being exposed to users.",
        "technical": "Error handler that wraps the parent class's `on_json_loading_failed` method. Catches `BadRequest` exceptions raised by the parent handler and conditionally re-raises them based on `current_app.debug` flag. In debug mode, propagates the original detailed exception; in production, raises a sanitized `BadRequest()` without error details while maintaining exception chaining via `from ebr`. Returns `t.Any` to match parent signature."
      },
      "max_cookie_size": {
        "human": "Retrieves the maximum allowed size for cookies that the application can set. When the application is running, it uses the size limit configured by the developer. When no application is active (like during testing or initialization), it falls back to a standard default size limit to ensure cookies don't become too large.",
        "technical": "Property getter that returns the MAX_COOKIE_SIZE configuration value from current_app.config when within an application context. Falls back to Werkzeug's Response.max_cookie_size default value via super() when current_app is unavailable. Returns an integer representing the maximum cookie size in bytes. No side effects; purely read-only access to configuration."
      }
    }
  },
  "module_summaries": {
    "docs/conf.py": {
      "human": "This module configures how Flask's documentation is built and displayed using Sphinx, the documentation generation tool. It sets up the visual theme, defines project metadata like version numbers, and creates custom features for the documentation such as special links that automatically point to the correct version of Flask's source code on GitHub. It ensures that when developers or users read the documentation, they can easily navigate to the corresponding code files, whether they're viewing docs for a stable release or the development version.",
      "technical": "Sphinx configuration module that defines documentation build settings and extends Sphinx with custom roles. Imports pallets_sphinx_themes for consistent Flask project styling and packaging.version for release version parsing. Implements github_link() as a custom docutils role registered with Sphinx that dynamically generates GitHub repository URLs based on whether the current version is a development or stable release. Integrates with docutils' role registration system to provide :gh: markup in reStructuredText documentation. Serves as the central configuration entry point for Sphinx documentation generation, defining project metadata, theme selection, and custom documentation features."
    },
    "examples/celery/make_celery.py": {
      "human": "This module serves as a Celery application factory or initialization point for a task-based application. It imports the main task application module and likely instantiates or configures a Celery app instance that can be used by workers and other parts of the system to execute asynchronous tasks.",
      "technical": "Imports `task_app` module, which presumably contains Celery task definitions or application configuration. With only 5 lines of code and no functions/classes, this module likely contains module-level variable assignments that create or expose a Celery application instance (commonly named `celery` or `app`). Serves as the entry point for Celery workers to discover and execute tasks defined in the imported module."
    },
    "examples/celery/src/task_app/__init__.py": {
      "human": "This module sets up a Flask web application that can handle background tasks using Celery. It solves the problem of running time-consuming operations (like sending emails, processing large files, or generating reports) without making users wait for the web page to load. The module connects Flask (the web framework) with Celery (the background task system) and Redis (which manages the task queue), ensuring background jobs can access the same application resources as the main website. It's the foundation that allows the web application to do work \"behind the scenes\" while staying responsive to users.",
      "technical": "Implements Flask-Celery integration pattern through factory function `create_app()` and custom task class `FlaskTask`. Provides `celery_init_app()` as the primary integration API that creates a Celery instance with Flask-aware task execution via app_context wrapping. FlaskTask extends celery.Task with `__call__` override to ensure all task executions run within Flask's application context. Configures Celery broker/backend using Redis, loads configuration from Flask's config system with environment variable override support, and stores Celery instance in app.extensions registry. Registers blueprint-based views and serves as the application entry point for both Flask web server and Celery worker processes."
    },
    "examples/celery/src/task_app/tasks.py": {
      "human": "This module provides background task functionality for a Celery-based application. It defines tasks that can run asynchronously outside the main application flow, allowing long-running operations to execute without blocking user interactions. The main purpose is to demonstrate how to create tasks that report their progress in real-time, so users can see how much work has been completed. This is useful for operations like batch processing, data imports, or any lengthy computation where users need feedback about completion status.",
      "technical": "Implements Celery shared tasks for asynchronous job processing in a distributed task queue system. Exports a `process` function decorated with `@celery.shared_task(bind=True)` that leverages Celery's task instance binding for state management. Uses `self.update_state()` API to publish custom \"PROGRESS\" state with metadata to task result backend. Depends on celery library for distributed task execution and time module for simulating work. Provides a simple demonstration pattern for implementing progress-tracking tasks that can be monitored by frontend applications or other consumers polling task status endpoints."
    },
    "examples/celery/src/task_app/views.py": {
      "human": "This module provides the web interface for submitting background tasks and checking their status. It acts as the bridge between users making web requests and a task queue system that processes work in the background. Users can submit different types of jobs (like adding numbers, blocking operations, or processing tasks) through web forms, and the module immediately gives them a tracking number. They can later use that tracking number to check if their job is finished and get the results, without having to wait while the work is being done.",
      "technical": "Implements Flask Blueprint endpoints that serve as the HTTP API layer for Celery task management. Provides four route handlers: three POST endpoints (`add`, `block`, `process`) that dispatch asynchronous Celery tasks via `.delay()` and return task IDs, plus one GET endpoint (`result`) that polls task status using AsyncResult. Depends on Flask for HTTP handling and celery.result for async task coordination. Acts as the presentation layer in a distributed task queue architecture, translating HTTP requests into Celery task dispatches and task states into JSON responses. No input validation or error handling implemented."
    },
    "examples/javascript/js_example/__init__.py": {
      "human": "This module serves as the package initializer for the js_example application, which appears to be a Flask-based web application demonstrating JavaScript integration. It likely imports and exposes key components from both Flask and the js_example package to make them available when the package is imported. This is a typical pattern for Flask applications to set up the application instance and make it accessible to other modules.",
      "technical": "Imports the `flask` module and components from the `js_example` package itself. As an `__init__.py` file, it defines what gets exposed when `js_example` is imported as a package. With 6 lines of code and no functions/classes, it likely contains import statements and possibly assigns module-level variables (e.g., `app = Flask(__name__)`) or defines `__all__` to control the package's public API. Acts as the entry point for the Flask application structure."
    },
    "examples/javascript/js_example/views.py": {
      "human": "This module provides a simple web calculator interface for adding two numbers together. It's designed to work as part of a JavaScript example application, where users can submit numbers through a web form and receive the calculated sum. The module handles the server-side processing of addition requests and returns results in a format that JavaScript code can easily use. It's meant to demonstrate how a web frontend can communicate with a Python backend to perform calculations.",
      "technical": "Flask view module that exposes a single HTTP endpoint for arithmetic operations. Implements a route handler decorated with @app.route that processes POST form data containing numeric operands. Uses Flask's request.form.get() for parameter extraction with type coercion and default values, and jsonify() for JSON response serialization. Serves as the backend API layer for a JavaScript frontend example, demonstrating basic Flask request/response patterns and client-server communication. No class-based views or complex routing; follows simple function-based Flask view pattern."
    },
    "examples/tutorial/flaskr/__init__.py": {
      "human": "This module serves as the main entry point and factory for creating a Flask blog application called \"flaskr\". It sets up the entire web application by configuring security settings, establishing where data will be stored, and connecting all the different features together (like user login and blog posting). It also creates the necessary folders on the computer and sets up a simple test page to confirm everything is working. Think of it as the blueprint that assembles all the pieces of the blog application into a working website.",
      "technical": "Implements the application factory pattern through the create_app() function, which instantiates and configures a Flask application instance with instance-relative configuration. Establishes default configuration for SECRET_KEY and SQLite DATABASE path, with support for test configuration override. Integrates database initialization via db module, registers auth and blog blueprints for modular routing, and defines URL mappings including root endpoint aliasing to blog.index. Returns fully configured WSGI application object ready for deployment via development server or production WSGI server."
    },
    "examples/tutorial/flaskr/auth.py": {
      "human": "This module handles all user authentication and account management for the Flask tutorial application (Flaskr). It manages user registration, login, and logout functionality, ensuring that passwords are securely stored and verified. The module also provides protection for pages that require users to be logged in, automatically redirecting unauthorized visitors to the login page. It maintains user session state throughout their visit, remembering who is logged in and making that information available across the application.",
      "technical": "Implements authentication blueprint for Flask with six core functions: registration, login/logout handlers, session management, and route protection. Provides `login_required` decorator using functools.wraps for protecting authenticated routes. Uses Flask's `g` object for request-scoped user storage and session cookies for persistent authentication state. Integrates werkzeug.security for password hashing (generate_password_hash/check_password_hash). Implements `before_app_request` hook to automatically load authenticated user data from SQLite database on each request. Exposes auth routes and decorator as reusable components for the larger Flask application."
    },
    "examples/tutorial/flaskr/blog.py": {
      "human": "This module implements the core blogging functionality for a Flask tutorial application called Flaskr. It handles everything users need to read and manage blog posts: displaying all posts on the homepage, creating new posts, editing existing posts, and deleting posts. The module ensures that only post authors can modify or delete their own content, while allowing anyone to view all published posts. It serves as the main content management system for the blog, connecting user actions to database operations.",
      "technical": "Implements a Flask Blueprint ('bp') providing five view functions for CRUD operations on blog posts. Integrates with the application's authentication system (via @login_required decorator and g.user) and database layer (via get_db()). Exposes routes for index (GET), create (GET/POST), update (GET/POST), and delete (POST) operations. Uses SQL JOIN queries to combine post and user data, implements authorization checks through get_post() helper function, and follows Flask patterns with template rendering, flash messaging, and URL redirects. Depends on auth and db modules for authentication and database connectivity."
    },
    "examples/tutorial/flaskr/db.py": {
      "human": "This module manages all database operations for the Flaskr tutorial application. It handles connecting to the SQLite database, ensuring connections are properly opened and closed during web requests, and provides tools to set up a fresh database from scratch. The module acts as a bridge between the Flask web application and the SQLite database, making sure database resources are used efficiently and cleaned up properly. It also includes a command-line tool that developers can use to initialize or reset the database when needed.",
      "technical": "Implements database lifecycle management for Flask using request-scoped connection pooling via Flask's `g` object. Provides `get_db()` as the primary API for obtaining SQLite connections with `sqlite3.Row` factory for dict-like access. Registers `close_db()` as a teardown handler to ensure connections are closed after each request context. Exposes `init_app()` integration point for Flask application factory pattern, which registers teardown handlers and CLI commands. Includes `init_db_command` Click command for schema initialization from schema.sql file. Uses `PARSE_DECLTYPES` for automatic SQLite type conversion and leverages Flask's `current_app` for resource access."
    },
    "src/flask/__init__.py": {
      "human": "This is Flask's main package initialization file that serves as the primary entry point for the Flask web framework. It aggregates and re-exports core Flask components like the application class, blueprints, configuration management, request contexts, and helper utilities. Users import Flask components from this module rather than accessing internal submodules directly, providing a clean public API.",
      "technical": "Imports and re-exports Flask's core components from submodules: `app` (Flask application class), `blueprints` (Blueprint registration), `config` (configuration management), `ctx` (4 context-related objects like request/application contexts), `globals` (4 global proxy objects like request, session, g, current_app), and `helpers` (2 utility functions like url_for, render_template). Functions as the package's `__init__.py` to establish the public API surface and namespace for the Flask framework."
    },
    "src/flask/__main__.py": {
      "human": "This module serves as the entry point for running Flask as a Python module using `python -m flask`. It enables command-line execution of Flask applications by importing and exposing the CLI interface. When invoked with `python -m flask`, this module allows users to run Flask commands like `run`, `shell`, or custom commands without directly executing a script.",
      "technical": "Imports the `cli` module from the Flask package to expose Flask's command-line interface. Acts as the `__main__.py` entry point that Python executes when the flask package is run as a module (`python -m flask`). Contains minimal code (4 lines) likely consisting of the import statement and a conditional `if __name__ == '__main__'` block that invokes the CLI main function."
    },
    "src/flask/app.py": {
      "human": "This module implements the core Flask application class, which serves as the central component of the Flask web framework. It handles the complete lifecycle of web requests, from receiving HTTP requests to sending back responses. The module manages URL routing (connecting web addresses to Python functions), renders HTML templates, serves static files like images and CSS, and handles errors gracefully. It also provides context management so that request-specific information is available throughout the application, and includes utilities for testing web applications. Essentially, this is the engine that makes Flask web applications work.",
      "technical": "The `Flask` class is the primary WSGI application implementing the request-response cycle through context managers (`AppContext`, `RequestContext`) and decorator-based routing. It integrates key dependencies including Werkzeug for WSGI/HTTP utilities, Jinja2 for templating, and Click for CLI support. The module implements the application factory pattern, supports blueprint registration for modular applications, and uses a hook-based architecture (before_request, after_request, teardown handlers) for request processing. It manages thread-local contexts via `LocalStack` and `LocalProxy`, implements error handling with registered error handlers, and provides WSGI compliance for deployment on various web servers."
    },
    "src/flask/blueprints.py": {
      "human": "This module provides the Blueprint class, which allows developers to organize Flask web applications into modular, reusable components. Blueprints act as templates that group related web pages, static files (images, CSS), templates, and command-line tools together under a single name. They can be created independently and then registered with the main application, making it easier to build large applications by breaking them into smaller, manageable pieces. Blueprints help teams work on different parts of an application simultaneously and enable code reuse across multiple projects.",
      "technical": "Implements the Blueprint class extending sansio.blueprints base classes to provide Flask-specific blueprint functionality. Exposes APIs for static file serving (send_static_file), resource file access (open_resource), and cache control configuration (get_send_file_max_age). Integrates with Flask's CLI system by creating an AppGroup instance for blueprint-specific commands. Depends on Flask's globals, helpers, and sansio.scaffold modules for core functionality. Acts as a registration container that defers route, error handler, and before/after request hook registration until blueprint attachment to the main Flask application instance."
    },
    "src/flask/cli.py": {
      "human": "This module provides the command-line interface (CLI) for Flask web applications, allowing developers to interact with their apps through terminal commands. It handles discovering and loading Flask applications from Python files, manages common development tasks like starting the development server and opening an interactive shell, and displays useful information like available routes. The module solves the problem of needing to manually write scripts for common Flask operations by providing a standardized, extensible command system that works automatically with minimal configuration.",
      "technical": "Implements Flask's CLI system through Click integration with core classes: ScriptInfo (manages app loading state), AppGroup (command grouping with app context), FlaskGroup (main CLI entry point with plugin discovery), and specialized parameter types (CertParamType, SeparatedPathType). Provides app discovery via find_best_app() and locate_app() with three-tier strategy (named attributes, module scanning, factory functions). Exposes primary commands (run, shell, routes) and supports plugin extension via importlib.metadata entry points. Integrates python-dotenv for environment configuration, manages Flask application context wrapping via with_appcontext decorator, and handles WSGI app initialization with sophisticated error recovery for reloader scenarios."
    },
    "src/flask/config.py": {
      "human": "This module manages application configuration settings for Flask web applications. It provides a flexible system for loading configuration from multiple sources like Python files, environment variables, JSON files, or Python objects. The module handles common configuration tasks like reading settings from files, filtering environment variables by prefix, converting data types automatically, and organizing settings into namespaces. It acts as a central configuration registry that applications can query throughout their lifecycle.",
      "technical": "Implements two main classes: ConfigAttribute (a descriptor for accessing config values with optional type conversion) and Config (a dict subclass managing configuration state). Config class provides multiple loader methods (from_pyfile, from_object, from_envvar, from_file, from_mapping, from_prefixed_env) that populate configuration from various sources. Depends on werkzeug.utils for import_string functionality and integrates with Flask's root_path concept for relative file resolution. Uses uppercase key filtering convention to distinguish config constants from regular attributes. Supports nested configuration via double-underscore delimited environment variables and namespace-based config subsetting via get_namespace()."
    },
    "src/flask/ctx.py": {
      "human": "This module manages Flask's context system, which keeps track of what's happening during web requests and application operations. It provides two main workspaces: one for application-level information (like configuration and global variables) and another for request-specific data (like the current user's session and URL). The module ensures that different parts of your Flask application can safely access the right information at the right time, whether handling web requests, running background tasks, or executing command-line scripts. It's like a smart filing system that automatically knows which documents you need based on what you're currently doing.",
      "technical": "Implements Flask's context management through two primary classes: `_AppCtxGlobals` (dict-like storage for application-scoped data) and `AppContext` (manages both app and request contexts). Uses Python's `contextvars` module for thread-safe context isolation via `_cv_app` context variable. Provides context manager protocol (`__enter__`/`__exit__`) and manual stack management (`push`/`pop`) with reference counting. Exposes utility functions (`has_request_context`, `has_app_context`, `after_this_request`, `copy_current_request_context`) for context inspection and manipulation. Integrates with Werkzeug for URL routing and exception handling, and Flask's signals system for lifecycle events (`appcontext_pushed`/`appcontext_popped`). Handles lazy session initialization and request teardown coordination."
    },
    "src/flask/debughelpers.py": {
      "human": "This module provides helpful debugging tools for Flask web developers by improving error messages when common mistakes occur. It detects situations like forgetting to set the correct form encoding when uploading files, accessing URLs with incorrect trailing slashes, or template files that can't be found. Instead of showing confusing technical errors, it explains what went wrong in plain language and suggests how to fix the problem, making it much easier for developers to identify and resolve issues during development.",
      "technical": "Implements debugging utilities through custom exception classes (UnexpectedUnicodeError, DebugFilesKeyError, FormDataRoutingRedirect) and diagnostic functions. Core functionality includes `attach_enctype_error_multidict()` which dynamically patches request.files with enhanced error handling via class substitution, and `explain_template_loading_attempts()` which logs detailed template loader diagnostics using Jinja2 loader introspection. Integrates with Flask's request context (globals, wrappers) and routing system (werkzeug.routing) to intercept errors at runtime and augment them with actionable debugging information. Primarily used during development mode to enhance developer experience."
    },
    "src/flask/globals.py": {
      "human": "This module provides global access points to Flask's request and application data throughout your web application. It acts as a bridge that lets any part of your code access information about the current web request (like form data or cookies) or application settings, without having to pass these objects around manually. The module also handles the transition from old naming conventions to new ones, warning developers when they use outdated names that will stop working in future versions.",
      "technical": "Implements proxy classes (ProxyMixin, FlaskProxy, AppContextProxy, _AppCtxGlobalsProxy, RequestProxy, SessionMixinProxy) that provide thread-safe access to Flask's context-local objects using werkzeug.local and contextvars. Exposes global proxy objects for accessing current_app, request, session, and g (application globals) from anywhere in the application. Module-level `__getattr__` provides backward compatibility by intercepting deprecated attribute access (request_ctx \u2192 app_ctx) with deprecation warnings. Integrates with Flask's context management system (app.ctx, ctx modules) and Werkzeug's request/session infrastructure to enable context-aware global state access patterns."
    },
    "src/flask/helpers.py": {
      "human": "This module provides essential helper utilities that Flask web applications use throughout their lifecycle. It handles common web development tasks like creating URLs to different pages, redirecting users between pages, sending files to browsers, and displaying temporary notification messages (flash messages). It also manages application configuration settings like debug mode, helps with streaming large responses while maintaining request context, and provides safe ways to serve files from the server. These utilities simplify everyday web development tasks that nearly every Flask application needs.",
      "technical": "Provides core Flask utility functions that bridge application context, request handling, and response generation. Key APIs include url_for() for URL generation, redirect()/abort() for flow control, send_file()/send_from_directory() for file serving, and flash()/get_flashed_messages() for session-based messaging. Implements stream_with_context() decorator to preserve request context during generator execution. Depends on Werkzeug for low-level HTTP utilities and Jinja2 for template integration. Functions intelligently fall back to Werkzeug implementations when Flask application context is unavailable, acting as context-aware wrappers around lower-level web framework primitives."
    },
    "src/flask/json/__init__.py": {
      "human": "This module provides Flask's JSON handling interface, allowing web applications to convert data between Python objects and JSON format. It acts as a smart wrapper that automatically uses Flask's customizable JSON settings when running inside a Flask application, or falls back to Python's standard JSON tools otherwise. This enables Flask applications to handle special data types (like dates or decimals) consistently across all JSON operations, whether reading from files, writing to files, or sending data to web browsers.",
      "technical": "Provides a unified JSON serialization/deserialization API that conditionally delegates to Flask's JSONProvider system or standard library json module based on application context availability. Exposes five functions (dumps, dump, loads, load, jsonify) that check for `current_app` existence and route accordingly. When Flask context exists, delegates to `current_app.json.*` methods to enable app-specific JSON customization; otherwise uses `_json.*` with `_default` fallback serializer. The jsonify function specifically creates Flask Response objects with proper JSON mimetype. Serves as the primary JSON interface layer between Flask applications and the underlying provider/wrappers modules."
    },
    "src/flask/json/provider.py": {
      "human": "This module handles converting Python data to and from JSON format for Flask web applications. It manages how special Python objects (like dates, decimals, and UUIDs) are converted into JSON text that can be sent over the internet or saved to files. It also creates properly formatted JSON responses that web browsers and API clients can understand, automatically making the output readable during development and compact in production. This is the core system that lets Flask applications communicate using the universal JSON data format.",
      "technical": "Defines JSONProvider abstract base class and DefaultJSONProvider concrete implementation that wraps Python's json module with Flask-specific serialization behavior. Provides dumps/loads/dump/load methods as primary API surface for JSON serialization/deserialization. Implements custom _default() handler for non-standard types (datetime, Decimal, UUID, dataclasses, __html__ objects). Integrates with Flask's response system via response() method that returns werkzeug Response objects with application/json mimetype. Uses app.debug flag to control JSON formatting (indented vs compact). Serves as pluggable serialization layer that can be customized per Flask application instance."
    },
    "src/flask/json/tag.py": {
      "human": "This module extends Flask's JSON serialization to handle Python data types that standard JSON doesn't support, like dates, UUIDs, bytes, and tuples. When saving data to JSON, it adds special markers (tags) to these complex types so they can be recognized and restored correctly when loading the data back. This solves the problem of losing type information when converting Python objects to JSON format, ensuring that a datetime object saved as JSON becomes a datetime object again (not just a string) when loaded.",
      "technical": "Implements a tagged JSON serialization system with TaggedJSONSerializer as the main coordinator and JSONTag as the base class for type-specific handlers (TagDateTime, TagUUID, TagBytes, TagTuple, etc.). Uses a registry pattern where tag handlers are registered in self.tags dict and processed in priority order via self.order list. Provides dumps()/loads() API that wraps standard json serialization with pre-serialization tagging and post-deserialization untagging via recursive scanning. Integrates with Werkzeug's http_date utilities and MarkupSafe for handling framework-specific types. Each tag handler implements check(), tag(), and to_python() methods for bidirectional type conversion."
    },
    "src/flask/logging.py": {
      "human": "This module sets up the logging system for Flask web applications so developers can track what's happening in their application. It ensures error messages always go to the right place - either to the web server's error log when handling requests, or to the console during startup. It automatically configures logging to be more detailed when the app is in debug mode, and makes sure log messages aren't lost by adding a default output destination if none exists. This gives developers visibility into their application's behavior and helps them troubleshoot problems.",
      "technical": "Provides Flask application logging infrastructure through three core utilities: `wsgi_errors_stream` (a LocalProxy that context-switches between WSGI error streams and sys.stderr), `has_level_handler()` for validating logger handler configuration across the logger hierarchy, and `create_logger()` as the primary factory function. Integrates with Python's standard logging module and Werkzeug's context-local system to provide request-aware error routing. The module bridges Flask's application context with WSGI server error streams, automatically configures debug-level logging based on app.debug flag, and ensures logger instances have appropriate handlers attached to prevent silent log loss."
    },
    "src/flask/sansio/app.py": {
      "human": "This module provides the core Flask application class that serves as the foundation for building web applications. It handles the initial setup and configuration of a Flask app, including organizing where files are stored (templates, static files, configuration), managing URL routing, and coordinating how different parts of the application work together. It allows developers to register custom functions for templates, handle errors, and organize code into modular blueprints. Essentially, it's the central control system that ties together all the pieces needed to run a Flask web application.",
      "technical": "Implements the `App` class (sans-IO base for Flask application) that manages application lifecycle, configuration, and component registration. Provides core APIs for URL routing (`add_url_rule`), blueprint registration (`register_blueprint`), Jinja2 template environment setup (`jinja_env`, template filters/tests/globals), and error handling (`_find_error_handler`, `trap_http_exception`). Uses lazy initialization patterns (`@cached_property`) for logger and Jinja environment. Integrates with Werkzeug for URL mapping and exception handling, maintains registries for view functions, blueprints, error handlers, and context processors. Serves as the configuration and coordination layer between routing, templating, and request handling subsystems."
    },
    "src/flask/sansio/blueprints.py": {
      "human": "This module provides the Blueprint system for Flask web applications, allowing developers to organize large applications into smaller, reusable components. Blueprints are like modular building blocks that can contain their own routes, templates, static files, and error handlers, which can then be plugged into the main application. The module handles the registration process, ensuring blueprints can be nested within each other and that all their functionality (routes, filters, error handlers) gets properly merged into the parent application. It solves the problem of managing complex applications by enabling a clean, hierarchical organization of features.",
      "technical": "Implements two core classes: Blueprint (extends Scaffold) for defining modular application components, and BlueprintSetupState for managing registration context. Blueprint provides decorator APIs (@route, @errorhandler, @before_request, etc.) that defer registration via record()/record_once() pattern until blueprint attachment. The register() method merges blueprint resources into Flask app dictionaries (view_functions, error_handler_spec, template_context_processors) with namespace prefixing. Supports recursive blueprint nesting with url_prefix/subdomain propagation. Uses deferred function execution pattern to allow blueprint configuration before app instantiation, with _check_setup_finished() enforcing setup-before-registration ordering."
    },
    "src/flask/sansio/scaffold.py": {
      "human": "This module provides the foundational scaffolding for Flask web applications and blueprints. It manages the core infrastructure for routing URLs to handler functions, organizing static files and templates, and registering lifecycle hooks that run before/during/after handling web requests. It acts as the base layer that both Flask applications and blueprints inherit from, providing common functionality like error handling, template rendering setup, and HTTP method decorators (GET, POST, etc.). Essentially, it's the shared foundation that makes Flask's modular architecture possible.",
      "technical": "Implements the Scaffold base class that provides shared functionality for Flask apps and blueprints. Manages five key registration systems: view_functions dict for route handlers, error_handler_spec for exception handlers, and defaultdict collections for request lifecycle hooks (before_request, after_request, teardown_request, url_value_preprocessors, url_default_functions). Provides decorator APIs (@route, @get, @post, @errorhandler, etc.) and core methods like add_url_rule() for URL registration. Uses setupmethod decorator to enforce configuration ordering constraints. Integrates with Jinja2 via FileSystemLoader for template resolution and handles static file path resolution using importlib introspection."
    },
    "src/flask/sessions.py": {
      "human": "This module manages user sessions in Flask web applications - the mechanism that remembers information about visitors as they navigate between pages. It handles storing session data securely in browser cookies using encryption and digital signatures to prevent tampering. The module provides both regular sessions (that persist across browser visits) and temporary sessions (that expire when the browser closes), while also offering a safe \"null session\" mode when security isn't properly configured. It controls all cookie security settings like HTTPS-only transmission, JavaScript access restrictions, and expiration times.",
      "technical": "Implements Flask's session management system through SessionInterface abstract base class and SecureCookieSessionInterface concrete implementation. SecureCookieSession extends CallbackDict with modification tracking via SessionMixin. Uses itsdangerous.URLSafeTimedSerializer for cryptographic signing/verification of cookie data with configurable hash algorithms (defaults to lazy-loaded SHA-1). Provides open_session()/save_session() lifecycle hooks for request/response processing, with NullSession as null-object pattern for unconfigured apps. Integrates with Flask's config system for all cookie attributes (domain, path, httponly, secure, samesite, partitioned) and supports secret key rotation via fallback keys."
    },
    "src/flask/signals.py": {
      "human": "This module defines Flask's signal system by creating named signals that allow different parts of a Flask application to communicate through event notifications. It provides signals for common Flask events like request handling, template rendering, and application lifecycle events. These signals enable loose coupling between components by allowing subscribers to react to specific events without direct dependencies.",
      "technical": "Imports the `blinker` library to create signal instances and defines Flask-specific signals as module-level variables (e.g., `request_started`, `request_finished`, `template_rendered`, `before_render_template`, `request_tearing_down`, `got_request_exception`, `appcontext_tearing_down`, `appcontext_pushed`, `appcontext_popped`, `message_flashed`). These signal objects are exported for use throughout Flask's core and extensions, implementing the observer pattern for Flask's event system."
    },
    "src/flask/templating.py": {
      "human": "This module handles all template rendering for Flask web applications. It manages how HTML pages and other templates are filled with dynamic data before being sent to users' browsers. The module provides functions to render templates from files or strings, supports streaming content piece-by-piece for faster page loads, and automatically makes common variables (like user session data and request information) available to all templates. It also coordinates with Flask's blueprint system to find templates across different parts of an application.",
      "technical": "Implements custom Jinja2 Environment subclass and DispatchingJinjaLoader for Flask's template system. Provides primary rendering APIs: render_template(), render_template_string(), stream_template(), and stream_template_string(). Environment class overrides get_source() to search templates across app and blueprints via _iter_loaders(). Integrates with Flask's signal system (before_render_template, template_rendered) and context management (app context, request context). DispatchingJinjaLoader aggregates multiple template loaders from blueprints. Includes _default_template_ctx_processor for automatic context injection of g, request, and session objects into all templates."
    },
    "src/flask/testing.py": {
      "human": "This module provides testing utilities for Flask web applications, making it easy to write automated tests without running a real web server. It includes tools to simulate HTTP requests (like clicking links or submitting forms), manage test sessions (like logging in users), and run command-line commands in a test environment. The module handles all the complexity of creating fake web requests and managing application state during testing, so developers can focus on verifying their application behaves correctly.",
      "technical": "Implements three primary classes: EnvironBuilder (extends Werkzeug's builder for Flask-specific request construction), FlaskClient (test client for simulating HTTP requests with session management), and FlaskCliRunner (for testing Click CLI commands). FlaskClient provides open() method as main API for request simulation, session_transaction() context manager for session manipulation, and context preservation via _new_contexts list. Integrates with Werkzeug's test utilities and Click's testing framework. Uses context manager protocol (__enter__/__exit__) for proper resource cleanup and implements lazy version checking for Werkzeug compatibility."
    },
    "src/flask/typing.py": {
      "human": "This module serves as a type definitions file for Flask's type hinting system. It provides type aliases and protocol definitions that enable static type checking throughout the Flask framework. The module helps developers write type-safe Flask applications by defining common types for WSGI applications, request/response objects, and Werkzeug data structures.",
      "technical": "Imports typing utilities from `__future__`, `collections.abc`, and `typing` modules, along with WSGI type stubs from `_typeshed.wsgi` and Werkzeug's data structures and response types. Defines type aliases for Flask-specific constructs like response types, header collections, and WSGI application callables. Acts as a centralized typing module that other Flask components import to maintain consistent type annotations across the framework's codebase."
    },
    "src/flask/views.py": {
      "human": "This module provides the foundation for creating class-based views in Flask web applications. Instead of writing individual functions for each webpage, developers can organize related request handlers into classes. The module automatically figures out which HTTP methods (GET, POST, etc.) each view class supports by examining its methods, and converts these classes into functions that Flask's routing system can use. It handles the complexity of dispatching incoming web requests to the right method and managing whether view instances are created once or per-request.",
      "technical": "Implements two base classes: View (basic class-based view) and MethodView (HTTP method-based routing). Provides as_view() class method that converts view classes into RouteCallable functions compatible with Flask's routing system. Uses __init_subclass__ hook to auto-populate the methods attribute by introspecting HTTP method handlers (get, post, etc.). The dispatch_request() method performs dynamic method dispatch using getattr() with HEAD-to-GET fallback logic. Integrates with Flask's current_app.ensure_sync() for async/sync compatibility and supports decorator chains via cls.decorators attribute for middleware-style request processing."
    },
    "src/flask/wrappers.py": {
      "human": "This module customizes how Flask handles incoming web requests and outgoing responses. It wraps the underlying Werkzeug request/response objects to add Flask-specific features like accessing blueprint information, enforcing size limits on uploaded files and form data, and providing better error messages during development. It acts as the bridge between raw HTTP data and Flask's application logic, ensuring requests are safely processed and responses are properly formatted before being sent back to users.",
      "technical": "Implements Request and Response wrapper classes that extend werkzeug.wrappers with Flask-specific functionality. Request class adds properties for routing metadata (endpoint, blueprint, blueprints), enforces configurable limits via max_content_length/max_form_memory_size/max_form_parts properties that read from Flask app config, and enhances error handling in _load_form_data() and on_json_loading_failed() with debug-mode-aware messages. Response class provides max_cookie_size property with app-context-aware configuration fallback. Uses three-tier property resolution pattern: instance attribute \u2192 parent class \u2192 Flask app config, integrating with Flask's globals module for app context access."
    }
  },
  "repo_summary": {
    "human": "Flask is a lightweight web framework for Python that helps developers build websites and web applications. It provides the essential tools needed to handle web requests, render HTML pages, manage user sessions, and organize code into reusable components. Flask is designed to be simple and flexible, making it easy for beginners to start building web apps while giving experienced developers the freedom to structure their applications however they want. It's widely used for everything from small personal projects to large-scale web services, and includes built-in development tools like a test server and debugging helpers.",
    "technical": "Implements a WSGI-compliant web framework with modular architecture centered around the Flask application class. Core components include: request/response handling via Werkzeug integration, Jinja2-based template rendering, URL routing with decorator-based view registration, and context management using contextvars for thread-safe request/application state. Supports application modularity through Blueprint system for component registration and namespace isolation. Provides session management via cryptographically-signed cookies (itsdangerous), CLI integration through Click, signal-based event system (blinker), and comprehensive testing utilities. Uses application factory pattern, context managers for resource lifecycle, and proxy objects for global state access. Includes pluggable JSON serialization, file serving utilities, and development-mode debugging enhancements."
  },
  "dead_code_analysis": {
    "unreferenced_functions": [
      {
        "name": "setup",
        "module": "docs/conf.py",
        "lineno": 100,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "config",
          "reason": "This is a Sphinx documentation configuration function in docs/conf.py. Sphinx automatically calls the setup() function to register custom roles and extensions during documentation generation.",
          "recommendation": "keep",
          "evidence": [
            "Located in docs/conf.py which is a Sphinx configuration file",
            "Standard Sphinx pattern where setup(app) is called automatically by the documentation build system"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Sphinx documentation configuration function in docs/conf.py. Sphinx automatically calls the setup() function to register custom roles and extensions during documentation generation.",
        "recommendation": "keep"
      },
      {
        "name": "block",
        "module": "examples/celery/src/task_app/tasks.py",
        "lineno": 13,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This function is decorated with @shared_task, making it a Celery task. Celery tasks are invoked asynchronously through the Celery framework, not directly called in code.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @shared_task which registers it as a Celery task",
            "Celery tasks are called via .delay() or .apply_async() methods from other parts of the application"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This function is decorated with @shared_task, making it a Celery task. Celery tasks are invoked asynchronously through the Celery framework, not directly called in code.",
        "recommendation": "keep"
      },
      {
        "name": "process",
        "module": "examples/celery/src/task_app/tasks.py",
        "lineno": 18,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This function is decorated with @shared_task, making it a Celery task that gets executed by Celery workers. The function is called asynchronously through the Celery framework, not directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @shared_task which registers it as a Celery task",
            "Celery tasks are invoked through the task queue system, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This function is decorated with @shared_task, making it a Celery task that gets executed by Celery workers. The function is called asynchronously through the Celery framework, not directly in code.",
        "recommendation": "keep"
      },
      {
        "name": "block",
        "module": "examples/celery/src/task_app/views.py",
        "lineno": 30,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @bp.post, making it a Flask route handler. Flask automatically calls this function when POST requests are made to the corresponding endpoint.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @bp.post which registers it as a Flask POST route handler",
            "Function calls tasks.block.delay() indicating it triggers the Celery task"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @bp.post, making it a Flask route handler. Flask automatically calls this function when POST requests are made to the corresponding endpoint.",
        "recommendation": "keep"
      },
      {
        "name": "process",
        "module": "examples/celery/src/task_app/views.py",
        "lineno": 36,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @bp.post, making it a Flask route handler. Flask automatically invokes this function when POST requests hit the corresponding route.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @bp.post which registers it as a Flask POST route handler",
            "Function calls tasks.process.delay() indicating it triggers the Celery task"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @bp.post, making it a Flask route handler. Flask automatically invokes this function when POST requests hit the corresponding route.",
        "recommendation": "keep"
      },
      {
        "name": "login_required",
        "module": "examples/tutorial/flaskr/auth.py",
        "lineno": 19,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This is a decorator function used to wrap view functions. Decorators are typically applied using @ syntax which may not show up as direct function calls in static analysis. The docstring indicates it's meant to be used as a view decorator.",
          "recommendation": "keep",
          "evidence": [
            "Function is a decorator that wraps other functions",
            "Docstring explicitly describes it as a 'View decorator'",
            "Located in auth.py suggesting it's part of authentication system"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a decorator function used to wrap view functions. Decorators are typically applied using @ syntax which may not show up as direct function calls in static analysis. The docstring indicates it's meant to be used as a view decorator.",
        "recommendation": "keep"
      },
      {
        "name": "load_logged_in_user",
        "module": "examples/tutorial/flaskr/auth.py",
        "lineno": 33,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This function is decorated with @bp.before_app_request, making it a Flask hook that runs before each request. Flask automatically calls these decorated functions, so no direct calls in code are expected.",
          "recommendation": "keep",
          "evidence": [
            "Has @bp.before_app_request decorator",
            "Flask hook functions are called automatically by the framework",
            "Docstring describes session-based user loading functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This function is decorated with @bp.before_app_request, making it a Flask hook that runs before each request. Flask automatically calls these decorated functions, so no direct calls in code are expected.",
        "recommendation": "keep"
      },
      {
        "name": "_make_timedelta",
        "module": "src/flask/app.py",
        "lineno": 72,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 80,
          "category": "genuinely_unused",
          "reason": "This is a private utility function (prefixed with underscore) that appears to have no callers in the codebase. Since this is an application project, all code should be called somewhere internally.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Private function (underscore prefix) with no apparent callers",
            "Simple utility function that should show usage if actually needed",
            "No decorators or special patterns indicating external usage"
          ]
        },
        "status": "dead_code",
        "confidence": 80,
        "reason": "This is a private utility function (prefixed with underscore) that appears to have no callers in the codebase. Since this is an application project, all code should be called somewhere internally.",
        "recommendation": "safe_to_delete"
      },
      {
        "name": "open_instance_resource",
        "module": "src/flask/app.py",
        "lineno": 446,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a method of the Flask class which is exported and well-documented with detailed docstring. It's part of Flask's public API for opening instance resource files, even if not used internally in this specific application.",
          "recommendation": "keep",
          "evidence": [
            "Method of exported Flask class with comprehensive docstring",
            "Part of Flask's resource management public API",
            "Documented parameters and clear public interface design"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a method of the Flask class which is exported and well-documented with detailed docstring. It's part of Flask's public API for opening instance resource files, even if not used internally in this specific application.",
        "recommendation": "keep"
      },
      {
        "name": "test_client",
        "module": "src/flask/app.py",
        "lineno": 754,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core method of the Flask class for creating test clients. It's a well-documented public API method that users rely on for testing Flask applications, even if not called internally within the framework code itself.",
          "recommendation": "keep",
          "evidence": [
            "Method of exported Flask class with detailed testing documentation",
            "Core testing functionality that external users depend on",
            "References documentation (:doc:`/testing`) indicating public API status"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core method of the Flask class for creating test clients. It's a well-documented public API method that users rely on for testing Flask applications, even if not called internally within the framework code itself.",
        "recommendation": "keep"
      },
      {
        "name": "test_cli_runner",
        "module": "src/flask/app.py",
        "lineno": 812,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a public API method of the Flask class for creating CLI test runners. Flask apps are used by external users who need this method for testing CLI commands in their applications.",
          "recommendation": "keep",
          "evidence": [
            "Method is part of exported Flask class with comprehensive docstring",
            "Explicitly mentioned for testing CLI commands with version annotation",
            "Flask is a web framework where this method would be called by application developers"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a public API method of the Flask class for creating CLI test runners. Flask apps are used by external users who need this method for testing CLI commands in their applications.",
        "recommendation": "keep"
      },
      {
        "name": "_path_is_ancestor",
        "module": "src/flask/cli.py",
        "lineno": 691,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This is a private utility function that appears to be unused internally. No evidence of it being called elsewhere in the codebase, and being prefixed with underscore indicates internal use only.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "Function name starts with underscore indicating private/internal use",
            "No clear integration points or callback patterns visible",
            "Appears to be a standalone utility function with no callers"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This is a private utility function that appears to be unused internally. No evidence of it being called elsewhere in the codebase, and being prefixed with underscore indicates internal use only.",
        "recommendation": "safe_to_delete"
      },
      {
        "name": "from_envvar",
        "module": "src/flask/config.py",
        "lineno": 102,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a public API method of the exported Config class that allows loading configuration from environment variables. This is a common pattern Flask users would employ for configuration management.",
          "recommendation": "keep",
          "evidence": [
            "Method of exported Config class with detailed docstring and parameter documentation",
            "Configuration loading from environment variables is standard Flask usage pattern",
            "Well-documented public API for external application developers"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a public API method of the exported Config class that allows loading configuration from environment variables. This is a common pattern Flask users would employ for configuration management.",
        "recommendation": "keep"
      },
      {
        "name": "from_file",
        "module": "src/flask/config.py",
        "lineno": 256,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a public API method of the exported Config class for loading configuration from files with custom loaders. The detailed docstring with code examples indicates it's intended for external use.",
          "recommendation": "keep",
          "evidence": [
            "Method of exported Config class with comprehensive docstring and code examples",
            "Flexible file loading mechanism that Flask users would need for various config formats",
            "Part of Flask's configuration management public API"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a public API method of the exported Config class for loading configuration from files with custom loaders. The detailed docstring with code examples indicates it's intended for external use.",
        "recommendation": "keep"
      },
      {
        "name": "get_namespace",
        "module": "src/flask/config.py",
        "lineno": 323,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a public API method of the exported Config class for extracting configuration subsets by namespace/prefix. The detailed docstring with usage examples shows it's designed for external consumption.",
          "recommendation": "keep",
          "evidence": [
            "Method of exported Config class with detailed usage examples in docstring",
            "Common configuration pattern for organizing related settings by namespace",
            "Public API that Flask application developers would use for config organization"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a public API method of the exported Config class for extracting configuration subsets by namespace/prefix. The detailed docstring with usage examples shows it's designed for external consumption.",
        "recommendation": "keep"
      },
      {
        "name": "_make_timedelta",
        "module": "src/flask/sansio/app.py",
        "lineno": 52,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This is a utility function with an underscore prefix indicating internal use. It converts int/timedelta/None values to timedelta objects, which is a common pattern in Flask for configuration values like timeouts.",
          "recommendation": "keep",
          "evidence": [
            "Function has underscore prefix indicating internal utility",
            "Handles common Flask pattern of accepting both int seconds and timedelta objects"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a utility function with an underscore prefix indicating internal use. It converts int/timedelta/None values to timedelta objects, which is a common pattern in Flask for configuration values like timeouts.",
        "recommendation": "keep"
      },
      {
        "name": "template_filter",
        "module": "src/flask/sansio/app.py",
        "lineno": 661,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is a typing overload for the template_filter method in Flask's App class. Overloads are used purely for static type checking and are not actual runtime code.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating typing overload",
            "Part of Flask's template filter registration system"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for the template_filter method in Flask's App class. Overloads are used purely for static type checking and are not actual runtime code.",
        "recommendation": "keep"
      },
      {
        "name": "template_filter",
        "module": "src/flask/sansio/app.py",
        "lineno": 663,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is another typing overload for the template_filter method. Multiple overloads provide different type signatures for the same method to support various usage patterns.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating typing overload",
            "Provides alternative type signature for template filter registration"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is another typing overload for the template_filter method. Multiple overloads provide different type signatures for the same method to support various usage patterns.",
        "recommendation": "keep"
      },
      {
        "name": "template_filter",
        "module": "src/flask/sansio/app.py",
        "lineno": 667,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is the third typing overload for template_filter method. All overloads work together to provide comprehensive type hints for different ways this method can be called.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating typing overload",
            "Part of complete type signature definition for template_filter method"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the third typing overload for template_filter method. All overloads work together to provide comprehensive type hints for different ways this method can be called.",
        "recommendation": "keep"
      },
      {
        "name": "template_test",
        "module": "src/flask/sansio/app.py",
        "lineno": 711,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is a typing overload for the template_test method in Flask's App class. Similar to template_filter, this is used for type checking template test registration.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating typing overload",
            "Part of Flask's template test registration system type definitions"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for the template_test method in Flask's App class. Similar to template_filter, this is used for type checking template test registration.",
        "recommendation": "keep"
      },
      {
        "name": "template_test",
        "module": "src/flask/sansio/app.py",
        "lineno": 713,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is a typing overload for the template_test method, which is a decorator function used in Flask applications. Overloads are used by type checkers to provide better type hints and are not meant to be called directly.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Part of Flask's template system which provides decorator functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for the template_test method, which is a decorator function used in Flask applications. Overloads are used by type checkers to provide better type hints and are not meant to be called directly.",
        "recommendation": "keep"
      },
      {
        "name": "template_test",
        "module": "src/flask/sansio/app.py",
        "lineno": 717,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is another typing overload for the template_test method. Multiple overloads allow the type system to handle different calling patterns for the same decorator method.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Multiple overloads are common for decorator methods that can be called with or without arguments"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is another typing overload for the template_test method. Multiple overloads allow the type system to handle different calling patterns for the same decorator method.",
        "recommendation": "keep"
      },
      {
        "name": "template_global",
        "module": "src/flask/sansio/app.py",
        "lineno": 770,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is a typing overload for the template_global method, which is a decorator function in Flask for registering global template functions. Overloads provide type hints for different usage patterns.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Part of Flask's template system for registering global template functions"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for the template_global method, which is a decorator function in Flask for registering global template functions. Overloads provide type hints for different usage patterns.",
        "recommendation": "keep"
      },
      {
        "name": "template_global",
        "module": "src/flask/sansio/app.py",
        "lineno": 772,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "Another typing overload for template_global decorator method. These overloads help type checkers understand the different ways this decorator can be used.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Sequential overloads are necessary for proper type checking of decorator methods"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Another typing overload for template_global decorator method. These overloads help type checkers understand the different ways this decorator can be used.",
        "recommendation": "keep"
      },
      {
        "name": "template_global",
        "module": "src/flask/sansio/app.py",
        "lineno": 776,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "Third typing overload for template_global decorator method. Multiple overloads allow the type system to handle various calling conventions for this Flask template decorator.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Part of a series of overloads for the same decorator method"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Third typing overload for template_global decorator method. Multiple overloads allow the type system to handle various calling conventions for this Flask template decorator.",
        "recommendation": "keep"
      },
      {
        "name": "shell_context_processor",
        "module": "src/flask/sansio/app.py",
        "lineno": 855,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a decorator method used to register shell context processors in Flask applications. It's part of Flask's public API and would be called by application developers to register functions that provide context for the Flask shell.",
          "recommendation": "keep",
          "evidence": [
            "Has @setupmethod decorator indicating it's part of Flask's setup API",
            "Method signature and docstring indicate it's a registration decorator",
            "Flask shell context processors are a documented feature used by developers"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a decorator method used to register shell context processors in Flask applications. It's part of Flask's public API and would be called by application developers to register functions that provide context for the Flask shell.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_filter",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 444,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a typing overload for the app_template_filter method in Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints and are not meant to be called directly.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Blueprint class is exported and part of Flask's public API",
            "Overloads are necessary for proper type checking in Flask applications"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for the app_template_filter method in Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints and are not meant to be called directly.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_filter",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 446,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is another typing overload for the app_template_filter method. Like other overloads, it provides type information for different usage patterns of the same method.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Part of Blueprint's public API for template filter registration",
            "Multiple overloads suggest different parameter combinations are supported"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is another typing overload for the app_template_filter method. Like other overloads, it provides type information for different usage patterns of the same method.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_filter",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 450,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is the third typing overload for app_template_filter method. It complements the other overloads to provide complete type coverage for all supported usage patterns.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Blueprint class is exported making this part of public API",
            "Template filter registration is a core Flask Blueprint feature"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is the third typing overload for app_template_filter method. It complements the other overloads to provide complete type coverage for all supported usage patterns.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_test",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 498,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a typing overload for the app_template_test method in Blueprint class. It provides type hints for registering template tests at the application level from blueprints.",
          "recommendation": "keep",
          "evidence": [
            "Has @t.overload decorator indicating it's a typing overload",
            "Blueprint is exported class with public API methods",
            "Template test registration is a documented Flask feature"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for the app_template_test method in Blueprint class. It provides type hints for registering template tests at the application level from blueprints.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_test",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 500,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
          "recommendation": "keep",
          "evidence": [
            "Method has @t.overload decorator indicating it's a typing overload",
            "Blueprint class is exported and part of Flask's public API",
            "Overloads are never called directly - they guide type checking"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_test",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 504,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
          "recommendation": "keep",
          "evidence": [
            "Method has @t.overload decorator indicating it's a typing overload",
            "Blueprint class is exported and part of Flask's public API",
            "Overloads are never called directly - they guide type checking"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_global",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 556,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
          "recommendation": "keep",
          "evidence": [
            "Method has @t.overload decorator indicating it's a typing overload",
            "Blueprint class is exported and part of Flask's public API",
            "Overloads are never called directly - they guide type checking"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_global",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 558,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
          "recommendation": "keep",
          "evidence": [
            "Method has @t.overload decorator indicating it's a typing overload",
            "Blueprint class is exported and part of Flask's public API",
            "Overloads are never called directly - they guide type checking"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
        "recommendation": "keep"
      },
      {
        "name": "app_template_global",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 562,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
          "recommendation": "keep",
          "evidence": [
            "Method has @t.overload decorator indicating it's a typing overload",
            "Blueprint class is exported and part of Flask's public API",
            "Overloads are never called directly - they guide type checking"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a typing overload for a public API method in Flask's Blueprint class. Overloads are used by type checkers and IDEs to provide better type hints, not for runtime execution.",
        "recommendation": "keep"
      },
      {
        "name": "before_app_request",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 614,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator method in the Blueprint class that Flask users call to register functions that run before every request in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
          "recommendation": "keep",
          "evidence": [
            "Method is decorated with @setupmethod indicating it's part of Flask's setup API",
            "Blueprint class is exported and this method provides functionality equivalent to Flask.before_request",
            "Decorator methods like this are called by user code to register callbacks, not internally by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator method in the Blueprint class that Flask users call to register functions that run before every request in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
        "recommendation": "keep"
      },
      {
        "name": "after_app_request",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 624,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator method in the Blueprint class that Flask users call to register functions that run after every request in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
          "recommendation": "keep",
          "evidence": [
            "Method is decorated with @setupmethod indicating it's part of Flask's setup API",
            "Blueprint class is exported and this method provides functionality equivalent to Flask.after_request",
            "Decorator methods like this are called by user code to register callbacks, not internally by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator method in the Blueprint class that Flask users call to register functions that run after every request in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
        "recommendation": "keep"
      },
      {
        "name": "teardown_app_request",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 634,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator method in the Blueprint class that Flask users call to register teardown functions that run after every request in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
          "recommendation": "keep",
          "evidence": [
            "Method is decorated with @setupmethod indicating it's part of Flask's setup API",
            "Blueprint class is exported and this method provides functionality equivalent to Flask.teardown_request",
            "Decorator methods like this are called by user code to register teardown handlers, not internally by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator method in the Blueprint class that Flask users call to register teardown functions that run after every request in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
        "recommendation": "keep"
      },
      {
        "name": "app_context_processor",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 644,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator method in the Blueprint class that Flask users call to register template context processors for all views in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
          "recommendation": "keep",
          "evidence": [
            "Method is decorated with @setupmethod indicating it's part of Flask's setup API",
            "Blueprint class is exported and this method provides functionality equivalent to Flask.context_processor",
            "Decorator methods like this are called by user code to register context processors, not internally by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator method in the Blueprint class that Flask users call to register template context processors for all views in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
        "recommendation": "keep"
      },
      {
        "name": "app_errorhandler",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 656,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator method in the Blueprint class that Flask users call to register error handlers for all requests in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
          "recommendation": "keep",
          "evidence": [
            "Method is decorated with @setupmethod indicating it's part of Flask's setup API",
            "Blueprint class is exported and this method provides functionality equivalent to Flask.errorhandler",
            "Decorator methods like this are called by user code to register error handlers, not internally by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator method in the Blueprint class that Flask users call to register error handlers for all requests in the app. The @setupmethod decorator indicates it's part of Flask's public API for configuring blueprints.",
        "recommendation": "keep"
      },
      {
        "name": "app_url_value_preprocessor",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 673,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a method of the Blueprint class which is exported. It's a decorator method (has @setupmethod) that provides public API functionality for Flask blueprints. Users would call this to register URL value preprocessors at the app level.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint class is exported and this is a public method",
            "Has @setupmethod decorator indicating it's part of Flask's setup API",
            "Well-documented with clear public API purpose"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a method of the Blueprint class which is exported. It's a decorator method (has @setupmethod) that provides public API functionality for Flask blueprints. Users would call this to register URL value preprocessors at the app level.",
        "recommendation": "keep"
      },
      {
        "name": "app_url_defaults",
        "module": "src/flask/sansio/blueprints.py",
        "lineno": 685,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a method of the Blueprint class which is exported. It's a decorator method (has @setupmethod) that provides public API functionality for Flask blueprints. Users would call this to register URL defaults at the app level.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint class is exported and this is a public method",
            "Has @setupmethod decorator indicating it's part of Flask's setup API",
            "Well-documented with clear public API purpose"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a method of the Blueprint class which is exported. It's a decorator method (has @setupmethod) that provides public API functionality for Flask blueprints. Users would call this to register URL defaults at the app level.",
        "recommendation": "keep"
      },
      {
        "name": "setupmethod",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 42,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This is a decorator function used throughout the Flask codebase to wrap setup methods. It's used by other methods like the ones above and provides runtime checking functionality. It's infrastructure code that supports the framework.",
          "recommendation": "keep",
          "evidence": [
            "Used as @setupmethod decorator on other methods in the codebase",
            "Provides runtime checking with _check_setup_finished calls",
            "Infrastructure function supporting Flask's setup pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a decorator function used throughout the Flask codebase to wrap setup methods. It's used by other methods like the ones above and provides runtime checking functionality. It's infrastructure code that supports the framework.",
        "recommendation": "keep"
      },
      {
        "name": "put",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 312,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This is a method of the Scaffold class that provides a convenient decorator for HTTP PUT routes. Even though Scaffold itself isn't exported, it's a base class for Blueprint and Flask classes that are exported, making this part of the public API.",
          "recommendation": "keep",
          "evidence": [
            "HTTP method shortcut decorator - common pattern for web frameworks",
            "Has @setupmethod decorator indicating it's part of Flask's routing API",
            "Version added in 2.0 indicates it's intentional public API"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This is a method of the Scaffold class that provides a convenient decorator for HTTP PUT routes. Even though Scaffold itself isn't exported, it's a base class for Blueprint and Flask classes that are exported, making this part of the public API.",
        "recommendation": "keep"
      },
      {
        "name": "delete",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 320,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This is a method of the Scaffold class that provides a convenient decorator for HTTP DELETE routes. Even though Scaffold itself isn't exported, it's a base class for Blueprint and Flask classes that are exported, making this part of the public API.",
          "recommendation": "keep",
          "evidence": [
            "HTTP method shortcut decorator - common pattern for web frameworks",
            "Has @setupmethod decorator indicating it's part of Flask's routing API",
            "Version added in 2.0 indicates it's intentional public API"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This is a method of the Scaffold class that provides a convenient decorator for HTTP DELETE routes. Even though Scaffold itself isn't exported, it's a base class for Blueprint and Flask classes that are exported, making this part of the public API.",
        "recommendation": "keep"
      },
      {
        "name": "patch",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 328,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator method for HTTP PATCH routes in Flask's Scaffold class. It's designed to be used as @app.patch('/route') by Flask application developers. The @setupmethod decorator indicates it's part of Flask's public API setup interface.",
          "recommendation": "keep",
          "evidence": [
            "Method is a decorator for HTTP PATCH routes (@app.patch usage pattern)",
            "Has @setupmethod decorator indicating it's part of Flask's setup API",
            "Well-documented with version info, typical of public API methods"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator method for HTTP PATCH routes in Flask's Scaffold class. It's designed to be used as @app.patch('/route') by Flask application developers. The @setupmethod decorator indicates it's part of Flask's public API setup interface.",
        "recommendation": "keep"
      },
      {
        "name": "before_request",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 460,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Flask hook decorator that registers functions to run before each request. It's used as @app.before_request by Flask developers to register callback functions. The @setupmethod decorator confirms it's part of Flask's public hook system.",
          "recommendation": "keep",
          "evidence": [
            "Hook decorator for registering before-request callbacks",
            "Has @setupmethod decorator indicating setup API functionality",
            "Documentation shows clear usage pattern with code examples"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask hook decorator that registers functions to run before each request. It's used as @app.before_request by Flask developers to register callback functions. The @setupmethod decorator confirms it's part of Flask's public hook system.",
        "recommendation": "keep"
      },
      {
        "name": "after_request",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 487,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Flask hook decorator that registers functions to run after each request. It's used as @app.after_request by Flask developers to register response processing callbacks. The @setupmethod decorator indicates it's part of Flask's public hook API.",
          "recommendation": "keep",
          "evidence": [
            "Hook decorator for registering after-request callbacks",
            "Has @setupmethod decorator indicating setup API functionality",
            "Well-documented Flask hook pattern for response modification"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask hook decorator that registers functions to run after each request. It's used as @app.after_request by Flask developers to register response processing callbacks. The @setupmethod decorator indicates it's part of Flask's public hook API.",
        "recommendation": "keep"
      },
      {
        "name": "teardown_request",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 508,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Flask hook decorator that registers cleanup functions to run when request context is popped. It's used as @app.teardown_request by Flask developers for cleanup tasks. The @setupmethod decorator confirms it's part of Flask's public teardown hook system.",
          "recommendation": "keep",
          "evidence": [
            "Hook decorator for registering request teardown callbacks",
            "Has @setupmethod decorator indicating setup API functionality",
            "Documentation includes code examples showing typical usage pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask hook decorator that registers cleanup functions to run when request context is popped. It's used as @app.teardown_request by Flask developers for cleanup tasks. The @setupmethod decorator confirms it's part of Flask's public teardown hook system.",
        "recommendation": "keep"
      },
      {
        "name": "context_processor",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 542,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Flask decorator that registers template context processor functions. It's used as @app.context_processor by Flask developers to add variables to template contexts. The @setupmethod decorator indicates it's part of Flask's public template processing API.",
          "recommendation": "keep",
          "evidence": [
            "Template context processor decorator for Flask applications",
            "Has @setupmethod decorator indicating setup API functionality",
            "Well-documented Flask feature for template variable injection"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask decorator that registers template context processor functions. It's used as @app.context_processor by Flask developers to add variables to template contexts. The @setupmethod decorator indicates it's part of Flask's public template processing API.",
        "recommendation": "keep"
      },
      {
        "name": "url_value_preprocessor",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 559,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a decorator method marked with @setupmethod that registers URL value preprocessors in Flask applications. It's part of Flask's public API for configuring request preprocessing behavior.",
          "recommendation": "keep",
          "evidence": [
            "Has @setupmethod decorator indicating it's part of Flask's configuration API",
            "Well-documented public method for registering URL value preprocessors",
            "Part of Scaffold class which is Flask's core routing infrastructure"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a decorator method marked with @setupmethod that registers URL value preprocessors in Flask applications. It's part of Flask's public API for configuring request preprocessing behavior.",
        "recommendation": "keep"
      },
      {
        "name": "_lazy_sha1",
        "module": "src/flask/sessions.py",
        "lineno": 290,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This utility function is designed to defer SHA-1 access until runtime to handle FIPS builds. The underscore prefix suggests internal use, but it's likely called indirectly or used as a factory function.",
          "recommendation": "keep",
          "evidence": [
            "Specifically designed to handle FIPS compliance issues with SHA-1",
            "Documentation explains its purpose for deferred hashlib access",
            "Utility function that may be used as a callback or factory"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This utility function is designed to defer SHA-1 access until runtime to handle FIPS builds. The underscore prefix suggests internal use, but it's likely called indirectly or used as a factory function.",
        "recommendation": "keep"
      },
      {
        "name": "permanent",
        "module": "src/flask/sessions.py",
        "lineno": 33,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is a property method on SessionMixin that provides access to session permanence state. Properties are accessed like attributes and may not show up in direct call analysis.",
          "recommendation": "keep",
          "evidence": [
            "Decorated with @property making it an attribute-like interface",
            "Part of SessionMixin which provides session functionality",
            "Provides access to '_permanent' key in session dict"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a property method on SessionMixin that provides access to session permanence state. Properties are accessed like attributes and may not show up in direct call analysis.",
        "recommendation": "keep"
      },
      {
        "name": "_fail",
        "module": "src/flask/sessions.py",
        "lineno": 103,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method is part of NullSession class and likely overrides methods from SecureCookieSession to raise errors when no secret key is set. It's probably called through method dispatch.",
          "recommendation": "keep",
          "evidence": [
            "Part of NullSession which inherits from SecureCookieSession",
            "Designed to raise runtime errors when session operations are attempted without proper configuration",
            "Takes *args, **kwargs suggesting it overrides multiple method signatures"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is part of NullSession class and likely overrides methods from SecureCookieSession to raise errors when no secret key is set. It's probably called through method dispatch.",
        "recommendation": "keep"
      },
      {
        "name": "_default_template_ctx_processor",
        "module": "src/flask/templating.py",
        "lineno": 21,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This is a template context processor function that gets registered with Flask's templating system. Context processors are called automatically by the template engine, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Function name and documentation indicate it's a template context processor",
            "Injects common variables (request, session, g) into template context",
            "Called automatically by Flask's templating system during template rendering"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a template context processor function that gets registered with Flask's templating system. Context processors are called automatically by the template engine, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "name": "json_dumps",
        "module": "src/flask/testing.py",
        "lineno": 88,
        "llm_analysis": {
          "status": "dead_code",
          "confidence": 85,
          "category": "genuinely_unused",
          "reason": "This method in EnvironBuilder class is not exported and appears to be unused internally. Flask applications would typically use the app's JSON serialization directly rather than through the test environment builder.",
          "recommendation": "safe_to_delete",
          "evidence": [
            "EnvironBuilder class is not exported",
            "Method provides redundant functionality already available via app.json.dumps",
            "No clear testing use case that requires JSON serialization through environment builder"
          ]
        },
        "status": "dead_code",
        "confidence": 85,
        "reason": "This method in EnvironBuilder class is not exported and appears to be unused internally. Flask applications would typically use the app's JSON serialization directly rather than through the test environment builder.",
        "recommendation": "safe_to_delete"
      },
      {
        "name": "session_transaction",
        "module": "src/flask/testing.py",
        "lineno": 136,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a context manager method for Flask's test client that allows modifying sessions during testing. The @contextmanager decorator and comprehensive docstring with usage example indicate this is intended public API for testing.",
          "recommendation": "keep",
          "evidence": [
            "Has @contextmanager decorator indicating it's designed for external use",
            "Detailed docstring with usage example shows intended public API",
            "Part of FlaskClient testing functionality that users would call directly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a context manager method for Flask's test client that allows modifying sessions during testing. The @contextmanager decorator and comprehensive docstring with usage example indicate this is intended public API for testing.",
        "recommendation": "keep"
      },
      {
        "name": "max_content_length",
        "module": "src/flask/wrappers.py",
        "lineno": 89,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a property on Flask's Request class which is exported. Request properties are part of Flask's public API that users access to inspect request limits and characteristics.",
          "recommendation": "keep",
          "evidence": [
            "Request class is exported making this public API",
            "Property decorator indicates it's meant to be accessed by users",
            "Well-documented property for inspecting request content limits"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a property on Flask's Request class which is exported. Request properties are part of Flask's public API that users access to inspect request limits and characteristics.",
        "recommendation": "keep"
      },
      {
        "name": "max_form_memory_size",
        "module": "src/flask/wrappers.py",
        "lineno": 116,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a property on Flask's exported Request class that allows users to inspect form memory size limits. As part of the public Request API, users would access this property directly.",
          "recommendation": "keep",
          "evidence": [
            "Request class is exported making this public API",
            "Property decorator for user access to form memory limits",
            "Detailed docstring explaining usage and configuration"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a property on Flask's exported Request class that allows users to inspect form memory size limits. As part of the public Request API, users would access this property directly.",
        "recommendation": "keep"
      },
      {
        "name": "max_form_parts",
        "module": "src/flask/wrappers.py",
        "lineno": 143,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a property on Flask's exported Request class for inspecting multipart form field limits. It's part of Flask's public API that users access to understand request constraints.",
          "recommendation": "keep",
          "evidence": [
            "Request class is exported making this public API",
            "Property decorator indicates user-facing access pattern",
            "Comprehensive docstring with configuration details"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a property on Flask's exported Request class for inspecting multipart form field limits. It's part of Flask's public API that users access to understand request constraints.",
        "recommendation": "keep"
      }
    ],
    "unused_classes": [
      {
        "name": "ConfigAttribute",
        "module": "src/flask/config.py",
        "lineno": 20,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "ConfigAttribute is a descriptor class that makes attributes forward to Flask's config system. It's likely used in Flask's internal architecture for config management and may be part of the public API for creating custom config attributes.",
          "recommendation": "keep",
          "evidence": [
            "Docstring indicates it's a functional descriptor for config forwarding",
            "Located in config.py suggesting it's core config infrastructure",
            "Flask applications often need custom config attribute handling"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "ConfigAttribute is a descriptor class that makes attributes forward to Flask's config system. It's likely used in Flask's internal architecture for config management and may be part of the public API for creating custom config attributes.",
        "recommendation": "keep"
      },
      {
        "name": "_AppCtxGlobals",
        "module": "src/flask/ctx.py",
        "lineno": 29,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This class is used as the namespace object for Flask's 'g' proxy during application context. The docstring explicitly mentions it's automatically created and made available as the g proxy, which is a core Flask feature.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly states it's used for the Flask 'g' proxy",
            "Core Flask context management infrastructure",
            "Automatically instantiated by Flask framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This class is used as the namespace object for Flask's 'g' proxy during application context. The docstring explicitly mentions it's automatically created and made available as the g proxy, which is a core Flask feature.",
        "recommendation": "keep"
      },
      {
        "name": "UnexpectedUnicodeError",
        "module": "src/flask/debughelpers.py",
        "lineno": 17,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a custom exception class for better Unicode error reporting in Flask. Exception classes are typically raised in specific error conditions and may be caught by user code, making them part of the public API.",
          "recommendation": "keep",
          "evidence": [
            "Custom exception class for specific Unicode error scenarios",
            "Located in debughelpers.py indicating it's part of Flask's error handling",
            "Exception classes are often part of public API for error handling"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a custom exception class for better Unicode error reporting in Flask. Exception classes are typically raised in specific error conditions and may be caught by user code, making them part of the public API.",
        "recommendation": "keep"
      },
      {
        "name": "ProxyMixin",
        "module": "src/flask/globals.py",
        "lineno": 17,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "interface_method",
          "reason": "ProxyMixin appears to be a mixin class that provides proxy functionality. Mixin classes are typically used as base classes to add functionality and may not be directly instantiated but provide methods to subclasses.",
          "recommendation": "keep",
          "evidence": [
            "Named as 'Mixin' indicating it's designed for inheritance",
            "Located in globals.py suggesting it's part of Flask's proxy system",
            "Mixin classes provide functionality through inheritance patterns"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "ProxyMixin appears to be a mixin class that provides proxy functionality. Mixin classes are typically used as base classes to add functionality and may not be directly instantiated but provide methods to subclasses.",
        "recommendation": "keep"
      },
      {
        "name": "FlaskProxy",
        "module": "src/flask/globals.py",
        "lineno": 22,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "FlaskProxy inherits from Flask and appears to be a proxy wrapper around Flask instances. This is likely part of Flask's proxy system for handling context-local Flask applications and would be used internally by the framework.",
          "recommendation": "keep",
          "evidence": [
            "Inherits from Flask class indicating it's a Flask application wrapper",
            "Located in globals.py with other proxy infrastructure",
            "Proxy classes are core to Flask's context-local application handling"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "FlaskProxy inherits from Flask and appears to be a proxy wrapper around Flask instances. This is likely part of Flask's proxy system for handling context-local Flask applications and would be used internally by the framework.",
        "recommendation": "keep"
      },
      {
        "name": "AppContextProxy",
        "module": "src/flask/globals.py",
        "lineno": 24,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a proxy class in Flask's globals module that provides access to application context. Flask uses proxy objects to provide thread-local access to context objects, which are fundamental to Flask's architecture.",
          "recommendation": "keep",
          "evidence": [
            "Located in flask/globals.py which contains core Flask proxy objects",
            "Inherits from AppContext, indicating it's part of Flask's context system",
            "Proxy classes in Flask are accessed indirectly through global variables"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a proxy class in Flask's globals module that provides access to application context. Flask uses proxy objects to provide thread-local access to context objects, which are fundamental to Flask's architecture.",
        "recommendation": "keep"
      },
      {
        "name": "_AppCtxGlobalsProxy",
        "module": "src/flask/globals.py",
        "lineno": 26,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a proxy class for application context globals in Flask. The underscore prefix suggests internal use, but proxy classes are essential infrastructure that Flask uses to provide thread-safe access to context-specific data.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's context proxy system in globals.py",
            "Inherits from _AppCtxGlobals indicating it proxies global context data",
            "Flask's proxy pattern is used internally but accessed through global variables"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a proxy class for application context globals in Flask. The underscore prefix suggests internal use, but proxy classes are essential infrastructure that Flask uses to provide thread-safe access to context-specific data.",
        "recommendation": "keep"
      },
      {
        "name": "RequestProxy",
        "module": "src/flask/globals.py",
        "lineno": 28,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is Flask's request proxy class that provides thread-local access to the current request object. This is a core Flask component that users access through the global 'request' variable, making it essential infrastructure.",
          "recommendation": "keep",
          "evidence": [
            "Request proxy is fundamental to Flask's request handling architecture",
            "Inherits from Request class, providing proxy access to request data",
            "Flask applications access this through the global 'request' object"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is Flask's request proxy class that provides thread-local access to the current request object. This is a core Flask component that users access through the global 'request' variable, making it essential infrastructure.",
        "recommendation": "keep"
      },
      {
        "name": "SessionMixinProxy",
        "module": "src/flask/globals.py",
        "lineno": 30,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a proxy class for Flask's session functionality. Like other proxy classes in Flask, it provides thread-local access to session data and is accessed through Flask's global 'session' variable.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's session management proxy system",
            "Inherits from SessionMixin providing session interface methods",
            "Flask applications access sessions through global proxy variables"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a proxy class for Flask's session functionality. Like other proxy classes in Flask, it provides thread-local access to session data and is accessed through Flask's global 'session' variable.",
        "recommendation": "keep"
      },
      {
        "name": "JSONProvider",
        "module": "src/flask/json/provider.py",
        "lineno": 19,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a base class for JSON providers in Flask with clear documentation indicating it's designed for subclassing. The docstring explicitly states it can be subclassed to customize JSON behavior, making it part of Flask's public API.",
          "recommendation": "keep",
          "evidence": [
            "Has comprehensive docstring indicating it's meant for subclassing",
            "Described as 'standard set of JSON operations' suggesting it's a public interface",
            "Located in flask/json/provider.py indicating it's part of Flask's JSON handling system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a base class for JSON providers in Flask with clear documentation indicating it's designed for subclassing. The docstring explicitly states it can be subclassed to customize JSON behavior, making it part of Flask's public API.",
        "recommendation": "keep"
      },
      {
        "name": "DefaultJSONProvider",
        "module": "src/flask/json/provider.py",
        "lineno": 124,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is Flask's default JSON provider class that implements the JSONProvider interface. It's likely registered and used by Flask's application factory or configuration system, even if not directly instantiated in user code.",
          "recommendation": "keep",
          "evidence": [
            "Class name suggests it's the default implementation used by Flask framework",
            "Inherits from JSONProvider interface indicating it's part of Flask's JSON handling system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is Flask's default JSON provider class that implements the JSONProvider interface. It's likely registered and used by Flask's application factory or configuration system, even if not directly instantiated in user code.",
        "recommendation": "keep"
      },
      {
        "name": "JSONTag",
        "module": "src/flask/json/tag.py",
        "lineno": 60,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This is a base class for defining type tags in TaggedJSONSerializer. Base classes in serialization systems are typically extended by other tag classes and used polymorphically by the serializer framework.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly states it's a base class for defining type tags",
            "Part of Flask's JSON tagging system which likely uses subclasses polymorphically"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a base class for defining type tags in TaggedJSONSerializer. Base classes in serialization systems are typically extended by other tag classes and used polymorphically by the serializer framework.",
        "recommendation": "keep"
      },
      {
        "name": "TagDict",
        "module": "src/flask/json/tag.py",
        "lineno": 93,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "interface_method",
          "reason": "This is a concrete JSONTag implementation for handling dict serialization. Tag classes are typically registered with and used by the TaggedJSONSerializer system automatically, not called directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Inherits from JSONTag base class indicating it's part of the tagging system",
            "Specific implementation for dict handling with detailed docstring explaining its purpose"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This is a concrete JSONTag implementation for handling dict serialization. Tag classes are typically registered with and used by the TaggedJSONSerializer system automatically, not called directly in application code.",
        "recommendation": "keep"
      },
      {
        "name": "PassDict",
        "module": "src/flask/json/tag.py",
        "lineno": 119,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 75,
          "category": "interface_method",
          "reason": "Another JSONTag subclass that's likely registered with TaggedJSONSerializer for handling specific dict types. Like other tag classes, it's used by the serialization framework rather than called directly.",
          "recommendation": "keep",
          "evidence": [
            "Inherits from JSONTag indicating it's part of the JSON tagging system",
            "Follows the same pattern as other tag classes in the module"
          ]
        },
        "status": "false_positive",
        "confidence": 75,
        "reason": "Another JSONTag subclass that's likely registered with TaggedJSONSerializer for handling specific dict types. Like other tag classes, it's used by the serialization framework rather than called directly.",
        "recommendation": "keep"
      },
      {
        "name": "TagTuple",
        "module": "src/flask/json/tag.py",
        "lineno": 133,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "interface_method",
          "reason": "JSONTag subclass for tuple serialization. Tag classes are registered components used by Flask's JSON serialization system, so lack of direct calls in application code is expected behavior.",
          "recommendation": "keep",
          "evidence": [
            "Inherits from JSONTag base class for serialization system",
            "Name indicates it handles tuple serialization as part of the tagging framework"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "JSONTag subclass for tuple serialization. Tag classes are registered components used by Flask's JSON serialization system, so lack of direct calls in application code is expected behavior.",
        "recommendation": "keep"
      },
      {
        "name": "PassList",
        "module": "src/flask/json/tag.py",
        "lineno": 147,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This is a JSONTag subclass that implements Flask's JSON serialization system. These tag classes are registered with the serializer and used automatically when certain data types are encountered during JSON encoding/decoding.",
          "recommendation": "keep",
          "evidence": [
            "Inherits from JSONTag which is part of Flask's extensible JSON serialization framework",
            "Tag classes are typically registered and invoked by the JSON serializer, not called directly in code"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a JSONTag subclass that implements Flask's JSON serialization system. These tag classes are registered with the serializer and used automatically when certain data types are encountered during JSON encoding/decoding.",
        "recommendation": "keep"
      },
      {
        "name": "TagBytes",
        "module": "src/flask/json/tag.py",
        "lineno": 159,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This is a JSONTag subclass for handling bytes serialization in Flask's JSON system. It's invoked automatically by the JSON serializer when bytes objects need to be serialized/deserialized.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's JSON tag system for handling specific data types",
            "Automatically invoked by JSON serializer when bytes objects are encountered"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a JSONTag subclass for handling bytes serialization in Flask's JSON system. It's invoked automatically by the JSON serializer when bytes objects need to be serialized/deserialized.",
        "recommendation": "keep"
      },
      {
        "name": "TagMarkup",
        "module": "src/flask/json/tag.py",
        "lineno": 173,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This JSONTag handles MarkupSafe objects in Flask's JSON serialization. The docstring clearly indicates it's designed to serialize objects with __html__ method and deserialize to Markup instances, showing it's part of the active serialization system.",
          "recommendation": "keep",
          "evidence": [
            "Has detailed docstring explaining its purpose for MarkupSafe integration",
            "Part of Flask's JSON tag system for handling HTML markup objects safely"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This JSONTag handles MarkupSafe objects in Flask's JSON serialization. The docstring clearly indicates it's designed to serialize objects with __html__ method and deserialize to Markup instances, showing it's part of the active serialization system.",
        "recommendation": "keep"
      },
      {
        "name": "TagUUID",
        "module": "src/flask/json/tag.py",
        "lineno": 191,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This JSONTag handles UUID serialization in Flask's JSON system. UUID objects are commonly used in web applications and this tag enables their automatic serialization/deserialization.",
          "recommendation": "keep",
          "evidence": [
            "UUIDs are frequently used in web applications for identifiers",
            "Part of Flask's JSON tag registration system for automatic type handling"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This JSONTag handles UUID serialization in Flask's JSON system. UUID objects are commonly used in web applications and this tag enables their automatic serialization/deserialization.",
        "recommendation": "keep"
      },
      {
        "name": "TagDateTime",
        "module": "src/flask/json/tag.py",
        "lineno": 205,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This JSONTag handles datetime serialization, which is essential for web applications dealing with timestamps. DateTime objects cannot be serialized to JSON natively, so this tag is crucial functionality.",
          "recommendation": "keep",
          "evidence": [
            "DateTime serialization is fundamental requirement for most web applications",
            "Part of Flask's core JSON handling capabilities for temporal data"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This JSONTag handles datetime serialization, which is essential for web applications dealing with timestamps. DateTime objects cannot be serialized to JSON natively, so this tag is crucial functionality.",
        "recommendation": "keep"
      },
      {
        "name": "Scaffold",
        "module": "src/flask/sansio/scaffold.py",
        "lineno": 52,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a base class in Flask's core architecture that provides common behavior shared between Flask and Blueprint classes. As a fundamental component of Flask's public API, it's designed to be subclassed and used by the framework internally.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly states it's shared between Flask and Blueprint classes",
            "Located in Flask's core sansio module, indicating it's part of the framework's architecture",
            "Base classes like this are typically subclassed rather than instantiated directly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a base class in Flask's core architecture that provides common behavior shared between Flask and Blueprint classes. As a fundamental component of Flask's public API, it's designed to be subclassed and used by the framework internally.",
        "recommendation": "keep"
      },
      {
        "name": "SessionMixin",
        "module": "src/flask/sessions.py",
        "lineno": 24,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This is a mixin class that extends basic dictionary functionality with session attributes. Mixins are designed to be inherited by other classes to provide additional functionality, and may not be directly instantiated or called.",
          "recommendation": "keep",
          "evidence": [
            "Named as 'Mixin' which indicates it's designed for inheritance",
            "Docstring indicates it expands dictionary with session attributes",
            "Part of Flask's session management system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a mixin class that extends basic dictionary functionality with session attributes. Mixins are designed to be inherited by other classes to provide additional functionality, and may not be directly instantiated or called.",
        "recommendation": "keep"
      },
      {
        "name": "SecureCookieSession",
        "module": "src/flask/sessions.py",
        "lineno": 52,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a base class for Flask's session implementation based on signed cookies. It's part of Flask's session management system and likely used internally by the framework or extended by users implementing custom session backends.",
          "recommendation": "keep",
          "evidence": [
            "Docstring describes it as a 'base class for sessions'",
            "Inherits from SessionMixin, indicating it's part of the session hierarchy",
            "Manages session attributes like 'modified' and 'accessed'"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a base class for Flask's session implementation based on signed cookies. It's part of Flask's session management system and likely used internally by the framework or extended by users implementing custom session backends.",
        "recommendation": "keep"
      },
      {
        "name": "NullSession",
        "module": "src/flask/sessions.py",
        "lineno": 97,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This class is used by Flask to generate better error messages when sessions are not available. It's likely instantiated by Flask's session management system internally when sessions are disabled or unavailable.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly states its purpose for generating error messages",
            "Inherits from SecureCookieSession, part of session class hierarchy",
            "Provides read-only access but fails on setting, indicating active error handling"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This class is used by Flask to generate better error messages when sessions are not available. It's likely instantiated by Flask's session management system internally when sessions are disabled or unavailable.",
        "recommendation": "keep"
      },
      {
        "name": "SessionInterface",
        "module": "src/flask/sessions.py",
        "lineno": 114,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is an interface class that defines the contract for implementing custom session backends in Flask. Interface classes are designed to be subclassed by users who want to replace Flask's default session implementation.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly states it's 'the basic interface you have to implement'",
            "Named 'Interface' indicating it's meant to be implemented by subclasses",
            "Part of Flask's extensible session system architecture"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is an interface class that defines the contract for implementing custom session backends in Flask. Interface classes are designed to be subclassed by users who want to replace Flask's default session implementation.",
        "recommendation": "keep"
      },
      {
        "name": "SecureCookieSessionInterface",
        "module": "src/flask/sessions.py",
        "lineno": 298,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's default session interface implementation that stores sessions in signed cookies. It's a core component of Flask's session management system and would be instantiated by Flask internally or used by developers who want to customize session behavior.",
          "recommendation": "keep",
          "evidence": [
            "Extends SessionInterface which is a core Flask interface",
            "Docstring indicates it's 'the default session interface' suggesting active use",
            "Session interfaces are typically registered and used by Flask's app context"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's default session interface implementation that stores sessions in signed cookies. It's a core component of Flask's session management system and would be instantiated by Flask internally or used by developers who want to customize session behavior.",
        "recommendation": "keep"
      },
      {
        "name": "Environment",
        "module": "src/flask/templating.py",
        "lineno": 35,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is Flask's custom Jinja2 environment that extends BaseEnvironment with Flask-specific functionality like blueprint template resolution. It's a core component of Flask's templating system and would be used internally by Flask when rendering templates.",
          "recommendation": "keep",
          "evidence": [
            "Extends Jinja2's BaseEnvironment with Flask-specific blueprint knowledge",
            "Templating environments are essential infrastructure used by Flask's render_template functions",
            "Docstring describes specific Flask functionality for blueprint template handling"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is Flask's custom Jinja2 environment that extends BaseEnvironment with Flask-specific functionality like blueprint template resolution. It's a core component of Flask's templating system and would be used internally by Flask when rendering templates.",
        "recommendation": "keep"
      },
      {
        "name": "FlaskClient",
        "module": "src/flask/testing.py",
        "lineno": 109,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's test client that extends Werkzeug's Client with Flask-specific testing capabilities. It's designed to be used by developers writing tests for Flask applications and provides additional context management for Flask's request handling.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py indicating it's part of Flask's testing infrastructure",
            "Extends Werkzeug's Client with Flask-specific testing behavior",
            "Docstring mentions context cleanup and Flask-specific functionality for testing"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's test client that extends Werkzeug's Client with Flask-specific testing capabilities. It's designed to be used by developers writing tests for Flask applications and provides additional context management for Flask's request handling.",
        "recommendation": "keep"
      },
      {
        "name": "FlaskCliRunner",
        "module": "src/flask/testing.py",
        "lineno": 265,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's CLI test runner that extends Click's CliRunner for testing Flask CLI commands. It's part of Flask's testing infrastructure and would be created via Flask.test_cli_runner() method for testing command-line interfaces.",
          "recommendation": "keep",
          "evidence": [
            "Located in testing.py as part of Flask's testing suite",
            "Docstring explicitly mentions it's created using Flask.test_cli_runner()",
            "Extends Click's CliRunner with Flask-specific CLI testing capabilities"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's CLI test runner that extends Click's CliRunner for testing Flask CLI commands. It's part of Flask's testing infrastructure and would be created via Flask.test_cli_runner() method for testing command-line interfaces.",
        "recommendation": "keep"
      },
      {
        "name": "View",
        "module": "src/flask/views.py",
        "lineno": 16,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is Flask's base class for class-based views that developers subclass to create view classes. The docstring explicitly instructs users to subclass it and mentions the as_view() method for converting to view functions, indicating it's part of Flask's public API.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly instructs developers to 'Subclass this class'",
            "Mentions as_view() method for creating view functions from class instances",
            "Class-based views are a documented Flask feature for organizing view logic"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is Flask's base class for class-based views that developers subclass to create view classes. The docstring explicitly instructs users to subclass it and mentions the as_view() method for converting to view functions, indicating it's part of Flask's public API.",
        "recommendation": "keep"
      },
      {
        "name": "MethodView",
        "module": "src/flask/views.py",
        "lineno": 138,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "MethodView is a base class in Flask's view system that users extend to create REST APIs. It's designed to be subclassed by application developers, and its dispatch mechanism is called by Flask's routing system, not directly by user code.",
          "recommendation": "keep",
          "evidence": [
            "Docstring explicitly mentions it's for 'defining a REST API' indicating public API usage",
            "This is Flask framework code - MethodView is a core component for class-based views",
            "Base classes like this are typically imported and subclassed by Flask applications"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "MethodView is a base class in Flask's view system that users extend to create REST APIs. It's designed to be subclassed by application developers, and its dispatch mechanism is called by Flask's routing system, not directly by user code.",
        "recommendation": "keep"
      }
    ],
    "unused_imports": [],
    "unused_global_variables": [
      {
        "module": "examples/celery/make_celery.py",
        "name": "celery_app",
        "lineno": 4,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "config",
          "reason": "This appears to be a Celery application instance in an examples directory, likely used as a demonstration or template for integrating Flask with Celery. Example code is typically referenced or copied by users.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/celery/ directory indicating tutorial/demo purpose",
            "Celery app instances are typically imported and used by task runners"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a Celery application instance in an examples directory, likely used as a demonstration or template for integrating Flask with Celery. Example code is typically referenced or copied by users.",
        "recommendation": "keep"
      },
      {
        "module": "examples/javascript/js_example/__init__.py",
        "name": "app",
        "lineno": 3,
        "assigned_to": "Flask",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "config",
          "reason": "Variable in __init__.py of an examples directory, likely used to expose the Flask app instance for the JavaScript integration example. Package initialization variables are commonly imported externally.",
          "recommendation": "keep",
          "evidence": [
            "Located in __init__.py which serves as package interface",
            "Part of examples directory structure for demonstrating Flask-JavaScript integration"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Variable in __init__.py of an examples directory, likely used to expose the Flask app instance for the JavaScript integration example. Package initialization variables are commonly imported externally.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "T_shell_context_processor",
        "lineno": 63,
        "assigned_to": "t.TypeVar",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a type variable definition in Flask's core app.py, used for type hints in the shell context processor functionality. Type variables are consumed by type checkers and IDEs, not directly called in code.",
          "recommendation": "keep",
          "evidence": [
            "Type variable (T_*) used for generic type annotations",
            "Located in Flask core source code for public API type safety"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a type variable definition in Flask's core app.py, used for type hints in the shell context processor functionality. Type variables are consumed by type checkers and IDEs, not directly called in code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "T_teardown",
        "lineno": 66,
        "assigned_to": "t.TypeVar",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Type variable for teardown handler functions in Flask's type system. Used by type checkers for ensuring proper teardown handler signatures, essential for Flask's public API type safety.",
          "recommendation": "keep",
          "evidence": [
            "Type variable for Flask's teardown handler system",
            "Part of Flask's public typing interface for developers"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Type variable for teardown handler functions in Flask's type system. Used by type checkers for ensuring proper teardown handler signatures, essential for Flask's public API type safety.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "T_template_filter",
        "lineno": 67,
        "assigned_to": "t.TypeVar",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Type variable for template filter functions in Flask's type system. Used by type checkers to validate template filter function signatures, crucial for Flask's templating API type safety.",
          "recommendation": "keep",
          "evidence": [
            "Type variable for Flask's template filter system",
            "Essential for type checking Flask template filter decorators and functions"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Type variable for template filter functions in Flask's type system. Used by type checkers to validate template filter function signatures, crucial for Flask's templating API type safety.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "T_template_global",
        "lineno": 68,
        "assigned_to": "t.TypeVar",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a TypeVar used for type hinting in Flask's template system. TypeVars are typically used across multiple modules for type checking and are part of the public typing interface.",
          "recommendation": "keep",
          "evidence": [
            "Located in main Flask app.py module suggesting it's part of core API",
            "TypeVars are commonly used for generic type annotations across codebases"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a TypeVar used for type hinting in Flask's template system. TypeVars are typically used across multiple modules for type checking and are part of the public typing interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "T_template_test",
        "lineno": 69,
        "assigned_to": "t.TypeVar",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a TypeVar used for type hinting in Flask's template system. TypeVars are typically used across multiple modules for type checking and are part of the public typing interface.",
          "recommendation": "keep",
          "evidence": [
            "Located in main Flask app.py module suggesting it's part of core API",
            "TypeVars are commonly used for generic type annotations across codebases"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a TypeVar used for type hinting in Flask's template system. TypeVars are typically used across multiple modules for type checking and are part of the public typing interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "_sentinel",
        "lineno": 25,
        "assigned_to": "object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "Sentinel objects are commonly used as unique default values to distinguish from None. The underscore prefix indicates internal use, and it's in scaffold.py which is likely used across the Flask framework.",
          "recommendation": "keep",
          "evidence": [
            "Sentinel pattern is standard for distinguishing unset values from None",
            "Located in scaffold.py which is likely a foundational module used by other parts"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Sentinel objects are commonly used as unique default values to distinguish from None. The underscore prefix indicates internal use, and it's in scaffold.py which is likely used across the Flask framework.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "AppOrBlueprintKey",
        "lineno": 49,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a type alias in the typing module, which is typically used for type hints throughout the codebase. Type aliases in typing modules are part of the public API for type checking.",
          "recommendation": "keep",
          "evidence": [
            "Located in dedicated typing.py module indicating it's for public type annotations",
            "Type aliases are commonly referenced in function signatures and variable annotations"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a type alias in the typing module, which is typically used for type hints throughout the codebase. Type aliases in typing modules are part of the public API for type checking.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "AfterRequestCallable",
        "lineno": 50,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a type alias in the typing module for defining callable signatures. It's likely used for type hinting Flask's after_request decorators and handlers throughout the framework.",
          "recommendation": "keep",
          "evidence": [
            "Located in dedicated typing.py module indicating it's for public type annotations",
            "Name suggests it's for Flask's after_request functionality which is a core feature"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a type alias in the typing module for defining callable signatures. It's likely used for type hinting Flask's after_request decorators and handlers throughout the framework.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "BeforeFirstRequestCallable",
        "lineno": 54,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a type alias defined in Flask's typing module for callback functions that run before the first request. It's part of Flask's public type system used by developers for type hints when working with Flask decorators and callbacks.",
          "recommendation": "keep",
          "evidence": [
            "Located in typing.py which is typically used for public type definitions",
            "Follows Flask's naming convention for callable type aliases",
            "Type aliases are consumed by type checkers and IDEs, not called directly in code"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a type alias defined in Flask's typing module for callback functions that run before the first request. It's part of Flask's public type system used by developers for type hints when working with Flask decorators and callbacks.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "BeforeRequestCallable",
        "lineno": 55,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a type alias for callback functions that run before each request in Flask. It's part of Flask's public typing system used by developers to properly type their before_request handler functions.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's public type system in typing.py",
            "Corresponds to Flask's @app.before_request decorator functionality",
            "Type aliases are used by type checkers, not invoked directly"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a type alias for callback functions that run before each request in Flask. It's part of Flask's public typing system used by developers to properly type their before_request handler functions.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "ShellContextProcessorCallable",
        "lineno": 59,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a type alias for shell context processor functions in Flask. These are callbacks that add variables to the shell context when using 'flask shell' command, part of Flask's public typing interface.",
          "recommendation": "keep",
          "evidence": [
            "Corresponds to Flask's @app.shell_context_processor decorator",
            "Part of Flask's public type system for shell functionality",
            "Type aliases are not called directly but used for type checking"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a type alias for shell context processor functions in Flask. These are callbacks that add variables to the shell context when using 'flask shell' command, part of Flask's public typing interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "TeardownCallable",
        "lineno": 60,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a type alias for teardown callback functions that run after request/application context cleanup. It's part of Flask's public typing system for developers implementing teardown handlers.",
          "recommendation": "keep",
          "evidence": [
            "Corresponds to Flask's teardown handler decorators",
            "Part of Flask's public type system in typing.py",
            "Type aliases are consumed by type checkers and development tools"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a type alias for teardown callback functions that run after request/application context cleanup. It's part of Flask's public typing system for developers implementing teardown handlers.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "TemplateContextProcessorCallable",
        "lineno": 64,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a type alias for template context processor functions that add variables to template rendering context. It's part of Flask's public typing system for developers implementing template context processors.",
          "recommendation": "keep",
          "evidence": [
            "Corresponds to Flask's @app.context_processor decorator functionality",
            "Part of Flask's public type system for template processing",
            "Type aliases are used for type hints, not direct invocation"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a type alias for template context processor functions that add variables to template rendering context. It's part of Flask's public typing system for developers implementing template context processors.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "TemplateFilterCallable",
        "lineno": 67,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a type alias in Flask's typing module for template filter functions. Type aliases in typing modules are part of the public API for type annotations and static analysis tools.",
          "recommendation": "keep",
          "evidence": [
            "Located in typing.py module which provides public type definitions",
            "Template filters are a core Flask feature that users implement"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a type alias in Flask's typing module for template filter functions. Type aliases in typing modules are part of the public API for type annotations and static analysis tools.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "TemplateGlobalCallable",
        "lineno": 68,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a type alias for template global functions in Flask's typing system. Used by developers for type hints when creating template globals.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's public typing API",
            "Template globals are a documented Flask feature"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a type alias for template global functions in Flask's typing system. Used by developers for type hints when creating template globals.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "TemplateTestCallable",
        "lineno": 69,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Type alias for template test functions in Flask's typing system. Provides type safety for custom template tests that users can register.",
          "recommendation": "keep",
          "evidence": [
            "Part of typing module's public API",
            "Template tests are a standard Jinja2/Flask feature"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Type alias for template test functions in Flask's typing system. Provides type safety for custom template tests that users can register.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "URLDefaultCallable",
        "lineno": 70,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Type alias for URL default functions in Flask's routing system. Used for type annotations when developers implement URL defaults functionality.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's typing API for URL routing",
            "URL defaults are a documented Flask routing feature"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Type alias for URL default functions in Flask's routing system. Used for type annotations when developers implement URL defaults functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "URLValuePreprocessorCallable",
        "lineno": 71,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Type alias for URL value preprocessor functions in Flask's routing system. Provides type hints for developers implementing custom URL preprocessing logic.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's public typing interface",
            "URL value preprocessors are a documented Flask feature"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Type alias for URL value preprocessor functions in Flask's routing system. Provides type hints for developers implementing custom URL preprocessing logic.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "ErrorHandlerCallable",
        "lineno": 79,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a type alias in Flask's typing module that provides type hints for error handler functions. It's part of Flask's public typing API used by developers for type annotations.",
          "recommendation": "keep",
          "evidence": [
            "Located in src/flask/typing.py which is a public typing module",
            "Type aliases are used by external developers for type annotations, not called internally"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a type alias in Flask's typing module that provides type hints for error handler functions. It's part of Flask's public typing API used by developers for type annotations.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/typing.py",
        "name": "RouteCallable",
        "lineno": 84,
        "assigned_to": null,
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a type alias in Flask's typing module that provides type hints for route handler functions. It's part of Flask's public typing API used by developers for type annotations.",
          "recommendation": "keep",
          "evidence": [
            "Located in src/flask/typing.py which is a public typing module",
            "Type aliases are used by external developers for type annotations, not called internally"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a type alias in Flask's typing module that provides type hints for route handler functions. It's part of Flask's public typing API used by developers for type annotations.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/views.py",
        "name": "F",
        "lineno": 9,
        "assigned_to": "t.TypeVar",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a TypeVar used for generic type annotations in Flask's views module. TypeVars are part of the typing system and are used by type checkers and developers for generic programming.",
          "recommendation": "keep",
          "evidence": [
            "TypeVars are consumed by type checkers like mypy, not called directly in code",
            "Located in views.py which is part of Flask's public API"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a TypeVar used for generic type annotations in Flask's views module. TypeVars are part of the typing system and are used by type checkers and developers for generic programming.",
        "recommendation": "keep"
      }
    ],
    "unreachable_code": [],
    "suspicious_patterns": [
      {
        "module": "docs/conf.py",
        "name": "github_link",
        "lineno": 72,
        "pattern_type": "too_many_parameters",
        "details": "Function has 7 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "config",
          "reason": "This is in docs/conf.py which is a configuration file used by Sphinx documentation tools. Variables in such config files are consumed by external tools, not by internal application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in docs/conf.py which is a Sphinx configuration file",
            "Config file variables are used by external documentation tools"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is in docs/conf.py which is a configuration file used by Sphinx documentation tools. Variables in such config files are consumed by external tools, not by internal application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "run",
        "lineno": 631,
        "pattern_type": "long_function",
        "details": "Function is very long (122 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is Flask's app.run() method, a core public API method that users call to start the Flask development server. It's the standard way to run Flask applications and is heavily used by Flask users externally.",
          "recommendation": "keep",
          "evidence": [
            "Flask is a web framework library where app.run() is a primary public API",
            "Standard method for starting Flask development servers in user applications"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is Flask's app.run() method, a core public API method that users call to start the Flask development server. It's the standard way to run Flask applications and is heavily used by Flask users externally.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "url_for",
        "lineno": 1090,
        "pattern_type": "long_function",
        "details": "Function is very long (121 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's url_for() method, a fundamental public API function for URL generation. It's one of Flask's most commonly used features by developers for generating URLs in templates and application code.",
          "recommendation": "keep",
          "evidence": [
            "Core Flask public API method for URL generation",
            "Widely used by Flask developers in templates and application logic"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's url_for() method, a fundamental public API function for URL generation. It's one of Flask's most commonly used features by developers for generating URLs in templates and application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "make_response",
        "lineno": 1212,
        "pattern_type": "long_function",
        "details": "Function is very long (141 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is Flask's make_response() method, a public API function that allows users to create response objects with custom headers, status codes, etc. It's part of Flask's response handling public interface.",
          "recommendation": "keep",
          "evidence": [
            "Public API method for creating custom Flask response objects",
            "Used by Flask developers for advanced response handling"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is Flask's make_response() method, a public API function that allows users to create response objects with custom headers, status codes, etc. It's part of Flask's response handling public interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "run_command",
        "lineno": 935,
        "pattern_type": "too_many_parameters",
        "details": "Function has 9 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This appears to be in Flask's CLI module and likely serves as a command handler or callback function for the Flask command-line interface. Such functions are typically invoked by the CLI framework rather than called directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Located in cli.py suggesting it's a command-line interface handler",
            "CLI command functions are typically invoked by framework, not direct calls"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be in Flask's CLI module and likely serves as a command handler or callback function for the Flask command-line interface. Such functions are typically invoked by the CLI framework rather than called directly in code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "send_file",
        "lineno": 401,
        "pattern_type": "long_function",
        "details": "Function is very long (124 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's send_file function, a core public API method for sending files in web responses. It's exported and widely used by Flask applications externally.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's helpers.py which contains public utility functions",
            "send_file is a fundamental Flask feature for file downloads/serving"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's send_file function, a core public API method for sending files in web responses. It's exported and widely used by Flask applications externally.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "send_file",
        "lineno": 401,
        "pattern_type": "too_many_parameters",
        "details": "Function has 8 parameters - consider parameter object",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Duplicate of the previous send_file function - same Flask public API method for sending files in web responses.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous item - Flask's core helpers module",
            "Essential Flask functionality for file handling"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Duplicate of the previous send_file function - same Flask public API method for sending files in web responses.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/blueprints.py",
        "name": "register",
        "lineno": 273,
        "pattern_type": "long_function",
        "details": "Function is very long (105 lines) - consider refactoring",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is likely the Blueprint.register method in Flask, which is a core public API for registering blueprints with Flask applications. Called externally by applications using blueprints.",
          "recommendation": "keep",
          "evidence": [
            "Located in blueprints.py which handles Flask's blueprint system",
            "Blueprint registration is a fundamental Flask pattern used by applications"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely the Blueprint.register method in Flask, which is a core public API for registering blueprints with Flask applications. Called externally by applications using blueprints.",
        "recommendation": "keep"
      },
      {
        "module": "docs/conf.py",
        "name": "setup",
        "lineno": 100,
        "pattern_type": "similar_function_names",
        "details": "Similar to setupmethod in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 100,
          "category": "config",
          "reason": "This is in docs/conf.py which is a Sphinx documentation configuration file. The setup function is called by Sphinx to configure documentation building.",
          "recommendation": "keep",
          "evidence": [
            "Located in conf.py which is a standard Sphinx configuration file",
            "Sphinx automatically calls setup() function during documentation build"
          ]
        },
        "status": "false_positive",
        "confidence": 100,
        "reason": "This is in docs/conf.py which is a Sphinx documentation configuration file. The setup function is called by Sphinx to configure documentation building.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/__init__.py",
        "name": "create_app",
        "lineno": 7,
        "pattern_type": "similar_function_names",
        "details": "Similar to create in examples/tutorial/flaskr/blog.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is the Flask application factory pattern function, typically called externally by WSGI servers or when importing the package. Being in __init__.py makes it the main entry point.",
          "recommendation": "keep",
          "evidence": [
            "Located in __init__.py making it the package's main interface",
            "create_app is the standard Flask application factory pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is the Flask application factory pattern function, typically called externally by WSGI servers or when importing the package. Being in __init__.py makes it the main entry point.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_ctx in src/flask/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in tasks.py which is a standard Celery module structure",
            "Celery tasks are invoked by the task queue system, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in tasks.py which is a standard Celery module structure",
            "Celery tasks are invoked by the task queue system, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_filter in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in tasks.py which is a standard Celery module structure",
            "Celery tasks are invoked by the task queue system, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_test in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in tasks.py which is a standard Celery module structure",
            "Celery tasks are invoked by the task queue system, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_global in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in tasks.py which is a standard Celery module structure",
            "Celery tasks are invoked by the task queue system, not direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task. Celery tasks are executed by the Celery worker process when called asynchronously, not directly in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/celery/src/task_app/tasks.py suggesting it's a Celery task",
            "Celery tasks are called externally by workers, not through direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/celery/src/task_app/tasks.py suggesting it's a Celery task",
            "Celery tasks are called externally by workers, not through direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/celery/src/task_app/tasks.py suggesting it's a Celery task",
            "Celery tasks are called externally by workers, not through direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/celery/src/task_app/tasks.py suggesting it's a Celery task",
            "Celery tasks are called externally by workers, not through direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/celery/src/task_app/tasks.py suggesting it's a Celery task",
            "Celery tasks are called externally by workers, not through direct function calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Celery task function decorated with @app.task or similar. Celery tasks are invoked by the Celery worker process, not directly called in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "add",
        "lineno": 8,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Celery task decorated with @app.task, making it a background task that gets called by the Celery worker system. Celery tasks are invoked through the task queue system, not direct function calls in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "@app.task decorator indicates this is a Celery background task",
            "Celery tasks are called by workers through message queue, not direct invocation"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Celery task decorated with @app.task, making it a background task that gets called by the Celery worker system. Celery tasks are invoked through the task queue system, not direct function calls in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/tasks.py",
        "name": "process",
        "lineno": 18,
        "pattern_type": "similar_function_names",
        "details": "Similar to process_response in src/flask/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Celery task decorated with @app.task, making it a background task that gets executed by Celery workers. Like other Celery tasks, it's invoked through the task queue system rather than direct function calls.",
          "recommendation": "keep",
          "evidence": [
            "@app.task decorator indicates this is a Celery background task",
            "Celery framework handles task execution through message queue system"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Celery task decorated with @app.task, making it a background task that gets executed by Celery workers. Like other Celery tasks, it's invoked through the task queue system rather than direct function calls.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_ctx in src/flask/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be calling a Celery task (likely the add task from tasks.py) in a view function. In web applications, view functions are called by the web framework when handling HTTP requests, not through direct code invocation.",
          "recommendation": "keep",
          "evidence": [
            "Located in views.py indicating it's a web view function",
            "Likely calling a Celery task which is normal pattern in web applications"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be calling a Celery task (likely the add task from tasks.py) in a view function. In web applications, view functions are called by the web framework when handling HTTP requests, not through direct code invocation.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This is the same as item #3 - appears to be a Celery task call within a view function. Web framework handles calling view functions when processing HTTP requests.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous item in views.py",
            "Part of web application request handling flow"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is the same as item #3 - appears to be a Celery task call within a view function. Web framework handles calling view functions when processing HTTP requests.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_filter in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This is the same as items #3 and #4 - a Celery task call within a view function. The web framework invokes view functions when handling HTTP requests, so no direct calls are expected in the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous items in views.py",
            "Web frameworks call view functions automatically during request processing"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is the same as items #3 and #4 - a Celery task call within a view function. The web framework invokes view functions when handling HTTP requests, so no direct calls are expected in the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_test in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical names and locations",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_global in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical names and locations",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical names and locations",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical names and locations",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical names and locations",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze the actual code pattern without seeing the implementation. All 5 items appear to be the same 'add' pattern at the same location, suggesting potential duplicates or analysis artifacts.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 40,
          "category": "callback",
          "reason": "This appears to be a Celery task function based on the file path. Celery tasks are invoked by the task queue system, not through direct code calls. Without seeing the actual code, cannot confirm if it's properly registered as a Celery task.",
          "recommendation": "investigate",
          "evidence": [
            "Located in task_app/views.py suggesting Celery application structure",
            "Pattern-based detection may miss framework-based invocation"
          ]
        },
        "status": "uncertain",
        "confidence": 40,
        "reason": "This appears to be a Celery task function based on the file path. Celery tasks are invoked by the task queue system, not through direct code calls. Without seeing the actual code, cannot confirm if it's properly registered as a Celery task.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 40,
          "category": "callback",
          "reason": "Duplicate entry of the same function. This appears to be a Celery task function that would be invoked by the task queue system rather than direct code calls. Multiple detections suggest potential configuration issue.",
          "recommendation": "investigate",
          "evidence": [
            "Same location as item #1 indicating potential duplicate detection",
            "Celery tasks are called via queue system, not direct invocation"
          ]
        },
        "status": "uncertain",
        "confidence": 40,
        "reason": "Duplicate entry of the same function. This appears to be a Celery task function that would be invoked by the task queue system rather than direct code calls. Multiple detections suggest potential configuration issue.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "add",
        "lineno": 22,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 40,
          "category": "callback",
          "reason": "Third duplicate entry of the same function. This reinforces that it's likely a Celery task that should be invoked by the task queue system. Multiple detections may indicate analysis tool issues.",
          "recommendation": "investigate",
          "evidence": [
            "Third occurrence of same function at same location",
            "Pattern suggests framework-based invocation rather than direct calls"
          ]
        },
        "status": "uncertain",
        "confidence": 40,
        "reason": "Third duplicate entry of the same function. This reinforces that it's likely a Celery task that should be invoked by the task queue system. Multiple detections may indicate analysis tool issues.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/celery/src/task_app/views.py",
        "name": "process",
        "lineno": 36,
        "pattern_type": "similar_function_names",
        "details": "Similar to process_response in src/flask/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 50,
          "category": "callback",
          "reason": "Function named 'process' in a Celery application is likely a task or callback function. The name suggests it processes data and may be invoked by the task queue system or as a callback handler.",
          "recommendation": "investigate",
          "evidence": [
            "Function name 'process' suggests callback or handler pattern",
            "Located in Celery application where tasks are invoked by queue system"
          ]
        },
        "status": "uncertain",
        "confidence": 50,
        "reason": "Function named 'process' in a Celery application is likely a task or callback function. The name suggests it processes data and may be invoked by the task queue system or as a callback handler.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_ctx in src/flask/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 45,
          "category": "callback",
          "reason": "Located in a JavaScript example's views.py file, this could be a Django view function or similar web framework handler. Web framework views are typically called by URL routing systems rather than direct code invocation.",
          "recommendation": "investigate",
          "evidence": [
            "Located in views.py suggesting web framework view function",
            "Web framework views are invoked by routing systems, not direct calls"
          ]
        },
        "status": "uncertain",
        "confidence": 45,
        "reason": "Located in a JavaScript example's views.py file, this could be a Django view function or similar web framework handler. Web framework views are typically called by URL routing systems rather than direct code invocation.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location examples/javascript/js_example/views.py:15",
            "No actual code content provided to determine usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_filter in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location examples/javascript/js_example/views.py:15",
            "No actual code content provided to determine usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_test in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location examples/javascript/js_example/views.py:15",
            "No actual code content provided to determine usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_template_global in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location examples/javascript/js_example/views.py:15",
            "No actual code content provided to determine usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location examples/javascript/js_example/views.py:15",
            "No actual code content provided to determine usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and name, which suggests either duplicate reporting or insufficient code context provided.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical location (examples/javascript/js_example/views.py:15)",
            "No actual code content provided to analyze usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical location (examples/javascript/js_example/views.py:15)",
            "No actual code content provided to analyze usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical location (examples/javascript/js_example/views.py:15)",
            "No actual code content provided to analyze usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical location (examples/javascript/js_example/views.py:15)",
            "No actual code content provided to analyze usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/javascript/js_example/views.py",
        "name": "add",
        "lineno": 15,
        "pattern_type": "similar_function_names",
        "details": "Similar to add_url_rule in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "genuinely_unused",
          "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
          "recommendation": "investigate",
          "evidence": [
            "All 5 items have identical location (examples/javascript/js_example/views.py:15)",
            "No actual code content provided to analyze usage patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code content. All 5 items show identical location and pattern name, which suggests either duplicate detection or missing code context.",
        "recommendation": "investigate"
      },
      {
        "module": "examples/tutorial/flaskr/__init__.py",
        "name": "create_app",
        "lineno": 6,
        "pattern_type": "similar_function_names",
        "details": "Similar to create in examples/tutorial/flaskr/blog.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a Flask application factory function in __init__.py, which is the standard pattern for creating Flask apps. It's likely called by WSGI servers or main entry points to instantiate the application.",
          "recommendation": "keep",
          "evidence": [
            "Located in __init__.py suggesting it's meant to be imported",
            "Flask application factory pattern is standard practice",
            "WSGI servers and deployment tools typically call create_app functions"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask application factory function in __init__.py, which is the standard pattern for creating Flask apps. It's likely called by WSGI servers or main entry points to instantiate the application.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "login_required",
        "lineno": 19,
        "pattern_type": "similar_function_names",
        "details": "Similar to login in examples/tutorial/flaskr/auth.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a decorator function used to protect routes that require authentication. Decorators are applied to functions using @ syntax and may not show up in static analysis as direct function calls.",
          "recommendation": "keep",
          "evidence": [
            "Name follows decorator pattern (login_required)",
            "Located in auth.py suggesting authentication functionality",
            "Decorators are applied with @ syntax which may not be detected by static analysis"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a decorator function used to protect routes that require authentication. Decorators are applied to functions using @ syntax and may not show up in static analysis as direct function calls.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "load_logged_in_user",
        "lineno": 33,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/__init__.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This function name suggests it's a Flask before_request handler or similar hook that automatically loads user data before each request. Such functions are registered with Flask and called by the framework, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Name suggests Flask before_request or similar hook pattern",
            "Located in auth.py indicating authentication middleware functionality",
            "Framework hooks are called by Flask, not application code directly"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This function name suggests it's a Flask before_request handler or similar hook that automatically loads user data before each request. Such functions are registered with Flask and called by the framework, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "load_logged_in_user",
        "lineno": 33,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This is a duplicate entry of the same function. Same reasoning applies - it's likely a Flask framework hook that loads user data automatically before requests.",
          "recommendation": "keep",
          "evidence": [
            "Duplicate of previous item with same reasoning",
            "Flask framework hooks are not called directly by application code"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a duplicate entry of the same function. Same reasoning applies - it's likely a Flask framework hook that loads user data automatically before requests.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "register",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_blueprint in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This is likely a Flask route handler function for user registration. Route handlers are called by the Flask framework when matching URLs are accessed, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py suggesting it's an authentication route",
            "Flask route handlers are called by framework via URL routing",
            "Register is a common authentication endpoint name"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely a Flask route handler function for user registration. Route handlers are called by the Flask framework when matching URLs are accessed, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "register",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_blueprint in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py suggesting authentication-related Flask routes",
            "Flask route handlers are invoked by the web framework, not internal code calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "register",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py suggesting authentication-related Flask routes",
            "Flask route handlers are invoked by the web framework, not internal code calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "register",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py suggesting authentication-related Flask routes",
            "Flask route handlers are invoked by the web framework, not internal code calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "register",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py suggesting authentication-related Flask routes",
            "Flask route handlers are invoked by the web framework, not internal code calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/auth.py",
        "name": "register",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_error_handler in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in auth.py suggesting authentication-related Flask routes",
            "Flask route handlers are invoked by the web framework, not internal code calls"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Flask route handler function decorated with @bp.route('/register'). Flask route handlers are called by the Flask framework when HTTP requests match the route pattern, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "get_post",
        "lineno": 28,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function in a tutorial application. Flask route handlers are called by the Flask framework when HTTP requests match the route, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in blog.py suggesting it's a web route handler",
            "Flask tutorial applications typically have route handlers that are called by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a Flask route handler function in a tutorial application. Flask route handlers are called by the Flask framework when HTTP requests match the route, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "get_post",
        "lineno": 28,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function in a tutorial application. Flask route handlers are called by the Flask framework when HTTP requests match the route, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in blog.py suggesting it's a web route handler",
            "Flask tutorial applications typically have route handlers that are called by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a Flask route handler function in a tutorial application. Flask route handlers are called by the Flask framework when HTTP requests match the route, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "get_post",
        "lineno": 28,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function in a tutorial application. Flask route handlers are called by the Flask framework when HTTP requests match the route, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in blog.py suggesting it's a web route handler",
            "Flask tutorial applications typically have route handlers that are called by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a Flask route handler function in a tutorial application. Flask route handlers are called by the Flask framework when HTTP requests match the route, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "create",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to create_jinja_environment in src/flask/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function for creating blog posts in a tutorial application. Flask route handlers are invoked by the Flask framework when matching HTTP requests are made, not called directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in blog.py at line 62 suggesting it's a web route handler for POST creation",
            "Flask tutorial applications typically have CRUD operation handlers called by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a Flask route handler function for creating blog posts in a tutorial application. Flask route handlers are invoked by the Flask framework when matching HTTP requests are made, not called directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "create",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to create_url_adapter in src/flask/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a Flask route handler function for creating blog posts in a tutorial application. Flask route handlers are invoked by the Flask framework when matching HTTP requests are made, not called directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in blog.py at line 62 suggesting it's a web route handler for POST creation",
            "Flask tutorial applications typically have CRUD operation handlers called by the framework"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a Flask route handler function for creating blog posts in a tutorial application. Flask route handlers are invoked by the Flask framework when matching HTTP requests are made, not called directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "create",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to create_logger in src/flask/logging.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Flask route handler function decorated with @bp.route that handles HTTP POST requests to create blog posts. Flask calls this function when the route is accessed, so it doesn't need internal calls within the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Function is decorated with Flask route decorator @bp.route",
            "Flask tutorial application where routes are called by the web framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask route handler function decorated with @bp.route that handles HTTP POST requests to create blog posts. Flask calls this function when the route is accessed, so it doesn't need internal calls within the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "create",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to create_jinja_environment in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Flask route handler function decorated with @bp.route that handles HTTP POST requests to create blog posts. Flask calls this function when the route is accessed, so it doesn't need internal calls within the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Function is decorated with Flask route decorator @bp.route",
            "Flask tutorial application where routes are called by the web framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask route handler function decorated with @bp.route that handles HTTP POST requests to create blog posts. Flask calls this function when the route is accessed, so it doesn't need internal calls within the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "create",
        "lineno": 62,
        "pattern_type": "similar_function_names",
        "details": "Similar to create_global_jinja_loader in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Flask route handler function decorated with @bp.route that handles HTTP POST requests to create blog posts. Flask calls this function when the route is accessed, so it doesn't need internal calls within the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Function is decorated with Flask route decorator @bp.route",
            "Flask tutorial application where routes are called by the web framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask route handler function decorated with @bp.route that handles HTTP POST requests to create blog posts. Flask calls this function when the route is accessed, so it doesn't need internal calls within the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/blog.py",
        "name": "update",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to update_template_context in src/flask/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a Flask route handler function decorated with @bp.route that handles HTTP requests to update blog posts. Flask calls this function when the route is accessed, so it doesn't need internal calls within the codebase.",
          "recommendation": "keep",
          "evidence": [
            "Function is decorated with Flask route decorator @bp.route",
            "Flask tutorial application where routes are called by the web framework"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask route handler function decorated with @bp.route that handles HTTP requests to update blog posts. Flask calls this function when the route is accessed, so it doesn't need internal calls within the codebase.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/db.py",
        "name": "get_db",
        "lineno": 9,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a database connection utility function in a Flask application that likely uses Flask's application context or is called by other parts of the Flask tutorial application. Database utility functions are commonly called indirectly through Flask's context system.",
          "recommendation": "keep",
          "evidence": [
            "Located in db.py indicating it's a database utility function",
            "Flask tutorial applications typically use such functions through application context"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a database connection utility function in a Flask application that likely uses Flask's application context or is called by other parts of the Flask tutorial application. Database utility functions are commonly called indirectly through Flask's context system.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/db.py",
        "name": "get_db",
        "lineno": 9,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is in a Flask tutorial example project, likely demonstrating database connection patterns. Tutorial code is meant to be educational and may not have all functions called within the example itself.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/tutorial directory indicating tutorial/educational code",
            "Database connection functions are typically called by web framework routes"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is in a Flask tutorial example project, likely demonstrating database connection patterns. Tutorial code is meant to be educational and may not have all functions called within the example itself.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/db.py",
        "name": "get_db",
        "lineno": 9,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Duplicate of the previous item - same function in Flask tutorial example. Database connection functions are essential infrastructure code that may be called by Flask's request context.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/tutorial directory indicating tutorial/educational code",
            "Database connection functions are typically called by web framework routes"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Duplicate of the previous item - same function in Flask tutorial example. Database connection functions are essential infrastructure code that may be called by Flask's request context.",
        "recommendation": "keep"
      },
      {
        "module": "examples/tutorial/flaskr/db.py",
        "name": "init_db",
        "lineno": 33,
        "pattern_type": "similar_function_names",
        "details": "Similar to init_db_command in examples/tutorial/flaskr/db.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Database initialization function in Flask tutorial. These are typically called during application setup or via CLI commands, not necessarily in the main application flow.",
          "recommendation": "keep",
          "evidence": [
            "Located in examples/tutorial directory for educational purposes",
            "Database initialization functions are usually called during app setup or migration scripts"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Database initialization function in Flask tutorial. These are typically called during application setup or via CLI commands, not necessarily in the main application flow.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "wrapper",
        "lineno": 85,
        "pattern_type": "similar_function_names",
        "details": "Similar to wrapper_func in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This is a wrapper function in Flask's core app.py file, likely part of a decorator pattern. Wrapper functions are typically returned by decorators and called indirectly.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's core source code (src/flask/app.py)",
            "Wrapper functions are commonly used in decorator patterns and called indirectly"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a wrapper function in Flask's core app.py file, likely part of a decorator pattern. Wrapper functions are typically returned by decorators and called indirectly.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "wrapper",
        "lineno": 97,
        "pattern_type": "similar_function_names",
        "details": "Similar to wrapper_func in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "Another wrapper function in Flask's core app.py, likely part of decorator infrastructure. These functions are called indirectly through Python's decorator mechanism.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's core source code (src/flask/app.py)",
            "Wrapper functions in framework code are essential for decorator functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Another wrapper function in Flask's core app.py, likely part of decorator infrastructure. These functions are called indirectly through Python's decorator mechanism.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "get_send_file_max_age",
        "lineno": 364,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a method on the Flask app class that provides configuration for file serving max age. It's designed to be overridden by users and called by Flask's send_file functionality internally.",
          "recommendation": "keep",
          "evidence": [
            "Method is on main Flask class which is the primary public API",
            "Name suggests it's a configuration hook for send_file operations",
            "Flask framework likely calls this internally during file serving"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a method on the Flask app class that provides configuration for file serving max age. It's designed to be overridden by users and called by Flask's send_file functionality internally.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "get_send_file_max_age",
        "lineno": 364,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a method on the Flask app class that provides configuration for file serving max age. It's designed to be overridden by users and called by Flask's send_file functionality internally.",
          "recommendation": "keep",
          "evidence": [
            "Method is on main Flask class which is the primary public API",
            "Name suggests it's a configuration hook for send_file operations",
            "Flask framework likely calls this internally during file serving"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a method on the Flask app class that provides configuration for file serving max age. It's designed to be overridden by users and called by Flask's send_file functionality internally.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "get_send_file_max_age",
        "lineno": 364,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a method on the Flask app class that provides configuration for file serving max age. It's designed to be overridden by users and called by Flask's send_file functionality internally.",
          "recommendation": "keep",
          "evidence": [
            "Method is on main Flask class which is the primary public API",
            "Name suggests it's a configuration hook for send_file operations",
            "Flask framework likely calls this internally during file serving"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a method on the Flask app class that provides configuration for file serving max age. It's designed to be overridden by users and called by Flask's send_file functionality internally.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "open_resource",
        "lineno": 413,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a public method on the Flask app class for opening resources from the application's package. It's part of Flask's resource management API that users rely on to access bundled files.",
          "recommendation": "keep",
          "evidence": [
            "Method is on main Flask class which is core public API",
            "Resource opening is a common pattern in Flask applications",
            "Method name follows standard Flask naming conventions for public methods"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a public method on the Flask app class for opening resources from the application's package. It's part of Flask's resource management API that users rely on to access bundled files.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "open_instance_resource",
        "lineno": 446,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a public method on the Flask app class for opening resources from the instance folder. It complements open_resource and is part of Flask's resource management API for accessing instance-specific files.",
          "recommendation": "keep",
          "evidence": [
            "Method is on main Flask class which is core public API",
            "Instance folder resource access is a documented Flask feature",
            "Pairs with open_resource to provide complete resource access functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a public method on the Flask app class for opening resources from the instance folder. It complements open_resource and is part of Flask's resource management API for accessing instance-specific files.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "run",
        "lineno": 631,
        "pattern_type": "similar_function_names",
        "details": "Similar to run_command in src/flask/cli.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "The run() method is a core Flask API method that developers use to start their Flask applications. This is one of the most commonly used Flask methods externally.",
          "recommendation": "keep",
          "evidence": [
            "Flask.run() is documented as the primary way to start a Flask development server",
            "This method is part of Flask's main public API and called by user applications, not internally"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The run() method is a core Flask API method that developers use to start their Flask applications. This is one of the most commonly used Flask methods externally.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "app_context",
        "lineno": 1451,
        "pattern_type": "similar_function_names",
        "details": "Similar to app in src/flask/cli.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "The app_context() method returns an application context manager that users employ for accessing Flask application features outside of request context. This is a fundamental Flask API method.",
          "recommendation": "keep",
          "evidence": [
            "Flask.app_context() is documented as the way to create application contexts",
            "Used by developers in testing, CLI commands, and background tasks"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The app_context() method returns an application context manager that users employ for accessing Flask application features outside of request context. This is a fundamental Flask API method.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "app_context",
        "lineno": 1451,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_context_processor in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "The app_context() method returns an application context manager that users employ for accessing Flask application features outside of request context. This is a fundamental Flask API method.",
          "recommendation": "keep",
          "evidence": [
            "Flask.app_context() is documented as the way to create application contexts",
            "Used by developers in testing, CLI commands, and background tasks"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The app_context() method returns an application context manager that users employ for accessing Flask application features outside of request context. This is a fundamental Flask API method.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/app.py",
        "name": "request_context",
        "lineno": 1471,
        "pattern_type": "similar_function_names",
        "details": "Similar to request in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "The request_context() method creates a request context for testing and other scenarios where you need to simulate a request. This is a core Flask testing and debugging API.",
          "recommendation": "keep",
          "evidence": [
            "Flask.request_context() is documented for creating request contexts in testing",
            "Essential method for Flask testing patterns and debugging scenarios"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The request_context() method creates a request context for testing and other scenarios where you need to simulate a request. This is a core Flask testing and debugging API.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/blueprints.py",
        "name": "get_send_file_max_age",
        "lineno": 55,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This method appears to be a hook/callback method that can be overridden to customize file caching behavior in Flask blueprints. Such methods are designed to be called by the framework internally.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows Flask's pattern for customizable hook methods",
            "Located in blueprints.py suggesting it's part of Flask's blueprint extension system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This method appears to be a hook/callback method that can be overridden to customize file caching behavior in Flask blueprints. Such methods are designed to be called by the framework internally.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/blueprints.py",
        "name": "get_send_file_max_age",
        "lineno": 55,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a method in Flask's Blueprint class that provides a hook for customizing file caching behavior. Flask is a web framework library where Blueprint methods are part of the public API for developers to override.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint class is a core Flask component exported for public use",
            "Method follows Flask's pattern for customizable behavior hooks",
            "Flask framework would call this internally during file serving"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a method in Flask's Blueprint class that provides a hook for customizing file caching behavior. Flask is a web framework library where Blueprint methods are part of the public API for developers to override.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/blueprints.py",
        "name": "get_send_file_max_age",
        "lineno": 55,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a method in Flask's Blueprint class that provides a hook for customizing file caching behavior. Flask is a web framework library where Blueprint methods are part of the public API for developers to override.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint class is a core Flask component exported for public use",
            "Method follows Flask's pattern for customizable behavior hooks",
            "Flask framework would call this internally during file serving"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a method in Flask's Blueprint class that provides a hook for customizing file caching behavior. Flask is a web framework library where Blueprint methods are part of the public API for developers to override.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/blueprints.py",
        "name": "open_resource",
        "lineno": 104,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is a Blueprint method that provides resource file access functionality. As part of Flask's public API, it's intended for developers to access blueprint-relative resources like templates or static files.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint is a public Flask class with documented API methods",
            "Resource opening is a common pattern in web frameworks",
            "Method name follows Flask's naming conventions for public methods"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is a Blueprint method that provides resource file access functionality. As part of Flask's public API, it's intended for developers to access blueprint-relative resources like templates or static files.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "get_version",
        "lineno": 267,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Click command callback function in Flask's CLI module. Click framework calls these functions when processing command-line arguments, so they don't need internal code references.",
          "recommendation": "keep",
          "evidence": [
            "Located in cli.py suggesting command-line interface functionality",
            "get_version is a standard CLI callback pattern",
            "Click framework would invoke this when --version flag is used"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Click command callback function in Flask's CLI module. Click framework calls these functions when processing command-line arguments, so they don't need internal code references.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "get_version",
        "lineno": 267,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "callback",
          "reason": "This appears to be a Click command callback function in Flask's CLI module. Click framework calls these functions when processing command-line arguments, so they don't need internal code references.",
          "recommendation": "keep",
          "evidence": [
            "Located in cli.py suggesting command-line interface functionality",
            "get_version is a standard CLI callback pattern",
            "Click framework would invoke this when --version flag is used"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a Click command callback function in Flask's CLI module. Click framework calls these functions when processing command-line arguments, so they don't need internal code references.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "get_version",
        "lineno": 267,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This appears to be a CLI command callback function that would be invoked by Flask's command-line interface when users run version-related commands. CLI command functions are typically called by the framework rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in cli.py suggesting it's part of Flask's command-line interface",
            "Function name follows CLI command naming pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a CLI command callback function that would be invoked by Flask's command-line interface when users run version-related commands. CLI command functions are typically called by the framework rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "load_dotenv",
        "lineno": 698,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/__init__.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "callback",
          "reason": "This function is likely called during Flask's application initialization or configuration loading process. Environment file loading functions are typically invoked by the framework during startup rather than being called directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in cli.py indicating framework-level functionality",
            "Dotenv loading is a common framework initialization step"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This function is likely called during Flask's application initialization or configuration loading process. Environment file loading functions are typically invoked by the framework during startup rather than being called directly in application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "load_dotenv",
        "lineno": 698,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "callback",
          "reason": "This function is likely called during Flask's application initialization or configuration loading process. Environment file loading functions are typically invoked by the framework during startup rather than being called directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in cli.py indicating framework-level functionality",
            "Dotenv loading is a common framework initialization step"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This function is likely called during Flask's application initialization or configuration loading process. Environment file loading functions are typically invoked by the framework during startup rather than being called directly in application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "routes_command",
        "lineno": 1061,
        "pattern_type": "similar_function_names",
        "details": "Similar to route in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This is clearly a CLI command function that displays route information when invoked through Flask's command-line interface. The '_command' suffix strongly indicates it's a CLI callback that users can invoke from the command line.",
          "recommendation": "keep",
          "evidence": [
            "Function name ends with '_command' indicating CLI command callback",
            "Located in cli.py and likely handles 'flask routes' command"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is clearly a CLI command function that displays route information when invoked through Flask's command-line interface. The '_command' suffix strongly indicates it's a CLI callback that users can invoke from the command line.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "load_app",
        "lineno": 333,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/__init__.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This function is likely part of Flask's application loading mechanism, called by the CLI system or application factory patterns. Application loading functions are typically invoked by the framework during initialization rather than directly by user code.",
          "recommendation": "keep",
          "evidence": [
            "Located in cli.py suggesting it's part of Flask's CLI infrastructure",
            "App loading functions are essential for framework bootstrapping"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This function is likely part of Flask's application loading mechanism, called by the CLI system or application factory patterns. Application loading functions are typically invoked by the framework during initialization rather than directly by user code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "load_app",
        "lineno": 333,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This function is in Flask's CLI module and is likely used by Flask's command-line interface system or exposed as part of Flask's public API for loading applications. CLI functions are typically called by the framework's command dispatch system.",
          "recommendation": "keep",
          "evidence": [
            "Located in cli.py which suggests it's part of Flask's command-line interface",
            "Function name suggests it's a utility for loading Flask applications, likely used by CLI framework"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This function is in Flask's CLI module and is likely used by Flask's command-line interface system or exposed as part of Flask's public API for loading applications. CLI functions are typically called by the framework's command dispatch system.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "get_command",
        "lineno": 609,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "This method is likely part of a command-line interface class that implements Click or similar CLI framework protocols. The get_command method is a standard interface method used by CLI frameworks to retrieve command objects dynamically.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows CLI framework convention for command retrieval",
            "Located in cli.py indicating it's part of command-line interface implementation"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This method is likely part of a command-line interface class that implements Click or similar CLI framework protocols. The get_command method is a standard interface method used by CLI frameworks to retrieve command objects dynamically.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "get_command",
        "lineno": 609,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "Same as previous item - this method implements CLI framework protocols for command retrieval. Multiple instances suggest it may be implemented in different classes within the CLI module.",
          "recommendation": "keep",
          "evidence": [
            "Method name follows CLI framework convention for command retrieval",
            "Part of Flask's command-line interface system"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Same as previous item - this method implements CLI framework protocols for command retrieval. Multiple instances suggest it may be implemented in different classes within the CLI module.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "get_command",
        "lineno": 609,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "Third instance of get_command method, likely another implementation of the CLI framework interface. These methods are called by the CLI framework itself, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Implements CLI framework interface for command discovery",
            "Called by framework infrastructure rather than application code"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Third instance of get_command method, likely another implementation of the CLI framework interface. These methods are called by the CLI framework itself, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This appears to be a property or attribute in Flask's CLI module that provides access to the Flask application instance. It's likely used by CLI commands or exposed as part of the public API for command implementations.",
          "recommendation": "keep",
          "evidence": [
            "Located in CLI module where app access is commonly needed",
            "Short name suggests it's a commonly used property or attribute"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This appears to be a property or attribute in Flask's CLI module that provides access to the Flask application instance. It's likely used by CLI commands or exposed as part of the public API for command implementations.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
          "recommendation": "investigate",
          "evidence": [
            "Only location and generic 'app (pattern)' description provided",
            "No actual code content visible to analyze"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
          "recommendation": "investigate",
          "evidence": [
            "Only location and generic 'app (pattern)' description provided",
            "No actual code content visible to analyze"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
          "recommendation": "investigate",
          "evidence": [
            "Only location and generic 'app (pattern)' description provided",
            "No actual code content visible to analyze"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
          "recommendation": "investigate",
          "evidence": [
            "Only location and generic 'app (pattern)' description provided",
            "No actual code content visible to analyze"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
          "recommendation": "investigate",
          "evidence": [
            "Only location and generic 'app (pattern)' description provided",
            "No actual code content visible to analyze"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot determine if this is dead code without seeing the actual code at line 963 in flask/cli.py. The item shows only 'app (pattern)' which appears to be a variable or pattern match, but no context is provided about what code block or statement this refers to.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location (src/flask/cli.py:963) and pattern name",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location (src/flask/cli.py:963) and pattern name",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location (src/flask/cli.py:963) and pattern name",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_context_processor in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location (src/flask/cli.py:963) and pattern name",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_errorhandler in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
          "recommendation": "investigate",
          "evidence": [
            "All items have identical location (src/flask/cli.py:963) and pattern name",
            "No actual code content provided for analysis"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Unable to analyze without seeing the actual code at src/flask/cli.py:963. All 5 items reference the same location and pattern name, suggesting potential duplicate detection or incomplete analysis data.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_url_value_preprocessor in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Cannot analyze without seeing the actual code at src/flask/cli.py:963. The pattern 'app' is too generic and could be a variable, function parameter, or code block that may or may not be reachable.",
          "recommendation": "investigate",
          "evidence": [
            "Only location and pattern name provided without code context",
            "Flask CLI module typically contains application initialization code that may be conditionally executed"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Cannot analyze without seeing the actual code at src/flask/cli.py:963. The pattern 'app' is too generic and could be a variable, function parameter, or code block that may or may not be reachable.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/cli.py",
        "name": "app",
        "lineno": 963,
        "pattern_type": "similar_function_names",
        "details": "Similar to app_url_defaults in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "unreachable",
          "reason": "Duplicate entry of the same pattern at the same location. Cannot determine if this represents dead code without seeing the actual implementation and surrounding context.",
          "recommendation": "investigate",
          "evidence": [
            "Identical to previous entry - same location and pattern",
            "May represent duplicate detection of the same code element"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Duplicate entry of the same pattern at the same location. Cannot determine if this represents dead code without seeing the actual implementation and surrounding context.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 30,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "The __get__ method is a Python descriptor protocol method that is called automatically by Python's attribute access mechanism. These methods are invoked by the interpreter, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "__get__ is part of Python's descriptor protocol",
            "Called automatically during attribute access, not by direct application code"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "The __get__ method is a Python descriptor protocol method that is called automatically by Python's attribute access mechanism. These methods are invoked by the interpreter, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 30,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "Duplicate detection of the same __get__ descriptor method. This is a Python protocol method that is automatically invoked by the interpreter during attribute access operations.",
          "recommendation": "keep",
          "evidence": [
            "Python descriptor protocol method called by interpreter",
            "Duplicate entry of the same method at same location"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate detection of the same __get__ descriptor method. This is a Python protocol method that is automatically invoked by the interpreter during attribute access operations.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 30,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "interface_method",
          "reason": "Third duplicate detection of the same __get__ method. Descriptor protocol methods like __get__ are essential for proper attribute access behavior and are called by Python's attribute resolution system.",
          "recommendation": "keep",
          "evidence": [
            "Part of Python's descriptor protocol - called automatically",
            "Multiple duplicate detections of the same method suggest analysis tool issue rather than dead code"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Third duplicate detection of the same __get__ method. Descriptor protocol methods like __get__ are essential for proper attribute access behavior and are called by Python's attribute resolution system.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 33,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
          "recommendation": "keep",
          "evidence": [
            "__get__ is part of Python's descriptor protocol",
            "Called automatically by Python interpreter during attribute access",
            "Essential for descriptor functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 33,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
          "recommendation": "keep",
          "evidence": [
            "__get__ is part of Python's descriptor protocol",
            "Called automatically by Python interpreter during attribute access",
            "Essential for descriptor functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 33,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
          "recommendation": "keep",
          "evidence": [
            "__get__ is part of Python's descriptor protocol",
            "Called automatically by Python interpreter during attribute access",
            "Essential for descriptor functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 35,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
          "recommendation": "keep",
          "evidence": [
            "__get__ is part of Python's descriptor protocol",
            "Called automatically by Python interpreter during attribute access",
            "Essential for descriptor functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 35,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
          "recommendation": "keep",
          "evidence": [
            "__get__ is part of Python's descriptor protocol",
            "Called automatically by Python interpreter during attribute access",
            "Essential for descriptor functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The __get__ method is a Python descriptor protocol method that is automatically called by the Python interpreter when the descriptor is accessed as an attribute. These methods are not called directly in code but are invoked by Python's attribute access mechanism.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "__get__",
        "lineno": 35,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "__get__ is a Python descriptor protocol method that is called automatically by the Python interpreter when accessing attributes. It doesn't need to be called directly by application code to be functional.",
          "recommendation": "keep",
          "evidence": [
            "__get__ implements the descriptor protocol in Python",
            "Called automatically by Python's attribute access mechanism"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "__get__ is a Python descriptor protocol method that is called automatically by the Python interpreter when accessing attributes. It doesn't need to be called directly by application code to be functional.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "get_namespace",
        "lineno": 323,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Flask is a web framework library and Config.get_namespace appears to be a utility method for configuration management. Even though this is marked as an application project, Flask itself serves as a library/framework for web applications.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's Config class which is a core framework component",
            "Method name suggests it's designed for external use to retrieve configuration namespaces"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Flask is a web framework library and Config.get_namespace appears to be a utility method for configuration management. Even though this is marked as an application project, Flask itself serves as a library/framework for web applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "get_namespace",
        "lineno": 323,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of item #2 - same method in Flask's Config class. This appears to be a utility method for configuration management that would be used by Flask applications.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's Config class which is a core framework component",
            "Method name suggests it's designed for external use to retrieve configuration namespaces"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of item #2 - same method in Flask's Config class. This appears to be a utility method for configuration management that would be used by Flask applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/config.py",
        "name": "get_namespace",
        "lineno": 323,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of items #2 and #3 - same method in Flask's Config class. This is a configuration utility method that would be called by Flask applications using the framework.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's Config class which is a core framework component",
            "Method name suggests it's designed for external use to retrieve configuration namespaces"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of items #2 and #3 - same method in Flask's Config class. This is a configuration utility method that would be called by Flask applications using the framework.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "copy_current_request_context",
        "lineno": 153,
        "pattern_type": "similar_function_names",
        "details": "Similar to copy in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a Flask utility function for copying request context, which is essential for handling threading and asynchronous operations in Flask applications. It's a framework feature that applications would use directly.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's context module which handles request/application contexts",
            "Function name indicates it's designed for external use to manage request contexts"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a Flask utility function for copying request context, which is essential for handling threading and asynchronous operations in Flask applications. It's a framework feature that applications would use directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "has_request_context",
        "lineno": 208,
        "pattern_type": "similar_function_names",
        "details": "Similar to has_request in src/flask/ctx.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a Flask utility function that checks if there's an active request context. Flask is a web framework library where this function would be used by application developers to conditionally execute code based on context availability.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's context module, a core part of the web framework",
            "Context checking functions are essential utilities in web frameworks for conditional logic"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask utility function that checks if there's an active request context. Flask is a web framework library where this function would be used by application developers to conditionally execute code based on context availability.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_debug_flag in src/flask/helpers.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This is likely a get method on a context stack or similar container class in Flask. The get method implements standard dictionary-like protocol and would be called by Flask's internal machinery or user code accessing context data.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python container protocol",
            "Located in Flask's context module where context data access is fundamental"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely a get method on a context stack or similar container class in Flask. The get method implements standard dictionary-like protocol and would be called by Flask's internal machinery or user code accessing context data.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_load_dotenv in src/flask/helpers.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Same as previous - this is a get method implementing dictionary-like access protocol. Multiple instances suggest it's on different classes or the same method detected multiple times, both indicating it's part of Flask's public interface.",
          "recommendation": "keep",
          "evidence": [
            "Standard dictionary-like interface method",
            "Part of Flask's context system which is heavily used"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Same as previous - this is a get method implementing dictionary-like access protocol. Multiple instances suggest it's on different classes or the same method detected multiple times, both indicating it's part of Flask's public interface.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_template_attribute in src/flask/helpers.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Another instance of the get method, reinforcing that this is a standard interface method used throughout Flask's context system for accessing context data in a dictionary-like manner.",
          "recommendation": "keep",
          "evidence": [
            "Implements standard Python container protocol",
            "Multiple occurrences suggest widespread usage pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Another instance of the get method, reinforcing that this is a standard interface method used throughout Flask's context system for accessing context data in a dictionary-like manner.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_flashed_messages in src/flask/helpers.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Fourth instance of the get method, confirming this is a fundamental part of Flask's context access interface. These methods are called by user applications and Flask's internal systems for context data retrieval.",
          "recommendation": "keep",
          "evidence": [
            "Standard dictionary-like access method",
            "Core part of Flask's context management system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Fourth instance of the get method, confirming this is a fundamental part of Flask's context access interface. These methods are called by user applications and Flask's internal systems for context data retrieval.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_root_path in src/flask/helpers.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask context module where objects are often accessed as mappings"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_name in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask context module where objects are often accessed as mappings"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_domain in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask context module where objects are often accessed as mappings"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_path in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask context module where objects are often accessed as mappings"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_httponly in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask context module where objects are often accessed as mappings"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method is a standard dictionary-like interface method that implements the mapping protocol. It's likely called by Python's built-in functions, frameworks, or external code that treats the object as a mapping.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_secure in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's ctx.py which handles request/application context",
            "get() is a standard dictionary protocol method used for safe key access",
            "Context objects are accessed by users and Flask internals using dict-like syntax"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_samesite in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's ctx.py which handles request/application context",
            "get() is a standard dictionary protocol method used for safe key access",
            "Context objects are accessed by users and Flask internals using dict-like syntax"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_partitioned in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's ctx.py which handles request/application context",
            "get() is a standard dictionary protocol method used for safe key access",
            "Context objects are accessed by users and Flask internals using dict-like syntax"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_expiration_time in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's ctx.py which handles request/application context",
            "get() is a standard dictionary protocol method used for safe key access",
            "Context objects are accessed by users and Flask internals using dict-like syntax"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_signing_serializer in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's ctx.py which handles request/application context",
            "get() is a standard dictionary protocol method used for safe key access",
            "Context objects are accessed by users and Flask internals using dict-like syntax"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The 'get' method in Flask's context objects implements dictionary-like interface protocol. These methods are called by Python's built-in functions and user code accessing context variables.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "get",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_source in src/flask/templating.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This appears to be a dict-like interface method in a context object. Flask context objects are commonly accessed using dict-like patterns by users and extensions.",
          "recommendation": "keep",
          "evidence": [
            "Located in ctx.py which handles Flask request/application contexts",
            "Method name 'get' follows standard dict interface pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a dict-like interface method in a context object. Flask context objects are commonly accessed using dict-like patterns by users and extensions.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "wrapper",
        "lineno": 201,
        "pattern_type": "similar_function_names",
        "details": "Similar to wrapper_func in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "callback",
          "reason": "This is likely a decorator wrapper function in Flask's context handling. Wrapper functions are typically called indirectly through the decorator mechanism rather than direct function calls.",
          "recommendation": "keep",
          "evidence": [
            "Located in ctx.py suggesting context management functionality",
            "Name 'wrapper' indicates decorator pattern usage"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is likely a decorator wrapper function in Flask's context handling. Wrapper functions are typically called indirectly through the decorator mechanism rather than direct function calls.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/ctx.py",
        "name": "session",
        "lineno": 381,
        "pattern_type": "similar_function_names",
        "details": "Similar to session_transaction in src/flask/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "Flask's session is a core public API feature accessed by users in their applications. It's likely a property or attribute that provides access to session data.",
          "recommendation": "keep",
          "evidence": [
            "Session handling is fundamental Flask functionality",
            "Located in ctx.py which manages request contexts where session is accessed"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Flask's session is a core public API feature accessed by users in their applications. It's likely a property or attribute that provides access to session data.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_debug_flag",
        "lineno": 27,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This helper function in Flask's helpers module is likely part of the public API for retrieving debug configuration. Helper functions are commonly used by applications and extensions.",
          "recommendation": "keep",
          "evidence": [
            "Located in helpers.py suggesting it's a utility function",
            "Debug flag retrieval is common functionality needed by Flask applications"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This helper function in Flask's helpers module is likely part of the public API for retrieving debug configuration. Helper functions are commonly used by applications and extensions.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_debug_flag",
        "lineno": 27,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This helper function in Flask's helpers module is likely part of the public API for retrieving debug configuration. Helper functions are commonly used by applications and extensions.",
          "recommendation": "keep",
          "evidence": [
            "Located in helpers.py suggesting it's a utility function",
            "Debug flag retrieval is common functionality needed by Flask applications"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This helper function in Flask's helpers module is likely part of the public API for retrieving debug configuration. Helper functions are commonly used by applications and extensions.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_load_dotenv",
        "lineno": 35,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a Flask helper function that's likely part of the public API for loading environment variables from .env files. Flask users would call this function directly in their applications for configuration management.",
          "recommendation": "keep",
          "evidence": [
            "Located in flask/helpers.py which contains public utility functions",
            "Function name follows Flask's naming convention for public helpers",
            "Environment variable loading is a common Flask application pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask helper function that's likely part of the public API for loading environment variables from .env files. Flask users would call this function directly in their applications for configuration management.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_load_dotenv",
        "lineno": 35,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a Flask helper function that's likely part of the public API for loading environment variables from .env files. Flask users would call this function directly in their applications for configuration management.",
          "recommendation": "keep",
          "evidence": [
            "Located in flask/helpers.py which contains public utility functions",
            "Function name follows Flask's naming convention for public helpers",
            "Environment variable loading is a common Flask application pattern"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a Flask helper function that's likely part of the public API for loading environment variables from .env files. Flask users would call this function directly in their applications for configuration management.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_template_attribute",
        "lineno": 288,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a Flask helper function for accessing template attributes, which is part of Flask's template system API. Users call this to programmatically access template variables and functions from Python code.",
          "recommendation": "keep",
          "evidence": [
            "Template manipulation is a core Flask feature",
            "Function provides programmatic access to Jinja2 template attributes",
            "Located in helpers.py indicating it's meant for external use"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a Flask helper function for accessing template attributes, which is part of Flask's template system API. Users call this to programmatically access template variables and functions from Python code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_template_attribute",
        "lineno": 288,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a Flask helper function for accessing template attributes, which is part of Flask's template system API. Users call this to programmatically access template variables and functions from Python code.",
          "recommendation": "keep",
          "evidence": [
            "Template manipulation is a core Flask feature",
            "Function provides programmatic access to Jinja2 template attributes",
            "Located in helpers.py indicating it's meant for external use"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a Flask helper function for accessing template attributes, which is part of Flask's template system API. Users call this to programmatically access template variables and functions from Python code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_flashed_messages",
        "lineno": 344,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core Flask function used in templates and view functions to retrieve flash messages. It's a fundamental part of Flask's message flashing system and widely used by Flask applications.",
          "recommendation": "keep",
          "evidence": [
            "Flash messages are a core Flask feature for user feedback",
            "Commonly called in Jinja2 templates and view functions",
            "Essential part of Flask's session-based messaging system"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core Flask function used in templates and view functions to retrieve flash messages. It's a fundamental part of Flask's message flashing system and widely used by Flask applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_flashed_messages",
        "lineno": 344,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core Flask function used in templates and application code to retrieve flash messages. It's part of Flask's public API for message flashing functionality.",
          "recommendation": "keep",
          "evidence": [
            "Function is in flask/helpers.py which contains public utility functions",
            "Flash messaging is a standard web framework feature that users call from templates and views"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core Flask function used in templates and application code to retrieve flash messages. It's part of Flask's public API for message flashing functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_root_path",
        "lineno": 571,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a Flask utility function for determining application root paths. It's used for package discovery and resource loading, which are common needs in Flask applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in helpers.py indicating it's a public utility function",
            "Root path detection is essential for Flask's module/blueprint loading system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a Flask utility function for determining application root paths. It's used for package discovery and resource loading, which are common needs in Flask applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/helpers.py",
        "name": "get_root_path",
        "lineno": 571,
        "pattern_type": "similar_function_names",
        "details": "Similar to get in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a Flask utility function for determining application root paths. It's used for package discovery and resource loading, which are common needs in Flask applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in helpers.py indicating it's a public utility function",
            "Root path detection is essential for Flask's module/blueprint loading system"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a Flask utility function for determining application root paths. It's used for package discovery and resource loading, which are common needs in Flask applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "dumps",
        "lineno": 13,
        "pattern_type": "similar_function_names",
        "details": "Similar to dump in src/flask/json/__init__.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's JSON serialization function, exported in the json package __init__.py. It's part of Flask's public API for JSON handling and likely used by applications for serializing data.",
          "recommendation": "keep",
          "evidence": [
            "Located in __init__.py indicating it's exported as part of the package API",
            "JSON dumps/loads are standard functions that applications need for serialization"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's JSON serialization function, exported in the json package __init__.py. It's part of Flask's public API for JSON handling and likely used by applications for serializing data.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "dumps",
        "lineno": 13,
        "pattern_type": "similar_function_names",
        "details": "Similar to dump in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's JSON serialization function, exported in the json package __init__.py. It's part of Flask's public API for JSON handling and likely used by applications for serializing data.",
          "recommendation": "keep",
          "evidence": [
            "Located in __init__.py indicating it's exported as part of the package API",
            "JSON dumps/loads are standard functions that applications need for serialization"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's JSON serialization function, exported in the json package __init__.py. It's part of Flask's public API for JSON handling and likely used by applications for serializing data.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "dump",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to dumps in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's json.dump function exported in the package's __init__.py file. Flask is a web framework library where this function is part of the public API for users to serialize JSON data.",
          "recommendation": "keep",
          "evidence": [
            "Located in __init__.py indicating it's part of the public package interface",
            "Flask is a widely-used web framework where JSON serialization is core functionality",
            "Function name 'dump' follows standard JSON library conventions"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's json.dump function exported in the package's __init__.py file. Flask is a web framework library where this function is part of the public API for users to serialize JSON data.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "dump",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to dumps in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be a duplicate entry of the same dump function. As Flask's public JSON API, it's intended for external use by Flask applications.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous dump function",
            "Part of Flask's public JSON module interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a duplicate entry of the same dump function. As Flask's public JSON API, it's intended for external use by Flask applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "dump",
        "lineno": 47,
        "pattern_type": "similar_function_names",
        "details": "Similar to dumps in src/flask/json/tag.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be another duplicate entry of the same dump function. Flask's JSON dump functionality is essential public API.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous dump function entries",
            "Critical part of Flask's JSON handling capabilities"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be another duplicate entry of the same dump function. Flask's JSON dump functionality is essential public API.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "loads",
        "lineno": 77,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/__init__.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's json.loads function for deserializing JSON data. It's exported in __init__.py as part of Flask's public API for parsing JSON in web applications.",
          "recommendation": "keep",
          "evidence": [
            "Located in __init__.py indicating public package interface",
            "JSON deserialization is fundamental functionality for web frameworks",
            "Follows standard naming convention matching Python's json.loads"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's json.loads function for deserializing JSON data. It's exported in __init__.py as part of Flask's public API for parsing JSON in web applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "loads",
        "lineno": 77,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be a duplicate entry of the loads function. As part of Flask's JSON module, it's essential public API for deserializing JSON data in Flask applications.",
          "recommendation": "keep",
          "evidence": [
            "Same location as previous loads function",
            "Essential component of Flask's JSON processing capabilities"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a duplicate entry of the loads function. As part of Flask's JSON module, it's essential public API for deserializing JSON data in Flask applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "load",
        "lineno": 108,
        "pattern_type": "similar_function_names",
        "details": "Similar to loads in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This is Flask's json.load function exported in the json package's __init__.py. Flask is a web framework library where users need to load JSON data from files and streams.",
          "recommendation": "keep",
          "evidence": [
            "Exported in package __init__.py indicating public API",
            "Flask is a library framework where JSON loading is core functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This is Flask's json.load function exported in the json package's __init__.py. Flask is a web framework library where users need to load JSON data from files and streams.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "load",
        "lineno": 108,
        "pattern_type": "similar_function_names",
        "details": "Similar to loads in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of item #1 - Flask's json.load function exported in the json package's __init__.py for public use by Flask applications.",
          "recommendation": "keep",
          "evidence": [
            "Exported in package __init__.py indicating public API",
            "Flask is a library framework where JSON loading is core functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of item #1 - Flask's json.load function exported in the json package's __init__.py for public use by Flask applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/__init__.py",
        "name": "load",
        "lineno": 108,
        "pattern_type": "similar_function_names",
        "details": "Similar to loads in src/flask/json/tag.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "Duplicate of items #1 and #2 - Flask's json.load function exported in the json package's __init__.py for public consumption.",
          "recommendation": "keep",
          "evidence": [
            "Exported in package __init__.py indicating public API",
            "Flask is a library framework where JSON loading is core functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "Duplicate of items #1 and #2 - Flask's json.load function exported in the json package's __init__.py for public consumption.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/provider.py",
        "name": "_default",
        "lineno": 108,
        "pattern_type": "similar_function_names",
        "details": "Similar to _default_template_ctx_processor in src/flask/templating.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "interface_method",
          "reason": "This appears to be a private method (_default prefix) in Flask's JSON provider system, likely used as a default serialization handler or fallback mechanism for JSON encoding.",
          "recommendation": "keep",
          "evidence": [
            "Private method naming convention suggests internal framework use",
            "Located in provider.py indicating part of Flask's pluggable JSON system"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This appears to be a private method (_default prefix) in Flask's JSON provider system, likely used as a default serialization handler or fallback mechanism for JSON encoding.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/provider.py",
        "name": "dumps",
        "lineno": 41,
        "pattern_type": "similar_function_names",
        "details": "Similar to dump in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is Flask's json.dumps function in the JSON provider, which is core functionality for serializing Python objects to JSON strings in Flask applications.",
          "recommendation": "keep",
          "evidence": [
            "Standard JSON serialization function name following Python json module conventions",
            "Part of Flask's JSON provider system which is essential for web API responses"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is Flask's json.dumps function in the JSON provider, which is core functionality for serializing Python objects to JSON strings in Flask applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/provider.py",
        "name": "dump",
        "lineno": 49,
        "pattern_type": "similar_function_names",
        "details": "Similar to dumps in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core JSON serialization method in Flask's JSON provider interface. Flask applications and extensions rely on this method for converting Python objects to JSON strings.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's JSON provider public API",
            "Essential method for JSON serialization functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core JSON serialization method in Flask's JSON provider interface. Flask applications and extensions rely on this method for converting Python objects to JSON strings.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/provider.py",
        "name": "dump",
        "lineno": 49,
        "pattern_type": "similar_function_names",
        "details": "Similar to dumps in src/flask/json/tag.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be a duplicate detection of the same dump method. The method is part of Flask's core JSON functionality and is essential for the framework.",
          "recommendation": "keep",
          "evidence": [
            "Same as previous dump method",
            "Core Flask JSON provider functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a duplicate detection of the same dump method. The method is part of Flask's core JSON functionality and is essential for the framework.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/provider.py",
        "name": "loads",
        "lineno": 59,
        "pattern_type": "similar_function_names",
        "details": "Similar to load in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core JSON deserialization method in Flask's JSON provider interface. Flask applications depend on this method for parsing JSON strings into Python objects.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's JSON provider public API",
            "Essential method for JSON deserialization functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core JSON deserialization method in Flask's JSON provider interface. Flask applications depend on this method for parsing JSON strings into Python objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/provider.py",
        "name": "load",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to loads in src/flask/json/provider.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core JSON loading method in Flask's JSON provider interface. It's used for reading JSON data from file-like objects, which is standard functionality in web applications.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's JSON provider public API",
            "Standard JSON loading functionality from streams/files"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core JSON loading method in Flask's JSON provider interface. It's used for reading JSON data from file-like objects, which is standard functionality in web applications.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/provider.py",
        "name": "load",
        "lineno": 67,
        "pattern_type": "similar_function_names",
        "details": "Similar to loads in src/flask/json/tag.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This appears to be a duplicate detection of the same load method. The method is part of Flask's core JSON functionality for loading from file-like objects.",
          "recommendation": "keep",
          "evidence": [
            "Same as previous load method",
            "Core Flask JSON provider functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a duplicate detection of the same load method. The method is part of Flask's core JSON functionality for loading from file-like objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/json/tag.py",
        "name": "register",
        "lineno": 256,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_blueprint in src/flask/sansio/app.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "public_api",
          "reason": "Without seeing the actual code at line 256, this appears to be a register method in Flask's JSON tag module. Register methods are typically used to register serializers/deserializers and could be part of Flask's public API for JSON handling.",
          "recommendation": "investigate",
          "evidence": [
            "Located in Flask's json/tag.py module which handles JSON serialization",
            "Register methods are common patterns for plugin/extension systems"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Without seeing the actual code at line 256, this appears to be a register method in Flask's JSON tag module. Register methods are typically used to register serializers/deserializers and could be part of Flask's public API for JSON handling.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/json/tag.py",
        "name": "register",
        "lineno": 256,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_blueprint in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "public_api",
          "reason": "Duplicate entry of the same register method. This appears to be a register method in Flask's JSON tag module that could be part of the public API for registering JSON serialization handlers.",
          "recommendation": "investigate",
          "evidence": [
            "Same location as item #1 in Flask's JSON handling module",
            "Register pattern suggests API for extending JSON functionality"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Duplicate entry of the same register method. This appears to be a register method in Flask's JSON tag module that could be part of the public API for registering JSON serialization handlers.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/json/tag.py",
        "name": "register",
        "lineno": 256,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "public_api",
          "reason": "Another duplicate entry of the register method. Given Flask's architecture, this is likely a method for registering custom JSON serializers/deserializers which would be part of the public API.",
          "recommendation": "investigate",
          "evidence": [
            "Consistent location in Flask's JSON tag system",
            "Register methods are typically public API entry points"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Another duplicate entry of the register method. Given Flask's architecture, this is likely a method for registering custom JSON serializers/deserializers which would be part of the public API.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/json/tag.py",
        "name": "register",
        "lineno": 256,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "public_api",
          "reason": "Fourth duplicate of the same register method. This method is likely used by developers to register custom JSON serialization handlers, making it part of Flask's public API even if not called internally.",
          "recommendation": "investigate",
          "evidence": [
            "Part of Flask's JSON serialization system",
            "Registration methods are common public API patterns"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Fourth duplicate of the same register method. This method is likely used by developers to register custom JSON serialization handlers, making it part of Flask's public API even if not called internally.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/json/tag.py",
        "name": "register",
        "lineno": 256,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "uncertain",
          "confidence": 30,
          "category": "public_api",
          "reason": "Fifth duplicate of the register method. Despite being flagged as unused, this is likely a public API method for Flask users to register custom JSON serialization tags, which wouldn't show internal usage.",
          "recommendation": "investigate",
          "evidence": [
            "Located in Flask's JSON tag handling module",
            "Register methods serve as extension points for users"
          ]
        },
        "status": "uncertain",
        "confidence": 30,
        "reason": "Fifth duplicate of the register method. Despite being flagged as unused, this is likely a public API method for Flask users to register custom JSON serialization tags, which wouldn't show internal usage.",
        "recommendation": "investigate"
      },
      {
        "module": "src/flask/json/tag.py",
        "name": "register",
        "lineno": 256,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_error_handler in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This appears to be a register method in Flask's JSON tag system, likely used for registering custom JSON serializers/deserializers. Flask applications commonly need to register custom JSON handling for specific types.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's json/tag.py module which handles JSON serialization",
            "Register pattern is common in Flask for extending functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This appears to be a register method in Flask's JSON tag system, likely used for registering custom JSON serializers/deserializers. Flask applications commonly need to register custom JSON handling for specific types.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/app.py",
        "name": "register_blueprint",
        "lineno": 567,
        "pattern_type": "similar_function_names",
        "details": "Similar to register in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core Flask method for registering blueprints to organize application routes and functionality. It's a fundamental Flask API method that applications use to modularize their code structure.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint registration is a core Flask feature used by applications",
            "Located in sansio/app.py indicating it's part of Flask's main application interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core Flask method for registering blueprints to organize application routes and functionality. It's a fundamental Flask API method that applications use to modularize their code structure.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/blueprints.py",
        "name": "record",
        "lineno": 224,
        "pattern_type": "similar_function_names",
        "details": "Similar to record_once in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 80,
          "category": "public_api",
          "reason": "This method in the blueprints module likely records blueprint operations or state. Blueprint systems often need to record operations for later execution when the blueprint is registered with an application.",
          "recommendation": "keep",
          "evidence": [
            "Located in blueprints.py suggesting it's part of Flask's blueprint system",
            "Record pattern is common in deferred execution systems like blueprints"
          ]
        },
        "status": "false_positive",
        "confidence": 80,
        "reason": "This method in the blueprints module likely records blueprint operations or state. Blueprint systems often need to record operations for later execution when the blueprint is registered with an application.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/blueprints.py",
        "name": "register_blueprint",
        "lineno": 256,
        "pattern_type": "similar_function_names",
        "details": "Similar to register in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "Another blueprint registration method, possibly for handling blueprint registration at the blueprint level. This is consistent with Flask's blueprint architecture where blueprints can be nested or have complex registration logic.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint registration is fundamental to Flask's modular architecture",
            "Multiple register_blueprint methods suggest different registration contexts"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Another blueprint registration method, possibly for handling blueprint registration at the blueprint level. This is consistent with Flask's blueprint architecture where blueprints can be nested or have complex registration logic.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/blueprints.py",
        "name": "register",
        "lineno": 273,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_filter in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 85,
          "category": "public_api",
          "reason": "This register method in the blueprints module likely handles registration of various blueprint components like routes, error handlers, or other blueprint features. It's part of Flask's blueprint registration system.",
          "recommendation": "keep",
          "evidence": [
            "Located in blueprints.py indicating it's part of Flask's blueprint system",
            "Register methods are essential for Flask's extensible architecture"
          ]
        },
        "status": "false_positive",
        "confidence": 85,
        "reason": "This register method in the blueprints module likely handles registration of various blueprint components like routes, error handlers, or other blueprint features. It's part of Flask's blueprint registration system.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/blueprints.py",
        "name": "register",
        "lineno": 273,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_test in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's Blueprint.register() method, which is a core public API method used to register blueprints with Flask applications. It's called externally by application developers, not internally by Flask itself.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint registration is a fundamental Flask feature",
            "Method is part of Flask's public API for application developers"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's Blueprint.register() method, which is a core public API method used to register blueprints with Flask applications. It's called externally by application developers, not internally by Flask itself.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/blueprints.py",
        "name": "register",
        "lineno": 273,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_template_global in src/flask/sansio/blueprints.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's Blueprint.register() method, which is a core public API method used to register blueprints with Flask applications. It's called externally by application developers, not internally by Flask itself.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint registration is a fundamental Flask feature",
            "Method is part of Flask's public API for application developers"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's Blueprint.register() method, which is a core public API method used to register blueprints with Flask applications. It's called externally by application developers, not internally by Flask itself.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/blueprints.py",
        "name": "register",
        "lineno": 273,
        "pattern_type": "similar_function_names",
        "details": "Similar to register_error_handler in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is Flask's Blueprint.register() method, which is a core public API method used to register blueprints with Flask applications. It's called externally by application developers, not internally by Flask itself.",
          "recommendation": "keep",
          "evidence": [
            "Blueprint registration is a fundamental Flask feature",
            "Method is part of Flask's public API for application developers"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is Flask's Blueprint.register() method, which is a core public API method used to register blueprints with Flask applications. It's called externally by application developers, not internally by Flask itself.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/blueprints.py",
        "name": "wrapper",
        "lineno": 240,
        "pattern_type": "similar_function_names",
        "details": "Similar to wrapper_func in src/flask/sansio/scaffold.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This appears to be a decorator wrapper function, likely generated inside a decorator factory. Wrapper functions are called by Python's decorator mechanism when the decorated function is invoked, not directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in blueprints.py suggesting it's part of Flask's decorator system",
            "Wrapper functions are called indirectly through Python's decorator mechanism"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a decorator wrapper function, likely generated inside a decorator factory. Wrapper functions are called by Python's decorator mechanism when the decorated function is invoked, not directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_name in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely implementing a dict-like interface method 'get()' in Flask's scaffold module. These methods are called by Python's built-in functions and framework code, following standard protocols for container objects.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows Python's mapping protocol",
            "Located in scaffold.py which likely provides container-like functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely implementing a dict-like interface method 'get()' in Flask's scaffold module. These methods are called by Python's built-in functions and framework code, following standard protocols for container objects.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_domain in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask scaffold module, likely part of framework's internal mapping interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_path in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask scaffold module, likely part of framework's internal mapping interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_httponly in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask scaffold module, likely part of framework's internal mapping interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_secure in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask scaffold module, likely part of framework's internal mapping interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_samesite in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python mapping protocol",
            "Located in Flask scaffold module, likely part of framework's internal mapping interface"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a mapping protocol method (dict-like interface) that implements the standard Python `get()` method. Such methods are called by Python's runtime or framework code rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_partitioned in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "This appears to be a dict-like interface method (get) that implements standard Python container protocols. Such methods are typically called by Python's internal mechanisms or framework code rather than directly in application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python dict-like interface pattern",
            "Located in Flask's scaffold module which likely implements container-like behavior"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This appears to be a dict-like interface method (get) that implements standard Python container protocols. Such methods are typically called by Python's internal mechanisms or framework code rather than directly in application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_expiration_time in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Same as item #1 - this appears to be a dict-like interface method that implements standard Python container protocols. These methods are called by Python's internal mechanisms rather than directly in code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python dict-like interface pattern",
            "Part of Flask's core scaffolding functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Same as item #1 - this appears to be a dict-like interface method that implements standard Python container protocols. These methods are called by Python's internal mechanisms rather than directly in code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_signing_serializer in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Same as items #1 and #2 - this is a dict-like interface method implementing standard Python container protocols. Called by Python internals rather than direct application code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python dict-like interface pattern",
            "Part of Flask framework's core functionality"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Same as items #1 and #2 - this is a dict-like interface method implementing standard Python container protocols. Called by Python internals rather than direct application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sansio/scaffold.py",
        "name": "get",
        "lineno": 296,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_source in src/flask/templating.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "interface_method",
          "reason": "Same as previous items - this is a dict-like interface method implementing standard Python container protocols. These are called by Python's built-in mechanisms and framework code.",
          "recommendation": "keep",
          "evidence": [
            "Method name 'get' follows standard Python dict-like interface pattern",
            "Essential part of Flask's scaffolding infrastructure"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "Same as previous items - this is a dict-like interface method implementing standard Python container protocols. These are called by Python's built-in mechanisms and framework code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_name in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is a dict-like get method in Flask's sessions module, implementing the standard Python dict interface. Session objects need dict-like behavior for user code to access session data using standard dict methods.",
          "recommendation": "keep",
          "evidence": [
            "Located in sessions.py indicating session dict-like interface implementation",
            "get() is a fundamental dict method that users expect on session objects"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a dict-like get method in Flask's sessions module, implementing the standard Python dict interface. Session objects need dict-like behavior for user code to access session data using standard dict methods.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_domain in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
          "recommendation": "keep",
          "evidence": [
            "Session classes implement dictionary-like interface for user interaction",
            "get() is a standard Python dict method that external code expects to be available"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_path in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
          "recommendation": "keep",
          "evidence": [
            "Session classes implement dictionary-like interface for user interaction",
            "get() is a standard Python dict method that external code expects to be available"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_httponly in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
          "recommendation": "keep",
          "evidence": [
            "Session classes implement dictionary-like interface for user interaction",
            "get() is a standard Python dict method that external code expects to be available"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_secure in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
          "recommendation": "keep",
          "evidence": [
            "Session classes implement dictionary-like interface for user interaction",
            "get() is a standard Python dict method that external code expects to be available"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_samesite in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
          "recommendation": "keep",
          "evidence": [
            "Session classes implement dictionary-like interface for user interaction",
            "get() is a standard Python dict method that external code expects to be available"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "The get method implements the standard dictionary-like interface protocol. Session objects are expected to behave like dictionaries, and the get method is commonly used by Flask applications and middleware to safely retrieve session values.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_cookie_partitioned in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This is likely a dict-like get() method in a session class that implements the mapping protocol. These methods are called by Python's built-in mechanisms and frameworks rather than directly by application code.",
          "recommendation": "keep",
          "evidence": [
            "Located in sessions.py which typically implements dict-like interfaces",
            "get() is a standard mapping protocol method called by Python internals"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is likely a dict-like get() method in a session class that implements the mapping protocol. These methods are called by Python's built-in mechanisms and frameworks rather than directly by application code.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_expiration_time in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "This appears to be a duplicate detection of the same get() method. Session classes implement dict-like interfaces where get() is part of the mapping protocol.",
          "recommendation": "keep",
          "evidence": [
            "Same location as item 1, likely duplicate detection",
            "Part of standard mapping interface implementation"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This appears to be a duplicate detection of the same get() method. Session classes implement dict-like interfaces where get() is part of the mapping protocol.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_signing_serializer in src/flask/sessions.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "Another duplicate detection of the same get() method implementing the mapping protocol in the session class.",
          "recommendation": "keep",
          "evidence": [
            "Same location indicates duplicate detection",
            "Essential for dict-like behavior of session objects"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Another duplicate detection of the same get() method implementing the mapping protocol in the session class.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "get",
        "lineno": 88,
        "pattern_type": "similar_function_names",
        "details": "Similar to get_source in src/flask/templating.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "interface_method",
          "reason": "Fourth duplicate detection of the same get() method. This is a core mapping protocol method that must be preserved for proper session functionality.",
          "recommendation": "keep",
          "evidence": [
            "Identical location to previous items",
            "Required for Python's mapping interface compliance"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "Fourth duplicate detection of the same get() method. This is a core mapping protocol method that must be preserved for proper session functionality.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "open_session",
        "lineno": 263,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "callback",
          "reason": "This is likely a session interface method that Flask calls internally during request processing. Session management methods are typically invoked by the framework rather than application code directly.",
          "recommendation": "keep",
          "evidence": [
            "Part of Flask's session management system",
            "Framework callback methods aren't called directly by application code"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is likely a session interface method that Flask calls internally during request processing. Session management methods are typically invoked by the framework rather than application code directly.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/sessions.py",
        "name": "open_session",
        "lineno": 337,
        "pattern_type": "similar_function_names",
        "details": "Similar to open in src/flask/testing.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 95,
          "category": "public_api",
          "reason": "This is a core Flask framework method for session management that's part of the public API. Flask applications and extensions call this method to open user sessions, even if not called directly within Flask's own codebase.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's sessions module, which is a core framework component",
            "Session management is a fundamental web framework feature that external code relies on"
          ]
        },
        "status": "false_positive",
        "confidence": 95,
        "reason": "This is a core Flask framework method for session management that's part of the public API. Flask applications and extensions call this method to open user sessions, even if not called directly within Flask's own codebase.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/templating.py",
        "name": "render_template",
        "lineno": 135,
        "pattern_type": "similar_function_names",
        "details": "Similar to render_template_string in src/flask/templating.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 98,
          "category": "public_api",
          "reason": "This is one of Flask's most commonly used public API functions for rendering Jinja2 templates. Flask applications extensively use this function, and it's a core feature of the framework that external code depends on.",
          "recommendation": "keep",
          "evidence": [
            "Template rendering is a fundamental web framework feature",
            "This is likely exported in Flask's main __init__.py as a primary API function"
          ]
        },
        "status": "false_positive",
        "confidence": 98,
        "reason": "This is one of Flask's most commonly used public API functions for rendering Jinja2 templates. Flask applications extensively use this function, and it's a core feature of the framework that external code depends on.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/templating.py",
        "name": "stream_template",
        "lineno": 180,
        "pattern_type": "similar_function_names",
        "details": "Similar to stream_template_string in src/flask/templating.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 90,
          "category": "public_api",
          "reason": "This is a Flask public API function for streaming template content, used by applications that need to render large templates incrementally. It's a specialized but legitimate part of Flask's templating API.",
          "recommendation": "keep",
          "evidence": [
            "Streaming templates is a valid use case for large content rendering",
            "Located alongside render_template in templating module, suggesting it's part of the public API"
          ]
        },
        "status": "false_positive",
        "confidence": 90,
        "reason": "This is a Flask public API function for streaming template content, used by applications that need to render large templates incrementally. It's a specialized but legitimate part of Flask's templating API.",
        "recommendation": "keep"
      },
      {
        "module": "src/flask/wrappers.py",
        "name": "blueprint",
        "lineno": 162,
        "pattern_type": "similar_function_names",
        "details": "Similar to blueprints in src/flask/wrappers.py - possible duplicate logic",
        "needs_llm": true,
        "llm_analysis": {
          "status": "false_positive",
          "confidence": 92,
          "category": "public_api",
          "reason": "This appears to be a property or method related to Flask's Blueprint system, which is a core organizational feature. Blueprints are widely used by Flask applications for modular application structure.",
          "recommendation": "keep",
          "evidence": [
            "Located in Flask's wrappers module, likely part of request/response handling",
            "Blueprints are a fundamental Flask feature for application organization"
          ]
        },
        "status": "false_positive",
        "confidence": 92,
        "reason": "This appears to be a property or method related to Flask's Blueprint system, which is a core organizational feature. Blueprints are widely used by Flask applications for modular application structure.",
        "recommendation": "keep"
      }
    ],
    "summary": {
      "total_analyzed": 318,
      "confirmed_dead_code": 3,
      "false_positives": 278,
      "uncertain": 37,
      "avg_confidence": 84.22955974842768
    }
  },
  "logical_groups": {
    "Core Framework": [
      "src/flask/__init__.py",
      "src/flask/app.py",
      "src/flask/sansio/app.py",
      "src/flask/sansio/scaffold.py",
      "src/flask/blueprints.py",
      "src/flask/sansio/blueprints.py",
      "src/flask/ctx.py",
      "src/flask/globals.py",
      "src/flask/typing.py"
    ],
    "Request/Response Handling": [
      "src/flask/wrappers.py",
      "src/flask/sessions.py",
      "src/flask/views.py",
      "src/flask/templating.py"
    ],
    "Application Entry & CLI": [
      "src/flask/__main__.py",
      "src/flask/cli.py"
    ],
    "Configuration & Settings": [
      "src/flask/config.py"
    ],
    "JSON Handling": [
      "src/flask/json/__init__.py",
      "src/flask/json/provider.py",
      "src/flask/json/tag.py"
    ],
    "Utilities & Helpers": [
      "src/flask/helpers.py",
      "src/flask/signals.py",
      "src/flask/logging.py",
      "src/flask/debughelpers.py"
    ],
    "Testing Infrastructure": [
      "src/flask/testing.py"
    ],
    "Documentation": [
      "docs/conf.py"
    ],
    "Example: Tutorial Blog App": [
      "examples/tutorial/flaskr/__init__.py",
      "examples/tutorial/flaskr/auth.py",
      "examples/tutorial/flaskr/blog.py",
      "examples/tutorial/flaskr/db.py"
    ],
    "Example: Celery Background Tasks": [
      "examples/celery/make_celery.py",
      "examples/celery/src/task_app/__init__.py",
      "examples/celery/src/task_app/tasks.py",
      "examples/celery/src/task_app/views.py"
    ],
    "Example: JavaScript Integration": [
      "examples/javascript/js_example/__init__.py",
      "examples/javascript/js_example/views.py"
    ]
  },
  "audio_narration": {
    "audio_file": "/Users/navyan/Desktop/LLM-Project/repospeak/audio/flask_summary.mp3",
    "script_file": "/Users/navyan/Desktop/LLM-Project/repospeak/audio/flask_audio_script.txt",
    "audio_text": "Imagine you're building a house, but instead of starting from scratch with raw lumber and nails, someone hands you a toolkit with all the essentials already organized and ready to use. That's exactly what Flask does for web developers.\n\nFlask is a lightweight Python framework... think of it as a smart assistant that handles all the behind-the-scenes work of running a website. You know when you click a button on a webpage and something happens? Flask is managing that conversation between your browser and the server.\n\nHere's what makes it special. First, it gives you the fundamental building blocks... tools to handle web requests, render those HTML pages you see in your browser, and manage user sessions so the website remembers who you are. It's like having a receptionist, a filing system, and a memory bank all rolled into one.\n\nNext, there's the flexibility factor. Flask doesn't force you into a rigid structure. If traditional frameworks are like building with LEGO sets that have specific instructions, Flask is more like having a bucket of blocks where you decide what to build and how to build it. This makes it perfect for beginners taking their first steps, while still being powerful enough for experienced developers working on complex projects.\n\nFinally, it comes with practical development tools built right in... a test server so you can preview your work locally, and debugging helpers that act like a magnifying glass, helping you spot and fix problems quickly.\n\nWhether you're creating a simple personal blog or a full-scale web service used by thousands, Flask adapts to your needs. It's this combination of simplicity and power that's made it one of the most popular choices in the Python web development world.",
    "word_count": 286,
    "estimated_duration_minutes": 1.9
  }
}