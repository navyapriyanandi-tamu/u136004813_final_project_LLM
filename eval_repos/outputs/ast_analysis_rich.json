{
  "benchmarks/__init__.py": {
    "filepath": "../rich/benchmarks/__init__.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 1
  },
  "benchmarks/benchmarks.py": {
    "filepath": "../rich/benchmarks/benchmarks.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "setup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 15,
        "decorators": [],
        "is_async": false,
        "calls": [
          "snippets.LOREM_IPSUM",
          "StringIO",
          "Console",
          "snippets.MARKUP",
          "Text.from_markup",
          "len"
        ],
        "docstring": null,
        "code": "def setup(self):\n        self.console = Console(\n            file=StringIO(), color_system=\"truecolor\", legacy_windows=False\n        )\n        self.len_lorem_ipsum = len(snippets.LOREM_IPSUM)\n        self.text = Text.from_markup(snippets.MARKUP)",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "time_wrapping",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 22,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.console",
          "self.text.wrap"
        ],
        "docstring": null,
        "code": "def time_wrapping(self):\n        self.text.wrap(self.console, 12, overflow=\"fold\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_indent_guides",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 25,
        "decorators": [],
        "is_async": false,
        "calls": [
          "snippets.PYTHON_SNIPPET",
          "Text",
          "unknown.with_indent_guides"
        ],
        "docstring": null,
        "code": "def time_indent_guides(self):\n        Text(snippets.PYTHON_SNIPPET).with_indent_guides()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_fit",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 28,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.fit",
          "snippets.LOREM_IPSUM",
          "Text"
        ],
        "docstring": null,
        "code": "def time_fit(self):\n        Text(snippets.LOREM_IPSUM).fit(12)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_split",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 31,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.text.split"
        ],
        "docstring": null,
        "code": "def time_split(self):\n        self.text.split()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_divide",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 34,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.divide",
          "range",
          "snippets.LOREM_IPSUM",
          "Text"
        ],
        "docstring": null,
        "code": "def time_divide(self):\n        Text(snippets.LOREM_IPSUM).divide(range(20, 100, 4))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_align_center",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 37,
        "decorators": [],
        "is_async": false,
        "calls": [
          "snippets.LOREM_IPSUM",
          "unknown.align",
          "Text"
        ],
        "docstring": null,
        "code": "def time_align_center(self):\n        Text(snippets.LOREM_IPSUM).align(\"center\", width=self.len_lorem_ipsum * 3)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_render",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.text.render",
          "list",
          "self.console"
        ],
        "docstring": null,
        "code": "def time_render(self):\n        list(self.text.render(self.console))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_wrapping_unicode_heavy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 43,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Text",
          "unknown.wrap",
          "snippets.UNICODE_HEAVY_TEXT",
          "self.console"
        ],
        "docstring": null,
        "code": "def time_wrapping_unicode_heavy(self):\n        Text(snippets.UNICODE_HEAVY_TEXT).wrap(self.console, 12, overflow=\"fold\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_fit_unicode_heavy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 46,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.fit",
          "snippets.UNICODE_HEAVY_TEXT",
          "Text"
        ],
        "docstring": null,
        "code": "def time_fit_unicode_heavy(self):\n        Text(snippets.UNICODE_HEAVY_TEXT).fit(12)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_split_unicode_heavy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 49,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.split",
          "snippets.UNICODE_HEAVY_TEXT",
          "Text"
        ],
        "docstring": null,
        "code": "def time_split_unicode_heavy(self):\n        Text(snippets.UNICODE_HEAVY_TEXT).split()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_divide_unicode_heavy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 52,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.text.divide",
          "range"
        ],
        "docstring": null,
        "code": "def time_divide_unicode_heavy(self):\n        self.text.divide(range(20, 100, 4))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_align_center_unicode_heavy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 55,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.align",
          "Text",
          "snippets.UNICODE_HEAVY_TEXT"
        ],
        "docstring": null,
        "code": "def time_align_center_unicode_heavy(self):\n        Text(snippets.UNICODE_HEAVY_TEXT).align(\n            \"center\", width=self.len_lorem_ipsum * 3\n        )",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "time_render_unicode_heavy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 60,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.render",
          "self.console",
          "list",
          "snippets.UNICODE_HEAVY_TEXT",
          "Text"
        ],
        "docstring": null,
        "code": "def time_render_unicode_heavy(self):\n        list(Text(snippets.UNICODE_HEAVY_TEXT).render(self.console))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "setup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 65,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Console",
          "StringIO"
        ],
        "docstring": null,
        "code": "def setup(self):\n        self.console = Console(\n            file=StringIO(), color_system=\"truecolor\", legacy_windows=False\n        )",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "time_wrapping_unicode_heavy_warm_cache",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 70,
        "decorators": [],
        "is_async": false,
        "calls": [
          "range",
          "unknown.wrap",
          "self.console",
          "snippets.UNICODE_HEAVY_TEXT",
          "Text"
        ],
        "docstring": null,
        "code": "def time_wrapping_unicode_heavy_warm_cache(self):\n        for _ in range(20):\n            Text(snippets.UNICODE_HEAVY_TEXT).wrap(self.console, 12, overflow=\"fold\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "setup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [
          "snippets.PYTHON_SNIPPET",
          "Console",
          "StringIO",
          "Syntax"
        ],
        "docstring": null,
        "code": "def setup(self):\n        self.console = Console(\n            file=StringIO(), color_system=\"truecolor\", legacy_windows=False\n        )\n        self.syntax = Syntax(\n            code=snippets.PYTHON_SNIPPET, lexer=\"python\", word_wrap=True\n        )",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "time_text_thin_terminal_heavy_wrapping",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 84,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._print_with_width"
        ],
        "docstring": null,
        "code": "def time_text_thin_terminal_heavy_wrapping(self):\n        self._print_with_width(20)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_text_thin_terminal_medium_wrapping",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 87,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._print_with_width"
        ],
        "docstring": null,
        "code": "def time_text_thin_terminal_medium_wrapping(self):\n        self._print_with_width(60)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_text_wide_terminal_no_wrapping",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 90,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._print_with_width"
        ],
        "docstring": null,
        "code": "def time_text_wide_terminal_no_wrapping(self):\n        self._print_with_width(100)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_print_with_width",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width"
          }
        ],
        "return_type": null,
        "lineno": 93,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.syntax",
          "width",
          "self.console.print"
        ],
        "docstring": null,
        "code": "def _print_with_width(self, width):\n        self.console.print(self.syntax, width)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_table_no_wrapping",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 98,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._print_table"
        ],
        "docstring": null,
        "code": "def time_table_no_wrapping(self):\n        self._print_table(width=100)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_table_heavy_wrapping",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 101,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._print_table"
        ],
        "docstring": null,
        "code": "def time_table_heavy_wrapping(self):\n        self._print_table(width=30)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_print_table",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width"
          }
        ],
        "return_type": null,
        "lineno": 104,
        "decorators": [],
        "is_async": false,
        "calls": [
          "console.print",
          "StringIO",
          "table",
          "Console",
          "width",
          "table.add_column",
          "table.add_row",
          "Table"
        ],
        "docstring": null,
        "code": "def _print_table(self, width):\n        table = Table(title=\"Star Wars Movies\")\n        console = Console(\n            file=StringIO(), color_system=\"truecolor\", legacy_windows=False, width=width\n        )\n        table.add_column(\"Released\", justify=\"right\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Title\", style=\"magenta\")\n        table.add_column(\"Box Office\", justify=\"right\", style=\"green\")\n        table.add_row(\n            \"Dec 20, 2019\", \"[b]Star Wars[/]: The Rise of Skywalker\", \"$952,110,690\"\n        )\n        table.add_row(\n            \"May 25, 2018\", \"Solo: A [red][b]Star Wars[/] Story[/]\", \"$393,151,347\"\n        )\n        table.add_row(\n            \"Dec 15, 2017\",\n            \"[b red]Star Wars[/] Ep. V111: The Last Jedi\",\n            \"$1,332,539,889\",\n        )\n        table.add_row(\n            \"Dec 16, 2016\", \"Rogue One: A [blue]Star Wars[/] Story\", \"$1,332,439,889\"\n        )\n        console.print(table)",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "setup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 130,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Console",
          "StringIO"
        ],
        "docstring": null,
        "code": "def setup(self):\n        self.console = Console(\n            file=StringIO(), color_system=\"truecolor\", legacy_windows=False, width=100\n        )",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "time_pretty",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 135,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Pretty",
          "pretty",
          "snippets.PYTHON_DICT",
          "self.console.print"
        ],
        "docstring": null,
        "code": "def time_pretty(self):\n        pretty = Pretty(snippets.PYTHON_DICT)\n        self.console.print(pretty)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "time_pretty_indent_guides",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 139,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Pretty",
          "pretty",
          "snippets.PYTHON_DICT",
          "self.console.print"
        ],
        "docstring": null,
        "code": "def time_pretty_indent_guides(self):\n        pretty = Pretty(snippets.PYTHON_DICT, indent_guides=True)\n        self.console.print(pretty)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "time_pretty_justify_center",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 143,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Pretty",
          "pretty",
          "snippets.PYTHON_DICT",
          "self.console.print"
        ],
        "docstring": null,
        "code": "def time_pretty_justify_center(self):\n        pretty = Pretty(snippets.PYTHON_DICT, justify=\"center\")\n        self.console.print(pretty)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "setup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 149,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Console",
          "StringIO",
          "Style.parse"
        ],
        "docstring": null,
        "code": "def setup(self):\n        self.console = Console(\n            file=StringIO(), color_system=\"truecolor\", legacy_windows=False, width=100\n        )\n        self.style1 = Style.parse(\"blue on red\")\n        self.style2 = Style.parse(\"green italic bold\")",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "time_parse_ansi",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 156,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Style.parse"
        ],
        "docstring": null,
        "code": "def time_parse_ansi(self):\n        Style.parse(\"red on blue\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_parse_hex",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 159,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Style.parse"
        ],
        "docstring": null,
        "code": "def time_parse_hex(self):\n        Style.parse(\"#f0f0f0 on #e2e28a\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_parse_mixed_complex_style",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 162,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Style.parse"
        ],
        "docstring": null,
        "code": "def time_parse_mixed_complex_style(self):\n        Style.parse(\"dim bold reverse #00ee00 on rgb(123,12,50)\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_style_add",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 165,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def time_style_add(self):\n        self.style1 + self.style2",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "setup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 170,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Console",
          "Color.parse",
          "StringIO"
        ],
        "docstring": null,
        "code": "def setup(self):\n        self.console = Console(\n            file=StringIO(), color_system=\"truecolor\", legacy_windows=False, width=100\n        )\n        self.color = Color.parse(\"#0d1da0\")",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "time_downgrade_to_eight_bit",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 176,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.color.downgrade",
          "ColorSystem.EIGHT_BIT"
        ],
        "docstring": null,
        "code": "def time_downgrade_to_eight_bit(self):\n        self.color.downgrade(ColorSystem.EIGHT_BIT)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_downgrade_to_standard",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 179,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.color.downgrade",
          "ColorSystem.STANDARD"
        ],
        "docstring": null,
        "code": "def time_downgrade_to_standard(self):\n        self.color.downgrade(ColorSystem.STANDARD)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_downgrade_to_windows",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 182,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.color.downgrade",
          "ColorSystem.WINDOWS"
        ],
        "docstring": null,
        "code": "def time_downgrade_to_windows(self):\n        self.color.downgrade(ColorSystem.WINDOWS)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "setup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 187,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.color.downgrade",
          "StringIO",
          "ColorSystem.STANDARD",
          "Console",
          "ColorSystem.WINDOWS",
          "Color.parse",
          "ColorSystem.EIGHT_BIT"
        ],
        "docstring": null,
        "code": "def setup(self):\n        self.console = Console(\n            file=StringIO(), color_system=\"truecolor\", legacy_windows=False, width=100\n        )\n        self.color = Color.parse(\"#0d1da0\")\n        # Warm cache\n        self.color.downgrade(ColorSystem.EIGHT_BIT)\n        self.color.downgrade(ColorSystem.STANDARD)\n        self.color.downgrade(ColorSystem.WINDOWS)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "time_downgrade_to_eight_bit",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 197,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.color.downgrade",
          "ColorSystem.EIGHT_BIT"
        ],
        "docstring": null,
        "code": "def time_downgrade_to_eight_bit(self):\n        self.color.downgrade(ColorSystem.EIGHT_BIT)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_downgrade_to_standard",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 200,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.color.downgrade",
          "ColorSystem.STANDARD"
        ],
        "docstring": null,
        "code": "def time_downgrade_to_standard(self):\n        self.color.downgrade(ColorSystem.STANDARD)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "time_downgrade_to_windows",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 203,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.color.downgrade",
          "ColorSystem.WINDOWS"
        ],
        "docstring": null,
        "code": "def time_downgrade_to_windows(self):\n        self.color.downgrade(ColorSystem.WINDOWS)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "setup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 208,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment"
        ],
        "docstring": null,
        "code": "def setup(self):\n        self.line = [\n            Segment(\"foo\"),\n            Segment(\"bar\"),\n            Segment(\"egg\"),\n            Segment(\"Where there is a Will\"),\n            Segment(\"There is a way\"),\n        ] * 2",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "test_divide_complex",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 217,
        "decorators": [],
        "is_async": false,
        "calls": [
          "list",
          "Segment.divide",
          "self.line"
        ],
        "docstring": null,
        "code": "def test_divide_complex(self):\n        list(Segment.divide(self.line, [5, 10, 20, 50, 108, 110, 118]))",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "TextSuite",
        "methods": [
          "setup",
          "time_wrapping",
          "time_indent_guides",
          "time_fit",
          "time_split",
          "time_divide",
          "time_align_center",
          "time_render",
          "time_wrapping_unicode_heavy",
          "time_fit_unicode_heavy",
          "time_split_unicode_heavy",
          "time_divide_unicode_heavy",
          "time_align_center_unicode_heavy",
          "time_render_unicode_heavy"
        ],
        "base_classes": [],
        "lineno": 14,
        "docstring": null
      },
      {
        "name": "TextHotCacheSuite",
        "methods": [
          "setup",
          "time_wrapping_unicode_heavy_warm_cache"
        ],
        "base_classes": [],
        "lineno": 64,
        "docstring": null
      },
      {
        "name": "SyntaxWrappingSuite",
        "methods": [
          "setup",
          "time_text_thin_terminal_heavy_wrapping",
          "time_text_thin_terminal_medium_wrapping",
          "time_text_wide_terminal_no_wrapping",
          "_print_with_width"
        ],
        "base_classes": [],
        "lineno": 75,
        "docstring": null
      },
      {
        "name": "TableSuite",
        "methods": [
          "time_table_no_wrapping",
          "time_table_heavy_wrapping",
          "_print_table"
        ],
        "base_classes": [],
        "lineno": 97,
        "docstring": null
      },
      {
        "name": "PrettySuite",
        "methods": [
          "setup",
          "time_pretty",
          "time_pretty_indent_guides",
          "time_pretty_justify_center"
        ],
        "base_classes": [],
        "lineno": 129,
        "docstring": null
      },
      {
        "name": "StyleSuite",
        "methods": [
          "setup",
          "time_parse_ansi",
          "time_parse_hex",
          "time_parse_mixed_complex_style",
          "time_style_add"
        ],
        "base_classes": [],
        "lineno": 148,
        "docstring": null
      },
      {
        "name": "ColorSuite",
        "methods": [
          "setup",
          "time_downgrade_to_eight_bit",
          "time_downgrade_to_standard",
          "time_downgrade_to_windows"
        ],
        "base_classes": [],
        "lineno": 169,
        "docstring": null
      },
      {
        "name": "ColorSuiteCached",
        "methods": [
          "setup",
          "time_downgrade_to_eight_bit",
          "time_downgrade_to_standard",
          "time_downgrade_to_windows"
        ],
        "base_classes": [],
        "lineno": 186,
        "docstring": null
      },
      {
        "name": "SegmentSuite",
        "methods": [
          "setup",
          "test_divide_complex"
        ],
        "base_classes": [],
        "lineno": 207,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "io",
        "name": "StringIO",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "benchmarks",
        "name": "snippets",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich.color",
        "name": "Color",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.color",
        "name": "ColorSystem",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich.segment",
        "name": "Segment",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.style",
        "name": "Style",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "io"
      ],
      "third_party": {
        "other": [
          "benchmarks",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 219
  },
  "benchmarks/snippets.py": {
    "filepath": "../rich/benchmarks/snippets.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [],
    "variables": [
      {
        "name": "PYTHON_SNIPPET",
        "assigned_to": "str",
        "lineno": 1
      },
      {
        "name": "PYTHON_DICT",
        "assigned_to": null,
        "lineno": 70
      },
      {
        "name": "LOREM_IPSUM",
        "assigned_to": "str",
        "lineno": 93
      },
      {
        "name": "UNICODE_HEAVY_TEXT",
        "assigned_to": "str",
        "lineno": 105
      },
      {
        "name": "MARKUP",
        "assigned_to": "unknown.join",
        "lineno": 176
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "unknown.join",
        "range"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 180
  },
  "docs/source/conf.py": {
    "filepath": "../rich/docs/source/conf.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "sphinx_rtd_theme",
        "alias": null,
        "lineno": 20,
        "type": "import"
      },
      {
        "module": "importlib.metadata",
        "name": "Distribution",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "html_theme",
        "assigned_to": "str",
        "lineno": 23
      },
      {
        "name": "html_theme_path",
        "assigned_to": null,
        "lineno": 25
      },
      {
        "name": "project",
        "assigned_to": "str",
        "lineno": 27
      },
      {
        "name": "copyright",
        "assigned_to": "str",
        "lineno": 28
      },
      {
        "name": "author",
        "assigned_to": "str",
        "lineno": 29
      },
      {
        "name": "release",
        "assigned_to": null,
        "lineno": 32
      },
      {
        "name": "extensions",
        "assigned_to": null,
        "lineno": 40
      },
      {
        "name": "templates_path",
        "assigned_to": null,
        "lineno": 51
      },
      {
        "name": "exclude_patterns",
        "assigned_to": null,
        "lineno": 56
      },
      {
        "name": "html_static_path",
        "assigned_to": null,
        "lineno": 69
      },
      {
        "name": "intersphinx_mapping",
        "assigned_to": null,
        "lineno": 71
      },
      {
        "name": "autodoc_typehints",
        "assigned_to": "str",
        "lineno": 73
      },
      {
        "name": "html_css_files",
        "assigned_to": null,
        "lineno": 75
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "unknown.version",
        "Distribution.from_name",
        "sphinx_rtd_theme.get_html_theme_path"
      ],
      "class_instantiations": [
        "Distribution"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "sphinx_rtd_theme",
          "importlib"
        ]
      },
      "tech_stack": []
    },
    "line_count": 78
  },
  "examples/attrs.py": {
    "filepath": "../rich/examples/attrs.py",
    "module_docstring": null,
    "functions": [],
    "classes": [
      {
        "name": "Point3D",
        "methods": [],
        "base_classes": [],
        "lineno": 12,
        "docstring": null
      },
      {
        "name": "Triangle",
        "methods": [],
        "base_classes": [],
        "lineno": 19,
        "docstring": null
      },
      {
        "name": "Model",
        "methods": [],
        "base_classes": [],
        "lineno": 26,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "attr",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "rich.pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Column",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Column",
      "Pretty",
      "Model",
      "Console",
      "Text.from_markup",
      "Triangle",
      "table.add_row",
      "repr",
      "Point3D",
      "Table"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "Column",
        "SystemExit",
        "Model",
        "table",
        "Console",
        "Pretty",
        "Text.from_markup",
        "Triangle",
        "model",
        "print",
        "table.add_row",
        "repr",
        "Point3D",
        "Table"
      ],
      "class_instantiations": [
        "Column",
        "SystemExit",
        "Model",
        "Pretty",
        "Console",
        "Text",
        "Triangle",
        "Point3D",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "attr",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 54
  },
  "examples/bars.py": {
    "filepath": "../rich/examples/bars.py",
    "module_docstring": "Use Bar to renderer a sort-of circle.",
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "math",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "rich.align",
        "name": "Align",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.bar",
        "name": "Bar",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.color",
        "name": "Color",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "SIZE",
        "assigned_to": "int",
        "lineno": 14
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "SIZE",
        "range",
        "color",
        "math.sqrt",
        "Bar",
        "Color.from_rgb",
        "print",
        "Align.center",
        "bar"
      ],
      "class_instantiations": [
        "Color",
        "Bar",
        "Align"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "math"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 22
  },
  "examples/columns.py": {
    "filepath": "../rich/examples/columns.py",
    "module_docstring": "This example shows how to display content in columns.\n\nThe data is pulled from https://randomuser.me",
    "functions": [
      {
        "name": "get_content",
        "args": [
          {
            "name": "user"
          }
        ],
        "return_type": null,
        "lineno": 15,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Extract text from user dict.",
        "code": "def get_content(user):\n    \"\"\"Extract text from user dict.\"\"\"\n    country = user[\"location\"][\"country\"]\n    name = f\"{user['name']['first']} {user['name']['last']}\"\n    return f\"[b]{name}[/b]\\n[yellow]{country}\"",
        "line_count": 5,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "json",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "urllib.request",
        "name": "urlopen",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich.columns",
        "name": "Columns",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 22
      },
      {
        "name": "users",
        "assigned_to": null,
        "lineno": 25
      },
      {
        "name": "user_renderables",
        "assigned_to": null,
        "lineno": 27
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "users",
        "Columns",
        "unknown.read",
        "Console",
        "Panel",
        "json.loads",
        "user",
        "user_renderables",
        "urlopen",
        "get_content"
      ],
      "class_instantiations": [
        "Console",
        "Panel",
        "Columns"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "json"
      ],
      "third_party": {
        "other": [
          "urllib",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 29
  },
  "examples/cp_progress.py": {
    "filepath": "../rich/examples/cp_progress.py",
    "module_docstring": "A very minimal `cp` clone that displays a progress bar.",
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "os",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "shutil",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "rich.progress",
        "name": "Progress",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "Progress",
      "os.path.basename",
      "progress.open",
      "open",
      "print",
      "len",
      "shutil.copyfileobj"
    ],
    "module_level_calls": {
      "function_calls": [
        "dst",
        "Progress",
        "desc",
        "sys.argv",
        "os.path.basename",
        "progress.open",
        "open",
        "print",
        "src",
        "len",
        "shutil.copyfileobj"
      ],
      "class_instantiations": [
        "Progress"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "shutil",
        "os"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 20
  },
  "examples/downloader.py": {
    "filepath": "../rich/examples/downloader.py",
    "module_docstring": "A rudimentary URL downloader (like wget or curl) to demonstrate Rich progress bars.",
    "functions": [
      {
        "name": "handle_sigint",
        "args": [
          {
            "name": "signum"
          },
          {
            "name": "frame"
          }
        ],
        "return_type": null,
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "done_event.set"
        ],
        "docstring": null,
        "code": "def handle_sigint(signum, frame):\n    done_event.set()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "copy_url",
        "args": [
          {
            "name": "task_id",
            "type": "TaskID"
          },
          {
            "name": "url",
            "type": "str"
          },
          {
            "name": "path",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 47,
        "decorators": [],
        "is_async": false,
        "calls": [
          "response.info",
          "response.read",
          "done_event.is_set",
          "task_id",
          "progress.start_task",
          "url",
          "path",
          "iter",
          "urlopen",
          "dest_file.write",
          "data",
          "open",
          "progress.console.log",
          "progress.update",
          "int",
          "len",
          "partial"
        ],
        "docstring": "Copy data from a url to a local file.",
        "code": "def copy_url(task_id: TaskID, url: str, path: str) -> None:\n    \"\"\"Copy data from a url to a local file.\"\"\"\n    progress.console.log(f\"Requesting {url}\")\n    response = urlopen(url)\n    # This will break if the response doesn't contain content length\n    progress.update(task_id, total=int(response.info()[\"Content-length\"]))\n    with open(path, \"wb\") as dest_file:\n        progress.start_task(task_id)\n        for data in iter(partial(response.read, 32768), b\"\"):\n            dest_file.write(data)\n            progress.update(task_id, advance=len(data))\n            if done_event.is_set():\n                return\n    progress.console.log(f\"Downloaded {path}\")",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "download",
        "args": [
          {
            "name": "urls",
            "type": "Iterable[str]"
          },
          {
            "name": "dest_dir",
            "type": "str"
          }
        ],
        "return_type": null,
        "lineno": 63,
        "decorators": [],
        "is_async": false,
        "calls": [
          "dest_path",
          "url.split",
          "os.path.join",
          "task_id",
          "copy_url",
          "url",
          "pool.submit",
          "progress.add_task",
          "filename",
          "dest_dir",
          "ThreadPoolExecutor"
        ],
        "docstring": "Download multiple files to the given directory.",
        "code": "def download(urls: Iterable[str], dest_dir: str):\n    \"\"\"Download multiple files to the given directory.\"\"\"\n\n    with progress:\n        with ThreadPoolExecutor(max_workers=4) as pool:\n            for url in urls:\n                filename = url.split(\"/\")[-1]\n                dest_path = os.path.join(dest_dir, filename)\n                task_id = progress.add_task(\"download\", filename=filename, start=False)\n                pool.submit(copy_url, task_id, url, dest_path)",
        "line_count": 10,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "os.path",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "concurrent.futures",
        "name": "ThreadPoolExecutor",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "signal",
        "alias": null,
        "lineno": 8,
        "type": "import"
      },
      {
        "module": "functools",
        "name": "partial",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "threading",
        "name": "Event",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "urllib.request",
        "name": "urlopen",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "BarColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "DownloadColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "Progress",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "TaskID",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "TextColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "TimeRemainingColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "TransferSpeedColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "progress",
        "assigned_to": "Progress",
        "lineno": 24
      },
      {
        "name": "done_event",
        "assigned_to": "Event",
        "lineno": 37
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "print",
      "download"
    ],
    "module_level_calls": {
      "function_calls": [
        "BarColumn",
        "signal.SIGINT",
        "Event",
        "DownloadColumn",
        "Progress",
        "TextColumn",
        "TimeRemainingColumn",
        "handle_sigint",
        "TransferSpeedColumn",
        "print",
        "signal.signal",
        "download"
      ],
      "class_instantiations": [
        "BarColumn",
        "Event",
        "DownloadColumn",
        "Progress",
        "TextColumn",
        "TimeRemainingColumn",
        "TransferSpeedColumn"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "threading",
        "typing",
        "functools",
        "os",
        "sys"
      ],
      "third_party": {
        "other": [
          "concurrent",
          "signal",
          "urllib",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 82
  },
  "examples/dynamic_progress.py": {
    "filepath": "../rich/examples/dynamic_progress.py",
    "module_docstring": "Demonstrates how to create a dynamic group of progress bars,\nshowing multi-level progress for multiple tasks (installing apps in the example),\neach of which consisting of multiple steps.",
    "functions": [
      {
        "name": "run_steps",
        "args": [
          {
            "name": "name"
          },
          {
            "name": "step_times"
          },
          {
            "name": "app_steps_task_id"
          }
        ],
        "return_type": null,
        "lineno": 23,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "range",
          "step_progress.update",
          "step_progress.add_task",
          "name",
          "step_time",
          "step_progress.stop_task",
          "step_task_id",
          "time.sleep",
          "action",
          "step_times",
          "app_steps_task_id",
          "app_steps_progress.update"
        ],
        "docstring": "Run steps for a single app, and update corresponding progress bars.",
        "code": "def run_steps(name, step_times, app_steps_task_id):\n    \"\"\"Run steps for a single app, and update corresponding progress bars.\"\"\"\n\n    for idx, step_time in enumerate(step_times):\n        # add progress bar for this step (time elapsed + spinner)\n        action = step_actions[idx]\n        step_task_id = step_progress.add_task(\"\", action=action, name=name)\n\n        # run steps, update progress\n        for _ in range(step_time):\n            time.sleep(0.5)\n            step_progress.update(step_task_id, advance=1)\n\n        # stop and hide progress bar for this step when done\n        step_progress.stop_task(step_task_id)\n        step_progress.update(step_task_id, visible=False)\n\n        # also update progress bar for current app when step is done\n        app_steps_progress.update(app_steps_task_id, advance=1)",
        "line_count": 19,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "alias": null,
        "lineno": 9,
        "type": "import"
      },
      {
        "module": "rich.console",
        "name": "Group",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "rich.live",
        "name": "Live",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "BarColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "Progress",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "SpinnerColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "TextColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "TimeElapsedColumn",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "current_app_progress",
        "assigned_to": "Progress",
        "lineno": 46
      },
      {
        "name": "step_progress",
        "assigned_to": "Progress",
        "lineno": 52
      },
      {
        "name": "app_steps_progress",
        "assigned_to": "Progress",
        "lineno": 59
      },
      {
        "name": "overall_progress",
        "assigned_to": "Progress",
        "lineno": 67
      },
      {
        "name": "progress_group",
        "assigned_to": "Group",
        "lineno": 72
      },
      {
        "name": "step_actions",
        "assigned_to": null,
        "lineno": 78
      },
      {
        "name": "apps",
        "assigned_to": null,
        "lineno": 79
      },
      {
        "name": "overall_task_id",
        "assigned_to": "overall_progress.add_task",
        "lineno": 86
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "enumerate",
        "Panel",
        "top_descr",
        "current_app_progress",
        "apps",
        "current_task_id",
        "step_times",
        "SpinnerColumn",
        "step_progress",
        "Progress",
        "Live",
        "current_app_progress.stop_task",
        "run_steps",
        "current_app_progress.update",
        "BarColumn",
        "TimeElapsedColumn",
        "app_steps_progress",
        "overall_progress.update",
        "app_steps_progress.add_task",
        "name",
        "Group",
        "overall_task_id",
        "app_steps_task_id",
        "len",
        "overall_progress",
        "TextColumn",
        "progress_group",
        "overall_progress.add_task",
        "current_app_progress.add_task",
        "app_steps_progress.update"
      ],
      "class_instantiations": [
        "BarColumn",
        "TimeElapsedColumn",
        "Progress",
        "Live",
        "Panel",
        "TextColumn",
        "Group",
        "SpinnerColumn"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 118
  },
  "examples/exception.py": {
    "filepath": "../rich/examples/exception.py",
    "module_docstring": "Basic example to show how to print an traceback of an exception",
    "functions": [
      {
        "name": "divide_by",
        "args": [
          {
            "name": "number",
            "type": "float"
          },
          {
            "name": "divisor",
            "type": "float"
          }
        ],
        "return_type": "float",
        "lineno": 11,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Divide any number by zero.",
        "code": "def divide_by(number: float, divisor: float) -> float:\n    \"\"\"Divide any number by zero.\"\"\"\n    # Will throw a ZeroDivisionError if divisor is 0\n    result = number / divisor\n    return result",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "divide_all",
        "args": [
          {
            "name": "divides",
            "type": "List[Tuple[float, float]]"
          }
        ],
        "return_type": "None",
        "lineno": 18,
        "decorators": [],
        "is_async": false,
        "calls": [
          "console.print",
          "number",
          "console.print_exception",
          "divisor",
          "divide_by"
        ],
        "docstring": "Do something impossible every day.",
        "code": "def divide_all(divides: List[Tuple[float, float]]) -> None:\n    \"\"\"Do something impossible every day.\"\"\"\n\n    for number, divisor in divides:\n        console.print(f\"dividing {number} by {divisor}\")\n        try:\n            result = divide_by(number, divisor)\n        except Exception:\n            console.print_exception(extra_lines=8, show_locals=True)\n        else:\n            console.print(f\" = {result}\")",
        "line_count": 11,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 8
      },
      {
        "name": "DIVIDES",
        "assigned_to": null,
        "lineno": 31
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "DIVIDES",
        "Console",
        "divide_all"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 42
  },
  "examples/export.py": {
    "filepath": "../rich/examples/export.py",
    "module_docstring": "Demonstrates export console output",
    "functions": [
      {
        "name": "print_table",
        "args": [],
        "return_type": null,
        "lineno": 11,
        "decorators": [],
        "is_async": false,
        "calls": [
          "console.print",
          "table",
          "table.add_column",
          "table.add_row",
          "Table"
        ],
        "docstring": null,
        "code": "def print_table():\n    table = Table(title=\"Star Wars Movies\")\n\n    table.add_column(\"Released\", style=\"cyan\", no_wrap=True)\n    table.add_column(\"Title\", style=\"magenta\")\n    table.add_column(\"Box Office\", justify=\"right\", style=\"green\")\n\n    table.add_row(\"Dec 20, 2019\", \"Star Wars: The Rise of Skywalker\", \"$952,110,690\")\n    table.add_row(\"May 25, 2018\", \"Solo: A Star Wars Story\", \"$393,151,347\")\n    table.add_row(\"Dec 15, 2017\", \"Star Wars Ep. V111: The Last Jedi\", \"$1,332,539,889\")\n    table.add_row(\"Dec 16, 2016\", \"Rogue One: A Star Wars Story\", \"$1,332,439,889\")\n\n    console.print(table)",
        "line_count": 13,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 8
      },
      {
        "name": "file1",
        "assigned_to": "str",
        "lineno": 30
      },
      {
        "name": "text",
        "assigned_to": "console.export_text",
        "lineno": 31
      },
      {
        "name": "file2",
        "assigned_to": "str",
        "lineno": 42
      },
      {
        "name": "html",
        "assigned_to": "console.export_html",
        "lineno": 43
      },
      {
        "name": "file3",
        "assigned_to": "str",
        "lineno": 49
      },
      {
        "name": "file4",
        "assigned_to": "str",
        "lineno": 54
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "file3",
        "console.export_html",
        "file1",
        "file2",
        "print_table",
        "Console",
        "file4",
        "console.save_html",
        "text",
        "console.save_text",
        "file.write",
        "open",
        "print",
        "console.export_text",
        "html"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 57
  },
  "examples/file_progress.py": {
    "filepath": "../rich/examples/file_progress.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "urllib.request",
        "name": "urlopen",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "wrap_file",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "response",
        "assigned_to": "urlopen",
        "lineno": 7
      },
      {
        "name": "size",
        "assigned_to": "int",
        "lineno": 9
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "line.decode",
        "wrap_file",
        "response",
        "urlopen",
        "sleep",
        "size",
        "print",
        "int"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "urllib",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 17
  },
  "examples/fullscreen.py": {
    "filepath": "../rich/examples/fullscreen.py",
    "module_docstring": "Demonstrates a Rich \"application\" using the Layout and Live classes.",
    "functions": [
      {
        "name": "make_layout",
        "args": [],
        "return_type": "Layout",
        "lineno": 20,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Layout",
          "unknown.split",
          "unknown.split_row",
          "layout.split"
        ],
        "docstring": "Define the layout.",
        "code": "def make_layout() -> Layout:\n    \"\"\"Define the layout.\"\"\"\n    layout = Layout(name=\"root\")\n\n    layout.split(\n        Layout(name=\"header\", size=3),\n        Layout(name=\"main\", ratio=1),\n        Layout(name=\"footer\", size=7),\n    )\n    layout[\"main\"].split_row(\n        Layout(name=\"side\"),\n        Layout(name=\"body\", ratio=2, minimum_size=60),\n    )\n    layout[\"side\"].split(Layout(name=\"box1\"), Layout(name=\"box2\"))\n    return layout",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "make_sponsor_message",
        "args": [],
        "return_type": "Panel",
        "lineno": 37,
        "decorators": [],
        "is_async": false,
        "calls": [
          "message.add_column",
          "box.ROUNDED",
          "sponsor_message.add_column",
          "sponsor_message",
          "sponsor_message.add_row",
          "Panel",
          "Group",
          "Table.grid",
          "Align.center",
          "message.add_row"
        ],
        "docstring": "Some example content.",
        "code": "def make_sponsor_message() -> Panel:\n    \"\"\"Some example content.\"\"\"\n    sponsor_message = Table.grid(padding=1)\n    sponsor_message.add_column(style=\"green\", justify=\"right\")\n    sponsor_message.add_column(no_wrap=True)\n    sponsor_message.add_row(\n        \"Twitter\",\n        \"[u blue link=https://twitter.com/textualize]https://twitter.com/textualize\",\n    )\n    sponsor_message.add_row(\n        \"CEO\",\n        \"[u blue link=https://twitter.com/willmcgugan]https://twitter.com/willmcgugan\",\n    )\n    sponsor_message.add_row(\n        \"Textualize\", \"[u blue link=https://www.textualize.io]https://www.textualize.io\"\n    )\n\n    message = Table.grid(padding=1)\n    message.add_column()\n    message.add_column(no_wrap=True)\n    message.add_row(sponsor_message)\n\n    message_panel = Panel(\n        Align.center(\n            Group(\"\\n\", Align.center(sponsor_message)),\n            vertical=\"middle\",\n        ),\n        box=box.ROUNDED,\n        padding=(1, 2),\n        title=\"[b red]Thanks for trying out Rich!\",\n        border_style=\"bright_blue\",\n    )\n    return message_panel",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "make_syntax",
        "args": [],
        "return_type": "Syntax",
        "lineno": 86,
        "decorators": [],
        "is_async": false,
        "calls": [
          "code",
          "Syntax"
        ],
        "docstring": null,
        "code": "def make_syntax() -> Syntax:\n    code = \"\"\"\\\ndef ratio_resolve(total: int, edges: List[Edge]) -> List[int]:\n    sizes = [(edge.size or None) for edge in edges]\n\n    # While any edges haven't been calculated\n    while any(size is None for size in sizes):\n        # Get flexible edges and index to map these back on to sizes list\n        flexible_edges = [\n            (index, edge)\n            for index, (size, edge) in enumerate(zip(sizes, edges))\n            if size is None\n        ]\n        # Remaining space in total\n        remaining = total - sum(size or 0 for size in sizes)\n        if remaining <= 0:\n            # No room for flexible edges\n            sizes[:] = [(size or 0) for size in sizes]\n            break\n        # Calculate number of characters in a ratio portion\n        portion = remaining / sum((edge.ratio or 1) for _, edge in flexible_edges)\n\n        # If any edges will be less than their minimum, replace size with the minimum\n        for index, edge in flexible_edges:\n            if portion * edge.ratio <= edge.minimum_size:\n                sizes[index] = edge.minimum_size\n                break\n        else:\n            # Distribute flexible space and compensate for rounding error\n            # Since edge sizes can only be integers we need to add the remainder\n            # to the following line\n            _modf = modf\n            remainder = 0.0\n            for index, edge in flexible_edges:\n                remainder, size = _modf(portion * edge.ratio + remainder)\n                sizes[index] = int(size)\n            break\n    # Sizes now contains integers only\n    return cast(List[int], sizes)\n    \"\"\"\n    syntax = Syntax(code, \"python\", line_numbers=True)\n    return syntax",
        "line_count": 42,
        "needs_llm_summary": true
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Panel",
        "lineno": 75,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.ctime",
          "grid",
          "unknown.replace",
          "Panel",
          "Table.grid",
          "grid.add_column",
          "grid.add_row",
          "datetime.now"
        ],
        "docstring": null,
        "code": "def __rich__(self) -> Panel:\n        grid = Table.grid(expand=True)\n        grid.add_column(justify=\"center\", ratio=1)\n        grid.add_column(justify=\"right\")\n        grid.add_row(\n            \"[b]Rich[/b] Layout application\",\n            datetime.now().ctime().replace(\":\", \"[blink]:[/]\"),\n        )\n        return Panel(grid, style=\"white on blue\")",
        "line_count": 9,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Header",
        "methods": [
          "__rich__"
        ],
        "base_classes": [],
        "lineno": 72,
        "docstring": "Display header with clock."
      }
    ],
    "imports": [
      {
        "module": "datetime",
        "name": "datetime",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "box",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.align",
        "name": "Align",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Group",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich.layout",
        "name": "Layout",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "BarColumn",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "Progress",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "SpinnerColumn",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "TextColumn",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 164,
        "type": "from_import"
      },
      {
        "module": "rich.live",
        "name": "Live",
        "alias": null,
        "lineno": 166,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 17
      },
      {
        "name": "job_progress",
        "assigned_to": "Progress",
        "lineno": 130
      },
      {
        "name": "total",
        "assigned_to": "sum",
        "lineno": 140
      },
      {
        "name": "overall_progress",
        "assigned_to": "Progress",
        "lineno": 141
      },
      {
        "name": "overall_task",
        "assigned_to": "overall_progress.add_task",
        "lineno": 142
      },
      {
        "name": "progress_table",
        "assigned_to": "Table.grid",
        "lineno": 144
      },
      {
        "name": "layout",
        "assigned_to": "make_layout",
        "lineno": 156
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "sum",
        "Panel",
        "job_progress.advance",
        "Table.grid",
        "make_layout",
        "SpinnerColumn",
        "layout",
        "layout.tree",
        "total",
        "Progress",
        "overall_task",
        "completed",
        "Live",
        "make_sponsor_message",
        "int",
        "sleep",
        "job_progress.add_task",
        "BarColumn",
        "overall_progress.update",
        "Console",
        "progress_table.add_row",
        "job_progress",
        "make_syntax",
        "job.id",
        "Header",
        "unknown.update",
        "overall_progress",
        "TextColumn",
        "progress_table",
        "overall_progress.add_task"
      ],
      "class_instantiations": [
        "BarColumn",
        "Header",
        "Progress",
        "Live",
        "Console",
        "TextColumn",
        "Panel",
        "SpinnerColumn",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time",
        "datetime"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 177
  },
  "examples/group.py": {
    "filepath": "../rich/examples/group.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Group",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "panel_group",
        "assigned_to": "Group",
        "lineno": 5
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "print",
        "Panel",
        "Group",
        "panel_group"
      ],
      "class_instantiations": [
        "Panel",
        "Group"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 10
  },
  "examples/group2.py": {
    "filepath": "../rich/examples/group2.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "get_panels",
        "args": [],
        "return_type": null,
        "lineno": 7,
        "decorators": [
          {
            "name": "group",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "Panel",
          "group"
        ],
        "docstring": null,
        "code": "def get_panels():\n    yield Panel(\"Hello\", style=\"on blue\")\n    yield Panel(\"World\", style=\"on red\")",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "group",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "print",
        "Panel",
        "get_panels"
      ],
      "class_instantiations": [
        "Panel"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 13
  },
  "examples/highlighter.py": {
    "filepath": "../rich/examples/highlighter.py",
    "module_docstring": "This example demonstrates a simple text highlighter.",
    "functions": [],
    "classes": [
      {
        "name": "EmailHighlighter",
        "methods": [],
        "base_classes": [
          "RegexHighlighter"
        ],
        "lineno": 10,
        "docstring": "Apply style to anything that looks like an email."
      }
    ],
    "imports": [
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.highlighter",
        "name": "RegexHighlighter",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich.theme",
        "name": "Theme",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "theme",
        "assigned_to": "Theme",
        "lineno": 17
      },
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 18
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "Theme",
        "Console",
        "theme",
        "EmailHighlighter"
      ],
      "class_instantiations": [
        "Theme",
        "Console",
        "EmailHighlighter"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 21
  },
  "examples/jobs.py": {
    "filepath": "../rich/examples/jobs.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "Progress",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "JOBS",
        "assigned_to": null,
        "lineno": 6
      },
      {
        "name": "progress",
        "assigned_to": "Progress",
        "lineno": 8
      },
      {
        "name": "master_task",
        "assigned_to": "progress.add_task",
        "lineno": 9
      },
      {
        "name": "jobs_task",
        "assigned_to": "progress.add_task",
        "lineno": 10
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "JOBS",
        "sum",
        "enumerate",
        "progress.reset",
        "Progress",
        "jobs_task",
        "master_task",
        "range",
        "Panel",
        "progress.start_task",
        "progress.track",
        "progress.advance",
        "progress.add_task",
        "job",
        "sleep",
        "progress.console.print",
        "progress.log"
      ],
      "class_instantiations": [
        "Panel",
        "Progress"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 32
  },
  "examples/justify.py": {
    "filepath": "../rich/examples/justify.py",
    "module_docstring": "This example demonstrates the justify argument to print.",
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 7
      },
      {
        "name": "style",
        "assigned_to": "str",
        "lineno": 9
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "style",
        "Console"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 14
  },
  "examples/justify2.py": {
    "filepath": "../rich/examples/justify2.py",
    "module_docstring": "This example demonstrates the justify argument to print.",
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 8
      },
      {
        "name": "style",
        "assigned_to": "str",
        "lineno": 10
      },
      {
        "name": "panel",
        "assigned_to": "Panel",
        "lineno": 11
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "style",
        "Console",
        "Panel",
        "panel"
      ],
      "class_instantiations": [
        "Console",
        "Panel"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 16
  },
  "examples/layout.py": {
    "filepath": "../rich/examples/layout.py",
    "module_docstring": "Demonstrates a dynamic Layout",
    "functions": [
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Text",
        "lineno": 44,
        "decorators": [],
        "is_async": false,
        "calls": [
          "datetime.now",
          "Text",
          "unknown.ctime"
        ],
        "docstring": null,
        "code": "def __rich__(self) -> Text:\n        return Text(datetime.now().ctime(), style=\"bold magenta\", justify=\"center\")",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "Clock",
        "methods": [
          "__rich__"
        ],
        "base_classes": [],
        "lineno": 41,
        "docstring": "Renders the time in the center of the screen."
      }
    ],
    "imports": [
      {
        "module": "datetime",
        "name": "datetime",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.align",
        "name": "Align",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "rich.layout",
        "name": "Layout",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.live",
        "name": "Live",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 17
      },
      {
        "name": "layout",
        "assigned_to": "Layout",
        "lineno": 18
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Layout",
        "layout",
        "layout.split",
        "Clock",
        "unknown.update",
        "Console",
        "unknown.split",
        "Live",
        "Align.center",
        "sleep",
        "unknown.split_row",
        "Text"
      ],
      "class_instantiations": [
        "Layout",
        "Clock",
        "Live",
        "Console",
        "Align",
        "Text"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time",
        "datetime"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 56
  },
  "examples/link.py": {
    "filepath": "../rich/examples/link.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "print"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 5
  },
  "examples/listdir.py": {
    "filepath": "../rich/examples/listdir.py",
    "module_docstring": "A very simple `ls` clone.\n\nIf your terminal supports hyperlinks you should be able to launch files by clicking the filename\n(usually with cmd / ctrl).",
    "functions": [
      {
        "name": "make_filename_text",
        "args": [
          {
            "name": "filename"
          }
        ],
        "return_type": null,
        "lineno": 22,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.path.isdir",
          "text.stylize",
          "os.path.join",
          "text.highlight_regex",
          "path",
          "filename",
          "os.path.abspath",
          "root_path",
          "Text"
        ],
        "docstring": null,
        "code": "def make_filename_text(filename):\n        path = os.path.abspath(os.path.join(root_path, filename))\n        text = Text(filename, style=\"bold blue\" if os.path.isdir(path) else \"default\")\n        text.stylize(f\"link file://{path}\")\n        text.highlight_regex(r\"\\..*?$\", \"bold\")\n        return text",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "os",
        "alias": null,
        "lineno": 9,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 10,
        "type": "import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "rich.columns",
        "name": "Columns",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "os.path.isdir",
        "text.stylize",
        "Columns",
        "os.path.abspath",
        "filename.startswith",
        "os.path.join",
        "text.highlight_regex",
        "filename.lower",
        "path",
        "make_filename_text",
        "columns",
        "filename",
        "filename_text",
        "print",
        "filenames.sort",
        "root_path",
        "Text",
        "os.listdir"
      ],
      "class_instantiations": [
        "Columns",
        "Text"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "os"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 36
  },
  "examples/live_progress.py": {
    "filepath": "../rich/examples/live_progress.py",
    "module_docstring": "Demonstrates the use of multiple Progress instances in a single Live display.    ",
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.live",
        "name": "Live",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "Progress",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "SpinnerColumn",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "BarColumn",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.progress",
        "name": "TextColumn",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "job_progress",
        "assigned_to": "Progress",
        "lineno": 15
      },
      {
        "name": "job1",
        "assigned_to": "job_progress.add_task",
        "lineno": 21
      },
      {
        "name": "job2",
        "assigned_to": "job_progress.add_task",
        "lineno": 22
      },
      {
        "name": "job3",
        "assigned_to": "job_progress.add_task",
        "lineno": 23
      },
      {
        "name": "total",
        "assigned_to": "sum",
        "lineno": 25
      },
      {
        "name": "overall_progress",
        "assigned_to": "Progress",
        "lineno": 26
      },
      {
        "name": "overall_task",
        "assigned_to": "overall_progress.add_task",
        "lineno": 27
      },
      {
        "name": "progress_table",
        "assigned_to": "Table.grid",
        "lineno": 29
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "sum",
        "job_progress.advance",
        "Table.grid",
        "SpinnerColumn",
        "total",
        "Progress",
        "overall_task",
        "completed",
        "Live",
        "sleep",
        "int",
        "Panel.fit",
        "job_progress.add_task",
        "BarColumn",
        "overall_progress.update",
        "progress_table.add_row",
        "job_progress",
        "job.id",
        "overall_progress",
        "TextColumn",
        "progress_table",
        "overall_progress.add_task"
      ],
      "class_instantiations": [
        "BarColumn",
        "Progress",
        "Live",
        "Panel",
        "TextColumn",
        "SpinnerColumn",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 46
  },
  "examples/log.py": {
    "filepath": "../rich/examples/log.py",
    "module_docstring": "A simulation of Rich console logging.",
    "functions": [
      {
        "name": "test_locals",
        "args": [],
        "return_type": null,
        "lineno": 53,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Console",
          "console.log"
        ],
        "docstring": null,
        "code": "def test_locals():\n    foo = (1, 2, 3)\n    movies = [\"Deadpool\", \"Rise of the Skywalker\"]\n    console = Console()\n\n    console.log(\n        \"[b]JSON[/b] RPC [i]batch[/i]\",\n        [\n            {\"jsonrpc\": \"2.0\", \"method\": \"sum\", \"params\": [1, 2, 4], \"id\": \"1\"},\n            {\"jsonrpc\": \"2.0\", \"method\": \"notify_hello\", \"params\": [7]},\n            {\"jsonrpc\": \"2.0\", \"method\": \"subtract\", \"params\": [42, 23], \"id\": \"2\"},\n            {\"foo\": \"boo\"},\n            {\n                \"jsonrpc\": \"2.0\",\n                \"method\": \"foo.get\",\n                \"params\": {\"name\": \"myself\", \"enable\": False, \"grommits\": None},\n                \"id\": \"5\",\n            },\n            {\"jsonrpc\": \"2.0\", \"method\": \"get_data\", \"id\": \"9\"},\n        ],\n        log_locals=True,\n    )",
        "line_count": 22,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "RequestHighlighter",
        "methods": [],
        "base_classes": [
          "RegexHighlighter"
        ],
        "lineno": 12,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "time",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich.style",
        "name": "Style",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.theme",
        "name": "Theme",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.highlighter",
        "name": "RegexHighlighter",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "theme",
        "assigned_to": "Theme",
        "lineno": 20
      },
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 30
      },
      {
        "name": "request_highlighter",
        "assigned_to": "RequestHighlighter",
        "lineno": 37
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.log",
        "time.sleep",
        "Theme",
        "Console",
        "request_highlighter",
        "theme",
        "test_locals",
        "RequestHighlighter",
        "Style.parse"
      ],
      "class_instantiations": [
        "Theme",
        "Style",
        "Console",
        "RequestHighlighter"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 78
  },
  "examples/overflow.py": {
    "filepath": "../rich/examples/overflow.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "OverflowMethod",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 4
      },
      {
        "name": "supercali",
        "assigned_to": "str",
        "lineno": 5
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.rule",
        "overflow",
        "Console",
        "supercali"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 12
  },
  "examples/padding.py": {
    "filepath": "../rich/examples/padding.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.padding",
        "name": "Padding",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "test",
        "assigned_to": "Padding",
        "lineno": 4
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Padding",
        "print",
        "test"
      ],
      "class_instantiations": [
        "Padding"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 6
  },
  "examples/print_calendar.py": {
    "filepath": "../rich/examples/print_calendar.py",
    "module_docstring": "Builds calendar layout using Columns and Tables.\nUsage:\npython print_calendar.py [YEAR]\nExample:\npython print_calendar.py 2021",
    "functions": [
      {
        "name": "print_calendar",
        "args": [
          {
            "name": "year"
          }
        ],
        "return_type": null,
        "lineno": 20,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "Columns",
          "console.rule",
          "day_label.stylize",
          "datetime.today",
          "tables.append",
          "table.add_row",
          "unknown.format",
          "box.SIMPLE_HEAVY",
          "calendar.Calendar",
          "tables",
          "days.append",
          "year",
          "month",
          "int",
          "cal.iterweekdays",
          "Text",
          "str",
          "table",
          "Console",
          "Align.center",
          "console.print",
          "range",
          "day_label",
          "weekdays",
          "columns",
          "table.add_column",
          "Table",
          "cal.monthdayscalendar"
        ],
        "docstring": "Print a calendar for a given year.",
        "code": "def print_calendar(year):\n    \"\"\"Print a calendar for a given year.\"\"\"\n\n    today = datetime.today()\n    year = int(year)\n    cal = calendar.Calendar()\n    today_tuple = today.day, today.month, today.year\n\n    tables = []\n\n    for month in range(1, 13):\n        table = Table(\n            title=f\"{calendar.month_name[month]} {year}\",\n            style=\"green\",\n            box=box.SIMPLE_HEAVY,\n            padding=0,\n        )\n\n        for week_day in cal.iterweekdays():\n            table.add_column(\n                \"{:.3}\".format(calendar.day_name[week_day]), justify=\"right\"\n            )\n\n        month_days = cal.monthdayscalendar(year, month)\n        for weekdays in month_days:\n            days = []\n            for index, day in enumerate(weekdays):\n                day_label = Text(str(day or \"\"), style=\"magenta\")\n                if index in (5, 6):\n                    day_label.stylize(\"blue\")\n                if day and (day, month, year) == today_tuple:\n                    day_label.stylize(\"white on dark_red\")\n                days.append(day_label)\n            table.add_row(*days)\n\n        tables.append(Align.center(table))\n\n    console = Console()\n    columns = Columns(tables, padding=1, expand=True)\n    console.rule(str(year))\n    console.print()\n    console.print(columns)\n    console.rule(str(year))",
        "line_count": 43,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "argparse",
        "alias": null,
        "lineno": 8,
        "type": "import"
      },
      {
        "module": "calendar",
        "alias": null,
        "lineno": 9,
        "type": "import"
      },
      {
        "module": "datetime",
        "name": "datetime",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich.align",
        "name": "Align",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "box",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.columns",
        "name": "Columns",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "print_calendar",
      "argparse.ArgumentParser",
      "parser.parse_args",
      "parser.add_argument"
    ],
    "module_level_calls": {
      "function_calls": [
        "argparse.ArgumentParser",
        "args.year",
        "print_calendar",
        "parser.parse_args",
        "int",
        "parser.add_argument"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "argparse",
        "datetime"
      ],
      "third_party": {
        "other": [
          "calendar",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 71
  },
  "examples/rainbow.py": {
    "filepath": "../rich/examples/rainbow.py",
    "module_docstring": "This example demonstrates how to write a custom highlighter.",
    "functions": [
      {
        "name": "highlight",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text"
          }
        ],
        "return_type": null,
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text.stylize",
          "randint",
          "range",
          "index",
          "text",
          "len"
        ],
        "docstring": null,
        "code": "def highlight(self, text):\n        for index in range(len(text)):\n            text.stylize(f\"color({randint(16, 255)})\", index, index + 1)",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "RainbowHighlighter",
        "methods": [
          "highlight"
        ],
        "base_classes": [
          "Highlighter"
        ],
        "lineno": 13,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "random",
        "name": "randint",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.highlighter",
        "name": "Highlighter",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "rainbow",
        "assigned_to": "RainbowHighlighter",
        "lineno": 19
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "rainbow",
        "print",
        "RainbowHighlighter"
      ],
      "class_instantiations": [
        "RainbowHighlighter"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "random"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 21
  },
  "examples/recursive_error.py": {
    "filepath": "../rich/examples/recursive_error.py",
    "module_docstring": "Demonstrates Rich tracebacks for recursion errors.\n\nRich can exclude frames in the middle to avoid huge tracebacks.",
    "functions": [
      {
        "name": "foo",
        "args": [
          {
            "name": "n"
          }
        ],
        "return_type": null,
        "lineno": 12,
        "decorators": [],
        "is_async": false,
        "calls": [
          "n",
          "bar"
        ],
        "docstring": null,
        "code": "def foo(n):\n    return bar(n)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "bar",
        "args": [
          {
            "name": "n"
          }
        ],
        "return_type": null,
        "lineno": 16,
        "decorators": [],
        "is_async": false,
        "calls": [
          "n",
          "foo"
        ],
        "docstring": null,
        "code": "def bar(n):\n    return foo(n)",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 20
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Console",
        "foo",
        "console.print_exception"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 26
  },
  "examples/repr.py": {
    "filepath": "../rich/examples/repr.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name"
          },
          {
            "name": "eats"
          },
          {
            "name": "fly"
          },
          {
            "name": "extinct"
          }
        ],
        "return_type": null,
        "lineno": 6,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "eats",
          "list",
          "fly",
          "extinct"
        ],
        "docstring": null,
        "code": "def __init__(self, name, eats=None, fly=True, extinct=False):\n        self.name = name\n        self.eats = list(eats) if eats else []\n        self.fly = fly\n        self.extinct = extinct",
        "line_count": 5,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Bird",
        "methods": [
          "__init__"
        ],
        "base_classes": [],
        "lineno": 5,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "rich.repr",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "BIRDS",
        "assigned_to": null,
        "lineno": 18
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "print",
        "Bird",
        "BIRDS"
      ],
      "class_instantiations": [
        "Bird"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 24
  },
  "examples/save_table_svg.py": {
    "filepath": "../rich/examples/save_table_svg.py",
    "module_docstring": "Demonstrates how to export a SVG",
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 23,
        "type": "import"
      },
      {
        "module": "webbrowser",
        "alias": null,
        "lineno": 24,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "table",
        "assigned_to": "Table",
        "lineno": 8
      },
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 19
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.save_svg",
        "os.path.abspath",
        "table",
        "Console",
        "webbrowser.open",
        "table.add_column",
        "table.add_row",
        "Table"
      ],
      "class_instantiations": [
        "Console",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "os"
      ],
      "third_party": {
        "other": [
          "rich",
          "webbrowser"
        ]
      },
      "tech_stack": []
    },
    "line_count": 27
  },
  "examples/screen.py": {
    "filepath": "../rich/examples/screen.py",
    "module_docstring": "Demonstration of Console.screen() ",
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.align",
        "name": "Align",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 11
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.screen",
        "Console",
        "Panel",
        "screen.update",
        "text",
        "Align.center",
        "sleep"
      ],
      "class_instantiations": [
        "Align",
        "Console",
        "Panel"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 17
  },
  "examples/spinners.py": {
    "filepath": "../rich/examples/spinners.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.columns",
        "name": "Columns",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.live",
        "name": "Live",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich.spinner",
        "name": "Spinner",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.spinner",
        "name": "SPINNERS",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "all_spinners",
        "assigned_to": "Columns",
        "lineno": 9
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Columns",
        "Spinner",
        "Live",
        "Panel",
        "SPINNERS",
        "all_spinners",
        "sorted",
        "sleep",
        "spinner_name",
        "repr",
        "Text"
      ],
      "class_instantiations": [
        "Columns",
        "Spinner",
        "Live",
        "Panel",
        "Text"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 24
  },
  "examples/status.py": {
    "filepath": "../rich/examples/status.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 4
      },
      {
        "name": "tasks",
        "assigned_to": null,
        "lineno": 7
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "range",
        "console.log",
        "Console",
        "tasks.pop",
        "sleep",
        "console.status"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 14
  },
  "examples/suppress.py": {
    "filepath": "../rich/examples/suppress.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "hello",
        "args": [
          {
            "name": "count"
          }
        ],
        "return_type": null,
        "lineno": 15,
        "decorators": [
          {
            "name": "click.command",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "click.option",
            "args": [
              "--count"
            ],
            "kwargs": {
              "default": 1,
              "help": "Number of greetings."
            }
          }
        ],
        "is_async": false,
        "calls": [
          "range",
          "count",
          "click.echo",
          "click.command",
          "click.option"
        ],
        "docstring": "Simple program that greets NAME for a total of COUNT times.",
        "code": "def hello(count):\n    \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\"\n    1 / 0\n    for x in range(count):\n        click.echo(f\"Hello {name}!\")",
        "line_count": 5,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "rich.traceback",
        "name": "install",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "click",
        "alias": null,
        "lineno": 2,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "hello"
    ],
    "module_level_calls": {
      "function_calls": [
        "hello",
        "print",
        "install",
        "exit"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich",
          "click"
        ]
      },
      "tech_stack": []
    },
    "line_count": 24
  },
  "examples/table.py": {
    "filepath": "../rich/examples/table.py",
    "module_docstring": "Demonstrates how to render a table.",
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "table",
        "assigned_to": "Table",
        "lineno": 8
      },
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 19
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "table",
        "Console",
        "table.add_column",
        "table.add_row",
        "Table"
      ],
      "class_instantiations": [
        "Console",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 21
  },
  "examples/table_movie.py": {
    "filepath": "../rich/examples/table_movie.py",
    "module_docstring": "Same as the table_movie.py but uses Live to update",
    "functions": [
      {
        "name": "beat",
        "args": [
          {
            "name": "length",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 63,
        "decorators": [
          {
            "name": "contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "time.sleep"
        ],
        "docstring": null,
        "code": "def beat(length: int = 1) -> None:\n    yield\n    time.sleep(length * BEAT_TIME)",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "contextlib",
        "name": "contextmanager",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "box",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.align",
        "name": "Align",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.live",
        "name": "Live",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "TABLE_DATA",
        "assigned_to": null,
        "lineno": 12
      },
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 57
      },
      {
        "name": "BEAT_TIME",
        "assigned_to": "float",
        "lineno": 59
      },
      {
        "name": "table",
        "assigned_to": "Table",
        "lineno": 68
      },
      {
        "name": "table_centered",
        "assigned_to": "Align.center",
        "lineno": 69
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "table_centered",
        "table.add_row",
        "console.clear",
        "console.width",
        "console.measure",
        "box_style",
        "Live",
        "Text.from_markup",
        "original_width",
        "table",
        "Console",
        "width",
        "Align.center",
        "console",
        "range",
        "unknown.maximum",
        "beat",
        "table.add_column",
        "Table"
      ],
      "class_instantiations": [
        "Live",
        "Console",
        "Text",
        "Align",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "contextlib",
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 197
  },
  "examples/top_lite_simulator.py": {
    "filepath": "../rich/examples/top_lite_simulator.py",
    "module_docstring": "Lite simulation of the top linux command.",
    "functions": [
      {
        "name": "generate_process",
        "args": [
          {
            "name": "pid",
            "type": "int"
          }
        ],
        "return_type": "Process",
        "lineno": 37,
        "decorators": [],
        "is_async": false,
        "calls": [
          "datetime.timedelta",
          "datetime.datetime.now",
          "pid",
          "random.random",
          "Process",
          "random.randint"
        ],
        "docstring": null,
        "code": "def generate_process(pid: int) -> Process:\n    return Process(\n        pid=pid,\n        command=f\"Process {pid}\",\n        cpu_percent=random.random() * 20,\n        memory=random.randint(10, 200) ** 3,\n        start_time=datetime.datetime.now()\n        - datetime.timedelta(seconds=random.randint(0, 500) ** 2),\n        thread_count=random.randint(1, 32),\n        state=\"running\" if random.randint(0, 10) < 8 else \"sleeping\",\n    )",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "create_process_table",
        "args": [
          {
            "name": "height",
            "type": "int"
          }
        ],
        "return_type": "Table",
        "lineno": 50,
        "decorators": [],
        "is_async": false,
        "calls": [
          "generate_process",
          "process.pid",
          "range",
          "str",
          "process.thread_count",
          "process.command",
          "process.memory_str",
          "height",
          "process.state",
          "pid",
          "sorted",
          "process.time_str",
          "box.SIMPLE",
          "table.add_row",
          "Table"
        ],
        "docstring": null,
        "code": "def create_process_table(height: int) -> Table:\n    processes = sorted(\n        [generate_process(pid) for pid in range(height)],\n        key=lambda p: p.cpu_percent,\n        reverse=True,\n    )\n    table = Table(\n        \"PID\", \"Command\", \"CPU %\", \"Memory\", \"Time\", \"Thread #\", \"State\", box=box.SIMPLE\n    )\n\n    for process in processes:\n        table.add_row(\n            str(process.pid),\n            process.command,\n            f\"{process.cpu_percent:.1f}\",\n            process.memory_str,\n            process.time_str,\n            str(process.thread_count),\n            process.state,\n        )\n\n    return table",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "memory_str",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 25,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "int",
          "str",
          "self.memory"
        ],
        "docstring": null,
        "code": "def memory_str(self) -> str:\n        if self.memory > 1e6:\n            return f\"{int(self.memory/1e6)}M\"\n        if self.memory > 1e3:\n            return f\"{int(self.memory/1e3)}K\"\n        return str(self.memory)",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "time_str",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 33,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "str",
          "datetime.datetime.now"
        ],
        "docstring": null,
        "code": "def time_str(self) -> str:\n        return str(datetime.datetime.now() - self.start_time)",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "Process",
        "methods": [
          "memory_str",
          "time_str"
        ],
        "base_classes": [],
        "lineno": 15,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "datetime",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "random",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "time",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "dataclasses",
        "name": "dataclass",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "box",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.live",
        "name": "Live",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Literal",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 74
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "create_process_table",
        "time.sleep",
        "Live",
        "Console",
        "console",
        "live.update"
      ],
      "class_instantiations": [
        "Live",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "datetime",
        "typing",
        "dataclasses",
        "random",
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 80
  },
  "examples/tree.py": {
    "filepath": "../rich/examples/tree.py",
    "module_docstring": "Demonstrates how to display a tree of files / directories with the Tree renderable.",
    "functions": [
      {
        "name": "walk_directory",
        "args": [
          {
            "name": "directory",
            "type": "pathlib.Path"
          },
          {
            "name": "tree",
            "type": "Tree"
          }
        ],
        "return_type": "None",
        "lineno": 16,
        "decorators": [],
        "is_async": false,
        "calls": [
          "icon",
          "unknown.st_size",
          "style",
          "tree.add",
          "text_filename.highlight_regex",
          "path.name",
          "path.is_file",
          "path.stat",
          "decimal",
          "walk_directory",
          "escape",
          "Text",
          "path.name.startswith",
          "path.name.lower",
          "file_size",
          "text_filename.stylize",
          "path.is_dir",
          "branch",
          "unknown.iterdir",
          "text_filename.append",
          "directory",
          "path",
          "sorted",
          "pathlib.Path"
        ],
        "docstring": "Recursively build a Tree with directory contents.",
        "code": "def walk_directory(directory: pathlib.Path, tree: Tree) -> None:\n    \"\"\"Recursively build a Tree with directory contents.\"\"\"\n    # Sort dirs first then by filename\n    paths = sorted(\n        pathlib.Path(directory).iterdir(),\n        key=lambda path: (path.is_file(), path.name.lower()),\n    )\n    for path in paths:\n        # Remove hidden files\n        if path.name.startswith(\".\"):\n            continue\n        if path.is_dir():\n            style = \"dim\" if path.name.startswith(\"__\") else \"\"\n            branch = tree.add(\n                f\"[bold magenta]:open_file_folder: [link file://{path}]{escape(path.name)}\",\n                style=style,\n                guide_style=style,\n            )\n            walk_directory(path, branch)\n        else:\n            text_filename = Text(path.name, \"green\")\n            text_filename.highlight_regex(r\"\\..*$\", \"bold red\")\n            text_filename.stylize(f\"link file://{path}\")\n            file_size = path.stat().st_size\n            text_filename.append(f\" ({decimal(file_size)})\", \"blue\")\n            icon = \"\ud83d\udc0d \" if path.suffix == \".py\" else \"\ud83d\udcc4 \"\n            tree.add(Text(icon) + text_filename)",
        "line_count": 27,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "os",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "pathlib",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.filesize",
        "name": "decimal",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich.markup",
        "name": "escape",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "rich.tree",
        "name": "Tree",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "directory",
        "tree",
        "Tree",
        "walk_directory",
        "print",
        "os.path.abspath",
        "pathlib.Path"
      ],
      "class_instantiations": [
        "Tree"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "os",
        "pathlib"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 56
  },
  "rich/__init__.py": {
    "filepath": "../rich/rich/__init__.py",
    "module_docstring": "Rich text and beautiful formatting in the terminal.",
    "functions": [
      {
        "name": "get_console",
        "args": [],
        "return_type": "Console",
        "lineno": 23,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Console"
        ],
        "docstring": "Get a global :class:`~rich.console.Console` instance. This function is used when Rich requires a Console,\nand hasn't been explicitly given one.\n\nReturns:\n    Console: A console instance.",
        "code": "def get_console() -> \"Console\":\n    \"\"\"Get a global :class:`~rich.console.Console` instance. This function is used when Rich requires a Console,\n    and hasn't been explicitly given one.\n\n    Returns:\n        Console: A console instance.\n    \"\"\"\n    global _console\n    if _console is None:\n        from .console import Console\n\n        _console = Console()\n\n    return _console",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "reconfigure",
        "args": [],
        "return_type": "None",
        "lineno": 39,
        "decorators": [],
        "is_async": false,
        "calls": [
          "get_console",
          "new_console.__dict__",
          "kwargs",
          "Console"
        ],
        "docstring": "Reconfigures the global console by replacing it with another.\n\nArgs:\n    *args (Any): Positional arguments for the replacement :class:`~rich.console.Console`.\n    **kwargs (Any): Keyword arguments for the replacement :class:`~rich.console.Console`.",
        "code": "def reconfigure(*args: Any, **kwargs: Any) -> None:\n    \"\"\"Reconfigures the global console by replacing it with another.\n\n    Args:\n        *args (Any): Positional arguments for the replacement :class:`~rich.console.Console`.\n        **kwargs (Any): Keyword arguments for the replacement :class:`~rich.console.Console`.\n    \"\"\"\n    from rich.console import Console\n\n    new_console = Console(*args, **kwargs)\n    _console = get_console()\n    _console.__dict__ = new_console.__dict__",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "print",
        "args": [],
        "return_type": "None",
        "lineno": 53,
        "decorators": [],
        "is_async": false,
        "calls": [
          "write_console.print",
          "end",
          "Console",
          "get_console",
          "sep",
          "file"
        ],
        "docstring": "Print object(s) supplied via positional arguments.\nThis function has an identical signature to the built-in print.\nFor more advanced features, see the :class:`~rich.console.Console` class.\n\nArgs:\n    sep (str, optional): Separator between printed objects. Defaults to \" \".\n    end (str, optional): Character to write at end of output. Defaults to \"\\\\n\".\n    file (IO[str], optional): File to write to, or None for stdout. Defaults to None.\n    flush (bool, optional): Has no effect as Rich always flushes output. Defaults to False.",
        "code": "def print(\n    *objects: Any,\n    sep: str = \" \",\n    end: str = \"\\n\",\n    file: Optional[IO[str]] = None,\n    flush: bool = False,\n) -> None:\n    r\"\"\"Print object(s) supplied via positional arguments.\n    This function has an identical signature to the built-in print.\n    For more advanced features, see the :class:`~rich.console.Console` class.\n\n    Args:\n        sep (str, optional): Separator between printed objects. Defaults to \" \".\n        end (str, optional): Character to write at end of output. Defaults to \"\\\\n\".\n        file (IO[str], optional): File to write to, or None for stdout. Defaults to None.\n        flush (bool, optional): Has no effect as Rich always flushes output. Defaults to False.\n\n    \"\"\"\n    from .console import Console\n\n    write_console = get_console() if file is None else Console(file=file)\n    return write_console.print(*objects, sep=sep, end=end)",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "print_json",
        "args": [
          {
            "name": "json",
            "type": "Optional[str]"
          }
        ],
        "return_type": "None",
        "lineno": 77,
        "decorators": [],
        "is_async": false,
        "calls": [
          "check_circular",
          "indent",
          "ensure_ascii",
          "sort_keys",
          "highlight",
          "allow_nan",
          "get_console",
          "json",
          "data",
          "skip_keys",
          "unknown.print_json",
          "default"
        ],
        "docstring": "Pretty prints JSON. Output will be valid JSON.\n\nArgs:\n    json (str): A string containing JSON.\n    data (Any): If json is not supplied, then encode this data.\n    indent (int, optional): Number of spaces to indent. Defaults to 2.\n    highlight (bool, optional): Enable highlighting of output: Defaults to True.\n    skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n    ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n    check_circular (bool, optional): Check for circular references. Defaults to True.\n    allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n    default (Callable, optional): A callable that converts values that can not be encoded\n        in to something that can be JSON encoded. Defaults to None.\n    sort_keys (bool, optional): Sort dictionary keys. Defaults to False.",
        "code": "def print_json(\n    json: Optional[str] = None,\n    *,\n    data: Any = None,\n    indent: Union[None, int, str] = 2,\n    highlight: bool = True,\n    skip_keys: bool = False,\n    ensure_ascii: bool = False,\n    check_circular: bool = True,\n    allow_nan: bool = True,\n    default: Optional[Callable[[Any], Any]] = None,\n    sort_keys: bool = False,\n) -> None:\n    \"\"\"Pretty prints JSON. Output will be valid JSON.\n\n    Args:\n        json (str): A string containing JSON.\n        data (Any): If json is not supplied, then encode this data.\n        indent (int, optional): Number of spaces to indent. Defaults to 2.\n        highlight (bool, optional): Enable highlighting of output: Defaults to True.\n        skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n        ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n        check_circular (bool, optional): Check for circular references. Defaults to True.\n        allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n        default (Callable, optional): A callable that converts values that can not be encoded\n            in to something that can be JSON encoded. Defaults to None.\n        sort_keys (bool, optional): Sort dictionary keys. Defaults to False.\n    \"\"\"\n\n    get_console().print_json(\n        json,\n        data=data,\n        indent=indent,\n        highlight=highlight,\n        skip_keys=skip_keys,\n        ensure_ascii=ensure_ascii,\n        check_circular=check_circular,\n        allow_nan=allow_nan,\n        default=default,\n        sort_keys=sort_keys,\n    )",
        "line_count": 41,
        "needs_llm_summary": true
      },
      {
        "name": "inspect",
        "args": [
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 120,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sort",
          "value",
          "obj",
          "_inspect",
          "dunder",
          "get_console",
          "Inspect",
          "title",
          "all",
          "_console.print",
          "private"
        ],
        "docstring": "Inspect any Python object.\n\n* inspect(<OBJECT>) to see summarized info.\n* inspect(<OBJECT>, methods=True) to see methods.\n* inspect(<OBJECT>, help=True) to see full (non-abbreviated) help.\n* inspect(<OBJECT>, private=True) to see private attributes (single underscore).\n* inspect(<OBJECT>, dunder=True) to see attributes beginning with double underscore.\n* inspect(<OBJECT>, all=True) to see all attributes.\n\nArgs:\n    obj (Any): An object to inspect.\n    title (str, optional): Title to display over inspect result, or None use type. Defaults to None.\n    help (bool, optional): Show full help text rather than just first paragraph. Defaults to False.\n    methods (bool, optional): Enable inspection of callables. Defaults to False.\n    docs (bool, optional): Also render doc strings. Defaults to True.\n    private (bool, optional): Show private attributes (beginning with underscore). Defaults to False.\n    dunder (bool, optional): Show attributes starting with double underscore. Defaults to False.\n    sort (bool, optional): Sort attributes alphabetically. Defaults to True.\n    all (bool, optional): Show all attributes. Defaults to False.\n    value (bool, optional): Pretty print value. Defaults to True.",
        "code": "def inspect(\n    obj: Any,\n    *,\n    console: Optional[\"Console\"] = None,\n    title: Optional[str] = None,\n    help: bool = False,\n    methods: bool = False,\n    docs: bool = True,\n    private: bool = False,\n    dunder: bool = False,\n    sort: bool = True,\n    all: bool = False,\n    value: bool = True,\n) -> None:\n    \"\"\"Inspect any Python object.\n\n    * inspect(<OBJECT>) to see summarized info.\n    * inspect(<OBJECT>, methods=True) to see methods.\n    * inspect(<OBJECT>, help=True) to see full (non-abbreviated) help.\n    * inspect(<OBJECT>, private=True) to see private attributes (single underscore).\n    * inspect(<OBJECT>, dunder=True) to see attributes beginning with double underscore.\n    * inspect(<OBJECT>, all=True) to see all attributes.\n\n    Args:\n        obj (Any): An object to inspect.\n        title (str, optional): Title to display over inspect result, or None use type. Defaults to None.\n        help (bool, optional): Show full help text rather than just first paragraph. Defaults to False.\n        methods (bool, optional): Enable inspection of callables. Defaults to False.\n        docs (bool, optional): Also render doc strings. Defaults to True.\n        private (bool, optional): Show private attributes (beginning with underscore). Defaults to False.\n        dunder (bool, optional): Show attributes starting with double underscore. Defaults to False.\n        sort (bool, optional): Sort attributes alphabetically. Defaults to True.\n        all (bool, optional): Show all attributes. Defaults to False.\n        value (bool, optional): Pretty print value. Defaults to True.\n    \"\"\"\n    _console = console or get_console()\n    from rich._inspect import Inspect\n\n    # Special case for inspect(inspect)\n    is_inspect = obj is inspect\n\n    _inspect = Inspect(\n        obj,\n        title=title,\n        help=is_inspect or help,\n        methods=is_inspect or methods,\n        docs=is_inspect or docs,\n        private=private,\n        dunder=dunder,\n        sort=sort,\n        all=all,\n        value=value,\n    )\n    _console.print(_inspect)",
        "line_count": 54,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "os",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "IO",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "_extension",
        "name": "load_ipython_extension",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 71,
        "type": "from_import"
      },
      {
        "module": "rich._inspect",
        "name": "Inspect",
        "alias": null,
        "lineno": 156,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "__all__",
        "assigned_to": null,
        "lineno": 8
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "print"
    ],
    "module_level_calls": {
      "function_calls": [
        "print",
        "os.path.abspath",
        "os.getcwd"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "os",
        "typing"
      ],
      "third_party": {
        "other": [
          "_extension",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 178
  },
  "rich/__main__.py": {
    "filepath": "../rich/rich/__main__.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "make_test_card",
        "args": [],
        "return_type": "Table",
        "lineno": 39,
        "decorators": [],
        "is_async": false,
        "calls": [
          "markdown_example",
          "Table.grid",
          "renderable2",
          "color_table.add_row",
          "table.add_row",
          "example_table.add_row",
          "example_table",
          "comparison",
          "Text.from_markup",
          "ColorBox",
          "markup_example",
          "Markdown",
          "code",
          "Syntax",
          "renderable1",
          "Text",
          "lorem",
          "Group",
          "color_table",
          "lorem_table.add_row",
          "box.SIMPLE",
          "lorem_table",
          "Pretty",
          "example_table.add_column",
          "pretty_data",
          "table.add_column",
          "Table"
        ],
        "docstring": "Get a renderable that demonstrates a number of features.",
        "code": "def make_test_card() -> Table:\n    \"\"\"Get a renderable that demonstrates a number of features.\"\"\"\n    table = Table.grid(padding=1, pad_edge=True)\n    table.title = \"Rich features\"\n    table.add_column(\"Feature\", no_wrap=True, justify=\"center\", style=\"bold red\")\n    table.add_column(\"Demonstration\")\n\n    color_table = Table(\n        box=None,\n        expand=False,\n        show_header=False,\n        show_edge=False,\n        pad_edge=False,\n    )\n    color_table.add_row(\n        (\n            \"\u2713 [bold green]4-bit color[/]\\n\"\n            \"\u2713 [bold blue]8-bit color[/]\\n\"\n            \"\u2713 [bold magenta]Truecolor (16.7 million)[/]\\n\"\n            \"\u2713 [bold yellow]Dumb terminals[/]\\n\"\n            \"\u2713 [bold cyan]Automatic color conversion\"\n        ),\n        ColorBox(),\n    )\n\n    table.add_row(\"Colors\", color_table)\n\n    table.add_row(\n        \"Styles\",\n        \"All ansi styles: [bold]bold[/], [dim]dim[/], [italic]italic[/italic], [underline]underline[/], [strike]strikethrough[/], [reverse]reverse[/], and even [blink]blink[/].\",\n    )\n\n    lorem = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque in metus sed sapien ultricies pretium a at justo. Maecenas luctus velit et auctor maximus.\"\n    lorem_table = Table.grid(padding=1, collapse_padding=True)\n    lorem_table.pad_edge = False\n    lorem_table.add_row(\n        Text(lorem, justify=\"left\", style=\"green\"),\n        Text(lorem, justify=\"center\", style=\"yellow\"),\n        Text(lorem, justify=\"right\", style=\"blue\"),\n        Text(lorem, justify=\"full\", style=\"red\"),\n    )\n    table.add_row(\n        \"Text\",\n        Group(\n            Text.from_markup(\n                \"\"\"Word wrap text. Justify [green]left[/], [yellow]center[/], [blue]right[/] or [red]full[/].\\n\"\"\"\n            ),\n            lorem_table,\n        ),\n    )\n\n    def comparison(renderable1: RenderableType, renderable2: RenderableType) -> Table:\n        table = Table(show_header=False, pad_edge=False, box=None, expand=True)\n        table.add_column(\"1\", ratio=1)\n        table.add_column(\"2\", ratio=1)\n        table.add_row(renderable1, renderable2)\n        return table\n\n    table.add_row(\n        \"Asian\\nlanguage\\nsupport\",\n        \":flag_for_china:  \u8be5\u5e93\u652f\u6301\u4e2d\u6587\uff0c\u65e5\u6587\u548c\u97e9\u6587\u6587\u672c\uff01\\n:flag_for_japan:  \u30e9\u30a4\u30d6\u30e9\u30ea\u306f\u4e2d\u56fd\u8a9e\u3001\u65e5\u672c\u8a9e\u3001\u97d3\u56fd\u8a9e\u306e\u30c6\u30ad\u30b9\u30c8\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u307e\u3059\\n:flag_for_south_korea:  \uc774 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 \uc911\uad6d\uc5b4, \uc77c\ubcf8\uc5b4 \ubc0f \ud55c\uad6d\uc5b4 \ud14d\uc2a4\ud2b8\ub97c \uc9c0\uc6d0\ud569\ub2c8\ub2e4\",\n    )\n\n    markup_example = (\n        \"[bold magenta]Rich[/] supports a simple [i]bbcode[/i]-like [b]markup[/b] for [yellow]color[/], [underline]style[/], and emoji! \"\n        \":+1: :apple: :ant: :bear: :baguette_bread: :bus: \"\n    )\n    table.add_row(\"Markup\", markup_example)\n\n    example_table = Table(\n        show_edge=False,\n        show_header=True,\n        expand=False,\n        row_styles=[\"none\", \"dim\"],\n        box=box.SIMPLE,\n    )\n    example_table.add_column(\"[green]Date\", style=\"green\", no_wrap=True)\n    example_table.add_column(\"[blue]Title\", style=\"blue\")\n    example_table.add_column(\n        \"[cyan]Production Budget\",\n        style=\"cyan\",\n        justify=\"right\",\n        no_wrap=True,\n    )\n    example_table.add_column(\n        \"[magenta]Box Office\",\n        style=\"magenta\",\n        justify=\"right\",\n        no_wrap=True,\n    )\n    example_table.add_row(\n        \"Dec 20, 2019\",\n        \"Star Wars: The Rise of Skywalker\",\n        \"$275,000,000\",\n        \"$375,126,118\",\n    )\n    example_table.add_row(\n        \"May 25, 2018\",\n        \"[b]Solo[/]: A Star Wars Story\",\n        \"$275,000,000\",\n        \"$393,151,347\",\n    )\n    example_table.add_row(\n        \"Dec 15, 2017\",\n        \"Star Wars Ep. VIII: The Last Jedi\",\n        \"$262,000,000\",\n        \"[bold]$1,332,539,889[/bold]\",\n    )\n    example_table.add_row(\n        \"May 19, 1999\",\n        \"Star Wars Ep. [b]I[/b]: [i]The phantom Menace\",\n        \"$115,000,000\",\n        \"$1,027,044,677\",\n    )\n\n    table.add_row(\"Tables\", example_table)\n\n    code = '''\\\ndef iter_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    for value in iter_values:\n        yield False, previous_value\n        previous_value = value\n    yield True, previous_value'''\n\n    pretty_data = {\n        \"foo\": [\n            3.1427,\n            (\n                \"Paul Atreides\",\n                \"Vladimir Harkonnen\",\n                \"Thufir Hawat\",\n            ),\n        ],\n        \"atomic\": (False, True, None),\n    }\n    table.add_row(\n        \"Syntax\\nhighlighting\\n&\\npretty\\nprinting\",\n        comparison(\n            Syntax(code, \"python3\", line_numbers=True, indent_guides=True),\n            Pretty(pretty_data, indent_guides=True),\n        ),\n    )\n\n    markdown_example = \"\"\"\\\n# Markdown\n\nSupports much of the *markdown* __syntax__!\n\n- Headers\n- Basic formatting: **bold**, *italic*, `code`\n- Block quotes\n- Lists, and more...\n    \"\"\"\n    table.add_row(\n        \"Markdown\", comparison(\"[cyan]\" + markdown_example, Markdown(markdown_example))\n    )\n\n    table.add_row(\n        \"+more!\",\n        \"\"\"Progress bars, columns, styled logging handler, tracebacks, etc...\"\"\",\n    )\n    return table",
        "line_count": 168,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 19,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "range",
          "options.max_width",
          "colorsys.hls_to_rgb",
          "color",
          "h",
          "Color.from_rgb",
          "bgcolor",
          "Segment",
          "Style",
          "l"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        for y in range(0, 5):\n            for x in range(options.max_width):\n                h = x / options.max_width\n                l = 0.1 + ((y / 5) * 0.7)\n                r1, g1, b1 = colorsys.hls_to_rgb(h, l, 1.0)\n                r2, g2, b2 = colorsys.hls_to_rgb(h, l + 0.7 / 10, 1.0)\n                bgcolor = Color.from_rgb(r1 * 255, g1 * 255, b1 * 255)\n                color = Color.from_rgb(r2 * 255, g2 * 255, b2 * 255)\n                yield Segment(\"\u2584\", Style(color=color, bgcolor=bgcolor))\n            yield Segment.line()",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 33,
        "decorators": [],
        "is_async": false,
        "calls": [
          "options.max_width",
          "Measurement"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: ConsoleOptions\n    ) -> Measurement:\n        return Measurement(1, options.max_width)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "comparison",
        "args": [
          {
            "name": "renderable1",
            "type": "RenderableType"
          },
          {
            "name": "renderable2",
            "type": "RenderableType"
          }
        ],
        "return_type": "Table",
        "lineno": 90,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Table",
          "renderable2",
          "table.add_column",
          "table.add_row",
          "renderable1"
        ],
        "docstring": null,
        "code": "def comparison(renderable1: RenderableType, renderable2: RenderableType) -> Table:\n        table = Table(show_header=False, pad_edge=False, box=None, expand=True)\n        table.add_column(\"1\", ratio=1)\n        table.add_column(\"2\", ratio=1)\n        table.add_row(renderable1, renderable2)\n        return table",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ColorBox",
        "methods": [
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [],
        "lineno": 18,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "colorsys",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "time",
        "name": "process_time",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "box",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.color",
        "name": "Color",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Group",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.markdown",
        "name": "Markdown",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich.segment",
        "name": "Segment",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.style",
        "name": "Style",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "rich.syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 210,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "process_time",
      "round",
      "Console",
      "io.StringIO",
      "make_test_card",
      "Panel.fit",
      "c.print"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "process_time",
        "test_card",
        "round",
        "Console",
        "io.StringIO",
        "make_test_card",
        "Panel.fit",
        "c.print"
      ],
      "class_instantiations": [
        "Console",
        "Panel"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "io",
        "time"
      ],
      "third_party": {
        "other": [
          "colorsys",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 246
  },
  "rich/_cell_widths.py": {
    "filepath": "../rich/rich/_cell_widths.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [],
    "variables": [
      {
        "name": "CELL_WIDTHS",
        "assigned_to": null,
        "lineno": 3
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 455
  },
  "rich/_emoji_codes.py": {
    "filepath": "../rich/rich/_emoji_codes.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [],
    "variables": [
      {
        "name": "EMOJI",
        "assigned_to": null,
        "lineno": 1
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 3611
  },
  "rich/_emoji_replace.py": {
    "filepath": "../rich/rich/_emoji_replace.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_emoji_replace",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "default_variant",
            "type": "Optional[str]"
          },
          {
            "name": "_emoji_sub",
            "type": "_EmojiSubMethod"
          }
        ],
        "return_type": "str",
        "lineno": 12,
        "decorators": [],
        "is_async": false,
        "calls": [
          "do_replace",
          "default_variant_code",
          "emoji_name.lower",
          "EMOJI.__getitem__",
          "re.compile",
          "get_variant",
          "_emoji_sub",
          "text",
          "get_emoji",
          "default_variant",
          "variants.get",
          "match.groups",
          "variant"
        ],
        "docstring": "Replace emoji code in text.",
        "code": "def _emoji_replace(\n    text: str,\n    default_variant: Optional[str] = None,\n    _emoji_sub: _EmojiSubMethod = re.compile(r\"(:(\\S*?)(?:(?:\\-)(emoji|text))?:)\").sub,\n) -> str:\n    \"\"\"Replace emoji code in text.\"\"\"\n    get_emoji = EMOJI.__getitem__\n    variants = {\"text\": \"\\uFE0E\", \"emoji\": \"\\uFE0F\"}\n    get_variant = variants.get\n    default_variant_code = variants.get(default_variant, \"\") if default_variant else \"\"\n\n    def do_replace(match: Match[str]) -> str:\n        emoji_code, emoji_name, variant = match.groups()\n        try:\n            return get_emoji(emoji_name.lower()) + get_variant(\n                variant, default_variant_code\n            )\n        except KeyError:\n            return emoji_code\n\n    return _emoji_sub(do_replace, text)",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "do_replace",
        "args": [
          {
            "name": "match",
            "type": "Match[str]"
          }
        ],
        "return_type": "str",
        "lineno": 23,
        "decorators": [],
        "is_async": false,
        "calls": [
          "default_variant_code",
          "emoji_name.lower",
          "get_variant",
          "get_emoji",
          "match.groups",
          "variant"
        ],
        "docstring": null,
        "code": "def do_replace(match: Match[str]) -> str:\n        emoji_code, emoji_name, variant = match.groups()\n        try:\n            return get_emoji(emoji_name.lower()) + get_variant(\n                variant, default_variant_code\n            )\n        except KeyError:\n            return emoji_code",
        "line_count": 8,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Match",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "re",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "_emoji_codes",
        "name": "EMOJI",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "_ReStringMatch",
        "assigned_to": null,
        "lineno": 7
      },
      {
        "name": "_ReSubCallable",
        "assigned_to": null,
        "lineno": 8
      },
      {
        "name": "_EmojiSubMethod",
        "assigned_to": null,
        "lineno": 9
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "re",
        "typing"
      ],
      "third_party": {
        "other": [
          "_emoji_codes"
        ]
      },
      "tech_stack": []
    },
    "line_count": 33
  },
  "rich/_export_format.py": {
    "filepath": "../rich/rich/_export_format.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [],
    "variables": [
      {
        "name": "CONSOLE_HTML_FORMAT",
        "assigned_to": "str",
        "lineno": 1
      },
      {
        "name": "CONSOLE_SVG_FORMAT",
        "assigned_to": "str",
        "lineno": 20
      },
      {
        "name": "_SVG_FONT_FAMILY",
        "assigned_to": "str",
        "lineno": 75
      },
      {
        "name": "_SVG_CLASSES_PREFIX",
        "assigned_to": "str",
        "lineno": 76
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 77
  },
  "rich/_extension.py": {
    "filepath": "../rich/rich/_extension.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "load_ipython_extension",
        "args": [
          {
            "name": "ip",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 4,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tr_install",
          "install"
        ],
        "docstring": null,
        "code": "def load_ipython_extension(ip: Any) -> None:  # pragma: no cover\n    # prevent circular import\n    from rich.pretty import install\n    from rich.traceback import install as tr_install\n\n    install()\n    tr_install()",
        "line_count": 7,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.pretty",
        "name": "install",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich.traceback",
        "name": "install",
        "alias": "tr_install",
        "lineno": 7,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 11
  },
  "rich/_fileno.py": {
    "filepath": "../rich/rich/_fileno.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "get_fileno",
        "args": [
          {
            "name": "file_like",
            "type": "IO[str]"
          }
        ],
        "return_type": "Any",
        "lineno": 6,
        "decorators": [],
        "is_async": false,
        "calls": [
          "getattr",
          "file_like",
          "fileno"
        ],
        "docstring": "Get fileno() from a file, accounting for poorly implemented file-like objects.\n\nArgs:\n    file_like (IO): A file-like object.\n\nReturns:\n    int | None: The result of fileno if available, or None if operation failed.",
        "code": "def get_fileno(file_like: IO[str]) -> int | None:\n    \"\"\"Get fileno() from a file, accounting for poorly implemented file-like objects.\n\n    Args:\n        file_like (IO): A file-like object.\n\n    Returns:\n        int | None: The result of fileno if available, or None if operation failed.\n    \"\"\"\n    fileno: Callable[[], int] | None = getattr(file_like, \"fileno\", None)\n    if fileno is not None:\n        try:\n            return fileno()\n        except Exception:\n            # `fileno` is documented as potentially raising a OSError\n            # Alas, from the issues, there are so many poorly implemented file-like objects,\n            # that `fileno()` can raise just about anything.\n            return None\n    return None",
        "line_count": 19,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "IO",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "__future__"
        ]
      },
      "tech_stack": []
    },
    "line_count": 25
  },
  "rich/_inspect.py": {
    "filepath": "../rich/rich/_inspect.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_first_paragraph",
        "args": [
          {
            "name": "doc",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 15,
        "decorators": [],
        "is_async": false,
        "calls": [
          "doc.partition"
        ],
        "docstring": "Get the first paragraph from a docstring.",
        "code": "def _first_paragraph(doc: str) -> str:\n    \"\"\"Get the first paragraph from a docstring.\"\"\"\n    paragraph, _, _ = doc.partition(\"\\n\\n\")\n    return paragraph",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "get_object_types_mro",
        "args": [
          {
            "name": "obj",
            "type": "Union[object, Type[Any]]"
          }
        ],
        "return_type": "Tuple[type, Ellipsis]",
        "lineno": 236,
        "decorators": [],
        "is_async": false,
        "calls": [
          "type",
          "getattr",
          "hasattr",
          "obj"
        ],
        "docstring": "Returns the MRO of an object's class, or of the object itself if it's a class.",
        "code": "def get_object_types_mro(obj: Union[object, Type[Any]]) -> Tuple[type, ...]:\n    \"\"\"Returns the MRO of an object's class, or of the object itself if it's a class.\"\"\"\n    if not hasattr(obj, \"__mro__\"):\n        # N.B. we cannot use `if type(obj) is type` here because it doesn't work with\n        # some types of classes, such as the ones that use abc.ABCMeta.\n        obj = type(obj)\n    return getattr(obj, \"__mro__\", ())",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "get_object_types_mro_as_strings",
        "args": [
          {
            "name": "obj",
            "type": "object"
          }
        ],
        "return_type": "Collection[str]",
        "lineno": 245,
        "decorators": [],
        "is_async": false,
        "calls": [
          "type_",
          "get_object_types_mro",
          "obj",
          "getattr"
        ],
        "docstring": "Returns the MRO of an object's class as full qualified names, or of the object itself if it's a class.\n\nExamples:\n    `object_types_mro_as_strings(JSONDecoder)` will return `['json.decoder.JSONDecoder', 'builtins.object']`",
        "code": "def get_object_types_mro_as_strings(obj: object) -> Collection[str]:\n    \"\"\"\n    Returns the MRO of an object's class as full qualified names, or of the object itself if it's a class.\n\n    Examples:\n        `object_types_mro_as_strings(JSONDecoder)` will return `['json.decoder.JSONDecoder', 'builtins.object']`\n    \"\"\"\n    return [\n        f'{getattr(type_, \"__module__\", \"\")}.{getattr(type_, \"__qualname__\", \"\")}'\n        for type_ in get_object_types_mro(obj)\n    ]",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "is_object_one_of_types",
        "args": [
          {
            "name": "obj",
            "type": "object"
          },
          {
            "name": "fully_qualified_types_names",
            "type": "Collection[str]"
          }
        ],
        "return_type": "bool",
        "lineno": 258,
        "decorators": [],
        "is_async": false,
        "calls": [
          "get_object_types_mro_as_strings",
          "obj"
        ],
        "docstring": "Returns `True` if the given object's class (or the object itself, if it's a class) has one of the\nfully qualified names in its MRO.",
        "code": "def is_object_one_of_types(\n    obj: object, fully_qualified_types_names: Collection[str]\n) -> bool:\n    \"\"\"\n    Returns `True` if the given object's class (or the object itself, if it's a class) has one of the\n    fully qualified names in its MRO.\n    \"\"\"\n    for type_name in get_object_types_mro_as_strings(obj):\n        if type_name in fully_qualified_types_names:\n            return True\n    return False",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 37,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sort",
          "value",
          "obj",
          "dunder",
          "help",
          "self._make_title",
          "methods",
          "ReprHighlighter"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        obj: Any,\n        *,\n        title: Optional[TextType] = None,\n        help: bool = False,\n        methods: bool = False,\n        docs: bool = True,\n        private: bool = False,\n        dunder: bool = False,\n        sort: bool = True,\n        all: bool = True,\n        value: bool = True,\n    ) -> None:\n        self.highlighter = ReprHighlighter()\n        self.obj = obj\n        self.title = title or self._make_title(obj)\n        if all:\n            methods = private = dunder = True\n        self.help = help\n        self.methods = methods\n        self.docs = docs or help\n        self.private = private or dunder\n        self.dunder = dunder\n        self.sort = sort\n        self.value = value",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "_make_title",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "Text",
        "lineno": 64,
        "decorators": [],
        "is_async": false,
        "calls": [
          "callable",
          "str",
          "obj",
          "isclass",
          "ismodule",
          "self.highlighter",
          "type",
          "title_str"
        ],
        "docstring": "Make a default title.",
        "code": "def _make_title(self, obj: Any) -> Text:\n        \"\"\"Make a default title.\"\"\"\n        title_str = (\n            str(obj)\n            if (isclass(obj) or callable(obj) or ismodule(obj))\n            else str(type(obj))\n        )\n        title_text = self.highlighter(title_str)\n        return title_text",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Panel",
        "lineno": 74,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Group",
          "self.title",
          "Panel.fit",
          "self._render"
        ],
        "docstring": null,
        "code": "def __rich__(self) -> Panel:\n        return Panel.fit(\n            Group(*self._render()),\n            title=self.title,\n            border_style=\"scope.border\",\n            padding=(0, 1),\n        )",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_get_signature",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "Optional[Text]",
        "lineno": 82,
        "decorators": [],
        "is_async": false,
        "calls": [
          "inspect.isclass",
          "prefix.replace",
          "getattr",
          "str",
          "obj",
          "name",
          "inspect.iscoroutinefunction",
          "_signature",
          "self.highlighter",
          "Text.assemble",
          "signature",
          "getfile",
          "callable_name.stylize",
          "signature_text",
          "Text"
        ],
        "docstring": "Get a signature for a callable.",
        "code": "def _get_signature(self, name: str, obj: Any) -> Optional[Text]:\n        \"\"\"Get a signature for a callable.\"\"\"\n        try:\n            _signature = str(signature(obj)) + \":\"\n        except ValueError:\n            _signature = \"(...)\"\n        except TypeError:\n            return None\n\n        source_filename: Optional[str] = None\n        try:\n            source_filename = getfile(obj)\n        except (OSError, TypeError):\n            # OSError is raised if obj has no source file, e.g. when defined in REPL.\n            pass\n\n        callable_name = Text(name, style=\"inspect.callable\")\n        if source_filename:\n            callable_name.stylize(f\"link file://{source_filename}\")\n        signature_text = self.highlighter(_signature)\n\n        qualname = name or getattr(obj, \"__qualname__\", name)\n\n        # If obj is a module, there may be classes (which are callable) to display\n        if inspect.isclass(obj):\n            prefix = \"class\"\n        elif inspect.iscoroutinefunction(obj):\n            prefix = \"async def\"\n        else:\n            prefix = \"def\"\n\n        qual_signature = Text.assemble(\n            (f\"{prefix} \", f\"inspect.{prefix.replace(' ', '_')}\"),\n            (qualname, \"inspect.callable\"),\n            signature_text,\n        )\n\n        return qual_signature",
        "line_count": 38,
        "needs_llm_summary": true
      },
      {
        "name": "_render",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Iterable[RenderableType]",
        "lineno": 121,
        "decorators": [],
        "is_async": false,
        "calls": [
          "callable",
          "highlighter",
          "keys",
          "docs",
          "Panel",
          "Table.grid",
          "key_text.copy",
          "key",
          "warning",
          "_doc",
          "unknown.lower",
          "Text.from_markup",
          "add_row",
          "self._get_signature",
          "dir",
          "items.sort",
          "_signature_text",
          "Text",
          "items_table.add_column",
          "key.startswith",
          "doc.stylize",
          "value",
          "self.obj",
          "key.strip",
          "item",
          "_signature_text.append",
          "self.highlighter",
          "len",
          "items_table.add_row",
          "sort_items",
          "safe_getattr",
          "getattr",
          "error",
          "obj",
          "self._get_formatted_doc",
          "Pretty",
          "key_text",
          "isclass",
          "warning.stylize",
          "ismodule",
          "attr_name",
          "doc",
          "doc_text",
          "Text.assemble",
          "repr"
        ],
        "docstring": "Render object.",
        "code": "def _render(self) -> Iterable[RenderableType]:\n        \"\"\"Render object.\"\"\"\n\n        def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:\n            key, (_error, value) = item\n            return (callable(value), key.strip(\"_\").lower())\n\n        def safe_getattr(attr_name: str) -> Tuple[Any, Any]:\n            \"\"\"Get attribute or any exception.\"\"\"\n            try:\n                return (None, getattr(obj, attr_name))\n            except Exception as error:\n                return (error, None)\n\n        obj = self.obj\n        keys = dir(obj)\n        total_items = len(keys)\n        if not self.dunder:\n            keys = [key for key in keys if not key.startswith(\"__\")]\n        if not self.private:\n            keys = [key for key in keys if not key.startswith(\"_\")]\n        not_shown_count = total_items - len(keys)\n        items = [(key, safe_getattr(key)) for key in keys]\n        if self.sort:\n            items.sort(key=sort_items)\n\n        items_table = Table.grid(padding=(0, 1), expand=False)\n        items_table.add_column(justify=\"right\")\n        add_row = items_table.add_row\n        highlighter = self.highlighter\n\n        if callable(obj):\n            signature = self._get_signature(\"\", obj)\n            if signature is not None:\n                yield signature\n                yield \"\"\n\n        if self.docs:\n            _doc = self._get_formatted_doc(obj)\n            if _doc is not None:\n                doc_text = Text(_doc, style=\"inspect.help\")\n                doc_text = highlighter(doc_text)\n                yield doc_text\n                yield \"\"\n\n        if self.value and not (isclass(obj) or callable(obj) or ismodule(obj)):\n            yield Panel(\n                Pretty(obj, indent_guides=True, max_length=10, max_string=60),\n                border_style=\"inspect.value.border\",\n            )\n            yield \"\"\n\n        for key, (error, value) in items:\n            key_text = Text.assemble(\n                (\n                    key,\n                    \"inspect.attr.dunder\" if key.startswith(\"__\") else \"inspect.attr\",\n                ),\n                (\" =\", \"inspect.equals\"),\n            )\n            if error is not None:\n                warning = key_text.copy()\n                warning.stylize(\"inspect.error\")\n                add_row(warning, highlighter(repr(error)))\n                continue\n\n            if callable(value):\n                if not self.methods:\n                    continue\n\n                _signature_text = self._get_signature(key, value)\n                if _signature_text is None:\n                    add_row(key_text, Pretty(value, highlighter=highlighter))\n                else:\n                    if self.docs:\n                        docs = self._get_formatted_doc(value)\n                        if docs is not None:\n                            _signature_text.append(\"\\n\" if \"\\n\" in docs else \" \")\n                            doc = highlighter(docs)\n                            doc.stylize(\"inspect.doc\")\n                            _signature_text.append(doc)\n\n                    add_row(key_text, _signature_text)\n            else:\n                add_row(key_text, Pretty(value, highlighter=highlighter))\n        if items_table.row_count:\n            yield items_table\n        elif not_shown_count:\n            yield Text.from_markup(\n                f\"[b cyan]{not_shown_count}[/][i] attribute(s) not shown.[/i] \"\n                f\"Run [b][magenta]inspect[/]([not b]inspect[/])[/b] for options.\"\n            )",
        "line_count": 92,
        "needs_llm_summary": true
      },
      {
        "name": "_get_formatted_doc",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "object_",
            "type": "Any"
          }
        ],
        "return_type": "Optional[str]",
        "lineno": 214,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.strip",
          "getdoc",
          "docs",
          "_first_paragraph",
          "cleandoc",
          "escape_control_codes",
          "object_"
        ],
        "docstring": "Extract the docstring of an object, process it and returns it.\nThe processing consists in cleaning up the docstring's indentation,\ntaking only its 1st paragraph if `self.help` is not True,\nand escape its control codes.\n\nArgs:\n    object_ (Any): the object to get the docstring from.\n\nReturns:\n    Optional[str]: the processed docstring, or None if no docstring was found.",
        "code": "def _get_formatted_doc(self, object_: Any) -> Optional[str]:\n        \"\"\"\n        Extract the docstring of an object, process it and returns it.\n        The processing consists in cleaning up the docstring's indentation,\n        taking only its 1st paragraph if `self.help` is not True,\n        and escape its control codes.\n\n        Args:\n            object_ (Any): the object to get the docstring from.\n\n        Returns:\n            Optional[str]: the processed docstring, or None if no docstring was found.\n        \"\"\"\n        docs = getdoc(object_)\n        if docs is None:\n            return None\n        docs = cleandoc(docs).strip()\n        if not self.help:\n            docs = _first_paragraph(docs)\n        return escape_control_codes(docs)",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "sort_items",
        "args": [
          {
            "name": "item",
            "type": "Tuple[str, Any]"
          }
        ],
        "return_type": "Tuple[bool, str]",
        "lineno": 124,
        "decorators": [],
        "is_async": false,
        "calls": [
          "callable",
          "value",
          "key.strip",
          "item",
          "unknown.lower"
        ],
        "docstring": null,
        "code": "def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:\n            key, (_error, value) = item\n            return (callable(value), key.strip(\"_\").lower())",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "safe_getattr",
        "args": [
          {
            "name": "attr_name",
            "type": "str"
          }
        ],
        "return_type": "Tuple[Any, Any]",
        "lineno": 128,
        "decorators": [],
        "is_async": false,
        "calls": [
          "getattr",
          "attr_name",
          "obj"
        ],
        "docstring": "Get attribute or any exception.",
        "code": "def safe_getattr(attr_name: str) -> Tuple[Any, Any]:\n            \"\"\"Get attribute or any exception.\"\"\"\n            try:\n                return (None, getattr(obj, attr_name))\n            except Exception as error:\n                return (error, None)",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Inspect",
        "methods": [
          "__init__",
          "_make_title",
          "__rich__",
          "_get_signature",
          "_render",
          "_get_formatted_doc"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 21,
        "docstring": "A renderable to inspect any Python Object.\n\nArgs:\n    obj (Any): An object to inspect.\n    title (str, optional): Title to display over inspect result, or None use type. Defaults to None.\n    help (bool, optional): Show full help text rather than just first paragraph. Defaults to False.\n    methods (bool, optional): Enable inspection of callables. Defaults to False.\n    docs (bool, optional): Also render doc strings. Defaults to True.\n    private (bool, optional): Show private attributes (beginning with underscore). Defaults to False.\n    dunder (bool, optional): Show attributes starting with double underscore. Defaults to False.\n    sort (bool, optional): Sort attributes alphabetically. Defaults to True.\n    all (bool, optional): Show all attributes. Defaults to False.\n    value (bool, optional): Pretty print value of object. Defaults to True."
      }
    ],
    "imports": [
      {
        "module": "inspect",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "inspect",
        "name": "cleandoc",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "name": "getdoc",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "name": "getfile",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "name": "isclass",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "name": "ismodule",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "name": "signature",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Collection",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Group",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "control",
        "name": "escape_control_codes",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "panel",
        "name": "Panel",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "inspect",
          "console",
          "control",
          "highlighter",
          "jupyter",
          "panel",
          "pretty",
          "table",
          "text"
        ]
      },
      "tech_stack": []
    },
    "line_count": 269
  },
  "rich/_log_render.py": {
    "filepath": "../rich/rich/_log_render.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "show_time",
            "type": "bool"
          },
          {
            "name": "show_level",
            "type": "bool"
          },
          {
            "name": "show_path",
            "type": "bool"
          },
          {
            "name": "time_format",
            "type": "Union[str, FormatTimeCallable]"
          },
          {
            "name": "omit_repeated_times",
            "type": "bool"
          },
          {
            "name": "level_width",
            "type": "Optional[int]"
          }
        ],
        "return_type": "None",
        "lineno": 15,
        "decorators": [],
        "is_async": false,
        "calls": [
          "show_path",
          "level_width",
          "time_format",
          "show_level",
          "omit_repeated_times",
          "show_time"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        show_time: bool = True,\n        show_level: bool = False,\n        show_path: bool = True,\n        time_format: Union[str, FormatTimeCallable] = \"[%x %X]\",\n        omit_repeated_times: bool = True,\n        level_width: Optional[int] = 8,\n    ) -> None:\n        self.show_time = show_time\n        self.show_level = show_level\n        self.show_path = show_path\n        self.time_format = time_format\n        self.omit_repeated_times = omit_repeated_times\n        self.level_width = level_width\n        self._last_time: Optional[Text] = None",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "renderables",
            "type": "Iterable[ConsoleRenderable]"
          },
          {
            "name": "log_time",
            "type": "Optional[datetime]"
          },
          {
            "name": "time_format",
            "type": "Optional[Union[str, FormatTimeCallable]]"
          },
          {
            "name": "level",
            "type": "TextType"
          },
          {
            "name": "path",
            "type": "Optional[str]"
          },
          {
            "name": "line_no",
            "type": "Optional[int]"
          },
          {
            "name": "link_path",
            "type": "Optional[str]"
          }
        ],
        "return_type": "Table",
        "lineno": 32,
        "decorators": [],
        "is_async": false,
        "calls": [
          "callable",
          "level",
          "Table.grid",
          "log_time.strftime",
          "log_time",
          "time_format",
          "Text",
          "console.get_datetime",
          "Renderables",
          "row.append",
          "output.add_column",
          "len",
          "self.level_width",
          "path_text",
          "output.add_row",
          "log_time_display",
          "path",
          "path_text.append",
          "renderables"
        ],
        "docstring": null,
        "code": "def __call__(\n        self,\n        console: \"Console\",\n        renderables: Iterable[\"ConsoleRenderable\"],\n        log_time: Optional[datetime] = None,\n        time_format: Optional[Union[str, FormatTimeCallable]] = None,\n        level: TextType = \"\",\n        path: Optional[str] = None,\n        line_no: Optional[int] = None,\n        link_path: Optional[str] = None,\n    ) -> \"Table\":\n        from .containers import Renderables\n        from .table import Table\n\n        output = Table.grid(padding=(0, 1))\n        output.expand = True\n        if self.show_time:\n            output.add_column(style=\"log.time\")\n        if self.show_level:\n            output.add_column(style=\"log.level\", width=self.level_width)\n        output.add_column(ratio=1, style=\"log.message\", overflow=\"fold\")\n        if self.show_path and path:\n            output.add_column(style=\"log.path\")\n        row: List[\"RenderableType\"] = []\n        if self.show_time:\n            log_time = log_time or console.get_datetime()\n            time_format = time_format or self.time_format\n            if callable(time_format):\n                log_time_display = time_format(log_time)\n            else:\n                log_time_display = Text(log_time.strftime(time_format))\n            if log_time_display == self._last_time and self.omit_repeated_times:\n                row.append(Text(\" \" * len(log_time_display)))\n            else:\n                row.append(log_time_display)\n                self._last_time = log_time_display\n        if self.show_level:\n            row.append(level)\n\n        row.append(Renderables(renderables))\n        if self.show_path and path:\n            path_text = Text()\n            path_text.append(\n                path, style=f\"link file://{link_path}\" if link_path else \"\"\n            )\n            if line_no:\n                path_text.append(\":\")\n                path_text.append(\n                    f\"{line_no}\",\n                    style=f\"link file://{link_path}#{line_no}\" if link_path else \"\",\n                )\n            row.append(path_text)\n\n        output.add_row(*row)\n        return output",
        "line_count": 55,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "LogRender",
        "methods": [
          "__init__",
          "__call__"
        ],
        "base_classes": [],
        "lineno": 14,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "datetime",
        "name": "datetime",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleRenderable",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 90,
        "type": "from_import"
      },
      {
        "module": "containers",
        "name": "Renderables",
        "alias": null,
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "FormatTimeCallable",
        "assigned_to": null,
        "lineno": 11
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "Console",
      "c.log",
      "c.print"
    ],
    "module_level_calls": {
      "function_calls": [
        "Console",
        "c.log",
        "c.print"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "datetime",
        "typing"
      ],
      "third_party": {
        "other": [
          "text",
          "console",
          "table",
          "rich",
          "containers"
        ]
      },
      "tech_stack": []
    },
    "line_count": 95
  },
  "rich/_loop.py": {
    "filepath": "../rich/rich/_loop.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "loop_first",
        "args": [
          {
            "name": "values",
            "type": "Iterable[T]"
          }
        ],
        "return_type": "Iterable[Tuple[bool, T]]",
        "lineno": 6,
        "decorators": [],
        "is_async": false,
        "calls": [
          "values",
          "next",
          "iter_values",
          "iter"
        ],
        "docstring": "Iterate and generate a tuple with a flag for first value.",
        "code": "def loop_first(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first value.\"\"\"\n    iter_values = iter(values)\n    try:\n        value = next(iter_values)\n    except StopIteration:\n        return\n    yield True, value\n    for value in iter_values:\n        yield False, value",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "loop_last",
        "args": [
          {
            "name": "values",
            "type": "Iterable[T]"
          }
        ],
        "return_type": "Iterable[Tuple[bool, T]]",
        "lineno": 18,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value",
          "next",
          "iter",
          "values",
          "iter_values"
        ],
        "docstring": "Iterate and generate a tuple with a flag for last value.",
        "code": "def loop_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    for value in iter_values:\n        yield False, previous_value\n        previous_value = value\n    yield True, previous_value",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "loop_first_last",
        "args": [
          {
            "name": "values",
            "type": "Iterable[T]"
          }
        ],
        "return_type": "Iterable[Tuple[bool, bool, T]]",
        "lineno": 31,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value",
          "next",
          "iter",
          "values",
          "iter_values"
        ],
        "docstring": "Iterate and generate a tuple with a flag for first and last value.",
        "code": "def loop_first_last(values: Iterable[T]) -> Iterable[Tuple[bool, bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first and last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    first = True\n    for value in iter_values:\n        yield first, False, previous_value\n        first = False\n        previous_value = value\n    yield first, True, previous_value",
        "line_count": 13,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TypeVar",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "T",
        "assigned_to": "TypeVar",
        "lineno": 3
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "TypeVar"
      ],
      "class_instantiations": [
        "TypeVar"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 44
  },
  "rich/_null_file.py": {
    "filepath": "../rich/rich/_null_file.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "close",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 6,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def close(self) -> None:\n        pass",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "isatty",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 9,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def isatty(self) -> bool:\n        return False",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "read",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__n",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 12,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def read(self, __n: int = 1) -> str:\n        return \"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "readable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 15,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def readable(self) -> bool:\n        return False",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "readline",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__limit",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 18,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def readline(self, __limit: int = 1) -> str:\n        return \"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "readlines",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__hint",
            "type": "int"
          }
        ],
        "return_type": "List[str]",
        "lineno": 21,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def readlines(self, __hint: int = 1) -> List[str]:\n        return []",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "seek",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__offset",
            "type": "int"
          },
          {
            "name": "__whence",
            "type": "int"
          }
        ],
        "return_type": "int",
        "lineno": 24,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def seek(self, __offset: int, __whence: int = 1) -> int:\n        return 0",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "seekable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 27,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def seekable(self) -> bool:\n        return False",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "tell",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 30,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def tell(self) -> int:\n        return 0",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "truncate",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__size",
            "type": "Optional[int]"
          }
        ],
        "return_type": "int",
        "lineno": 33,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def truncate(self, __size: Optional[int] = 1) -> int:\n        return 0",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "writable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 36,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def writable(self) -> bool:\n        return False",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "writelines",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__lines",
            "type": "Iterable[str]"
          }
        ],
        "return_type": "None",
        "lineno": 39,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def writelines(self, __lines: Iterable[str]) -> None:\n        pass",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__next__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 42,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __next__(self) -> str:\n        return \"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__iter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Iterator[str]",
        "lineno": 45,
        "decorators": [],
        "is_async": false,
        "calls": [
          "iter"
        ],
        "docstring": null,
        "code": "def __iter__(self) -> Iterator[str]:\n        return iter([\"\"])",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "IO[str]",
        "lineno": 48,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __enter__(self) -> IO[str]:\n        return self",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "__t",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "__value",
            "type": "Optional[BaseException]"
          },
          {
            "name": "__traceback",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 51,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        __t: Optional[Type[BaseException]],\n        __value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> None:\n        pass",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "write",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "int",
        "lineno": 59,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def write(self, text: str) -> int:\n        return 0",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "flush",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 62,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def flush(self) -> None:\n        pass",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "fileno",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 65,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def fileno(self) -> int:\n        return -1",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "NullFile",
        "methods": [
          "close",
          "isatty",
          "read",
          "readable",
          "readline",
          "readlines",
          "seek",
          "seekable",
          "tell",
          "truncate",
          "writable",
          "writelines",
          "__next__",
          "__iter__",
          "__enter__",
          "__exit__",
          "write",
          "flush",
          "fileno"
        ],
        "base_classes": [
          "unknown"
        ],
        "lineno": 5,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "IO",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterator",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "NULL_FILE",
        "assigned_to": "NullFile",
        "lineno": 69
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "NullFile"
      ],
      "class_instantiations": [
        "NullFile"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "types"
        ]
      },
      "tech_stack": []
    },
    "line_count": 70
  },
  "rich/_palettes.py": {
    "filepath": "../rich/rich/_palettes.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "palette",
        "name": "Palette",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "WINDOWS_PALETTE",
        "assigned_to": "Palette",
        "lineno": 5
      },
      {
        "name": "STANDARD_PALETTE",
        "assigned_to": "Palette",
        "lineno": 27
      },
      {
        "name": "EIGHT_BIT_PALETTE",
        "assigned_to": "Palette",
        "lineno": 50
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Palette"
      ],
      "class_instantiations": [
        "Palette"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "palette"
        ]
      },
      "tech_stack": []
    },
    "line_count": 310
  },
  "rich/_pick.py": {
    "filepath": "../rich/rich/_pick.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "pick_bool",
        "args": [],
        "return_type": "bool",
        "lineno": 4,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "value"
        ],
        "docstring": "Pick the first non-none bool or return the last value.\n\nArgs:\n    *values (bool): Any number of boolean or None values.\n\nReturns:\n    bool: First non-none boolean.",
        "code": "def pick_bool(*values: Optional[bool]) -> bool:\n    \"\"\"Pick the first non-none bool or return the last value.\n\n    Args:\n        *values (bool): Any number of boolean or None values.\n\n    Returns:\n        bool: First non-none boolean.\n    \"\"\"\n    assert values, \"1 or more values required\"\n    for value in values:\n        if value is not None:\n            return value\n    return bool(value)",
        "line_count": 14,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 18
  },
  "rich/_ratio.py": {
    "filepath": "../rich/rich/_ratio.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "ratio_resolve",
        "args": [
          {
            "name": "total",
            "type": "int"
          },
          {
            "name": "edges",
            "type": "Sequence[Edge]"
          }
        ],
        "return_type": "List[int]",
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sizes",
          "sum",
          "enumerate",
          "divmod",
          "edges",
          "Fraction",
          "edge.minimum_size",
          "cast",
          "remaining",
          "size",
          "_Fraction",
          "zip"
        ],
        "docstring": "Divide total space to satisfy size, ratio, and minimum_size, constraints.\n\nThe returned list of integers should add up to total in most cases, unless it is\nimpossible to satisfy all the constraints. For instance, if there are two edges\nwith a minimum size of 20 each and `total` is 30 then the returned list will be\ngreater than total. In practice, this would mean that a Layout object would\nclip the rows that would overflow the screen height.\n\nArgs:\n    total (int): Total number of characters.\n    edges (List[Edge]): Edges within total space.\n\nReturns:\n    List[int]: Number of characters for each edge.",
        "code": "def ratio_resolve(total: int, edges: Sequence[Edge]) -> List[int]:\n    \"\"\"Divide total space to satisfy size, ratio, and minimum_size, constraints.\n\n    The returned list of integers should add up to total in most cases, unless it is\n    impossible to satisfy all the constraints. For instance, if there are two edges\n    with a minimum size of 20 each and `total` is 30 then the returned list will be\n    greater than total. In practice, this would mean that a Layout object would\n    clip the rows that would overflow the screen height.\n\n    Args:\n        total (int): Total number of characters.\n        edges (List[Edge]): Edges within total space.\n\n    Returns:\n        List[int]: Number of characters for each edge.\n    \"\"\"\n    # Size of edge or None for yet to be determined\n    sizes = [(edge.size or None) for edge in edges]\n\n    _Fraction = Fraction\n\n    # While any edges haven't been calculated\n    while None in sizes:\n        # Get flexible edges and index to map these back on to sizes list\n        flexible_edges = [\n            (index, edge)\n            for index, (size, edge) in enumerate(zip(sizes, edges))\n            if size is None\n        ]\n        # Remaining space in total\n        remaining = total - sum(size or 0 for size in sizes)\n        if remaining <= 0:\n            # No room for flexible edges\n            return [\n                ((edge.minimum_size or 1) if size is None else size)\n                for size, edge in zip(sizes, edges)\n            ]\n        # Calculate number of characters in a ratio portion\n        portion = _Fraction(\n            remaining, sum((edge.ratio or 1) for _, edge in flexible_edges)\n        )\n\n        # If any edges will be less than their minimum, replace size with the minimum\n        for index, edge in flexible_edges:\n            if portion * edge.ratio <= edge.minimum_size:\n                sizes[index] = edge.minimum_size\n                # New fixed size will invalidate calculations, so we need to repeat the process\n                break\n        else:\n            # Distribute flexible space and compensate for rounding error\n            # Since edge sizes can only be integers we need to add the remainder\n            # to the following line\n            remainder = _Fraction(0)\n            for index, edge in flexible_edges:\n                size, remainder = divmod(portion * edge.ratio + remainder, 1)\n                sizes[index] = size\n            break\n    # Sizes now contains integers only\n    return cast(List[int], sizes)",
        "line_count": 59,
        "needs_llm_summary": true
      },
      {
        "name": "ratio_reduce",
        "args": [
          {
            "name": "total",
            "type": "int"
          },
          {
            "name": "ratios",
            "type": "List[int]"
          },
          {
            "name": "maximums",
            "type": "List[int]"
          },
          {
            "name": "values",
            "type": "List[int]"
          }
        ],
        "return_type": "List[int]",
        "lineno": 75,
        "decorators": [],
        "is_async": false,
        "calls": [
          "total",
          "min",
          "sum",
          "append",
          "value",
          "round",
          "result.append",
          "values",
          "ratios",
          "maximum",
          "zip",
          "maximums"
        ],
        "docstring": "Divide an integer total in to parts based on ratios.\n\nArgs:\n    total (int): The total to divide.\n    ratios (List[int]): A list of integer ratios.\n    maximums (List[int]): List of maximums values for each slot.\n    values (List[int]): List of values\n\nReturns:\n    List[int]: A list of integers guaranteed to sum to total.",
        "code": "def ratio_reduce(\n    total: int, ratios: List[int], maximums: List[int], values: List[int]\n) -> List[int]:\n    \"\"\"Divide an integer total in to parts based on ratios.\n\n    Args:\n        total (int): The total to divide.\n        ratios (List[int]): A list of integer ratios.\n        maximums (List[int]): List of maximums values for each slot.\n        values (List[int]): List of values\n\n    Returns:\n        List[int]: A list of integers guaranteed to sum to total.\n    \"\"\"\n    ratios = [ratio if _max else 0 for ratio, _max in zip(ratios, maximums)]\n    total_ratio = sum(ratios)\n    if not total_ratio:\n        return values[:]\n    total_remaining = total\n    result: List[int] = []\n    append = result.append\n    for ratio, maximum, value in zip(ratios, maximums, values):\n        if ratio and total_ratio > 0:\n            distributed = min(maximum, round(ratio * total_remaining / total_ratio))\n            append(value - distributed)\n            total_remaining -= distributed\n            total_ratio -= ratio\n        else:\n            append(value)\n    return result",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "ratio_distribute",
        "args": [
          {
            "name": "total",
            "type": "int"
          },
          {
            "name": "ratios",
            "type": "List[int]"
          },
          {
            "name": "minimums",
            "type": "Optional[List[int]]"
          }
        ],
        "return_type": "List[int]",
        "lineno": 107,
        "decorators": [],
        "is_async": false,
        "calls": [
          "total",
          "max",
          "sum",
          "minimum",
          "append",
          "_minimums",
          "distributed",
          "total_remaining",
          "ratios",
          "ceil",
          "minimums",
          "zip",
          "len",
          "distributed_total.append"
        ],
        "docstring": "Distribute an integer total in to parts based on ratios.\n\nArgs:\n    total (int): The total to divide.\n    ratios (List[int]): A list of integer ratios.\n    minimums (List[int]): List of minimum values for each slot.\n\nReturns:\n    List[int]: A list of integers guaranteed to sum to total.",
        "code": "def ratio_distribute(\n    total: int, ratios: List[int], minimums: Optional[List[int]] = None\n) -> List[int]:\n    \"\"\"Distribute an integer total in to parts based on ratios.\n\n    Args:\n        total (int): The total to divide.\n        ratios (List[int]): A list of integer ratios.\n        minimums (List[int]): List of minimum values for each slot.\n\n    Returns:\n        List[int]: A list of integers guaranteed to sum to total.\n    \"\"\"\n    if minimums:\n        ratios = [ratio if _min else 0 for ratio, _min in zip(ratios, minimums)]\n    total_ratio = sum(ratios)\n    assert total_ratio > 0, \"Sum of ratios must be > 0\"\n\n    total_remaining = total\n    distributed_total: List[int] = []\n    append = distributed_total.append\n    if minimums is None:\n        _minimums = [0] * len(ratios)\n    else:\n        _minimums = minimums\n    for ratio, minimum in zip(ratios, _minimums):\n        if total_ratio > 0:\n            distributed = max(minimum, ceil(ratio * total_remaining / total_ratio))\n        else:\n            distributed = total_remaining\n        append(distributed)\n        total_ratio -= ratio\n        total_remaining -= distributed\n    return distributed_total",
        "line_count": 34,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Edge",
        "methods": [],
        "base_classes": [
          "Protocol"
        ],
        "lineno": 6,
        "docstring": "Any object that defines an edge (such as Layout)."
      },
      {
        "name": "E",
        "methods": [],
        "base_classes": [],
        "lineno": 147,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "fractions",
        "name": "Fraction",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "math",
        "name": "ceil",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "cast",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Protocol",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "dataclass",
        "alias": null,
        "lineno": 144,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "print",
      "E",
      "sum",
      "ratio_resolve"
    ],
    "module_level_calls": {
      "function_calls": [
        "sum",
        "resolved",
        "ratio_resolve",
        "E",
        "print"
      ],
      "class_instantiations": [
        "E"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "math",
        "dataclasses",
        "typing"
      ],
      "third_party": {
        "other": [
          "fractions"
        ]
      },
      "tech_stack": []
    },
    "line_count": 154
  },
  "rich/_spinners.py": {
    "filepath": "../rich/rich/_spinners.py",
    "module_docstring": "Spinners are from:\n* cli-spinners:\n    MIT License\n    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights to\n    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n    the Software, and to permit persons to whom the Software is furnished to do so,\n    subject to the following conditions:\n    The above copyright notice and this permission notice shall be included\n    in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n    PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    IN THE SOFTWARE.",
    "functions": [],
    "classes": [],
    "imports": [],
    "variables": [
      {
        "name": "SPINNERS",
        "assigned_to": null,
        "lineno": 22
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 483
  },
  "rich/_stack.py": {
    "filepath": "../rich/rich/_stack.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "top",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "T",
        "lineno": 10,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get top of stack.",
        "code": "def top(self) -> T:\n        \"\"\"Get top of stack.\"\"\"\n        return self[-1]",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "push",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "item",
            "type": "T"
          }
        ],
        "return_type": "None",
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.append",
          "item"
        ],
        "docstring": "Push an item on to the stack (append in stack nomenclature).",
        "code": "def push(self, item: T) -> None:\n        \"\"\"Push an item on to the stack (append in stack nomenclature).\"\"\"\n        self.append(item)",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Stack",
        "methods": [
          "top",
          "push"
        ],
        "base_classes": [
          "unknown"
        ],
        "lineno": 6,
        "docstring": "A small shim over builtin list."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TypeVar",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "T",
        "assigned_to": "TypeVar",
        "lineno": 3
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "TypeVar"
      ],
      "class_instantiations": [
        "TypeVar"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 17
  },
  "rich/_timer.py": {
    "filepath": "../rich/rich/_timer.py",
    "module_docstring": "Timer context manager, only used in debug.",
    "functions": [
      {
        "name": "timer",
        "args": [
          {
            "name": "subject",
            "type": "str"
          }
        ],
        "return_type": "Generator[None, None, None]",
        "lineno": 13,
        "decorators": [
          {
            "name": "contextlib.contextmanager",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "print",
          "time"
        ],
        "docstring": "print the elapsed time. (only used in debugging)",
        "code": "def timer(subject: str = \"time\") -> Generator[None, None, None]:\n    \"\"\"print the elapsed time. (only used in debugging)\"\"\"\n    start = time()\n    yield\n    elapsed = time() - start\n    elapsed_ms = elapsed * 1000\n    print(f\"{subject} elapsed {elapsed_ms:.1f}ms\")",
        "line_count": 7,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "time",
        "name": "time",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "contextlib",
        "alias": null,
        "lineno": 8,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "Generator",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "contextlib",
        "time",
        "typing"
      ],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 20
  },
  "rich/_win32_console.py": {
    "filepath": "../rich/rich/_win32_console.py",
    "module_docstring": "Light wrapper around the Win32 Console API - this module should only be imported on Windows\n\nThe API that this module wraps is documented at https://docs.microsoft.com/en-us/windows/console/console-functions",
    "functions": [
      {
        "name": "GetStdHandle",
        "args": [
          {
            "name": "handle",
            "type": "int"
          }
        ],
        "return_type": "wintypes.HANDLE",
        "lineno": 78,
        "decorators": [],
        "is_async": false,
        "calls": [
          "wintypes.HANDLE",
          "cast",
          "handle",
          "_GetStdHandle"
        ],
        "docstring": "Retrieves a handle to the specified standard device (standard input, standard output, or standard error).\n\nArgs:\n    handle (int): Integer identifier for the handle. Defaults to -11 (stdout).\n\nReturns:\n    wintypes.HANDLE: The handle",
        "code": "def GetStdHandle(handle: int = STDOUT) -> wintypes.HANDLE:\n    \"\"\"Retrieves a handle to the specified standard device (standard input, standard output, or standard error).\n\n    Args:\n        handle (int): Integer identifier for the handle. Defaults to -11 (stdout).\n\n    Returns:\n        wintypes.HANDLE: The handle\n    \"\"\"\n    return cast(wintypes.HANDLE, _GetStdHandle(handle))",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "GetConsoleMode",
        "args": [
          {
            "name": "std_handle",
            "type": "wintypes.HANDLE"
          }
        ],
        "return_type": "int",
        "lineno": 95,
        "decorators": [],
        "is_async": false,
        "calls": [
          "LegacyWindowsError",
          "bool",
          "std_handle",
          "console_mode",
          "wintypes.DWORD",
          "_GetConsoleMode"
        ],
        "docstring": "Retrieves the current input mode of a console's input buffer\nor the current output mode of a console screen buffer.\n\nArgs:\n    std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n\nRaises:\n    LegacyWindowsError: If any error occurs while calling the Windows console API.\n\nReturns:\n    int: Value representing the current console mode as documented at\n        https://docs.microsoft.com/en-us/windows/console/getconsolemode#parameters",
        "code": "def GetConsoleMode(std_handle: wintypes.HANDLE) -> int:\n    \"\"\"Retrieves the current input mode of a console's input buffer\n    or the current output mode of a console screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n\n    Raises:\n        LegacyWindowsError: If any error occurs while calling the Windows console API.\n\n    Returns:\n        int: Value representing the current console mode as documented at\n            https://docs.microsoft.com/en-us/windows/console/getconsolemode#parameters\n    \"\"\"\n\n    console_mode = wintypes.DWORD()\n    success = bool(_GetConsoleMode(std_handle, console_mode))\n    if not success:\n        raise LegacyWindowsError(\"Unable to get legacy Windows Console Mode\")\n    return console_mode.value",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "FillConsoleOutputCharacter",
        "args": [
          {
            "name": "std_handle",
            "type": "wintypes.HANDLE"
          },
          {
            "name": "char",
            "type": "str"
          },
          {
            "name": "length",
            "type": "int"
          },
          {
            "name": "start",
            "type": "WindowsCoordinates"
          }
        ],
        "return_type": "int",
        "lineno": 128,
        "decorators": [],
        "is_async": false,
        "calls": [
          "num_characters",
          "character",
          "std_handle",
          "wintypes.DWORD",
          "byref",
          "length",
          "ctypes.c_char",
          "num_written",
          "start",
          "char.encode",
          "_FillConsoleOutputCharacterW"
        ],
        "docstring": "Writes a character to the console screen buffer a specified number of times, beginning at the specified coordinates.\n\nArgs:\n    std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n    char (str): The character to write. Must be a string of length 1.\n    length (int): The number of times to write the character.\n    start (WindowsCoordinates): The coordinates to start writing at.\n\nReturns:\n    int: The number of characters written.",
        "code": "def FillConsoleOutputCharacter(\n    std_handle: wintypes.HANDLE,\n    char: str,\n    length: int,\n    start: WindowsCoordinates,\n) -> int:\n    \"\"\"Writes a character to the console screen buffer a specified number of times, beginning at the specified coordinates.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        char (str): The character to write. Must be a string of length 1.\n        length (int): The number of times to write the character.\n        start (WindowsCoordinates): The coordinates to start writing at.\n\n    Returns:\n        int: The number of characters written.\n    \"\"\"\n    character = ctypes.c_char(char.encode())\n    num_characters = wintypes.DWORD(length)\n    num_written = wintypes.DWORD(0)\n    _FillConsoleOutputCharacterW(\n        std_handle,\n        character,\n        num_characters,\n        start,\n        byref(num_written),\n    )\n    return num_written.value",
        "line_count": 28,
        "needs_llm_summary": true
      },
      {
        "name": "FillConsoleOutputAttribute",
        "args": [
          {
            "name": "std_handle",
            "type": "wintypes.HANDLE"
          },
          {
            "name": "attributes",
            "type": "int"
          },
          {
            "name": "length",
            "type": "int"
          },
          {
            "name": "start",
            "type": "WindowsCoordinates"
          }
        ],
        "return_type": "int",
        "lineno": 169,
        "decorators": [],
        "is_async": false,
        "calls": [
          "attributes",
          "std_handle",
          "wintypes.DWORD",
          "style_attrs",
          "wintypes.WORD",
          "_FillConsoleOutputAttribute",
          "byref",
          "length",
          "start",
          "num_written",
          "num_cells"
        ],
        "docstring": "Sets the character attributes for a specified number of character cells,\nbeginning at the specified coordinates in a screen buffer.\n\nArgs:\n    std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n    attributes (int): Integer value representing the foreground and background colours of the cells.\n    length (int): The number of cells to set the output attribute of.\n    start (WindowsCoordinates): The coordinates of the first cell whose attributes are to be set.\n\nReturns:\n    int: The number of cells whose attributes were actually set.",
        "code": "def FillConsoleOutputAttribute(\n    std_handle: wintypes.HANDLE,\n    attributes: int,\n    length: int,\n    start: WindowsCoordinates,\n) -> int:\n    \"\"\"Sets the character attributes for a specified number of character cells,\n    beginning at the specified coordinates in a screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        attributes (int): Integer value representing the foreground and background colours of the cells.\n        length (int): The number of cells to set the output attribute of.\n        start (WindowsCoordinates): The coordinates of the first cell whose attributes are to be set.\n\n    Returns:\n        int: The number of cells whose attributes were actually set.\n    \"\"\"\n    num_cells = wintypes.DWORD(length)\n    style_attrs = wintypes.WORD(attributes)\n    num_written = wintypes.DWORD(0)\n    _FillConsoleOutputAttribute(\n        std_handle, style_attrs, num_cells, start, byref(num_written)\n    )\n    return num_written.value",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "SetConsoleTextAttribute",
        "args": [
          {
            "name": "std_handle",
            "type": "wintypes.HANDLE"
          },
          {
            "name": "attributes",
            "type": "wintypes.WORD"
          }
        ],
        "return_type": "bool",
        "lineno": 204,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "std_handle",
          "attributes",
          "_SetConsoleTextAttribute"
        ],
        "docstring": "Set the colour attributes for all text written after this function is called.\n\nArgs:\n    std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n    attributes (int): Integer value representing the foreground and background colours.\n\n\nReturns:\n    bool: True if the attribute was set successfully, otherwise False.",
        "code": "def SetConsoleTextAttribute(\n    std_handle: wintypes.HANDLE, attributes: wintypes.WORD\n) -> bool:\n    \"\"\"Set the colour attributes for all text written after this function is called.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        attributes (int): Integer value representing the foreground and background colours.\n\n\n    Returns:\n        bool: True if the attribute was set successfully, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleTextAttribute(std_handle, attributes))",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "GetConsoleScreenBufferInfo",
        "args": [
          {
            "name": "std_handle",
            "type": "wintypes.HANDLE"
          }
        ],
        "return_type": "CONSOLE_SCREEN_BUFFER_INFO",
        "lineno": 228,
        "decorators": [],
        "is_async": false,
        "calls": [
          "std_handle",
          "byref",
          "CONSOLE_SCREEN_BUFFER_INFO",
          "console_screen_buffer_info",
          "_GetConsoleScreenBufferInfo"
        ],
        "docstring": "Retrieves information about the specified console screen buffer.\n\nArgs:\n    std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n\nReturns:\n    CONSOLE_SCREEN_BUFFER_INFO: A CONSOLE_SCREEN_BUFFER_INFO ctype struct contain information about\n        screen size, cursor position, colour attributes, and more.",
        "code": "def GetConsoleScreenBufferInfo(\n    std_handle: wintypes.HANDLE,\n) -> CONSOLE_SCREEN_BUFFER_INFO:\n    \"\"\"Retrieves information about the specified console screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n\n    Returns:\n        CONSOLE_SCREEN_BUFFER_INFO: A CONSOLE_SCREEN_BUFFER_INFO ctype struct contain information about\n            screen size, cursor position, colour attributes, and more.\"\"\"\n    console_screen_buffer_info = CONSOLE_SCREEN_BUFFER_INFO()\n    _GetConsoleScreenBufferInfo(std_handle, byref(console_screen_buffer_info))\n    return console_screen_buffer_info",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "SetConsoleCursorPosition",
        "args": [
          {
            "name": "std_handle",
            "type": "wintypes.HANDLE"
          },
          {
            "name": "coords",
            "type": "WindowsCoordinates"
          }
        ],
        "return_type": "bool",
        "lineno": 252,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "std_handle",
          "coords",
          "_SetConsoleCursorPosition"
        ],
        "docstring": "Set the position of the cursor in the console screen\n\nArgs:\n    std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n    coords (WindowsCoordinates): The coordinates to move the cursor to.\n\nReturns:\n    bool: True if the function succeeds, otherwise False.",
        "code": "def SetConsoleCursorPosition(\n    std_handle: wintypes.HANDLE, coords: WindowsCoordinates\n) -> bool:\n    \"\"\"Set the position of the cursor in the console screen\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        coords (WindowsCoordinates): The coordinates to move the cursor to.\n\n    Returns:\n        bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleCursorPosition(std_handle, coords))",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "GetConsoleCursorInfo",
        "args": [
          {
            "name": "std_handle",
            "type": "wintypes.HANDLE"
          },
          {
            "name": "cursor_info",
            "type": "CONSOLE_CURSOR_INFO"
          }
        ],
        "return_type": "bool",
        "lineno": 275,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "std_handle",
          "byref",
          "_GetConsoleCursorInfo",
          "cursor_info"
        ],
        "docstring": "Get the cursor info - used to get cursor visibility and width\n\nArgs:\n    std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n    cursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct that receives information\n        about the console's cursor.\n\nReturns:\n      bool: True if the function succeeds, otherwise False.",
        "code": "def GetConsoleCursorInfo(\n    std_handle: wintypes.HANDLE, cursor_info: CONSOLE_CURSOR_INFO\n) -> bool:\n    \"\"\"Get the cursor info - used to get cursor visibility and width\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        cursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct that receives information\n            about the console's cursor.\n\n    Returns:\n          bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_GetConsoleCursorInfo(std_handle, byref(cursor_info)))",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "SetConsoleCursorInfo",
        "args": [
          {
            "name": "std_handle",
            "type": "wintypes.HANDLE"
          },
          {
            "name": "cursor_info",
            "type": "CONSOLE_CURSOR_INFO"
          }
        ],
        "return_type": "bool",
        "lineno": 299,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "std_handle",
          "byref",
          "_SetConsoleCursorInfo",
          "cursor_info"
        ],
        "docstring": "Set the cursor info - used for adjusting cursor visibility and width\n\nArgs:\n    std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n    cursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct containing the new cursor info.\n\nReturns:\n      bool: True if the function succeeds, otherwise False.",
        "code": "def SetConsoleCursorInfo(\n    std_handle: wintypes.HANDLE, cursor_info: CONSOLE_CURSOR_INFO\n) -> bool:\n    \"\"\"Set the cursor info - used for adjusting cursor visibility and width\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        cursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct containing the new cursor info.\n\n    Returns:\n          bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleCursorInfo(std_handle, byref(cursor_info)))",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "SetConsoleTitle",
        "args": [
          {
            "name": "title",
            "type": "str"
          }
        ],
        "return_type": "bool",
        "lineno": 319,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "_SetConsoleTitle",
          "title"
        ],
        "docstring": "Sets the title of the current console window\n\nArgs:\n    title (str): The new title of the console window.\n\nReturns:\n    bool: True if the function succeeds, otherwise False.",
        "code": "def SetConsoleTitle(title: str) -> bool:\n    \"\"\"Sets the title of the current console window\n\n    Args:\n        title (str): The new title of the console window.\n\n    Returns:\n        bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleTitle(title))",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "from_param",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "value",
            "type": "WindowsCoordinates"
          }
        ],
        "return_type": "COORD",
        "lineno": 44,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "value.col",
          "value.row",
          "COORD"
        ],
        "docstring": "Converts a WindowsCoordinates into a wintypes _COORD structure.\nThis classmethod is internally called by ctypes to perform the conversion.\n\nArgs:\n    value (WindowsCoordinates): The input coordinates to convert.\n\nReturns:\n    wintypes._COORD: The converted coordinates struct.",
        "code": "def from_param(cls, value: \"WindowsCoordinates\") -> COORD:\n        \"\"\"Converts a WindowsCoordinates into a wintypes _COORD structure.\n        This classmethod is internally called by ctypes to perform the conversion.\n\n        Args:\n            value (WindowsCoordinates): The input coordinates to convert.\n\n        Returns:\n            wintypes._COORD: The converted coordinates struct.\n        \"\"\"\n        return COORD(value.col, value.row)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "IO[str]"
          }
        ],
        "return_type": "None",
        "lineno": 362,
        "decorators": [],
        "is_async": false,
        "calls": [
          "default_text",
          "unknown.wAttributes",
          "GetStdHandle",
          "handle",
          "GetConsoleScreenBufferInfo",
          "file.write",
          "STDOUT",
          "file",
          "file.flush"
        ],
        "docstring": null,
        "code": "def __init__(self, file: \"IO[str]\") -> None:\n        handle = GetStdHandle(STDOUT)\n        self._handle = handle\n        default_text = GetConsoleScreenBufferInfo(handle).wAttributes\n        self._default_text = default_text\n\n        self._default_fore = default_text & 7\n        self._default_back = (default_text >> 4) & 7\n        self._default_attrs = self._default_fore | (self._default_back << 4)\n\n        self._file = file\n        self.write = file.write\n        self.flush = file.flush",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "cursor_position",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "WindowsCoordinates",
        "lineno": 377,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "coord.X",
          "WindowsCoordinates",
          "GetConsoleScreenBufferInfo",
          "coord.Y",
          "self._handle"
        ],
        "docstring": "Returns the current position of the cursor (0-based)\n\nReturns:\n    WindowsCoordinates: The current cursor position.",
        "code": "def cursor_position(self) -> WindowsCoordinates:\n        \"\"\"Returns the current position of the cursor (0-based)\n\n        Returns:\n            WindowsCoordinates: The current cursor position.\n        \"\"\"\n        coord: COORD = GetConsoleScreenBufferInfo(self._handle).dwCursorPosition\n        return WindowsCoordinates(row=coord.Y, col=coord.X)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "screen_size",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "WindowsCoordinates",
        "lineno": 387,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "WindowsCoordinates",
          "screen_size.Y",
          "GetConsoleScreenBufferInfo",
          "screen_size.X",
          "self._handle"
        ],
        "docstring": "Returns the current size of the console screen buffer, in character columns and rows\n\nReturns:\n    WindowsCoordinates: The width and height of the screen as WindowsCoordinates.",
        "code": "def screen_size(self) -> WindowsCoordinates:\n        \"\"\"Returns the current size of the console screen buffer, in character columns and rows\n\n        Returns:\n            WindowsCoordinates: The width and height of the screen as WindowsCoordinates.\n        \"\"\"\n        screen_size: COORD = GetConsoleScreenBufferInfo(self._handle).dwSize\n        return WindowsCoordinates(row=screen_size.Y, col=screen_size.X)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "write_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 396,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.write",
          "self.flush",
          "text"
        ],
        "docstring": "Write text directly to the terminal without any modification of styles\n\nArgs:\n    text (str): The text to write to the console",
        "code": "def write_text(self, text: str) -> None:\n        \"\"\"Write text directly to the terminal without any modification of styles\n\n        Args:\n            text (str): The text to write to the console\n        \"\"\"\n        self.write(text)\n        self.flush()",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "write_styled",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "style",
            "type": "Style"
          }
        ],
        "return_type": "None",
        "lineno": 405,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._default_text",
          "unknown.number",
          "style.color",
          "bgcolor.downgrade",
          "color.downgrade",
          "SetConsoleTextAttribute",
          "self.write_text",
          "self._handle",
          "style.bgcolor",
          "ColorSystem.WINDOWS",
          "text",
          "ctypes.c_ushort",
          "self._default_fore",
          "self._default_back"
        ],
        "docstring": "Write styled text to the terminal.\n\nArgs:\n    text (str): The text to write\n    style (Style): The style of the text",
        "code": "def write_styled(self, text: str, style: Style) -> None:\n        \"\"\"Write styled text to the terminal.\n\n        Args:\n            text (str): The text to write\n            style (Style): The style of the text\n        \"\"\"\n        color = style.color\n        bgcolor = style.bgcolor\n        if style.reverse:\n            color, bgcolor = bgcolor, color\n\n        if color:\n            fore = color.downgrade(ColorSystem.WINDOWS).number\n            fore = fore if fore is not None else 7  # Default to ANSI 7: White\n            if style.bold:\n                fore = fore | self.BRIGHT_BIT\n            if style.dim:\n                fore = fore & ~self.BRIGHT_BIT\n            fore = self.ANSI_TO_WINDOWS[fore]\n        else:\n            fore = self._default_fore\n\n        if bgcolor:\n            back = bgcolor.downgrade(ColorSystem.WINDOWS).number\n            back = back if back is not None else 0  # Default to ANSI 0: Black\n            back = self.ANSI_TO_WINDOWS[back]\n        else:\n            back = self._default_back\n\n        assert fore is not None\n        assert back is not None\n\n        SetConsoleTextAttribute(\n            self._handle, attributes=ctypes.c_ushort(fore | (back << 4))\n        )\n        self.write_text(text)\n        SetConsoleTextAttribute(self._handle, attributes=self._default_text)",
        "line_count": 38,
        "needs_llm_summary": true
      },
      {
        "name": "move_cursor_to",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "new_position",
            "type": "WindowsCoordinates"
          }
        ],
        "return_type": "None",
        "lineno": 444,
        "decorators": [],
        "is_async": false,
        "calls": [
          "new_position",
          "self._handle",
          "SetConsoleCursorPosition"
        ],
        "docstring": "Set the position of the cursor\n\nArgs:\n    new_position (WindowsCoordinates): The WindowsCoordinates representing the new position of the cursor.",
        "code": "def move_cursor_to(self, new_position: WindowsCoordinates) -> None:\n        \"\"\"Set the position of the cursor\n\n        Args:\n            new_position (WindowsCoordinates): The WindowsCoordinates representing the new position of the cursor.\n        \"\"\"\n        if new_position.col < 0 or new_position.row < 0:\n            return\n        SetConsoleCursorPosition(self._handle, coords=new_position)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "erase_line",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 454,
        "decorators": [],
        "is_async": false,
        "calls": [
          "WindowsCoordinates",
          "FillConsoleOutputCharacter",
          "self._default_attrs",
          "cells_to_erase",
          "self.cursor_position",
          "FillConsoleOutputAttribute",
          "self.screen_size",
          "start_coordinates",
          "cursor_position.row",
          "screen_size.col",
          "self._handle"
        ],
        "docstring": "Erase all content on the line the cursor is currently located at",
        "code": "def erase_line(self) -> None:\n        \"\"\"Erase all content on the line the cursor is currently located at\"\"\"\n        screen_size = self.screen_size\n        cursor_position = self.cursor_position\n        cells_to_erase = screen_size.col\n        start_coordinates = WindowsCoordinates(row=cursor_position.row, col=0)\n        FillConsoleOutputCharacter(\n            self._handle, \" \", length=cells_to_erase, start=start_coordinates\n        )\n        FillConsoleOutputAttribute(\n            self._handle,\n            self._default_attrs,\n            length=cells_to_erase,\n            start=start_coordinates,\n        )",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "erase_end_of_line",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 470,
        "decorators": [],
        "is_async": false,
        "calls": [
          "FillConsoleOutputCharacter",
          "self._default_attrs",
          "cells_to_erase",
          "self.cursor_position",
          "FillConsoleOutputAttribute",
          "self._handle",
          "cursor_position"
        ],
        "docstring": "Erase all content from the cursor position to the end of that line",
        "code": "def erase_end_of_line(self) -> None:\n        \"\"\"Erase all content from the cursor position to the end of that line\"\"\"\n        cursor_position = self.cursor_position\n        cells_to_erase = self.screen_size.col - cursor_position.col\n        FillConsoleOutputCharacter(\n            self._handle, \" \", length=cells_to_erase, start=cursor_position\n        )\n        FillConsoleOutputAttribute(\n            self._handle,\n            self._default_attrs,\n            length=cells_to_erase,\n            start=cursor_position,\n        )",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "erase_start_of_line",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 484,
        "decorators": [],
        "is_async": false,
        "calls": [
          "col",
          "WindowsCoordinates",
          "FillConsoleOutputCharacter",
          "self._default_attrs",
          "row",
          "self.cursor_position",
          "FillConsoleOutputAttribute",
          "start",
          "self._handle"
        ],
        "docstring": "Erase all content from the cursor position to the start of that line",
        "code": "def erase_start_of_line(self) -> None:\n        \"\"\"Erase all content from the cursor position to the start of that line\"\"\"\n        row, col = self.cursor_position\n        start = WindowsCoordinates(row, 0)\n        FillConsoleOutputCharacter(self._handle, \" \", length=col, start=start)\n        FillConsoleOutputAttribute(\n            self._handle, self._default_attrs, length=col, start=start\n        )",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "move_cursor_up",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 493,
        "decorators": [],
        "is_async": false,
        "calls": [
          "WindowsCoordinates",
          "self.cursor_position",
          "SetConsoleCursorPosition",
          "cursor_position.col",
          "self._handle"
        ],
        "docstring": "Move the cursor up a single cell",
        "code": "def move_cursor_up(self) -> None:\n        \"\"\"Move the cursor up a single cell\"\"\"\n        cursor_position = self.cursor_position\n        SetConsoleCursorPosition(\n            self._handle,\n            coords=WindowsCoordinates(\n                row=cursor_position.row - 1, col=cursor_position.col\n            ),\n        )",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "move_cursor_down",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 503,
        "decorators": [],
        "is_async": false,
        "calls": [
          "WindowsCoordinates",
          "self.cursor_position",
          "SetConsoleCursorPosition",
          "cursor_position.col",
          "self._handle"
        ],
        "docstring": "Move the cursor down a single cell",
        "code": "def move_cursor_down(self) -> None:\n        \"\"\"Move the cursor down a single cell\"\"\"\n        cursor_position = self.cursor_position\n        SetConsoleCursorPosition(\n            self._handle,\n            coords=WindowsCoordinates(\n                row=cursor_position.row + 1,\n                col=cursor_position.col,\n            ),\n        )",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "move_cursor_forward",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 514,
        "decorators": [],
        "is_async": false,
        "calls": [
          "col",
          "WindowsCoordinates",
          "row",
          "self.cursor_position",
          "SetConsoleCursorPosition",
          "self._handle"
        ],
        "docstring": "Move the cursor forward a single cell. Wrap to the next line if required.",
        "code": "def move_cursor_forward(self) -> None:\n        \"\"\"Move the cursor forward a single cell. Wrap to the next line if required.\"\"\"\n        row, col = self.cursor_position\n        if col == self.screen_size.col - 1:\n            row += 1\n            col = 0\n        else:\n            col += 1\n        SetConsoleCursorPosition(\n            self._handle, coords=WindowsCoordinates(row=row, col=col)\n        )",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "move_cursor_to_column",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "column",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 526,
        "decorators": [],
        "is_async": false,
        "calls": [
          "WindowsCoordinates",
          "column",
          "row",
          "self.cursor_position",
          "SetConsoleCursorPosition",
          "self._handle"
        ],
        "docstring": "Move cursor to the column specified by the zero-based column index, staying on the same row\n\nArgs:\n    column (int): The zero-based column index to move the cursor to.",
        "code": "def move_cursor_to_column(self, column: int) -> None:\n        \"\"\"Move cursor to the column specified by the zero-based column index, staying on the same row\n\n        Args:\n            column (int): The zero-based column index to move the cursor to.\n        \"\"\"\n        row, _ = self.cursor_position\n        SetConsoleCursorPosition(self._handle, coords=WindowsCoordinates(row, column))",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "move_cursor_backward",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 535,
        "decorators": [],
        "is_async": false,
        "calls": [
          "col",
          "WindowsCoordinates",
          "row",
          "self.cursor_position",
          "SetConsoleCursorPosition",
          "self._handle"
        ],
        "docstring": "Move the cursor backward a single cell. Wrap to the previous line if required.",
        "code": "def move_cursor_backward(self) -> None:\n        \"\"\"Move the cursor backward a single cell. Wrap to the previous line if required.\"\"\"\n        row, col = self.cursor_position\n        if col == 0:\n            row -= 1\n            col = self.screen_size.col - 1\n        else:\n            col -= 1\n        SetConsoleCursorPosition(\n            self._handle, coords=WindowsCoordinates(row=row, col=col)\n        )",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "hide_cursor",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 547,
        "decorators": [],
        "is_async": false,
        "calls": [
          "SetConsoleCursorInfo",
          "current_cursor_size",
          "self._get_cursor_size",
          "self._handle",
          "invisible_cursor",
          "CONSOLE_CURSOR_INFO"
        ],
        "docstring": "Hide the cursor",
        "code": "def hide_cursor(self) -> None:\n        \"\"\"Hide the cursor\"\"\"\n        current_cursor_size = self._get_cursor_size()\n        invisible_cursor = CONSOLE_CURSOR_INFO(dwSize=current_cursor_size, bVisible=0)\n        SetConsoleCursorInfo(self._handle, cursor_info=invisible_cursor)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "show_cursor",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 553,
        "decorators": [],
        "is_async": false,
        "calls": [
          "SetConsoleCursorInfo",
          "current_cursor_size",
          "self._get_cursor_size",
          "visible_cursor",
          "self._handle",
          "CONSOLE_CURSOR_INFO"
        ],
        "docstring": "Show the cursor",
        "code": "def show_cursor(self) -> None:\n        \"\"\"Show the cursor\"\"\"\n        current_cursor_size = self._get_cursor_size()\n        visible_cursor = CONSOLE_CURSOR_INFO(dwSize=current_cursor_size, bVisible=1)\n        SetConsoleCursorInfo(self._handle, cursor_info=visible_cursor)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "set_title",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "title",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 559,
        "decorators": [],
        "is_async": false,
        "calls": [
          "SetConsoleTitle",
          "title",
          "len"
        ],
        "docstring": "Set the title of the terminal window\n\nArgs:\n    title (str): The new title of the console window",
        "code": "def set_title(self, title: str) -> None:\n        \"\"\"Set the title of the terminal window\n\n        Args:\n            title (str): The new title of the console window\n        \"\"\"\n        assert len(title) < 255, \"Console title must be less than 255 characters\"\n        SetConsoleTitle(title)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "_get_cursor_size",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 568,
        "decorators": [],
        "is_async": false,
        "calls": [
          "cursor_info.dwSize",
          "cursor_info",
          "self._handle",
          "int",
          "GetConsoleCursorInfo",
          "CONSOLE_CURSOR_INFO"
        ],
        "docstring": "Get the percentage of the character cell that is filled by the cursor",
        "code": "def _get_cursor_size(self) -> int:\n        \"\"\"Get the percentage of the character cell that is filled by the cursor\"\"\"\n        cursor_info = CONSOLE_CURSOR_INFO()\n        GetConsoleCursorInfo(self._handle, cursor_info=cursor_info)\n        return int(cursor_info.dwSize)",
        "line_count": 5,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "LegacyWindowsError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 29,
        "docstring": null
      },
      {
        "name": "WindowsCoordinates",
        "methods": [
          "from_param"
        ],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 33,
        "docstring": "Coordinates in the Windows Console API are (y, x), not (x, y).\nThis class is intended to prevent that confusion.\nRows and columns are indexed from 0.\nThis class can be used in place of wintypes._COORD in arguments and argtypes."
      },
      {
        "name": "CONSOLE_SCREEN_BUFFER_INFO",
        "methods": [],
        "base_classes": [
          "Structure"
        ],
        "lineno": 57,
        "docstring": null
      },
      {
        "name": "CONSOLE_CURSOR_INFO",
        "methods": [],
        "base_classes": [
          "ctypes.Structure"
        ],
        "lineno": 67,
        "docstring": null
      },
      {
        "name": "LegacyWindowsTerm",
        "methods": [
          "__init__",
          "cursor_position",
          "screen_size",
          "write_text",
          "write_styled",
          "move_cursor_to",
          "erase_line",
          "erase_end_of_line",
          "erase_start_of_line",
          "move_cursor_up",
          "move_cursor_down",
          "move_cursor_forward",
          "move_cursor_to_column",
          "move_cursor_backward",
          "hide_cursor",
          "show_cursor",
          "set_title",
          "_get_cursor_size"
        ],
        "base_classes": [],
        "lineno": 331,
        "docstring": "This class allows interaction with the legacy Windows Console API. It should only be used in the context\nof environments where virtual terminal processing is not available. However, if it is used in a Windows environment,\nthe entire API should work.\n\nArgs:\n    file (IO[str]): The file which the Windows Console API HANDLE is retrieved from, defaults to sys.stdout."
      }
    ],
    "imports": [
      {
        "module": "ctypes",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "time",
        "alias": null,
        "lineno": 16,
        "type": "import"
      },
      {
        "module": "ctypes",
        "name": "Structure",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "byref",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "name": "wintypes",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "IO",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "cast",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "rich.color",
        "name": "ColorSystem",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "rich.style",
        "name": "Style",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 578,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "STDOUT",
        "assigned_to": null,
        "lineno": 23
      },
      {
        "name": "ENABLE_VIRTUAL_TERMINAL_PROCESSING",
        "assigned_to": "int",
        "lineno": 24
      },
      {
        "name": "COORD",
        "assigned_to": null,
        "lineno": 26
      },
      {
        "name": "_GetStdHandle",
        "assigned_to": null,
        "lineno": 71
      },
      {
        "name": "_GetConsoleMode",
        "assigned_to": null,
        "lineno": 90
      },
      {
        "name": "_FillConsoleOutputCharacterW",
        "assigned_to": null,
        "lineno": 117
      },
      {
        "name": "_FillConsoleOutputAttribute",
        "assigned_to": null,
        "lineno": 158
      },
      {
        "name": "_SetConsoleTextAttribute",
        "assigned_to": null,
        "lineno": 196
      },
      {
        "name": "_GetConsoleScreenBufferInfo",
        "assigned_to": null,
        "lineno": 220
      },
      {
        "name": "_SetConsoleCursorPosition",
        "assigned_to": null,
        "lineno": 244
      },
      {
        "name": "_GetConsoleCursorInfo",
        "assigned_to": null,
        "lineno": 267
      },
      {
        "name": "_SetConsoleCursorInfo",
        "assigned_to": null,
        "lineno": 291
      },
      {
        "name": "_SetConsoleTitle",
        "assigned_to": null,
        "lineno": 314
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.rule",
      "time.sleep",
      "term.move_cursor_down",
      "term.move_cursor_to_column",
      "Style",
      "term.show_cursor",
      "term.write_styled",
      "GetStdHandle",
      "Console",
      "term.move_cursor_backward",
      "term.move_cursor_up",
      "term.erase_end_of_line",
      "term.hide_cursor",
      "term.set_title",
      "Style.parse",
      "LegacyWindowsTerm",
      "console.print",
      "term.write_text",
      "term.erase_start_of_line",
      "print",
      "term.erase_line"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.rule",
        "time.sleep",
        "windll.kernel32.SetConsoleCursorInfo",
        "windll.kernel32.GetConsoleScreenBufferInfo",
        "term.move_cursor_down",
        "term.move_cursor_to_column",
        "cast",
        "ctypes.WinDLL",
        "ctypes.LibraryLoader",
        "Style",
        "ctypes.POINTER",
        "wintypes.HANDLE",
        "term.write_styled",
        "term.show_cursor",
        "wintypes.DWORD",
        "windll.kernel32.SetConsoleTextAttribute",
        "GetStdHandle",
        "sys.stdout",
        "CONSOLE_CURSOR_INFO",
        "wintypes.BOOL",
        "Console",
        "windll.kernel32.FillConsoleOutputCharacterW",
        "term.move_cursor_backward",
        "term.move_cursor_up",
        "term.erase_end_of_line",
        "CONSOLE_SCREEN_BUFFER_INFO",
        "term.hide_cursor",
        "term.set_title",
        "Style.parse",
        "windll.kernel32.GetConsoleMode",
        "LegacyWindowsTerm",
        "console.print",
        "WindowsCoordinates",
        "windll.kernel32.FillConsoleOutputAttribute",
        "windll.kernel32.SetConsoleCursorPosition",
        "windll.kernel32.GetConsoleCursorInfo",
        "term.write_text",
        "windll.kernel32.GetStdHandle",
        "wintypes._COORD",
        "term.erase_start_of_line",
        "ImportError",
        "print",
        "term.erase_line",
        "windll.kernel32.SetConsoleTitleW"
      ],
      "class_instantiations": [
        "Console",
        "GetStdHandle",
        "ImportError",
        "Style",
        "LegacyWindowsTerm"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "time",
        "typing"
      ],
      "third_party": {
        "other": [
          "ctypes",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 662
  },
  "rich/_windows.py": {
    "filepath": "../rich/rich/_windows.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "get_windows_console_features",
        "args": [],
        "return_type": "WindowsConsoleFeatures",
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "truecolor",
          "WindowsConsoleFeatures",
          "bool",
          "GetStdHandle",
          "GetConsoleMode",
          "handle",
          "sys.getwindowsversion",
          "vt"
        ],
        "docstring": "Get windows console features.\n\nReturns:\n    WindowsConsoleFeatures: An instance of WindowsConsoleFeatures.",
        "code": "def get_windows_console_features() -> WindowsConsoleFeatures:\n        \"\"\"Get windows console features.\n\n        Returns:\n            WindowsConsoleFeatures: An instance of WindowsConsoleFeatures.\n        \"\"\"\n        handle = GetStdHandle()\n        try:\n            console_mode = GetConsoleMode(handle)\n            success = True\n        except LegacyWindowsError:\n            console_mode = 0\n            success = False\n        vt = bool(success and console_mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING)\n        truecolor = False\n        if vt:\n            win_version = sys.getwindowsversion()\n            truecolor = win_version.major > 10 or (\n                win_version.major == 10 and win_version.build >= 15063\n            )\n        features = WindowsConsoleFeatures(vt=vt, truecolor=truecolor)\n        return features",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "get_windows_console_features",
        "args": [],
        "return_type": "WindowsConsoleFeatures",
        "lineno": 34,
        "decorators": [],
        "is_async": false,
        "calls": [
          "WindowsConsoleFeatures"
        ],
        "docstring": null,
        "code": "def get_windows_console_features() -> WindowsConsoleFeatures:\n        features = WindowsConsoleFeatures()\n        return features",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "WindowsConsoleFeatures",
        "methods": [],
        "base_classes": [],
        "lineno": 6,
        "docstring": "Windows features available."
      }
    ],
    "imports": [
      {
        "module": "sys",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "dataclasses",
        "name": "dataclass",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "ctypes",
        "alias": null,
        "lineno": 16,
        "type": "import"
      },
      {
        "module": "ctypes",
        "name": "LibraryLoader",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "rich._win32_console",
        "name": "ENABLE_VIRTUAL_TERMINAL_PROCESSING",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "rich._win32_console",
        "name": "GetConsoleMode",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "rich._win32_console",
        "name": "GetStdHandle",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "rich._win32_console",
        "name": "LegacyWindowsError",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "platform",
        "alias": null,
        "lineno": 65,
        "type": "import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 68,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "get_windows_console_features",
      "repr",
      "print",
      "platform.system"
    ],
    "module_level_calls": {
      "function_calls": [
        "truecolor",
        "WindowsConsoleFeatures",
        "bool",
        "GetStdHandle",
        "GetConsoleMode",
        "handle",
        "features",
        "sys.getwindowsversion",
        "get_windows_console_features",
        "ImportError",
        "platform.system",
        "vt",
        "ctypes.WinDLL",
        "print",
        "LibraryLoader",
        "repr"
      ],
      "class_instantiations": [
        "WindowsConsoleFeatures",
        "GetStdHandle",
        "GetConsoleMode",
        "ImportError",
        "LibraryLoader"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "dataclasses"
      ],
      "third_party": {
        "other": [
          "ctypes",
          "rich",
          "platform"
        ]
      },
      "tech_stack": []
    },
    "line_count": 72
  },
  "rich/_windows_renderer.py": {
    "filepath": "../rich/rich/_windows_renderer.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "legacy_windows_render",
        "args": [
          {
            "name": "buffer",
            "type": "Iterable[Segment]"
          },
          {
            "name": "term",
            "type": "LegacyWindowsTerm"
          }
        ],
        "return_type": "None",
        "lineno": 7,
        "decorators": [],
        "is_async": false,
        "calls": [
          "term.move_cursor_to",
          "style",
          "term.move_cursor_down",
          "term.move_cursor_to_column",
          "cast",
          "term.show_cursor",
          "term.write_styled",
          "control_code",
          "title",
          "term.move_cursor_forward",
          "term.move_cursor_backward",
          "term.move_cursor_up",
          "term.erase_end_of_line",
          "text",
          "term.hide_cursor",
          "term.set_title",
          "WindowsCoordinates",
          "term.write_text",
          "term.erase_start_of_line",
          "term.erase_line"
        ],
        "docstring": "Makes appropriate Windows Console API calls based on the segments in the buffer.\n\nArgs:\n    buffer (Iterable[Segment]): Iterable of Segments to convert to Win32 API calls.\n    term (LegacyWindowsTerm): Used to call the Windows Console API.",
        "code": "def legacy_windows_render(buffer: Iterable[Segment], term: LegacyWindowsTerm) -> None:\n    \"\"\"Makes appropriate Windows Console API calls based on the segments in the buffer.\n\n    Args:\n        buffer (Iterable[Segment]): Iterable of Segments to convert to Win32 API calls.\n        term (LegacyWindowsTerm): Used to call the Windows Console API.\n    \"\"\"\n    for text, style, control in buffer:\n        if not control:\n            if style:\n                term.write_styled(text, style)\n            else:\n                term.write_text(text)\n        else:\n            control_codes: Sequence[ControlCode] = control\n            for control_code in control_codes:\n                control_type = control_code[0]\n                if control_type == ControlType.CURSOR_MOVE_TO:\n                    _, x, y = cast(Tuple[ControlType, int, int], control_code)\n                    term.move_cursor_to(WindowsCoordinates(row=y - 1, col=x - 1))\n                elif control_type == ControlType.CARRIAGE_RETURN:\n                    term.write_text(\"\\r\")\n                elif control_type == ControlType.HOME:\n                    term.move_cursor_to(WindowsCoordinates(0, 0))\n                elif control_type == ControlType.CURSOR_UP:\n                    term.move_cursor_up()\n                elif control_type == ControlType.CURSOR_DOWN:\n                    term.move_cursor_down()\n                elif control_type == ControlType.CURSOR_FORWARD:\n                    term.move_cursor_forward()\n                elif control_type == ControlType.CURSOR_BACKWARD:\n                    term.move_cursor_backward()\n                elif control_type == ControlType.CURSOR_MOVE_TO_COLUMN:\n                    _, column = cast(Tuple[ControlType, int], control_code)\n                    term.move_cursor_to_column(column - 1)\n                elif control_type == ControlType.HIDE_CURSOR:\n                    term.hide_cursor()\n                elif control_type == ControlType.SHOW_CURSOR:\n                    term.show_cursor()\n                elif control_type == ControlType.ERASE_IN_LINE:\n                    _, mode = cast(Tuple[ControlType, int], control_code)\n                    if mode == 0:\n                        term.erase_end_of_line()\n                    elif mode == 1:\n                        term.erase_start_of_line()\n                    elif mode == 2:\n                        term.erase_line()\n                elif control_type == ControlType.SET_WINDOW_TITLE:\n                    _, title = cast(Tuple[ControlType, str], control_code)\n                    term.set_title(title)",
        "line_count": 50,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "cast",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich._win32_console",
        "name": "LegacyWindowsTerm",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich._win32_console",
        "name": "WindowsCoordinates",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich.segment",
        "name": "ControlCode",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.segment",
        "name": "ControlType",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.segment",
        "name": "Segment",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 57
  },
  "rich/_wrap.py": {
    "filepath": "../rich/rich/_wrap.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "words",
        "args": [
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "Iterable[tuple[int, int, str]]",
        "lineno": 12,
        "decorators": [],
        "is_async": false,
        "calls": [
          "word_match.span",
          "end",
          "re_word.match",
          "word_match.group",
          "position",
          "text"
        ],
        "docstring": "Yields each word from the text as a tuple\ncontaining (start_index, end_index, word). A \"word\" in this context may\ninclude the actual word and any whitespace to the right.",
        "code": "def words(text: str) -> Iterable[tuple[int, int, str]]:\n    \"\"\"Yields each word from the text as a tuple\n    containing (start_index, end_index, word). A \"word\" in this context may\n    include the actual word and any whitespace to the right.\n    \"\"\"\n    position = 0\n    word_match = re_word.match(text, position)\n    while word_match is not None:\n        start, end = word_match.span()\n        word = word_match.group(0)\n        yield start, end, word\n        word_match = re_word.match(text, end)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "divide_line",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "fold",
            "type": "bool"
          }
        ],
        "return_type": "list[int]",
        "lineno": 26,
        "decorators": [],
        "is_async": false,
        "calls": [
          "len",
          "folded_word",
          "append",
          "_cell_len",
          "word",
          "line",
          "word.rstrip",
          "chop_cells",
          "width",
          "text",
          "break_positions.append",
          "loop_last",
          "start",
          "words",
          "cell_len"
        ],
        "docstring": "Given a string of text, and a width (measured in cells), return a list\nof cell offsets which the string should be split at in order for it to fit\nwithin the given width.\n\nArgs:\n    text: The text to examine.\n    width: The available cell width.\n    fold: If True, words longer than `width` will be folded onto a new line.\n\nReturns:\n    A list of indices to break the line at.",
        "code": "def divide_line(text: str, width: int, fold: bool = True) -> list[int]:\n    \"\"\"Given a string of text, and a width (measured in cells), return a list\n    of cell offsets which the string should be split at in order for it to fit\n    within the given width.\n\n    Args:\n        text: The text to examine.\n        width: The available cell width.\n        fold: If True, words longer than `width` will be folded onto a new line.\n\n    Returns:\n        A list of indices to break the line at.\n    \"\"\"\n    break_positions: list[int] = []  # offsets to insert the breaks at\n    append = break_positions.append\n    cell_offset = 0\n    _cell_len = cell_len\n\n    for start, _end, word in words(text):\n        word_length = _cell_len(word.rstrip())\n        remaining_space = width - cell_offset\n        word_fits_remaining_space = remaining_space >= word_length\n\n        if word_fits_remaining_space:\n            # Simplest case - the word fits within the remaining width for this line.\n            cell_offset += _cell_len(word)\n        else:\n            # Not enough space remaining for this word on the current line.\n            if word_length > width:\n                # The word doesn't fit on any line, so we can't simply\n                # place it on the next line...\n                if fold:\n                    # Fold the word across multiple lines.\n                    folded_word = chop_cells(word, width=width)\n                    for last, line in loop_last(folded_word):\n                        if start:\n                            append(start)\n                        if last:\n                            cell_offset = _cell_len(line)\n                        else:\n                            start += len(line)\n                else:\n                    # Folding isn't allowed, so crop the word.\n                    if start:\n                        append(start)\n                    cell_offset = _cell_len(word)\n            elif cell_offset and start:\n                # The word doesn't fit within the remaining space on the current\n                # line, but it *can* fit on to the next (empty) line.\n                append(start)\n                cell_offset = _cell_len(word)\n\n    return break_positions",
        "line_count": 53,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "re",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "chop_cells",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 82,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "re_word",
        "assigned_to": "re.compile",
        "lineno": 9
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "console.rule",
      "Console",
      "chop_cells",
      "print"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.rule",
        "Console",
        "re.compile",
        "chop_cells",
        "print"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "re"
      ],
      "third_party": {
        "other": [
          "__future__",
          "_loop",
          "cells",
          "console"
        ]
      },
      "tech_stack": []
    },
    "line_count": 94
  },
  "rich/abc.py": {
    "filepath": "../rich/rich/abc.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__subclasshook__",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "other",
            "type": "type"
          }
        ],
        "return_type": "bool",
        "lineno": 16,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "other",
          "hasattr"
        ],
        "docstring": "Check if this class supports the rich render protocol.",
        "code": "def __subclasshook__(cls, other: type) -> bool:\n        \"\"\"Check if this class supports the rich render protocol.\"\"\"\n        return hasattr(other, \"__rich_console__\") or hasattr(other, \"__rich__\")",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "RichRenderable",
        "methods": [
          "__subclasshook__"
        ],
        "base_classes": [
          "ABC"
        ],
        "lineno": 4,
        "docstring": "An abstract base class for Rich renderables.\n\nNote that there is no need to extend this class, the intended use is to check if an\nobject supports the Rich renderable protocol. For example::\n\n    if isinstance(my_object, RichRenderable):\n        console.print(my_object)"
      },
      {
        "name": "Foo",
        "methods": [],
        "base_classes": [],
        "lineno": 28,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "abc",
        "name": "ABC",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "isinstance",
      "print",
      "Foo",
      "Text"
    ],
    "module_level_calls": {
      "function_calls": [
        "isinstance",
        "Foo",
        "t",
        "f",
        "RichRenderable",
        "print",
        "Text"
      ],
      "class_instantiations": [
        "Foo",
        "Text"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "abc"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 34
  },
  "rich/align.py": {
    "filepath": "../rich/rich/align.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "align",
            "type": "AlignMethod"
          },
          {
            "name": "style",
            "type": "Optional[StyleType]"
          }
        ],
        "return_type": "None",
        "lineno": 33,
        "decorators": [],
        "is_async": false,
        "calls": [
          "vertical",
          "align",
          "style",
          "ValueError",
          "height",
          "renderable",
          "width",
          "pad"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        renderable: \"RenderableType\",\n        align: AlignMethod = \"left\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> None:\n        if align not in (\"left\", \"center\", \"right\"):\n            raise ValueError(\n                f'invalid value for align, expected \"left\", \"center\", or \"right\" (not {align!r})'\n            )\n        if vertical is not None and vertical not in (\"top\", \"middle\", \"bottom\"):\n            raise ValueError(\n                f'invalid value for vertical, expected \"top\", \"middle\", or \"bottom\" (not {vertical!r})'\n            )\n        self.renderable = renderable\n        self.align = align\n        self.style = style\n        self.vertical = vertical\n        self.pad = pad\n        self.width = width\n        self.height = height",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 60,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"Align({self.renderable!r}, {self.align!r})\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "left",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "style",
            "type": "Optional[StyleType]"
          }
        ],
        "return_type": "Align",
        "lineno": 64,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "vertical",
          "style",
          "height",
          "renderable",
          "width",
          "cls",
          "pad"
        ],
        "docstring": "Align a renderable to the left.",
        "code": "def left(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the left.\"\"\"\n        return cls(\n            renderable,\n            \"left\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "center",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "style",
            "type": "Optional[StyleType]"
          }
        ],
        "return_type": "Align",
        "lineno": 86,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "vertical",
          "style",
          "height",
          "renderable",
          "width",
          "cls",
          "pad"
        ],
        "docstring": "Align a renderable to the center.",
        "code": "def center(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the center.\"\"\"\n        return cls(\n            renderable,\n            \"center\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "right",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "style",
            "type": "Optional[StyleType]"
          }
        ],
        "return_type": "Align",
        "lineno": 108,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "vertical",
          "style",
          "height",
          "renderable",
          "width",
          "cls",
          "pad"
        ],
        "docstring": "Align a renderable to the right.",
        "code": "def right(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the right.\"\"\"\n        return cls(\n            renderable,\n            \"right\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 129,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "lines",
          "iter_segments",
          "count",
          "style",
          "top_space",
          "console.render",
          "list",
          "self.width",
          "options.update",
          "height",
          "console.measure",
          "self.style",
          "Segment.split_lines",
          "Constrain",
          "console.get_style",
          "Segment.apply_style",
          "rendered",
          "bottom_space",
          "options",
          "width",
          "Segment",
          "self.align",
          "min",
          "Segment.get_shape",
          "range",
          "Segment.set_shape",
          "unknown.maximum",
          "self.renderable",
          "blank_lines",
          "chain",
          "generate_segments"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        align = self.align\n        width = console.measure(self.renderable, options=options).maximum\n        rendered = console.render(\n            Constrain(\n                self.renderable, width if self.width is None else min(width, self.width)\n            ),\n            options.update(height=None),\n        )\n        lines = list(Segment.split_lines(rendered))\n        width, height = Segment.get_shape(lines)\n        lines = Segment.set_shape(lines, width, height)\n        new_line = Segment.line()\n        excess_space = options.max_width - width\n        style = console.get_style(self.style) if self.style is not None else None\n\n        def generate_segments() -> Iterable[Segment]:\n            if excess_space <= 0:\n                # Exact fit\n                for line in lines:\n                    yield from line\n                    yield new_line\n\n            elif align == \"left\":\n                # Pad on the right\n                pad = Segment(\" \" * excess_space, style) if self.pad else None\n                for line in lines:\n                    yield from line\n                    if pad:\n                        yield pad\n                    yield new_line\n\n            elif align == \"center\":\n                # Pad left and right\n                left = excess_space // 2\n                pad = Segment(\" \" * left, style)\n                pad_right = (\n                    Segment(\" \" * (excess_space - left), style) if self.pad else None\n                )\n                for line in lines:\n                    if left:\n                        yield pad\n                    yield from line\n                    if pad_right:\n                        yield pad_right\n                    yield new_line\n\n            elif align == \"right\":\n                # Padding on left\n                pad = Segment(\" \" * excess_space, style)\n                for line in lines:\n                    yield pad\n                    yield from line\n                    yield new_line\n\n        blank_line = (\n            Segment(f\"{' ' * (self.width or options.max_width)}\\n\", style)\n            if self.pad\n            else Segment(\"\\n\")\n        )\n\n        def blank_lines(count: int) -> Iterable[Segment]:\n            if count > 0:\n                for _ in range(count):\n                    yield blank_line\n\n        vertical_height = self.height or options.height\n        iter_segments: Iterable[Segment]\n        if self.vertical and vertical_height is not None:\n            if self.vertical == \"top\":\n                bottom_space = vertical_height - height\n                iter_segments = chain(generate_segments(), blank_lines(bottom_space))\n            elif self.vertical == \"middle\":\n                top_space = (vertical_height - height) // 2\n                bottom_space = vertical_height - top_space - height\n                iter_segments = chain(\n                    blank_lines(top_space),\n                    generate_segments(),\n                    blank_lines(bottom_space),\n                )\n            else:  #  self.vertical == \"bottom\":\n                top_space = vertical_height - height\n                iter_segments = chain(blank_lines(top_space), generate_segments())\n        else:\n            iter_segments = generate_segments()\n        if self.style:\n            style = console.get_style(self.style)\n            iter_segments = Segment.apply_style(iter_segments, style)\n        yield from iter_segments",
        "line_count": 91,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 221,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.renderable",
          "Measurement.get",
          "console",
          "options"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        measurement = Measurement.get(console, options, self.renderable)\n        return measurement",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "style",
            "type": "Optional[StyleType]"
          }
        ],
        "return_type": "None",
        "lineno": 240,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "renderable"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n    ) -> None:\n        self.renderable = renderable\n        self.style = style",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 248,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"VerticalCenter({self.renderable!r})\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 251,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "self.style",
          "lines",
          "Segment.get_shape",
          "console.render_lines",
          "range",
          "count",
          "bottom_space",
          "style",
          "console.get_style",
          "self.renderable",
          "blank_lines",
          "top_space",
          "Segment",
          "options.update",
          "len"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        style = console.get_style(self.style) if self.style is not None else None\n        lines = console.render_lines(\n            self.renderable, options.update(height=None), pad=False\n        )\n        width, _height = Segment.get_shape(lines)\n        new_line = Segment.line()\n        height = options.height or options.size.height\n        top_space = (height - len(lines)) // 2\n        bottom_space = height - top_space - len(lines)\n        blank_line = Segment(f\"{' ' * width}\", style)\n\n        def blank_lines(count: int) -> Iterable[Segment]:\n            for _ in range(count):\n                yield blank_line\n                yield new_line\n\n        if top_space > 0:\n            yield from blank_lines(top_space)\n        for line in lines:\n            yield from line\n            yield new_line\n        if bottom_space > 0:\n            yield from blank_lines(bottom_space)",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 278,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.renderable",
          "Measurement.get",
          "console",
          "options"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        measurement = Measurement.get(console, options, self.renderable)\n        return measurement",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "generate_segments",
        "args": [],
        "return_type": "Iterable[Segment]",
        "lineno": 147,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "Segment"
        ],
        "docstring": null,
        "code": "def generate_segments() -> Iterable[Segment]:\n            if excess_space <= 0:\n                # Exact fit\n                for line in lines:\n                    yield from line\n                    yield new_line\n\n            elif align == \"left\":\n                # Pad on the right\n                pad = Segment(\" \" * excess_space, style) if self.pad else None\n                for line in lines:\n                    yield from line\n                    if pad:\n                        yield pad\n                    yield new_line\n\n            elif align == \"center\":\n                # Pad left and right\n                left = excess_space // 2\n                pad = Segment(\" \" * left, style)\n                pad_right = (\n                    Segment(\" \" * (excess_space - left), style) if self.pad else None\n                )\n                for line in lines:\n                    if left:\n                        yield pad\n                    yield from line\n                    if pad_right:\n                        yield pad_right\n                    yield new_line\n\n            elif align == \"right\":\n                # Padding on left\n                pad = Segment(\" \" * excess_space, style)\n                for line in lines:\n                    yield pad\n                    yield from line\n                    yield new_line",
        "line_count": 38,
        "needs_llm_summary": true
      },
      {
        "name": "blank_lines",
        "args": [
          {
            "name": "count",
            "type": "int"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 192,
        "decorators": [],
        "is_async": false,
        "calls": [
          "range",
          "count"
        ],
        "docstring": null,
        "code": "def blank_lines(count: int) -> Iterable[Segment]:\n            if count > 0:\n                for _ in range(count):\n                    yield blank_line",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "blank_lines",
        "args": [
          {
            "name": "count",
            "type": "int"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 265,
        "decorators": [],
        "is_async": false,
        "calls": [
          "range",
          "count"
        ],
        "docstring": null,
        "code": "def blank_lines(count: int) -> Iterable[Segment]:\n            for _ in range(count):\n                yield blank_line\n                yield new_line",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Align",
        "methods": [
          "__init__",
          "__repr__",
          "left",
          "center",
          "right",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 17,
        "docstring": "Align a renderable by adding spaces if necessary.\n\nArgs:\n    renderable (RenderableType): A console renderable.\n    align (AlignMethod): One of \"left\", \"center\", or \"right\"\"\n    style (StyleType, optional): An optional style to apply to the background.\n    vertical (Optional[VerticalAlignMethod], optional): Optional vertical align, one of \"top\", \"middle\", or \"bottom\". Defaults to None.\n    pad (bool, optional): Pad the right with spaces. Defaults to True.\n    width (int, optional): Restrict contents to given width, or None to use default width. Defaults to None.\n    height (int, optional): Set height of align renderable, or None to fit to contents. Defaults to None.\n\nRaises:\n    ValueError: if ``align`` is not one of the expected values."
      },
      {
        "name": "VerticalCenter",
        "methods": [
          "__init__",
          "__repr__",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 228,
        "docstring": "Vertically aligns a renderable.\n\nWarn:\n    This class is deprecated and may be removed in a future version. Use Align class with\n    `vertical=\"middle\"`.\n\nArgs:\n    renderable (RenderableType): A renderable object.\n    style (StyleType, optional): An optional style to apply to the background. Defaults to None."
      }
    ],
    "imports": [
      {
        "module": "itertools",
        "name": "chain",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Literal",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "constrain",
        "name": "Constrain",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 286,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Group",
        "alias": null,
        "lineno": 286,
        "type": "from_import"
      },
      {
        "module": "rich.highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 287,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 288,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "AlignMethod",
        "assigned_to": null,
        "lineno": 13
      },
      {
        "name": "VerticalAlignMethod",
        "assigned_to": null,
        "lineno": 14
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Align.right",
      "highlighter",
      "Align.left",
      "Console",
      "Panel",
      "Group",
      "ReprHighlighter",
      "Align.center"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.height",
        "Align.right",
        "highlighter",
        "Align.left",
        "Console",
        "Panel",
        "Group",
        "panel",
        "ReprHighlighter",
        "Align.center"
      ],
      "class_instantiations": [
        "Console",
        "Panel",
        "Group",
        "ReprHighlighter",
        "Align"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "itertools",
        "typing"
      ],
      "third_party": {
        "other": [
          "constrain",
          "jupyter",
          "measure",
          "segment",
          "style",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 307
  },
  "rich/ansi.py": {
    "filepath": "../rich/rich/ansi.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_ansi_tokenize",
        "args": [
          {
            "name": "ansi_text",
            "type": "str"
          }
        ],
        "return_type": "Iterable[_AnsiToken]",
        "lineno": 28,
        "decorators": [],
        "is_async": false,
        "calls": [
          "osc",
          "end",
          "re_ansi.finditer",
          "sgr",
          "_AnsiToken",
          "ansi_text",
          "sgr.endswith",
          "match.span",
          "match.groups",
          "len"
        ],
        "docstring": "Tokenize a string in to plain text and ANSI codes.\n\nArgs:\n    ansi_text (str): A String containing ANSI codes.\n\nYields:\n    AnsiToken: A named tuple of (plain, sgr, osc)",
        "code": "def _ansi_tokenize(ansi_text: str) -> Iterable[_AnsiToken]:\n    \"\"\"Tokenize a string in to plain text and ANSI codes.\n\n    Args:\n        ansi_text (str): A String containing ANSI codes.\n\n    Yields:\n        AnsiToken: A named tuple of (plain, sgr, osc)\n    \"\"\"\n\n    position = 0\n    sgr: Optional[str]\n    osc: Optional[str]\n    for match in re_ansi.finditer(ansi_text):\n        start, end = match.span(0)\n        osc, sgr = match.groups()\n        if start > position:\n            yield _AnsiToken(ansi_text[position:start])\n        if sgr:\n            if sgr == \"(\":\n                position = end + 1\n                continue\n            if sgr.endswith(\"m\"):\n                yield _AnsiToken(\"\", sgr[1:-1], osc)\n        else:\n            yield _AnsiToken(\"\", sgr, osc)\n        position = end\n    if position < len(ansi_text):\n        yield _AnsiToken(ansi_text[position:])",
        "line_count": 29,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 123,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Style.null"
        ],
        "docstring": null,
        "code": "def __init__(self) -> None:\n        self.style = Style.null()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "decode",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "terminal_text",
            "type": "str"
          }
        ],
        "return_type": "Iterable[Text]",
        "lineno": 126,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line",
          "self.decode_line",
          "terminal_text.splitlines"
        ],
        "docstring": "Decode ANSI codes in an iterable of lines.\n\nArgs:\n    lines (Iterable[str]): An iterable of lines of terminal output.\n\nYields:\n    Text: Marked up Text.",
        "code": "def decode(self, terminal_text: str) -> Iterable[Text]:\n        \"\"\"Decode ANSI codes in an iterable of lines.\n\n        Args:\n            lines (Iterable[str]): An iterable of lines of terminal output.\n\n        Yields:\n            Text: Marked up Text.\n        \"\"\"\n        for line in terminal_text.splitlines():\n            yield self.decode_line(line)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "decode_line",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "line",
            "type": "str"
          }
        ],
        "return_type": "Text",
        "lineno": 138,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.partition",
          "Color.from_ansi",
          "codes",
          "next",
          "_ansi_tokenize",
          "Style",
          "self.style.update_link",
          "_Style.from_color",
          "sgr.split",
          "iter_codes",
          "_Style.null",
          "Color.from_rgb",
          "int",
          "from_ansi",
          "Text",
          "_code.isdigit",
          "osc.startswith",
          "append",
          "line",
          "from_rgb",
          "line.rsplit",
          "min",
          "suppress",
          "StopIteration",
          "text.append",
          "plain_text",
          "iter",
          "_Style.parse",
          "_code"
        ],
        "docstring": "Decode a line containing ansi codes.\n\nArgs:\n    line (str): A line of terminal output.\n\nReturns:\n    Text: A Text instance marked up according to ansi codes.",
        "code": "def decode_line(self, line: str) -> Text:\n        \"\"\"Decode a line containing ansi codes.\n\n        Args:\n            line (str): A line of terminal output.\n\n        Returns:\n            Text: A Text instance marked up according to ansi codes.\n        \"\"\"\n        from_ansi = Color.from_ansi\n        from_rgb = Color.from_rgb\n        _Style = Style\n        text = Text()\n        append = text.append\n        line = line.rsplit(\"\\r\", 1)[-1]\n        for plain_text, sgr, osc in _ansi_tokenize(line):\n            if plain_text:\n                append(plain_text, self.style or None)\n            elif osc is not None:\n                if osc.startswith(\"8;\"):\n                    _params, semicolon, link = osc[2:].partition(\";\")\n                    if semicolon:\n                        self.style = self.style.update_link(link or None)\n            elif sgr is not None:\n                # Translate in to semi-colon separated codes\n                # Ignore invalid codes, because we want to be lenient\n                codes = [\n                    min(255, int(_code) if _code else 0)\n                    for _code in sgr.split(\";\")\n                    if _code.isdigit() or _code == \"\"\n                ]\n                iter_codes = iter(codes)\n                for code in iter_codes:\n                    if code == 0:\n                        # reset\n                        self.style = _Style.null()\n                    elif code in SGR_STYLE_MAP:\n                        # styles\n                        self.style += _Style.parse(SGR_STYLE_MAP[code])\n                    elif code == 38:\n                        # \u00a0Foreground\n                        with suppress(StopIteration):\n                            color_type = next(iter_codes)\n                            if color_type == 5:\n                                self.style += _Style.from_color(\n                                    from_ansi(next(iter_codes))\n                                )\n                            elif color_type == 2:\n                                self.style += _Style.from_color(\n                                    from_rgb(\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                    )\n                                )\n                    elif code == 48:\n                        # Background\n                        with suppress(StopIteration):\n                            color_type = next(iter_codes)\n                            if color_type == 5:\n                                self.style += _Style.from_color(\n                                    None, from_ansi(next(iter_codes))\n                                )\n                            elif color_type == 2:\n                                self.style += _Style.from_color(\n                                    None,\n                                    from_rgb(\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                    ),\n                                )\n\n        return text",
        "line_count": 74,
        "needs_llm_summary": true
      },
      {
        "name": "read",
        "args": [
          {
            "name": "fd",
            "type": "int"
          }
        ],
        "return_type": "bytes",
        "lineno": 224,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stdout.write",
          "os.read",
          "fd",
          "data"
        ],
        "docstring": null,
        "code": "def read(fd: int) -> bytes:\n        data = os.read(fd, 1024)\n        stdout.write(data)\n        return data",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "_AnsiToken",
        "methods": [],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 20,
        "docstring": "Result of ansi tokenized string."
      },
      {
        "name": "AnsiDecoder",
        "methods": [
          "__init__",
          "decode",
          "decode_line"
        ],
        "base_classes": [],
        "lineno": 120,
        "docstring": "Translate ANSI code in to styled Text."
      }
    ],
    "imports": [
      {
        "module": "re",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "contextlib",
        "name": "suppress",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "Color",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 215,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 216,
        "type": "import"
      },
      {
        "module": "pty",
        "alias": null,
        "lineno": 217,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 218,
        "type": "import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 231,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "re_ansi",
        "assigned_to": "re.compile",
        "lineno": 10
      },
      {
        "name": "SGR_STYLE_MAP",
        "assigned_to": null,
        "lineno": 59
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "re.compile",
        "data",
        "stdout.getvalue",
        "read",
        "unknown.decode",
        "stdout_result",
        "decoder.decode",
        "line",
        "Console",
        "AnsiDecoder",
        "io.BytesIO",
        "console.save_html",
        "stdout.write",
        "console.print",
        "pty.spawn",
        "fd",
        "re.VERBOSE",
        "os.read",
        "print"
      ],
      "class_instantiations": [
        "AnsiDecoder",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "io",
        "contextlib",
        "typing",
        "re",
        "os",
        "sys"
      ],
      "third_party": {
        "other": [
          "color",
          "style",
          "text",
          "pty",
          "console"
        ]
      },
      "tech_stack": []
    },
    "line_count": 242
  },
  "rich/bar.py": {
    "filepath": "../rich/rich/bar.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "size",
            "type": "float"
          },
          {
            "name": "begin",
            "type": "float"
          },
          {
            "name": "end",
            "type": "float"
          }
        ],
        "return_type": null,
        "lineno": 29,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "max",
          "end",
          "begin",
          "color",
          "bgcolor",
          "width",
          "size",
          "Style"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        size: float,\n        begin: float,\n        end: float,\n        *,\n        width: Optional[int] = None,\n        color: Union[Color, str] = \"default\",\n        bgcolor: Union[Color, str] = \"default\",\n    ):\n        self.size = size\n        self.begin = max(begin, 0)\n        self.end = min(end, size)\n        self.width = width\n        self.style = Style(color=color, bgcolor=bgcolor)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 45,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"Bar({self.size}, {self.begin}, {self.end})\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 48,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "min",
          "Segment.line",
          "options.max_width",
          "prefix",
          "body",
          "Segment",
          "int",
          "len"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = min(\n            self.width if self.width is not None else options.max_width,\n            options.max_width,\n        )\n\n        if self.begin >= self.end:\n            yield Segment(\" \" * width, self.style)\n            yield Segment.line()\n            return\n\n        prefix_complete_eights = int(width * 8 * self.begin / self.size)\n        prefix_bar_count = prefix_complete_eights // 8\n        prefix_eights_count = prefix_complete_eights % 8\n\n        body_complete_eights = int(width * 8 * self.end / self.size)\n        body_bar_count = body_complete_eights // 8\n        body_eights_count = body_complete_eights % 8\n\n        # When start and end fall into the same cell, we ideally should render\n        # a symbol that's \"center-aligned\", but there is no good symbol in Unicode.\n        # In this case, we fall back to right-aligned block symbol for simplicity.\n\n        prefix = \" \" * prefix_bar_count\n        if prefix_eights_count:\n            prefix += BEGIN_BLOCK_ELEMENTS[prefix_eights_count]\n\n        body = FULL_BLOCK * body_bar_count\n        if body_eights_count:\n            body += END_BLOCK_ELEMENTS[body_eights_count]\n\n        suffix = \" \" * (width - len(body))\n\n        yield Segment(prefix + body[len(prefix) :] + suffix, self.style)\n        yield Segment.line()",
        "line_count": 37,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 86,
        "decorators": [],
        "is_async": false,
        "calls": [
          "options.max_width",
          "self.width",
          "Measurement"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return (\n            Measurement(self.width, self.width)\n            if self.width is not None\n            else Measurement(4, options.max_width)\n        )",
        "line_count": 8,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Bar",
        "methods": [
          "__init__",
          "__repr__",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 17,
        "docstring": "Renders a solid block bar.\n\nArgs:\n    size (float): Value for the end of the bar.\n    begin (float): Begin point (between 0 and size, inclusive).\n    end (float): End point (between 0 and size, inclusive).\n    width (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.\n    color (Union[Color, str], optional): Color of the bar. Defaults to \"default\".\n    bgcolor (Union[Color, str], optional): Color of bar background. Defaults to \"default\"."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "Color",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "BEGIN_BLOCK_ELEMENTS",
        "assigned_to": null,
        "lineno": 12
      },
      {
        "name": "END_BLOCK_ELEMENTS",
        "assigned_to": null,
        "lineno": 13
      },
      {
        "name": "FULL_BLOCK",
        "assigned_to": "str",
        "lineno": 14
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "color",
          "console",
          "jupyter",
          "measure",
          "segment",
          "style"
        ]
      },
      "tech_stack": []
    },
    "line_count": 94
  },
  "rich/box.py": {
    "filepath": "../rich/rich/box.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "box",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 27,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line6",
          "box",
          "line2",
          "line3",
          "line7",
          "iter",
          "line1",
          "line8",
          "box.splitlines",
          "ascii",
          "line5",
          "line4"
        ],
        "docstring": null,
        "code": "def __init__(self, box: str, *, ascii: bool = False) -> None:\n        self._box = box\n        self.ascii = ascii\n        line1, line2, line3, line4, line5, line6, line7, line8 = box.splitlines()\n        # top\n        self.top_left, self.top, self.top_divider, self.top_right = iter(line1)\n        # head\n        self.head_left, _, self.head_vertical, self.head_right = iter(line2)\n        # head_row\n        (\n            self.head_row_left,\n            self.head_row_horizontal,\n            self.head_row_cross,\n            self.head_row_right,\n        ) = iter(line3)\n\n        # mid\n        self.mid_left, _, self.mid_vertical, self.mid_right = iter(line4)\n        # row\n        self.row_left, self.row_horizontal, self.row_cross, self.row_right = iter(line5)\n        # foot_row\n        (\n            self.foot_row_left,\n            self.foot_row_horizontal,\n            self.foot_row_cross,\n            self.foot_row_right,\n        ) = iter(line6)\n        # foot\n        self.foot_left, _, self.foot_vertical, self.foot_right = iter(line7)\n        # bottom\n        self.bottom_left, self.bottom, self.bottom_divider, self.bottom_right = iter(\n            line8\n        )",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 61,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return \"Box(...)\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 64,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        return self._box",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "substitute",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          },
          {
            "name": "safe",
            "type": "bool"
          }
        ],
        "return_type": "Box",
        "lineno": 67,
        "decorators": [],
        "is_async": false,
        "calls": [
          "LEGACY_WINDOWS_SUBSTITUTIONS.get",
          "box",
          "ASCII",
          "self"
        ],
        "docstring": "Substitute this box for another if it won't render due to platform issues.\n\nArgs:\n    options (ConsoleOptions): Console options used in rendering.\n    safe (bool, optional): Substitute this for another Box if there are known problems\n        displaying on the platform (currently only relevant on Windows). Default is True.\n\nReturns:\n    Box: A different Box or the same Box.",
        "code": "def substitute(self, options: \"ConsoleOptions\", safe: bool = True) -> \"Box\":\n        \"\"\"Substitute this box for another if it won't render due to platform issues.\n\n        Args:\n            options (ConsoleOptions): Console options used in rendering.\n            safe (bool, optional): Substitute this for another Box if there are known problems\n                displaying on the platform (currently only relevant on Windows). Default is True.\n\n        Returns:\n            Box: A different Box or the same Box.\n        \"\"\"\n        box = self\n        if options.legacy_windows and safe:\n            box = LEGACY_WINDOWS_SUBSTITUTIONS.get(box, box)\n        if options.ascii_only and not box.ascii:\n            box = ASCII\n        return box",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "get_plain_headed_box",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Box",
        "lineno": 85,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self",
          "PLAIN_HEADED_SUBSTITUTIONS.get"
        ],
        "docstring": "If this box uses special characters for the borders of the header, then\nreturn the equivalent box that does not.\n\nReturns:\n    Box: The most similar Box that doesn't use header-specific box characters.\n        If the current Box already satisfies this criterion, then it's returned.",
        "code": "def get_plain_headed_box(self) -> \"Box\":\n        \"\"\"If this box uses special characters for the borders of the header, then\n        return the equivalent box that does not.\n\n        Returns:\n            Box: The most similar Box that doesn't use header-specific box characters.\n                If the current Box already satisfies this criterion, then it's returned.\n        \"\"\"\n        return PLAIN_HEADED_SUBSTITUTIONS.get(self, self)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "get_top",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "widths",
            "type": "Iterable[int]"
          }
        ],
        "return_type": "str",
        "lineno": 95,
        "decorators": [],
        "is_async": false,
        "calls": [
          "parts.append",
          "self.top_divider",
          "self.top_right",
          "append",
          "self.top_left",
          "unknown.join",
          "parts",
          "widths",
          "loop_last"
        ],
        "docstring": "Get the top of a simple box.\n\nArgs:\n    widths (List[int]): Widths of columns.\n\nReturns:\n    str: A string of box characters.",
        "code": "def get_top(self, widths: Iterable[int]) -> str:\n        \"\"\"Get the top of a simple box.\n\n        Args:\n            widths (List[int]): Widths of columns.\n\n        Returns:\n            str: A string of box characters.\n        \"\"\"\n\n        parts: List[str] = []\n        append = parts.append\n        append(self.top_left)\n        for last, width in loop_last(widths):\n            append(self.top * width)\n            if not last:\n                append(self.top_divider)\n        append(self.top_right)\n        return \"\".join(parts)",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "get_row",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "widths",
            "type": "Iterable[int]"
          },
          {
            "name": "level",
            "type": "Literal[head, row, foot, mid]"
          },
          {
            "name": "edge",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 115,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.row_right",
          "self.mid_right",
          "self.foot_row_right",
          "right",
          "self.mid_vertical",
          "parts",
          "widths",
          "self.head_row_left",
          "self.head_row_right",
          "ValueError",
          "unknown.join",
          "self.row_horizontal",
          "self.foot_row_left",
          "self.foot_row_horizontal",
          "append",
          "self.foot_row_cross",
          "left",
          "self.head_row_cross",
          "self.row_left",
          "parts.append",
          "self.mid_left",
          "cross",
          "self.row_cross",
          "loop_last",
          "self.head_row_horizontal"
        ],
        "docstring": "Get the top of a simple box.\n\nArgs:\n    width (List[int]): Widths of columns.\n\nReturns:\n    str: A string of box characters.",
        "code": "def get_row(\n        self,\n        widths: Iterable[int],\n        level: Literal[\"head\", \"row\", \"foot\", \"mid\"] = \"row\",\n        edge: bool = True,\n    ) -> str:\n        \"\"\"Get the top of a simple box.\n\n        Args:\n            width (List[int]): Widths of columns.\n\n        Returns:\n            str: A string of box characters.\n        \"\"\"\n        if level == \"head\":\n            left = self.head_row_left\n            horizontal = self.head_row_horizontal\n            cross = self.head_row_cross\n            right = self.head_row_right\n        elif level == \"row\":\n            left = self.row_left\n            horizontal = self.row_horizontal\n            cross = self.row_cross\n            right = self.row_right\n        elif level == \"mid\":\n            left = self.mid_left\n            horizontal = \" \"\n            cross = self.mid_vertical\n            right = self.mid_right\n        elif level == \"foot\":\n            left = self.foot_row_left\n            horizontal = self.foot_row_horizontal\n            cross = self.foot_row_cross\n            right = self.foot_row_right\n        else:\n            raise ValueError(\"level must be 'head', 'row' or 'foot'\")\n\n        parts: List[str] = []\n        append = parts.append\n        if edge:\n            append(left)\n        for last, width in loop_last(widths):\n            append(horizontal * width)\n            if not last:\n                append(cross)\n        if edge:\n            append(right)\n        return \"\".join(parts)",
        "line_count": 48,
        "needs_llm_summary": true
      },
      {
        "name": "get_bottom",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "widths",
            "type": "Iterable[int]"
          }
        ],
        "return_type": "str",
        "lineno": 164,
        "decorators": [],
        "is_async": false,
        "calls": [
          "parts.append",
          "append",
          "self.bottom_divider",
          "self.bottom_left",
          "self.bottom_right",
          "unknown.join",
          "parts",
          "widths",
          "loop_last"
        ],
        "docstring": "Get the bottom of a simple box.\n\nArgs:\n    widths (List[int]): Widths of columns.\n\nReturns:\n    str: A string of box characters.",
        "code": "def get_bottom(self, widths: Iterable[int]) -> str:\n        \"\"\"Get the bottom of a simple box.\n\n        Args:\n            widths (List[int]): Widths of columns.\n\n        Returns:\n            str: A string of box characters.\n        \"\"\"\n\n        parts: List[str] = []\n        append = parts.append\n        append(self.bottom_left)\n        for last, width in loop_last(widths):\n            append(self.bottom * width)\n            if not last:\n                append(self.bottom_divider)\n        append(self.bottom_right)\n        return \"\".join(parts)",
        "line_count": 19,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Box",
        "methods": [
          "__init__",
          "__repr__",
          "__str__",
          "substitute",
          "get_plain_headed_box",
          "get_top",
          "get_row",
          "get_bottom"
        ],
        "base_classes": [],
        "lineno": 10,
        "docstring": "Defines characters to render boxes.\n\n\u250c\u2500\u252c\u2510 top\n\u2502 \u2502\u2502 head\n\u251c\u2500\u253c\u2524 head_row\n\u2502 \u2502\u2502 mid\n\u251c\u2500\u253c\u2524 row\n\u251c\u2500\u253c\u2524 foot_row\n\u2502 \u2502\u2502 foot\n\u2514\u2500\u2534\u2518 bottom\n\nArgs:\n    box (str): Characters making up box.\n    ascii (bool, optional): True if this box uses ascii characters only. Default is False."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Literal",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.columns",
        "name": "Columns",
        "alias": null,
        "lineno": 425,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 426,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "box",
        "alias": "box",
        "lineno": 428,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 429,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 430,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 431,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "LEGACY_WINDOWS_SUBSTITUTIONS",
        "assigned_to": null,
        "lineno": 405
      },
      {
        "name": "PLAIN_HEADED_SUBSTITUTIONS",
        "assigned_to": null,
        "lineno": 415
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Columns",
      "getattr",
      "Console",
      "Panel",
      "sorted",
      "Text",
      "table.add_column",
      "table.add_row",
      "Table",
      "columns.add_renderable"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "box",
        "Columns",
        "getattr",
        "box_name",
        "table",
        "Console",
        "BOXES",
        "Panel",
        "Box",
        "sorted",
        "columns",
        "table.add_column",
        "table.add_row",
        "Text",
        "Table",
        "columns.add_renderable"
      ],
      "class_instantiations": [
        "Columns",
        "Console",
        "Panel",
        "Box",
        "Text",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "_loop",
          "rich",
          "box",
          "console",
          "table",
          "text"
        ]
      },
      "tech_stack": []
    },
    "line_count": 475
  },
  "rich/cells.py": {
    "filepath": "../rich/rich/cells.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cached_cell_len",
        "args": [
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "int",
        "lineno": 34,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [
              4096
            ],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "sum",
          "lru_cache",
          "map",
          "_is_single_cell_widths",
          "text",
          "get_character_cell_size",
          "len"
        ],
        "docstring": "Get the number of cells required to display text.\n\nThis method always caches, which may use up a lot of memory. It is recommended to use\n`cell_len` over this method.\n\nArgs:\n    text (str): Text to display.\n\nReturns:\n    int: Get the number of cells required to display text.",
        "code": "def cached_cell_len(text: str) -> int:\n    \"\"\"Get the number of cells required to display text.\n\n    This method always caches, which may use up a lot of memory. It is recommended to use\n    `cell_len` over this method.\n\n    Args:\n        text (str): Text to display.\n\n    Returns:\n        int: Get the number of cells required to display text.\n    \"\"\"\n    if _is_single_cell_widths(text):\n        return len(text)\n    return sum(map(get_character_cell_size, text))",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "cell_len",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "_cell_len",
            "type": "Callable[Any, int]"
          }
        ],
        "return_type": "int",
        "lineno": 51,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sum",
          "_cell_len",
          "map",
          "_is_single_cell_widths",
          "text",
          "get_character_cell_size",
          "len"
        ],
        "docstring": "Get the number of cells required to display text.\n\nArgs:\n    text (str): Text to display.\n\nReturns:\n    int: Get the number of cells required to display text.",
        "code": "def cell_len(text: str, _cell_len: Callable[[str], int] = cached_cell_len) -> int:\n    \"\"\"Get the number of cells required to display text.\n\n    Args:\n        text (str): Text to display.\n\n    Returns:\n        int: Get the number of cells required to display text.\n    \"\"\"\n    if len(text) < 512:\n        return _cell_len(text)\n    if _is_single_cell_widths(text):\n        return len(text)\n    return sum(map(get_character_cell_size, text))",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "get_character_cell_size",
        "args": [
          {
            "name": "character",
            "type": "str"
          }
        ],
        "return_type": "int",
        "lineno": 68,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 4096
            }
          }
        ],
        "is_async": false,
        "calls": [
          "character",
          "CELL_WIDTHS",
          "lru_cache",
          "ord",
          "_table",
          "len"
        ],
        "docstring": "Get the cell size of a character.\n\nArgs:\n    character (str): A single character.\n\nReturns:\n    int: Number of cells (0, 1 or 2) occupied by that character.",
        "code": "def get_character_cell_size(character: str) -> int:\n    \"\"\"Get the cell size of a character.\n\n    Args:\n        character (str): A single character.\n\n    Returns:\n        int: Number of cells (0, 1 or 2) occupied by that character.\n    \"\"\"\n    codepoint = ord(character)\n    _table = CELL_WIDTHS\n    lower_bound = 0\n    upper_bound = len(_table) - 1\n    index = (lower_bound + upper_bound) // 2\n    while True:\n        start, end, width = _table[index]\n        if codepoint < start:\n            upper_bound = index - 1\n        elif codepoint > end:\n            lower_bound = index + 1\n        else:\n            return 0 if width == -1 else width\n        if upper_bound < lower_bound:\n            break\n        index = (lower_bound + upper_bound) // 2\n    return 1",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "set_cell_size",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "total",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 96,
        "decorators": [],
        "is_async": false,
        "calls": [
          "before",
          "pos",
          "_is_single_cell_widths",
          "cell_len",
          "text",
          "len"
        ],
        "docstring": "Set the length of a string to fit within given number of cells.",
        "code": "def set_cell_size(text: str, total: int) -> str:\n    \"\"\"Set the length of a string to fit within given number of cells.\"\"\"\n\n    if _is_single_cell_widths(text):\n        size = len(text)\n        if size < total:\n            return text + \" \" * (total - size)\n        return text[:total]\n\n    if total <= 0:\n        return \"\"\n    cell_size = cell_len(text)\n    if cell_size == total:\n        return text\n    if cell_size < total:\n        return text + \" \" * (total - cell_size)\n\n    start = 0\n    end = len(text)\n\n    # Binary search until we find the right size\n    while True:\n        pos = (start + end) // 2\n        before = text[: pos + 1]\n        before_len = cell_len(before)\n        if before_len == total + 1 and cell_len(before[-1]) == 2:\n            return before[:-1] + \" \"\n        if before_len == total:\n            return before\n        if before_len > total:\n            end = pos\n        else:\n            start = pos",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "chop_cells",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "list[str]",
        "lineno": 131,
        "decorators": [],
        "is_async": false,
        "calls": [
          "character",
          "lines.append",
          "line",
          "append_new_line",
          "unknown.join",
          "unknown.append",
          "_get_character_cell_size",
          "get_character_cell_size",
          "append_to_last_line",
          "cell_width"
        ],
        "docstring": "Split text into lines such that each line fits within the available (cell) width.\n\nArgs:\n    text: The text to fold such that it fits in the given width.\n    width: The width available (number of cells).\n\nReturns:\n    A list of strings such that each string in the list has cell width\n    less than or equal to the available width.",
        "code": "def chop_cells(\n    text: str,\n    width: int,\n) -> list[str]:\n    \"\"\"Split text into lines such that each line fits within the available (cell) width.\n\n    Args:\n        text: The text to fold such that it fits in the given width.\n        width: The width available (number of cells).\n\n    Returns:\n        A list of strings such that each string in the list has cell width\n        less than or equal to the available width.\n    \"\"\"\n    _get_character_cell_size = get_character_cell_size\n    lines: list[list[str]] = [[]]\n\n    append_new_line = lines.append\n    append_to_last_line = lines[-1].append\n\n    total_width = 0\n\n    for character in text:\n        cell_width = _get_character_cell_size(character)\n        char_doesnt_fit = total_width + cell_width > width\n\n        if char_doesnt_fit:\n            append_new_line([character])\n            append_to_last_line = lines[-1].append\n            total_width = cell_width\n        else:\n            append_to_last_line(character)\n            total_width += cell_width\n\n    return [\"\".join(line) for line in lines]",
        "line_count": 35,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "functools",
        "name": "lru_cache",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "_cell_widths",
        "name": "CELL_WIDTHS",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "_SINGLE_CELLS",
        "assigned_to": "frozenset",
        "lineno": 20
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "range",
      "set_cell_size",
      "chop_cells",
      "get_character_cell_size",
      "print"
    ],
    "module_level_calls": {
      "function_calls": [
        "range",
        "chr",
        "line",
        "frozenset",
        "map",
        "chop_cells",
        "set_cell_size",
        "get_character_cell_size",
        "n",
        "print",
        "_start"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "functools",
        "typing"
      ],
      "third_party": {
        "other": [
          "__future__",
          "_cell_widths"
        ]
      },
      "tech_stack": []
    },
    "line_count": 175
  },
  "rich/color.py": {
    "filepath": "../rich/rich/color.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "parse_rgb_hex",
        "args": [
          {
            "name": "hex_color",
            "type": "str"
          }
        ],
        "return_type": "ColorTriplet",
        "lineno": 571,
        "decorators": [],
        "is_async": false,
        "calls": [
          "int",
          "ColorTriplet",
          "hex_color",
          "len"
        ],
        "docstring": "Parse six hex characters in to RGB triplet.",
        "code": "def parse_rgb_hex(hex_color: str) -> ColorTriplet:\n    \"\"\"Parse six hex characters in to RGB triplet.\"\"\"\n    assert len(hex_color) == 6, \"must be 6 characters\"\n    color = ColorTriplet(\n        int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)\n    )\n    return color",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "blend_rgb",
        "args": [
          {
            "name": "color1",
            "type": "ColorTriplet"
          },
          {
            "name": "color2",
            "type": "ColorTriplet"
          },
          {
            "name": "cross_fade",
            "type": "float"
          }
        ],
        "return_type": "ColorTriplet",
        "lineno": 580,
        "decorators": [],
        "is_async": false,
        "calls": [
          "color1",
          "int",
          "ColorTriplet",
          "color2"
        ],
        "docstring": "Blend one RGB color in to another.",
        "code": "def blend_rgb(\n    color1: ColorTriplet, color2: ColorTriplet, cross_fade: float = 0.5\n) -> ColorTriplet:\n    \"\"\"Blend one RGB color in to another.\"\"\"\n    r1, g1, b1 = color1\n    r2, g2, b2 = color2\n    new_color = ColorTriplet(\n        int(r1 + (r2 - r1) * cross_fade),\n        int(g1 + (g2 - g1) * cross_fade),\n        int(b1 + (b2 - b1) * cross_fade),\n    )\n    return new_color",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 29,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"ColorSystem.{self.name}\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 32,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr",
          "self"
        ],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        return repr(self)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 45,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"ColorType.{self.name}\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Text",
        "lineno": 315,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Style",
          "Text.assemble",
          "self.type.name.lower",
          "self"
        ],
        "docstring": "Displays the actual color if Rich printed.",
        "code": "def __rich__(self) -> \"Text\":\n        \"\"\"Displays the actual color if Rich printed.\"\"\"\n        from .style import Style\n        from .text import Text\n\n        return Text.assemble(\n            f\"<color {self.name!r} ({self.type.name.lower()})\",\n            (\"\u2b24\", Style(color=self)),\n            \" >\",\n        )",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Result",
        "lineno": 326,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_repr__(self) -> Result:\n        yield self.name\n        yield self.type\n        yield \"number\", self.number, None\n        yield \"triplet\", self.triplet, None",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "system",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ColorSystem",
        "lineno": 333,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "int",
          "self.type",
          "ColorSystem"
        ],
        "docstring": "Get the native color system for this color.",
        "code": "def system(self) -> ColorSystem:\n        \"\"\"Get the native color system for this color.\"\"\"\n        if self.type == ColorType.DEFAULT:\n            return ColorSystem.STANDARD\n        return ColorSystem(int(self.type))",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "is_system_defined",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 340,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Check if the color is ultimately defined by the system.",
        "code": "def is_system_defined(self) -> bool:\n        \"\"\"Check if the color is ultimately defined by the system.\"\"\"\n        return self.system not in (ColorSystem.EIGHT_BIT, ColorSystem.TRUECOLOR)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "is_default",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 345,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Check if the color is a default color.",
        "code": "def is_default(self) -> bool:\n        \"\"\"Check if the color is a default color.\"\"\"\n        return self.type == ColorType.DEFAULT",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get_truecolor",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "theme",
            "type": "Optional[TerminalTheme]"
          },
          {
            "name": "foreground",
            "type": "bool"
          }
        ],
        "return_type": "ColorTriplet",
        "lineno": 349,
        "decorators": [],
        "is_async": false,
        "calls": [
          "DEFAULT_TERMINAL_THEME"
        ],
        "docstring": "Get an equivalent color triplet for this color.\n\nArgs:\n    theme (TerminalTheme, optional): Optional terminal theme, or None to use default. Defaults to None.\n    foreground (bool, optional): True for a foreground color, or False for background. Defaults to True.\n\nReturns:\n    ColorTriplet: A color triplet containing RGB components.",
        "code": "def get_truecolor(\n        self, theme: Optional[\"TerminalTheme\"] = None, foreground: bool = True\n    ) -> ColorTriplet:\n        \"\"\"Get an equivalent color triplet for this color.\n\n        Args:\n            theme (TerminalTheme, optional): Optional terminal theme, or None to use default. Defaults to None.\n            foreground (bool, optional): True for a foreground color, or False for background. Defaults to True.\n\n        Returns:\n            ColorTriplet: A color triplet containing RGB components.\n        \"\"\"\n\n        if theme is None:\n            theme = DEFAULT_TERMINAL_THEME\n        if self.type == ColorType.TRUECOLOR:\n            assert self.triplet is not None\n            return self.triplet\n        elif self.type == ColorType.EIGHT_BIT:\n            assert self.number is not None\n            return EIGHT_BIT_PALETTE[self.number]\n        elif self.type == ColorType.STANDARD:\n            assert self.number is not None\n            return theme.ansi_colors[self.number]\n        elif self.type == ColorType.WINDOWS:\n            assert self.number is not None\n            return WINDOWS_PALETTE[self.number]\n        else:  # self.type == ColorType.DEFAULT:\n            assert self.number is None\n            return theme.foreground_color if foreground else theme.background_color",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "from_ansi",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "number",
            "type": "int"
          }
        ],
        "return_type": "Color",
        "lineno": 381,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "number",
          "cls"
        ],
        "docstring": "Create a Color number from it's 8-bit ansi number.\n\nArgs:\n    number (int): A number between 0-255 inclusive.\n\nReturns:\n    Color: A new Color instance.",
        "code": "def from_ansi(cls, number: int) -> \"Color\":\n        \"\"\"Create a Color number from it's 8-bit ansi number.\n\n        Args:\n            number (int): A number between 0-255 inclusive.\n\n        Returns:\n            Color: A new Color instance.\n        \"\"\"\n        return cls(\n            name=f\"color({number})\",\n            type=(ColorType.STANDARD if number < 16 else ColorType.EIGHT_BIT),\n            number=number,\n        )",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "from_triplet",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "triplet",
            "type": "ColorTriplet"
          }
        ],
        "return_type": "Color",
        "lineno": 397,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ColorType.TRUECOLOR",
          "cls",
          "triplet",
          "triplet.hex"
        ],
        "docstring": "Create a truecolor RGB color from a triplet of values.\n\nArgs:\n    triplet (ColorTriplet): A color triplet containing red, green and blue components.\n\nReturns:\n    Color: A new color object.",
        "code": "def from_triplet(cls, triplet: \"ColorTriplet\") -> \"Color\":\n        \"\"\"Create a truecolor RGB color from a triplet of values.\n\n        Args:\n            triplet (ColorTriplet): A color triplet containing red, green and blue components.\n\n        Returns:\n            Color: A new color object.\n        \"\"\"\n        return cls(name=triplet.hex, type=ColorType.TRUECOLOR, triplet=triplet)",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "from_rgb",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "red",
            "type": "float"
          },
          {
            "name": "green",
            "type": "float"
          },
          {
            "name": "blue",
            "type": "float"
          }
        ],
        "return_type": "Color",
        "lineno": 409,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "green",
          "blue",
          "cls.from_triplet",
          "ColorTriplet",
          "red",
          "int"
        ],
        "docstring": "Create a truecolor from three color components in the range(0->255).\n\nArgs:\n    red (float): Red component in range 0-255.\n    green (float): Green component in range 0-255.\n    blue (float): Blue component in range 0-255.\n\nReturns:\n    Color: A new color object.",
        "code": "def from_rgb(cls, red: float, green: float, blue: float) -> \"Color\":\n        \"\"\"Create a truecolor from three color components in the range(0->255).\n\n        Args:\n            red (float): Red component in range 0-255.\n            green (float): Green component in range 0-255.\n            blue (float): Blue component in range 0-255.\n\n        Returns:\n            Color: A new color object.\n        \"\"\"\n        return cls.from_triplet(ColorTriplet(int(red), int(green), int(blue)))",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "default",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Color",
        "lineno": 423,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ColorType.DEFAULT",
          "cls"
        ],
        "docstring": "Get a Color instance representing the default color.\n\nReturns:\n    Color: Default color.",
        "code": "def default(cls) -> \"Color\":\n        \"\"\"Get a Color instance representing the default color.\n\n        Returns:\n            Color: Default color.\n        \"\"\"\n        return cls(name=\"default\", type=ColorType.DEFAULT)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "parse",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "color",
            "type": "str"
          }
        ],
        "return_type": "Color",
        "lineno": 433,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 1024
            }
          }
        ],
        "is_async": false,
        "calls": [
          "components",
          "lru_cache",
          "blue",
          "all",
          "color_rgb.split",
          "color_match.groups",
          "number",
          "color",
          "triplet",
          "color_8",
          "red",
          "int",
          "ColorType.TRUECOLOR",
          "RE_COLOR.match",
          "ColorType.DEFAULT",
          "ANSI_COLOR_NAMES.get",
          "color_number",
          "cls",
          "color.lower",
          "len",
          "unknown.strip",
          "green",
          "ColorParseError",
          "ColorTriplet"
        ],
        "docstring": "Parse a color definition.",
        "code": "def parse(cls, color: str) -> \"Color\":\n        \"\"\"Parse a color definition.\"\"\"\n        original_color = color\n        color = color.lower().strip()\n\n        if color == \"default\":\n            return cls(color, type=ColorType.DEFAULT)\n\n        color_number = ANSI_COLOR_NAMES.get(color)\n        if color_number is not None:\n            return cls(\n                color,\n                type=(ColorType.STANDARD if color_number < 16 else ColorType.EIGHT_BIT),\n                number=color_number,\n            )\n\n        color_match = RE_COLOR.match(color)\n        if color_match is None:\n            raise ColorParseError(f\"{original_color!r} is not a valid color\")\n\n        color_24, color_8, color_rgb = color_match.groups()\n        if color_24:\n            triplet = ColorTriplet(\n                int(color_24[0:2], 16), int(color_24[2:4], 16), int(color_24[4:6], 16)\n            )\n            return cls(color, ColorType.TRUECOLOR, triplet=triplet)\n\n        elif color_8:\n            number = int(color_8)\n            if number > 255:\n                raise ColorParseError(f\"color number must be <= 255 in {color!r}\")\n            return cls(\n                color,\n                type=(ColorType.STANDARD if number < 16 else ColorType.EIGHT_BIT),\n                number=number,\n            )\n\n        else:  #  color_rgb:\n            components = color_rgb.split(\",\")\n            if len(components) != 3:\n                raise ColorParseError(\n                    f\"expected three components in {original_color!r}\"\n                )\n            red, green, blue = components\n            triplet = ColorTriplet(int(red), int(green), int(blue))\n            if not all(component <= 255 for component in triplet):\n                raise ColorParseError(\n                    f\"color components must be <= 255 in {original_color!r}\"\n                )\n            return cls(color, ColorType.TRUECOLOR, triplet=triplet)",
        "line_count": 50,
        "needs_llm_summary": true
      },
      {
        "name": "get_ansi_codes",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "foreground",
            "type": "bool"
          }
        ],
        "return_type": "Tuple[str, Ellipsis]",
        "lineno": 485,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 1024
            }
          }
        ],
        "is_async": false,
        "calls": [
          "green",
          "str",
          "lru_cache",
          "blue",
          "self.triplet",
          "red",
          "self.type",
          "self.number"
        ],
        "docstring": "Get the ANSI escape codes for this color.",
        "code": "def get_ansi_codes(self, foreground: bool = True) -> Tuple[str, ...]:\n        \"\"\"Get the ANSI escape codes for this color.\"\"\"\n        _type = self.type\n        if _type == ColorType.DEFAULT:\n            return (\"39\" if foreground else \"49\",)\n\n        elif _type == ColorType.WINDOWS:\n            number = self.number\n            assert number is not None\n            fore, back = (30, 40) if number < 8 else (82, 92)\n            return (str(fore + number if foreground else back + number),)\n\n        elif _type == ColorType.STANDARD:\n            number = self.number\n            assert number is not None\n            fore, back = (30, 40) if number < 8 else (82, 92)\n            return (str(fore + number if foreground else back + number),)\n\n        elif _type == ColorType.EIGHT_BIT:\n            assert self.number is not None\n            return (\"38\" if foreground else \"48\", \"5\", str(self.number))\n\n        else:  # self.standard == ColorStandard.TRUECOLOR:\n            assert self.triplet is not None\n            red, green, blue = self.triplet\n            return (\"38\" if foreground else \"48\", \"2\", str(red), str(green), str(blue))",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "downgrade",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "system",
            "type": "ColorSystem"
          }
        ],
        "return_type": "Color",
        "lineno": 513,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 1024
            }
          }
        ],
        "is_async": false,
        "calls": [
          "ColorType.STANDARD",
          "six_blue",
          "six_red",
          "lru_cache",
          "round",
          "Color",
          "self.name",
          "ColorType.EIGHT_BIT",
          "triplet",
          "self.number",
          "color_number",
          "self.triplet",
          "ColorTriplet",
          "WINDOWS_PALETTE.match",
          "rgb_to_hls",
          "ColorType.WINDOWS",
          "six_green",
          "STANDARD_PALETTE.match"
        ],
        "docstring": "Downgrade a color system to a system with fewer colors.",
        "code": "def downgrade(self, system: ColorSystem) -> \"Color\":\n        \"\"\"Downgrade a color system to a system with fewer colors.\"\"\"\n\n        if self.type in (ColorType.DEFAULT, system):\n            return self\n        # Convert to 8-bit color from truecolor color\n        if system == ColorSystem.EIGHT_BIT and self.system == ColorSystem.TRUECOLOR:\n            assert self.triplet is not None\n            _h, l, s = rgb_to_hls(*self.triplet.normalized)\n            # If saturation is under 15% assume it is grayscale\n            if s < 0.15:\n                gray = round(l * 25.0)\n                if gray == 0:\n                    color_number = 16\n                elif gray == 25:\n                    color_number = 231\n                else:\n                    color_number = 231 + gray\n                return Color(self.name, ColorType.EIGHT_BIT, number=color_number)\n\n            red, green, blue = self.triplet\n            six_red = red / 95 if red < 95 else 1 + (red - 95) / 40\n            six_green = green / 95 if green < 95 else 1 + (green - 95) / 40\n            six_blue = blue / 95 if blue < 95 else 1 + (blue - 95) / 40\n\n            color_number = (\n                16 + 36 * round(six_red) + 6 * round(six_green) + round(six_blue)\n            )\n            return Color(self.name, ColorType.EIGHT_BIT, number=color_number)\n\n        # Convert to standard from truecolor or 8-bit\n        elif system == ColorSystem.STANDARD:\n            if self.system == ColorSystem.TRUECOLOR:\n                assert self.triplet is not None\n                triplet = self.triplet\n            else:  # self.system == ColorSystem.EIGHT_BIT\n                assert self.number is not None\n                triplet = ColorTriplet(*EIGHT_BIT_PALETTE[self.number])\n\n            color_number = STANDARD_PALETTE.match(triplet)\n            return Color(self.name, ColorType.STANDARD, number=color_number)\n\n        elif system == ColorSystem.WINDOWS:\n            if self.system == ColorSystem.TRUECOLOR:\n                assert self.triplet is not None\n                triplet = self.triplet\n            else:  # self.system == ColorSystem.EIGHT_BIT\n                assert self.number is not None\n                if self.number < 16:\n                    return Color(self.name, ColorType.WINDOWS, number=self.number)\n                triplet = ColorTriplet(*EIGHT_BIT_PALETTE[self.number])\n\n            color_number = WINDOWS_PALETTE.match(triplet)\n            return Color(self.name, ColorType.WINDOWS, number=color_number)\n\n        return self",
        "line_count": 56,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ColorSystem",
        "methods": [
          "__repr__",
          "__str__"
        ],
        "base_classes": [
          "IntEnum"
        ],
        "lineno": 21,
        "docstring": "One of the 3 color system supported by terminals."
      },
      {
        "name": "ColorType",
        "methods": [
          "__repr__"
        ],
        "base_classes": [
          "IntEnum"
        ],
        "lineno": 36,
        "docstring": "Type of color stored in Color class."
      },
      {
        "name": "ColorParseError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 288,
        "docstring": "The color could not be parsed."
      },
      {
        "name": "Color",
        "methods": [
          "__rich__",
          "__rich_repr__",
          "system",
          "is_system_defined",
          "is_default",
          "get_truecolor",
          "from_ansi",
          "from_triplet",
          "from_rgb",
          "default",
          "parse",
          "get_ansi_codes",
          "downgrade"
        ],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 303,
        "docstring": "Terminal color definition."
      }
    ],
    "imports": [
      {
        "module": "re",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "colorsys",
        "name": "rgb_to_hls",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "enum",
        "name": "IntEnum",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "functools",
        "name": "lru_cache",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "_palettes",
        "name": "EIGHT_BIT_PALETTE",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "_palettes",
        "name": "STANDARD_PALETTE",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "_palettes",
        "name": "WINDOWS_PALETTE",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "color_triplet",
        "name": "ColorTriplet",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "repr",
        "name": "Result",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "repr",
        "name": "rich_repr",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "terminal_theme",
        "name": "DEFAULT_TERMINAL_THEME",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "terminal_theme",
        "name": "TerminalTheme",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 595,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 596,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 597,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 317,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 318,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "WINDOWS",
        "assigned_to": null,
        "lineno": 18
      },
      {
        "name": "ANSI_COLOR_NAMES",
        "assigned_to": null,
        "lineno": 49
      },
      {
        "name": "RE_COLOR",
        "assigned_to": "re.compile",
        "lineno": 292
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "str",
      "Console",
      "ANSI_COLOR_NAMES.items",
      "sorted",
      "Text",
      "table.add_column",
      "table.add_row",
      "Table"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "str",
        "table",
        "Console",
        "re.compile",
        "color.hex",
        "color_number",
        "color_cell",
        "ANSI_COLOR_NAMES.items",
        "sorted",
        "re.VERBOSE",
        "color.rgb",
        "table.add_column",
        "table.add_row",
        "Text",
        "Table"
      ],
      "class_instantiations": [
        "Text",
        "Console",
        "Table",
        "ANSI_COLOR_NAMES"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "functools",
        "enum",
        "re",
        "sys"
      ],
      "third_party": {
        "other": [
          "colorsys",
          "_palettes",
          "color_triplet",
          "repr",
          "terminal_theme",
          "text",
          "console",
          "table",
          "style"
        ]
      },
      "tech_stack": []
    },
    "line_count": 622
  },
  "rich/color_triplet.py": {
    "filepath": "../rich/rich/color_triplet.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "hex",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 15,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self"
        ],
        "docstring": "get the color triplet in CSS style.",
        "code": "def hex(self) -> str:\n        \"\"\"get the color triplet in CSS style.\"\"\"\n        red, green, blue = self\n        return f\"#{red:02x}{green:02x}{blue:02x}\"",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "rgb",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 21,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self"
        ],
        "docstring": "The color in RGB format.\n\nReturns:\n    str: An rgb color, e.g. ``\"rgb(100,23,255)\"``.",
        "code": "def rgb(self) -> str:\n        \"\"\"The color in RGB format.\n\n        Returns:\n            str: An rgb color, e.g. ``\"rgb(100,23,255)\"``.\n        \"\"\"\n        red, green, blue = self\n        return f\"rgb({red},{green},{blue})\"",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "normalized",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Tuple[float, float, float]",
        "lineno": 31,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self"
        ],
        "docstring": "Convert components into floats between 0 and 1.\n\nReturns:\n    Tuple[float, float, float]: A tuple of three normalized colour components.",
        "code": "def normalized(self) -> Tuple[float, float, float]:\n        \"\"\"Convert components into floats between 0 and 1.\n\n        Returns:\n            Tuple[float, float, float]: A tuple of three normalized colour components.\n        \"\"\"\n        red, green, blue = self\n        return red / 255.0, green / 255.0, blue / 255.0",
        "line_count": 8,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ColorTriplet",
        "methods": [
          "hex",
          "rgb",
          "normalized"
        ],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 4,
        "docstring": "The red, green, and blue components of a color."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 39
  },
  "rich/columns.py": {
    "filepath": "../rich/rich/columns.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderables",
            "type": "Optional[Iterable[RenderableType]]"
          },
          {
            "name": "padding",
            "type": "PaddingDimensions"
          }
        ],
        "return_type": "None",
        "lineno": 31,
        "decorators": [],
        "is_async": false,
        "calls": [
          "padding",
          "column_first",
          "expand",
          "right_to_left",
          "list",
          "title",
          "width",
          "equal"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        renderables: Optional[Iterable[RenderableType]] = None,\n        padding: PaddingDimensions = (0, 1),\n        *,\n        width: Optional[int] = None,\n        expand: bool = False,\n        equal: bool = False,\n        column_first: bool = False,\n        right_to_left: bool = False,\n        align: Optional[AlignMethod] = None,\n        title: Optional[TextType] = None,\n    ) -> None:\n        self.renderables = list(renderables or [])\n        self.width = width\n        self.padding = padding\n        self.expand = expand\n        self.equal = equal\n        self.column_first = column_first\n        self.right_to_left = right_to_left\n        self.align: Optional[AlignMethod] = align\n        self.title = title",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "add_renderable",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 54,
        "decorators": [],
        "is_async": false,
        "calls": [
          "renderable",
          "self.renderables.append"
        ],
        "docstring": "Add a renderable to the columns.\n\nArgs:\n    renderable (RenderableType): Any renderable object.",
        "code": "def add_renderable(self, renderable: RenderableType) -> None:\n        \"\"\"Add a renderable to the columns.\n\n        Args:\n            renderable (RenderableType): Any renderable object.\n        \"\"\"\n        self.renderables.append(renderable)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 62,
        "decorators": [],
        "is_async": false,
        "calls": [
          "row_count",
          "self.right_to_left",
          "cells",
          "sum",
          "render_str",
          "index",
          "Table.grid",
          "right",
          "renderable_width",
          "self.width",
          "list",
          "itemgetter",
          "widths",
          "table.add_row",
          "Padding.unpack",
          "get_measurement",
          "Measurement.get",
          "Constrain",
          "add_row",
          "max",
          "Align",
          "int",
          "console.render_str",
          "str",
          "chain.from_iterable",
          "_Align",
          "_renderables",
          "options.max_width",
          "options",
          "align",
          "self.title",
          "left",
          "renderable_widths",
          "column_count",
          "get_renderable",
          "defaultdict",
          "renderable",
          "widths.clear",
          "self.padding",
          "console",
          "iter_renderables",
          "self.align",
          "len",
          "isinstance",
          "zip",
          "range",
          "_renderable",
          "item_count",
          "self.expand",
          "renderables",
          "widths.values",
          "table.add_column"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        render_str = console.render_str\n        renderables = [\n            render_str(renderable) if isinstance(renderable, str) else renderable\n            for renderable in self.renderables\n        ]\n        if not renderables:\n            return\n        _top, right, _bottom, left = Padding.unpack(self.padding)\n        width_padding = max(left, right)\n        max_width = options.max_width\n        widths: Dict[int, int] = defaultdict(int)\n        column_count = len(renderables)\n\n        get_measurement = Measurement.get\n        renderable_widths = [\n            get_measurement(console, options, renderable).maximum\n            for renderable in renderables\n        ]\n        if self.equal:\n            renderable_widths = [max(renderable_widths)] * len(renderable_widths)\n\n        def iter_renderables(\n            column_count: int,\n        ) -> Iterable[Tuple[int, Optional[RenderableType]]]:\n            item_count = len(renderables)\n            if self.column_first:\n                width_renderables = list(zip(renderable_widths, renderables))\n\n                column_lengths: List[int] = [item_count // column_count] * column_count\n                for col_no in range(item_count % column_count):\n                    column_lengths[col_no] += 1\n\n                row_count = (item_count + column_count - 1) // column_count\n                cells = [[-1] * column_count for _ in range(row_count)]\n                row = col = 0\n                for index in range(item_count):\n                    cells[row][col] = index\n                    column_lengths[col] -= 1\n                    if column_lengths[col]:\n                        row += 1\n                    else:\n                        col += 1\n                        row = 0\n                for index in chain.from_iterable(cells):\n                    if index == -1:\n                        break\n                    yield width_renderables[index]\n            else:\n                yield from zip(renderable_widths, renderables)\n            # Pad odd elements with spaces\n            if item_count % column_count:\n                for _ in range(column_count - (item_count % column_count)):\n                    yield 0, None\n\n        table = Table.grid(padding=self.padding, collapse_padding=True, pad_edge=False)\n        table.expand = self.expand\n        table.title = self.title\n\n        if self.width is not None:\n            column_count = (max_width) // (self.width + width_padding)\n            for _ in range(column_count):\n                table.add_column(width=self.width)\n        else:\n            while column_count > 1:\n                widths.clear()\n                column_no = 0\n                for renderable_width, _ in iter_renderables(column_count):\n                    widths[column_no] = max(widths[column_no], renderable_width)\n                    total_width = sum(widths.values()) + width_padding * (\n                        len(widths) - 1\n                    )\n                    if total_width > max_width:\n                        column_count = len(widths) - 1\n                        break\n                    else:\n                        column_no = (column_no + 1) % column_count\n                else:\n                    break\n\n        get_renderable = itemgetter(1)\n        _renderables = [\n            get_renderable(_renderable)\n            for _renderable in iter_renderables(column_count)\n        ]\n        if self.equal:\n            _renderables = [\n                None\n                if renderable is None\n                else Constrain(renderable, renderable_widths[0])\n                for renderable in _renderables\n            ]\n        if self.align:\n            align = self.align\n            _Align = Align\n            _renderables = [\n                None if renderable is None else _Align(renderable, align)\n                for renderable in _renderables\n            ]\n\n        right_to_left = self.right_to_left\n        add_row = table.add_row\n        for start in range(0, len(_renderables), column_count):\n            row = _renderables[start : start + column_count]\n            if right_to_left:\n                row = row[::-1]\n            add_row(*row)\n        yield table",
        "line_count": 110,
        "needs_llm_summary": true
      },
      {
        "name": "iter_renderables",
        "args": [
          {
            "name": "column_count",
            "type": "int"
          }
        ],
        "return_type": "Iterable[Tuple[int, Optional[RenderableType]]]",
        "lineno": 86,
        "decorators": [],
        "is_async": false,
        "calls": [
          "row_count",
          "range",
          "cells",
          "chain.from_iterable",
          "index",
          "item_count",
          "renderable_widths",
          "list",
          "renderables",
          "zip",
          "len"
        ],
        "docstring": null,
        "code": "def iter_renderables(\n            column_count: int,\n        ) -> Iterable[Tuple[int, Optional[RenderableType]]]:\n            item_count = len(renderables)\n            if self.column_first:\n                width_renderables = list(zip(renderable_widths, renderables))\n\n                column_lengths: List[int] = [item_count // column_count] * column_count\n                for col_no in range(item_count % column_count):\n                    column_lengths[col_no] += 1\n\n                row_count = (item_count + column_count - 1) // column_count\n                cells = [[-1] * column_count for _ in range(row_count)]\n                row = col = 0\n                for index in range(item_count):\n                    cells[row][col] = index\n                    column_lengths[col] -= 1\n                    if column_lengths[col]:\n                        row += 1\n                    else:\n                        col += 1\n                        row = 0\n                for index in chain.from_iterable(cells):\n                    if index == -1:\n                        break\n                    yield width_renderables[index]\n            else:\n                yield from zip(renderable_widths, renderables)\n            # Pad odd elements with spaces\n            if item_count % column_count:\n                for _ in range(column_count - (item_count % column_count)):\n                    yield 0, None",
        "line_count": 32,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Columns",
        "methods": [
          "__init__",
          "add_renderable",
          "__rich_console__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 16,
        "docstring": "Display renderables in neat columns.\n\nArgs:\n    renderables (Iterable[RenderableType]): Any number of Rich renderables (including str).\n    width (int, optional): The desired width of the columns, or None to auto detect. Defaults to None.\n    padding (PaddingDimensions, optional): Optional padding around cells. Defaults to (0, 1).\n    expand (bool, optional): Expand columns to full width. Defaults to False.\n    equal (bool, optional): Arrange in to equal sized columns. Defaults to False.\n    column_first (bool, optional): Align items from top to bottom (rather than left to right). Defaults to False.\n    right_to_left (bool, optional): Start column from right hand side. Defaults to False.\n    align (str, optional): Align value (\"left\", \"right\", or \"center\") or None for default. Defaults to None.\n    title (TextType, optional): Optional title for Columns."
      }
    ],
    "imports": [
      {
        "module": "collections",
        "name": "defaultdict",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "itertools",
        "name": "chain",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "operator",
        "name": "itemgetter",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "Align",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "AlignMethod",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "constrain",
        "name": "Constrain",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "padding",
        "name": "Padding",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "padding",
        "name": "PaddingDimensions",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 175,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "enumerate",
      "console.rule",
      "Columns",
      "Console",
      "sorted",
      "os.listdir"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "files",
        "enumerate",
        "Columns",
        "console.rule",
        "Console",
        "sorted",
        "columns",
        "os.listdir"
      ],
      "class_instantiations": [
        "Console",
        "Columns"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "itertools",
        "typing",
        "os",
        "collections"
      ],
      "third_party": {
        "other": [
          "operator",
          "align",
          "console",
          "constrain",
          "measure",
          "padding",
          "table",
          "text",
          "jupyter"
        ]
      },
      "tech_stack": []
    },
    "line_count": 188
  },
  "rich/console.py": {
    "filepath": "../rich/rich/console.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "group",
        "args": [
          {
            "name": "fit",
            "type": "bool"
          }
        ],
        "return_type": "Callable[Ellipsis, Callable[Ellipsis, Group]]",
        "lineno": 489,
        "decorators": [],
        "is_async": false,
        "calls": [
          "kwargs",
          "method",
          "Group",
          "fit",
          "wraps"
        ],
        "docstring": "A decorator that turns an iterable of renderables in to a group.\n\nArgs:\n    fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True.",
        "code": "def group(fit: bool = True) -> Callable[..., Callable[..., Group]]:\n    \"\"\"A decorator that turns an iterable of renderables in to a group.\n\n    Args:\n        fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True.\n    \"\"\"\n\n    def decorator(\n        method: Callable[..., Iterable[RenderableType]],\n    ) -> Callable[..., Group]:\n        \"\"\"Convert a method that returns an iterable of renderables in to a Group.\"\"\"\n\n        @wraps(method)\n        def _replace(*args: Any, **kwargs: Any) -> Group:\n            renderables = method(*args, **kwargs)\n            return Group(*renderables, fit=fit)\n\n        return _replace\n\n    return decorator",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "_is_jupyter",
        "args": [],
        "return_type": "bool",
        "lineno": 511,
        "decorators": [],
        "is_async": false,
        "calls": [
          "str",
          "ipython.__class__",
          "get_ipython",
          "ipython.__class__.__name__",
          "os.getenv"
        ],
        "docstring": "Check if we're running in a Jupyter notebook.",
        "code": "def _is_jupyter() -> bool:  # pragma: no cover\n    \"\"\"Check if we're running in a Jupyter notebook.\"\"\"\n    try:\n        get_ipython  # type: ignore[name-defined]\n    except NameError:\n        return False\n    ipython = get_ipython()  # type: ignore[name-defined]\n    shell = ipython.__class__.__name__\n    if (\n        \"google.colab\" in str(ipython.__class__)\n        or os.getenv(\"DATABRICKS_RUNTIME_VERSION\")\n        or shell == \"ZMQInteractiveShell\"\n    ):\n        return True  # Jupyter notebook or qtconsole\n    elif shell == \"TerminalInteractiveShell\":\n        return False  # Terminal running IPython\n    else:\n        return False",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "get_windows_console_features",
        "args": [],
        "return_type": "WindowsConsoleFeatures",
        "lineno": 572,
        "decorators": [],
        "is_async": false,
        "calls": [
          "get_windows_console_features"
        ],
        "docstring": null,
        "code": "def get_windows_console_features() -> \"WindowsConsoleFeatures\":  # pragma: no cover\n    global _windows_console_features\n    if _windows_console_features is not None:\n        return _windows_console_features\n    from ._windows import get_windows_console_features\n\n    _windows_console_features = get_windows_console_features()\n    return _windows_console_features",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "detect_legacy_windows",
        "args": [],
        "return_type": "bool",
        "lineno": 582,
        "decorators": [],
        "is_async": false,
        "calls": [
          "get_windows_console_features"
        ],
        "docstring": "Detect legacy Windows.",
        "code": "def detect_legacy_windows() -> bool:\n    \"\"\"Detect legacy Windows.\"\"\"\n    return WINDOWS and not get_windows_console_features().vt",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_svg_hash",
        "args": [
          {
            "name": "svg_main_code",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 2615,
        "decorators": [],
        "is_async": false,
        "calls": [
          "zlib.adler32",
          "str",
          "svg_main_code.encode"
        ],
        "docstring": "Returns a unique hash for the given SVG main code.\n\nArgs:\n    svg_main_code (str): The content we're going to inject in the SVG envelope.\n\nReturns:\n    str: a hash of the given content",
        "code": "def _svg_hash(svg_main_code: str) -> str:\n    \"\"\"Returns a unique hash for the given SVG main code.\n\n    Args:\n        svg_main_code (str): The content we're going to inject in the SVG envelope.\n\n    Returns:\n        str: a hash of the given content\n    \"\"\"\n    return str(zlib.adler32(svg_main_code.encode()))",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "ascii_only",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 149,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.encoding.startswith"
        ],
        "docstring": "Check if renderables should use ascii only.",
        "code": "def ascii_only(self) -> bool:\n        \"\"\"Check if renderables should use ascii only.\"\"\"\n        return not self.encoding.startswith(\"utf\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "copy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ConsoleOptions",
        "lineno": 153,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ConsoleOptions.__new__",
          "ConsoleOptions",
          "self.__dict__.copy"
        ],
        "docstring": "Return a copy of the options.\n\nReturns:\n    ConsoleOptions: a copy of self.",
        "code": "def copy(self) -> \"ConsoleOptions\":\n        \"\"\"Return a copy of the options.\n\n        Returns:\n            ConsoleOptions: a copy of self.\n        \"\"\"\n        options: ConsoleOptions = ConsoleOptions.__new__(ConsoleOptions)\n        options.__dict__ = self.__dict__.copy()\n        return options",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ConsoleOptions",
        "lineno": 163,
        "decorators": [],
        "is_async": false,
        "calls": [
          "no_wrap",
          "isinstance",
          "markup",
          "overflow",
          "highlight",
          "height",
          "max_width",
          "width",
          "justify",
          "NoChange",
          "max",
          "min_width",
          "self.copy"
        ],
        "docstring": "Update values, return a copy.",
        "code": "def update(\n        self,\n        *,\n        width: Union[int, NoChange] = NO_CHANGE,\n        min_width: Union[int, NoChange] = NO_CHANGE,\n        max_width: Union[int, NoChange] = NO_CHANGE,\n        justify: Union[Optional[JustifyMethod], NoChange] = NO_CHANGE,\n        overflow: Union[Optional[OverflowMethod], NoChange] = NO_CHANGE,\n        no_wrap: Union[Optional[bool], NoChange] = NO_CHANGE,\n        highlight: Union[Optional[bool], NoChange] = NO_CHANGE,\n        markup: Union[Optional[bool], NoChange] = NO_CHANGE,\n        height: Union[Optional[int], NoChange] = NO_CHANGE,\n    ) -> \"ConsoleOptions\":\n        \"\"\"Update values, return a copy.\"\"\"\n        options = self.copy()\n        if not isinstance(width, NoChange):\n            options.min_width = options.max_width = max(0, width)\n        if not isinstance(min_width, NoChange):\n            options.min_width = min_width\n        if not isinstance(max_width, NoChange):\n            options.max_width = max_width\n        if not isinstance(justify, NoChange):\n            options.justify = justify\n        if not isinstance(overflow, NoChange):\n            options.overflow = overflow\n        if not isinstance(no_wrap, NoChange):\n            options.no_wrap = no_wrap\n        if not isinstance(highlight, NoChange):\n            options.highlight = highlight\n        if not isinstance(markup, NoChange):\n            options.markup = markup\n        if not isinstance(height, NoChange):\n            if height is not None:\n                options.max_height = height\n            options.height = None if height is None else max(0, height)\n        return options",
        "line_count": 36,
        "needs_llm_summary": true
      },
      {
        "name": "update_width",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "ConsoleOptions",
        "lineno": 200,
        "decorators": [],
        "is_async": false,
        "calls": [
          "max",
          "self.copy",
          "width"
        ],
        "docstring": "Update just the width, return a copy.\n\nArgs:\n    width (int): New width (sets both min_width and max_width)\n\nReturns:\n    ~ConsoleOptions: New console options instance.",
        "code": "def update_width(self, width: int) -> \"ConsoleOptions\":\n        \"\"\"Update just the width, return a copy.\n\n        Args:\n            width (int): New width (sets both min_width and max_width)\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.min_width = options.max_width = max(0, width)\n        return options",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "update_height",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "height",
            "type": "int"
          }
        ],
        "return_type": "ConsoleOptions",
        "lineno": 213,
        "decorators": [],
        "is_async": false,
        "calls": [
          "height",
          "self.copy"
        ],
        "docstring": "Update the height, and return a copy.\n\nArgs:\n    height (int): New height\n\nReturns:\n    ~ConsoleOptions: New Console options instance.",
        "code": "def update_height(self, height: int) -> \"ConsoleOptions\":\n        \"\"\"Update the height, and return a copy.\n\n        Args:\n            height (int): New height\n\n        Returns:\n            ~ConsoleOptions: New Console options instance.\n        \"\"\"\n        options = self.copy()\n        options.max_height = options.height = height\n        return options",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "reset_height",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ConsoleOptions",
        "lineno": 226,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.copy"
        ],
        "docstring": "Return a copy of the options with height set to ``None``.\n\nReturns:\n    ~ConsoleOptions: New console options instance.",
        "code": "def reset_height(self) -> \"ConsoleOptions\":\n        \"\"\"Return a copy of the options with height set to ``None``.\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.height = None\n        return options",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "update_dimensions",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "height",
            "type": "int"
          }
        ],
        "return_type": "ConsoleOptions",
        "lineno": 236,
        "decorators": [],
        "is_async": false,
        "calls": [
          "max",
          "width",
          "height",
          "self.copy"
        ],
        "docstring": "Update the width and height, and return a copy.\n\nArgs:\n    width (int): New width (sets both min_width and max_width).\n    height (int): New height.\n\nReturns:\n    ~ConsoleOptions: New console options instance.",
        "code": "def update_dimensions(self, width: int, height: int) -> \"ConsoleOptions\":\n        \"\"\"Update the width and height, and return a copy.\n\n        Args:\n            width (int): New width (sets both min_width and max_width).\n            height (int): New height.\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.min_width = options.max_width = max(0, width)\n        options.height = options.max_height = height\n        return options",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Union[ConsoleRenderable, RichCast, str]",
        "lineno": 256,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich__(\n        self,\n    ) -> Union[\"ConsoleRenderable\", \"RichCast\", str]:  # pragma: no cover\n        ...",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 266,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":  # pragma: no cover\n        ...",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "count",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 289,
        "decorators": [],
        "is_async": false,
        "calls": [
          "count"
        ],
        "docstring": null,
        "code": "def __init__(self, count: int = 1) -> None:\n        self.count = count",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 292,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Iterable[Segment]:\n        yield Segment(\"\\n\" * self.count)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lines",
            "type": "List[List[Segment]]"
          },
          {
            "name": "x",
            "type": "int"
          },
          {
            "name": "y",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 301,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "x",
          "y"
        ],
        "docstring": null,
        "code": "def __init__(self, lines: List[List[Segment]], x: int, y: int) -> None:\n        self._lines = lines\n        self.x = x\n        self.y = y",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 306,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "Control.move_to",
          "self.x",
          "move_to",
          "self.y",
          "self._lines",
          "offset",
          "x"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: ConsoleOptions\n    ) -> RenderResult:\n        x = self.x\n        move_to = Control.move_to\n        for offset, line in enumerate(self._lines, self.y):\n            yield move_to(x, offset)\n            yield from line",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          }
        ],
        "return_type": "None",
        "lineno": 324,
        "decorators": [],
        "is_async": false,
        "calls": [
          "console"
        ],
        "docstring": null,
        "code": "def __init__(self, console: \"Console\") -> None:\n        self._console = console\n        self._result: Optional[str] = None",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Capture",
        "lineno": 328,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._console.begin_capture"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> \"Capture\":\n        self._console.begin_capture()\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 332,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._console.end_capture"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self._result = self._console.end_capture()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "get",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 340,
        "decorators": [],
        "is_async": false,
        "calls": [
          "CaptureError"
        ],
        "docstring": "Get the result of the capture.",
        "code": "def get(self) -> str:\n        \"\"\"Get the result of the capture.\"\"\"\n        if self._result is None:\n            raise CaptureError(\n                \"Capture result is not available until context manager exits.\"\n            )\n        return self._result",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "theme",
            "type": "Theme"
          },
          {
            "name": "inherit",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 352,
        "decorators": [],
        "is_async": false,
        "calls": [
          "theme",
          "inherit",
          "console"
        ],
        "docstring": null,
        "code": "def __init__(self, console: \"Console\", theme: Theme, inherit: bool = True) -> None:\n        self.console = console\n        self.theme = theme\n        self.inherit = inherit",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ThemeContext",
        "lineno": 357,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.theme",
          "self.console.push_theme"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> \"ThemeContext\":\n        self.console.push_theme(self.theme)\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 361,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.console.pop_theme"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.console.pop_theme()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "pager",
            "type": "Optional[Pager]"
          },
          {
            "name": "styles",
            "type": "bool"
          },
          {
            "name": "links",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 373,
        "decorators": [],
        "is_async": false,
        "calls": [
          "styles",
          "console",
          "links",
          "SystemPager"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        console: \"Console\",\n        pager: Optional[Pager] = None,\n        styles: bool = False,\n        links: bool = False,\n    ) -> None:\n        self._console = console\n        self.pager = SystemPager() if pager is None else pager\n        self.styles = styles\n        self.links = links",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "PagerContext",
        "lineno": 385,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._console._enter_buffer"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> \"PagerContext\":\n        self._console._enter_buffer()\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 389,
        "decorators": [],
        "is_async": false,
        "calls": [
          "content",
          "self.pager.show",
          "self._console._exit_buffer",
          "segments",
          "Segment.strip_styles",
          "self._console._render_buffer",
          "Segment.strip_links"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        if exc_type is None:\n            with self._console._lock:\n                buffer: List[Segment] = self._console._buffer[:]\n                del self._console._buffer[:]\n                segments: Iterable[Segment] = buffer\n                if not self.styles:\n                    segments = Segment.strip_styles(segments)\n                elif not self.links:\n                    segments = Segment.strip_links(segments)\n                content = self._console._render_buffer(segments)\n            self.pager.show(content)\n        self._console._exit_buffer()",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "hide_cursor",
            "type": "bool"
          },
          {
            "name": "style",
            "type": "StyleType"
          }
        ],
        "return_type": "None",
        "lineno": 412,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Screen",
          "style",
          "hide_cursor",
          "console"
        ],
        "docstring": null,
        "code": "def __init__(\n        self, console: \"Console\", hide_cursor: bool, style: StyleType = \"\"\n    ) -> None:\n        self.console = console\n        self.hide_cursor = hide_cursor\n        self.screen = Screen(style=style)\n        self._changed = False",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 420,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "self.screen",
          "Group",
          "renderables",
          "self.console.print",
          "len"
        ],
        "docstring": "Update the screen.\n\nArgs:\n    renderable (RenderableType, optional): Optional renderable to replace current renderable,\n        or None for no change. Defaults to None.\n    style: (Style, optional): Replacement style, or None for no change. Defaults to None.",
        "code": "def update(\n        self, *renderables: RenderableType, style: Optional[StyleType] = None\n    ) -> None:\n        \"\"\"Update the screen.\n\n        Args:\n            renderable (RenderableType, optional): Optional renderable to replace current renderable,\n                or None for no change. Defaults to None.\n            style: (Style, optional): Replacement style, or None for no change. Defaults to None.\n        \"\"\"\n        if renderables:\n            self.screen.renderable = (\n                Group(*renderables) if len(renderables) > 1 else renderables[0]\n            )\n        if style is not None:\n            self.screen.style = style\n        self.console.print(self.screen, end=\"\")",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ScreenContext",
        "lineno": 438,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.console.show_cursor",
          "self.console.set_alt_screen"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> \"ScreenContext\":\n        self._changed = self.console.set_alt_screen(True)\n        if self._changed and self.hide_cursor:\n            self.console.show_cursor(False)\n        return self",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 444,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.console.show_cursor",
          "self.console.set_alt_screen"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        if self._changed:\n            self.console.set_alt_screen(False)\n            if self.hide_cursor:\n                self.console.show_cursor(True)",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 464,
        "decorators": [],
        "is_async": false,
        "calls": [
          "renderables",
          "fit"
        ],
        "docstring": null,
        "code": "def __init__(self, *renderables: \"RenderableType\", fit: bool = True) -> None:\n        self._renderables = renderables\n        self.fit = fit\n        self._render: Optional[List[RenderableType]] = None",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "renderables",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "List[RenderableType]",
        "lineno": 470,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "list",
          "self._renderables"
        ],
        "docstring": null,
        "code": "def renderables(self) -> List[\"RenderableType\"]:\n        if self._render is None:\n            self._render = list(self._renderables)\n        return self._render",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 475,
        "decorators": [],
        "is_async": false,
        "calls": [
          "measure_renderables",
          "options",
          "options.max_width",
          "Measurement",
          "self.renderables",
          "console"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        if self.fit:\n            return measure_renderables(console, options, self.renderables)\n        else:\n            return Measurement(options.max_width, options.max_width)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 483,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> RenderResult:\n        yield from self.renderables",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "decorator",
        "args": [
          {
            "name": "method",
            "type": "Callable[Ellipsis, Iterable[RenderableType]]"
          }
        ],
        "return_type": "Callable[Ellipsis, Group]",
        "lineno": 496,
        "decorators": [],
        "is_async": false,
        "calls": [
          "kwargs",
          "method",
          "Group",
          "fit",
          "wraps"
        ],
        "docstring": "Convert a method that returns an iterable of renderables in to a Group.",
        "code": "def decorator(\n        method: Callable[..., Iterable[RenderableType]],\n    ) -> Callable[..., Group]:\n        \"\"\"Convert a method that returns an iterable of renderables in to a Group.\"\"\"\n\n        @wraps(method)\n        def _replace(*args: Any, **kwargs: Any) -> Group:\n            renderables = method(*args, **kwargs)\n            return Group(*renderables, fit=fit)\n\n        return _replace",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "process_renderables",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderables",
            "type": "List[ConsoleRenderable]"
          }
        ],
        "return_type": "List[ConsoleRenderable]",
        "lineno": 554,
        "decorators": [
          {
            "name": "abstractmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Called with a list of objects to render.\n\nThis method can return a new list of renderables, or modify and return the same list.\n\nArgs:\n    renderables (List[ConsoleRenderable]): A number of renderable objects.\n\nReturns:\n    List[ConsoleRenderable]: A replacement list of renderables.",
        "code": "def process_renderables(\n        self, renderables: List[ConsoleRenderable]\n    ) -> List[ConsoleRenderable]:\n        \"\"\"Called with a list of objects to render.\n\n        This method can return a new list of renderables, or modify and return the same list.\n\n        Args:\n            renderables (List[ConsoleRenderable]): A number of renderable objects.\n\n        Returns:\n            List[ConsoleRenderable]: A replacement list of renderables.\n        \"\"\"",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 625,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "markup",
          "style",
          "highlight",
          "_environ",
          "height",
          "log_time",
          "threading.RLock",
          "tab_size",
          "self._environ.get",
          "emoji",
          "JUPYTER_DEFAULT_COLUMNS",
          "stderr",
          "self._detect_color_system",
          "ReprHighlighter",
          "LogRender",
          "file",
          "log_path",
          "int",
          "force_terminal",
          "safe_box",
          "log_time_format",
          "ThemeStack",
          "jupyter_lines",
          "width",
          "ConsoleThreadLocals",
          "lines.isdigit",
          "_is_jupyter",
          "record",
          "columns.isdigit",
          "quiet",
          "detect_legacy_windows",
          "jupyter_columns.isdigit",
          "jupyter_columns",
          "soft_wrap",
          "JUPYTER_DEFAULT_LINES",
          "columns",
          "jupyter_lines.isdigit"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        *,\n        color_system: Optional[\n            Literal[\"auto\", \"standard\", \"256\", \"truecolor\", \"windows\"]\n        ] = \"auto\",\n        force_terminal: Optional[bool] = None,\n        force_jupyter: Optional[bool] = None,\n        force_interactive: Optional[bool] = None,\n        soft_wrap: bool = False,\n        theme: Optional[Theme] = None,\n        stderr: bool = False,\n        file: Optional[IO[str]] = None,\n        quiet: bool = False,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        style: Optional[StyleType] = None,\n        no_color: Optional[bool] = None,\n        tab_size: int = 8,\n        record: bool = False,\n        markup: bool = True,\n        emoji: bool = True,\n        emoji_variant: Optional[EmojiVariant] = None,\n        highlight: bool = True,\n        log_time: bool = True,\n        log_path: bool = True,\n        log_time_format: Union[str, FormatTimeCallable] = \"[%X]\",\n        highlighter: Optional[\"HighlighterType\"] = ReprHighlighter(),\n        legacy_windows: Optional[bool] = None,\n        safe_box: bool = True,\n        get_datetime: Optional[Callable[[], datetime]] = None,\n        get_time: Optional[Callable[[], float]] = None,\n        _environ: Optional[Mapping[str, str]] = None,\n    ):\n        # Copy of os.environ allows us to replace it for testing\n        if _environ is not None:\n            self._environ = _environ\n\n        self.is_jupyter = _is_jupyter() if force_jupyter is None else force_jupyter\n        if self.is_jupyter:\n            if width is None:\n                jupyter_columns = self._environ.get(\"JUPYTER_COLUMNS\")\n                if jupyter_columns is not None and jupyter_columns.isdigit():\n                    width = int(jupyter_columns)\n                else:\n                    width = JUPYTER_DEFAULT_COLUMNS\n            if height is None:\n                jupyter_lines = self._environ.get(\"JUPYTER_LINES\")\n                if jupyter_lines is not None and jupyter_lines.isdigit():\n                    height = int(jupyter_lines)\n                else:\n                    height = JUPYTER_DEFAULT_LINES\n\n        self.tab_size = tab_size\n        self.record = record\n        self._markup = markup\n        self._emoji = emoji\n        self._emoji_variant: Optional[EmojiVariant] = emoji_variant\n        self._highlight = highlight\n        self.legacy_windows: bool = (\n            (detect_legacy_windows() and not self.is_jupyter)\n            if legacy_windows is None\n            else legacy_windows\n        )\n\n        if width is None:\n            columns = self._environ.get(\"COLUMNS\")\n            if columns is not None and columns.isdigit():\n                width = int(columns) - self.legacy_windows\n        if height is None:\n            lines = self._environ.get(\"LINES\")\n            if lines is not None and lines.isdigit():\n                height = int(lines)\n\n        self.soft_wrap = soft_wrap\n        self._width = width\n        self._height = height\n\n        self._color_system: Optional[ColorSystem]\n\n        self._force_terminal = None\n        if force_terminal is not None:\n            self._force_terminal = force_terminal\n\n        self._file = file\n        self.quiet = quiet\n        self.stderr = stderr\n\n        if color_system is None:\n            self._color_system = None\n        elif color_system == \"auto\":\n            self._color_system = self._detect_color_system()\n        else:\n            self._color_system = COLOR_SYSTEMS[color_system]\n\n        self._lock = threading.RLock()\n        self._log_render = LogRender(\n            show_time=log_time,\n            show_path=log_path,\n            time_format=log_time_format,\n        )\n        self.highlighter: HighlighterType = highlighter or _null_highlighter\n        self.safe_box = safe_box\n        self.get_datetime = get_datetime or datetime.now\n        self.get_time = get_time or monotonic\n        self.style = style\n        self.no_color = (\n            no_color\n            if no_color is not None\n            else self._environ.get(\"NO_COLOR\", \"\") != \"\"\n        )\n        if force_interactive is None:\n            tty_interactive = self._environ.get(\"TTY_INTERACTIVE\", None)\n            if tty_interactive is not None:\n                if tty_interactive == \"0\":\n                    force_interactive = False\n                elif tty_interactive == \"1\":\n                    force_interactive = True\n\n        self.is_interactive = (\n            (self.is_terminal and not self.is_dumb_terminal)\n            if force_interactive is None\n            else force_interactive\n        )\n\n        self._record_buffer_lock = threading.RLock()\n        self._thread_locals = ConsoleThreadLocals(\n            theme_stack=ThemeStack(themes.DEFAULT if theme is None else theme)\n        )\n        self._record_buffer: List[Segment] = []\n        self._render_hooks: List[RenderHook] = []\n        self._live_stack: List[Live] = []\n        self._is_alt_screen = False",
        "line_count": 133,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 759,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"<console width={self.width} {self._color_system!s}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "file",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "IO[str]",
        "lineno": 763,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "NULL_FILE",
          "file",
          "getattr"
        ],
        "docstring": "Get the file object to write to.",
        "code": "def file(self) -> IO[str]:\n        \"\"\"Get the file object to write to.\"\"\"\n        file = self._file or (sys.stderr if self.stderr else sys.stdout)\n        file = getattr(file, \"rich_proxied_file\", file)\n        if file is None:\n            file = NULL_FILE\n        return file",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "file",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "new_file",
            "type": "IO[str]"
          }
        ],
        "return_type": "None",
        "lineno": 772,
        "decorators": [
          {
            "name": "file.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "new_file"
        ],
        "docstring": "Set a new file object.",
        "code": "def file(self, new_file: IO[str]) -> None:\n        \"\"\"Set a new file object.\"\"\"\n        self._file = new_file",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_buffer",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "List[Segment]",
        "lineno": 777,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get a thread local buffer.",
        "code": "def _buffer(self) -> List[Segment]:\n        \"\"\"Get a thread local buffer.\"\"\"\n        return self._thread_locals.buffer",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_buffer_index",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 782,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get a thread local buffer.",
        "code": "def _buffer_index(self) -> int:\n        \"\"\"Get a thread local buffer.\"\"\"\n        return self._thread_locals.buffer_index",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_buffer_index",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 787,
        "decorators": [
          {
            "name": "_buffer_index.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "value"
        ],
        "docstring": null,
        "code": "def _buffer_index(self, value: int) -> None:\n        self._thread_locals.buffer_index = value",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "_theme_stack",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ThemeStack",
        "lineno": 791,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get the thread local theme stack.",
        "code": "def _theme_stack(self) -> ThemeStack:\n        \"\"\"Get the thread local theme stack.\"\"\"\n        return self._thread_locals.theme_stack",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_detect_color_system",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[ColorSystem]",
        "lineno": 795,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.strip",
          "ColorSystem.STANDARD",
          "self._environ.get",
          "_TERM_COLORS.get",
          "unknown.lower",
          "get_windows_console_features",
          "colors",
          "term.rpartition"
        ],
        "docstring": "Detect color system from env vars.",
        "code": "def _detect_color_system(self) -> Optional[ColorSystem]:\n        \"\"\"Detect color system from env vars.\"\"\"\n        if self.is_jupyter:\n            return ColorSystem.TRUECOLOR\n        if not self.is_terminal or self.is_dumb_terminal:\n            return None\n        if WINDOWS:  # pragma: no cover\n            if self.legacy_windows:  # pragma: no cover\n                return ColorSystem.WINDOWS\n            windows_console_features = get_windows_console_features()\n            return (\n                ColorSystem.TRUECOLOR\n                if windows_console_features.truecolor\n                else ColorSystem.EIGHT_BIT\n            )\n        else:\n            color_term = self._environ.get(\"COLORTERM\", \"\").strip().lower()\n            if color_term in (\"truecolor\", \"24bit\"):\n                return ColorSystem.TRUECOLOR\n            term = self._environ.get(\"TERM\", \"\").strip().lower()\n            _term_name, _hyphen, colors = term.rpartition(\"-\")\n            color_system = _TERM_COLORS.get(colors, ColorSystem.STANDARD)\n            return color_system",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "_enter_buffer",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 819,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Enter in to a buffer context, and buffer all output.",
        "code": "def _enter_buffer(self) -> None:\n        \"\"\"Enter in to a buffer context, and buffer all output.\"\"\"\n        self._buffer_index += 1",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_exit_buffer",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 823,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._check_buffer"
        ],
        "docstring": "Leave buffer context, and render content if required.",
        "code": "def _exit_buffer(self) -> None:\n        \"\"\"Leave buffer context, and render content if required.\"\"\"\n        self._buffer_index -= 1\n        self._check_buffer()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "set_live",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "live",
            "type": "Live"
          }
        ],
        "return_type": "bool",
        "lineno": 828,
        "decorators": [],
        "is_async": false,
        "calls": [
          "live",
          "self._live_stack.append",
          "self._live_stack",
          "len"
        ],
        "docstring": "Set Live instance. Used by Live context manager (no need to call directly).\n\nArgs:\n    live (Live): Live instance using this Console.\n\nReturns:\n    Boolean that indicates if the live is the topmost of the stack.\n\nRaises:\n    errors.LiveError: If this Console has a Live context currently active.",
        "code": "def set_live(self, live: \"Live\") -> bool:\n        \"\"\"Set Live instance. Used by Live context manager (no need to call directly).\n\n        Args:\n            live (Live): Live instance using this Console.\n\n        Returns:\n            Boolean that indicates if the live is the topmost of the stack.\n\n        Raises:\n            errors.LiveError: If this Console has a Live context currently active.\n        \"\"\"\n        with self._lock:\n            self._live_stack.append(live)\n            return len(self._live_stack) == 1",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "clear_live",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 844,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._live_stack.pop"
        ],
        "docstring": "Clear the Live instance. Used by the Live context manager (no need to call directly).",
        "code": "def clear_live(self) -> None:\n        \"\"\"Clear the Live instance. Used by the Live context manager (no need to call directly).\"\"\"\n        with self._lock:\n            self._live_stack.pop()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "push_render_hook",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "hook",
            "type": "RenderHook"
          }
        ],
        "return_type": "None",
        "lineno": 849,
        "decorators": [],
        "is_async": false,
        "calls": [
          "hook",
          "self._render_hooks.append"
        ],
        "docstring": "Add a new render hook to the stack.\n\nArgs:\n    hook (RenderHook): Render hook instance.",
        "code": "def push_render_hook(self, hook: RenderHook) -> None:\n        \"\"\"Add a new render hook to the stack.\n\n        Args:\n            hook (RenderHook): Render hook instance.\n        \"\"\"\n        with self._lock:\n            self._render_hooks.append(hook)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "pop_render_hook",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 858,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._render_hooks.pop"
        ],
        "docstring": "Pop the last renderhook from the stack.",
        "code": "def pop_render_hook(self) -> None:\n        \"\"\"Pop the last renderhook from the stack.\"\"\"\n        with self._lock:\n            self._render_hooks.pop()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Console",
        "lineno": 863,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._enter_buffer"
        ],
        "docstring": "Own context manager to enter buffer context.",
        "code": "def __enter__(self) -> \"Console\":\n        \"\"\"Own context manager to enter buffer context.\"\"\"\n        self._enter_buffer()\n        return self",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Any"
          },
          {
            "name": "exc_value",
            "type": "Any"
          },
          {
            "name": "traceback",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 868,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._exit_buffer"
        ],
        "docstring": "Exit buffer context.",
        "code": "def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        \"\"\"Exit buffer context.\"\"\"\n        self._exit_buffer()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "begin_capture",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 872,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._enter_buffer"
        ],
        "docstring": "Begin capturing console output. Call :meth:`end_capture` to exit capture mode and return output.",
        "code": "def begin_capture(self) -> None:\n        \"\"\"Begin capturing console output. Call :meth:`end_capture` to exit capture mode and return output.\"\"\"\n        self._enter_buffer()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "end_capture",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 876,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._exit_buffer",
          "self._buffer",
          "self._render_buffer"
        ],
        "docstring": "End capture mode and return captured string.\n\nReturns:\n    str: Console output.",
        "code": "def end_capture(self) -> str:\n        \"\"\"End capture mode and return captured string.\n\n        Returns:\n            str: Console output.\n        \"\"\"\n        render_result = self._render_buffer(self._buffer)\n        del self._buffer[:]\n        self._exit_buffer()\n        return render_result",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "push_theme",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "theme",
            "type": "Theme"
          }
        ],
        "return_type": "None",
        "lineno": 887,
        "decorators": [],
        "is_async": false,
        "calls": [
          "theme",
          "inherit",
          "self._theme_stack.push_theme"
        ],
        "docstring": "Push a new theme on to the top of the stack, replacing the styles from the previous theme.\nGenerally speaking, you should call :meth:`~rich.console.Console.use_theme` to get a context manager, rather\nthan calling this method directly.\n\nArgs:\n    theme (Theme): A theme instance.\n    inherit (bool, optional): Inherit existing styles. Defaults to True.",
        "code": "def push_theme(self, theme: Theme, *, inherit: bool = True) -> None:\n        \"\"\"Push a new theme on to the top of the stack, replacing the styles from the previous theme.\n        Generally speaking, you should call :meth:`~rich.console.Console.use_theme` to get a context manager, rather\n        than calling this method directly.\n\n        Args:\n            theme (Theme): A theme instance.\n            inherit (bool, optional): Inherit existing styles. Defaults to True.\n        \"\"\"\n        self._theme_stack.push_theme(theme, inherit=inherit)",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "pop_theme",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 898,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._theme_stack.pop_theme"
        ],
        "docstring": "Remove theme from top of stack, restoring previous theme.",
        "code": "def pop_theme(self) -> None:\n        \"\"\"Remove theme from top of stack, restoring previous theme.\"\"\"\n        self._theme_stack.pop_theme()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "use_theme",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "theme",
            "type": "Theme"
          }
        ],
        "return_type": "ThemeContext",
        "lineno": 902,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ThemeContext",
          "inherit",
          "theme",
          "self"
        ],
        "docstring": "Use a different theme for the duration of the context manager.\n\nArgs:\n    theme (Theme): Theme instance to user.\n    inherit (bool, optional): Inherit existing console styles. Defaults to True.\n\nReturns:\n    ThemeContext: [description]",
        "code": "def use_theme(self, theme: Theme, *, inherit: bool = True) -> ThemeContext:\n        \"\"\"Use a different theme for the duration of the context manager.\n\n        Args:\n            theme (Theme): Theme instance to user.\n            inherit (bool, optional): Inherit existing console styles. Defaults to True.\n\n        Returns:\n            ThemeContext: [description]\n        \"\"\"\n        return ThemeContext(self, theme, inherit)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "color_system",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[str]",
        "lineno": 915,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get color system string.\n\nReturns:\n    Optional[str]: \"standard\", \"256\" or \"truecolor\".",
        "code": "def color_system(self) -> Optional[str]:\n        \"\"\"Get color system string.\n\n        Returns:\n            Optional[str]: \"standard\", \"256\" or \"truecolor\".\n        \"\"\"\n\n        if self._color_system is not None:\n            return _COLOR_SYSTEMS_NAMES[self._color_system]\n        else:\n            return None",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "encoding",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 928,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.file",
          "getattr",
          "unknown.lower"
        ],
        "docstring": "Get the encoding of the console file, e.g. ``\"utf-8\"``.\n\nReturns:\n    str: A standard encoding string.",
        "code": "def encoding(self) -> str:\n        \"\"\"Get the encoding of the console file, e.g. ``\"utf-8\"``.\n\n        Returns:\n            str: A standard encoding string.\n        \"\"\"\n        return (getattr(self.file, \"encoding\", \"utf-8\") or \"utf-8\").lower()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "is_terminal",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 937,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "getattr",
          "sys.stdin",
          "isatty",
          "sys.stdin.__module__.startswith",
          "self._environ",
          "environ.get",
          "hasattr",
          "self.file"
        ],
        "docstring": "Check if the console is writing to a terminal.\n\nReturns:\n    bool: True if the console writing to a device capable of\n        understanding escape sequences, otherwise False.",
        "code": "def is_terminal(self) -> bool:\n        \"\"\"Check if the console is writing to a terminal.\n\n        Returns:\n            bool: True if the console writing to a device capable of\n                understanding escape sequences, otherwise False.\n        \"\"\"\n        # If dev has explicitly set this value, return it\n        if self._force_terminal is not None:\n            return self._force_terminal\n\n        # Fudge for Idle\n        if hasattr(sys.stdin, \"__module__\") and sys.stdin.__module__.startswith(\n            \"idlelib\"\n        ):\n            # Return False for Idle which claims to be a tty but can't handle ansi codes\n            return False\n\n        if self.is_jupyter:\n            # return False for Jupyter, which may have FORCE_COLOR set\n            return False\n\n        environ = self._environ\n\n        tty_compatible = environ.get(\"TTY_COMPATIBLE\", \"\")\n        # 0 indicates device is not tty compatible\n        if tty_compatible == \"0\":\n            return False\n        # 1 indicates device is tty compatible\n        if tty_compatible == \"1\":\n            return True\n\n        # https://force-color.org/\n        force_color = environ.get(\"FORCE_COLOR\")\n        if force_color is not None:\n            return force_color != \"\"\n\n        # Any other value defaults to auto detect\n        isatty: Optional[Callable[[], bool]] = getattr(self.file, \"isatty\", None)\n        try:\n            return False if isatty is None else isatty()\n        except ValueError:\n            # in some situation (at the end of a pytest run for example) isatty() can raise\n            # ValueError: I/O operation on closed file\n            # return False because we aren't in a terminal anymore\n            return False",
        "line_count": 46,
        "needs_llm_summary": true
      },
      {
        "name": "is_dumb_terminal",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 985,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self._environ.get",
          "_term.lower"
        ],
        "docstring": "Detect dumb terminal.\n\nReturns:\n    bool: True if writing to a dumb terminal, otherwise False.",
        "code": "def is_dumb_terminal(self) -> bool:\n        \"\"\"Detect dumb terminal.\n\n        Returns:\n            bool: True if writing to a dumb terminal, otherwise False.\n\n        \"\"\"\n        _term = self._environ.get(\"TERM\", \"\")\n        is_dumb = _term.lower() in (\"dumb\", \"unknown\")\n        return self.is_terminal and is_dumb",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "options",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ConsoleOptions",
        "lineno": 997,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.encoding",
          "self.is_terminal",
          "size",
          "size.height",
          "size.width",
          "self.size",
          "ConsoleOptions",
          "self.legacy_windows"
        ],
        "docstring": "Get default console options.",
        "code": "def options(self) -> ConsoleOptions:\n        \"\"\"Get default console options.\"\"\"\n        size = self.size\n        return ConsoleOptions(\n            max_height=size.height,\n            size=size,\n            legacy_windows=self.legacy_windows,\n            min_width=1,\n            max_width=size.width,\n            encoding=self.encoding,\n            is_terminal=self.is_terminal,\n        )",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "size",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ConsoleDimensions",
        "lineno": 1011,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "columns.isdigit",
          "file_descriptor",
          "lines",
          "self._height",
          "self._environ.get",
          "os.get_terminal_size",
          "columns",
          "lines.isdigit",
          "ConsoleDimensions",
          "int"
        ],
        "docstring": "Get the size of the console.\n\nReturns:\n    ConsoleDimensions: A named tuple containing the dimensions.",
        "code": "def size(self) -> ConsoleDimensions:\n        \"\"\"Get the size of the console.\n\n        Returns:\n            ConsoleDimensions: A named tuple containing the dimensions.\n        \"\"\"\n\n        if self._width is not None and self._height is not None:\n            return ConsoleDimensions(self._width - self.legacy_windows, self._height)\n\n        if self.is_dumb_terminal:\n            return ConsoleDimensions(80, 25)\n\n        width: Optional[int] = None\n        height: Optional[int] = None\n\n        streams = _STD_STREAMS_OUTPUT if WINDOWS else _STD_STREAMS\n        for file_descriptor in streams:\n            try:\n                width, height = os.get_terminal_size(file_descriptor)\n            except (AttributeError, ValueError, OSError):  # Probably not a terminal\n                pass\n            else:\n                break\n\n        columns = self._environ.get(\"COLUMNS\")\n        if columns is not None and columns.isdigit():\n            width = int(columns)\n        lines = self._environ.get(\"LINES\")\n        if lines is not None and lines.isdigit():\n            height = int(lines)\n\n        # get_terminal_size can report 0, 0 if run from pseudo-terminal\n        width = width or 80\n        height = height or 25\n        return ConsoleDimensions(\n            width - self.legacy_windows if self._width is None else self._width,\n            height if self._height is None else self._height,\n        )",
        "line_count": 39,
        "needs_llm_summary": true
      },
      {
        "name": "size",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "new_size",
            "type": "Tuple[int, int]"
          }
        ],
        "return_type": "None",
        "lineno": 1052,
        "decorators": [
          {
            "name": "size.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "height",
          "width",
          "new_size"
        ],
        "docstring": "Set a new size for the terminal.\n\nArgs:\n    new_size (Tuple[int, int]): New width and height.",
        "code": "def size(self, new_size: Tuple[int, int]) -> None:\n        \"\"\"Set a new size for the terminal.\n\n        Args:\n            new_size (Tuple[int, int]): New width and height.\n        \"\"\"\n        width, height = new_size\n        self._width = width\n        self._height = height",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "width",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 1063,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get the width of the console.\n\nReturns:\n    int: The width (in characters) of the console.",
        "code": "def width(self) -> int:\n        \"\"\"Get the width of the console.\n\n        Returns:\n            int: The width (in characters) of the console.\n        \"\"\"\n        return self.size.width",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "width",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 1072,
        "decorators": [
          {
            "name": "width.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "width"
        ],
        "docstring": "Set width.\n\nArgs:\n    width (int): New width.",
        "code": "def width(self, width: int) -> None:\n        \"\"\"Set width.\n\n        Args:\n            width (int): New width.\n        \"\"\"\n        self._width = width",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "height",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 1081,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get the height of the console.\n\nReturns:\n    int: The height (in lines) of the console.",
        "code": "def height(self) -> int:\n        \"\"\"Get the height of the console.\n\n        Returns:\n            int: The height (in lines) of the console.\n        \"\"\"\n        return self.size.height",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "height",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "height",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 1090,
        "decorators": [
          {
            "name": "height.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "height"
        ],
        "docstring": "Set height.\n\nArgs:\n    height (int): new height.",
        "code": "def height(self, height: int) -> None:\n        \"\"\"Set height.\n\n        Args:\n            height (int): new height.\n        \"\"\"\n        self._height = height",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "bell",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1098,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.control",
          "Control.bell"
        ],
        "docstring": "Play a 'bell' sound (if supported by the terminal).",
        "code": "def bell(self) -> None:\n        \"\"\"Play a 'bell' sound (if supported by the terminal).\"\"\"\n        self.control(Control.bell())",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "capture",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Capture",
        "lineno": 1102,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Capture",
          "self"
        ],
        "docstring": "A context manager to *capture* the result of print() or log() in a string,\nrather than writing it to the console.\n\nExample:\n    >>> from rich.console import Console\n    >>> console = Console()\n    >>> with console.capture() as capture:\n    ...     console.print(\"[bold magenta]Hello World[/]\")\n    >>> print(capture.get())\n\nReturns:\n    Capture: Context manager with disables writing to the terminal.",
        "code": "def capture(self) -> Capture:\n        \"\"\"A context manager to *capture* the result of print() or log() in a string,\n        rather than writing it to the console.\n\n        Example:\n            >>> from rich.console import Console\n            >>> console = Console()\n            >>> with console.capture() as capture:\n            ...     console.print(\"[bold magenta]Hello World[/]\")\n            >>> print(capture.get())\n\n        Returns:\n            Capture: Context manager with disables writing to the terminal.\n        \"\"\"\n        capture = Capture(self)\n        return capture",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "pager",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "pager",
            "type": "Optional[Pager]"
          },
          {
            "name": "styles",
            "type": "bool"
          },
          {
            "name": "links",
            "type": "bool"
          }
        ],
        "return_type": "PagerContext",
        "lineno": 1119,
        "decorators": [],
        "is_async": false,
        "calls": [
          "links",
          "styles",
          "PagerContext",
          "pager",
          "self"
        ],
        "docstring": "A context manager to display anything printed within a \"pager\". The pager application\nis defined by the system and will typically support at least pressing a key to scroll.\n\nArgs:\n    pager (Pager, optional): A pager object, or None to use :class:`~rich.pager.SystemPager`. Defaults to None.\n    styles (bool, optional): Show styles in pager. Defaults to False.\n    links (bool, optional): Show links in pager. Defaults to False.\n\nExample:\n    >>> from rich.console import Console\n    >>> from rich.__main__ import make_test_card\n    >>> console = Console()\n    >>> with console.pager():\n            console.print(make_test_card())\n\nReturns:\n    PagerContext: A context manager.",
        "code": "def pager(\n        self, pager: Optional[Pager] = None, styles: bool = False, links: bool = False\n    ) -> PagerContext:\n        \"\"\"A context manager to display anything printed within a \"pager\". The pager application\n        is defined by the system and will typically support at least pressing a key to scroll.\n\n        Args:\n            pager (Pager, optional): A pager object, or None to use :class:`~rich.pager.SystemPager`. Defaults to None.\n            styles (bool, optional): Show styles in pager. Defaults to False.\n            links (bool, optional): Show links in pager. Defaults to False.\n\n        Example:\n            >>> from rich.console import Console\n            >>> from rich.__main__ import make_test_card\n            >>> console = Console()\n            >>> with console.pager():\n                    console.print(make_test_card())\n\n        Returns:\n            PagerContext: A context manager.\n        \"\"\"\n        return PagerContext(self, pager=pager, styles=styles, links=links)",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "line",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "count",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 1142,
        "decorators": [],
        "is_async": false,
        "calls": [
          "NewLine",
          "count",
          "self.print"
        ],
        "docstring": "Write new line(s).\n\nArgs:\n    count (int, optional): Number of new lines. Defaults to 1.",
        "code": "def line(self, count: int = 1) -> None:\n        \"\"\"Write new line(s).\n\n        Args:\n            count (int, optional): Number of new lines. Defaults to 1.\n        \"\"\"\n\n        assert count >= 0, \"count must be >= 0\"\n        self.print(NewLine(count))",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "clear",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "home",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 1152,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Control.home",
          "self.control",
          "Control.clear"
        ],
        "docstring": "Clear the screen.\n\nArgs:\n    home (bool, optional): Also move the cursor to 'home' position. Defaults to True.",
        "code": "def clear(self, home: bool = True) -> None:\n        \"\"\"Clear the screen.\n\n        Args:\n            home (bool, optional): Also move the cursor to 'home' position. Defaults to True.\n        \"\"\"\n        if home:\n            self.control(Control.clear(), Control.home())\n        else:\n            self.control(Control.clear())",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "status",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "status",
            "type": "RenderableType"
          }
        ],
        "return_type": "Status",
        "lineno": 1163,
        "decorators": [],
        "is_async": false,
        "calls": [
          "spinner_style",
          "spinner",
          "speed",
          "refresh_per_second",
          "status",
          "Status",
          "self"
        ],
        "docstring": "Display a status and spinner.\n\nArgs:\n    status (RenderableType): A status renderable (str or Text typically).\n    spinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to \"dots\".\n    spinner_style (StyleType, optional): Style of spinner. Defaults to \"status.spinner\".\n    speed (float, optional): Speed factor for spinner animation. Defaults to 1.0.\n    refresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5.\n\nReturns:\n    Status: A Status object that may be used as a context manager.",
        "code": "def status(\n        self,\n        status: RenderableType,\n        *,\n        spinner: str = \"dots\",\n        spinner_style: StyleType = \"status.spinner\",\n        speed: float = 1.0,\n        refresh_per_second: float = 12.5,\n    ) -> \"Status\":\n        \"\"\"Display a status and spinner.\n\n        Args:\n            status (RenderableType): A status renderable (str or Text typically).\n            spinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to \"dots\".\n            spinner_style (StyleType, optional): Style of spinner. Defaults to \"status.spinner\".\n            speed (float, optional): Speed factor for spinner animation. Defaults to 1.0.\n            refresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5.\n\n        Returns:\n            Status: A Status object that may be used as a context manager.\n        \"\"\"\n        from .status import Status\n\n        status_renderable = Status(\n            status,\n            console=self,\n            spinner=spinner,\n            spinner_style=spinner_style,\n            speed=speed,\n            refresh_per_second=refresh_per_second,\n        )\n        return status_renderable",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "show_cursor",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "show",
            "type": "bool"
          }
        ],
        "return_type": "bool",
        "lineno": 1196,
        "decorators": [],
        "is_async": false,
        "calls": [
          "show",
          "self.control",
          "Control.show_cursor"
        ],
        "docstring": "Show or hide the cursor.\n\nArgs:\n    show (bool, optional): Set visibility of the cursor.",
        "code": "def show_cursor(self, show: bool = True) -> bool:\n        \"\"\"Show or hide the cursor.\n\n        Args:\n            show (bool, optional): Set visibility of the cursor.\n        \"\"\"\n        if self.is_terminal:\n            self.control(Control.show_cursor(show))\n            return True\n        return False",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "set_alt_screen",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "enable",
            "type": "bool"
          }
        ],
        "return_type": "bool",
        "lineno": 1207,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enable",
          "self.control",
          "Control.alt_screen"
        ],
        "docstring": "Enables alternative screen mode.\n\nNote, if you enable this mode, you should ensure that is disabled before\nthe application exits. See :meth:`~rich.Console.screen` for a context manager\nthat handles this for you.\n\nArgs:\n    enable (bool, optional): Enable (True) or disable (False) alternate screen. Defaults to True.\n\nReturns:\n    bool: True if the control codes were written.",
        "code": "def set_alt_screen(self, enable: bool = True) -> bool:\n        \"\"\"Enables alternative screen mode.\n\n        Note, if you enable this mode, you should ensure that is disabled before\n        the application exits. See :meth:`~rich.Console.screen` for a context manager\n        that handles this for you.\n\n        Args:\n            enable (bool, optional): Enable (True) or disable (False) alternate screen. Defaults to True.\n\n        Returns:\n            bool: True if the control codes were written.\n\n        \"\"\"\n        changed = False\n        if self.is_terminal and not self.legacy_windows:\n            self.control(Control.alt_screen(enable))\n            changed = True\n            self._is_alt_screen = enable\n        return changed",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "is_alt_screen",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 1229,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Check if the alt screen was enabled.\n\nReturns:\n    bool: True if the alt screen was enabled, otherwise False.",
        "code": "def is_alt_screen(self) -> bool:\n        \"\"\"Check if the alt screen was enabled.\n\n        Returns:\n            bool: True if the alt screen was enabled, otherwise False.\n        \"\"\"\n        return self._is_alt_screen",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "set_window_title",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "title",
            "type": "str"
          }
        ],
        "return_type": "bool",
        "lineno": 1237,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Control.title",
          "title",
          "self.control"
        ],
        "docstring": "Set the title of the console terminal window.\n\nWarning: There is no means within Rich of \"resetting\" the window title to its\nprevious value, meaning the title you set will persist even after your application\nexits.\n\n``fish`` shell resets the window title before and after each command by default,\nnegating this issue. Windows Terminal and command prompt will also reset the title for you.\nMost other shells and terminals, however, do not do this.\n\nSome terminals may require configuration changes before you can set the title.\nSome terminals may not support setting the title at all.\n\nOther software (including the terminal itself, the shell, custom prompts, plugins, etc.)\nmay also set the terminal window title. This could result in whatever value you write\nusing this method being overwritten.\n\nArgs:\n    title (str): The new title of the terminal window.\n\nReturns:\n    bool: True if the control code to change the terminal title was\n        written, otherwise False. Note that a return value of True\n        does not guarantee that the window title has actually changed,\n        since the feature may be unsupported/disabled in some terminals.",
        "code": "def set_window_title(self, title: str) -> bool:\n        \"\"\"Set the title of the console terminal window.\n\n        Warning: There is no means within Rich of \"resetting\" the window title to its\n        previous value, meaning the title you set will persist even after your application\n        exits.\n\n        ``fish`` shell resets the window title before and after each command by default,\n        negating this issue. Windows Terminal and command prompt will also reset the title for you.\n        Most other shells and terminals, however, do not do this.\n\n        Some terminals may require configuration changes before you can set the title.\n        Some terminals may not support setting the title at all.\n\n        Other software (including the terminal itself, the shell, custom prompts, plugins, etc.)\n        may also set the terminal window title. This could result in whatever value you write\n        using this method being overwritten.\n\n        Args:\n            title (str): The new title of the terminal window.\n\n        Returns:\n            bool: True if the control code to change the terminal title was\n                written, otherwise False. Note that a return value of True\n                does not guarantee that the window title has actually changed,\n                since the feature may be unsupported/disabled in some terminals.\n        \"\"\"\n        if self.is_terminal:\n            self.control(Control.title(title))\n            return True\n        return False",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "screen",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "hide_cursor",
            "type": "bool"
          },
          {
            "name": "style",
            "type": "Optional[StyleType]"
          }
        ],
        "return_type": "ScreenContext",
        "lineno": 1269,
        "decorators": [],
        "is_async": false,
        "calls": [
          "hide_cursor",
          "ScreenContext",
          "self"
        ],
        "docstring": "Context manager to enable and disable 'alternative screen' mode.\n\nArgs:\n    hide_cursor (bool, optional): Also hide the cursor. Defaults to False.\n    style (Style, optional): Optional style for screen. Defaults to None.\n\nReturns:\n    ~ScreenContext: Context which enables alternate screen on enter, and disables it on exit.",
        "code": "def screen(\n        self, hide_cursor: bool = True, style: Optional[StyleType] = None\n    ) -> \"ScreenContext\":\n        \"\"\"Context manager to enable and disable 'alternative screen' mode.\n\n        Args:\n            hide_cursor (bool, optional): Also hide the cursor. Defaults to False.\n            style (Style, optional): Optional style for screen. Defaults to None.\n\n        Returns:\n            ~ScreenContext: Context which enables alternate screen on enter, and disables it on exit.\n        \"\"\"\n        return ScreenContext(self, hide_cursor=hide_cursor, style=style or \"\")",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "measure",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "Measurement",
        "lineno": 1283,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Measurement.get",
          "renderable",
          "self"
        ],
        "docstring": "Measure a renderable. Returns a :class:`~rich.measure.Measurement` object which contains\ninformation regarding the number of characters required to print the renderable.\n\nArgs:\n    renderable (RenderableType): Any renderable or string.\n    options (Optional[ConsoleOptions], optional): Options to use when measuring, or None\n        to use default options. Defaults to None.\n\nReturns:\n    Measurement: A measurement of the renderable.",
        "code": "def measure(\n        self, renderable: RenderableType, *, options: Optional[ConsoleOptions] = None\n    ) -> Measurement:\n        \"\"\"Measure a renderable. Returns a :class:`~rich.measure.Measurement` object which contains\n        information regarding the number of characters required to print the renderable.\n\n        Args:\n            renderable (RenderableType): Any renderable or string.\n            options (Optional[ConsoleOptions], optional): Options to use when measuring, or None\n                to use default options. Defaults to None.\n\n        Returns:\n            Measurement: A measurement of the renderable.\n        \"\"\"\n        measurement = Measurement.get(self, options or self.options, renderable)\n        return measurement",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "options",
            "type": "Optional[ConsoleOptions]"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 1300,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_options.highlight",
          "render_iterable",
          "self.render_str",
          "text_renderable.__rich_console__",
          "self.render",
          "rich_cast",
          "_Segment",
          "render_output",
          "str",
          "_options.markup",
          "renderable",
          "_options.reset_height",
          "hasattr",
          "Segment",
          "isinstance",
          "_options",
          "isclass",
          "errors.NotRenderableError",
          "iter",
          "renderable.__rich_console__",
          "self"
        ],
        "docstring": "Render an object in to an iterable of `Segment` instances.\n\nThis method contains the logic for rendering objects with the console protocol.\nYou are unlikely to need to use it directly, unless you are extending the library.\n\nArgs:\n    renderable (RenderableType): An object supporting the console protocol, or\n        an object that may be converted to a string.\n    options (ConsoleOptions, optional): An options object, or None to use self.options. Defaults to None.\n\nReturns:\n    Iterable[Segment]: An iterable of segments that may be rendered.",
        "code": "def render(\n        self, renderable: RenderableType, options: Optional[ConsoleOptions] = None\n    ) -> Iterable[Segment]:\n        \"\"\"Render an object in to an iterable of `Segment` instances.\n\n        This method contains the logic for rendering objects with the console protocol.\n        You are unlikely to need to use it directly, unless you are extending the library.\n\n        Args:\n            renderable (RenderableType): An object supporting the console protocol, or\n                an object that may be converted to a string.\n            options (ConsoleOptions, optional): An options object, or None to use self.options. Defaults to None.\n\n        Returns:\n            Iterable[Segment]: An iterable of segments that may be rendered.\n        \"\"\"\n\n        _options = options or self.options\n        if _options.max_width < 1:\n            # No space to render anything. This prevents potential recursion errors.\n            return\n        render_iterable: RenderResult\n\n        renderable = rich_cast(renderable)\n        if hasattr(renderable, \"__rich_console__\") and not isclass(renderable):\n            render_iterable = renderable.__rich_console__(self, _options)\n        elif isinstance(renderable, str):\n            text_renderable = self.render_str(\n                renderable, highlight=_options.highlight, markup=_options.markup\n            )\n            render_iterable = text_renderable.__rich_console__(self, _options)\n        else:\n            raise errors.NotRenderableError(\n                f\"Unable to render {renderable!r}; \"\n                \"A str, Segment or object with __rich_console__ method is required\"\n            )\n\n        try:\n            iter_render = iter(render_iterable)\n        except TypeError:\n            raise errors.NotRenderableError(\n                f\"object {render_iterable!r} is not renderable\"\n            )\n        _Segment = Segment\n        _options = _options.reset_height()\n        for render_output in iter_render:\n            if isinstance(render_output, _Segment):\n                yield render_output\n            else:\n                yield from self.render(render_output, _options)",
        "line_count": 50,
        "needs_llm_summary": true
      },
      {
        "name": "render_lines",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "options",
            "type": "Optional[ConsoleOptions]"
          }
        ],
        "return_type": "List[List[Segment]]",
        "lineno": 1351,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "style",
          "islice",
          "render_options.max_width",
          "render_options.height",
          "list",
          "render_options",
          "self.render",
          "_rendered",
          "render_height",
          "lines.extend",
          "Segment.apply_style",
          "max",
          "renderable",
          "Segment.split_and_crop_lines",
          "Segment",
          "pad",
          "len",
          "new_lines"
        ],
        "docstring": "Render objects in to a list of lines.\n\n        The output of render_lines is useful when further formatting of rendered console text\n        is required, such as the Panel class which draws a border around any renderable object.\n\n        Args:\n            renderable (RenderableType): Any object renderable in the console.\n            options (Optional[ConsoleOptions], optional): Console options, or None to use self.options. Default to ``None``.\n            style (Style, optional): Optional style to apply to renderables. Defaults to ``None``.\n            pad (bool, optional): Pad lines shorter than render width. Defaults to ``True``.\n            new_lines (bool, optional): Include \"\n\" characters at end of lines.\n\n        Returns:\n            List[List[Segment]]: A list of lines, where a line is a list of Segment objects.\n        ",
        "code": "def render_lines(\n        self,\n        renderable: RenderableType,\n        options: Optional[ConsoleOptions] = None,\n        *,\n        style: Optional[Style] = None,\n        pad: bool = True,\n        new_lines: bool = False,\n    ) -> List[List[Segment]]:\n        \"\"\"Render objects in to a list of lines.\n\n        The output of render_lines is useful when further formatting of rendered console text\n        is required, such as the Panel class which draws a border around any renderable object.\n\n        Args:\n            renderable (RenderableType): Any object renderable in the console.\n            options (Optional[ConsoleOptions], optional): Console options, or None to use self.options. Default to ``None``.\n            style (Style, optional): Optional style to apply to renderables. Defaults to ``None``.\n            pad (bool, optional): Pad lines shorter than render width. Defaults to ``True``.\n            new_lines (bool, optional): Include \"\\n\" characters at end of lines.\n\n        Returns:\n            List[List[Segment]]: A list of lines, where a line is a list of Segment objects.\n        \"\"\"\n        with self._lock:\n            render_options = options or self.options\n            _rendered = self.render(renderable, render_options)\n            if style:\n                _rendered = Segment.apply_style(_rendered, style)\n\n            render_height = render_options.height\n            if render_height is not None:\n                render_height = max(0, render_height)\n\n            lines = list(\n                islice(\n                    Segment.split_and_crop_lines(\n                        _rendered,\n                        render_options.max_width,\n                        include_new_lines=new_lines,\n                        pad=pad,\n                        style=style,\n                    ),\n                    None,\n                    render_height,\n                )\n            )\n            if render_options.height is not None:\n                extra_lines = render_options.height - len(lines)\n                if extra_lines > 0:\n                    pad_line = [\n                        (\n                            [\n                                Segment(\" \" * render_options.max_width, style),\n                                Segment(\"\\n\"),\n                            ]\n                            if new_lines\n                            else [Segment(\" \" * render_options.max_width, style)]\n                        )\n                    ]\n                    lines.extend(pad_line * extra_lines)\n\n            return lines",
        "line_count": 63,
        "needs_llm_summary": true
      },
      {
        "name": "render_str",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "Text",
        "lineno": 1415,
        "decorators": [],
        "is_async": false,
        "calls": [
          "emoji_enabled",
          "str",
          "overflow",
          "style",
          "_highlighter",
          "rich_text",
          "render_markup",
          "self._emoji_variant",
          "_emoji_replace",
          "text",
          "justify",
          "highlight_text.copy_styles",
          "Text"
        ],
        "docstring": "Convert a string to a Text instance. This is called automatically if\nyou print or log a string.\n\nArgs:\n    text (str): Text to render.\n    style (Union[str, Style], optional): Style to apply to rendered text.\n    justify (str, optional): Justify method: \"default\", \"left\", \"center\", \"full\", or \"right\". Defaults to ``None``.\n    overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to ``None``.\n    emoji (Optional[bool], optional): Enable emoji, or ``None`` to use Console default.\n    markup (Optional[bool], optional): Enable markup, or ``None`` to use Console default.\n    highlight (Optional[bool], optional): Enable highlighting, or ``None`` to use Console default.\n    highlighter (HighlighterType, optional): Optional highlighter to apply.\nReturns:\n    ConsoleRenderable: Renderable object.",
        "code": "def render_str(\n        self,\n        text: str,\n        *,\n        style: Union[str, Style] = \"\",\n        justify: Optional[JustifyMethod] = None,\n        overflow: Optional[OverflowMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        highlighter: Optional[HighlighterType] = None,\n    ) -> \"Text\":\n        \"\"\"Convert a string to a Text instance. This is called automatically if\n        you print or log a string.\n\n        Args:\n            text (str): Text to render.\n            style (Union[str, Style], optional): Style to apply to rendered text.\n            justify (str, optional): Justify method: \"default\", \"left\", \"center\", \"full\", or \"right\". Defaults to ``None``.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to ``None``.\n            emoji (Optional[bool], optional): Enable emoji, or ``None`` to use Console default.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use Console default.\n            highlight (Optional[bool], optional): Enable highlighting, or ``None`` to use Console default.\n            highlighter (HighlighterType, optional): Optional highlighter to apply.\n        Returns:\n            ConsoleRenderable: Renderable object.\n\n        \"\"\"\n        emoji_enabled = emoji or (emoji is None and self._emoji)\n        markup_enabled = markup or (markup is None and self._markup)\n        highlight_enabled = highlight or (highlight is None and self._highlight)\n\n        if markup_enabled:\n            rich_text = render_markup(\n                text,\n                style=style,\n                emoji=emoji_enabled,\n                emoji_variant=self._emoji_variant,\n            )\n            rich_text.justify = justify\n            rich_text.overflow = overflow\n        else:\n            rich_text = Text(\n                (\n                    _emoji_replace(text, default_variant=self._emoji_variant)\n                    if emoji_enabled\n                    else text\n                ),\n                justify=justify,\n                overflow=overflow,\n                style=style,\n            )\n\n        _highlighter = (highlighter or self.highlighter) if highlight_enabled else None\n        if _highlighter is not None:\n            highlight_text = _highlighter(str(rich_text))\n            highlight_text.copy_styles(rich_text)\n            return highlight_text\n\n        return rich_text",
        "line_count": 60,
        "needs_llm_summary": true
      },
      {
        "name": "get_style",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "Union[str, Style]"
          }
        ],
        "return_type": "Style",
        "lineno": 1476,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "self.get_style",
          "style.copy",
          "errors.MissingStyle",
          "name",
          "self._theme_stack.get",
          "Style.parse",
          "Style",
          "default"
        ],
        "docstring": "Get a Style instance by its theme name or parse a definition.\n\nArgs:\n    name (str): The name of a style or a style definition.\n\nReturns:\n    Style: A Style object.\n\nRaises:\n    MissingStyle: If no style could be parsed from name.",
        "code": "def get_style(\n        self, name: Union[str, Style], *, default: Optional[Union[Style, str]] = None\n    ) -> Style:\n        \"\"\"Get a Style instance by its theme name or parse a definition.\n\n        Args:\n            name (str): The name of a style or a style definition.\n\n        Returns:\n            Style: A Style object.\n\n        Raises:\n            MissingStyle: If no style could be parsed from name.\n\n        \"\"\"\n        if isinstance(name, Style):\n            return name\n\n        try:\n            style = self._theme_stack.get(name)\n            if style is None:\n                style = Style.parse(name)\n            return style.copy() if style.link else style\n        except errors.StyleSyntaxError as error:\n            if default is not None:\n                return self.get_style(default)\n            raise errors.MissingStyle(\n                f\"Failed to get style {name!r}; {error}\"\n            ) from None",
        "line_count": 29,
        "needs_llm_summary": true
      },
      {
        "name": "_collect_renderables",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "objects",
            "type": "Iterable[Any]"
          },
          {
            "name": "sep",
            "type": "str"
          },
          {
            "name": "end",
            "type": "str"
          }
        ],
        "return_type": "List[ConsoleRenderable]",
        "lineno": 1506,
        "decorators": [],
        "is_async": false,
        "calls": [
          "check_text",
          "end",
          "markup",
          "style",
          "highlight",
          "renderables.append",
          "self.render_str",
          "cast",
          "self.style",
          "align_append",
          "rich_cast",
          "emoji",
          "text.clear",
          "Align",
          "Text",
          "self.get_style",
          "_append",
          "str",
          "append",
          "_highlighter",
          "AlignMethod",
          "renderable",
          "self.highlighter",
          "justify",
          "text",
          "isinstance",
          "sep_text.join",
          "text.append",
          "Styled",
          "is_expandable",
          "Pretty",
          "append_text",
          "sep",
          "ConsoleRenderable"
        ],
        "docstring": "Combine a number of renderables and text into one renderable.\n\nArgs:\n    objects (Iterable[Any]): Anything that Rich can render.\n    sep (str): String to write between print data.\n    end (str): String to write at end of print data.\n    justify (str, optional): One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n    emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default.\n    markup (Optional[bool], optional): Enable markup, or ``None`` to use console default.\n    highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default.\n\nReturns:\n    List[ConsoleRenderable]: A list of things to render.",
        "code": "def _collect_renderables(\n        self,\n        objects: Iterable[Any],\n        sep: str,\n        end: str,\n        *,\n        justify: Optional[JustifyMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n    ) -> List[ConsoleRenderable]:\n        \"\"\"Combine a number of renderables and text into one renderable.\n\n        Args:\n            objects (Iterable[Any]): Anything that Rich can render.\n            sep (str): String to write between print data.\n            end (str): String to write at end of print data.\n            justify (str, optional): One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default.\n\n        Returns:\n            List[ConsoleRenderable]: A list of things to render.\n        \"\"\"\n        renderables: List[ConsoleRenderable] = []\n        _append = renderables.append\n        text: List[Text] = []\n        append_text = text.append\n\n        append = _append\n        if justify in (\"left\", \"center\", \"right\"):\n\n            def align_append(renderable: RenderableType) -> None:\n                _append(Align(renderable, cast(AlignMethod, justify)))\n\n            append = align_append\n\n        _highlighter: HighlighterType = _null_highlighter\n        if highlight or (highlight is None and self._highlight):\n            _highlighter = self.highlighter\n\n        def check_text() -> None:\n            if text:\n                sep_text = Text(sep, justify=justify, end=end)\n                append(sep_text.join(text))\n                text.clear()\n\n        for renderable in objects:\n            renderable = rich_cast(renderable)\n            if isinstance(renderable, str):\n                append_text(\n                    self.render_str(\n                        renderable,\n                        emoji=emoji,\n                        markup=markup,\n                        highlight=highlight,\n                        highlighter=_highlighter,\n                    )\n                )\n            elif isinstance(renderable, Text):\n                append_text(renderable)\n            elif isinstance(renderable, ConsoleRenderable):\n                check_text()\n                append(renderable)\n            elif is_expandable(renderable):\n                check_text()\n                append(Pretty(renderable, highlighter=_highlighter))\n            else:\n                append_text(_highlighter(str(renderable)))\n\n        check_text()\n\n        if self.style is not None:\n            style = self.get_style(self.style)\n            renderables = [Styled(renderable, style) for renderable in renderables]\n\n        return renderables",
        "line_count": 78,
        "needs_llm_summary": true
      },
      {
        "name": "rule",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "title",
            "type": "TextType"
          }
        ],
        "return_type": "None",
        "lineno": 1585,
        "decorators": [],
        "is_async": false,
        "calls": [
          "characters",
          "align",
          "style",
          "Rule",
          "title",
          "rule",
          "self.print"
        ],
        "docstring": "Draw a line with optional centered title.\n\nArgs:\n    title (str, optional): Text to render over the rule. Defaults to \"\".\n    characters (str, optional): Character(s) to form the line. Defaults to \"\u2500\".\n    style (str, optional): Style of line. Defaults to \"rule.line\".\n    align (str, optional): How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".",
        "code": "def rule(\n        self,\n        title: TextType = \"\",\n        *,\n        characters: str = \"\u2500\",\n        style: Union[str, Style] = \"rule.line\",\n        align: AlignMethod = \"center\",\n    ) -> None:\n        \"\"\"Draw a line with optional centered title.\n\n        Args:\n            title (str, optional): Text to render over the rule. Defaults to \"\".\n            characters (str, optional): Character(s) to form the line. Defaults to \"\u2500\".\n            style (str, optional): Style of line. Defaults to \"rule.line\".\n            align (str, optional): How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".\n        \"\"\"\n        from .rule import Rule\n\n        rule = Rule(title=title, characters=characters, style=style, align=align)\n        self.print(rule)",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "control",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1606,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._buffer.extend"
        ],
        "docstring": "Insert non-printing control codes.\n\nArgs:\n    control_codes (str): Control codes, such as those that may move the cursor.",
        "code": "def control(self, *control: Control) -> None:\n        \"\"\"Insert non-printing control codes.\n\n        Args:\n            control_codes (str): Control codes, such as those that may move the cursor.\n        \"\"\"\n        if not self.is_dumb_terminal:\n            with self:\n                self._buffer.extend(_control.segment for _control in control)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "out",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1616,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sep.join",
          "str",
          "end",
          "style",
          "highlight",
          "_object",
          "raw_output",
          "self.print"
        ],
        "docstring": "Output to the terminal. This is a low-level way of writing to the terminal which unlike\n:meth:`~rich.console.Console.print` won't pretty print, wrap text, or apply markup, but will\noptionally apply highlighting and a basic style.\n\nArgs:\n    sep (str, optional): String to write between print data. Defaults to \" \".\n    end (str, optional): String to write at end of print data. Defaults to \"\\\\n\".\n    style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n    highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use\n        console default. Defaults to ``None``.",
        "code": "def out(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        highlight: Optional[bool] = None,\n    ) -> None:\n        \"\"\"Output to the terminal. This is a low-level way of writing to the terminal which unlike\n        :meth:`~rich.console.Console.print` won't pretty print, wrap text, or apply markup, but will\n        optionally apply highlighting and a basic style.\n\n        Args:\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use\n                console default. Defaults to ``None``.\n        \"\"\"\n        raw_output: str = sep.join(str(_object) for _object in objects)\n        self.print(\n            raw_output,\n            style=style,\n            highlight=highlight,\n            emoji=False,\n            markup=False,\n            no_wrap=True,\n            overflow=\"ignore\",\n            crop=False,\n            end=end,\n        )",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "print",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1648,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "end",
          "markup",
          "style",
          "highlight",
          "NewLine",
          "unknown.splitlines",
          "self.width",
          "extend",
          "render",
          "hook.process_renderables",
          "height",
          "render_options",
          "no_wrap",
          "self.render",
          "emoji",
          "unknown.join",
          "self._collect_renderables",
          "new_segments",
          "new_segments.insert",
          "Segment.apply_style",
          "self._buffer.extend",
          "self.get_style",
          "line",
          "self.options.update",
          "new_segments.extend",
          "objects",
          "renderable",
          "width",
          "justify",
          "Segment.split_and_crop_lines",
          "len",
          "min",
          "overflow",
          "buffer_extend",
          "self.soft_wrap",
          "renderables",
          "sep"
        ],
        "docstring": "Print to the console.\n\nArgs:\n    objects (positional args): Objects to log to the terminal.\n    sep (str, optional): String to write between print data. Defaults to \" \".\n    end (str, optional): String to write at end of print data. Defaults to \"\\\\n\".\n    style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n    justify (str, optional): Justify method: \"default\", \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n    overflow (str, optional): Overflow method: \"ignore\", \"crop\", \"fold\", or \"ellipsis\". Defaults to None.\n    no_wrap (Optional[bool], optional): Disable word wrapping. Defaults to None.\n    emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to ``None``.\n    markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to ``None``.\n    highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to ``None``.\n    width (Optional[int], optional): Width of output, or ``None`` to auto-detect. Defaults to ``None``.\n    crop (Optional[bool], optional): Crop output to width of terminal. Defaults to True.\n    soft_wrap (bool, optional): Enable soft wrap mode which disables word wrapping and cropping of text or ``None`` for\n        Console default. Defaults to ``None``.\n    new_line_start (bool, False): Insert a new line at the start if the output contains more than one line. Defaults to ``False``.",
        "code": "def print(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        justify: Optional[JustifyMethod] = None,\n        overflow: Optional[OverflowMethod] = None,\n        no_wrap: Optional[bool] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        crop: bool = True,\n        soft_wrap: Optional[bool] = None,\n        new_line_start: bool = False,\n    ) -> None:\n        \"\"\"Print to the console.\n\n        Args:\n            objects (positional args): Objects to log to the terminal.\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            justify (str, optional): Justify method: \"default\", \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            overflow (str, optional): Overflow method: \"ignore\", \"crop\", \"fold\", or \"ellipsis\". Defaults to None.\n            no_wrap (Optional[bool], optional): Disable word wrapping. Defaults to None.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to ``None``.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to ``None``.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to ``None``.\n            width (Optional[int], optional): Width of output, or ``None`` to auto-detect. Defaults to ``None``.\n            crop (Optional[bool], optional): Crop output to width of terminal. Defaults to True.\n            soft_wrap (bool, optional): Enable soft wrap mode which disables word wrapping and cropping of text or ``None`` for\n                Console default. Defaults to ``None``.\n            new_line_start (bool, False): Insert a new line at the start if the output contains more than one line. Defaults to ``False``.\n        \"\"\"\n        if not objects:\n            objects = (NewLine(),)\n\n        if soft_wrap is None:\n            soft_wrap = self.soft_wrap\n        if soft_wrap:\n            if no_wrap is None:\n                no_wrap = True\n            if overflow is None:\n                overflow = \"ignore\"\n            crop = False\n        render_hooks = self._render_hooks[:]\n        with self:\n            renderables = self._collect_renderables(\n                objects,\n                sep,\n                end,\n                justify=justify,\n                emoji=emoji,\n                markup=markup,\n                highlight=highlight,\n            )\n            for hook in render_hooks:\n                renderables = hook.process_renderables(renderables)\n            render_options = self.options.update(\n                justify=justify,\n                overflow=overflow,\n                width=min(width, self.width) if width is not None else NO_CHANGE,\n                height=height,\n                no_wrap=no_wrap,\n                markup=markup,\n                highlight=highlight,\n            )\n\n            new_segments: List[Segment] = []\n            extend = new_segments.extend\n            render = self.render\n            if style is None:\n                for renderable in renderables:\n                    extend(render(renderable, render_options))\n            else:\n                for renderable in renderables:\n                    extend(\n                        Segment.apply_style(\n                            render(renderable, render_options), self.get_style(style)\n                        )\n                    )\n            if new_line_start:\n                if (\n                    len(\"\".join(segment.text for segment in new_segments).splitlines())\n                    > 1\n                ):\n                    new_segments.insert(0, Segment.line())\n            if crop:\n                buffer_extend = self._buffer.extend\n                for line in Segment.split_and_crop_lines(\n                    new_segments, self.width, pad=False\n                ):\n                    buffer_extend(line)\n            else:\n                self._buffer.extend(new_segments)",
        "line_count": 98,
        "needs_llm_summary": true
      },
      {
        "name": "print_json",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "json",
            "type": "Optional[str]"
          }
        ],
        "return_type": "None",
        "lineno": 1747,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "str",
          "check_circular",
          "indent",
          "json_renderable",
          "ensure_ascii",
          "sort_keys",
          "highlight",
          "JSON",
          "TypeError",
          "allow_nan",
          "json",
          "default",
          "JSON.from_data",
          "data",
          "skip_keys",
          "self.print"
        ],
        "docstring": "Pretty prints JSON. Output will be valid JSON.\n\nArgs:\n    json (Optional[str]): A string containing JSON.\n    data (Any): If json is not supplied, then encode this data.\n    indent (Union[None, int, str], optional): Number of spaces to indent. Defaults to 2.\n    highlight (bool, optional): Enable highlighting of output: Defaults to True.\n    skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n    ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n    check_circular (bool, optional): Check for circular references. Defaults to True.\n    allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n    default (Callable, optional): A callable that converts values that can not be encoded\n        in to something that can be JSON encoded. Defaults to None.\n    sort_keys (bool, optional): Sort dictionary keys. Defaults to False.",
        "code": "def print_json(\n        self,\n        json: Optional[str] = None,\n        *,\n        data: Any = None,\n        indent: Union[None, int, str] = 2,\n        highlight: bool = True,\n        skip_keys: bool = False,\n        ensure_ascii: bool = False,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        default: Optional[Callable[[Any], Any]] = None,\n        sort_keys: bool = False,\n    ) -> None:\n        \"\"\"Pretty prints JSON. Output will be valid JSON.\n\n        Args:\n            json (Optional[str]): A string containing JSON.\n            data (Any): If json is not supplied, then encode this data.\n            indent (Union[None, int, str], optional): Number of spaces to indent. Defaults to 2.\n            highlight (bool, optional): Enable highlighting of output: Defaults to True.\n            skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n            ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n            check_circular (bool, optional): Check for circular references. Defaults to True.\n            allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n            default (Callable, optional): A callable that converts values that can not be encoded\n                in to something that can be JSON encoded. Defaults to None.\n            sort_keys (bool, optional): Sort dictionary keys. Defaults to False.\n        \"\"\"\n        from rich.json import JSON\n\n        if json is None:\n            json_renderable = JSON.from_data(\n                data,\n                indent=indent,\n                highlight=highlight,\n                skip_keys=skip_keys,\n                ensure_ascii=ensure_ascii,\n                check_circular=check_circular,\n                allow_nan=allow_nan,\n                default=default,\n                sort_keys=sort_keys,\n            )\n        else:\n            if not isinstance(json, str):\n                raise TypeError(\n                    f\"json must be str. Did you mean print_json(data={json!r}) ?\"\n                )\n            json_renderable = JSON(\n                json,\n                indent=indent,\n                highlight=highlight,\n                skip_keys=skip_keys,\n                ensure_ascii=ensure_ascii,\n                check_circular=check_circular,\n                allow_nan=allow_nan,\n                default=default,\n                sort_keys=sort_keys,\n            )\n        self.print(json_renderable, soft_wrap=True)",
        "line_count": 60,
        "needs_llm_summary": true
      },
      {
        "name": "update_screen",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 1808,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "self.render_lines",
          "render_options.update_dimensions",
          "render_options.max_width",
          "self.update_screen_lines",
          "y",
          "renderable",
          "x",
          "width",
          "height",
          "errors.NoAltScreen",
          "render_options",
          "region"
        ],
        "docstring": "Update the screen at a given offset.\n\nArgs:\n    renderable (RenderableType): A Rich renderable.\n    region (Region, optional): Region of screen to update, or None for entire screen. Defaults to None.\n    x (int, optional): x offset. Defaults to 0.\n    y (int, optional): y offset. Defaults to 0.\n\nRaises:\n    errors.NoAltScreen: If the Console isn't in alt screen mode.",
        "code": "def update_screen(\n        self,\n        renderable: RenderableType,\n        *,\n        region: Optional[Region] = None,\n        options: Optional[ConsoleOptions] = None,\n    ) -> None:\n        \"\"\"Update the screen at a given offset.\n\n        Args:\n            renderable (RenderableType): A Rich renderable.\n            region (Region, optional): Region of screen to update, or None for entire screen. Defaults to None.\n            x (int, optional): x offset. Defaults to 0.\n            y (int, optional): y offset. Defaults to 0.\n\n        Raises:\n            errors.NoAltScreen: If the Console isn't in alt screen mode.\n\n        \"\"\"\n        if not self.is_alt_screen:\n            raise errors.NoAltScreen(\"Alt screen must be enabled to call update_screen\")\n        render_options = options or self.options\n        if region is None:\n            x = y = 0\n            render_options = render_options.update_dimensions(\n                render_options.max_width, render_options.height or self.height\n            )\n        else:\n            x, y, width, height = region\n            render_options = render_options.update_dimensions(width, height)\n\n        lines = self.render_lines(renderable, options=render_options)\n        self.update_screen_lines(lines, x, y)",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "update_screen_lines",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lines",
            "type": "List[List[Segment]]"
          },
          {
            "name": "x",
            "type": "int"
          },
          {
            "name": "y",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 1842,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._check_buffer",
          "self.render",
          "lines",
          "ScreenUpdate",
          "screen_update",
          "errors.NoAltScreen",
          "y",
          "segments",
          "self._buffer.extend",
          "x"
        ],
        "docstring": "Update lines of the screen at a given offset.\n\nArgs:\n    lines (List[List[Segment]]): Rendered lines (as produced by :meth:`~rich.Console.render_lines`).\n    x (int, optional): x offset (column no). Defaults to 0.\n    y (int, optional): y offset (column no). Defaults to 0.\n\nRaises:\n    errors.NoAltScreen: If the Console isn't in alt screen mode.",
        "code": "def update_screen_lines(\n        self, lines: List[List[Segment]], x: int = 0, y: int = 0\n    ) -> None:\n        \"\"\"Update lines of the screen at a given offset.\n\n        Args:\n            lines (List[List[Segment]]): Rendered lines (as produced by :meth:`~rich.Console.render_lines`).\n            x (int, optional): x offset (column no). Defaults to 0.\n            y (int, optional): y offset (column no). Defaults to 0.\n\n        Raises:\n            errors.NoAltScreen: If the Console isn't in alt screen mode.\n        \"\"\"\n        if not self.is_alt_screen:\n            raise errors.NoAltScreen(\"Alt screen must be enabled to call update_screen\")\n        screen_update = ScreenUpdate(lines, x, y)\n        segments = self.render(screen_update)\n        self._buffer.extend(segments)\n        self._check_buffer()",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "print_exception",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1862,
        "decorators": [],
        "is_async": false,
        "calls": [
          "word_wrap",
          "max_frames",
          "suppress",
          "traceback",
          "Traceback",
          "theme",
          "width",
          "extra_lines",
          "show_locals",
          "self.print"
        ],
        "docstring": "Prints a rich render of the last exception and traceback.\n\nArgs:\n    width (Optional[int], optional): Number of characters used to render code. Defaults to 100.\n    extra_lines (int, optional): Additional lines of code to render. Defaults to 3.\n    theme (str, optional): Override pygments theme used in traceback\n    word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n    show_locals (bool, optional): Enable display of local variables. Defaults to False.\n    suppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n    max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.",
        "code": "def print_exception(\n        self,\n        *,\n        width: Optional[int] = 100,\n        extra_lines: int = 3,\n        theme: Optional[str] = None,\n        word_wrap: bool = False,\n        show_locals: bool = False,\n        suppress: Iterable[Union[str, ModuleType]] = (),\n        max_frames: int = 100,\n    ) -> None:\n        \"\"\"Prints a rich render of the last exception and traceback.\n\n        Args:\n            width (Optional[int], optional): Number of characters used to render code. Defaults to 100.\n            extra_lines (int, optional): Additional lines of code to render. Defaults to 3.\n            theme (str, optional): Override pygments theme used in traceback\n            word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n            show_locals (bool, optional): Enable display of local variables. Defaults to False.\n            suppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n            max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n        \"\"\"\n        from .traceback import Traceback\n\n        traceback = Traceback(\n            width=width,\n            extra_lines=extra_lines,\n            theme=theme,\n            word_wrap=word_wrap,\n            show_locals=show_locals,\n            suppress=suppress,\n            max_frames=max_frames,\n        )\n        self.print(traceback)",
        "line_count": 34,
        "needs_llm_summary": true
      },
      {
        "name": "_caller_frame_info",
        "args": [
          {
            "name": "offset",
            "type": "int"
          },
          {
            "name": "currentframe",
            "type": "Callable[Any, Optional[FrameType]]"
          }
        ],
        "return_type": "Tuple[str, int, Dict[str, Any]]",
        "lineno": 1898,
        "decorators": [
          {
            "name": "staticmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "frame.f_back",
          "currentframe",
          "inspect.stack"
        ],
        "docstring": "Get caller frame information.\n\nArgs:\n    offset (int): the caller offset within the current frame stack.\n    currentframe (Callable[[], Optional[FrameType]], optional): the callable to use to\n        retrieve the current frame. Defaults to ``inspect.currentframe``.\n\nReturns:\n    Tuple[str, int, Dict[str, Any]]: A tuple containing the filename, the line number and\n        the dictionary of local variables associated with the caller frame.\n\nRaises:\n    RuntimeError: If the stack offset is invalid.",
        "code": "def _caller_frame_info(\n        offset: int,\n        currentframe: Callable[[], Optional[FrameType]] = inspect.currentframe,\n    ) -> Tuple[str, int, Dict[str, Any]]:\n        \"\"\"Get caller frame information.\n\n        Args:\n            offset (int): the caller offset within the current frame stack.\n            currentframe (Callable[[], Optional[FrameType]], optional): the callable to use to\n                retrieve the current frame. Defaults to ``inspect.currentframe``.\n\n        Returns:\n            Tuple[str, int, Dict[str, Any]]: A tuple containing the filename, the line number and\n                the dictionary of local variables associated with the caller frame.\n\n        Raises:\n            RuntimeError: If the stack offset is invalid.\n        \"\"\"\n        # Ignore the frame of this local helper\n        offset += 1\n\n        frame = currentframe()\n        if frame is not None:\n            # Use the faster currentframe where implemented\n            while offset and frame is not None:\n                frame = frame.f_back\n                offset -= 1\n            assert frame is not None\n            return frame.f_code.co_filename, frame.f_lineno, frame.f_locals\n        else:\n            # Fallback to the slower stack\n            frame_info = inspect.stack()[offset]\n            return frame_info.filename, frame_info.lineno, frame_info.frame.f_locals",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "log",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1932,
        "decorators": [],
        "is_async": false,
        "calls": [
          "end",
          "markup",
          "style",
          "highlight",
          "NewLine",
          "locals_map",
          "self.width",
          "renderables.append",
          "extend",
          "render",
          "hook.process_renderables",
          "self.options",
          "filename.startswith",
          "render_options",
          "self.render",
          "render_scope",
          "link_path",
          "emoji",
          "self._collect_renderables",
          "new_segments",
          "filename",
          "self._log_render",
          "self._buffer.extend",
          "key.startswith",
          "line",
          "self.get_datetime",
          "new_segments.extend",
          "line_no",
          "objects",
          "renderable",
          "justify",
          "Segment.split_and_crop_lines",
          "os.path.abspath",
          "self._caller_frame_info",
          "buffer_extend",
          "Styled",
          "_stack_offset",
          "path",
          "os.sep",
          "renderables",
          "sep",
          "filename.rpartition",
          "locals.items",
          "self"
        ],
        "docstring": "Log rich content to the terminal.\n\nArgs:\n    objects (positional args): Objects to log to the terminal.\n    sep (str, optional): String to write between print data. Defaults to \" \".\n    end (str, optional): String to write at end of print data. Defaults to \"\\\\n\".\n    style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n    justify (str, optional): One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n    emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to None.\n    markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to None.\n    highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to None.\n    log_locals (bool, optional): Boolean to enable logging of locals where ``log()``\n        was called. Defaults to False.\n    _stack_offset (int, optional): Offset of caller from end of call stack. Defaults to 1.",
        "code": "def log(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        justify: Optional[JustifyMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        log_locals: bool = False,\n        _stack_offset: int = 1,\n    ) -> None:\n        \"\"\"Log rich content to the terminal.\n\n        Args:\n            objects (positional args): Objects to log to the terminal.\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            justify (str, optional): One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to None.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to None.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to None.\n            log_locals (bool, optional): Boolean to enable logging of locals where ``log()``\n                was called. Defaults to False.\n            _stack_offset (int, optional): Offset of caller from end of call stack. Defaults to 1.\n        \"\"\"\n        if not objects:\n            objects = (NewLine(),)\n\n        render_hooks = self._render_hooks[:]\n\n        with self:\n            renderables = self._collect_renderables(\n                objects,\n                sep,\n                end,\n                justify=justify,\n                emoji=emoji,\n                markup=markup,\n                highlight=highlight,\n            )\n            if style is not None:\n                renderables = [Styled(renderable, style) for renderable in renderables]\n\n            filename, line_no, locals = self._caller_frame_info(_stack_offset)\n            link_path = None if filename.startswith(\"<\") else os.path.abspath(filename)\n            path = filename.rpartition(os.sep)[-1]\n            if log_locals:\n                locals_map = {\n                    key: value\n                    for key, value in locals.items()\n                    if not key.startswith(\"__\")\n                }\n                renderables.append(render_scope(locals_map, title=\"[i]locals\"))\n\n            renderables = [\n                self._log_render(\n                    self,\n                    renderables,\n                    log_time=self.get_datetime(),\n                    path=path,\n                    line_no=line_no,\n                    link_path=link_path,\n                )\n            ]\n            for hook in render_hooks:\n                renderables = hook.process_renderables(renderables)\n            new_segments: List[Segment] = []\n            extend = new_segments.extend\n            render = self.render\n            render_options = self.options\n            for renderable in renderables:\n                extend(render(renderable, render_options))\n            buffer_extend = self._buffer.extend\n            for line in Segment.split_and_crop_lines(\n                new_segments, self.width, pad=False\n            ):\n                buffer_extend(line)",
        "line_count": 80,
        "needs_llm_summary": true
      },
      {
        "name": "on_broken_pipe",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 2013,
        "decorators": [],
        "is_async": false,
        "calls": [
          "os.O_WRONLY",
          "devnull",
          "SystemExit",
          "os.open",
          "sys.stdout.fileno",
          "os.devnull",
          "os.dup2"
        ],
        "docstring": "This function is called when a `BrokenPipeError` is raised.\n\nThis can occur when piping Textual output in Linux and macOS.\nThe default implementation is to exit the app, but you could implement\nthis method in a subclass to change the behavior.\n\nSee https://docs.python.org/3/library/signal.html#note-on-sigpipe for details.",
        "code": "def on_broken_pipe(self) -> None:\n        \"\"\"This function is called when a `BrokenPipeError` is raised.\n\n        This can occur when piping Textual output in Linux and macOS.\n        The default implementation is to exit the app, but you could implement\n        this method in a subclass to change the behavior.\n\n        See https://docs.python.org/3/library/signal.html#note-on-sigpipe for details.\n        \"\"\"\n        self.quiet = True\n        devnull = os.open(os.devnull, os.O_WRONLY)\n        os.dup2(devnull, sys.stdout.fileno())\n        raise SystemExit(1)",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "_check_buffer",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 2027,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.on_broken_pipe",
          "self._write_buffer"
        ],
        "docstring": "Check if the buffer may be rendered. Render it if it can (e.g. Console.quiet is False)\nRendering is supported on Windows, Unix and Jupyter environments. For\nlegacy Windows consoles, the win32 API is called directly.\nThis method will also record what it renders if recording is enabled via Console.record.",
        "code": "def _check_buffer(self) -> None:\n        \"\"\"Check if the buffer may be rendered. Render it if it can (e.g. Console.quiet is False)\n        Rendering is supported on Windows, Unix and Jupyter environments. For\n        legacy Windows consoles, the win32 API is called directly.\n        This method will also record what it renders if recording is enabled via Console.record.\n        \"\"\"\n        if self.quiet:\n            del self._buffer[:]\n            return\n\n        try:\n            self._write_buffer()\n        except BrokenPipeError:\n            self.on_broken_pipe()",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "_write_buffer",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 2042,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._record_buffer.extend",
          "self.file.write",
          "buffer",
          "list",
          "write",
          "self.file",
          "get_fileno",
          "Segment.remove_color",
          "display",
          "unknown.join",
          "batch_append",
          "line",
          "batch",
          "batch.append",
          "self._buffer",
          "text",
          "len",
          "LegacyWindowsTerm",
          "legacy_windows_render",
          "self._render_buffer",
          "self.file.flush",
          "text.splitlines",
          "batch.clear"
        ],
        "docstring": "Write the buffer to the output file.",
        "code": "def _write_buffer(self) -> None:\n        \"\"\"Write the buffer to the output file.\"\"\"\n\n        with self._lock:\n            if self.record and not self._buffer_index:\n                with self._record_buffer_lock:\n                    self._record_buffer.extend(self._buffer[:])\n\n            if self._buffer_index == 0:\n                if self.is_jupyter:  # pragma: no cover\n                    from .jupyter import display\n\n                    display(self._buffer, self._render_buffer(self._buffer[:]))\n                    del self._buffer[:]\n                else:\n                    if WINDOWS:\n                        use_legacy_windows_render = False\n                        if self.legacy_windows:\n                            fileno = get_fileno(self.file)\n                            if fileno is not None:\n                                use_legacy_windows_render = (\n                                    fileno in _STD_STREAMS_OUTPUT\n                                )\n\n                        if use_legacy_windows_render:\n                            from rich._win32_console import LegacyWindowsTerm\n                            from rich._windows_renderer import legacy_windows_render\n\n                            buffer = self._buffer[:]\n                            if self.no_color and self._color_system:\n                                buffer = list(Segment.remove_color(buffer))\n\n                            legacy_windows_render(buffer, LegacyWindowsTerm(self.file))\n                        else:\n                            # Either a non-std stream on legacy Windows, or modern Windows.\n                            text = self._render_buffer(self._buffer[:])\n                            # https://bugs.python.org/issue37871\n                            # https://github.com/python/cpython/issues/82052\n                            # We need to avoid writing more than 32Kb in a single write, due to the above bug\n                            write = self.file.write\n                            # Worse case scenario, every character is 4 bytes of utf-8\n                            MAX_WRITE = 32 * 1024 // 4\n                            try:\n                                if len(text) <= MAX_WRITE:\n                                    write(text)\n                                else:\n                                    batch: List[str] = []\n                                    batch_append = batch.append\n                                    size = 0\n                                    for line in text.splitlines(True):\n                                        if size + len(line) > MAX_WRITE and batch:\n                                            write(\"\".join(batch))\n                                            batch.clear()\n                                            size = 0\n                                        batch_append(line)\n                                        size += len(line)\n                                    if batch:\n                                        write(\"\".join(batch))\n                                        batch.clear()\n                            except UnicodeEncodeError as error:\n                                error.reason = f\"{error.reason}\\n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***\"\n                                raise\n                    else:\n                        text = self._render_buffer(self._buffer[:])\n                        try:\n                            self.file.write(text)\n                        except UnicodeEncodeError as error:\n                            error.reason = f\"{error.reason}\\n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***\"\n                            raise\n\n                    self.file.flush()\n                    del self._buffer[:]",
        "line_count": 72,
        "needs_llm_summary": true
      },
      {
        "name": "_render_buffer",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "buffer",
            "type": "Iterable[Segment]"
          }
        ],
        "return_type": "str",
        "lineno": 2115,
        "decorators": [],
        "is_async": false,
        "calls": [
          "append",
          "self._color_system",
          "Segment.remove_color",
          "style.render",
          "legacy_windows",
          "color_system",
          "output.append",
          "buffer",
          "output",
          "unknown.join",
          "text",
          "self.legacy_windows"
        ],
        "docstring": "Render buffered output, and clear buffer.",
        "code": "def _render_buffer(self, buffer: Iterable[Segment]) -> str:\n        \"\"\"Render buffered output, and clear buffer.\"\"\"\n        output: List[str] = []\n        append = output.append\n        color_system = self._color_system\n        legacy_windows = self.legacy_windows\n        not_terminal = not self.is_terminal\n        if self.no_color and color_system:\n            buffer = Segment.remove_color(buffer)\n        for text, style, control in buffer:\n            if style:\n                append(\n                    style.render(\n                        text,\n                        color_system=color_system,\n                        legacy_windows=legacy_windows,\n                    )\n                )\n            elif not (not_terminal and control):\n                append(text)\n\n        rendered = \"\".join(output)\n        return rendered",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "input",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "prompt",
            "type": "TextType"
          }
        ],
        "return_type": "str",
        "lineno": 2139,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "getpass",
          "prompt",
          "input",
          "markup",
          "emoji",
          "stream.readline",
          "self.print"
        ],
        "docstring": "Displays a prompt and waits for input from the user. The prompt may contain color / style.\n\nIt works in the same way as Python's builtin :func:`input` function and provides elaborate line editing and history features if Python's builtin :mod:`readline` module is previously loaded.\n\nArgs:\n    prompt (Union[str, Text]): Text to render in the prompt.\n    markup (bool, optional): Enable console markup (requires a str prompt). Defaults to True.\n    emoji (bool, optional): Enable emoji (requires a str prompt). Defaults to True.\n    password: (bool, optional): Hide typed text. Defaults to False.\n    stream: (TextIO, optional): Optional file to read input from (rather than stdin). Defaults to None.\n\nReturns:\n    str: Text read from stdin.",
        "code": "def input(\n        self,\n        prompt: TextType = \"\",\n        *,\n        markup: bool = True,\n        emoji: bool = True,\n        password: bool = False,\n        stream: Optional[TextIO] = None,\n    ) -> str:\n        \"\"\"Displays a prompt and waits for input from the user. The prompt may contain color / style.\n\n        It works in the same way as Python's builtin :func:`input` function and provides elaborate line editing and history features if Python's builtin :mod:`readline` module is previously loaded.\n\n        Args:\n            prompt (Union[str, Text]): Text to render in the prompt.\n            markup (bool, optional): Enable console markup (requires a str prompt). Defaults to True.\n            emoji (bool, optional): Enable emoji (requires a str prompt). Defaults to True.\n            password: (bool, optional): Hide typed text. Defaults to False.\n            stream: (TextIO, optional): Optional file to read input from (rather than stdin). Defaults to None.\n\n        Returns:\n            str: Text read from stdin.\n        \"\"\"\n        if prompt:\n            self.print(prompt, markup=markup, emoji=emoji, end=\"\")\n        if password:\n            result = getpass(\"\", stream=stream)\n        else:\n            if stream:\n                result = stream.readline()\n            else:\n                result = input()\n        return result",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "export_text",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 2173,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "style.render",
          "text"
        ],
        "docstring": "Generate text from console contents (requires record=True argument in constructor).\n\nArgs:\n    clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n    styles (bool, optional): If ``True``, ansi escape codes will be included. ``False`` for plain text.\n        Defaults to ``False``.\n\nReturns:\n    str: String containing console contents.",
        "code": "def export_text(self, *, clear: bool = True, styles: bool = False) -> str:\n        \"\"\"Generate text from console contents (requires record=True argument in constructor).\n\n        Args:\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            styles (bool, optional): If ``True``, ansi escape codes will be included. ``False`` for plain text.\n                Defaults to ``False``.\n\n        Returns:\n            str: String containing console contents.\n\n        \"\"\"\n        assert (\n            self.record\n        ), \"To export console contents set record=True in the constructor or instance\"\n\n        with self._record_buffer_lock:\n            if styles:\n                text = \"\".join(\n                    (style.render(text) if style else text)\n                    for text, style, _ in self._record_buffer\n                )\n            else:\n                text = \"\".join(\n                    segment.text\n                    for segment in self._record_buffer\n                    if not segment.control\n                )\n            if clear:\n                del self._record_buffer[:]\n        return text",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "save_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "path",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 2205,
        "decorators": [],
        "is_async": false,
        "calls": [
          "write_file.write",
          "path",
          "clear",
          "text",
          "open",
          "self.export_text",
          "styles"
        ],
        "docstring": "Generate text from console and save to a given location (requires record=True argument in constructor).\n\nArgs:\n    path (str): Path to write text files.\n    clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n    styles (bool, optional): If ``True``, ansi style codes will be included. ``False`` for plain text.\n        Defaults to ``False``.",
        "code": "def save_text(self, path: str, *, clear: bool = True, styles: bool = False) -> None:\n        \"\"\"Generate text from console and save to a given location (requires record=True argument in constructor).\n\n        Args:\n            path (str): Path to write text files.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            styles (bool, optional): If ``True``, ansi style codes will be included. ``False`` for plain text.\n                Defaults to ``False``.\n\n        \"\"\"\n        text = self.export_text(clear=clear, styles=styles)\n        with open(path, \"w\", encoding=\"utf-8\") as write_file:\n            write_file.write(text)",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "export_html",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 2219,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style.get_html_style",
          "_theme",
          "self._record_buffer",
          "_theme.foreground_color.hex",
          "unknown.join",
          "rule",
          "escape",
          "stylesheet_rules.append",
          "fragments.append",
          "append",
          "styles.items",
          "text",
          "Segment.filter_control",
          "Segment.simplify",
          "stylesheet_append",
          "styles.setdefault",
          "len",
          "render_code_format.format",
          "_theme.background_color.hex",
          "fragments",
          "stylesheet_rules",
          "styles",
          "stylesheet"
        ],
        "docstring": "Generate HTML from console contents (requires record=True argument in constructor).\n\nArgs:\n    theme (TerminalTheme, optional): TerminalTheme object containing console colors.\n    clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n    code_format (str, optional): Format string to render HTML. In addition to '{foreground}',\n        '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.\n    inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files\n        larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.\n        Defaults to False.\n\nReturns:\n    str: String containing console contents as HTML.",
        "code": "def export_html(\n        self,\n        *,\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: Optional[str] = None,\n        inline_styles: bool = False,\n    ) -> str:\n        \"\"\"Generate HTML from console contents (requires record=True argument in constructor).\n\n        Args:\n            theme (TerminalTheme, optional): TerminalTheme object containing console colors.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            code_format (str, optional): Format string to render HTML. In addition to '{foreground}',\n                '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.\n            inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files\n                larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.\n                Defaults to False.\n\n        Returns:\n            str: String containing console contents as HTML.\n        \"\"\"\n        assert (\n            self.record\n        ), \"To export console contents set record=True in the constructor or instance\"\n        fragments: List[str] = []\n        append = fragments.append\n        _theme = theme or DEFAULT_TERMINAL_THEME\n        stylesheet = \"\"\n\n        render_code_format = CONSOLE_HTML_FORMAT if code_format is None else code_format\n\n        with self._record_buffer_lock:\n            if inline_styles:\n                for text, style, _ in Segment.filter_control(\n                    Segment.simplify(self._record_buffer)\n                ):\n                    text = escape(text)\n                    if style:\n                        rule = style.get_html_style(_theme)\n                        if style.link:\n                            text = f'<a href=\"{style.link}\">{text}</a>'\n                        text = f'<span style=\"{rule}\">{text}</span>' if rule else text\n                    append(text)\n            else:\n                styles: Dict[str, int] = {}\n                for text, style, _ in Segment.filter_control(\n                    Segment.simplify(self._record_buffer)\n                ):\n                    text = escape(text)\n                    if style:\n                        rule = style.get_html_style(_theme)\n                        style_number = styles.setdefault(rule, len(styles) + 1)\n                        if style.link:\n                            text = f'<a class=\"r{style_number}\" href=\"{style.link}\">{text}</a>'\n                        else:\n                            text = f'<span class=\"r{style_number}\">{text}</span>'\n                    append(text)\n                stylesheet_rules: List[str] = []\n                stylesheet_append = stylesheet_rules.append\n                for style_rule, style_number in styles.items():\n                    if style_rule:\n                        stylesheet_append(f\".r{style_number} {{{style_rule}}}\")\n                stylesheet = \"\\n\".join(stylesheet_rules)\n\n            rendered_code = render_code_format.format(\n                code=\"\".join(fragments),\n                stylesheet=stylesheet,\n                foreground=_theme.foreground_color.hex,\n                background=_theme.background_color.hex,\n            )\n            if clear:\n                del self._record_buffer[:]\n        return rendered_code",
        "line_count": 74,
        "needs_llm_summary": true
      },
      {
        "name": "save_html",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "path",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 2294,
        "decorators": [],
        "is_async": false,
        "calls": [
          "write_file.write",
          "code_format",
          "self.export_html",
          "path",
          "theme",
          "clear",
          "open",
          "inline_styles",
          "html"
        ],
        "docstring": "Generate HTML from console contents and write to a file (requires record=True argument in constructor).\n\nArgs:\n    path (str): Path to write html file.\n    theme (TerminalTheme, optional): TerminalTheme object containing console colors.\n    clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n    code_format (str, optional): Format string to render HTML. In addition to '{foreground}',\n        '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.\n    inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files\n        larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.\n        Defaults to False.",
        "code": "def save_html(\n        self,\n        path: str,\n        *,\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_HTML_FORMAT,\n        inline_styles: bool = False,\n    ) -> None:\n        \"\"\"Generate HTML from console contents and write to a file (requires record=True argument in constructor).\n\n        Args:\n            path (str): Path to write html file.\n            theme (TerminalTheme, optional): TerminalTheme object containing console colors.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            code_format (str, optional): Format string to render HTML. In addition to '{foreground}',\n                '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.\n            inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files\n                larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.\n                Defaults to False.\n\n        \"\"\"\n        html = self.export_html(\n            theme=theme,\n            clear=clear,\n            code_format=code_format,\n            inline_styles=inline_styles,\n        )\n        with open(path, \"w\", encoding=\"utf-8\") as write_file:\n            write_file.write(html)",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "export_svg",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 2325,
        "decorators": [],
        "is_async": false,
        "calls": [
          "segment",
          "enumerate",
          "lines",
          "offset",
          "style.bgcolor.get_truecolor",
          "code_format.format",
          "css_rules",
          "style",
          "css_rules.append",
          "title_color",
          "self.width",
          "list",
          "y",
          "unique_id",
          "format",
          "Style",
          "blend_rgb",
          "text_group",
          "margin_left",
          "_theme",
          "style.color.get_truecolor",
          "margin_top",
          "self._record_buffer.clear",
          "terminal_width",
          "color",
          "make_tag",
          "unknown.replace",
          "self._record_buffer",
          "_theme.foreground_color.hex",
          "unknown.join",
          "title",
          "escape",
          "css",
          "background",
          "v",
          "char_height",
          "classes.items",
          "get_svg_style",
          "cell_len",
          "str",
          "value",
          "style_no",
          "attribs.items",
          "stringify",
          "zlib.adler32",
          "k.lstrip",
          "chrome",
          "width",
          "line_height",
          "float",
          "Segment.filter_control",
          "Segment.split_and_crop_lines",
          "bgcolor",
          "text",
          "text_group.append",
          "text_backgrounds.append",
          "backgrounds",
          "line_offsets",
          "isinstance",
          "escape_text",
          "len",
          "range",
          "unknown.encode",
          "_theme.background_color.hex",
          "title.encode",
          "matrix",
          "style.bgcolor",
          "terminal_height",
          "segments",
          "char_width",
          "text_backgrounds",
          "styles",
          "ceil",
          "repr"
        ],
        "docstring": "Generate an SVG from the console contents (requires record=True in Console constructor).\n\nArgs:\n    title (str, optional): The title of the tab in the output image\n    theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal\n    clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``\n    code_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables\n        into the string in order to form the final SVG output. The default template used and the variables\n        injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n    font_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``\n        string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).\n        If you aren't specifying a different font inside ``code_format``, you probably don't need this.\n    unique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node\n        ids). If not set, this defaults to a computed value based on the recorded content.",
        "code": "def export_svg(\n        self,\n        *,\n        title: str = \"Rich\",\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_SVG_FORMAT,\n        font_aspect_ratio: float = 0.61,\n        unique_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Generate an SVG from the console contents (requires record=True in Console constructor).\n\n        Args:\n            title (str, optional): The title of the tab in the output image\n            theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``\n            code_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables\n                into the string in order to form the final SVG output. The default template used and the variables\n                injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n            font_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``\n                string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).\n                If you aren't specifying a different font inside ``code_format``, you probably don't need this.\n            unique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node\n                ids). If not set, this defaults to a computed value based on the recorded content.\n        \"\"\"\n\n        from rich.cells import cell_len\n\n        style_cache: Dict[Style, str] = {}\n\n        def get_svg_style(style: Style) -> str:\n            \"\"\"Convert a Style to CSS rules for SVG.\"\"\"\n            if style in style_cache:\n                return style_cache[style]\n            css_rules = []\n            color = (\n                _theme.foreground_color\n                if (style.color is None or style.color.is_default)\n                else style.color.get_truecolor(_theme)\n            )\n            bgcolor = (\n                _theme.background_color\n                if (style.bgcolor is None or style.bgcolor.is_default)\n                else style.bgcolor.get_truecolor(_theme)\n            )\n            if style.reverse:\n                color, bgcolor = bgcolor, color\n            if style.dim:\n                color = blend_rgb(color, bgcolor, 0.4)\n            css_rules.append(f\"fill: {color.hex}\")\n            if style.bold:\n                css_rules.append(\"font-weight: bold\")\n            if style.italic:\n                css_rules.append(\"font-style: italic;\")\n            if style.underline:\n                css_rules.append(\"text-decoration: underline;\")\n            if style.strike:\n                css_rules.append(\"text-decoration: line-through;\")\n\n            css = \";\".join(css_rules)\n            style_cache[style] = css\n            return css\n\n        _theme = theme or SVG_EXPORT_THEME\n\n        width = self.width\n        char_height = 20\n        char_width = char_height * font_aspect_ratio\n        line_height = char_height * 1.22\n\n        margin_top = 1\n        margin_right = 1\n        margin_bottom = 1\n        margin_left = 1\n\n        padding_top = 40\n        padding_right = 8\n        padding_bottom = 8\n        padding_left = 8\n\n        padding_width = padding_left + padding_right\n        padding_height = padding_top + padding_bottom\n        margin_width = margin_left + margin_right\n        margin_height = margin_top + margin_bottom\n\n        text_backgrounds: List[str] = []\n        text_group: List[str] = []\n        classes: Dict[str, int] = {}\n        style_no = 1\n\n        def escape_text(text: str) -> str:\n            \"\"\"HTML escape text and replace spaces with nbsp.\"\"\"\n            return escape(text).replace(\" \", \"&#160;\")\n\n        def make_tag(\n            name: str, content: Optional[str] = None, **attribs: object\n        ) -> str:\n            \"\"\"Make a tag from name, content, and attributes.\"\"\"\n\n            def stringify(value: object) -> str:\n                if isinstance(value, (float)):\n                    return format(value, \"g\")\n                return str(value)\n\n            tag_attribs = \" \".join(\n                f'{k.lstrip(\"_\").replace(\"_\", \"-\")}=\"{stringify(v)}\"'\n                for k, v in attribs.items()\n            )\n            return (\n                f\"<{name} {tag_attribs}>{content}</{name}>\"\n                if content\n                else f\"<{name} {tag_attribs}/>\"\n            )\n\n        with self._record_buffer_lock:\n            segments = list(Segment.filter_control(self._record_buffer))\n            if clear:\n                self._record_buffer.clear()\n\n        if unique_id is None:\n            unique_id = \"terminal-\" + str(\n                zlib.adler32(\n                    (\"\".join(repr(segment) for segment in segments)).encode(\n                        \"utf-8\",\n                        \"ignore\",\n                    )\n                    + title.encode(\"utf-8\", \"ignore\")\n                )\n            )\n        y = 0\n        for y, line in enumerate(Segment.split_and_crop_lines(segments, length=width)):\n            x = 0\n            for text, style, _control in line:\n                style = style or Style()\n                rules = get_svg_style(style)\n                if rules not in classes:\n                    classes[rules] = style_no\n                    style_no += 1\n                class_name = f\"r{classes[rules]}\"\n\n                if style.reverse:\n                    has_background = True\n                    background = (\n                        _theme.foreground_color.hex\n                        if style.color is None\n                        else style.color.get_truecolor(_theme).hex\n                    )\n                else:\n                    bgcolor = style.bgcolor\n                    has_background = bgcolor is not None and not bgcolor.is_default\n                    background = (\n                        _theme.background_color.hex\n                        if style.bgcolor is None\n                        else style.bgcolor.get_truecolor(_theme).hex\n                    )\n\n                text_length = cell_len(text)\n                if has_background:\n                    text_backgrounds.append(\n                        make_tag(\n                            \"rect\",\n                            fill=background,\n                            x=x * char_width,\n                            y=y * line_height + 1.5,\n                            width=char_width * text_length,\n                            height=line_height + 0.25,\n                            shape_rendering=\"crispEdges\",\n                        )\n                    )\n\n                if text != \" \" * len(text):\n                    text_group.append(\n                        make_tag(\n                            \"text\",\n                            escape_text(text),\n                            _class=f\"{unique_id}-{class_name}\",\n                            x=x * char_width,\n                            y=y * line_height + char_height,\n                            textLength=char_width * len(text),\n                            clip_path=f\"url(#{unique_id}-line-{y})\",\n                        )\n                    )\n                x += cell_len(text)\n\n        line_offsets = [line_no * line_height + 1.5 for line_no in range(y)]\n        lines = \"\\n\".join(\n            f\"\"\"<clipPath id=\"{unique_id}-line-{line_no}\">\n    {make_tag(\"rect\", x=0, y=offset, width=char_width * width, height=line_height + 0.25)}\n            </clipPath>\"\"\"\n            for line_no, offset in enumerate(line_offsets)\n        )\n\n        styles = \"\\n\".join(\n            f\".{unique_id}-r{rule_no} {{ {css} }}\" for css, rule_no in classes.items()\n        )\n        backgrounds = \"\".join(text_backgrounds)\n        matrix = \"\".join(text_group)\n\n        terminal_width = ceil(width * char_width + padding_width)\n        terminal_height = (y + 1) * line_height + padding_height\n        chrome = make_tag(\n            \"rect\",\n            fill=_theme.background_color.hex,\n            stroke=\"rgba(255,255,255,0.35)\",\n            stroke_width=\"1\",\n            x=margin_left,\n            y=margin_top,\n            width=terminal_width,\n            height=terminal_height,\n            rx=8,\n        )\n\n        title_color = _theme.foreground_color.hex\n        if title:\n            chrome += make_tag(\n                \"text\",\n                escape_text(title),\n                _class=f\"{unique_id}-title\",\n                fill=title_color,\n                text_anchor=\"middle\",\n                x=terminal_width // 2,\n                y=margin_top + char_height + 6,\n            )\n        chrome += f\"\"\"\n            <g transform=\"translate(26,22)\">\n            <circle cx=\"0\" cy=\"0\" r=\"7\" fill=\"#ff5f57\"/>\n            <circle cx=\"22\" cy=\"0\" r=\"7\" fill=\"#febc2e\"/>\n            <circle cx=\"44\" cy=\"0\" r=\"7\" fill=\"#28c840\"/>\n            </g>\n        \"\"\"\n\n        svg = code_format.format(\n            unique_id=unique_id,\n            char_width=char_width,\n            char_height=char_height,\n            line_height=line_height,\n            terminal_width=char_width * width - 1,\n            terminal_height=(y + 1) * line_height - 1,\n            width=terminal_width + margin_width,\n            height=terminal_height + margin_height,\n            terminal_x=margin_left + padding_left,\n            terminal_y=margin_top + padding_top,\n            styles=styles,\n            chrome=chrome,\n            backgrounds=backgrounds,\n            matrix=matrix,\n            lines=lines,\n        )\n        return svg",
        "line_count": 250,
        "needs_llm_summary": true
      },
      {
        "name": "save_svg",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "path",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 2576,
        "decorators": [],
        "is_async": false,
        "calls": [
          "open",
          "write_file.write",
          "code_format",
          "font_aspect_ratio",
          "path",
          "self.export_svg",
          "theme",
          "clear",
          "title",
          "unique_id",
          "svg"
        ],
        "docstring": "Generate an SVG file from the console contents (requires record=True in Console constructor).\n\nArgs:\n    path (str): The path to write the SVG to.\n    title (str, optional): The title of the tab in the output image\n    theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal\n    clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``\n    code_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables\n        into the string in order to form the final SVG output. The default template used and the variables\n        injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n    font_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``\n        string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).\n        If you aren't specifying a different font inside ``code_format``, you probably don't need this.\n    unique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node\n        ids). If not set, this defaults to a computed value based on the recorded content.",
        "code": "def save_svg(\n        self,\n        path: str,\n        *,\n        title: str = \"Rich\",\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_SVG_FORMAT,\n        font_aspect_ratio: float = 0.61,\n        unique_id: Optional[str] = None,\n    ) -> None:\n        \"\"\"Generate an SVG file from the console contents (requires record=True in Console constructor).\n\n        Args:\n            path (str): The path to write the SVG to.\n            title (str, optional): The title of the tab in the output image\n            theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``\n            code_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables\n                into the string in order to form the final SVG output. The default template used and the variables\n                injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n            font_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``\n                string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).\n                If you aren't specifying a different font inside ``code_format``, you probably don't need this.\n            unique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node\n                ids). If not set, this defaults to a computed value based on the recorded content.\n        \"\"\"\n        svg = self.export_svg(\n            title=title,\n            theme=theme,\n            clear=clear,\n            code_format=code_format,\n            font_aspect_ratio=font_aspect_ratio,\n            unique_id=unique_id,\n        )\n        with open(path, \"w\", encoding=\"utf-8\") as write_file:\n            write_file.write(svg)",
        "line_count": 37,
        "needs_llm_summary": true
      },
      {
        "name": "_replace",
        "args": [],
        "return_type": "Group",
        "lineno": 502,
        "decorators": [
          {
            "name": "wraps",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "kwargs",
          "method",
          "Group",
          "fit",
          "wraps"
        ],
        "docstring": null,
        "code": "def _replace(*args: Any, **kwargs: Any) -> Group:\n            renderables = method(*args, **kwargs)\n            return Group(*renderables, fit=fit)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "check_text",
        "args": [],
        "return_type": "None",
        "lineno": 1548,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sep_text.join",
          "end",
          "append",
          "text.clear",
          "justify",
          "text",
          "sep",
          "Text"
        ],
        "docstring": null,
        "code": "def check_text() -> None:\n            if text:\n                sep_text = Text(sep, justify=justify, end=end)\n                append(sep_text.join(text))\n                text.clear()",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_svg_style",
        "args": [
          {
            "name": "style",
            "type": "Style"
          }
        ],
        "return_type": "str",
        "lineno": 2356,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style.color.get_truecolor",
          "style.bgcolor.get_truecolor",
          "css_rules",
          "color",
          "css_rules.append",
          "unknown.join",
          "css",
          "bgcolor",
          "blend_rgb",
          "_theme"
        ],
        "docstring": "Convert a Style to CSS rules for SVG.",
        "code": "def get_svg_style(style: Style) -> str:\n            \"\"\"Convert a Style to CSS rules for SVG.\"\"\"\n            if style in style_cache:\n                return style_cache[style]\n            css_rules = []\n            color = (\n                _theme.foreground_color\n                if (style.color is None or style.color.is_default)\n                else style.color.get_truecolor(_theme)\n            )\n            bgcolor = (\n                _theme.background_color\n                if (style.bgcolor is None or style.bgcolor.is_default)\n                else style.bgcolor.get_truecolor(_theme)\n            )\n            if style.reverse:\n                color, bgcolor = bgcolor, color\n            if style.dim:\n                color = blend_rgb(color, bgcolor, 0.4)\n            css_rules.append(f\"fill: {color.hex}\")\n            if style.bold:\n                css_rules.append(\"font-weight: bold\")\n            if style.italic:\n                css_rules.append(\"font-style: italic;\")\n            if style.underline:\n                css_rules.append(\"text-decoration: underline;\")\n            if style.strike:\n                css_rules.append(\"text-decoration: line-through;\")\n\n            css = \";\".join(css_rules)\n            style_cache[style] = css\n            return css",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "escape_text",
        "args": [
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 2416,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.replace",
          "escape",
          "text"
        ],
        "docstring": "HTML escape text and replace spaces with nbsp.",
        "code": "def escape_text(text: str) -> str:\n            \"\"\"HTML escape text and replace spaces with nbsp.\"\"\"\n            return escape(text).replace(\" \", \"&#160;\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "make_tag",
        "args": [
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "content",
            "type": "Optional[str]"
          }
        ],
        "return_type": "str",
        "lineno": 2420,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "str",
          "value",
          "attribs.items",
          "unknown.replace",
          "stringify",
          "unknown.join",
          "k.lstrip",
          "float",
          "v",
          "format"
        ],
        "docstring": "Make a tag from name, content, and attributes.",
        "code": "def make_tag(\n            name: str, content: Optional[str] = None, **attribs: object\n        ) -> str:\n            \"\"\"Make a tag from name, content, and attributes.\"\"\"\n\n            def stringify(value: object) -> str:\n                if isinstance(value, (float)):\n                    return format(value, \"g\")\n                return str(value)\n\n            tag_attribs = \" \".join(\n                f'{k.lstrip(\"_\").replace(\"_\", \"-\")}=\"{stringify(v)}\"'\n                for k, v in attribs.items()\n            )\n            return (\n                f\"<{name} {tag_attribs}>{content}</{name}>\"\n                if content\n                else f\"<{name} {tag_attribs}/>\"\n            )",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "align_append",
        "args": [
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 1539,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_append",
          "AlignMethod",
          "renderable",
          "cast",
          "justify",
          "Align"
        ],
        "docstring": null,
        "code": "def align_append(renderable: RenderableType) -> None:\n                _append(Align(renderable, cast(AlignMethod, justify)))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "stringify",
        "args": [
          {
            "name": "value",
            "type": "object"
          }
        ],
        "return_type": "str",
        "lineno": 2425,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "str",
          "value",
          "float",
          "format"
        ],
        "docstring": null,
        "code": "def stringify(value: object) -> str:\n                if isinstance(value, (float)):\n                    return format(value, \"g\")\n                return str(value)",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "NoChange",
        "methods": [],
        "base_classes": [],
        "lineno": 79,
        "docstring": null
      },
      {
        "name": "ConsoleDimensions",
        "methods": [],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 109,
        "docstring": "Size of the terminal."
      },
      {
        "name": "ConsoleOptions",
        "methods": [
          "ascii_only",
          "copy",
          "update",
          "update_width",
          "update_height",
          "reset_height",
          "update_dimensions"
        ],
        "base_classes": [],
        "lineno": 119,
        "docstring": "Options for __rich_console__ method."
      },
      {
        "name": "RichCast",
        "methods": [
          "__rich__"
        ],
        "base_classes": [
          "Protocol"
        ],
        "lineno": 253,
        "docstring": "An object that may be 'cast' to a console renderable."
      },
      {
        "name": "ConsoleRenderable",
        "methods": [
          "__rich_console__"
        ],
        "base_classes": [
          "Protocol"
        ],
        "lineno": 263,
        "docstring": "An object that supports the console protocol."
      },
      {
        "name": "CaptureError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 282,
        "docstring": "An error in the Capture context manager."
      },
      {
        "name": "NewLine",
        "methods": [
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 286,
        "docstring": "A renderable to generate new line(s)"
      },
      {
        "name": "ScreenUpdate",
        "methods": [
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 298,
        "docstring": "Render a list of lines at a given offset."
      },
      {
        "name": "Capture",
        "methods": [
          "__init__",
          "__enter__",
          "__exit__",
          "get"
        ],
        "base_classes": [],
        "lineno": 316,
        "docstring": "Context manager to capture the result of printing to the console.\nSee :meth:`~rich.console.Console.capture` for how to use.\n\nArgs:\n    console (Console): A console instance to capture output."
      },
      {
        "name": "ThemeContext",
        "methods": [
          "__init__",
          "__enter__",
          "__exit__"
        ],
        "base_classes": [],
        "lineno": 349,
        "docstring": "A context manager to use a temporary theme. See :meth:`~rich.console.Console.use_theme` for usage."
      },
      {
        "name": "PagerContext",
        "methods": [
          "__init__",
          "__enter__",
          "__exit__"
        ],
        "base_classes": [],
        "lineno": 370,
        "docstring": "A context manager that 'pages' content. See :meth:`~rich.console.Console.pager` for usage."
      },
      {
        "name": "ScreenContext",
        "methods": [
          "__init__",
          "update",
          "__enter__",
          "__exit__"
        ],
        "base_classes": [],
        "lineno": 409,
        "docstring": "A context manager that enables an alternative screen. See :meth:`~rich.console.Console.screen` for usage."
      },
      {
        "name": "Group",
        "methods": [
          "__init__",
          "renderables",
          "__rich_measure__",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 456,
        "docstring": "Takes a group of renderables and returns a renderable object that renders the group.\n\nArgs:\n    renderables (Iterable[RenderableType]): An iterable of renderable objects.\n    fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True."
      },
      {
        "name": "ConsoleThreadLocals",
        "methods": [],
        "base_classes": [
          "threading.local"
        ],
        "lineno": 542,
        "docstring": "Thread local values for Console context."
      },
      {
        "name": "RenderHook",
        "methods": [
          "process_renderables"
        ],
        "base_classes": [
          "ABC"
        ],
        "lineno": 550,
        "docstring": "Provides hooks in to the render process."
      },
      {
        "name": "Console",
        "methods": [
          "__init__",
          "__repr__",
          "file",
          "file",
          "_buffer",
          "_buffer_index",
          "_buffer_index",
          "_theme_stack",
          "_detect_color_system",
          "_enter_buffer",
          "_exit_buffer",
          "set_live",
          "clear_live",
          "push_render_hook",
          "pop_render_hook",
          "__enter__",
          "__exit__",
          "begin_capture",
          "end_capture",
          "push_theme",
          "pop_theme",
          "use_theme",
          "color_system",
          "encoding",
          "is_terminal",
          "is_dumb_terminal",
          "options",
          "size",
          "size",
          "width",
          "width",
          "height",
          "height",
          "bell",
          "capture",
          "pager",
          "line",
          "clear",
          "status",
          "show_cursor",
          "set_alt_screen",
          "is_alt_screen",
          "set_window_title",
          "screen",
          "measure",
          "render",
          "render_lines",
          "render_str",
          "get_style",
          "_collect_renderables",
          "rule",
          "control",
          "out",
          "print",
          "print_json",
          "update_screen",
          "update_screen_lines",
          "print_exception",
          "_caller_frame_info",
          "log",
          "on_broken_pipe",
          "_check_buffer",
          "_write_buffer",
          "_render_buffer",
          "input",
          "export_text",
          "save_text",
          "export_html",
          "save_html",
          "export_svg",
          "save_svg"
        ],
        "base_classes": [],
        "lineno": 587,
        "docstring": "A high level console interface.\n\nArgs:\n    color_system (str, optional): The color system supported by your terminal,\n        either ``\"standard\"``, ``\"256\"`` or ``\"truecolor\"``. Leave as ``\"auto\"`` to autodetect.\n    force_terminal (Optional[bool], optional): Enable/disable terminal control codes, or None to auto-detect terminal. Defaults to None.\n    force_jupyter (Optional[bool], optional): Enable/disable Jupyter rendering, or None to auto-detect Jupyter. Defaults to None.\n    force_interactive (Optional[bool], optional): Enable/disable interactive mode, or None to auto detect. Defaults to None.\n    soft_wrap (Optional[bool], optional): Set soft wrap default on print method. Defaults to False.\n    theme (Theme, optional): An optional style theme object, or ``None`` for default theme.\n    stderr (bool, optional): Use stderr rather than stdout if ``file`` is not specified. Defaults to False.\n    file (IO, optional): A file object where the console should write to. Defaults to stdout.\n    quiet (bool, Optional): Boolean to suppress all output. Defaults to False.\n    width (int, optional): The width of the terminal. Leave as default to auto-detect width.\n    height (int, optional): The height of the terminal. Leave as default to auto-detect height.\n    style (StyleType, optional): Style to apply to all output, or None for no style. Defaults to None.\n    no_color (Optional[bool], optional): Enabled no color mode, or None to auto detect. Defaults to None.\n    tab_size (int, optional): Number of spaces used to replace a tab character. Defaults to 8.\n    record (bool, optional): Boolean to enable recording of terminal output,\n        required to call :meth:`export_html`, :meth:`export_svg`, and :meth:`export_text`. Defaults to False.\n    markup (bool, optional): Boolean to enable :ref:`console_markup`. Defaults to True.\n    emoji (bool, optional): Enable emoji code. Defaults to True.\n    emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults to None.\n    highlight (bool, optional): Enable automatic highlighting. Defaults to True.\n    log_time (bool, optional): Boolean to enable logging of time by :meth:`log` methods. Defaults to True.\n    log_path (bool, optional): Boolean to enable the logging of the caller by :meth:`log`. Defaults to True.\n    log_time_format (Union[str, TimeFormatterCallable], optional): If ``log_time`` is enabled, either string for strftime or callable that formats the time. Defaults to \"[%X] \".\n    highlighter (HighlighterType, optional): Default highlighter.\n    legacy_windows (bool, optional): Enable legacy Windows mode, or ``None`` to auto detect. Defaults to ``None``.\n    safe_box (bool, optional): Restrict box options that don't render on legacy Windows.\n    get_datetime (Callable[[], datetime], optional): Callable that gets the current time as a datetime.datetime object (used by Console.log),\n        or None for datetime.now.\n    get_time (Callable[[], time], optional): Callable that gets the current time in seconds, default uses time.monotonic."
      }
    ],
    "imports": [
      {
        "module": "inspect",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "threading",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "zlib",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "abc",
        "name": "ABC",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "abc",
        "name": "abstractmethod",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "dataclass",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "field",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "datetime",
        "name": "datetime",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "functools",
        "name": "wraps",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "getpass",
        "name": "getpass",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "html",
        "name": "escape",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "name": "isclass",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "itertools",
        "name": "islice",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "math",
        "name": "ceil",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "time",
        "name": "monotonic",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "FrameType",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "ModuleType",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "IO",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Literal",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Mapping",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Protocol",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TextIO",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "cast",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "runtime_checkable",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "rich._null_file",
        "name": "NULL_FILE",
        "alias": null,
        "lineno": 38,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "errors",
        "alias": null,
        "lineno": 40,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "themes",
        "alias": null,
        "lineno": 40,
        "type": "from_import"
      },
      {
        "module": "_emoji_replace",
        "name": "_emoji_replace",
        "alias": null,
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "_export_format",
        "name": "CONSOLE_HTML_FORMAT",
        "alias": null,
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "_export_format",
        "name": "CONSOLE_SVG_FORMAT",
        "alias": null,
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "_fileno",
        "name": "get_fileno",
        "alias": null,
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "_log_render",
        "name": "FormatTimeCallable",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "_log_render",
        "name": "LogRender",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "Align",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "AlignMethod",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "ColorSystem",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "blend_rgb",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "control",
        "name": "Control",
        "alias": null,
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "emoji",
        "name": "EmojiVariant",
        "alias": null,
        "lineno": 48,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "NullHighlighter",
        "alias": null,
        "lineno": 49,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 49,
        "type": "from_import"
      },
      {
        "module": "markup",
        "name": "render",
        "alias": "render_markup",
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 51,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "measure_renderables",
        "alias": null,
        "lineno": 51,
        "type": "from_import"
      },
      {
        "module": "pager",
        "name": "Pager",
        "alias": null,
        "lineno": 52,
        "type": "from_import"
      },
      {
        "module": "pager",
        "name": "SystemPager",
        "alias": null,
        "lineno": 52,
        "type": "from_import"
      },
      {
        "module": "pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 53,
        "type": "from_import"
      },
      {
        "module": "pretty",
        "name": "is_expandable",
        "alias": null,
        "lineno": 53,
        "type": "from_import"
      },
      {
        "module": "protocol",
        "name": "rich_cast",
        "alias": null,
        "lineno": 54,
        "type": "from_import"
      },
      {
        "module": "region",
        "name": "Region",
        "alias": null,
        "lineno": 55,
        "type": "from_import"
      },
      {
        "module": "scope",
        "name": "render_scope",
        "alias": null,
        "lineno": 56,
        "type": "from_import"
      },
      {
        "module": "screen",
        "name": "Screen",
        "alias": null,
        "lineno": 57,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 58,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 59,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 59,
        "type": "from_import"
      },
      {
        "module": "styled",
        "name": "Styled",
        "alias": null,
        "lineno": 60,
        "type": "from_import"
      },
      {
        "module": "terminal_theme",
        "name": "DEFAULT_TERMINAL_THEME",
        "alias": null,
        "lineno": 61,
        "type": "from_import"
      },
      {
        "module": "terminal_theme",
        "name": "SVG_EXPORT_THEME",
        "alias": null,
        "lineno": 61,
        "type": "from_import"
      },
      {
        "module": "terminal_theme",
        "name": "TerminalTheme",
        "alias": null,
        "lineno": 61,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 62,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 62,
        "type": "from_import"
      },
      {
        "module": "theme",
        "name": "Theme",
        "alias": null,
        "lineno": 63,
        "type": "from_import"
      },
      {
        "module": "theme",
        "name": "ThemeStack",
        "alias": null,
        "lineno": 63,
        "type": "from_import"
      },
      {
        "module": "_windows",
        "name": "WindowsConsoleFeatures",
        "alias": null,
        "lineno": 66,
        "type": "from_import"
      },
      {
        "module": "live",
        "name": "Live",
        "alias": null,
        "lineno": 67,
        "type": "from_import"
      },
      {
        "module": "status",
        "name": "Status",
        "alias": null,
        "lineno": 68,
        "type": "from_import"
      },
      {
        "module": "_windows",
        "name": "get_windows_console_features",
        "alias": null,
        "lineno": 576,
        "type": "from_import"
      },
      {
        "module": "status",
        "name": "Status",
        "alias": null,
        "lineno": 1184,
        "type": "from_import"
      },
      {
        "module": "rule",
        "name": "Rule",
        "alias": null,
        "lineno": 1601,
        "type": "from_import"
      },
      {
        "module": "rich.json",
        "name": "JSON",
        "alias": null,
        "lineno": 1776,
        "type": "from_import"
      },
      {
        "module": "traceback",
        "name": "Traceback",
        "alias": null,
        "lineno": 1884,
        "type": "from_import"
      },
      {
        "module": "rich.cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 2352,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "display",
        "alias": null,
        "lineno": 2052,
        "type": "from_import"
      },
      {
        "module": "rich._win32_console",
        "name": "LegacyWindowsTerm",
        "alias": null,
        "lineno": 2067,
        "type": "from_import"
      },
      {
        "module": "rich._windows_renderer",
        "name": "legacy_windows_render",
        "alias": null,
        "lineno": 2068,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "JUPYTER_DEFAULT_COLUMNS",
        "assigned_to": "int",
        "lineno": 70
      },
      {
        "name": "JUPYTER_DEFAULT_LINES",
        "assigned_to": "int",
        "lineno": 71
      },
      {
        "name": "WINDOWS",
        "assigned_to": null,
        "lineno": 72
      },
      {
        "name": "HighlighterType",
        "assigned_to": null,
        "lineno": 74
      },
      {
        "name": "JustifyMethod",
        "assigned_to": null,
        "lineno": 75
      },
      {
        "name": "OverflowMethod",
        "assigned_to": null,
        "lineno": 76
      },
      {
        "name": "NO_CHANGE",
        "assigned_to": "NoChange",
        "lineno": 83
      },
      {
        "name": "_STD_STREAMS",
        "assigned_to": null,
        "lineno": 98
      },
      {
        "name": "_STD_STREAMS_OUTPUT",
        "assigned_to": null,
        "lineno": 99
      },
      {
        "name": "_TERM_COLORS",
        "assigned_to": null,
        "lineno": 102
      },
      {
        "name": "RenderableType",
        "assigned_to": null,
        "lineno": 273
      },
      {
        "name": "RenderResult",
        "assigned_to": null,
        "lineno": 277
      },
      {
        "name": "_null_highlighter",
        "assigned_to": "NullHighlighter",
        "lineno": 279
      },
      {
        "name": "COLOR_SYSTEMS",
        "assigned_to": null,
        "lineno": 531
      },
      {
        "name": "_COLOR_SYSTEMS_NAMES",
        "assigned_to": null,
        "lineno": 538
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Console",
      "repr",
      "console.log"
    ],
    "module_level_calls": {
      "function_calls": [
        "sys.__stdin__.fileno",
        "console.print",
        "sys.__stdout__.fileno",
        "console.log",
        "NullHighlighter",
        "Console",
        "COLOR_SYSTEMS.items",
        "NoChange",
        "console",
        "repr",
        "sys.__stderr__.fileno"
      ],
      "class_instantiations": [
        "COLOR_SYSTEMS",
        "Console",
        "NullHighlighter",
        "NoChange"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "abc",
        "threading",
        "datetime",
        "typing",
        "functools",
        "dataclasses",
        "math",
        "os",
        "itertools",
        "sys",
        "time"
      ],
      "third_party": {
        "other": [
          "inspect",
          "zlib",
          "getpass",
          "html",
          "types",
          "rich",
          "errors",
          "themes",
          "_emoji_replace",
          "_export_format",
          "_fileno",
          "_log_render",
          "align",
          "color",
          "control",
          "emoji",
          "highlighter",
          "markup",
          "measure",
          "pager",
          "pretty",
          "protocol",
          "region",
          "scope",
          "screen",
          "segment",
          "style",
          "styled",
          "terminal_theme",
          "text",
          "theme",
          "_windows",
          "live",
          "status",
          "rule",
          "traceback",
          "jupyter"
        ]
      },
      "tech_stack": []
    },
    "line_count": 2681
  },
  "rich/constrain.py": {
    "filepath": "../rich/rich/constrain.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "width",
            "type": "Optional[int]"
          }
        ],
        "return_type": "None",
        "lineno": 18,
        "decorators": [],
        "is_async": false,
        "calls": [
          "renderable",
          "width"
        ],
        "docstring": null,
        "code": "def __init__(self, renderable: \"RenderableType\", width: Optional[int] = 80) -> None:\n        self.renderable = renderable\n        self.width = width",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 22,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "options.max_width",
          "child_options",
          "self.renderable",
          "console.render",
          "self.width",
          "options.update_width"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.width is None:\n            yield self.renderable\n        else:\n            child_options = options.update_width(min(self.width, options.max_width))\n            yield from console.render(self.renderable, child_options)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 31,
        "decorators": [],
        "is_async": false,
        "calls": [
          "options",
          "Measurement.get",
          "self.renderable",
          "self.width",
          "options.update_width",
          "console"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        if self.width is not None:\n            options = options.update_width(self.width)\n        measurement = Measurement.get(console, options, self.renderable)\n        return measurement",
        "line_count": 7,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Constrain",
        "methods": [
          "__init__",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 10,
        "docstring": "Constrain the width of a renderable to a given number of characters.\n\nArgs:\n    renderable (RenderableType): A renderable object.\n    width (int, optional): The maximum width (in characters) to render. Defaults to 80."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "jupyter",
          "measure",
          "console"
        ]
      },
      "tech_stack": []
    },
    "line_count": 38
  },
  "rich/containers.py": {
    "filepath": "../rich/rich/containers.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderables",
            "type": "Optional[Iterable[RenderableType]]"
          }
        ],
        "return_type": "None",
        "lineno": 33,
        "decorators": [],
        "is_async": false,
        "calls": [
          "list",
          "renderables"
        ],
        "docstring": null,
        "code": "def __init__(\n        self, renderables: Optional[Iterable[\"RenderableType\"]] = None\n    ) -> None:\n        self._renderables: List[\"RenderableType\"] = (\n            list(renderables) if renderables is not None else []\n        )",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Console render method to insert line-breaks.",
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        \"\"\"Console render method to insert line-breaks.\"\"\"\n        yield from self._renderables",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 46,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_max",
          "options",
          "Measurement.get",
          "renderable",
          "Measurement",
          "max",
          "_min",
          "console"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        dimensions = [\n            Measurement.get(console, options, renderable)\n            for renderable in self._renderables\n        ]\n        if not dimensions:\n            return Measurement(1, 1)\n        _min = max(dimension.minimum for dimension in dimensions)\n        _max = max(dimension.maximum for dimension in dimensions)\n        return Measurement(_min, _max)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "append",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 59,
        "decorators": [],
        "is_async": false,
        "calls": [
          "renderable",
          "self._renderables.append"
        ],
        "docstring": null,
        "code": "def append(self, renderable: \"RenderableType\") -> None:\n        self._renderables.append(renderable)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__iter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Iterable[RenderableType]",
        "lineno": 62,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._renderables",
          "iter"
        ],
        "docstring": null,
        "code": "def __iter__(self) -> Iterable[\"RenderableType\"]:\n        return iter(self._renderables)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lines",
            "type": "Iterable[Text]"
          }
        ],
        "return_type": "None",
        "lineno": 69,
        "decorators": [],
        "is_async": false,
        "calls": [
          "list",
          "lines"
        ],
        "docstring": null,
        "code": "def __init__(self, lines: Iterable[\"Text\"] = ()) -> None:\n        self._lines: List[\"Text\"] = list(lines)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 72,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"Lines({self._lines!r})\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__iter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Iterator[Text]",
        "lineno": 75,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._lines",
          "iter"
        ],
        "docstring": null,
        "code": "def __iter__(self) -> Iterator[\"Text\"]:\n        return iter(self._lines)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__getitem__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "index",
            "type": "int"
          }
        ],
        "return_type": "Text",
        "lineno": 79,
        "decorators": [
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __getitem__(self, index: int) -> \"Text\":\n        ...",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__getitem__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "index",
            "type": "slice"
          }
        ],
        "return_type": "List[Text]",
        "lineno": 83,
        "decorators": [
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __getitem__(self, index: slice) -> List[\"Text\"]:\n        ...",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__getitem__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "index",
            "type": "Union[slice, int]"
          }
        ],
        "return_type": "Union[Text, List[Text]]",
        "lineno": 86,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __getitem__(self, index: Union[slice, int]) -> Union[\"Text\", List[\"Text\"]]:\n        return self._lines[index]",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__setitem__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "index",
            "type": "int"
          },
          {
            "name": "value",
            "type": "Text"
          }
        ],
        "return_type": "Lines",
        "lineno": 89,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value"
        ],
        "docstring": null,
        "code": "def __setitem__(self, index: int, value: \"Text\") -> \"Lines\":\n        self._lines[index] = value\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__len__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 93,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._lines.__len__"
        ],
        "docstring": null,
        "code": "def __len__(self) -> int:\n        return self._lines.__len__()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 96,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Console render method to insert line-breaks.",
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        \"\"\"Console render method to insert line-breaks.\"\"\"\n        yield from self._lines",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "append",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "line",
            "type": "Text"
          }
        ],
        "return_type": "None",
        "lineno": 102,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line",
          "self._lines.append"
        ],
        "docstring": null,
        "code": "def append(self, line: \"Text\") -> None:\n        self._lines.append(line)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "extend",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lines",
            "type": "Iterable[Text]"
          }
        ],
        "return_type": "None",
        "lineno": 105,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "self._lines.extend"
        ],
        "docstring": null,
        "code": "def extend(self, lines: Iterable[\"Text\"]) -> None:\n        self._lines.extend(lines)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "pop",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "index",
            "type": "int"
          }
        ],
        "return_type": "Text",
        "lineno": 108,
        "decorators": [],
        "is_async": false,
        "calls": [
          "index",
          "self._lines.pop"
        ],
        "docstring": null,
        "code": "def pop(self, index: int = -1) -> \"Text\":\n        return self._lines.pop(index)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "justify",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "justify",
            "type": "JustifyMethod"
          },
          {
            "name": "overflow",
            "type": "OverflowMethod"
          }
        ],
        "return_type": "None",
        "lineno": 111,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "sum",
          "num_spaces",
          "word.get_style_at_offset",
          "word",
          "space_style",
          "line.pad_right",
          "self._lines",
          "line.truncate",
          "line.split",
          "line.pad_left",
          "line.plain",
          "unknown.join",
          "words",
          "cell_len",
          "Text",
          "word.plain",
          "width",
          "next_word.get_style_at_offset",
          "console",
          "tokens",
          "len",
          "line.rstrip",
          "range",
          "overflow",
          "tokens.append",
          "zip_longest",
          "spaces"
        ],
        "docstring": "Justify and overflow text to a given width.\n\nArgs:\n    console (Console): Console instance.\n    width (int): Number of cells available per line.\n    justify (str, optional): Default justify method for text: \"left\", \"center\", \"full\" or \"right\". Defaults to \"left\".\n    overflow (str, optional): Default overflow for text: \"crop\", \"fold\", or \"ellipsis\". Defaults to \"fold\".",
        "code": "def justify(\n        self,\n        console: \"Console\",\n        width: int,\n        justify: \"JustifyMethod\" = \"left\",\n        overflow: \"OverflowMethod\" = \"fold\",\n    ) -> None:\n        \"\"\"Justify and overflow text to a given width.\n\n        Args:\n            console (Console): Console instance.\n            width (int): Number of cells available per line.\n            justify (str, optional): Default justify method for text: \"left\", \"center\", \"full\" or \"right\". Defaults to \"left\".\n            overflow (str, optional): Default overflow for text: \"crop\", \"fold\", or \"ellipsis\". Defaults to \"fold\".\n\n        \"\"\"\n        from .text import Text\n\n        if justify == \"left\":\n            for line in self._lines:\n                line.truncate(width, overflow=overflow, pad=True)\n        elif justify == \"center\":\n            for line in self._lines:\n                line.rstrip()\n                line.truncate(width, overflow=overflow)\n                line.pad_left((width - cell_len(line.plain)) // 2)\n                line.pad_right(width - cell_len(line.plain))\n        elif justify == \"right\":\n            for line in self._lines:\n                line.rstrip()\n                line.truncate(width, overflow=overflow)\n                line.pad_left(width - cell_len(line.plain))\n        elif justify == \"full\":\n            for line_index, line in enumerate(self._lines):\n                if line_index == len(self._lines) - 1:\n                    break\n                words = line.split(\" \")\n                words_size = sum(cell_len(word.plain) for word in words)\n                num_spaces = len(words) - 1\n                spaces = [1 for _ in range(num_spaces)]\n                index = 0\n                if spaces:\n                    while words_size + num_spaces < width:\n                        spaces[len(spaces) - index - 1] += 1\n                        num_spaces += 1\n                        index = (index + 1) % len(spaces)\n                tokens: List[Text] = []\n                for index, (word, next_word) in enumerate(\n                    zip_longest(words, words[1:])\n                ):\n                    tokens.append(word)\n                    if index < len(spaces):\n                        style = word.get_style_at_offset(console, -1)\n                        next_style = next_word.get_style_at_offset(console, 0)\n                        space_style = style if style == next_style else line.style\n                        tokens.append(Text(\" \" * spaces[index], style=space_style))\n                self[line_index] = Text(\"\").join(tokens)",
        "line_count": 57,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Renderables",
        "methods": [
          "__init__",
          "__rich_console__",
          "__rich_measure__",
          "append",
          "__iter__"
        ],
        "base_classes": [],
        "lineno": 30,
        "docstring": "A list subclass which renders its contents to the console."
      },
      {
        "name": "Lines",
        "methods": [
          "__init__",
          "__repr__",
          "__iter__",
          "__getitem__",
          "__getitem__",
          "__getitem__",
          "__setitem__",
          "__len__",
          "__rich_console__",
          "append",
          "extend",
          "pop",
          "justify"
        ],
        "base_classes": [],
        "lineno": 66,
        "docstring": "A list subclass which can render to the console."
      }
    ],
    "imports": [
      {
        "module": "itertools",
        "name": "zip_longest",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterator",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TypeVar",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "overload",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "JustifyMethod",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "OverflowMethod",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 127,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "T",
        "assigned_to": "TypeVar",
        "lineno": 27
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "TypeVar"
      ],
      "class_instantiations": [
        "TypeVar"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "itertools",
        "typing"
      ],
      "third_party": {
        "other": [
          "cells",
          "measure",
          "console",
          "text"
        ]
      },
      "tech_stack": []
    },
    "line_count": 168
  },
  "rich/control.py": {
    "filepath": "../rich/rich/control.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "strip_control_codes",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "_translate_table",
            "type": "Dict[int, None]"
          }
        ],
        "return_type": "str",
        "lineno": 181,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text.translate",
          "_translate_table"
        ],
        "docstring": "Remove control codes from text.\n\nArgs:\n    text (str): A string possibly contain control codes.\n\nReturns:\n    str: String with control codes removed.",
        "code": "def strip_control_codes(\n    text: str, _translate_table: Dict[int, None] = _CONTROL_STRIP_TRANSLATE\n) -> str:\n    \"\"\"Remove control codes from text.\n\n    Args:\n        text (str): A string possibly contain control codes.\n\n    Returns:\n        str: String with control codes removed.\n    \"\"\"\n    return text.translate(_translate_table)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "escape_control_codes",
        "args": [
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "_translate_table",
            "type": "Dict[int, str]"
          }
        ],
        "return_type": "str",
        "lineno": 195,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text.translate",
          "_translate_table"
        ],
        "docstring": "Replace control codes with their \"escaped\" equivalent in the given text.\n(e.g. \"\b\" becomes \"\\b\")\n\nArgs:\n    text (str): A string possibly containing control codes.\n\nReturns:\n    str: String with control codes replaced with their escaped version.",
        "code": "def escape_control_codes(\n    text: str,\n    _translate_table: Dict[int, str] = CONTROL_ESCAPE,\n) -> str:\n    \"\"\"Replace control codes with their \"escaped\" equivalent in the given text.\n    (e.g. \"\\b\" becomes \"\\\\b\")\n\n    Args:\n        text (str): A string possibly containing control codes.\n\n    Returns:\n        str: String with control codes replaced with their escaped version.\n    \"\"\"\n    return text.translate(_translate_table)",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 58,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "rendered_codes",
          "control_codes",
          "CONTROL_CODES_FORMAT",
          "unknown.join",
          "ControlType",
          "code",
          "Segment"
        ],
        "docstring": null,
        "code": "def __init__(self, *codes: Union[ControlType, ControlCode]) -> None:\n        control_codes: List[ControlCode] = [\n            (code,) if isinstance(code, ControlType) else code for code in codes\n        ]\n        _format_map = CONTROL_CODES_FORMAT\n        rendered_codes = \"\".join(\n            _format_map[code](*parameters) for code, *parameters in control_codes\n        )\n        self.segment = Segment(rendered_codes, None, control_codes)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "bell",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Control",
        "lineno": 69,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ControlType.BELL",
          "cls"
        ],
        "docstring": "Ring the 'bell'.",
        "code": "def bell(cls) -> \"Control\":\n        \"\"\"Ring the 'bell'.\"\"\"\n        return cls(ControlType.BELL)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "home",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Control",
        "lineno": 74,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ControlType.HOME",
          "cls"
        ],
        "docstring": "Move cursor to 'home' position.",
        "code": "def home(cls) -> \"Control\":\n        \"\"\"Move cursor to 'home' position.\"\"\"\n        return cls(ControlType.HOME)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "move",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "x",
            "type": "int"
          },
          {
            "name": "y",
            "type": "int"
          }
        ],
        "return_type": "Control",
        "lineno": 79,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "abs",
          "ControlType",
          "y",
          "cls",
          "get_codes",
          "x"
        ],
        "docstring": "Move cursor relative to current position.\n\nArgs:\n    x (int): X offset.\n    y (int): Y offset.\n\nReturns:\n    ~Control: Control object.",
        "code": "def move(cls, x: int = 0, y: int = 0) -> \"Control\":\n        \"\"\"Move cursor relative to current position.\n\n        Args:\n            x (int): X offset.\n            y (int): Y offset.\n\n        Returns:\n            ~Control: Control object.\n\n        \"\"\"\n\n        def get_codes() -> Iterable[ControlCode]:\n            control = ControlType\n            if x:\n                yield (\n                    control.CURSOR_FORWARD if x > 0 else control.CURSOR_BACKWARD,\n                    abs(x),\n                )\n            if y:\n                yield (\n                    control.CURSOR_DOWN if y > 0 else control.CURSOR_UP,\n                    abs(y),\n                )\n\n        control = cls(*get_codes())\n        return control",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "move_to_column",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "x",
            "type": "int"
          },
          {
            "name": "y",
            "type": "int"
          }
        ],
        "return_type": "Control",
        "lineno": 108,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "abs",
          "y",
          "cls"
        ],
        "docstring": "Move to the given column, optionally add offset to row.\n\nReturns:\n    x (int): absolute x (column)\n    y (int): optional y offset (row)\n\nReturns:\n    ~Control: Control object.",
        "code": "def move_to_column(cls, x: int, y: int = 0) -> \"Control\":\n        \"\"\"Move to the given column, optionally add offset to row.\n\n        Returns:\n            x (int): absolute x (column)\n            y (int): optional y offset (row)\n\n        Returns:\n            ~Control: Control object.\n        \"\"\"\n\n        return (\n            cls(\n                (ControlType.CURSOR_MOVE_TO_COLUMN, x),\n                (\n                    ControlType.CURSOR_DOWN if y > 0 else ControlType.CURSOR_UP,\n                    abs(y),\n                ),\n            )\n            if y\n            else cls((ControlType.CURSOR_MOVE_TO_COLUMN, x))\n        )",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "move_to",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "x",
            "type": "int"
          },
          {
            "name": "y",
            "type": "int"
          }
        ],
        "return_type": "Control",
        "lineno": 132,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cls"
        ],
        "docstring": "Move cursor to absolute position.\n\nArgs:\n    x (int): x offset (column)\n    y (int): y offset (row)\n\nReturns:\n    ~Control: Control object.",
        "code": "def move_to(cls, x: int, y: int) -> \"Control\":\n        \"\"\"Move cursor to absolute position.\n\n        Args:\n            x (int): x offset (column)\n            y (int): y offset (row)\n\n        Returns:\n            ~Control: Control object.\n        \"\"\"\n        return cls((ControlType.CURSOR_MOVE_TO, x, y))",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "clear",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Control",
        "lineno": 145,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cls",
          "ControlType.CLEAR"
        ],
        "docstring": "Clear the screen.",
        "code": "def clear(cls) -> \"Control\":\n        \"\"\"Clear the screen.\"\"\"\n        return cls(ControlType.CLEAR)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "show_cursor",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "show",
            "type": "bool"
          }
        ],
        "return_type": "Control",
        "lineno": 150,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cls"
        ],
        "docstring": "Show or hide the cursor.",
        "code": "def show_cursor(cls, show: bool) -> \"Control\":\n        \"\"\"Show or hide the cursor.\"\"\"\n        return cls(ControlType.SHOW_CURSOR if show else ControlType.HIDE_CURSOR)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "alt_screen",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "enable",
            "type": "bool"
          }
        ],
        "return_type": "Control",
        "lineno": 155,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ControlType.ENABLE_ALT_SCREEN",
          "ControlType.HOME",
          "cls",
          "ControlType.DISABLE_ALT_SCREEN"
        ],
        "docstring": "Enable or disable alt screen.",
        "code": "def alt_screen(cls, enable: bool) -> \"Control\":\n        \"\"\"Enable or disable alt screen.\"\"\"\n        if enable:\n            return cls(ControlType.ENABLE_ALT_SCREEN, ControlType.HOME)\n        else:\n            return cls(ControlType.DISABLE_ALT_SCREEN)",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "title",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "title",
            "type": "str"
          }
        ],
        "return_type": "Control",
        "lineno": 163,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cls"
        ],
        "docstring": "Set the terminal window title\n\nArgs:\n    title (str): The new terminal window title",
        "code": "def title(cls, title: str) -> \"Control\":\n        \"\"\"Set the terminal window title\n\n        Args:\n            title (str): The new terminal window title\n        \"\"\"\n        return cls((ControlType.SET_WINDOW_TITLE, title))",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 171,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        return self.segment.text",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 174,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.segment.text:\n            yield self.segment",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_codes",
        "args": [],
        "return_type": "Iterable[ControlCode]",
        "lineno": 91,
        "decorators": [],
        "is_async": false,
        "calls": [
          "abs",
          "ControlType",
          "x",
          "y"
        ],
        "docstring": null,
        "code": "def get_codes() -> Iterable[ControlCode]:\n            control = ControlType\n            if x:\n                yield (\n                    control.CURSOR_FORWARD if x > 0 else control.CURSOR_BACKWARD,\n                    abs(x),\n                )\n            if y:\n                yield (\n                    control.CURSOR_DOWN if y > 0 else control.CURSOR_UP,\n                    abs(y),\n                )",
        "line_count": 12,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Control",
        "methods": [
          "__init__",
          "bell",
          "home",
          "move",
          "move_to_column",
          "move_to",
          "clear",
          "show_cursor",
          "alt_screen",
          "title",
          "__str__",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 48,
        "docstring": "A renderable that inserts a control code (non printable but may move cursor).\n\nArgs:\n    *codes (str): Positional arguments are either a :class:`~rich.segment.ControlType` enum or a\n        tuple of ControlType and an integer parameter"
      }
    ],
    "imports": [
      {
        "module": "time",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Final",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "ControlCode",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "ControlType",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 212,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "range",
      "time.sleep",
      "Console",
      "console.set_window_title"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "range",
        "time.sleep",
        "Console",
        "console.set_window_title"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time",
        "typing"
      ],
      "third_party": {
        "other": [
          "segment",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 220
  },
  "rich/default_styles.py": {
    "filepath": "../rich/rich/default_styles.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "argparse",
        "alias": null,
        "lineno": 173,
        "type": "import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 174,
        "type": "import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 176,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 177,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 178,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "console.export_html",
      "argparse.ArgumentParser",
      "str",
      "Console",
      "DEFAULT_STYLES.items",
      "io.StringIO",
      "parser.parse_args",
      "Text",
      "print",
      "table.add_row",
      "parser.add_argument",
      "Table"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.export_html",
        "argparse.ArgumentParser",
        "str",
        "style",
        "table",
        "Console",
        "style_name",
        "DEFAULT_STYLES.items",
        "io.StringIO",
        "parser.parse_args",
        "Style.null",
        "Text",
        "print",
        "Style",
        "table.add_row",
        "parser.add_argument",
        "Table"
      ],
      "class_instantiations": [
        "DEFAULT_STYLES",
        "Table",
        "Console",
        "Style",
        "Text"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "io",
        "argparse",
        "typing"
      ],
      "third_party": {
        "other": [
          "style",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 194
  },
  "rich/diagnose.py": {
    "filepath": "../rich/rich/diagnose.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "report",
        "args": [],
        "return_type": "None",
        "lineno": 10,
        "decorators": [],
        "is_async": false,
        "calls": [
          "console.print",
          "name",
          "Pretty",
          "env",
          "Console",
          "features",
          "inspect",
          "platform.system",
          "get_windows_console_features",
          "console",
          "Panel.fit",
          "os.getenv"
        ],
        "docstring": "Print a report to the terminal with debugging information",
        "code": "def report() -> None:  # pragma: no cover\n    \"\"\"Print a report to the terminal with debugging information\"\"\"\n    console = Console()\n    inspect(console)\n    features = get_windows_console_features()\n    inspect(features)\n\n    env_names = (\n        \"CLICOLOR\",\n        \"COLORTERM\",\n        \"COLUMNS\",\n        \"JPY_PARENT_PID\",\n        \"JUPYTER_COLUMNS\",\n        \"JUPYTER_LINES\",\n        \"LINES\",\n        \"NO_COLOR\",\n        \"TERM_PROGRAM\",\n        \"TERM\",\n        \"TTY_COMPATIBLE\",\n        \"TTY_INTERACTIVE\",\n        \"VSCODE_VERBOSE_LOGGING\",\n    )\n    env = {name: os.getenv(name) for name in env_names}\n    console.print(Panel.fit((Pretty(env)), title=\"[b]Environment Variables\"))\n\n    console.print(f'platform=\"{platform.system()}\"')",
        "line_count": 26,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "os",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "platform",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "rich",
        "name": "inspect",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "get_windows_console_features",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich.pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "report"
    ],
    "module_level_calls": {
      "function_calls": [
        "report"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "os"
      ],
      "third_party": {
        "other": [
          "platform",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 40
  },
  "rich/emoji.py": {
    "filepath": "../rich/rich/emoji.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "style",
            "type": "Union[str, Style]"
          },
          {
            "name": "variant",
            "type": "Optional[EmojiVariant]"
          }
        ],
        "return_type": "None",
        "lineno": 27,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "style",
          "self.VARIANTS.get",
          "NoEmoji",
          "variant"
        ],
        "docstring": "A single emoji character.\n\nArgs:\n    name (str): Name of emoji.\n    style (Union[str, Style], optional): Optional style. Defaults to None.\n\nRaises:\n    NoEmoji: If the emoji doesn't exist.",
        "code": "def __init__(\n        self,\n        name: str,\n        style: Union[str, Style] = \"none\",\n        variant: Optional[EmojiVariant] = None,\n    ) -> None:\n        \"\"\"A single emoji character.\n\n        Args:\n            name (str): Name of emoji.\n            style (Union[str, Style], optional): Optional style. Defaults to None.\n\n        Raises:\n            NoEmoji: If the emoji doesn't exist.\n        \"\"\"\n        self.name = name\n        self.style = style\n        self.variant = variant\n        try:\n            self._char = EMOJI[name]\n        except KeyError:\n            raise NoEmoji(f\"No emoji called {name!r}\")\n        if variant is not None:\n            self._char += self.VARIANTS.get(variant, \"\")",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "replace",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 53,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "_emoji_replace",
          "text"
        ],
        "docstring": "Replace emoji markup with corresponding unicode characters.\n\nArgs:\n    text (str): A string with emojis codes, e.g. \"Hello :smiley:!\"\n\nReturns:\n    str: A string with emoji codes replaces with actual emoji.",
        "code": "def replace(cls, text: str) -> str:\n        \"\"\"Replace emoji markup with corresponding unicode characters.\n\n        Args:\n            text (str): A string with emojis codes, e.g. \"Hello :smiley:!\"\n\n        Returns:\n            str: A string with emoji codes replaces with actual emoji.\n        \"\"\"\n        return _emoji_replace(text)",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 64,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"<emoji {self.name!r}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 67,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        return self._char",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 70,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "Segment",
          "self._char",
          "console.get_style"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        yield Segment(self._char, console.get_style(self.style))",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "NoEmoji",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 18,
        "docstring": "No emoji by that name."
      },
      {
        "name": "Emoji",
        "methods": [
          "__init__",
          "replace",
          "__repr__",
          "__str__",
          "__rich_console__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 22,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "sys",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Literal",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "_emoji_codes",
        "name": "EMOJI",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "_emoji_replace",
        "name": "_emoji_replace",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 77,
        "type": "import"
      },
      {
        "module": "rich.columns",
        "name": "Columns",
        "alias": null,
        "lineno": 79,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 80,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "EmojiVariant",
        "assigned_to": null,
        "lineno": 15
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Columns",
      "Console",
      "sorted",
      "EMOJI.keys",
      "console.save_html",
      "len"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "Columns",
        "Console",
        "sys.argv",
        "sorted",
        "columns",
        "EMOJI.keys",
        "console.save_html",
        "len"
      ],
      "class_instantiations": [
        "Console",
        "Columns",
        "EMOJI"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "typing"
      ],
      "third_party": {
        "other": [
          "jupyter",
          "segment",
          "style",
          "_emoji_codes",
          "_emoji_replace",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 92
  },
  "rich/errors.py": {
    "filepath": "../rich/rich/errors.py",
    "module_docstring": null,
    "functions": [],
    "classes": [
      {
        "name": "ConsoleError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 1,
        "docstring": "An error in console operation."
      },
      {
        "name": "StyleError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 5,
        "docstring": "An error in styles."
      },
      {
        "name": "StyleSyntaxError",
        "methods": [],
        "base_classes": [
          "ConsoleError"
        ],
        "lineno": 9,
        "docstring": "Style was badly formatted."
      },
      {
        "name": "MissingStyle",
        "methods": [],
        "base_classes": [
          "StyleError"
        ],
        "lineno": 13,
        "docstring": "No such style."
      },
      {
        "name": "StyleStackError",
        "methods": [],
        "base_classes": [
          "ConsoleError"
        ],
        "lineno": 17,
        "docstring": "Style stack is invalid."
      },
      {
        "name": "NotRenderableError",
        "methods": [],
        "base_classes": [
          "ConsoleError"
        ],
        "lineno": 21,
        "docstring": "Object is not renderable."
      },
      {
        "name": "MarkupError",
        "methods": [],
        "base_classes": [
          "ConsoleError"
        ],
        "lineno": 25,
        "docstring": "Markup was badly formatted."
      },
      {
        "name": "LiveError",
        "methods": [],
        "base_classes": [
          "ConsoleError"
        ],
        "lineno": 29,
        "docstring": "Error related to Live display."
      },
      {
        "name": "NoAltScreen",
        "methods": [],
        "base_classes": [
          "ConsoleError"
        ],
        "lineno": 33,
        "docstring": "Alt screen mode was required."
      }
    ],
    "imports": [],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 35
  },
  "rich/file_proxy.py": {
    "filepath": "../rich/rich/file_proxy.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "file",
            "type": "IO[str]"
          }
        ],
        "return_type": "None",
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "AnsiDecoder",
          "file",
          "console"
        ],
        "docstring": null,
        "code": "def __init__(self, console: \"Console\", file: IO[str]) -> None:\n        self.__console = console\n        self.__file = file\n        self.__buffer: List[str] = []\n        self.__ansi_decoder = AnsiDecoder()",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "rich_proxied_file",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "IO[str]",
        "lineno": 21,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get proxied file.",
        "code": "def rich_proxied_file(self) -> IO[str]:\n        \"\"\"Get proxied file.\"\"\"\n        return self.__file",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__getattr__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 25,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "self.__file",
          "getattr"
        ],
        "docstring": null,
        "code": "def __getattr__(self, name: str) -> Any:\n        return getattr(self.__file, name)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "write",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "int",
        "lineno": 28,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines.append",
          "self.__buffer",
          "buffer",
          "type",
          "buffer.append",
          "output",
          "unknown.join",
          "Text",
          "str",
          "line",
          "buffer.clear",
          "text",
          "TypeError",
          "len",
          "isinstance",
          "console.print",
          "text.partition",
          "self.__ansi_decoder.decode_line",
          "self.__console"
        ],
        "docstring": null,
        "code": "def write(self, text: str) -> int:\n        if not isinstance(text, str):\n            raise TypeError(f\"write() argument must be str, not {type(text).__name__}\")\n        buffer = self.__buffer\n        lines: List[str] = []\n        while text:\n            line, new_line, text = text.partition(\"\\n\")\n            if new_line:\n                lines.append(\"\".join(buffer) + line)\n                buffer.clear()\n            else:\n                buffer.append(line)\n                break\n        if lines:\n            console = self.__console\n            with console:\n                output = Text(\"\\n\").join(\n                    self.__ansi_decoder.decode_line(line) for line in lines\n                )\n                console.print(output)\n        return len(text)",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "flush",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 50,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "output",
          "self.__buffer",
          "self.__console.print"
        ],
        "docstring": null,
        "code": "def flush(self) -> None:\n        output = \"\".join(self.__buffer)\n        if output:\n            self.__console.print(output)\n        del self.__buffer[:]",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "fileno",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 56,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.__file.fileno"
        ],
        "docstring": null,
        "code": "def fileno(self) -> int:\n        return self.__file.fileno()",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "FileProxy",
        "methods": [
          "__init__",
          "rich_proxied_file",
          "__getattr__",
          "write",
          "flush",
          "fileno"
        ],
        "base_classes": [
          "io.TextIOBase"
        ],
        "lineno": 11,
        "docstring": "Wraps a file (e.g. sys.stdout) and redirects writes to a console."
      }
    ],
    "imports": [
      {
        "module": "io",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "IO",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "ansi",
        "name": "AnsiDecoder",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "io",
        "typing"
      ],
      "third_party": {
        "other": [
          "ansi",
          "text",
          "console"
        ]
      },
      "tech_stack": []
    },
    "line_count": 58
  },
  "rich/filesize.py": {
    "filepath": "../rich/rich/filesize.py",
    "module_docstring": "Functions for reporting filesizes. Borrowed from https://github.com/PyFilesystem/pyfilesystem2\n\nThe functions declared in this module should cover the different\nuse cases needed to generate a string representation of a file size\nusing several different units. Since there are many standards regarding\nfile size units, three different functions have been implemented.\n\nSee Also:\n    * `Wikipedia: Binary prefix <https://en.wikipedia.org/wiki/Binary_prefix>`_",
    "functions": [
      {
        "name": "_to_str",
        "args": [
          {
            "name": "size",
            "type": "int"
          },
          {
            "name": "suffixes",
            "type": "Iterable[str]"
          },
          {
            "name": "base",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 18,
        "decorators": [],
        "is_async": false,
        "calls": [
          "suffixes",
          "precision",
          "enumerate",
          "unknown.format",
          "suffix",
          "separator"
        ],
        "docstring": null,
        "code": "def _to_str(\n    size: int,\n    suffixes: Iterable[str],\n    base: int,\n    *,\n    precision: Optional[int] = 1,\n    separator: Optional[str] = \" \",\n) -> str:\n    if size == 1:\n        return \"1 byte\"\n    elif size < base:\n        return f\"{size:,} bytes\"\n\n    for i, suffix in enumerate(suffixes, 2):  # noqa: B007\n        unit = base**i\n        if size < unit:\n            break\n    return \"{:,.{precision}f}{separator}{}\".format(\n        (base * size / unit),\n        suffix,\n        precision=precision,\n        separator=separator,\n    )",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "pick_unit_and_suffix",
        "args": [
          {
            "name": "size",
            "type": "int"
          },
          {
            "name": "suffixes",
            "type": "List[str]"
          },
          {
            "name": "base",
            "type": "int"
          }
        ],
        "return_type": "Tuple[int, str]",
        "lineno": 43,
        "decorators": [],
        "is_async": false,
        "calls": [
          "suffixes",
          "enumerate"
        ],
        "docstring": "Pick a suffix and base for the given size.",
        "code": "def pick_unit_and_suffix(size: int, suffixes: List[str], base: int) -> Tuple[int, str]:\n    \"\"\"Pick a suffix and base for the given size.\"\"\"\n    for i, suffix in enumerate(suffixes):\n        unit = base**i\n        if size < unit * base:\n            break\n    return unit, suffix",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "decimal",
        "args": [
          {
            "name": "size",
            "type": "int"
          }
        ],
        "return_type": "str",
        "lineno": 52,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_to_str",
          "precision",
          "size",
          "separator"
        ],
        "docstring": "Convert a filesize in to a string (powers of 1000, SI prefixes).\n\nIn this convention, ``1000 B = 1 kB``.\n\nThis is typically the format used to advertise the storage\ncapacity of USB flash drives and the like (*256 MB* meaning\nactually a storage capacity of more than *256 000 000 B*),\nor used by **Mac OS X** since v10.6 to report file sizes.\n\nArguments:\n    int (size): A file size.\n    int (precision): The number of decimal places to include (default = 1).\n    str (separator): The string to separate the value from the units (default = \" \").\n\nReturns:\n    `str`: A string containing a abbreviated file size and units.\n\nExample:\n    >>> filesize.decimal(30000)\n    '30.0 kB'\n    >>> filesize.decimal(30000, precision=2, separator=\"\")\n    '30.00kB'",
        "code": "def decimal(\n    size: int,\n    *,\n    precision: Optional[int] = 1,\n    separator: Optional[str] = \" \",\n) -> str:\n    \"\"\"Convert a filesize in to a string (powers of 1000, SI prefixes).\n\n    In this convention, ``1000 B = 1 kB``.\n\n    This is typically the format used to advertise the storage\n    capacity of USB flash drives and the like (*256 MB* meaning\n    actually a storage capacity of more than *256 000 000 B*),\n    or used by **Mac OS X** since v10.6 to report file sizes.\n\n    Arguments:\n        int (size): A file size.\n        int (precision): The number of decimal places to include (default = 1).\n        str (separator): The string to separate the value from the units (default = \" \").\n\n    Returns:\n        `str`: A string containing a abbreviated file size and units.\n\n    Example:\n        >>> filesize.decimal(30000)\n        '30.0 kB'\n        >>> filesize.decimal(30000, precision=2, separator=\"\")\n        '30.00kB'\n\n    \"\"\"\n    return _to_str(\n        size,\n        (\"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"),\n        1000,\n        precision=precision,\n        separator=separator,\n    )",
        "line_count": 37,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "__all__",
        "assigned_to": null,
        "lineno": 13
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 89
  },
  "rich/highlighter.py": {
    "filepath": "../rich/rich/highlighter.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_combine_regex",
        "args": [],
        "return_type": "str",
        "lineno": 8,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "regexes"
        ],
        "docstring": "Combine a number of regexes in to a single regex.\n\nReturns:\n    str: New regex with all regexes ORed together.",
        "code": "def _combine_regex(*regexes: str) -> str:\n    \"\"\"Combine a number of regexes in to a single regex.\n\n    Returns:\n        str: New regex with all regexes ORed together.\n    \"\"\"\n    return \"|\".join(regexes)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Union[str, Text]"
          }
        ],
        "return_type": "Text",
        "lineno": 20,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "text.copy",
          "str",
          "highlight_text",
          "text",
          "TypeError",
          "self.highlight",
          "Text"
        ],
        "docstring": "Highlight a str or Text instance.\n\nArgs:\n    text (Union[str, ~Text]): Text to highlight.\n\nRaises:\n    TypeError: If not called with text or str.\n\nReturns:\n    Text: A test instance with highlighting applied.",
        "code": "def __call__(self, text: Union[str, Text]) -> Text:\n        \"\"\"Highlight a str or Text instance.\n\n        Args:\n            text (Union[str, ~Text]): Text to highlight.\n\n        Raises:\n            TypeError: If not called with text or str.\n\n        Returns:\n            Text: A test instance with highlighting applied.\n        \"\"\"\n        if isinstance(text, str):\n            highlight_text = Text(text)\n        elif isinstance(text, Text):\n            highlight_text = text.copy()\n        else:\n            raise TypeError(f\"str or Text instance required, not {text!r}\")\n        self.highlight(highlight_text)\n        return highlight_text",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "highlight",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Text"
          }
        ],
        "return_type": "None",
        "lineno": 42,
        "decorators": [
          {
            "name": "abstractmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Apply highlighting in place to text.\n\nArgs:\n    text (~Text): A text object highlight.",
        "code": "def highlight(self, text: Text) -> None:\n        \"\"\"Apply highlighting in place to text.\n\n        Args:\n            text (~Text): A text object highlight.\n        \"\"\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "highlight",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Text"
          }
        ],
        "return_type": "None",
        "lineno": 57,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Nothing to do",
        "code": "def highlight(self, text: Text) -> None:\n        \"\"\"Nothing to do\"\"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "highlight",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Text"
          }
        ],
        "return_type": "None",
        "lineno": 67,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.base_style",
          "text.highlight_regex",
          "re_highlight",
          "highlight_regex"
        ],
        "docstring": "Highlight :class:`rich.text.Text` using regular expressions.\n\nArgs:\n    text (~Text): Text to highlighted.",
        "code": "def highlight(self, text: Text) -> None:\n        \"\"\"Highlight :class:`rich.text.Text` using regular expressions.\n\n        Args:\n            text (~Text): Text to highlighted.\n\n        \"\"\"\n\n        highlight_regex = text.highlight_regex\n        for re_highlight in self.highlights:\n            highlight_regex(re_highlight, style_prefix=self.base_style)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "highlight",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Text"
          }
        ],
        "return_type": "None",
        "lineno": 123,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.highlight",
          "re.finditer",
          "end",
          "append",
          "super",
          "Span",
          "text.spans.append",
          "plain",
          "text",
          "start",
          "match.span",
          "self.JSON_STR",
          "self.JSON_WHITESPACE",
          "text.plain",
          "len"
        ],
        "docstring": null,
        "code": "def highlight(self, text: Text) -> None:\n        super().highlight(text)\n\n        # Additional work to handle highlighting JSON keys\n        plain = text.plain\n        append = text.spans.append\n        whitespace = self.JSON_WHITESPACE\n        for match in re.finditer(self.JSON_STR, plain):\n            start, end = match.span()\n            cursor = end\n            while cursor < len(plain):\n                char = plain[cursor]\n                cursor += 1\n                if char == \":\":\n                    append(Span(start, end, \"json.key\"))\n                elif char in whitespace:\n                    continue\n                break",
        "line_count": 18,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Highlighter",
        "methods": [
          "__call__",
          "highlight"
        ],
        "base_classes": [
          "ABC"
        ],
        "lineno": 17,
        "docstring": "Abstract base class for highlighters."
      },
      {
        "name": "NullHighlighter",
        "methods": [
          "highlight"
        ],
        "base_classes": [
          "Highlighter"
        ],
        "lineno": 50,
        "docstring": "A highlighter object that doesn't highlight.\n\nMay be used to disable highlighting entirely."
      },
      {
        "name": "RegexHighlighter",
        "methods": [
          "highlight"
        ],
        "base_classes": [
          "Highlighter"
        ],
        "lineno": 61,
        "docstring": "Applies highlighting from a list of regular expressions."
      },
      {
        "name": "ReprHighlighter",
        "methods": [],
        "base_classes": [
          "RegexHighlighter"
        ],
        "lineno": 80,
        "docstring": "Highlights the text typically produced from ``__repr__`` methods."
      },
      {
        "name": "JSONHighlighter",
        "methods": [
          "highlight"
        ],
        "base_classes": [
          "RegexHighlighter"
        ],
        "lineno": 106,
        "docstring": "Highlights JSON"
      },
      {
        "name": "ISO8601Highlighter",
        "methods": [],
        "base_classes": [
          "RegexHighlighter"
        ],
        "lineno": 143,
        "docstring": "Highlights the ISO8601 date time strings.\nRegex reference: https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html"
      }
    ],
    "imports": [
      {
        "module": "re",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "abc",
        "name": "ABC",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "abc",
        "name": "abstractmethod",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Span",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 202,
        "type": "from_import"
      },
      {
        "module": "json",
        "alias": null,
        "lineno": 230,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Console",
      "json.dumps",
      "console.print_json"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "Console",
        "json.dumps",
        "console.print_json"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "abc",
        "json",
        "typing",
        "re"
      ],
      "third_party": {
        "other": [
          "text",
          "console"
        ]
      },
      "tech_stack": []
    },
    "line_count": 233
  },
  "rich/json.py": {
    "filepath": "../rich/rich/json.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "json",
            "type": "str"
          },
          {
            "name": "indent",
            "type": "Union[None, int, str]"
          },
          {
            "name": "highlight",
            "type": "bool"
          },
          {
            "name": "skip_keys",
            "type": "bool"
          },
          {
            "name": "ensure_ascii",
            "type": "bool"
          },
          {
            "name": "check_circular",
            "type": "bool"
          },
          {
            "name": "allow_nan",
            "type": "bool"
          },
          {
            "name": "default",
            "type": "Optional[Callable[Any, Any]]"
          },
          {
            "name": "sort_keys",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 25,
        "decorators": [],
        "is_async": false,
        "calls": [
          "highlighter",
          "check_circular",
          "indent",
          "skip_keys",
          "ensure_ascii",
          "sort_keys",
          "JSONHighlighter",
          "NullHighlighter",
          "allow_nan",
          "loads",
          "json",
          "data",
          "dumps",
          "default"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        json: str,\n        indent: Union[None, int, str] = 2,\n        highlight: bool = True,\n        skip_keys: bool = False,\n        ensure_ascii: bool = False,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        default: Optional[Callable[[Any], Any]] = None,\n        sort_keys: bool = False,\n    ) -> None:\n        data = loads(json)\n        json = dumps(\n            data,\n            indent=indent,\n            skipkeys=skip_keys,\n            ensure_ascii=ensure_ascii,\n            check_circular=check_circular,\n            allow_nan=allow_nan,\n            default=default,\n            sort_keys=sort_keys,\n        )\n        highlighter = JSONHighlighter() if highlight else NullHighlighter()\n        self.text = highlighter(json)\n        self.text.no_wrap = True\n        self.text.overflow = None",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "from_data",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "data",
            "type": "Any"
          },
          {
            "name": "indent",
            "type": "Union[None, int, str]"
          },
          {
            "name": "highlight",
            "type": "bool"
          },
          {
            "name": "skip_keys",
            "type": "bool"
          },
          {
            "name": "ensure_ascii",
            "type": "bool"
          },
          {
            "name": "check_circular",
            "type": "bool"
          },
          {
            "name": "allow_nan",
            "type": "bool"
          },
          {
            "name": "default",
            "type": "Optional[Callable[Any, Any]]"
          },
          {
            "name": "sort_keys",
            "type": "bool"
          }
        ],
        "return_type": "JSON",
        "lineno": 54,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "highlighter",
          "check_circular",
          "indent",
          "skip_keys",
          "ensure_ascii",
          "sort_keys",
          "JSONHighlighter",
          "NullHighlighter",
          "allow_nan",
          "cls.__new__",
          "json",
          "cls",
          "data",
          "dumps",
          "default"
        ],
        "docstring": "Encodes a JSON object from arbitrary data.\n\nArgs:\n    data (Any): An object that may be encoded in to JSON\n    indent (Union[None, int, str], optional): Number of characters to indent by. Defaults to 2.\n    highlight (bool, optional): Enable highlighting. Defaults to True.\n    default (Callable, optional): Optional callable which will be called for objects that cannot be serialized. Defaults to None.\n    skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n    ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n    check_circular (bool, optional): Check for circular references. Defaults to True.\n    allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n    default (Callable, optional): A callable that converts values that can not be encoded\n        in to something that can be JSON encoded. Defaults to None.\n    sort_keys (bool, optional): Sort dictionary keys. Defaults to False.\n\nReturns:\n    JSON: New JSON object from the given data.",
        "code": "def from_data(\n        cls,\n        data: Any,\n        indent: Union[None, int, str] = 2,\n        highlight: bool = True,\n        skip_keys: bool = False,\n        ensure_ascii: bool = False,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        default: Optional[Callable[[Any], Any]] = None,\n        sort_keys: bool = False,\n    ) -> \"JSON\":\n        \"\"\"Encodes a JSON object from arbitrary data.\n\n        Args:\n            data (Any): An object that may be encoded in to JSON\n            indent (Union[None, int, str], optional): Number of characters to indent by. Defaults to 2.\n            highlight (bool, optional): Enable highlighting. Defaults to True.\n            default (Callable, optional): Optional callable which will be called for objects that cannot be serialized. Defaults to None.\n            skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n            ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n            check_circular (bool, optional): Check for circular references. Defaults to True.\n            allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n            default (Callable, optional): A callable that converts values that can not be encoded\n                in to something that can be JSON encoded. Defaults to None.\n            sort_keys (bool, optional): Sort dictionary keys. Defaults to False.\n\n        Returns:\n            JSON: New JSON object from the given data.\n        \"\"\"\n        json_instance: \"JSON\" = cls.__new__(cls)\n        json = dumps(\n            data,\n            indent=indent,\n            skipkeys=skip_keys,\n            ensure_ascii=ensure_ascii,\n            check_circular=check_circular,\n            allow_nan=allow_nan,\n            default=default,\n            sort_keys=sort_keys,\n        )\n        highlighter = JSONHighlighter() if highlight else NullHighlighter()\n        json_instance.text = highlighter(json)\n        json_instance.text.no_wrap = True\n        json_instance.text.overflow = None\n        return json_instance",
        "line_count": 46,
        "needs_llm_summary": true
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Text",
        "lineno": 101,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich__(self) -> Text:\n        return self.text",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "JSON",
        "methods": [
          "__init__",
          "from_data",
          "__rich__"
        ],
        "base_classes": [],
        "lineno": 9,
        "docstring": "A renderable which pretty prints JSON.\n\nArgs:\n    json (str): JSON encoded data.\n    indent (Union[None, int, str], optional): Number of characters to indent by. Defaults to 2.\n    highlight (bool, optional): Enable highlighting. Defaults to True.\n    skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n    ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n    check_circular (bool, optional): Check for circular references. Defaults to True.\n    allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n    default (Callable, optional): A callable that converts values that can not be encoded\n        in to something that can be JSON encoded. Defaults to None.\n    sort_keys (bool, optional): Sort dictionary keys. Defaults to False."
      }
    ],
    "imports": [
      {
        "module": "pathlib",
        "name": "Path",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "json",
        "name": "loads",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "json",
        "name": "dumps",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "JSONHighlighter",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "NullHighlighter",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "argparse",
        "alias": null,
        "lineno": 106,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 107,
        "type": "import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 125,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "argparse.ArgumentParser",
      "sys.stdin.read",
      "unknown.read_text",
      "JSON",
      "Console",
      "sys.exit",
      "error_console.print",
      "parser.parse_args",
      "Path",
      "parser.add_argument"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "args.indent",
        "argparse.ArgumentParser",
        "sys.stdin.read",
        "unknown.read_text",
        "JSON",
        "Console",
        "sys.exit",
        "json_data",
        "error_console.print",
        "parser.parse_args",
        "args.path",
        "Path",
        "int",
        "parser.add_argument"
      ],
      "class_instantiations": [
        "Path",
        "JSON",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "pathlib",
        "json",
        "sys",
        "argparse"
      ],
      "third_party": {
        "other": [
          "text",
          "highlighter",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 140
  },
  "rich/jupyter.py": {
    "filepath": "../rich/rich/jupyter.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_render_segments",
        "args": [
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          }
        ],
        "return_type": "str",
        "lineno": 59,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style.get_html_style",
          "fragments.append",
          "unknown.replace",
          "fragments",
          "unknown.join",
          "theme",
          "segments",
          "escape",
          "Segment.simplify",
          "code",
          "text",
          "JUPYTER_HTML_FORMAT.format",
          "append_fragment",
          "DEFAULT_TERMINAL_THEME",
          "text.replace"
        ],
        "docstring": null,
        "code": "def _render_segments(segments: Iterable[Segment]) -> str:\n    def escape(text: str) -> str:\n        \"\"\"Escape html.\"\"\"\n        return text.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n\n    fragments: List[str] = []\n    append_fragment = fragments.append\n    theme = DEFAULT_TERMINAL_THEME\n    for text, style, control in Segment.simplify(segments):\n        if control:\n            continue\n        text = escape(text)\n        if style:\n            rule = style.get_html_style(theme)\n            text = f'<span style=\"{rule}\">{text}</span>' if rule else text\n            if style.link:\n                text = f'<a href=\"{style.link}\" target=\"_blank\">{text}</a>'\n        append_fragment(text)\n\n    code = \"\".join(fragments)\n    html = JUPYTER_HTML_FORMAT.format(code=code)\n\n    return html",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "display",
        "args": [
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 84,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_render_segments",
          "JupyterRenderable",
          "ipython_display",
          "segments",
          "text",
          "jupyter_renderable",
          "html"
        ],
        "docstring": "Render segments to Jupyter.",
        "code": "def display(segments: Iterable[Segment], text: str) -> None:\n    \"\"\"Render segments to Jupyter.\"\"\"\n    html = _render_segments(segments)\n    jupyter_renderable = JupyterRenderable(html, text)\n    try:\n        from IPython.display import display as ipython_display\n\n        ipython_display(jupyter_renderable)\n    except ModuleNotFoundError:\n        # Handle the case where the Console has force_jupyter=True,\n        # but IPython is not installed.\n        pass",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "print",
        "args": [],
        "return_type": "None",
        "lineno": 98,
        "decorators": [],
        "is_async": false,
        "calls": [
          "console.print",
          "get_console",
          "kwargs"
        ],
        "docstring": "Proxy for Console print.",
        "code": "def print(*args: Any, **kwargs: Any) -> None:\n    \"\"\"Proxy for Console print.\"\"\"\n    console = get_console()\n    return console.print(*args, **kwargs)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "html",
            "type": "str"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 21,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "html"
        ],
        "docstring": null,
        "code": "def __init__(self, html: str, text: str) -> None:\n        self.html = html\n        self.text = text",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_repr_mimebundle_",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "include",
            "type": "Sequence[str]"
          },
          {
            "name": "exclude",
            "type": "Sequence[str]"
          }
        ],
        "return_type": "Dict[str, str]",
        "lineno": 25,
        "decorators": [],
        "is_async": false,
        "calls": [
          "data.items"
        ],
        "docstring": null,
        "code": "def _repr_mimebundle_(\n        self, include: Sequence[str], exclude: Sequence[str], **kwargs: Any\n    ) -> Dict[str, str]:\n        data = {\"text/plain\": self.text, \"text/html\": self.html}\n        if include:\n            data = {k: v for (k, v) in data.items() if k in include}\n        if exclude:\n            data = {k: v for (k, v) in data.items() if k not in exclude}\n        return data",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "_repr_mimebundle_",
        "args": [
          {
            "name": "self",
            "type": "ConsoleRenderable"
          },
          {
            "name": "include",
            "type": "Sequence[str]"
          },
          {
            "name": "exclude",
            "type": "Sequence[str]"
          }
        ],
        "return_type": "Dict[str, str]",
        "lineno": 41,
        "decorators": [],
        "is_async": false,
        "calls": [
          "data.items",
          "_render_segments",
          "get_console",
          "list",
          "console.render",
          "console._render_buffer",
          "segments",
          "console.options",
          "self"
        ],
        "docstring": null,
        "code": "def _repr_mimebundle_(\n        self: \"ConsoleRenderable\",\n        include: Sequence[str],\n        exclude: Sequence[str],\n        **kwargs: Any,\n    ) -> Dict[str, str]:\n        console = get_console()\n        segments = list(console.render(self, console.options))\n        html = _render_segments(segments)\n        text = console._render_buffer(segments)\n        data = {\"text/plain\": text, \"text/html\": html}\n        if include:\n            data = {k: v for (k, v) in data.items() if k in include}\n        if exclude:\n            data = {k: v for (k, v) in data.items() if k not in exclude}\n        return data",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "escape",
        "args": [
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 60,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.replace",
          "text.replace"
        ],
        "docstring": "Escape html.",
        "code": "def escape(text: str) -> str:\n        \"\"\"Escape html.\"\"\"\n        return text.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "JupyterRenderable",
        "methods": [
          "__init__",
          "_repr_mimebundle_"
        ],
        "base_classes": [],
        "lineno": 18,
        "docstring": "A shim to write html to Jupyter notebook."
      },
      {
        "name": "JupyterMixin",
        "methods": [
          "_repr_mimebundle_"
        ],
        "base_classes": [],
        "lineno": 36,
        "docstring": "Add to an Rich renderable to make it render in Jupyter notebook."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "get_console",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "terminal_theme",
        "name": "DEFAULT_TERMINAL_THEME",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "ConsoleRenderable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "ConsoleRenderable",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "IPython.display",
        "name": "display",
        "alias": "ipython_display",
        "lineno": 89,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "JUPYTER_HTML_FORMAT",
        "assigned_to": "str",
        "lineno": 13
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "get_console",
          "segment",
          "terminal_theme",
          "rich",
          "IPython"
        ]
      },
      "tech_stack": []
    },
    "line_count": 102
  },
  "rich/layout.py": {
    "filepath": "../rich/rich/layout.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "layout",
            "type": "Layout"
          },
          {
            "name": "style",
            "type": "StyleType"
          }
        ],
        "return_type": "None",
        "lineno": 56,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "layout"
        ],
        "docstring": null,
        "code": "def __init__(self, layout: \"Layout\", style: StyleType = \"\") -> None:\n        self.layout = layout\n        self.style = style",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 60,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "options.max_width",
          "Pretty",
          "Panel",
          "self.layout",
          "title",
          "self.highlighter",
          "Align.center",
          "height",
          "layout"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = options.max_width\n        height = options.height or options.size.height\n        layout = self.layout\n        title = (\n            f\"{layout.name!r} ({width} x {height})\"\n            if layout.name\n            else f\"({width} x {height})\"\n        )\n        yield Panel(\n            Align.center(Pretty(layout), vertical=\"middle\"),\n            style=self.style,\n            title=self.highlighter(title),\n            border_style=\"blue\",\n            height=height,\n        )",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "get_tree_icon",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 86,
        "decorators": [
          {
            "name": "abstractmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get the icon (emoji) used in layout.tree",
        "code": "def get_tree_icon(self) -> str:\n        \"\"\"Get the icon (emoji) used in layout.tree\"\"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "divide",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "children",
            "type": "Sequence[Layout]"
          },
          {
            "name": "region",
            "type": "Region"
          }
        ],
        "return_type": "Iterable[Tuple[Layout, Region]]",
        "lineno": 90,
        "decorators": [
          {
            "name": "abstractmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Divide a region amongst several child layouts.\n\nArgs:\n    children (Sequence(Layout)): A number of child layouts.\n    region (Region): A rectangular region to divide.",
        "code": "def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        \"\"\"Divide a region amongst several child layouts.\n\n        Args:\n            children (Sequence(Layout)): A number of child layouts.\n            region (Region): A rectangular region to divide.\n        \"\"\"",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "get_tree_icon",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 106,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_tree_icon(self) -> str:\n        return \"[layout.tree.row]\u2b0c\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "divide",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "children",
            "type": "Sequence[Layout]"
          },
          {
            "name": "region",
            "type": "Region"
          }
        ],
        "return_type": "Iterable[Tuple[Layout, Region]]",
        "lineno": 109,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Region",
          "_Region",
          "ratio_resolve",
          "y",
          "width",
          "render_widths",
          "children",
          "child_width",
          "zip",
          "height",
          "region"
        ],
        "docstring": null,
        "code": "def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        x, y, width, height = region\n        render_widths = ratio_resolve(width, children)\n        offset = 0\n        _Region = Region\n        for child, child_width in zip(children, render_widths):\n            yield child, _Region(x + offset, y, child_width, height)\n            offset += child_width",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "get_tree_icon",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 126,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_tree_icon(self) -> str:\n        return \"[layout.tree.column]\u2b0d\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "divide",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "children",
            "type": "Sequence[Layout]"
          },
          {
            "name": "region",
            "type": "Region"
          }
        ],
        "return_type": "Iterable[Tuple[Layout, Region]]",
        "lineno": 129,
        "decorators": [],
        "is_async": false,
        "calls": [
          "render_heights",
          "Region",
          "_Region",
          "ratio_resolve",
          "child_height",
          "width",
          "children",
          "zip",
          "height",
          "region",
          "x"
        ],
        "docstring": null,
        "code": "def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        x, y, width, height = region\n        render_heights = ratio_resolve(height, children)\n        offset = 0\n        _Region = Region\n        for child, child_height in zip(children, render_heights):\n            yield child, _Region(x, y + offset, width, child_height)\n            offset += child_height",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "Optional[RenderableType]"
          }
        ],
        "return_type": "None",
        "lineno": 156,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_Placeholder",
          "name",
          "RLock",
          "minimum_size",
          "visible",
          "size",
          "ratio",
          "self"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        renderable: Optional[RenderableType] = None,\n        *,\n        name: Optional[str] = None,\n        size: Optional[int] = None,\n        minimum_size: int = 1,\n        ratio: int = 1,\n        visible: bool = True,\n    ) -> None:\n        self._renderable = renderable or _Placeholder(self)\n        self.size = size\n        self.minimum_size = minimum_size\n        self.ratio = ratio\n        self.name = name\n        self.visible = visible\n        self.splitter: Splitter = self.splitters[\"column\"]()\n        self._children: List[Layout] = []\n        self._render_map: RenderMap = {}\n        self._lock = RLock()",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Result",
        "lineno": 177,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_repr__(self) -> Result:\n        yield \"name\", self.name, None\n        yield \"size\", self.size, None\n        yield \"minimum_size\", self.minimum_size, 1\n        yield \"ratio\", self.ratio, 1",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "renderable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 184,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Layout renderable.",
        "code": "def renderable(self) -> RenderableType:\n        \"\"\"Layout renderable.\"\"\"\n        return self if self._children else self._renderable",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "children",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "List[Layout]",
        "lineno": 189,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Gets (visible) layout children.",
        "code": "def children(self) -> List[\"Layout\"]:\n        \"\"\"Gets (visible) layout children.\"\"\"\n        return [child for child in self._children if child.visible]",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "map",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "RenderMap",
        "lineno": 194,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get a map of the last render.",
        "code": "def map(self) -> RenderMap:\n        \"\"\"Get a map of the last render.\"\"\"\n        return self._render_map",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "Optional[Layout]",
        "lineno": 198,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "child.get"
        ],
        "docstring": "Get a named layout, or None if it doesn't exist.\n\nArgs:\n    name (str): Name of layout.\n\nReturns:\n    Optional[Layout]: Layout instance or None if no layout was found.",
        "code": "def get(self, name: str) -> Optional[\"Layout\"]:\n        \"\"\"Get a named layout, or None if it doesn't exist.\n\n        Args:\n            name (str): Name of layout.\n\n        Returns:\n            Optional[Layout]: Layout instance or None if no layout was found.\n        \"\"\"\n        if self.name == name:\n            return self\n        else:\n            for child in self._children:\n                named_layout = child.get(name)\n                if named_layout is not None:\n                    return named_layout\n        return None",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "__getitem__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          }
        ],
        "return_type": "Layout",
        "lineno": 216,
        "decorators": [],
        "is_async": false,
        "calls": [
          "name",
          "KeyError",
          "self.get"
        ],
        "docstring": null,
        "code": "def __getitem__(self, name: str) -> \"Layout\":\n        layout = self.get(name)\n        if layout is None:\n            raise KeyError(f\"No layout with name {name!r}\")\n        return layout",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "tree",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Tree",
        "lineno": 223,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "child",
          "summary",
          "icon",
          "Pretty",
          "table",
          "Styled",
          "layout.splitter.get_tree_icon",
          "tree",
          "Table.grid",
          "Tree",
          "text",
          "tree.add",
          "recurse",
          "table.add_row",
          "layout",
          "self"
        ],
        "docstring": "Get a tree renderable to show layout structure.",
        "code": "def tree(self) -> \"Tree\":\n        \"\"\"Get a tree renderable to show layout structure.\"\"\"\n        from rich.styled import Styled\n        from rich.table import Table\n        from rich.tree import Tree\n\n        def summary(layout: \"Layout\") -> Table:\n            icon = layout.splitter.get_tree_icon()\n\n            table = Table.grid(padding=(0, 1, 0, 0))\n\n            text: RenderableType = (\n                Pretty(layout) if layout.visible else Styled(Pretty(layout), \"dim\")\n            )\n            table.add_row(icon, text)\n            _summary = table\n            return _summary\n\n        layout = self\n        tree = Tree(\n            summary(layout),\n            guide_style=f\"layout.tree.{layout.splitter.name}\",\n            highlight=True,\n        )\n\n        def recurse(tree: \"Tree\", layout: \"Layout\") -> None:\n            for child in layout._children:\n                recurse(\n                    tree.add(\n                        summary(child),\n                        guide_style=f\"layout.tree.{child.splitter.name}\",\n                    ),\n                    child,\n                )\n\n        recurse(tree, self)\n        return tree",
        "line_count": 37,
        "needs_llm_summary": true
      },
      {
        "name": "split",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 261,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "Layout",
          "Splitter",
          "_layouts",
          "NoSplitter",
          "splitter",
          "layout"
        ],
        "docstring": "Split the layout in to multiple sub-layouts.\n\nArgs:\n    *layouts (Layout): Positional arguments should be (sub) Layout instances.\n    splitter (Union[Splitter, str]): Splitter instance or name of splitter.",
        "code": "def split(\n        self,\n        *layouts: Union[\"Layout\", RenderableType],\n        splitter: Union[Splitter, str] = \"column\",\n    ) -> None:\n        \"\"\"Split the layout in to multiple sub-layouts.\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n            splitter (Union[Splitter, str]): Splitter instance or name of splitter.\n        \"\"\"\n        _layouts = [\n            layout if isinstance(layout, Layout) else Layout(layout)\n            for layout in layouts\n        ]\n        try:\n            self.splitter = (\n                splitter\n                if isinstance(splitter, Splitter)\n                else self.splitters[splitter]()\n            )\n        except KeyError:\n            raise NoSplitter(f\"No splitter called {splitter!r}\")\n        self._children[:] = _layouts",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "add_split",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 286,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "Layout",
          "self._children.extend",
          "_layouts",
          "layout"
        ],
        "docstring": "Add a new layout(s) to existing split.\n\nArgs:\n    *layouts (Union[Layout, RenderableType]): Positional arguments should be renderables or (sub) Layout instances.",
        "code": "def add_split(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Add a new layout(s) to existing split.\n\n        Args:\n            *layouts (Union[Layout, RenderableType]): Positional arguments should be renderables or (sub) Layout instances.\n\n        \"\"\"\n        _layouts = (\n            layout if isinstance(layout, Layout) else Layout(layout)\n            for layout in layouts\n        )\n        self._children.extend(_layouts)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "split_row",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 299,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.split"
        ],
        "docstring": "Split the layout in to a row (layouts side by side).\n\nArgs:\n    *layouts (Layout): Positional arguments should be (sub) Layout instances.",
        "code": "def split_row(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Split the layout in to a row (layouts side by side).\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n        \"\"\"\n        self.split(*layouts, splitter=\"row\")",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "split_column",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 307,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.split"
        ],
        "docstring": "Split the layout in to a column (layouts stacked on top of each other).\n\nArgs:\n    *layouts (Layout): Positional arguments should be (sub) Layout instances.",
        "code": "def split_column(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Split the layout in to a column (layouts stacked on top of each other).\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n        \"\"\"\n        self.split(*layouts, splitter=\"column\")",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "unsplit",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 315,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Reset splits to initial state.",
        "code": "def unsplit(self) -> None:\n        \"\"\"Reset splits to initial state.\"\"\"\n        del self._children[:]",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 319,
        "decorators": [],
        "is_async": false,
        "calls": [
          "renderable"
        ],
        "docstring": "Update renderable.\n\nArgs:\n    renderable (RenderableType): New renderable object.",
        "code": "def update(self, renderable: RenderableType) -> None:\n        \"\"\"Update renderable.\n\n        Args:\n            renderable (RenderableType): New renderable object.\n        \"\"\"\n        with self._lock:\n            self._renderable = renderable",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "refresh_screen",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "layout_name",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 328,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "console.render_lines",
          "LayoutRender",
          "console.update_screen_lines",
          "console.options.update_dimensions",
          "y",
          "width",
          "height",
          "layout",
          "region",
          "x"
        ],
        "docstring": "Refresh a sub-layout.\n\nArgs:\n    console (Console): Console instance where Layout is to be rendered.\n    layout_name (str): Name of layout.",
        "code": "def refresh_screen(self, console: \"Console\", layout_name: str) -> None:\n        \"\"\"Refresh a sub-layout.\n\n        Args:\n            console (Console): Console instance where Layout is to be rendered.\n            layout_name (str): Name of layout.\n        \"\"\"\n        with self._lock:\n            layout = self[layout_name]\n            region, _lines = self._render_map[layout]\n            (x, y, width, height) = region\n            lines = console.render_lines(\n                layout, console.options.update_dimensions(width, height)\n            )\n            self._render_map[layout] = LayoutRender(region, lines)\n            console.update_screen_lines(lines, x, y)",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "_make_region_map",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "height",
            "type": "int"
          }
        ],
        "return_type": "RegionMap",
        "lineno": 345,
        "decorators": [],
        "is_async": false,
        "calls": [
          "layout_regions",
          "Region",
          "child_and_region",
          "layout_regions.append",
          "layout.children",
          "append_layout_region",
          "push",
          "stack.pop",
          "width",
          "children",
          "sorted",
          "stack.append",
          "pop",
          "itemgetter",
          "height",
          "region",
          "layout.splitter.divide"
        ],
        "docstring": "Create a dict that maps layout on to Region.",
        "code": "def _make_region_map(self, width: int, height: int) -> RegionMap:\n        \"\"\"Create a dict that maps layout on to Region.\"\"\"\n        stack: List[Tuple[Layout, Region]] = [(self, Region(0, 0, width, height))]\n        push = stack.append\n        pop = stack.pop\n        layout_regions: List[Tuple[Layout, Region]] = []\n        append_layout_region = layout_regions.append\n        while stack:\n            append_layout_region(pop())\n            layout, region = layout_regions[-1]\n            children = layout.children\n            if children:\n                for child_and_region in layout.splitter.divide(children, region):\n                    push(child_and_region)\n\n        region_map = {\n            layout: region\n            for layout, region in sorted(layout_regions, key=itemgetter(1))\n        }\n        return region_map",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderMap",
        "lineno": 366,
        "decorators": [],
        "is_async": false,
        "calls": [
          "update_dimensions",
          "lines",
          "console.render_lines",
          "render_height",
          "LayoutRender",
          "region.height",
          "layout.renderable",
          "options.max_width",
          "render_lines",
          "options.update_dimensions",
          "render_width",
          "region_map.items",
          "region.width",
          "region",
          "self._make_region_map"
        ],
        "docstring": "Render the sub_layouts.\n\nArgs:\n    console (Console): Console instance.\n    options (ConsoleOptions): Console options.\n\nReturns:\n    RenderMap: A dict that maps Layout on to a tuple of Region, lines",
        "code": "def render(self, console: Console, options: ConsoleOptions) -> RenderMap:\n        \"\"\"Render the sub_layouts.\n\n        Args:\n            console (Console): Console instance.\n            options (ConsoleOptions): Console options.\n\n        Returns:\n            RenderMap: A dict that maps Layout on to a tuple of Region, lines\n        \"\"\"\n        render_width = options.max_width\n        render_height = options.height or console.height\n        region_map = self._make_region_map(render_width, render_height)\n        layout_regions = [\n            (layout, region)\n            for layout, region in region_map.items()\n            if not layout.children\n        ]\n        render_map: Dict[\"Layout\", \"LayoutRender\"] = {}\n        render_lines = console.render_lines\n        update_dimensions = options.update_dimensions\n\n        for layout, region in layout_regions:\n            lines = render_lines(\n                layout.renderable, update_dimensions(region.width, region.height)\n            )\n            render_map[layout] = LayoutRender(region, lines)\n        return render_map",
        "line_count": 28,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 395,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "self.render",
          "lines",
          "range",
          "_islice",
          "line",
          "islice",
          "height",
          "render_map",
          "options.update_dimensions",
          "layout_lines",
          "y",
          "width",
          "render_map.values",
          "zip",
          "console",
          "region",
          "row.extend"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        with self._lock:\n            width = options.max_width or console.width\n            height = options.height or console.height\n            render_map = self.render(console, options.update_dimensions(width, height))\n            self._render_map = render_map\n            layout_lines: List[List[Segment]] = [[] for _ in range(height)]\n            _islice = islice\n            for region, lines in render_map.values():\n                _x, y, _layout_width, layout_height = region\n                for row, line in zip(\n                    _islice(layout_lines, y, y + layout_height), lines\n                ):\n                    row.extend(line)\n\n            new_line = Segment.line()\n            for layout_row in layout_lines:\n                yield from layout_row\n                yield new_line",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "summary",
        "args": [
          {
            "name": "layout",
            "type": "Layout"
          }
        ],
        "return_type": "Table",
        "lineno": 229,
        "decorators": [],
        "is_async": false,
        "calls": [
          "icon",
          "Pretty",
          "table",
          "Styled",
          "layout.splitter.get_tree_icon",
          "Table.grid",
          "text",
          "table.add_row",
          "layout"
        ],
        "docstring": null,
        "code": "def summary(layout: \"Layout\") -> Table:\n            icon = layout.splitter.get_tree_icon()\n\n            table = Table.grid(padding=(0, 1, 0, 0))\n\n            text: RenderableType = (\n                Pretty(layout) if layout.visible else Styled(Pretty(layout), \"dim\")\n            )\n            table.add_row(icon, text)\n            _summary = table\n            return _summary",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "recurse",
        "args": [
          {
            "name": "tree",
            "type": "Tree"
          },
          {
            "name": "layout",
            "type": "Layout"
          }
        ],
        "return_type": "None",
        "lineno": 248,
        "decorators": [],
        "is_async": false,
        "calls": [
          "child",
          "recurse",
          "tree.add",
          "summary"
        ],
        "docstring": null,
        "code": "def recurse(tree: \"Tree\", layout: \"Layout\") -> None:\n            for child in layout._children:\n                recurse(\n                    tree.add(\n                        summary(child),\n                        guide_style=f\"layout.tree.{child.splitter.name}\",\n                    ),\n                    child,\n                )",
        "line_count": 9,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "LayoutRender",
        "methods": [],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 32,
        "docstring": "An individual layout render."
      },
      {
        "name": "LayoutError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 43,
        "docstring": "Layout related error."
      },
      {
        "name": "NoSplitter",
        "methods": [],
        "base_classes": [
          "LayoutError"
        ],
        "lineno": 47,
        "docstring": "Requested splitter does not exist."
      },
      {
        "name": "_Placeholder",
        "methods": [
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 51,
        "docstring": "An internal renderable used as a Layout placeholder."
      },
      {
        "name": "Splitter",
        "methods": [
          "get_tree_icon",
          "divide"
        ],
        "base_classes": [
          "ABC"
        ],
        "lineno": 80,
        "docstring": "Base class for a splitter."
      },
      {
        "name": "RowSplitter",
        "methods": [
          "get_tree_icon",
          "divide"
        ],
        "base_classes": [
          "Splitter"
        ],
        "lineno": 101,
        "docstring": "Split a layout region in to rows."
      },
      {
        "name": "ColumnSplitter",
        "methods": [
          "get_tree_icon",
          "divide"
        ],
        "base_classes": [
          "Splitter"
        ],
        "lineno": 121,
        "docstring": "Split a layout region in to columns."
      },
      {
        "name": "Layout",
        "methods": [
          "__init__",
          "__rich_repr__",
          "renderable",
          "children",
          "map",
          "get",
          "__getitem__",
          "tree",
          "split",
          "add_split",
          "split_row",
          "split_column",
          "unsplit",
          "update",
          "refresh_screen",
          "_make_region_map",
          "render",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 142,
        "docstring": "A renderable to divide a fixed height in to rows or columns.\n\nArgs:\n    renderable (RenderableType, optional): Renderable content, or None for placeholder. Defaults to None.\n    name (str, optional): Optional identifier for Layout. Defaults to None.\n    size (int, optional): Optional fixed size of layout. Defaults to None.\n    minimum_size (int, optional): Minimum size of layout. Defaults to 1.\n    ratio (int, optional): Optional ratio for flexible layout. Defaults to 1.\n    visible (bool, optional): Visibility of layout. Defaults to True."
      }
    ],
    "imports": [
      {
        "module": "abc",
        "name": "ABC",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "abc",
        "name": "abstractmethod",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "itertools",
        "name": "islice",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "operator",
        "name": "itemgetter",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "threading",
        "name": "RLock",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "_ratio",
        "name": "ratio_resolve",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "Align",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "panel",
        "name": "Panel",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "region",
        "name": "Region",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "repr",
        "name": "Result",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "repr",
        "name": "rich_repr",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "rich.tree",
        "name": "Tree",
        "alias": null,
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 419,
        "type": "from_import"
      },
      {
        "module": "rich.styled",
        "name": "Styled",
        "alias": null,
        "lineno": 225,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 226,
        "type": "from_import"
      },
      {
        "module": "rich.tree",
        "name": "Tree",
        "alias": null,
        "lineno": 227,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "RegionMap",
        "assigned_to": null,
        "lineno": 39
      },
      {
        "name": "RenderMap",
        "assigned_to": null,
        "lineno": 40
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "Layout",
      "console.print",
      "unknown.update",
      "Console",
      "layout.split_column",
      "unknown.split_column",
      "unknown.split_row"
    ],
    "module_level_calls": {
      "function_calls": [
        "Layout",
        "console.print",
        "layout",
        "unknown.update",
        "Console",
        "layout.split_column",
        "unknown.split_column",
        "unknown.split_row",
        "layout.tree"
      ],
      "class_instantiations": [
        "Layout",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "abc",
        "itertools",
        "threading",
        "typing"
      ],
      "third_party": {
        "other": [
          "operator",
          "_ratio",
          "align",
          "console",
          "highlighter",
          "panel",
          "pretty",
          "region",
          "repr",
          "segment",
          "style",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 443
  },
  "rich/live.py": {
    "filepath": "../rich/rich/live.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "live",
            "type": "Live"
          },
          {
            "name": "refresh_per_second",
            "type": "float"
          }
        ],
        "return_type": "None",
        "lineno": 25,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Event",
          "live",
          "super",
          "unknown.__init__",
          "refresh_per_second"
        ],
        "docstring": null,
        "code": "def __init__(self, live: \"Live\", refresh_per_second: float) -> None:\n        self.live = live\n        self.refresh_per_second = refresh_per_second\n        self.done = Event()\n        super().__init__(daemon=True)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "stop",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 31,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.done.set"
        ],
        "docstring": null,
        "code": "def stop(self) -> None:\n        self.done.set()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "run",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 34,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.live.refresh",
          "self.done.is_set",
          "self.done.wait"
        ],
        "docstring": null,
        "code": "def run(self) -> None:\n        while not self.done.wait(1 / self.refresh_per_second):\n            with self.live._lock:\n                if not self.done.is_set():\n                    self.live.refresh()",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "Optional[RenderableType]"
          }
        ],
        "return_type": "None",
        "lineno": 57,
        "decorators": [],
        "is_async": false,
        "calls": [
          "RLock",
          "auto_refresh",
          "vertical_overflow",
          "get_console",
          "renderable",
          "get_renderable",
          "redirect_stdout",
          "screen",
          "redirect_stderr",
          "LiveRender",
          "self.get_renderable",
          "refresh_per_second"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        renderable: Optional[RenderableType] = None,\n        *,\n        console: Optional[Console] = None,\n        screen: bool = False,\n        auto_refresh: bool = True,\n        refresh_per_second: float = 4,\n        transient: bool = False,\n        redirect_stdout: bool = True,\n        redirect_stderr: bool = True,\n        vertical_overflow: VerticalOverflowMethod = \"ellipsis\",\n        get_renderable: Optional[Callable[[], RenderableType]] = None,\n    ) -> None:\n        assert refresh_per_second > 0, \"refresh_per_second must be > 0\"\n        self._renderable = renderable\n        self.console = console if console is not None else get_console()\n        self._screen = screen\n        self._alt_screen = False\n\n        self._redirect_stdout = redirect_stdout\n        self._redirect_stderr = redirect_stderr\n        self._restore_stdout: Optional[IO[str]] = None\n        self._restore_stderr: Optional[IO[str]] = None\n\n        self._lock = RLock()\n        self.ipy_widget: Optional[Any] = None\n        self.auto_refresh = auto_refresh\n        self._started: bool = False\n        self.transient = True if screen else transient\n\n        self._refresh_thread: Optional[_RefreshThread] = None\n        self.refresh_per_second = refresh_per_second\n\n        self.vertical_overflow = vertical_overflow\n        self._get_renderable = get_renderable\n        self._live_render = LiveRender(\n            self.get_renderable(), vertical_overflow=vertical_overflow\n        )\n        self._nested = False",
        "line_count": 40,
        "needs_llm_summary": true
      },
      {
        "name": "is_started",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 99,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Check if live display has been started.",
        "code": "def is_started(self) -> bool:\n        \"\"\"Check if live display has been started.\"\"\"\n        return self._started",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get_renderable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 103,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._get_renderable"
        ],
        "docstring": null,
        "code": "def get_renderable(self) -> RenderableType:\n        renderable = (\n            self._get_renderable()\n            if self._get_renderable is not None\n            else self._renderable\n        )\n        return renderable or \"\"",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "start",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "refresh",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 111,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.refresh_per_second",
          "self.refresh",
          "_RefreshThread",
          "self.console.set_live",
          "self.console.push_render_hook",
          "self.console.show_cursor",
          "self._enable_redirect_io",
          "self.stop",
          "self.console.set_alt_screen",
          "self._refresh_thread.start",
          "self"
        ],
        "docstring": "Start live rendering display.\n\nArgs:\n    refresh (bool, optional): Also refresh. Defaults to False.",
        "code": "def start(self, refresh: bool = False) -> None:\n        \"\"\"Start live rendering display.\n\n        Args:\n            refresh (bool, optional): Also refresh. Defaults to False.\n        \"\"\"\n        with self._lock:\n            if self._started:\n                return\n            self._started = True\n\n            if not self.console.set_live(self):\n                self._nested = True\n                return\n\n            if self._screen:\n                self._alt_screen = self.console.set_alt_screen(True)\n            self.console.show_cursor(False)\n            self._enable_redirect_io()\n            self.console.push_render_hook(self)\n            if refresh:\n                try:\n                    self.refresh()\n                except Exception:\n                    # If refresh fails, we want to stop the redirection of sys.stderr,\n                    # so the error stacktrace is properly displayed in the terminal.\n                    # (or, if the code that calls Rich captures the exception and wants to display something,\n                    # let this be displayed in the terminal).\n                    self.stop()\n                    raise\n            if self.auto_refresh:\n                self._refresh_thread = _RefreshThread(self, self.refresh_per_second)\n                self._refresh_thread.start()",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "stop",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 145,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._disable_redirect_io",
          "self.refresh",
          "self.console.control",
          "self.console.show_cursor",
          "self.console.line",
          "self.console.clear_live",
          "self._live_render.restore_cursor",
          "self._refresh_thread.stop",
          "self.renderable",
          "self.console.pop_render_hook",
          "self.console.set_alt_screen",
          "self.ipy_widget.close",
          "self.console.print"
        ],
        "docstring": "Stop live rendering display.",
        "code": "def stop(self) -> None:\n        \"\"\"Stop live rendering display.\"\"\"\n        with self._lock:\n            if not self._started:\n                return\n            self._started = False\n            self.console.clear_live()\n            if self._nested:\n                if not self.transient:\n                    self.console.print(self.renderable)\n                return\n\n            if self.auto_refresh and self._refresh_thread is not None:\n                self._refresh_thread.stop()\n                self._refresh_thread = None\n            # allow it to fully render on the last even if overflow\n            self.vertical_overflow = \"visible\"\n            with self.console:\n                try:\n                    if not self._alt_screen and not self.console.is_jupyter:\n                        self.refresh()\n                finally:\n                    self._disable_redirect_io()\n                    self.console.pop_render_hook()\n                    if not self._alt_screen and self.console.is_terminal:\n                        self.console.line()\n                    self.console.show_cursor(True)\n                    if self._alt_screen:\n                        self.console.set_alt_screen(False)\n                    if self.transient and not self._alt_screen:\n                        self.console.control(self._live_render.restore_cursor())\n                    if self.ipy_widget is not None and self.transient:\n                        self.ipy_widget.close()",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Self",
        "lineno": 179,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.start"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> Self:\n        self.start(refresh=self._renderable is not None)\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 183,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.stop"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.stop()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_enable_redirect_io",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 191,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "FileProxy",
          "sys.stderr",
          "sys.stdout",
          "self.console",
          "cast"
        ],
        "docstring": "Enable redirecting of stdout / stderr.",
        "code": "def _enable_redirect_io(self) -> None:\n        \"\"\"Enable redirecting of stdout / stderr.\"\"\"\n        if self.console.is_terminal or self.console.is_jupyter:\n            if self._redirect_stdout and not isinstance(sys.stdout, FileProxy):\n                self._restore_stdout = sys.stdout\n                sys.stdout = cast(\"TextIO\", FileProxy(self.console, sys.stdout))\n            if self._redirect_stderr and not isinstance(sys.stderr, FileProxy):\n                self._restore_stderr = sys.stderr\n                sys.stderr = cast(\"TextIO\", FileProxy(self.console, sys.stderr))",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "_disable_redirect_io",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 201,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._restore_stderr",
          "cast",
          "self._restore_stdout"
        ],
        "docstring": "Disable redirecting of stdout / stderr.",
        "code": "def _disable_redirect_io(self) -> None:\n        \"\"\"Disable redirecting of stdout / stderr.\"\"\"\n        if self._restore_stdout:\n            sys.stdout = cast(\"TextIO\", self._restore_stdout)\n            self._restore_stdout = None\n        if self._restore_stderr:\n            sys.stderr = cast(\"TextIO\", self._restore_stderr)\n            self._restore_stderr = None",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "renderable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 211,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "Screen",
          "live.get_renderable",
          "self.console._live_stack",
          "Group",
          "renderable",
          "self.get_renderable"
        ],
        "docstring": "Get the renderable that is being displayed\n\nReturns:\n    RenderableType: Displayed renderable.",
        "code": "def renderable(self) -> RenderableType:\n        \"\"\"Get the renderable that is being displayed\n\n        Returns:\n            RenderableType: Displayed renderable.\n        \"\"\"\n        live_stack = self.console._live_stack\n        renderable: RenderableType\n        if live_stack and self is live_stack[0]:\n            # The first Live instance will render everything in the Live stack\n            renderable = Group(*[live.get_renderable() for live in live_stack])\n        else:\n            renderable = self.get_renderable()\n        return Screen(renderable) if self._alt_screen else renderable",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 226,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "self.console.render_str",
          "str",
          "self.refresh",
          "renderable"
        ],
        "docstring": "Update the renderable that is being displayed\n\nArgs:\n    renderable (RenderableType): New renderable to use.\n    refresh (bool, optional): Refresh the display. Defaults to False.",
        "code": "def update(self, renderable: RenderableType, *, refresh: bool = False) -> None:\n        \"\"\"Update the renderable that is being displayed\n\n        Args:\n            renderable (RenderableType): New renderable to use.\n            refresh (bool, optional): Refresh the display. Defaults to False.\n        \"\"\"\n        if isinstance(renderable, str):\n            renderable = self.console.render_str(renderable)\n        with self._lock:\n            self._renderable = renderable\n            if refresh:\n                self.refresh()",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "refresh",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 240,
        "decorators": [],
        "is_async": false,
        "calls": [
          "display",
          "self._live_render.set_renderable",
          "Output",
          "self.renderable",
          "self.ipy_widget.clear_output",
          "warnings.warn",
          "unknown.refresh",
          "Control",
          "self.ipy_widget",
          "self._live_render.renderable",
          "self.console.print"
        ],
        "docstring": "Update the display of the Live Render.",
        "code": "def refresh(self) -> None:\n        \"\"\"Update the display of the Live Render.\"\"\"\n        with self._lock:\n            self._live_render.set_renderable(self.renderable)\n            if self._nested:\n                if self.console._live_stack:\n                    self.console._live_stack[0].refresh()\n                return\n\n            if self.console.is_jupyter:  # pragma: no cover\n                try:\n                    from IPython.display import display\n                    from ipywidgets import Output\n                except ImportError:\n                    import warnings\n\n                    warnings.warn('install \"ipywidgets\" for Jupyter support')\n                else:\n                    if self.ipy_widget is None:\n                        self.ipy_widget = Output()\n                        display(self.ipy_widget)\n\n                    with self.ipy_widget:\n                        self.ipy_widget.clear_output(wait=True)\n                        self.console.print(self._live_render.renderable)\n            elif self.console.is_terminal and not self.console.is_dumb_terminal:\n                with self.console:\n                    self.console.print(Control())\n            elif (\n                not self._started and not self.transient\n            ):  # if it is finished allow files or dumb-terminals to see final result\n                with self.console:\n                    self.console.print(Control())",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "process_renderables",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderables",
            "type": "List[ConsoleRenderable]"
          }
        ],
        "return_type": "List[ConsoleRenderable]",
        "lineno": 274,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Control.home",
          "self._live_render.position_cursor",
          "self.vertical_overflow"
        ],
        "docstring": "Process renderables to restore cursor and display progress.",
        "code": "def process_renderables(\n        self, renderables: List[ConsoleRenderable]\n    ) -> List[ConsoleRenderable]:\n        \"\"\"Process renderables to restore cursor and display progress.\"\"\"\n        self._live_render.vertical_overflow = self.vertical_overflow\n        if self.console.is_interactive:\n            # lock needs acquiring as user can modify live_render renderable at any time unlike in Progress.\n            with self._lock:\n                reset = (\n                    Control.home()\n                    if self._alt_screen\n                    else self._live_render.position_cursor()\n                )\n                renderables = [reset, *renderables, self._live_render]\n        elif (\n            not self._started and not self.transient\n        ):  # if it is finished render the final output for files or dumb_terminals\n            renderables = [*renderables, self._live_render]\n\n        return renderables",
        "line_count": 20,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "_RefreshThread",
        "methods": [
          "__init__",
          "stop",
          "run"
        ],
        "base_classes": [
          "Thread"
        ],
        "lineno": 22,
        "docstring": "A thread that calls refresh() at regular intervals."
      },
      {
        "name": "Live",
        "methods": [
          "__init__",
          "is_started",
          "get_renderable",
          "start",
          "stop",
          "__enter__",
          "__exit__",
          "_enable_redirect_io",
          "_disable_redirect_io",
          "renderable",
          "update",
          "refresh",
          "process_renderables"
        ],
        "base_classes": [
          "JupyterMixin",
          "RenderHook"
        ],
        "lineno": 41,
        "docstring": "Renders an auto-updating live display of any given renderable.\n\nArgs:\n    renderable (RenderableType, optional): The renderable to live display. Defaults to displaying nothing.\n    console (Console, optional): Optional Console instance. Defaults to an internal Console instance writing to stdout.\n    screen (bool, optional): Enable alternate screen mode. Defaults to False.\n    auto_refresh (bool, optional): Enable auto refresh. If disabled, you will need to call `refresh()` or `update()` with refresh flag. Defaults to True\n    refresh_per_second (float, optional): Number of times per second to refresh the live display. Defaults to 4.\n    transient (bool, optional): Clear the renderable on exit (has no effect when screen=True). Defaults to False.\n    redirect_stdout (bool, optional): Enable redirection of stdout, so ``print`` may be used. Defaults to True.\n    redirect_stderr (bool, optional): Enable redirection of stderr. Defaults to True.\n    vertical_overflow (VerticalOverflowMethod, optional): How to handle renderable when it is too tall for the console. Defaults to \"ellipsis\".\n    get_renderable (Callable[[], RenderableType], optional): Optional callable to get renderable. Defaults to None."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "threading",
        "name": "Event",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "threading",
        "name": "RLock",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "threading",
        "name": "Thread",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "IO",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TextIO",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "cast",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "get_console",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleRenderable",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Group",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderHook",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "control",
        "name": "Control",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "file_proxy",
        "name": "FileProxy",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "live_render",
        "name": "LiveRender",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "live_render",
        "name": "VerticalOverflowMethod",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "screen",
        "name": "Screen",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "typing_extensions",
        "name": "Self",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "random",
        "alias": null,
        "lineno": 297,
        "type": "import"
      },
      {
        "module": "time",
        "alias": null,
        "lineno": 298,
        "type": "import"
      },
      {
        "module": "itertools",
        "name": "cycle",
        "alias": null,
        "lineno": 299,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 300,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 300,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 300,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "Align",
        "alias": null,
        "lineno": 302,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 303,
        "type": "from_import"
      },
      {
        "module": "live",
        "name": "Live",
        "alias": "Live",
        "lineno": 304,
        "type": "from_import"
      },
      {
        "module": "panel",
        "name": "Panel",
        "alias": null,
        "lineno": 305,
        "type": "from_import"
      },
      {
        "module": "rule",
        "name": "Rule",
        "alias": null,
        "lineno": 306,
        "type": "from_import"
      },
      {
        "module": "syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 307,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 308,
        "type": "from_import"
      },
      {
        "module": "IPython.display",
        "name": "display",
        "alias": null,
        "lineno": 251,
        "type": "from_import"
      },
      {
        "module": "ipywidgets",
        "name": "Output",
        "alias": null,
        "lineno": 252,
        "type": "from_import"
      },
      {
        "module": "warnings",
        "alias": null,
        "lineno": 254,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "time.sleep",
      "exchange_rate_dict.keys",
      "next",
      "Panel",
      "Rule",
      "list",
      "cycle",
      "table.add_row",
      "console.log",
      "Live",
      "random.randint",
      "Syntax",
      "exchange_rate_dict.pop",
      "Text",
      "exchange_rate_dict.items",
      "Console",
      "Align.center",
      "len",
      "range",
      "random.random",
      "live_table.update",
      "table.add_column",
      "Table"
    ],
    "module_level_calls": {
      "function_calls": [
        "examples",
        "time.sleep",
        "exchange_rate_dict.keys",
        "next",
        "Panel",
        "Rule",
        "list",
        "cycle",
        "source",
        "table.add_row",
        "exchange_rate_dict",
        "console.log",
        "Live",
        "random.randint",
        "Syntax",
        "exchange_rate_dict.pop",
        "Text",
        "exchange_rate_dict.items",
        "table",
        "Console",
        "Align.center",
        "console",
        "len",
        "range",
        "dest",
        "exchanges",
        "progress_renderables",
        "random.random",
        "live_table.update",
        "table.add_column",
        "Table"
      ],
      "class_instantiations": [
        "Live",
        "Console",
        "Panel",
        "Rule",
        "Syntax",
        "Align",
        "Text",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "threading",
        "typing",
        "warnings",
        "random",
        "itertools",
        "sys",
        "time"
      ],
      "third_party": {
        "other": [
          "__future__",
          "types",
          "get_console",
          "console",
          "control",
          "file_proxy",
          "jupyter",
          "live_render",
          "screen",
          "text",
          "typing_extensions",
          "align",
          "live",
          "panel",
          "rule",
          "syntax",
          "table",
          "IPython",
          "ipywidgets"
        ]
      },
      "tech_stack": []
    },
    "line_count": 401
  },
  "rich/live_render.py": {
    "filepath": "../rich/rich/live_render.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "style",
            "type": "StyleType"
          },
          {
            "name": "vertical_overflow",
            "type": "VerticalOverflowMethod"
          }
        ],
        "return_type": "None",
        "lineno": 22,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "renderable",
          "vertical_overflow"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        renderable: RenderableType,\n        style: StyleType = \"\",\n        vertical_overflow: VerticalOverflowMethod = \"ellipsis\",\n    ) -> None:\n        self.renderable = renderable\n        self.style = style\n        self.vertical_overflow = vertical_overflow\n        self._shape: Optional[Tuple[int, int]] = None",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "set_renderable",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 33,
        "decorators": [],
        "is_async": false,
        "calls": [
          "renderable"
        ],
        "docstring": "Set a new renderable.\n\nArgs:\n    renderable (RenderableType): Any renderable object, including str.",
        "code": "def set_renderable(self, renderable: RenderableType) -> None:\n        \"\"\"Set a new renderable.\n\n        Args:\n            renderable (RenderableType): Any renderable object, including str.\n        \"\"\"\n        self.renderable = renderable",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "position_cursor",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Control",
        "lineno": 41,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ControlType.CARRIAGE_RETURN",
          "self._shape",
          "Control"
        ],
        "docstring": "Get control codes to move cursor to beginning of live render.\n\nReturns:\n    Control: A control instance that may be printed.",
        "code": "def position_cursor(self) -> Control:\n        \"\"\"Get control codes to move cursor to beginning of live render.\n\n        Returns:\n            Control: A control instance that may be printed.\n        \"\"\"\n        if self._shape is not None:\n            _, height = self._shape\n            return Control(\n                ControlType.CARRIAGE_RETURN,\n                (ControlType.ERASE_IN_LINE, 2),\n                *(\n                    (\n                        (ControlType.CURSOR_UP, 1),\n                        (ControlType.ERASE_IN_LINE, 2),\n                    )\n                    * (height - 1)\n                )\n            )\n        return Control()",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "restore_cursor",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Control",
        "lineno": 62,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ControlType.CARRIAGE_RETURN",
          "self._shape",
          "Control"
        ],
        "docstring": "Get control codes to clear the render and restore the cursor to its previous position.\n\nReturns:\n    Control: A Control instance that may be printed.",
        "code": "def restore_cursor(self) -> Control:\n        \"\"\"Get control codes to clear the render and restore the cursor to its previous position.\n\n        Returns:\n            Control: A Control instance that may be printed.\n        \"\"\"\n        if self._shape is not None:\n            _, height = self._shape\n            return Control(\n                ControlType.CARRIAGE_RETURN,\n                *((ControlType.CURSOR_UP, 1), (ControlType.ERASE_IN_LINE, 2)) * height\n            )\n        return Control()",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "Segment.line",
          "Segment.get_shape",
          "console.render_lines",
          "lines",
          "lines.append",
          "options",
          "style",
          "console.get_style",
          "self.renderable",
          "console.render",
          "list",
          "renderable",
          "shape",
          "loop_last",
          "Text",
          "overflow_text"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        renderable = self.renderable\n        style = console.get_style(self.style)\n        lines = console.render_lines(renderable, options, style=style, pad=False)\n        shape = Segment.get_shape(lines)\n\n        _, height = shape\n        if height > options.size.height:\n            if self.vertical_overflow == \"crop\":\n                lines = lines[: options.size.height]\n                shape = Segment.get_shape(lines)\n            elif self.vertical_overflow == \"ellipsis\":\n                lines = lines[: (options.size.height - 1)]\n                overflow_text = Text(\n                    \"...\",\n                    overflow=\"crop\",\n                    justify=\"center\",\n                    end=\"\",\n                    style=\"live.ellipsis\",\n                )\n                lines.append(list(console.render(overflow_text)))\n                shape = Segment.get_shape(lines)\n        self._shape = shape\n\n        new_line = Segment.line()\n        for last, line in loop_last(lines):\n            yield from line\n            if not last:\n                yield new_line",
        "line_count": 31,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "LiveRender",
        "methods": [
          "__init__",
          "set_renderable",
          "position_cursor",
          "restore_cursor",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 14,
        "docstring": "Creates a renderable that may be updated.\n\nArgs:\n    renderable (RenderableType): Any renderable object.\n    style (StyleType, optional): An optional style to apply to the renderable. Defaults to \"\"."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Literal",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "control",
        "name": "Control",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "ControlType",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "VerticalOverflowMethod",
        "assigned_to": null,
        "lineno": 11
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "_loop",
          "console",
          "control",
          "segment",
          "style",
          "text"
        ]
      },
      "tech_stack": []
    },
    "line_count": 107
  },
  "rich/logging.py": {
    "filepath": "../rich/rich/logging.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "level",
            "type": "Union[int, str]"
          },
          {
            "name": "console",
            "type": "Optional[Console]"
          }
        ],
        "return_type": "None",
        "lineno": 65,
        "decorators": [],
        "is_async": false,
        "calls": [
          "level",
          "markup",
          "locals_max_length",
          "keywords",
          "tracebacks_show_locals",
          "rich_tracebacks",
          "get_console",
          "tracebacks_suppress",
          "enable_link_path",
          "tracebacks_max_frames",
          "tracebacks_code_width",
          "LogRender",
          "omit_repeated_times",
          "log_time_format",
          "self.HIGHLIGHTER_CLASS",
          "super",
          "tracebacks_extra_lines",
          "tracebacks_theme",
          "show_time",
          "show_path",
          "show_level",
          "tracebacks_word_wrap",
          "locals_max_string",
          "unknown.__init__",
          "tracebacks_width"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        level: Union[int, str] = logging.NOTSET,\n        console: Optional[Console] = None,\n        *,\n        show_time: bool = True,\n        omit_repeated_times: bool = True,\n        show_level: bool = True,\n        show_path: bool = True,\n        enable_link_path: bool = True,\n        highlighter: Optional[Highlighter] = None,\n        markup: bool = False,\n        rich_tracebacks: bool = False,\n        tracebacks_width: Optional[int] = None,\n        tracebacks_code_width: Optional[int] = 88,\n        tracebacks_extra_lines: int = 3,\n        tracebacks_theme: Optional[str] = None,\n        tracebacks_word_wrap: bool = True,\n        tracebacks_show_locals: bool = False,\n        tracebacks_suppress: Iterable[Union[str, ModuleType]] = (),\n        tracebacks_max_frames: int = 100,\n        locals_max_length: int = 10,\n        locals_max_string: int = 80,\n        log_time_format: Union[str, FormatTimeCallable] = \"[%x %X]\",\n        keywords: Optional[List[str]] = None,\n    ) -> None:\n        super().__init__(level=level)\n        self.console = console or get_console()\n        self.highlighter = highlighter or self.HIGHLIGHTER_CLASS()\n        self._log_render = LogRender(\n            show_time=show_time,\n            show_level=show_level,\n            show_path=show_path,\n            time_format=log_time_format,\n            omit_repeated_times=omit_repeated_times,\n            level_width=None,\n        )\n        self.enable_link_path = enable_link_path\n        self.markup = markup\n        self.rich_tracebacks = rich_tracebacks\n        self.tracebacks_width = tracebacks_width\n        self.tracebacks_extra_lines = tracebacks_extra_lines\n        self.tracebacks_theme = tracebacks_theme\n        self.tracebacks_word_wrap = tracebacks_word_wrap\n        self.tracebacks_show_locals = tracebacks_show_locals\n        self.tracebacks_suppress = tracebacks_suppress\n        self.tracebacks_max_frames = tracebacks_max_frames\n        self.tracebacks_code_width = tracebacks_code_width\n        self.locals_max_length = locals_max_length\n        self.locals_max_string = locals_max_string\n        self.keywords = keywords",
        "line_count": 51,
        "needs_llm_summary": true
      },
      {
        "name": "get_level_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "record",
            "type": "LogRecord"
          }
        ],
        "return_type": "Text",
        "lineno": 117,
        "decorators": [],
        "is_async": false,
        "calls": [
          "level_name.lower",
          "level_name.ljust",
          "record.levelname",
          "Text.styled"
        ],
        "docstring": "Get the level name from the record.\n\nArgs:\n    record (LogRecord): LogRecord instance.\n\nReturns:\n    Text: A tuple of the style and level name.",
        "code": "def get_level_text(self, record: LogRecord) -> Text:\n        \"\"\"Get the level name from the record.\n\n        Args:\n            record (LogRecord): LogRecord instance.\n\n        Returns:\n            Text: A tuple of the style and level name.\n        \"\"\"\n        level_name = record.levelname\n        level_text = Text.styled(\n            level_name.ljust(8), f\"logging.level.{level_name.lower()}\"\n        )\n        return level_text",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "emit",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "record",
            "type": "LogRecord"
          }
        ],
        "return_type": "None",
        "lineno": 132,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.tracebacks_width",
          "self.tracebacks_max_frames",
          "self.render",
          "self.tracebacks_word_wrap",
          "self.locals_max_length",
          "self.handleError",
          "exc_value",
          "self.tracebacks_theme",
          "NullFile",
          "self.render_message",
          "self.formatter",
          "record.getMessage",
          "formatter.usesTime",
          "exc_type",
          "self.locals_max_string",
          "formatter.formatMessage",
          "message_renderable",
          "formatter.datefmt",
          "message",
          "hasattr",
          "self.tracebacks_suppress",
          "self.tracebacks_extra_lines",
          "log_renderable",
          "record",
          "self.console.print",
          "formatter.formatTime",
          "isinstance",
          "self.console.file",
          "traceback",
          "formatter",
          "exc_traceback",
          "self.tracebacks_show_locals",
          "self.tracebacks_code_width",
          "record.exc_info",
          "Traceback.from_exception",
          "self.format"
        ],
        "docstring": "Invoked by logging.",
        "code": "def emit(self, record: LogRecord) -> None:\n        \"\"\"Invoked by logging.\"\"\"\n        message = self.format(record)\n        traceback = None\n        if (\n            self.rich_tracebacks\n            and record.exc_info\n            and record.exc_info != (None, None, None)\n        ):\n            exc_type, exc_value, exc_traceback = record.exc_info\n            assert exc_type is not None\n            assert exc_value is not None\n            traceback = Traceback.from_exception(\n                exc_type,\n                exc_value,\n                exc_traceback,\n                width=self.tracebacks_width,\n                code_width=self.tracebacks_code_width,\n                extra_lines=self.tracebacks_extra_lines,\n                theme=self.tracebacks_theme,\n                word_wrap=self.tracebacks_word_wrap,\n                show_locals=self.tracebacks_show_locals,\n                locals_max_length=self.locals_max_length,\n                locals_max_string=self.locals_max_string,\n                suppress=self.tracebacks_suppress,\n                max_frames=self.tracebacks_max_frames,\n            )\n            message = record.getMessage()\n            if self.formatter:\n                record.message = record.getMessage()\n                formatter = self.formatter\n                if hasattr(formatter, \"usesTime\") and formatter.usesTime():\n                    record.asctime = formatter.formatTime(record, formatter.datefmt)\n                message = formatter.formatMessage(record)\n\n        message_renderable = self.render_message(record, message)\n        log_renderable = self.render(\n            record=record, traceback=traceback, message_renderable=message_renderable\n        )\n        if isinstance(self.console.file, NullFile):\n            # Handles pythonw, where stdout/stderr are null, and we return NullFile\n            # instance from Console.file. In this case, we still want to make a log record\n            # even though we won't be writing anything to a file.\n            self.handleError(record)\n        else:\n            try:\n                self.console.print(log_renderable)\n            except Exception:\n                self.handleError(record)",
        "line_count": 49,
        "needs_llm_summary": true
      },
      {
        "name": "render_message",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "record",
            "type": "LogRecord"
          },
          {
            "name": "message",
            "type": "str"
          }
        ],
        "return_type": "ConsoleRenderable",
        "lineno": 182,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.markup",
          "getattr",
          "highlighter",
          "message_text",
          "message",
          "Text.from_markup",
          "self.keywords",
          "self.highlighter",
          "message_text.highlight_words",
          "self.KEYWORDS",
          "record",
          "Text"
        ],
        "docstring": "Render message text in to Text.\n\nArgs:\n    record (LogRecord): logging Record.\n    message (str): String containing log message.\n\nReturns:\n    ConsoleRenderable: Renderable to display log message.",
        "code": "def render_message(self, record: LogRecord, message: str) -> \"ConsoleRenderable\":\n        \"\"\"Render message text in to Text.\n\n        Args:\n            record (LogRecord): logging Record.\n            message (str): String containing log message.\n\n        Returns:\n            ConsoleRenderable: Renderable to display log message.\n        \"\"\"\n        use_markup = getattr(record, \"markup\", self.markup)\n        message_text = Text.from_markup(message) if use_markup else Text(message)\n\n        highlighter = getattr(record, \"highlighter\", self.highlighter)\n        if highlighter:\n            message_text = highlighter(message_text)\n\n        if self.keywords is None:\n            self.keywords = self.KEYWORDS\n\n        if self.keywords:\n            message_text.highlight_words(self.keywords, \"logging.keyword\")\n\n        return message_text",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "ConsoleRenderable",
        "lineno": 207,
        "decorators": [],
        "is_async": false,
        "calls": [
          "level",
          "unknown.name",
          "record.created",
          "time_format",
          "self.get_level_text",
          "record.pathname",
          "self.console",
          "path",
          "self._log_render",
          "Path",
          "datetime.fromtimestamp",
          "record.lineno",
          "record",
          "log_time"
        ],
        "docstring": "Render log for display.\n\nArgs:\n    record (LogRecord): logging Record.\n    traceback (Optional[Traceback]): Traceback instance or None for no Traceback.\n    message_renderable (ConsoleRenderable): Renderable (typically Text) containing log message contents.\n\nReturns:\n    ConsoleRenderable: Renderable to display log.",
        "code": "def render(\n        self,\n        *,\n        record: LogRecord,\n        traceback: Optional[Traceback],\n        message_renderable: \"ConsoleRenderable\",\n    ) -> \"ConsoleRenderable\":\n        \"\"\"Render log for display.\n\n        Args:\n            record (LogRecord): logging Record.\n            traceback (Optional[Traceback]): Traceback instance or None for no Traceback.\n            message_renderable (ConsoleRenderable): Renderable (typically Text) containing log message contents.\n\n        Returns:\n            ConsoleRenderable: Renderable to display log.\n        \"\"\"\n        path = Path(record.pathname).name\n        level = self.get_level_text(record)\n        time_format = None if self.formatter is None else self.formatter.datefmt\n        log_time = datetime.fromtimestamp(record.created)\n\n        log_renderable = self._log_render(\n            self.console,\n            [message_renderable] if not traceback else [message_renderable, traceback],\n            log_time=log_time,\n            time_format=time_format,\n            level=level,\n            path=path,\n            line_no=record.lineno,\n            link_path=record.pathname if self.enable_link_path else None,\n        )\n        return log_renderable",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "divide",
        "args": [],
        "return_type": "None",
        "lineno": 283,
        "decorators": [],
        "is_async": false,
        "calls": [
          "log.debug",
          "log.exception"
        ],
        "docstring": null,
        "code": "def divide() -> None:\n        number = 1\n        divisor = 0\n        foos = [\"foo\"] * 100\n        log.debug(\"in divide\")\n        try:\n            number / divisor\n        except:\n            log.exception(\"An error of some kind occurred!\")",
        "line_count": 9,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "RichHandler",
        "methods": [
          "__init__",
          "get_level_text",
          "emit",
          "render_message",
          "render"
        ],
        "base_classes": [
          "Handler"
        ],
        "lineno": 18,
        "docstring": "A logging handler that renders output with Rich. The time / level / message and file are displayed in columns.\nThe level is color coded, and the message is syntax highlighted.\n\nNote:\n    Be careful when enabling console markup in log messages if you have configured logging for libraries not\n    under your control. If a dependency writes messages containing square brackets, it may not produce the intended output.\n\nArgs:\n    level (Union[int, str], optional): Log level. Defaults to logging.NOTSET.\n    console (:class:`~rich.console.Console`, optional): Optional console instance to write logs.\n        Default will use a global console instance writing to stdout.\n    show_time (bool, optional): Show a column for the time. Defaults to True.\n    omit_repeated_times (bool, optional): Omit repetition of the same time. Defaults to True.\n    show_level (bool, optional): Show a column for the level. Defaults to True.\n    show_path (bool, optional): Show the path to the original log call. Defaults to True.\n    enable_link_path (bool, optional): Enable terminal link of path column to file. Defaults to True.\n    highlighter (Highlighter, optional): Highlighter to style log messages, or None to use ReprHighlighter. Defaults to None.\n    markup (bool, optional): Enable console markup in log messages. Defaults to False.\n    rich_tracebacks (bool, optional): Enable rich tracebacks with syntax highlighting and formatting. Defaults to False.\n    tracebacks_width (Optional[int], optional): Number of characters used to render tracebacks, or None for full width. Defaults to None.\n    tracebacks_code_width (int, optional): Number of code characters used to render tracebacks, or None for full width. Defaults to 88.\n    tracebacks_extra_lines (int, optional): Additional lines of code to render tracebacks, or None for full width. Defaults to None.\n    tracebacks_theme (str, optional): Override pygments theme used in traceback.\n    tracebacks_word_wrap (bool, optional): Enable word wrapping of long tracebacks lines. Defaults to True.\n    tracebacks_show_locals (bool, optional): Enable display of locals in tracebacks. Defaults to False.\n    tracebacks_suppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n    tracebacks_max_frames (int, optional): Optional maximum number of frames returned by traceback.\n    locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to 10.\n    locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n    log_time_format (Union[str, TimeFormatterCallable], optional): If ``log_time`` is enabled, either string for strftime or callable that formats the time. Defaults to \"[%x %X] \".\n    keywords (List[str], optional): List of words to highlight instead of ``RichHandler.KEYWORDS``."
      }
    ],
    "imports": [
      {
        "module": "logging",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "datetime",
        "name": "datetime",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "logging",
        "name": "Handler",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "logging",
        "name": "LogRecord",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "pathlib",
        "name": "Path",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "ModuleType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "ClassVar",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "rich._null_file",
        "name": "NullFile",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "get_console",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "_log_render",
        "name": "FormatTimeCallable",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "_log_render",
        "name": "LogRender",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleRenderable",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "Highlighter",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "traceback",
        "name": "Traceback",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 243,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "RichHandler",
      "logging.basicConfig",
      "logging.getLogger",
      "log.exception",
      "log.error",
      "log.debug",
      "dict",
      "log.info",
      "log.critical",
      "log.warning",
      "sleep",
      "divide"
    ],
    "module_level_calls": {
      "function_calls": [
        "RichHandler",
        "FORMAT",
        "logging.basicConfig",
        "logging.getLogger",
        "log.exception",
        "log.error",
        "log.debug",
        "dict",
        "log.info",
        "log.critical",
        "log.warning",
        "sleep",
        "divide"
      ],
      "class_instantiations": [
        "RichHandler"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "datetime",
        "typing",
        "logging",
        "pathlib",
        "time"
      ],
      "third_party": {
        "other": [
          "types",
          "rich",
          "get_console",
          "_log_render",
          "console",
          "highlighter",
          "text",
          "traceback"
        ]
      },
      "tech_stack": []
    },
    "line_count": 298
  },
  "rich/markdown.py": {
    "filepath": "../rich/rich/markdown.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "create",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "markdown",
            "type": "Markdown"
          },
          {
            "name": "token",
            "type": "Token"
          }
        ],
        "return_type": "MarkdownElement",
        "lineno": 29,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cls"
        ],
        "docstring": "Factory to create markdown element,\n\nArgs:\n    markdown (Markdown): The parent Markdown object.\n    token (Token): A node from markdown-it.\n\nReturns:\n    MarkdownElement: A new markdown element",
        "code": "def create(cls, markdown: Markdown, token: Token) -> MarkdownElement:\n        \"\"\"Factory to create markdown element,\n\n        Args:\n            markdown (Markdown): The parent Markdown object.\n            token (Token): A node from markdown-it.\n\n        Returns:\n            MarkdownElement: A new markdown element\n        \"\"\"\n        return cls()",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "on_enter",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          }
        ],
        "return_type": "None",
        "lineno": 41,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Called when the node is entered.\n\nArgs:\n    context (MarkdownContext): The markdown context.",
        "code": "def on_enter(self, context: MarkdownContext) -> None:\n        \"\"\"Called when the node is entered.\n\n        Args:\n            context (MarkdownContext): The markdown context.\n        \"\"\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "on_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "text",
            "type": "TextType"
          }
        ],
        "return_type": "None",
        "lineno": 48,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Called when text is parsed.\n\nArgs:\n    context (MarkdownContext): The markdown context.",
        "code": "def on_text(self, context: MarkdownContext, text: TextType) -> None:\n        \"\"\"Called when text is parsed.\n\n        Args:\n            context (MarkdownContext): The markdown context.\n        \"\"\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "on_leave",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          }
        ],
        "return_type": "None",
        "lineno": 55,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Called when the parser leaves the element.\n\nArgs:\n    context (MarkdownContext): [description]",
        "code": "def on_leave(self, context: MarkdownContext) -> None:\n        \"\"\"Called when the parser leaves the element.\n\n        Args:\n            context (MarkdownContext): [description]\n        \"\"\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "on_child_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "child",
            "type": "MarkdownElement"
          }
        ],
        "return_type": "bool",
        "lineno": 62,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Called when a child element is closed.\n\nThis method allows a parent element to take over rendering of its children.\n\nArgs:\n    context (MarkdownContext): The markdown context.\n    child (MarkdownElement): The child markdown element.\n\nReturns:\n    bool: Return True to render the element, or False to not render the element.",
        "code": "def on_child_close(self, context: MarkdownContext, child: MarkdownElement) -> bool:\n        \"\"\"Called when a child element is closed.\n\n        This method allows a parent element to take over rendering of its children.\n\n        Args:\n            context (MarkdownContext): The markdown context.\n            child (MarkdownElement): The child markdown element.\n\n        Returns:\n            bool: Return True to render the element, or False to not render the element.\n        \"\"\"\n        return True",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        return ()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "on_enter",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          }
        ],
        "return_type": "None",
        "lineno": 96,
        "decorators": [],
        "is_async": false,
        "calls": [
          "context.enter_style",
          "self.style_name",
          "Text"
        ],
        "docstring": null,
        "code": "def on_enter(self, context: MarkdownContext) -> None:\n        self.style = context.enter_style(self.style_name)\n        self.text = Text(justify=\"left\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "on_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "text",
            "type": "TextType"
          }
        ],
        "return_type": "None",
        "lineno": 100,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "self.text.append",
          "str",
          "text"
        ],
        "docstring": null,
        "code": "def on_text(self, context: MarkdownContext, text: TextType) -> None:\n        self.text.append(text, context.current_style if isinstance(text, str) else None)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "on_leave",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          }
        ],
        "return_type": "None",
        "lineno": 103,
        "decorators": [],
        "is_async": false,
        "calls": [
          "context.leave_style"
        ],
        "docstring": null,
        "code": "def on_leave(self, context: MarkdownContext) -> None:\n        context.leave_style()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "create",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "markdown",
            "type": "Markdown"
          },
          {
            "name": "token",
            "type": "Token"
          }
        ],
        "return_type": "Paragraph",
        "lineno": 114,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cls"
        ],
        "docstring": null,
        "code": "def create(cls, markdown: Markdown, token: Token) -> Paragraph:\n        return cls(justify=markdown.justify or \"left\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "justify",
            "type": "JustifyMethod"
          }
        ],
        "return_type": "None",
        "lineno": 117,
        "decorators": [],
        "is_async": false,
        "calls": [
          "justify"
        ],
        "docstring": null,
        "code": "def __init__(self, justify: JustifyMethod) -> None:\n        self.justify = justify",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 120,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.justify"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        self.text.justify = self.justify\n        yield self.text",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "create",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "markdown",
            "type": "Markdown"
          },
          {
            "name": "token",
            "type": "Token"
          }
        ],
        "return_type": "Heading",
        "lineno": 131,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "token.tag",
          "cls"
        ],
        "docstring": null,
        "code": "def create(cls, markdown: Markdown, token: Token) -> Heading:\n        return cls(token.tag)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "on_enter",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          }
        ],
        "return_type": "None",
        "lineno": 134,
        "decorators": [],
        "is_async": false,
        "calls": [
          "context.enter_style",
          "self.style_name",
          "Text"
        ],
        "docstring": null,
        "code": "def on_enter(self, context: MarkdownContext) -> None:\n        self.text = Text()\n        context.enter_style(self.style_name)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "tag",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 138,
        "decorators": [],
        "is_async": false,
        "calls": [
          "tag",
          "unknown.__init__",
          "super"
        ],
        "docstring": null,
        "code": "def __init__(self, tag: str) -> None:\n        self.tag = tag\n        self.style_name = f\"markdown.{tag}\"\n        super().__init__()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 143,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.text",
          "Panel",
          "text",
          "box.HEAVY",
          "Text"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        text = self.text\n        text.justify = \"center\"\n        if self.tag == \"h1\":\n            # Draw a border around h1s\n            yield Panel(\n                text,\n                box=box.HEAVY,\n                style=\"markdown.h1.border\",\n            )\n        else:\n            # Styled text for h2 and beyond\n            if self.tag == \"h2\":\n                yield Text(\"\")\n            yield text",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "create",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "markdown",
            "type": "Markdown"
          },
          {
            "name": "token",
            "type": "Token"
          }
        ],
        "return_type": "CodeBlock",
        "lineno": 168,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "markdown.code_theme",
          "node_info.partition",
          "cls"
        ],
        "docstring": null,
        "code": "def create(cls, markdown: Markdown, token: Token) -> CodeBlock:\n        node_info = token.info or \"\"\n        lexer_name = node_info.partition(\" \")[0]\n        return cls(lexer_name or \"text\", markdown.code_theme)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lexer_name",
            "type": "str"
          },
          {
            "name": "theme",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 173,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lexer_name",
          "theme"
        ],
        "docstring": null,
        "code": "def __init__(self, lexer_name: str, theme: str) -> None:\n        self.lexer_name = lexer_name\n        self.theme = theme",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 177,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.text",
          "str",
          "self.lexer_name",
          "code",
          "Syntax",
          "unknown.rstrip",
          "self.theme"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        code = str(self.text).rstrip()\n        syntax = Syntax(\n            code, self.lexer_name, theme=self.theme, word_wrap=True, padding=1\n        )\n        yield syntax",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 192,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Renderables"
        ],
        "docstring": null,
        "code": "def __init__(self) -> None:\n        self.elements: Renderables = Renderables()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "on_child_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "child",
            "type": "MarkdownElement"
          }
        ],
        "return_type": "bool",
        "lineno": 195,
        "decorators": [],
        "is_async": false,
        "calls": [
          "child",
          "self.elements.append"
        ],
        "docstring": null,
        "code": "def on_child_close(self, context: MarkdownContext, child: MarkdownElement) -> bool:\n        self.elements.append(child)\n        return False",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 199,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "console.render_lines",
          "style",
          "self.elements",
          "Segment",
          "options.update",
          "render_options"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        render_options = options.update(width=options.max_width - 4)\n        lines = console.render_lines(self.elements, render_options, style=self.style)\n        style = self.style\n        new_line = Segment(\"\\n\")\n        padding = Segment(\"\u258c \", style)\n        for line in lines:\n            yield padding\n            yield from line\n            yield new_line",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 218,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "Rule",
          "console.get_style"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        style = console.get_style(\"markdown.hr\", default=\"none\")\n        yield Rule(style=style)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 228,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self) -> None:\n        self.header: TableHeaderElement | None = None\n        self.body: TableBodyElement | None = None",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "on_child_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "child",
            "type": "MarkdownElement"
          }
        ],
        "return_type": "bool",
        "lineno": 232,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "child",
          "TableBodyElement",
          "RuntimeError",
          "TableHeaderElement"
        ],
        "docstring": null,
        "code": "def on_child_close(self, context: MarkdownContext, child: MarkdownElement) -> bool:\n        if isinstance(child, TableHeaderElement):\n            self.header = child\n        elif isinstance(child, TableBodyElement):\n            self.body = child\n        else:\n            raise RuntimeError(\"Couldn't process markdown table.\")\n        return False",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 241,
        "decorators": [],
        "is_async": false,
        "calls": [
          "box.SIMPLE_HEAVY",
          "column.content",
          "table.add_column",
          "table.add_row",
          "Table"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        table = Table(box=box.SIMPLE_HEAVY)\n\n        if self.header is not None and self.header.row is not None:\n            for column in self.header.row.cells:\n                table.add_column(column.content)\n\n        if self.body is not None:\n            for row in self.body.rows:\n                row_content = [element.content for element in row.cells]\n                table.add_row(*row_content)\n\n        yield table",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 261,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self) -> None:\n        self.row: TableRowElement | None = None",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "on_child_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "child",
            "type": "MarkdownElement"
          }
        ],
        "return_type": "bool",
        "lineno": 264,
        "decorators": [],
        "is_async": false,
        "calls": [
          "child",
          "isinstance",
          "TableRowElement"
        ],
        "docstring": null,
        "code": "def on_child_close(self, context: MarkdownContext, child: MarkdownElement) -> bool:\n        assert isinstance(child, TableRowElement)\n        self.row = child\n        return False",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 273,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self) -> None:\n        self.rows: list[TableRowElement] = []",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "on_child_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "child",
            "type": "MarkdownElement"
          }
        ],
        "return_type": "bool",
        "lineno": 276,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "child",
          "TableRowElement",
          "self.rows.append"
        ],
        "docstring": null,
        "code": "def on_child_close(self, context: MarkdownContext, child: MarkdownElement) -> bool:\n        assert isinstance(child, TableRowElement)\n        self.rows.append(child)\n        return False",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 285,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self) -> None:\n        self.cells: list[TableDataElement] = []",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "on_child_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "child",
            "type": "MarkdownElement"
          }
        ],
        "return_type": "bool",
        "lineno": 288,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "child",
          "self.cells.append",
          "TableDataElement"
        ],
        "docstring": null,
        "code": "def on_child_close(self, context: MarkdownContext, child: MarkdownElement) -> bool:\n        assert isinstance(child, TableDataElement)\n        self.cells.append(child)\n        return False",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "create",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "markdown",
            "type": "Markdown"
          },
          {
            "name": "token",
            "type": "Token"
          }
        ],
        "return_type": "MarkdownElement",
        "lineno": 299,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "token.attrs.get",
          "str",
          "JustifyMethod",
          "justify",
          "cls",
          "get_args"
        ],
        "docstring": null,
        "code": "def create(cls, markdown: Markdown, token: Token) -> MarkdownElement:\n        style = str(token.attrs.get(\"style\")) or \"\"\n\n        justify: JustifyMethod\n        if \"text-align:right\" in style:\n            justify = \"right\"\n        elif \"text-align:center\" in style:\n            justify = \"center\"\n        elif \"text-align:left\" in style:\n            justify = \"left\"\n        else:\n            justify = \"default\"\n\n        assert justify in get_args(JustifyMethod)\n        return cls(justify=justify)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "justify",
            "type": "JustifyMethod"
          }
        ],
        "return_type": "None",
        "lineno": 315,
        "decorators": [],
        "is_async": false,
        "calls": [
          "justify",
          "Text"
        ],
        "docstring": null,
        "code": "def __init__(self, justify: JustifyMethod) -> None:\n        self.content: Text = Text(\"\", justify=justify)\n        self.justify = justify",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "on_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "text",
            "type": "TextType"
          }
        ],
        "return_type": "None",
        "lineno": 319,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "text.stylize",
          "context.current_style",
          "self.content.append_text",
          "str",
          "text",
          "Text"
        ],
        "docstring": null,
        "code": "def on_text(self, context: MarkdownContext, text: TextType) -> None:\n        text = Text(text) if isinstance(text, str) else text\n        text.stylize(context.current_style)\n        self.content.append_text(text)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "create",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "markdown",
            "type": "Markdown"
          },
          {
            "name": "token",
            "type": "Token"
          }
        ],
        "return_type": "ListElement",
        "lineno": 329,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "token.type",
          "int",
          "cls",
          "token.attrs.get"
        ],
        "docstring": null,
        "code": "def create(cls, markdown: Markdown, token: Token) -> ListElement:\n        return cls(token.type, int(token.attrs.get(\"start\", 1)))",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "list_type",
            "type": "str"
          },
          {
            "name": "list_start",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 332,
        "decorators": [],
        "is_async": false,
        "calls": [
          "list_type",
          "list_start"
        ],
        "docstring": null,
        "code": "def __init__(self, list_type: str, list_start: int | None) -> None:\n        self.items: list[ListItem] = []\n        self.list_type = list_type\n        self.list_start = list_start",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "on_child_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "child",
            "type": "MarkdownElement"
          }
        ],
        "return_type": "bool",
        "lineno": 337,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "child",
          "self.items.append",
          "ListItem"
        ],
        "docstring": null,
        "code": "def on_child_close(self, context: MarkdownContext, child: MarkdownElement) -> bool:\n        assert isinstance(child, ListItem)\n        self.items.append(child)\n        return False",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 342,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.items",
          "item.render_bullet",
          "enumerate",
          "item.render_number",
          "options",
          "last_number",
          "console",
          "len"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        if self.list_type == \"bullet_list_open\":\n            for item in self.items:\n                yield from item.render_bullet(console, options)\n        else:\n            number = 1 if self.list_start is None else self.list_start\n            last_number = number + len(self.items)\n            for index, item in enumerate(self.items):\n                yield from item.render_number(\n                    console, options, number + index, last_number\n                )",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 362,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Renderables"
        ],
        "docstring": null,
        "code": "def __init__(self) -> None:\n        self.elements: Renderables = Renderables()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "on_child_close",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          },
          {
            "name": "child",
            "type": "MarkdownElement"
          }
        ],
        "return_type": "bool",
        "lineno": 365,
        "decorators": [],
        "is_async": false,
        "calls": [
          "child",
          "self.elements.append"
        ],
        "docstring": null,
        "code": "def on_child_close(self, context: MarkdownContext, child: MarkdownElement) -> bool:\n        self.elements.append(child)\n        return False",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "render_bullet",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 369,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "lines",
          "console.render_lines",
          "bullet_style",
          "self.elements",
          "console.get_style",
          "loop_first",
          "Segment",
          "options.update",
          "render_options"
        ],
        "docstring": null,
        "code": "def render_bullet(self, console: Console, options: ConsoleOptions) -> RenderResult:\n        render_options = options.update(width=options.max_width - 3)\n        lines = console.render_lines(self.elements, render_options, style=self.style)\n        bullet_style = console.get_style(\"markdown.item.bullet\", default=\"none\")\n\n        bullet = Segment(\" \u2022 \", bullet_style)\n        padding = Segment(\" \" * 3, bullet_style)\n        new_line = Segment(\"\\n\")\n        for first, line in loop_first(lines):\n            yield bullet if first else padding\n            yield from line\n            yield new_line",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "render_number",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          },
          {
            "name": "number",
            "type": "int"
          },
          {
            "name": "last_number",
            "type": "int"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 382,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "lines",
          "console.render_lines",
          "str",
          "number_style",
          "self.elements",
          "console.get_style",
          "loop_first",
          "last_number",
          "Segment",
          "options.update",
          "unknown.rjust",
          "render_options",
          "len"
        ],
        "docstring": null,
        "code": "def render_number(\n        self, console: Console, options: ConsoleOptions, number: int, last_number: int\n    ) -> RenderResult:\n        number_width = len(str(last_number)) + 2\n        render_options = options.update(width=options.max_width - number_width)\n        lines = console.render_lines(self.elements, render_options, style=self.style)\n        number_style = console.get_style(\"markdown.item.number\", default=\"none\")\n\n        new_line = Segment(\"\\n\")\n        padding = Segment(\" \" * number_width, number_style)\n        numeral = Segment(f\"{number}\".rjust(number_width - 1) + \" \", number_style)\n        for first, line in loop_first(lines):\n            yield numeral if first else padding\n            yield from line\n            yield new_line",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "create",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "markdown",
            "type": "Markdown"
          },
          {
            "name": "token",
            "type": "Token"
          }
        ],
        "return_type": "MarkdownElement",
        "lineno": 401,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "token.attrs.get",
          "str",
          "url",
          "cls",
          "token.content"
        ],
        "docstring": null,
        "code": "def create(cls, markdown: Markdown, token: Token) -> MarkdownElement:\n        url = token.attrs.get(\"href\", \"#\")\n        return cls(token.content, str(url))",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "href",
            "type": "str"
          }
        ],
        "return_type": null,
        "lineno": 405,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text",
          "href",
          "Text"
        ],
        "docstring": null,
        "code": "def __init__(self, text: str, href: str):\n        self.text = Text(text)\n        self.href = href",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "create",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "markdown",
            "type": "Markdown"
          },
          {
            "name": "token",
            "type": "Token"
          }
        ],
        "return_type": "MarkdownElement",
        "lineno": 416,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "markdown.hyperlinks",
          "token.attrs.get",
          "str",
          "cls"
        ],
        "docstring": "Factory to create markdown element,\n\nArgs:\n    markdown (Markdown): The parent Markdown object.\n    token (Any): A token from markdown-it.\n\nReturns:\n    MarkdownElement: A new markdown element",
        "code": "def create(cls, markdown: Markdown, token: Token) -> MarkdownElement:\n        \"\"\"Factory to create markdown element,\n\n        Args:\n            markdown (Markdown): The parent Markdown object.\n            token (Any): A token from markdown-it.\n\n        Returns:\n            MarkdownElement: A new markdown element\n        \"\"\"\n        return cls(str(token.attrs.get(\"src\", \"\")), markdown.hyperlinks)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "destination",
            "type": "str"
          },
          {
            "name": "hyperlinks",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 428,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.__init__",
          "destination",
          "hyperlinks",
          "super"
        ],
        "docstring": null,
        "code": "def __init__(self, destination: str, hyperlinks: bool) -> None:\n        self.destination = destination\n        self.hyperlinks = hyperlinks\n        self.link: str | None = None\n        super().__init__()",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "on_enter",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "context",
            "type": "MarkdownContext"
          }
        ],
        "return_type": "None",
        "lineno": 434,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "context",
          "unknown.on_enter",
          "context.current_style.link",
          "Text"
        ],
        "docstring": null,
        "code": "def on_enter(self, context: MarkdownContext) -> None:\n        self.link = context.current_style.link\n        self.text = Text(justify=\"left\")\n        super().on_enter(context)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 439,
        "decorators": [],
        "is_async": false,
        "calls": [
          "link_style",
          "title.stylize",
          "title",
          "unknown.rsplit",
          "Text.assemble",
          "self.destination.strip",
          "Style",
          "Text"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        link_style = Style(link=self.link or self.destination or None)\n        title = self.text or Text(self.destination.strip(\"/\").rsplit(\"/\", 1)[-1])\n        if self.hyperlinks:\n            title.stylize(link_style)\n        text = Text.assemble(\"\ud83c\udf06 \", title, \" \", end=\"\")\n        yield text",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          },
          {
            "name": "style",
            "type": "Style"
          },
          {
            "name": "inline_code_lexer",
            "type": "Any"
          },
          {
            "name": "inline_code_theme",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 453,
        "decorators": [],
        "is_async": false,
        "calls": [
          "StyleStack",
          "Stack",
          "options",
          "style",
          "inline_code_theme",
          "inline_code_lexer",
          "Syntax",
          "console"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        console: Console,\n        options: ConsoleOptions,\n        style: Style,\n        inline_code_lexer: str | None = None,\n        inline_code_theme: str = \"monokai\",\n    ) -> None:\n        self.console = console\n        self.options = options\n        self.style_stack: StyleStack = StyleStack(style)\n        self.stack: Stack[MarkdownElement] = Stack()\n\n        self._syntax: Syntax | None = None\n        if inline_code_lexer is not None:\n            self._syntax = Syntax(\"\", inline_code_lexer, theme=inline_code_theme)",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "current_style",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 471,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Current style which is the product of all styles on the stack.",
        "code": "def current_style(self) -> Style:\n        \"\"\"Current style which is the product of all styles on the stack.\"\"\"\n        return self.style_stack.current",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "on_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "node_type",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 475,
        "decorators": [],
        "is_async": false,
        "calls": [
          "highlight_text.rstrip",
          "highlight_text",
          "self.stack.top.on_text",
          "self.style_stack.current",
          "text",
          "self._syntax.highlight",
          "Text.assemble",
          "self"
        ],
        "docstring": "Called when the parser visits text.",
        "code": "def on_text(self, text: str, node_type: str) -> None:\n        \"\"\"Called when the parser visits text.\"\"\"\n        if node_type in {\"fence\", \"code_inline\"} and self._syntax is not None:\n            highlight_text = self._syntax.highlight(text)\n            highlight_text.rstrip()\n            self.stack.top.on_text(\n                self, Text.assemble(highlight_text, style=self.style_stack.current)\n            )\n        else:\n            self.stack.top.on_text(self, text)",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "enter_style",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "style_name",
            "type": "Any"
          }
        ],
        "return_type": "Style",
        "lineno": 486,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "self.style_stack.push",
          "style_name",
          "self.console.get_style"
        ],
        "docstring": "Enter a style context.",
        "code": "def enter_style(self, style_name: str | Style) -> Style:\n        \"\"\"Enter a style context.\"\"\"\n        style = self.console.get_style(style_name, default=\"none\")\n        self.style_stack.push(style)\n        return self.current_style",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "leave_style",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 492,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style_stack.pop"
        ],
        "docstring": "Leave a style context.",
        "code": "def leave_style(self) -> Style:\n        \"\"\"Leave a style context.\"\"\"\n        style = self.style_stack.pop()\n        return style",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "markup",
            "type": "str"
          },
          {
            "name": "code_theme",
            "type": "str"
          },
          {
            "name": "justify",
            "type": "Any"
          },
          {
            "name": "style",
            "type": "Any"
          },
          {
            "name": "hyperlinks",
            "type": "bool"
          },
          {
            "name": "inline_code_lexer",
            "type": "Any"
          },
          {
            "name": "inline_code_theme",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 534,
        "decorators": [],
        "is_async": false,
        "calls": [
          "markup",
          "code_theme",
          "style",
          "unknown.enable",
          "inline_code_lexer",
          "MarkdownIt",
          "parser.parse",
          "hyperlinks"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        markup: str,\n        code_theme: str = \"monokai\",\n        justify: JustifyMethod | None = None,\n        style: str | Style = \"none\",\n        hyperlinks: bool = True,\n        inline_code_lexer: str | None = None,\n        inline_code_theme: str | None = None,\n    ) -> None:\n        parser = MarkdownIt().enable(\"strikethrough\").enable(\"table\")\n        self.markup = markup\n        self.parsed = parser.parse(markup)\n        self.code_theme = code_theme\n        self.justify: JustifyMethod | None = justify\n        self.style = style\n        self.hyperlinks = hyperlinks\n        self.inline_code_lexer = inline_code_lexer\n        self.inline_code_theme = inline_code_theme or code_theme",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "_flatten_tokens",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "tokens",
            "type": "Iterable[Token]"
          }
        ],
        "return_type": "Iterable[Token]",
        "lineno": 554,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._flatten_tokens",
          "token.children"
        ],
        "docstring": "Flattens the token stream.",
        "code": "def _flatten_tokens(self, tokens: Iterable[Token]) -> Iterable[Token]:\n        \"\"\"Flattens the token stream.\"\"\"\n        for token in tokens:\n            is_fence = token.type == \"fence\"\n            is_image = token.tag == \"img\"\n            if token.children and not (is_image or is_fence):\n                yield from self._flatten_tokens(token.children)\n            else:\n                yield token",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 564,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "link_style",
          "token",
          "element.on_leave",
          "style",
          "self.inlines",
          "self.elements.get",
          "token.type",
          "console.render",
          "href",
          "self.inline_code_lexer",
          "context.stack.top.on_child_close",
          "options.update",
          "Style",
          "element.new_line",
          "self.style",
          "self.inline_code_theme",
          "context",
          "console.get_style",
          "element.href",
          "element.on_text",
          "token.tag",
          "token.attrs.get",
          "context.on_text",
          "str",
          "Link",
          "options",
          "element",
          "context.stack.push",
          "context.options",
          "context.stack.pop",
          "text",
          "self.parsed",
          "token.content",
          "node_type",
          "console",
          "tokens",
          "Link.create",
          "isinstance",
          "link_url_style",
          "self._flatten_tokens",
          "element.text.plain",
          "element_class.create",
          "MarkdownContext",
          "context.enter_style",
          "element.on_enter",
          "context.leave_style",
          "self"
        ],
        "docstring": "Render markdown to the console.",
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        \"\"\"Render markdown to the console.\"\"\"\n        style = console.get_style(self.style, default=\"none\")\n        options = options.update(height=None)\n        context = MarkdownContext(\n            console,\n            options,\n            style,\n            inline_code_lexer=self.inline_code_lexer,\n            inline_code_theme=self.inline_code_theme,\n        )\n        tokens = self.parsed\n        inline_style_tags = self.inlines\n        new_line = False\n        _new_line_segment = Segment.line()\n\n        for token in self._flatten_tokens(tokens):\n            node_type = token.type\n            tag = token.tag\n\n            entering = token.nesting == 1\n            exiting = token.nesting == -1\n            self_closing = token.nesting == 0\n\n            if node_type == \"text\":\n                context.on_text(token.content, node_type)\n            elif node_type == \"hardbreak\":\n                context.on_text(\"\\n\", node_type)\n            elif node_type == \"softbreak\":\n                context.on_text(\" \", node_type)\n            elif node_type == \"link_open\":\n                href = str(token.attrs.get(\"href\", \"\"))\n                if self.hyperlinks:\n                    link_style = console.get_style(\"markdown.link_url\", default=\"none\")\n                    link_style += Style(link=href)\n                    context.enter_style(link_style)\n                else:\n                    context.stack.push(Link.create(self, token))\n            elif node_type == \"link_close\":\n                if self.hyperlinks:\n                    context.leave_style()\n                else:\n                    element = context.stack.pop()\n                    assert isinstance(element, Link)\n                    link_style = console.get_style(\"markdown.link\", default=\"none\")\n                    context.enter_style(link_style)\n                    context.on_text(element.text.plain, node_type)\n                    context.leave_style()\n                    context.on_text(\" (\", node_type)\n                    link_url_style = console.get_style(\n                        \"markdown.link_url\", default=\"none\"\n                    )\n                    context.enter_style(link_url_style)\n                    context.on_text(element.href, node_type)\n                    context.leave_style()\n                    context.on_text(\")\", node_type)\n            elif (\n                tag in inline_style_tags\n                and node_type != \"fence\"\n                and node_type != \"code_block\"\n            ):\n                if entering:\n                    # If it's an opening inline token e.g. strong, em, etc.\n                    # Then we move into a style context i.e. push to stack.\n                    context.enter_style(f\"markdown.{tag}\")\n                elif exiting:\n                    # If it's a closing inline style, then we pop the style\n                    # off of the stack, to move out of the context of it...\n                    context.leave_style()\n                else:\n                    # If it's a self-closing inline style e.g. `code_inline`\n                    context.enter_style(f\"markdown.{tag}\")\n                    if token.content:\n                        context.on_text(token.content, node_type)\n                    context.leave_style()\n            else:\n                # Map the markdown tag -> MarkdownElement renderable\n                element_class = self.elements.get(token.type) or UnknownElement\n                element = element_class.create(self, token)\n\n                if entering or self_closing:\n                    context.stack.push(element)\n                    element.on_enter(context)\n\n                if exiting:  # CLOSING tag\n                    element = context.stack.pop()\n\n                    should_render = not context.stack or (\n                        context.stack\n                        and context.stack.top.on_child_close(context, element)\n                    )\n\n                    if should_render:\n                        if new_line:\n                            yield _new_line_segment\n\n                        yield from console.render(element, context.options)\n                elif self_closing:  # SELF-CLOSING tags (e.g. text, code, image)\n                    context.stack.pop()\n                    text = token.content\n                    if text is not None:\n                        element.on_text(context, text)\n\n                    should_render = (\n                        not context.stack\n                        or context.stack\n                        and context.stack.top.on_child_close(context, element)\n                    )\n                    if should_render:\n                        if new_line and node_type != \"inline\":\n                            yield _new_line_segment\n                        yield from console.render(element, context.options)\n\n                if exiting or self_closing:\n                    element.on_leave(context)\n                    new_line = element.new_line",
        "line_count": 118,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "MarkdownElement",
        "methods": [
          "create",
          "on_enter",
          "on_text",
          "on_leave",
          "on_child_close",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 25,
        "docstring": null
      },
      {
        "name": "UnknownElement",
        "methods": [],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 82,
        "docstring": "An unknown element.\n\nHopefully there will be no unknown elements, and we will have a MarkdownElement for\neverything in the document."
      },
      {
        "name": "TextElement",
        "methods": [
          "on_enter",
          "on_text",
          "on_leave"
        ],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 91,
        "docstring": "Base class for elements that render text."
      },
      {
        "name": "Paragraph",
        "methods": [
          "create",
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [
          "TextElement"
        ],
        "lineno": 107,
        "docstring": "A Paragraph."
      },
      {
        "name": "Heading",
        "methods": [
          "create",
          "on_enter",
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [
          "TextElement"
        ],
        "lineno": 127,
        "docstring": "A heading."
      },
      {
        "name": "CodeBlock",
        "methods": [
          "create",
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [
          "TextElement"
        ],
        "lineno": 162,
        "docstring": "A code block with syntax highlighting."
      },
      {
        "name": "BlockQuote",
        "methods": [
          "__init__",
          "on_child_close",
          "__rich_console__"
        ],
        "base_classes": [
          "TextElement"
        ],
        "lineno": 187,
        "docstring": "A block quote."
      },
      {
        "name": "HorizontalRule",
        "methods": [
          "__rich_console__"
        ],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 213,
        "docstring": "A horizontal rule to divide sections."
      },
      {
        "name": "TableElement",
        "methods": [
          "__init__",
          "on_child_close",
          "__rich_console__"
        ],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 225,
        "docstring": "MarkdownElement corresponding to `table_open`."
      },
      {
        "name": "TableHeaderElement",
        "methods": [
          "__init__",
          "on_child_close"
        ],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 258,
        "docstring": "MarkdownElement corresponding to `thead_open` and `thead_close`."
      },
      {
        "name": "TableBodyElement",
        "methods": [
          "__init__",
          "on_child_close"
        ],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 270,
        "docstring": "MarkdownElement corresponding to `tbody_open` and `tbody_close`."
      },
      {
        "name": "TableRowElement",
        "methods": [
          "__init__",
          "on_child_close"
        ],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 282,
        "docstring": "MarkdownElement corresponding to `tr_open` and `tr_close`."
      },
      {
        "name": "TableDataElement",
        "methods": [
          "create",
          "__init__",
          "on_text"
        ],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 294,
        "docstring": "MarkdownElement corresponding to `td_open` and `td_close`\nand `th_open` and `th_close`."
      },
      {
        "name": "ListElement",
        "methods": [
          "create",
          "__init__",
          "on_child_close",
          "__rich_console__"
        ],
        "base_classes": [
          "MarkdownElement"
        ],
        "lineno": 325,
        "docstring": "A list element."
      },
      {
        "name": "ListItem",
        "methods": [
          "__init__",
          "on_child_close",
          "render_bullet",
          "render_number"
        ],
        "base_classes": [
          "TextElement"
        ],
        "lineno": 357,
        "docstring": "An item in a list."
      },
      {
        "name": "Link",
        "methods": [
          "create",
          "__init__"
        ],
        "base_classes": [
          "TextElement"
        ],
        "lineno": 399,
        "docstring": null
      },
      {
        "name": "ImageItem",
        "methods": [
          "create",
          "__init__",
          "on_enter",
          "__rich_console__"
        ],
        "base_classes": [
          "TextElement"
        ],
        "lineno": 410,
        "docstring": "Renders a placeholder for an image."
      },
      {
        "name": "MarkdownContext",
        "methods": [
          "__init__",
          "current_style",
          "on_text",
          "enter_style",
          "leave_style"
        ],
        "base_classes": [],
        "lineno": 450,
        "docstring": "Manages the console render state."
      },
      {
        "name": "Markdown",
        "methods": [
          "__init__",
          "_flatten_tokens",
          "__rich_console__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 498,
        "docstring": "A Markdown renderable.\n\nArgs:\n    markup (str): A string containing markdown.\n    code_theme (str, optional): Pygments theme for code blocks. Defaults to \"monokai\". See https://pygments.org/styles/ for code themes.\n    justify (JustifyMethod, optional): Justify value for paragraphs. Defaults to None.\n    style (Union[str, Style], optional): Optional style to apply to markdown.\n    hyperlinks (bool, optional): Enable hyperlinks. Defaults to ``True``.\n    inline_code_lexer: (str, optional): Lexer to use if inline code highlighting is\n        enabled. Defaults to None.\n    inline_code_theme: (Optional[str], optional): Pygments theme for inline code\n        highlighting, or None for no highlighting. Defaults to None."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "ClassVar",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "get_args",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "markdown_it",
        "name": "MarkdownIt",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "markdown_it.token",
        "name": "Token",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "box",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_first",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "_stack",
        "name": "Stack",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "JustifyMethod",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "containers",
        "name": "Renderables",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "panel",
        "name": "Panel",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "rule",
        "name": "Rule",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleStack",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "argparse",
        "alias": null,
        "lineno": 685,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 686,
        "type": "import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 749,
        "type": "from_import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 765,
        "type": "import"
      },
      {
        "module": "pydoc",
        "alias": null,
        "lineno": 766,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "argparse.ArgumentParser",
      "sys.stdin.read",
      "pydoc.pager",
      "markdown_file.read",
      "Console",
      "Markdown",
      "parser.parse_args",
      "fileio.getvalue",
      "open",
      "io.StringIO",
      "parser.add_argument"
    ],
    "module_level_calls": {
      "function_calls": [
        "argparse.ArgumentParser",
        "args.code_theme",
        "args.width",
        "args.force_color",
        "fileio.getvalue",
        "parser.add_argument",
        "Markdown",
        "args.inline_code_lexer",
        "fileio",
        "int",
        "args.hyperlinks",
        "sys.stdin.read",
        "pydoc.pager",
        "Console",
        "markdown",
        "parser.parse_args",
        "open",
        "io.StringIO",
        "console.print",
        "markdown_file.read",
        "markdown_body",
        "args.path"
      ],
      "class_instantiations": [
        "Markdown",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "io",
        "sys",
        "argparse",
        "typing"
      ],
      "third_party": {
        "other": [
          "__future__",
          "markdown_it",
          "rich",
          "box",
          "_loop",
          "_stack",
          "console",
          "containers",
          "jupyter",
          "panel",
          "rule",
          "segment",
          "style",
          "syntax",
          "text",
          "pydoc"
        ]
      },
      "tech_stack": []
    },
    "line_count": 780
  },
  "rich/markup.py": {
    "filepath": "../rich/rich/markup.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "escape",
        "args": [
          {
            "name": "markup",
            "type": "str"
          },
          {
            "name": "_escape",
            "type": "_EscapeSubMethod"
          }
        ],
        "return_type": "str",
        "lineno": 48,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_escape",
          "markup",
          "re.compile",
          "markup.endswith",
          "match.groups",
          "escape_backslashes"
        ],
        "docstring": "Escapes text so that it won't be interpreted as markup.\n\nArgs:\n    markup (str): Content to be inserted in to markup.\n\nReturns:\n    str: Markup with square brackets escaped.",
        "code": "def escape(\n    markup: str,\n    _escape: _EscapeSubMethod = re.compile(r\"(\\\\*)(\\[[a-z#/@][^[]*?])\").sub,\n) -> str:\n    \"\"\"Escapes text so that it won't be interpreted as markup.\n\n    Args:\n        markup (str): Content to be inserted in to markup.\n\n    Returns:\n        str: Markup with square brackets escaped.\n    \"\"\"\n\n    def escape_backslashes(match: Match[str]) -> str:\n        \"\"\"Called by re.sub replace matches.\"\"\"\n        backslashes, text = match.groups()\n        return f\"{backslashes}{backslashes}\\\\{text}\"\n\n    markup = _escape(escape_backslashes, markup)\n    if markup.endswith(\"\\\\\") and not markup.endswith(\"\\\\\\\\\"):\n        return markup + \"\\\\\"\n\n    return markup",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "_parse",
        "args": [
          {
            "name": "markup",
            "type": "str"
          }
        ],
        "return_type": "Iterable[Tuple[int, Optional[str], Optional[Tag]]]",
        "lineno": 73,
        "decorators": [],
        "is_async": false,
        "calls": [
          "escapes",
          "_Tag",
          "RE_TAGS.finditer",
          "end",
          "markup",
          "divmod",
          "Tag",
          "_divmod",
          "text",
          "match.span",
          "tag_text.partition",
          "match.groups",
          "len"
        ],
        "docstring": "Parse markup in to an iterable of tuples of (position, text, tag).\n\nArgs:\n    markup (str): A string containing console markup",
        "code": "def _parse(markup: str) -> Iterable[Tuple[int, Optional[str], Optional[Tag]]]:\n    \"\"\"Parse markup in to an iterable of tuples of (position, text, tag).\n\n    Args:\n        markup (str): A string containing console markup\n\n    \"\"\"\n    position = 0\n    _divmod = divmod\n    _Tag = Tag\n    for match in RE_TAGS.finditer(markup):\n        full_text, escapes, tag_text = match.groups()\n        start, end = match.span()\n        if start > position:\n            yield start, markup[position:start], None\n        if escapes:\n            backslashes, escaped = _divmod(len(escapes), 2)\n            if backslashes:\n                # Literal backslashes\n                yield start, \"\\\\\" * backslashes, None\n                start += backslashes * 2\n            if escaped:\n                # Escape of tag\n                yield start, full_text[len(escapes) :], None\n                position = end\n                continue\n        text, equals, parameters = tag_text.partition(\"=\")\n        yield start, None, _Tag(text, parameters if equals else None)\n        position = end\n    if position < len(markup):\n        yield position, markup[position:], None",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "markup",
            "type": "str"
          },
          {
            "name": "style",
            "type": "Union[str, Style]"
          },
          {
            "name": "emoji",
            "type": "bool"
          },
          {
            "name": "emoji_variant",
            "type": "Optional[EmojiVariant]"
          }
        ],
        "return_type": "Text",
        "lineno": 106,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "_parse",
          "markup",
          "tag.parameters",
          "style",
          "open_tag.name.startswith",
          "RE_HANDLER.match",
          "style_name",
          "attrgetter",
          "MarkupError",
          "tag.name",
          "emoji_replace",
          "literal_eval",
          "style_stack.pop",
          "Style",
          "style_stack.append",
          "_Tag",
          "KeyError",
          "text_length",
          "spans.append",
          "reversed",
          "_emoji_replace",
          "_Span",
          "open_tag.parameters.strip",
          "plain_text.replace",
          "handler_match.groups",
          "pop",
          "tag.name.startswith",
          "Text",
          "str",
          "tag",
          "append",
          "meta_params",
          "emoji_variant",
          "Span",
          "Tag",
          "text",
          "normalize",
          "parameters",
          "len",
          "tuple",
          "unknown.strip",
          "isinstance",
          "text.append",
          "append_span",
          "plain_text",
          "Style.normalize",
          "style_stack",
          "start",
          "sorted",
          "open_tag",
          "pop_style"
        ],
        "docstring": "Render console markup in to a Text instance.\n\nArgs:\n    markup (str): A string containing console markup.\n    style: (Union[str, Style]): The style to use.\n    emoji (bool, optional): Also render emoji code. Defaults to True.\n    emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults to None.\n\n\nRaises:\n    MarkupError: If there is a syntax error in the markup.\n\nReturns:\n    Text: A test instance.",
        "code": "def render(\n    markup: str,\n    style: Union[str, Style] = \"\",\n    emoji: bool = True,\n    emoji_variant: Optional[EmojiVariant] = None,\n) -> Text:\n    \"\"\"Render console markup in to a Text instance.\n\n    Args:\n        markup (str): A string containing console markup.\n        style: (Union[str, Style]): The style to use.\n        emoji (bool, optional): Also render emoji code. Defaults to True.\n        emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults to None.\n\n\n    Raises:\n        MarkupError: If there is a syntax error in the markup.\n\n    Returns:\n        Text: A test instance.\n    \"\"\"\n    emoji_replace = _emoji_replace\n    if \"[\" not in markup:\n        return Text(\n            emoji_replace(markup, default_variant=emoji_variant) if emoji else markup,\n            style=style,\n        )\n    text = Text(style=style)\n    append = text.append\n    normalize = Style.normalize\n\n    style_stack: List[Tuple[int, Tag]] = []\n    pop = style_stack.pop\n\n    spans: List[Span] = []\n    append_span = spans.append\n\n    _Span = Span\n    _Tag = Tag\n\n    def pop_style(style_name: str) -> Tuple[int, Tag]:\n        \"\"\"Pop tag matching given style name.\"\"\"\n        for index, (_, tag) in enumerate(reversed(style_stack), 1):\n            if tag.name == style_name:\n                return pop(-index)\n        raise KeyError(style_name)\n\n    for position, plain_text, tag in _parse(markup):\n        if plain_text is not None:\n            # Handle open brace escapes, where the brace is not part of a tag.\n            plain_text = plain_text.replace(\"\\\\[\", \"[\")\n            append(emoji_replace(plain_text) if emoji else plain_text)\n        elif tag is not None:\n            if tag.name.startswith(\"/\"):  # Closing tag\n                style_name = tag.name[1:].strip()\n\n                if style_name:  # explicit close\n                    style_name = normalize(style_name)\n                    try:\n                        start, open_tag = pop_style(style_name)\n                    except KeyError:\n                        raise MarkupError(\n                            f\"closing tag '{tag.markup}' at position {position} doesn't match any open tag\"\n                        ) from None\n                else:  # implicit close\n                    try:\n                        start, open_tag = pop()\n                    except IndexError:\n                        raise MarkupError(\n                            f\"closing tag '[/]' at position {position} has nothing to close\"\n                        ) from None\n\n                if open_tag.name.startswith(\"@\"):\n                    if open_tag.parameters:\n                        handler_name = \"\"\n                        parameters = open_tag.parameters.strip()\n                        handler_match = RE_HANDLER.match(parameters)\n                        if handler_match is not None:\n                            handler_name, match_parameters = handler_match.groups()\n                            parameters = (\n                                \"()\" if match_parameters is None else match_parameters\n                            )\n\n                        try:\n                            meta_params = literal_eval(parameters)\n                        except SyntaxError as error:\n                            raise MarkupError(\n                                f\"error parsing {parameters!r} in {open_tag.parameters!r}; {error.msg}\"\n                            )\n                        except Exception as error:\n                            raise MarkupError(\n                                f\"error parsing {open_tag.parameters!r}; {error}\"\n                            ) from None\n\n                        if handler_name:\n                            meta_params = (\n                                handler_name,\n                                meta_params\n                                if isinstance(meta_params, tuple)\n                                else (meta_params,),\n                            )\n\n                    else:\n                        meta_params = ()\n\n                    append_span(\n                        _Span(\n                            start, len(text), Style(meta={open_tag.name: meta_params})\n                        )\n                    )\n                else:\n                    append_span(_Span(start, len(text), str(open_tag)))\n\n            else:  # Opening tag\n                normalized_tag = _Tag(normalize(tag.name), tag.parameters)\n                style_stack.append((len(text), normalized_tag))\n\n    text_length = len(text)\n    while style_stack:\n        start, tag = style_stack.pop()\n        style = str(tag)\n        if style:\n            append_span(_Span(start, text_length, style))\n\n    text.spans = sorted(spans[::-1], key=attrgetter(\"start\"))\n    return text",
        "line_count": 126,
        "needs_llm_summary": true
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 28,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        return (\n            self.name if self.parameters is None else f\"{self.name} {self.parameters}\"\n        )",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "markup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 34,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get the string representation of this tag.",
        "code": "def markup(self) -> str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (\n            f\"[{self.name}]\"\n            if self.parameters is None\n            else f\"[{self.name}={self.parameters}]\"\n        )",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "escape_backslashes",
        "args": [
          {
            "name": "match",
            "type": "Match[str]"
          }
        ],
        "return_type": "str",
        "lineno": 61,
        "decorators": [],
        "is_async": false,
        "calls": [
          "match.groups"
        ],
        "docstring": "Called by re.sub replace matches.",
        "code": "def escape_backslashes(match: Match[str]) -> str:\n        \"\"\"Called by re.sub replace matches.\"\"\"\n        backslashes, text = match.groups()\n        return f\"{backslashes}{backslashes}\\\\{text}\"",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "pop_style",
        "args": [
          {
            "name": "style_name",
            "type": "str"
          }
        ],
        "return_type": "Tuple[int, Tag]",
        "lineno": 146,
        "decorators": [],
        "is_async": false,
        "calls": [
          "KeyError",
          "enumerate",
          "style_name",
          "reversed",
          "style_stack",
          "pop"
        ],
        "docstring": "Pop tag matching given style name.",
        "code": "def pop_style(style_name: str) -> Tuple[int, Tag]:\n        \"\"\"Pop tag matching given style name.\"\"\"\n        for index, (_, tag) in enumerate(reversed(style_stack), 1):\n            if tag.name == style_name:\n                return pop(-index)\n        raise KeyError(style_name)",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Tag",
        "methods": [
          "__str__",
          "markup"
        ],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 20,
        "docstring": "A tag in console markup."
      }
    ],
    "imports": [
      {
        "module": "re",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "ast",
        "name": "literal_eval",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "operator",
        "name": "attrgetter",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Match",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "_emoji_replace",
        "name": "_emoji_replace",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "emoji",
        "name": "EmojiVariant",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "errors",
        "name": "MarkupError",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Span",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 243,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 244,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "RE_TAGS",
        "assigned_to": "re.compile",
        "lineno": 12
      },
      {
        "name": "RE_HANDLER",
        "assigned_to": "re.compile",
        "lineno": 17
      },
      {
        "name": "_ReStringMatch",
        "assigned_to": null,
        "lineno": 43
      },
      {
        "name": "_ReSubCallable",
        "assigned_to": null,
        "lineno": 44
      },
      {
        "name": "_EscapeSubMethod",
        "assigned_to": null,
        "lineno": 45
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "Text",
      "print",
      "grid.add_row",
      "Table"
    ],
    "module_level_calls": {
      "function_calls": [
        "markup",
        "grid",
        "re.compile",
        "grid.add_row",
        "Text",
        "re.VERBOSE",
        "print",
        "Table"
      ],
      "class_instantiations": [
        "Text",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "re"
      ],
      "third_party": {
        "other": [
          "ast",
          "operator",
          "_emoji_replace",
          "emoji",
          "errors",
          "style",
          "text",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 252
  },
  "rich/measure.py": {
    "filepath": "../rich/rich/measure.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "measure_renderables",
        "args": [
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          },
          {
            "name": "renderables",
            "type": "Sequence[RenderableType]"
          }
        ],
        "return_type": "Measurement",
        "lineno": 125,
        "decorators": [],
        "is_async": false,
        "calls": [
          "get_measurement",
          "options",
          "Measurement.get",
          "unknown.maximum",
          "renderable",
          "measurements",
          "unknown.minimum",
          "Measurement",
          "max",
          "itemgetter",
          "console"
        ],
        "docstring": "Get a measurement that would fit a number of renderables.\n\nArgs:\n    console (~rich.console.Console): Console instance.\n    options (~rich.console.ConsoleOptions): Console options.\n    renderables (Iterable[RenderableType]): One or more renderable objects.\n\nReturns:\n    Measurement: Measurement object containing range of character widths required to\n        contain all given renderables.",
        "code": "def measure_renderables(\n    console: \"Console\",\n    options: \"ConsoleOptions\",\n    renderables: Sequence[\"RenderableType\"],\n) -> \"Measurement\":\n    \"\"\"Get a measurement that would fit a number of renderables.\n\n    Args:\n        console (~rich.console.Console): Console instance.\n        options (~rich.console.ConsoleOptions): Console options.\n        renderables (Iterable[RenderableType]): One or more renderable objects.\n\n    Returns:\n        Measurement: Measurement object containing range of character widths required to\n            contain all given renderables.\n    \"\"\"\n    if not renderables:\n        return Measurement(0, 0)\n    get_measurement = Measurement.get\n    measurements = [\n        get_measurement(console, options, renderable) for renderable in renderables\n    ]\n    measured_width = Measurement(\n        max(measurements, key=itemgetter(0)).minimum,\n        max(measurements, key=itemgetter(1)).maximum,\n    )\n    return measured_width",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "span",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 20,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get difference between maximum and minimum.",
        "code": "def span(self) -> int:\n        \"\"\"Get difference between maximum and minimum.\"\"\"\n        return self.maximum - self.minimum",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "normalize",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Measurement",
        "lineno": 24,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "self",
          "Measurement",
          "max",
          "minimum",
          "maximum"
        ],
        "docstring": "Get measurement that ensures that minimum <= maximum and minimum >= 0\n\nReturns:\n    Measurement: A normalized measurement.",
        "code": "def normalize(self) -> \"Measurement\":\n        \"\"\"Get measurement that ensures that minimum <= maximum and minimum >= 0\n\n        Returns:\n            Measurement: A normalized measurement.\n        \"\"\"\n        minimum, maximum = self\n        minimum = min(max(0, minimum), maximum)\n        return Measurement(max(0, minimum), max(0, max(minimum, maximum)))",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "with_maximum",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "Measurement",
        "lineno": 34,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "width",
          "Measurement",
          "maximum",
          "minimum",
          "self"
        ],
        "docstring": "Get a RenderableWith where the widths are <= width.\n\nArgs:\n    width (int): Maximum desired width.\n\nReturns:\n    Measurement: New Measurement object.",
        "code": "def with_maximum(self, width: int) -> \"Measurement\":\n        \"\"\"Get a RenderableWith where the widths are <= width.\n\n        Args:\n            width (int): Maximum desired width.\n\n        Returns:\n            Measurement: New Measurement object.\n        \"\"\"\n        minimum, maximum = self\n        return Measurement(min(minimum, width), min(maximum, width))",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "with_minimum",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "Measurement",
        "lineno": 46,
        "decorators": [],
        "is_async": false,
        "calls": [
          "width",
          "Measurement",
          "max",
          "maximum",
          "minimum",
          "self"
        ],
        "docstring": "Get a RenderableWith where the widths are >= width.\n\nArgs:\n    width (int): Minimum desired width.\n\nReturns:\n    Measurement: New Measurement object.",
        "code": "def with_minimum(self, width: int) -> \"Measurement\":\n        \"\"\"Get a RenderableWith where the widths are >= width.\n\n        Args:\n            width (int): Minimum desired width.\n\n        Returns:\n            Measurement: New Measurement object.\n        \"\"\"\n        minimum, maximum = self\n        width = max(0, width)\n        return Measurement(max(minimum, width), max(maximum, width))",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "clamp",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "min_width",
            "type": "Optional[int]"
          },
          {
            "name": "max_width",
            "type": "Optional[int]"
          }
        ],
        "return_type": "Measurement",
        "lineno": 59,
        "decorators": [],
        "is_async": false,
        "calls": [
          "measurement.with_minimum",
          "measurement.with_maximum",
          "max_width",
          "min_width",
          "self"
        ],
        "docstring": "Clamp a measurement within the specified range.\n\nArgs:\n    min_width (int): Minimum desired width, or ``None`` for no minimum. Defaults to None.\n    max_width (int): Maximum desired width, or ``None`` for no maximum. Defaults to None.\n\nReturns:\n    Measurement: New Measurement object.",
        "code": "def clamp(\n        self, min_width: Optional[int] = None, max_width: Optional[int] = None\n    ) -> \"Measurement\":\n        \"\"\"Clamp a measurement within the specified range.\n\n        Args:\n            min_width (int): Minimum desired width, or ``None`` for no minimum. Defaults to None.\n            max_width (int): Maximum desired width, or ``None`` for no maximum. Defaults to None.\n\n        Returns:\n            Measurement: New Measurement object.\n        \"\"\"\n        measurement = self\n        if min_width is not None:\n            measurement = measurement.with_minimum(min_width)\n        if max_width is not None:\n            measurement = measurement.with_maximum(max_width)\n        return measurement",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "get",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "Measurement",
        "lineno": 79,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "isinstance",
          "console.render_str",
          "str",
          "getattr",
          "rich_cast",
          "options.max_width",
          "options",
          "errors.NotRenderableError",
          "_max_width",
          "render_width.normalize",
          "get_console_width",
          "console",
          "renderable",
          "unknown.with_maximum",
          "Measurement",
          "unknown.normalize",
          "is_renderable",
          "options.markup"
        ],
        "docstring": "Get a measurement for a renderable.\n\nArgs:\n    console (~rich.console.Console): Console instance.\n    options (~rich.console.ConsoleOptions): Console options.\n    renderable (RenderableType): An object that may be rendered with Rich.\n\nRaises:\n    errors.NotRenderableError: If the object is not renderable.\n\nReturns:\n    Measurement: Measurement object containing range of character widths required to render the object.",
        "code": "def get(\n        cls, console: \"Console\", options: \"ConsoleOptions\", renderable: \"RenderableType\"\n    ) -> \"Measurement\":\n        \"\"\"Get a measurement for a renderable.\n\n        Args:\n            console (~rich.console.Console): Console instance.\n            options (~rich.console.ConsoleOptions): Console options.\n            renderable (RenderableType): An object that may be rendered with Rich.\n\n        Raises:\n            errors.NotRenderableError: If the object is not renderable.\n\n        Returns:\n            Measurement: Measurement object containing range of character widths required to render the object.\n        \"\"\"\n        _max_width = options.max_width\n        if _max_width < 1:\n            return Measurement(0, 0)\n        if isinstance(renderable, str):\n            renderable = console.render_str(\n                renderable, markup=options.markup, highlight=False\n            )\n        renderable = rich_cast(renderable)\n        if is_renderable(renderable):\n            get_console_width: Optional[\n                Callable[[\"Console\", \"ConsoleOptions\"], \"Measurement\"]\n            ] = getattr(renderable, \"__rich_measure__\", None)\n            if get_console_width is not None:\n                render_width = (\n                    get_console_width(console, options)\n                    .normalize()\n                    .with_maximum(_max_width)\n                )\n                if render_width.maximum < 1:\n                    return Measurement(0, 0)\n                return render_width.normalize()\n            else:\n                return Measurement(0, _max_width)\n        else:\n            raise errors.NotRenderableError(\n                f\"Unable to get render width for {renderable!r}; \"\n                \"a str, Segment, or object with __rich_console__ method is required\"\n            )",
        "line_count": 44,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Measurement",
        "methods": [
          "span",
          "normalize",
          "with_maximum",
          "with_minimum",
          "clamp",
          "get"
        ],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 11,
        "docstring": "Stores the minimum and maximum widths (in characters) required to render an object."
      }
    ],
    "imports": [
      {
        "module": "operator",
        "name": "itemgetter",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "errors",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "protocol",
        "name": "is_renderable",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "protocol",
        "name": "rich_cast",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "operator",
          "errors",
          "protocol",
          "console"
        ]
      },
      "tech_stack": []
    },
    "line_count": 152
  },
  "rich/padding.py": {
    "filepath": "../rich/rich/padding.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "pad",
            "type": "PaddingDimensions"
          }
        ],
        "return_type": null,
        "lineno": 33,
        "decorators": [],
        "is_async": false,
        "calls": [
          "expand",
          "style",
          "self.unpack",
          "renderable",
          "pad"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        renderable: \"RenderableType\",\n        pad: \"PaddingDimensions\" = (0, 0, 0, 0),\n        *,\n        style: Union[str, Style] = \"none\",\n        expand: bool = True,\n    ):\n        self.renderable = renderable\n        self.top, self.right, self.bottom, self.left = self.unpack(pad)\n        self.style = style\n        self.expand = expand",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "indent",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "level",
            "type": "int"
          }
        ],
        "return_type": "Padding",
        "lineno": 47,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "Padding",
          "renderable"
        ],
        "docstring": "Make padding instance to render an indent.\n\nArgs:\n    renderable (RenderableType): String or other renderable.\n    level (int): Number of characters to indent.\n\nReturns:\n    Padding: A Padding instance.",
        "code": "def indent(cls, renderable: \"RenderableType\", level: int) -> \"Padding\":\n        \"\"\"Make padding instance to render an indent.\n\n        Args:\n            renderable (RenderableType): String or other renderable.\n            level (int): Number of characters to indent.\n\n        Returns:\n            Padding: A Padding instance.\n        \"\"\"\n\n        return Padding(renderable, pad=(0, 0, 0, level), expand=False)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "unpack",
        "args": [
          {
            "name": "pad",
            "type": "PaddingDimensions"
          }
        ],
        "return_type": "Tuple[int, int, int, int]",
        "lineno": 61,
        "decorators": [
          {
            "name": "staticmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "isinstance",
          "ValueError",
          "pad",
          "int",
          "len"
        ],
        "docstring": "Unpack padding specified in CSS style.",
        "code": "def unpack(pad: \"PaddingDimensions\") -> Tuple[int, int, int, int]:\n        \"\"\"Unpack padding specified in CSS style.\"\"\"\n        if isinstance(pad, int):\n            return (pad, pad, pad, pad)\n        if len(pad) == 1:\n            _pad = pad[0]\n            return (_pad, _pad, _pad, _pad)\n        if len(pad) == 2:\n            pad_top, pad_right = pad\n            return (pad_top, pad_right, pad_top, pad_right)\n        if len(pad) == 4:\n            top, right, bottom, left = pad\n            return (top, right, bottom, left)\n        raise ValueError(f\"1, 2 or 4 integers required for padding; {len(pad)} given\")",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"Padding({self.renderable!r}, ({self.top},{self.right},{self.bottom},{self.left}))\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 79,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "min",
          "console.render_lines",
          "options",
          "options.max_width",
          "style",
          "Measurement.get",
          "console.get_style",
          "self.renderable",
          "options.update_width",
          "_Segment.line",
          "Segment",
          "render_options.update_height",
          "console",
          "_Segment",
          "render_options"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        style = console.get_style(self.style)\n        if self.expand:\n            width = options.max_width\n        else:\n            width = min(\n                Measurement.get(console, options, self.renderable).maximum\n                + self.left\n                + self.right,\n                options.max_width,\n            )\n        render_options = options.update_width(width - self.left - self.right)\n        if render_options.height is not None:\n            render_options = render_options.update_height(\n                height=render_options.height - self.top - self.bottom\n            )\n        lines = console.render_lines(\n            self.renderable, render_options, style=style, pad=True\n        )\n        _Segment = Segment\n\n        left = _Segment(\" \" * self.left, style) if self.left else None\n        right = (\n            [_Segment(f'{\" \" * self.right}', style), _Segment.line()]\n            if self.right\n            else [_Segment.line()]\n        )\n        blank_line: Optional[List[Segment]] = None\n        if self.top:\n            blank_line = [_Segment(f'{\" \" * width}\\n', style)]\n            yield from blank_line * self.top\n        if left:\n            for line in lines:\n                yield left\n                yield from line\n                yield from right\n        else:\n            for line in lines:\n                yield from line\n                yield from right\n        if self.bottom:\n            blank_line = blank_line or [_Segment(f'{\" \" * width}\\n', style)]\n            yield from blank_line * self.bottom",
        "line_count": 45,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 125,
        "decorators": [],
        "is_async": false,
        "calls": [
          "options",
          "options.max_width",
          "Measurement.get",
          "self.renderable",
          "measurement.with_maximum",
          "max_width",
          "Measurement",
          "console"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        max_width = options.max_width\n        extra_width = self.left + self.right\n        if max_width - extra_width < 1:\n            return Measurement(max_width, max_width)\n        measure_min, measure_max = Measurement.get(console, options, self.renderable)\n        measurement = Measurement(measure_min + extra_width, measure_max + extra_width)\n        measurement = measurement.with_maximum(max_width)\n        return measurement",
        "line_count": 11,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Padding",
        "methods": [
          "__init__",
          "indent",
          "unpack",
          "__repr__",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 19,
        "docstring": "Draw space around content.\n\nExample:\n    >>> print(Padding(\"Hello\", (2, 4), style=\"on blue\"))\n\nArgs:\n    renderable (RenderableType): String or other renderable.\n    pad (Union[int, Tuple[int]]): Padding for top, right, bottom, and left borders.\n        May be specified with 1, 2, or 4 integers (CSS style).\n    style (Union[str, Style], optional): Style for padding characters. Defaults to \"none\".\n    expand (bool, optional): Expand padding to fit available width. Defaults to True."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 139,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "PaddingDimensions",
        "assigned_to": null,
        "lineno": 16
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "Padding",
      "print"
    ],
    "module_level_calls": {
      "function_calls": [
        "Padding",
        "print"
      ],
      "class_instantiations": [
        "Padding"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "jupyter",
          "measure",
          "segment",
          "style",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 142
  },
  "rich/pager.py": {
    "filepath": "../rich/rich/pager.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "show",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "content",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 9,
        "decorators": [
          {
            "name": "abstractmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Show content in pager.\n\nArgs:\n    content (str): Content to be displayed.",
        "code": "def show(self, content: str) -> None:\n        \"\"\"Show content in pager.\n\n        Args:\n            content (str): Content to be displayed.\n        \"\"\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "_pager",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "content",
            "type": "str"
          }
        ],
        "return_type": "Any",
        "lineno": 20,
        "decorators": [],
        "is_async": false,
        "calls": [
          "__import__",
          "content",
          "unknown.pager"
        ],
        "docstring": null,
        "code": "def _pager(self, content: str) -> Any:  # \u00a0pragma: no cover\n        return __import__(\"pydoc\").pager(content)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "show",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "content",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 23,
        "decorators": [],
        "is_async": false,
        "calls": [
          "content",
          "self._pager"
        ],
        "docstring": "Use the same pager used by pydoc.",
        "code": "def show(self, content: str) -> None:\n        \"\"\"Use the same pager used by pydoc.\"\"\"\n        self._pager(content)",
        "line_count": 3,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Pager",
        "methods": [
          "show"
        ],
        "base_classes": [
          "ABC"
        ],
        "lineno": 5,
        "docstring": "Base class for a pager."
      },
      {
        "name": "SystemPager",
        "methods": [
          "_pager",
          "show"
        ],
        "base_classes": [
          "Pager"
        ],
        "lineno": 17,
        "docstring": "Uses the pager installed on the system."
      }
    ],
    "imports": [
      {
        "module": "abc",
        "name": "ABC",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "abc",
        "name": "abstractmethod",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "__main__",
        "name": "make_test_card",
        "alias": null,
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "make_test_card",
      "Console",
      "console.pager"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "make_test_card",
        "Console",
        "console.pager"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "abc",
        "typing"
      ],
      "third_party": {
        "other": [
          "__main__",
          "console"
        ]
      },
      "tech_stack": []
    },
    "line_count": 35
  },
  "rich/palette.py": {
    "filepath": "../rich/rich/palette.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "colors",
            "type": "Sequence[Tuple[int, int, int]]"
          }
        ],
        "return_type": null,
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "colors"
        ],
        "docstring": null,
        "code": "def __init__(self, colors: Sequence[Tuple[int, int, int]]):\n        self._colors = colors",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__getitem__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "number",
            "type": "int"
          }
        ],
        "return_type": "ColorTriplet",
        "lineno": 17,
        "decorators": [],
        "is_async": false,
        "calls": [
          "ColorTriplet"
        ],
        "docstring": null,
        "code": "def __getitem__(self, number: int) -> ColorTriplet:\n        return ColorTriplet(*self._colors[number])",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Table",
        "lineno": 20,
        "decorators": [],
        "is_async": false,
        "calls": [
          "len",
          "enumerate",
          "self._colors",
          "str",
          "color",
          "index",
          "Color.from_rgb",
          "Text",
          "Style",
          "table.add_row",
          "repr",
          "Table"
        ],
        "docstring": null,
        "code": "def __rich__(self) -> \"Table\":\n        from rich.color import Color\n        from rich.style import Style\n        from rich.text import Text\n        from rich.table import Table\n\n        table = Table(\n            \"index\",\n            \"RGB\",\n            \"Color\",\n            title=\"Palette\",\n            caption=f\"{len(self._colors)} colors\",\n            highlight=True,\n            caption_justify=\"right\",\n        )\n        for index, color in enumerate(self._colors):\n            table.add_row(\n                str(index),\n                repr(color),\n                Text(\" \" * 16, style=Style(bgcolor=Color.from_rgb(*color))),\n            )\n        return table",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "match",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "color",
            "type": "Tuple[int, int, int]"
          }
        ],
        "return_type": "int",
        "lineno": 45,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 1024
            }
          }
        ],
        "is_async": false,
        "calls": [
          "min",
          "get_color_distance",
          "range",
          "self._colors",
          "lru_cache",
          "color",
          "index",
          "get_color",
          "_sqrt",
          "self._colors.__getitem__",
          "len",
          "sqrt"
        ],
        "docstring": "Find a color from a palette that most closely matches a given color.\n\nArgs:\n    color (Tuple[int, int, int]): RGB components in range 0 > 255.\n\nReturns:\n    int: Index of closes matching color.",
        "code": "def match(self, color: Tuple[int, int, int]) -> int:\n        \"\"\"Find a color from a palette that most closely matches a given color.\n\n        Args:\n            color (Tuple[int, int, int]): RGB components in range 0 > 255.\n\n        Returns:\n            int: Index of closes matching color.\n        \"\"\"\n        red1, green1, blue1 = color\n        _sqrt = sqrt\n        get_color = self._colors.__getitem__\n\n        def get_color_distance(index: int) -> float:\n            \"\"\"Get the distance to a color.\"\"\"\n            red2, green2, blue2 = get_color(index)\n            red_mean = (red1 + red2) // 2\n            red = red1 - red2\n            green = green1 - green2\n            blue = blue1 - blue2\n            return _sqrt(\n                (((512 + red_mean) * red * red) >> 8)\n                + 4 * green * green\n                + (((767 - red_mean) * blue * blue) >> 8)\n            )\n\n        min_index = min(range(len(self._colors)), key=get_color_distance)\n        return min_index",
        "line_count": 28,
        "needs_llm_summary": true
      },
      {
        "name": "get_color_distance",
        "args": [
          {
            "name": "index",
            "type": "int"
          }
        ],
        "return_type": "float",
        "lineno": 58,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_sqrt",
          "index",
          "get_color"
        ],
        "docstring": "Get the distance to a color.",
        "code": "def get_color_distance(index: int) -> float:\n            \"\"\"Get the distance to a color.\"\"\"\n            red2, green2, blue2 = get_color(index)\n            red_mean = (red1 + red2) // 2\n            red = red1 - red2\n            green = green1 - green2\n            blue = blue1 - blue2\n            return _sqrt(\n                (((512 + red_mean) * red * red) >> 8)\n                + 4 * green * green\n                + (((767 - red_mean) * blue * blue) >> 8)\n            )",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 84,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "range",
          "options.max_width",
          "colorsys.hls_to_rgb",
          "color",
          "h",
          "Color.from_rgb",
          "bgcolor",
          "Segment",
          "Style",
          "height",
          "l"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n            self, console: Console, options: ConsoleOptions\n        ) -> Iterable[Segment]:\n            height = console.size.height - 3\n            for y in range(0, height):\n                for x in range(options.max_width):\n                    h = x / options.max_width\n                    l = y / (height + 1)\n                    r1, g1, b1 = colorsys.hls_to_rgb(h, l, 1.0)\n                    r2, g2, b2 = colorsys.hls_to_rgb(h, l + (1 / height / 2), 1.0)\n                    bgcolor = Color.from_rgb(r1 * 255, g1 * 255, b1 * 255)\n                    color = Color.from_rgb(r2 * 255, g2 * 255, b2 * 255)\n                    yield Segment(\"\u2584\", Style(color=color, bgcolor=bgcolor))\n                yield Segment.line()",
        "line_count": 14,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Palette",
        "methods": [
          "__init__",
          "__getitem__",
          "__rich__",
          "match"
        ],
        "base_classes": [],
        "lineno": 11,
        "docstring": "A palette of available colors."
      },
      {
        "name": "ColorBox",
        "methods": [
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 83,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "math",
        "name": "sqrt",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "functools",
        "name": "lru_cache",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "color_triplet",
        "name": "ColorTriplet",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "colorsys",
        "alias": null,
        "lineno": 76,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 77,
        "type": "from_import"
      },
      {
        "module": "rich.color",
        "name": "Color",
        "alias": null,
        "lineno": 78,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 79,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 79,
        "type": "from_import"
      },
      {
        "module": "rich.segment",
        "name": "Segment",
        "alias": null,
        "lineno": 80,
        "type": "from_import"
      },
      {
        "module": "rich.style",
        "name": "Style",
        "alias": null,
        "lineno": 81,
        "type": "from_import"
      },
      {
        "module": "rich.color",
        "name": "Color",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "rich.style",
        "name": "Style",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Segment.line",
      "range",
      "colorsys.hls_to_rgb",
      "Console",
      "ColorBox",
      "Color.from_rgb",
      "Segment",
      "Style"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "Segment.line",
        "range",
        "options.max_width",
        "colorsys.hls_to_rgb",
        "color",
        "Console",
        "ColorBox",
        "h",
        "Color.from_rgb",
        "bgcolor",
        "Segment",
        "Style",
        "height",
        "l"
      ],
      "class_instantiations": [
        "Color",
        "Console",
        "ColorBox",
        "Segment",
        "Style"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "math",
        "functools",
        "typing"
      ],
      "third_party": {
        "other": [
          "color_triplet",
          "rich",
          "colorsys"
        ]
      },
      "tech_stack": []
    },
    "line_count": 101
  },
  "rich/panel.py": {
    "filepath": "../rich/rich/panel.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "box",
            "type": "Box"
          }
        ],
        "return_type": "None",
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "box",
          "padding",
          "safe_box",
          "expand",
          "subtitle_align",
          "style",
          "highlight",
          "subtitle",
          "renderable",
          "title",
          "width",
          "border_style",
          "height"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        renderable: \"RenderableType\",\n        box: Box = ROUNDED,\n        *,\n        title: Optional[TextType] = None,\n        title_align: AlignMethod = \"center\",\n        subtitle: Optional[TextType] = None,\n        subtitle_align: AlignMethod = \"center\",\n        safe_box: Optional[bool] = None,\n        expand: bool = True,\n        style: StyleType = \"none\",\n        border_style: StyleType = \"none\",\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        padding: PaddingDimensions = (0, 1),\n        highlight: bool = False,\n    ) -> None:\n        self.renderable = renderable\n        self.box = box\n        self.title = title\n        self.title_align: AlignMethod = title_align\n        self.subtitle = subtitle\n        self.subtitle_align = subtitle_align\n        self.safe_box = safe_box\n        self.expand = expand\n        self.style = style\n        self.border_style = border_style\n        self.width = width\n        self.height = height\n        self.padding = padding\n        self.highlight = highlight",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "fit",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "box",
            "type": "Box"
          }
        ],
        "return_type": "Panel",
        "lineno": 74,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "box",
          "padding",
          "safe_box",
          "subtitle_align",
          "style",
          "highlight",
          "title_align",
          "subtitle",
          "title",
          "renderable",
          "cls",
          "width",
          "border_style",
          "height"
        ],
        "docstring": "An alternative constructor that sets expand=False.",
        "code": "def fit(\n        cls,\n        renderable: \"RenderableType\",\n        box: Box = ROUNDED,\n        *,\n        title: Optional[TextType] = None,\n        title_align: AlignMethod = \"center\",\n        subtitle: Optional[TextType] = None,\n        subtitle_align: AlignMethod = \"center\",\n        safe_box: Optional[bool] = None,\n        style: StyleType = \"none\",\n        border_style: StyleType = \"none\",\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        padding: PaddingDimensions = (0, 1),\n        highlight: bool = False,\n    ) -> \"Panel\":\n        \"\"\"An alternative constructor that sets expand=False.\"\"\"\n        return cls(\n            renderable,\n            box,\n            title=title,\n            title_align=title_align,\n            subtitle=subtitle,\n            subtitle_align=subtitle_align,\n            safe_box=safe_box,\n            style=style,\n            border_style=border_style,\n            width=width,\n            height=height,\n            padding=padding,\n            highlight=highlight,\n            expand=False,\n        )",
        "line_count": 34,
        "needs_llm_summary": true
      },
      {
        "name": "_title",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[Text]",
        "lineno": 110,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "isinstance",
          "str",
          "self.title.copy",
          "title_text.expand_tabs",
          "title_text.pad",
          "self.title",
          "Text.from_markup",
          "title_text.plain.replace"
        ],
        "docstring": null,
        "code": "def _title(self) -> Optional[Text]:\n        if self.title:\n            title_text = (\n                Text.from_markup(self.title)\n                if isinstance(self.title, str)\n                else self.title.copy()\n            )\n            title_text.end = \"\"\n            title_text.plain = title_text.plain.replace(\"\\n\", \" \")\n            title_text.no_wrap = True\n            title_text.expand_tabs()\n            title_text.pad(1)\n            return title_text\n        return None",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "_subtitle",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[Text]",
        "lineno": 126,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "subtitle_text.plain.replace",
          "isinstance",
          "str",
          "self.subtitle",
          "subtitle_text.pad",
          "Text.from_markup",
          "subtitle_text.expand_tabs",
          "self.subtitle.copy"
        ],
        "docstring": null,
        "code": "def _subtitle(self) -> Optional[Text]:\n        if self.subtitle:\n            subtitle_text = (\n                Text.from_markup(self.subtitle)\n                if isinstance(self.subtitle, str)\n                else self.subtitle.copy()\n            )\n            subtitle_text.end = \"\"\n            subtitle_text.plain = subtitle_text.plain.replace(\"\\n\", \" \")\n            subtitle_text.no_wrap = True\n            subtitle_text.expand_tabs()\n            subtitle_text.pad(1)\n            return subtitle_text\n        return None",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 141,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "self.title_align",
          "console.render_lines",
          "child_options.update_width",
          "box.get_bottom",
          "style",
          "subtitle_text.stylize_before",
          "child_options",
          "self.width",
          "console.render",
          "_padding",
          "any",
          "options.update",
          "self.highlight",
          "console.measure",
          "align_text",
          "self.style",
          "text.stylize",
          "Padding.unpack",
          "self.border_style",
          "box.get_top",
          "console.get_style",
          "max",
          "cell_len",
          "self._subtitle",
          "text.copy",
          "safe_box",
          "options",
          "options.max_width",
          "self.box.substitute",
          "text.style",
          "renderable",
          "text.truncate",
          "child_width",
          "width",
          "text",
          "border_style",
          "Segment",
          "self.padding",
          "box.top",
          "Padding",
          "min",
          "title_text.stylize_before",
          "self.subtitle_align",
          "title_text",
          "child_height",
          "self.renderable",
          "subtitle_text",
          "options.update_width",
          "Text.assemble",
          "box.bottom",
          "self._title",
          "box.mid_left",
          "text.plain"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        _padding = Padding.unpack(self.padding)\n        renderable = (\n            Padding(self.renderable, _padding) if any(_padding) else self.renderable\n        )\n        style = console.get_style(self.style)\n        border_style = style + console.get_style(self.border_style)\n        width = (\n            options.max_width\n            if self.width is None\n            else min(options.max_width, self.width)\n        )\n\n        safe_box: bool = console.safe_box if self.safe_box is None else self.safe_box\n        box = self.box.substitute(options, safe=safe_box)\n\n        def align_text(\n            text: Text, width: int, align: str, character: str, style: Style\n        ) -> Text:\n            \"\"\"Gets new aligned text.\n\n            Args:\n                text (Text): Title or subtitle text.\n                width (int): Desired width.\n                align (str): Alignment.\n                character (str): Character for alignment.\n                style (Style): Border style\n\n            Returns:\n                Text: New text instance\n            \"\"\"\n            text = text.copy()\n            text.truncate(width)\n            excess_space = width - cell_len(text.plain)\n            if text.style:\n                text.stylize(console.get_style(text.style))\n\n            if excess_space:\n                if align == \"left\":\n                    return Text.assemble(\n                        text,\n                        (character * excess_space, style),\n                        no_wrap=True,\n                        end=\"\",\n                    )\n                elif align == \"center\":\n                    left = excess_space // 2\n                    return Text.assemble(\n                        (character * left, style),\n                        text,\n                        (character * (excess_space - left), style),\n                        no_wrap=True,\n                        end=\"\",\n                    )\n                else:\n                    return Text.assemble(\n                        (character * excess_space, style),\n                        text,\n                        no_wrap=True,\n                        end=\"\",\n                    )\n            return text\n\n        title_text = self._title\n        if title_text is not None:\n            title_text.stylize_before(border_style)\n\n        child_width = (\n            width - 2\n            if self.expand\n            else console.measure(\n                renderable, options=options.update_width(width - 2)\n            ).maximum\n        )\n        child_height = self.height or options.height or None\n        if child_height:\n            child_height -= 2\n        if title_text is not None:\n            child_width = min(\n                options.max_width - 2, max(child_width, title_text.cell_len + 2)\n            )\n\n        width = child_width + 2\n        child_options = options.update(\n            width=child_width, height=child_height, highlight=self.highlight\n        )\n        lines = console.render_lines(renderable, child_options, style=style)\n\n        line_start = Segment(box.mid_left, border_style)\n        line_end = Segment(f\"{box.mid_right}\", border_style)\n        new_line = Segment.line()\n        if title_text is None or width <= 4:\n            yield Segment(box.get_top([width - 2]), border_style)\n        else:\n            title_text = align_text(\n                title_text,\n                width - 4,\n                self.title_align,\n                box.top,\n                border_style,\n            )\n            yield Segment(box.top_left + box.top, border_style)\n            yield from console.render(title_text, child_options.update_width(width - 4))\n            yield Segment(box.top + box.top_right, border_style)\n\n        yield new_line\n        for line in lines:\n            yield line_start\n            yield from line\n            yield line_end\n            yield new_line\n\n        subtitle_text = self._subtitle\n        if subtitle_text is not None:\n            subtitle_text.stylize_before(border_style)\n\n        if subtitle_text is None or width <= 4:\n            yield Segment(box.get_bottom([width - 2]), border_style)\n        else:\n            subtitle_text = align_text(\n                subtitle_text,\n                width - 4,\n                self.subtitle_align,\n                box.bottom,\n                border_style,\n            )\n            yield Segment(box.bottom_left + box.bottom, border_style)\n            yield from console.render(\n                subtitle_text, child_options.update_width(width - 4)\n            )\n            yield Segment(box.bottom + box.bottom_right, border_style)\n\n        yield new_line",
        "line_count": 135,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 277,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Padding.unpack",
          "measure_renderables",
          "self.width",
          "renderables",
          "width",
          "options.update_width",
          "Measurement",
          "self.padding",
          "self._title",
          "console"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        _title = self._title\n        _, right, _, left = Padding.unpack(self.padding)\n        padding = left + right\n        renderables = [self.renderable, _title] if _title else [self.renderable]\n\n        if self.width is None:\n            width = (\n                measure_renderables(\n                    console,\n                    options.update_width(options.max_width - padding - 2),\n                    renderables,\n                ).maximum\n                + padding\n                + 2\n            )\n        else:\n            width = self.width\n        return Measurement(width, width)",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "align_text",
        "args": [
          {
            "name": "text",
            "type": "Text"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "align",
            "type": "str"
          },
          {
            "name": "character",
            "type": "str"
          },
          {
            "name": "style",
            "type": "Style"
          }
        ],
        "return_type": "Text",
        "lineno": 159,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text.copy",
          "text.stylize",
          "text.style",
          "console.get_style",
          "width",
          "text.truncate",
          "Text.assemble",
          "text",
          "text.plain",
          "cell_len"
        ],
        "docstring": "Gets new aligned text.\n\nArgs:\n    text (Text): Title or subtitle text.\n    width (int): Desired width.\n    align (str): Alignment.\n    character (str): Character for alignment.\n    style (Style): Border style\n\nReturns:\n    Text: New text instance",
        "code": "def align_text(\n            text: Text, width: int, align: str, character: str, style: Style\n        ) -> Text:\n            \"\"\"Gets new aligned text.\n\n            Args:\n                text (Text): Title or subtitle text.\n                width (int): Desired width.\n                align (str): Alignment.\n                character (str): Character for alignment.\n                style (Style): Border style\n\n            Returns:\n                Text: New text instance\n            \"\"\"\n            text = text.copy()\n            text.truncate(width)\n            excess_space = width - cell_len(text.plain)\n            if text.style:\n                text.stylize(console.get_style(text.style))\n\n            if excess_space:\n                if align == \"left\":\n                    return Text.assemble(\n                        text,\n                        (character * excess_space, style),\n                        no_wrap=True,\n                        end=\"\",\n                    )\n                elif align == \"center\":\n                    left = excess_space // 2\n                    return Text.assemble(\n                        (character * left, style),\n                        text,\n                        (character * (excess_space - left), style),\n                        no_wrap=True,\n                        end=\"\",\n                    )\n                else:\n                    return Text.assemble(\n                        (character * excess_space, style),\n                        text,\n                        no_wrap=True,\n                        end=\"\",\n                    )\n            return text",
        "line_count": 46,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Panel",
        "methods": [
          "__init__",
          "fit",
          "_title",
          "_subtitle",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 17,
        "docstring": "A console renderable that draws a border around its contents.\n\nExample:\n    >>> console.print(Panel(\"Hello, World!\"))\n\nArgs:\n    renderable (RenderableType): A console renderable object.\n    box (Box): A Box instance that defines the look of the border (see :ref:`appendix_box`. Defaults to box.ROUNDED.\n    title (Optional[TextType], optional): Optional title displayed in panel header. Defaults to None.\n    title_align (AlignMethod, optional): Alignment of title. Defaults to \"center\".\n    subtitle (Optional[TextType], optional): Optional subtitle displayed in panel footer. Defaults to None.\n    subtitle_align (AlignMethod, optional): Alignment of subtitle. Defaults to \"center\".\n    safe_box (bool, optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.\n    expand (bool, optional): If True the panel will stretch to fill the console width, otherwise it will be sized to fit the contents. Defaults to True.\n    style (str, optional): The style of the panel (border and contents). Defaults to \"none\".\n    border_style (str, optional): The style of the border. Defaults to \"none\".\n    width (Optional[int], optional): Optional width of panel. Defaults to None to auto-detect.\n    height (Optional[int], optional): Optional height of panel. Defaults to None to auto-detect.\n    padding (Optional[PaddingDimensions]): Optional padding around renderable. Defaults to 0.\n    highlight (bool, optional): Enable automatic highlighting of panel title (if str). Defaults to False."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "AlignMethod",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "box",
        "name": "ROUNDED",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "box",
        "name": "Box",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "measure_renderables",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "padding",
        "name": "Padding",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "padding",
        "name": "PaddingDimensions",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 301,
        "type": "from_import"
      },
      {
        "module": "box",
        "name": "DOUBLE",
        "alias": null,
        "lineno": 305,
        "type": "from_import"
      },
      {
        "module": "box",
        "name": "ROUNDED",
        "alias": null,
        "lineno": 305,
        "type": "from_import"
      },
      {
        "module": "padding",
        "name": "Padding",
        "alias": null,
        "lineno": 306,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "Console",
      "Panel",
      "c.print"
    ],
    "module_level_calls": {
      "function_calls": [
        "p",
        "Console",
        "Panel",
        "DOUBLE",
        "c.print"
      ],
      "class_instantiations": [
        "Console",
        "Panel"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "align",
          "box",
          "cells",
          "jupyter",
          "measure",
          "padding",
          "segment",
          "style",
          "text",
          "console"
        ]
      },
      "tech_stack": []
    },
    "line_count": 318
  },
  "rich/pretty.py": {
    "filepath": "../rich/rich/pretty.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_is_attr_object",
        "args": [
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 60,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_attr_module.has",
          "type",
          "obj"
        ],
        "docstring": "Check if an object was created with attrs module.",
        "code": "def _is_attr_object(obj: Any) -> bool:\n    \"\"\"Check if an object was created with attrs module.\"\"\"\n    return _has_attrs and _attr_module.has(type(obj))",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_get_attr_fields",
        "args": [
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "Sequence[_attr_module.Attribute[Any]]",
        "lineno": 65,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_attr_module.fields",
          "type",
          "obj"
        ],
        "docstring": "Get fields for an attrs object.",
        "code": "def _get_attr_fields(obj: Any) -> Sequence[\"_attr_module.Attribute[Any]\"]:\n    \"\"\"Get fields for an attrs object.\"\"\"\n    return _attr_module.fields(type(obj)) if _has_attrs else []",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_is_dataclass_repr",
        "args": [
          {
            "name": "obj",
            "type": "object"
          }
        ],
        "return_type": "bool",
        "lineno": 70,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Check if an instance of a dataclass contains the default repr.\n\nArgs:\n    obj (object): A dataclass instance.\n\nReturns:\n    bool: True if the default repr is used, False if there is a custom repr.",
        "code": "def _is_dataclass_repr(obj: object) -> bool:\n    \"\"\"Check if an instance of a dataclass contains the default repr.\n\n    Args:\n        obj (object): A dataclass instance.\n\n    Returns:\n        bool: True if the default repr is used, False if there is a custom repr.\n    \"\"\"\n    # Digging in to a lot of internals here\n    # Catching all exceptions in case something is missing on a non CPython implementation\n    try:\n        return obj.__repr__.__code__.co_filename in (\n            dataclasses.__file__,\n            reprlib.__file__,\n        )\n    except Exception:  # pragma: no coverage\n        return False",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "_has_default_namedtuple_repr",
        "args": [
          {
            "name": "obj",
            "type": "object"
          }
        ],
        "return_type": "bool",
        "lineno": 93,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_dummy_namedtuple.__repr__",
          "inspect.getfile",
          "obj.__repr__"
        ],
        "docstring": "Check if an instance of namedtuple contains the default repr\n\nArgs:\n    obj (object): A namedtuple\n\nReturns:\n    bool: True if the default repr is used, False if there's a custom repr.",
        "code": "def _has_default_namedtuple_repr(obj: object) -> bool:\n    \"\"\"Check if an instance of namedtuple contains the default repr\n\n    Args:\n        obj (object): A namedtuple\n\n    Returns:\n        bool: True if the default repr is used, False if there's a custom repr.\n    \"\"\"\n    obj_file = None\n    try:\n        obj_file = inspect.getfile(obj.__repr__)\n    except (OSError, TypeError):\n        # OSError handles case where object is defined in __main__ scope, e.g. REPL - no filename available.\n        # TypeError trapped defensively, in case of object without filename slips through.\n        pass\n    default_repr_file = inspect.getfile(_dummy_namedtuple.__repr__)\n    return obj_file == default_repr_file",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "_ipy_display_hook",
        "args": [
          {
            "name": "value",
            "type": "Any"
          },
          {
            "name": "console",
            "type": "Optional[Console]"
          },
          {
            "name": "overflow",
            "type": "OverflowMethod"
          },
          {
            "name": "crop",
            "type": "bool"
          },
          {
            "name": "indent_guides",
            "type": "bool"
          },
          {
            "name": "max_length",
            "type": "Optional[int]"
          },
          {
            "name": "max_string",
            "type": "Optional[int]"
          },
          {
            "name": "max_depth",
            "type": "Optional[int]"
          },
          {
            "name": "expand_all",
            "type": "bool"
          }
        ],
        "return_type": "Union[str, None]",
        "lineno": 113,
        "decorators": [],
        "is_async": false,
        "calls": [
          "capture.get",
          "max_depth",
          "JupyterRenderable",
          "RichRenderable",
          "max_length",
          "get_console",
          "unknown.rstrip",
          "crop",
          "console.line",
          "max_string",
          "value",
          "expand_all",
          "_safe_isinstance",
          "indent_guides",
          "console.capture",
          "console.print",
          "overflow",
          "Pretty",
          "ConsoleRenderable"
        ],
        "docstring": null,
        "code": "def _ipy_display_hook(\n    value: Any,\n    console: Optional[\"Console\"] = None,\n    overflow: \"OverflowMethod\" = \"ignore\",\n    crop: bool = False,\n    indent_guides: bool = False,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> Union[str, None]:\n    # needed here to prevent circular import:\n    from .console import ConsoleRenderable\n\n    # always skip rich generated jupyter renderables or None values\n    if _safe_isinstance(value, JupyterRenderable) or value is None:\n        return None\n\n    console = console or get_console()\n\n    with console.capture() as capture:\n        # certain renderables should start on a new line\n        if _safe_isinstance(value, ConsoleRenderable):\n            console.line()\n        console.print(\n            (\n                value\n                if _safe_isinstance(value, RichRenderable)\n                else Pretty(\n                    value,\n                    overflow=overflow,\n                    indent_guides=indent_guides,\n                    max_length=max_length,\n                    max_string=max_string,\n                    max_depth=max_depth,\n                    expand_all=expand_all,\n                    margin=12,\n                )\n            ),\n            crop=crop,\n            new_line_start=True,\n            end=\"\",\n        )\n    # strip trailing newline, not usually part of a text repr\n    # I'm not sure if this should be prevented at a lower level\n    return capture.get().rstrip(\"\\n\")",
        "line_count": 46,
        "needs_llm_summary": true
      },
      {
        "name": "_safe_isinstance",
        "args": [
          {
            "name": "obj",
            "type": "object"
          },
          {
            "name": "class_or_tuple",
            "type": "Union[type, Tuple[type, Ellipsis]]"
          }
        ],
        "return_type": "bool",
        "lineno": 161,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "class_or_tuple",
          "obj"
        ],
        "docstring": "isinstance can fail in rare cases, for example types with no __class__",
        "code": "def _safe_isinstance(\n    obj: object, class_or_tuple: Union[type, Tuple[type, ...]]\n) -> bool:\n    \"\"\"isinstance can fail in rare cases, for example types with no __class__\"\"\"\n    try:\n        return isinstance(obj, class_or_tuple)\n    except Exception:\n        return False",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "install",
        "args": [
          {
            "name": "console",
            "type": "Optional[Console]"
          },
          {
            "name": "overflow",
            "type": "OverflowMethod"
          },
          {
            "name": "crop",
            "type": "bool"
          },
          {
            "name": "indent_guides",
            "type": "bool"
          },
          {
            "name": "max_length",
            "type": "Optional[int]"
          },
          {
            "name": "max_string",
            "type": "Optional[int]"
          },
          {
            "name": "max_depth",
            "type": "Optional[int]"
          },
          {
            "name": "expand_all",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 171,
        "decorators": [],
        "is_async": false,
        "calls": [
          "RichFormatter",
          "max_depth",
          "RichRenderable",
          "max_length",
          "get_console",
          "crop",
          "rich_formatter",
          "max_string",
          "value",
          "expand_all",
          "_safe_isinstance",
          "indent_guides",
          "console.print",
          "overflow",
          "Pretty",
          "_ipy_display_hook",
          "get_ipython",
          "display_hook",
          "repr"
        ],
        "docstring": "Install automatic pretty printing in the Python REPL.\n\nArgs:\n    console (Console, optional): Console instance or ``None`` to use global console. Defaults to None.\n    overflow (Optional[OverflowMethod], optional): Overflow method. Defaults to \"ignore\".\n    crop (Optional[bool], optional): Enable cropping of long lines. Defaults to False.\n    indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n    max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to None.\n    max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n    max_depth (int, optional): Maximum depth of nested data structures, or None for no maximum. Defaults to None.\n    expand_all (bool, optional): Expand all containers. Defaults to False.\n    max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.",
        "code": "def install(\n    console: Optional[\"Console\"] = None,\n    overflow: \"OverflowMethod\" = \"ignore\",\n    crop: bool = False,\n    indent_guides: bool = False,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> None:\n    \"\"\"Install automatic pretty printing in the Python REPL.\n\n    Args:\n        console (Console, optional): Console instance or ``None`` to use global console. Defaults to None.\n        overflow (Optional[OverflowMethod], optional): Overflow method. Defaults to \"ignore\".\n        crop (Optional[bool], optional): Enable cropping of long lines. Defaults to False.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n        max_depth (int, optional): Maximum depth of nested data structures, or None for no maximum. Defaults to None.\n        expand_all (bool, optional): Expand all containers. Defaults to False.\n        max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n    \"\"\"\n    from rich import get_console\n\n    console = console or get_console()\n    assert console is not None\n\n    def display_hook(value: Any) -> None:\n        \"\"\"Replacement sys.displayhook which prettifies objects with Rich.\"\"\"\n        if value is not None:\n            assert console is not None\n            builtins._ = None  # type: ignore[attr-defined]\n            console.print(\n                (\n                    value\n                    if _safe_isinstance(value, RichRenderable)\n                    else Pretty(\n                        value,\n                        overflow=overflow,\n                        indent_guides=indent_guides,\n                        max_length=max_length,\n                        max_string=max_string,\n                        max_depth=max_depth,\n                        expand_all=expand_all,\n                    )\n                ),\n                crop=crop,\n            )\n            builtins._ = value  # type: ignore[attr-defined]\n\n    try:\n        ip = get_ipython()  # type: ignore[name-defined]\n    except NameError:\n        sys.displayhook = display_hook\n    else:\n        from IPython.core.formatters import BaseFormatter\n\n        class RichFormatter(BaseFormatter):  # type: ignore[misc]\n            pprint: bool = True\n\n            def __call__(self, value: Any) -> Any:\n                if self.pprint:\n                    return _ipy_display_hook(\n                        value,\n                        console=get_console(),\n                        overflow=overflow,\n                        indent_guides=indent_guides,\n                        max_length=max_length,\n                        max_string=max_string,\n                        max_depth=max_depth,\n                        expand_all=expand_all,\n                    )\n                else:\n                    return repr(value)\n\n        # replace plain text formatter with rich formatter\n        rich_formatter = RichFormatter()\n        ip.display_formatter.formatters[\"text/plain\"] = rich_formatter",
        "line_count": 80,
        "needs_llm_summary": true
      },
      {
        "name": "_get_braces_for_defaultdict",
        "args": [
          {
            "name": "_object",
            "type": "DefaultDict[Any, Any]"
          }
        ],
        "return_type": "Tuple[str, str, str]",
        "lineno": 357,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def _get_braces_for_defaultdict(_object: DefaultDict[Any, Any]) -> Tuple[str, str, str]:\n    return (\n        f\"defaultdict({_object.default_factory!r}, {{\",\n        \"})\",\n        f\"defaultdict({_object.default_factory!r}, {{}})\",\n    )",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "_get_braces_for_deque",
        "args": [
          {
            "name": "_object",
            "type": "Deque[Any]"
          }
        ],
        "return_type": "Tuple[str, str, str]",
        "lineno": 365,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def _get_braces_for_deque(_object: Deque[Any]) -> Tuple[str, str, str]:\n    if _object.maxlen is None:\n        return (\"deque([\", \"])\", \"deque()\")\n    return (\n        \"deque([\",\n        f\"], maxlen={_object.maxlen})\",\n        f\"deque(maxlen={_object.maxlen})\",\n    )",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "_get_braces_for_array",
        "args": [
          {
            "name": "_object",
            "type": "array[Any]"
          }
        ],
        "return_type": "Tuple[str, str, str]",
        "lineno": 375,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def _get_braces_for_array(_object: \"array[Any]\") -> Tuple[str, str, str]:\n    return (f\"array({_object.typecode!r}, [\", \"])\", f\"array({_object.typecode!r})\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "is_expandable",
        "args": [
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 398,
        "decorators": [],
        "is_async": false,
        "calls": [
          "obj",
          "_is_attr_object",
          "isclass",
          "_safe_isinstance",
          "_CONTAINERS",
          "hasattr",
          "is_dataclass"
        ],
        "docstring": "Check if an object may be expanded by pretty print.",
        "code": "def is_expandable(obj: Any) -> bool:\n    \"\"\"Check if an object may be expanded by pretty print.\"\"\"\n    return (\n        _safe_isinstance(obj, _CONTAINERS)\n        or (is_dataclass(obj))\n        or (hasattr(obj, \"__rich_repr__\"))\n        or _is_attr_object(obj)\n    ) and not isclass(obj)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "_is_namedtuple",
        "args": [
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 561,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "getattr",
          "obj",
          "fields",
          "tuple"
        ],
        "docstring": "Checks if an object is most likely a namedtuple. It is possible\nto craft an object that passes this check and isn't a namedtuple, but\nthere is only a minuscule chance of this happening unintentionally.\n\nArgs:\n    obj (Any): The object to test\n\nReturns:\n    bool: True if the object is a namedtuple. False otherwise.",
        "code": "def _is_namedtuple(obj: Any) -> bool:\n    \"\"\"Checks if an object is most likely a namedtuple. It is possible\n    to craft an object that passes this check and isn't a namedtuple, but\n    there is only a minuscule chance of this happening unintentionally.\n\n    Args:\n        obj (Any): The object to test\n\n    Returns:\n        bool: True if the object is a namedtuple. False otherwise.\n    \"\"\"\n    try:\n        fields = getattr(obj, \"_fields\", None)\n    except Exception:\n        # Being very defensive - if we cannot get the attr then its not a namedtuple\n        return False\n    return isinstance(obj, tuple) and isinstance(fields, tuple)",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "traverse",
        "args": [
          {
            "name": "_object",
            "type": "Any"
          },
          {
            "name": "max_length",
            "type": "Optional[int]"
          },
          {
            "name": "max_string",
            "type": "Optional[int]"
          },
          {
            "name": "max_depth",
            "type": "Optional[int]"
          }
        ],
        "return_type": "Node",
        "lineno": 580,
        "decorators": [],
        "is_async": false,
        "calls": [
          "callable",
          "enumerate",
          "rich_repr_result",
          "empty",
          "obj.items",
          "root",
          "visited_ids.add",
          "islice",
          "container_type",
          "fields",
          "max_length",
          "list",
          "loop_last",
          "type",
          "pop_visited",
          "children",
          "field.name",
          "child_node",
          "attr.name",
          "_object",
          "iter_rich_args",
          "iter_attrs",
          "repr_callable",
          "child",
          "key",
          "visited_ids.remove",
          "arg",
          "attr.repr",
          "obj_id",
          "children.append",
          "_MAPPING_CONTAINERS",
          "iter_values",
          "id",
          "repr",
          "unknown.items",
          "obj.__class__.__name__",
          "obj.__rich_repr__",
          "args",
          "close_brace",
          "_has_default_namedtuple_repr",
          "_is_dataclass_repr",
          "str",
          "append",
          "value",
          "name",
          "_safe_isinstance",
          "_CONTAINERS",
          "hasattr",
          "obj._asdict",
          "_is_namedtuple",
          "_get_attr_fields",
          "len",
          "is_dataclass",
          "open_brace",
          "getattr",
          "error",
          "obj",
          "iter_items",
          "_is_attr_object",
          "isclass",
          "set",
          "last",
          "iter",
          "to_repr",
          "tuple",
          "_traverse",
          "Node",
          "push_visited"
        ],
        "docstring": "Traverse object and generate a tree.\n\nArgs:\n    _object (Any): Object to be traversed.\n    max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to None.\n    max_string (int, optional): Maximum length of string before truncating, or None to disable truncating.\n        Defaults to None.\n    max_depth (int, optional): Maximum depth of data structures, or None for no maximum.\n        Defaults to None.\n\nReturns:\n    Node: The root of a tree structure which can be used to render a pretty repr.",
        "code": "def traverse(\n    _object: Any,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n) -> Node:\n    \"\"\"Traverse object and generate a tree.\n\n    Args:\n        _object (Any): Object to be traversed.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable truncating.\n            Defaults to None.\n        max_depth (int, optional): Maximum depth of data structures, or None for no maximum.\n            Defaults to None.\n\n    Returns:\n        Node: The root of a tree structure which can be used to render a pretty repr.\n    \"\"\"\n\n    def to_repr(obj: Any) -> str:\n        \"\"\"Get repr string for an object, but catch errors.\"\"\"\n        if (\n            max_string is not None\n            and _safe_isinstance(obj, (bytes, str))\n            and len(obj) > max_string\n        ):\n            truncated = len(obj) - max_string\n            obj_repr = f\"{obj[:max_string]!r}+{truncated}\"\n        else:\n            try:\n                obj_repr = repr(obj)\n            except Exception as error:\n                obj_repr = f\"<repr-error {str(error)!r}>\"\n        return obj_repr\n\n    visited_ids: Set[int] = set()\n    push_visited = visited_ids.add\n    pop_visited = visited_ids.remove\n\n    def _traverse(obj: Any, root: bool = False, depth: int = 0) -> Node:\n        \"\"\"Walk the object depth first.\"\"\"\n\n        obj_id = id(obj)\n        if obj_id in visited_ids:\n            # Recursion detected\n            return Node(value_repr=\"...\")\n\n        obj_type = type(obj)\n        children: List[Node]\n        reached_max_depth = max_depth is not None and depth >= max_depth\n\n        def iter_rich_args(rich_args: Any) -> Iterable[Union[Any, Tuple[str, Any]]]:\n            for arg in rich_args:\n                if _safe_isinstance(arg, tuple):\n                    if len(arg) == 3:\n                        key, child, default = arg\n                        if default == child:\n                            continue\n                        yield key, child\n                    elif len(arg) == 2:\n                        key, child = arg\n                        yield key, child\n                    elif len(arg) == 1:\n                        yield arg[0]\n                else:\n                    yield arg\n\n        try:\n            fake_attributes = hasattr(\n                obj, \"awehoi234_wdfjwljet234_234wdfoijsdfmmnxpi492\"\n            )\n        except Exception:\n            fake_attributes = False\n\n        rich_repr_result: Optional[RichReprResult] = None\n        if not fake_attributes:\n            try:\n                if hasattr(obj, \"__rich_repr__\") and not isclass(obj):\n                    rich_repr_result = obj.__rich_repr__()\n            except Exception:\n                pass\n\n        if rich_repr_result is not None:\n            push_visited(obj_id)\n            angular = getattr(obj.__rich_repr__, \"angular\", False)\n            args = list(iter_rich_args(rich_repr_result))\n            class_name = obj.__class__.__name__\n\n            if args:\n                children = []\n                append = children.append\n\n                if reached_max_depth:\n                    if angular:\n                        node = Node(value_repr=f\"<{class_name}...>\")\n                    else:\n                        node = Node(value_repr=f\"{class_name}(...)\")\n                else:\n                    if angular:\n                        node = Node(\n                            open_brace=f\"<{class_name} \",\n                            close_brace=\">\",\n                            children=children,\n                            last=root,\n                            separator=\" \",\n                        )\n                    else:\n                        node = Node(\n                            open_brace=f\"{class_name}(\",\n                            close_brace=\")\",\n                            children=children,\n                            last=root,\n                        )\n                    for last, arg in loop_last(args):\n                        if _safe_isinstance(arg, tuple):\n                            key, child = arg\n                            child_node = _traverse(child, depth=depth + 1)\n                            child_node.last = last\n                            child_node.key_repr = key\n                            child_node.key_separator = \"=\"\n                            append(child_node)\n                        else:\n                            child_node = _traverse(arg, depth=depth + 1)\n                            child_node.last = last\n                            append(child_node)\n            else:\n                node = Node(\n                    value_repr=f\"<{class_name}>\" if angular else f\"{class_name}()\",\n                    children=[],\n                    last=root,\n                )\n            pop_visited(obj_id)\n        elif _is_attr_object(obj) and not fake_attributes:\n            push_visited(obj_id)\n            children = []\n            append = children.append\n\n            attr_fields = _get_attr_fields(obj)\n            if attr_fields:\n                if reached_max_depth:\n                    node = Node(value_repr=f\"{obj.__class__.__name__}(...)\")\n                else:\n                    node = Node(\n                        open_brace=f\"{obj.__class__.__name__}(\",\n                        close_brace=\")\",\n                        children=children,\n                        last=root,\n                    )\n\n                    def iter_attrs() -> (\n                        Iterable[Tuple[str, Any, Optional[Callable[[Any], str]]]]\n                    ):\n                        \"\"\"Iterate over attr fields and values.\"\"\"\n                        for attr in attr_fields:\n                            if attr.repr:\n                                try:\n                                    value = getattr(obj, attr.name)\n                                except Exception as error:\n                                    # Can happen, albeit rarely\n                                    yield (attr.name, error, None)\n                                else:\n                                    yield (\n                                        attr.name,\n                                        value,\n                                        attr.repr if callable(attr.repr) else None,\n                                    )\n\n                    for last, (name, value, repr_callable) in loop_last(iter_attrs()):\n                        if repr_callable:\n                            child_node = Node(value_repr=str(repr_callable(value)))\n                        else:\n                            child_node = _traverse(value, depth=depth + 1)\n                        child_node.last = last\n                        child_node.key_repr = name\n                        child_node.key_separator = \"=\"\n                        append(child_node)\n            else:\n                node = Node(\n                    value_repr=f\"{obj.__class__.__name__}()\", children=[], last=root\n                )\n            pop_visited(obj_id)\n        elif (\n            is_dataclass(obj)\n            and not _safe_isinstance(obj, type)\n            and not fake_attributes\n            and _is_dataclass_repr(obj)\n        ):\n            push_visited(obj_id)\n            children = []\n            append = children.append\n            if reached_max_depth:\n                node = Node(value_repr=f\"{obj.__class__.__name__}(...)\")\n            else:\n                node = Node(\n                    open_brace=f\"{obj.__class__.__name__}(\",\n                    close_brace=\")\",\n                    children=children,\n                    last=root,\n                    empty=f\"{obj.__class__.__name__}()\",\n                )\n\n                for last, field in loop_last(\n                    field\n                    for field in fields(obj)\n                    if field.repr and hasattr(obj, field.name)\n                ):\n                    child_node = _traverse(getattr(obj, field.name), depth=depth + 1)\n                    child_node.key_repr = field.name\n                    child_node.last = last\n                    child_node.key_separator = \"=\"\n                    append(child_node)\n\n            pop_visited(obj_id)\n        elif _is_namedtuple(obj) and _has_default_namedtuple_repr(obj):\n            push_visited(obj_id)\n            class_name = obj.__class__.__name__\n            if reached_max_depth:\n                # If we've reached the max depth, we still show the class name, but not its contents\n                node = Node(\n                    value_repr=f\"{class_name}(...)\",\n                )\n            else:\n                children = []\n                append = children.append\n                node = Node(\n                    open_brace=f\"{class_name}(\",\n                    close_brace=\")\",\n                    children=children,\n                    empty=f\"{class_name}()\",\n                )\n                for last, (key, value) in loop_last(obj._asdict().items()):\n                    child_node = _traverse(value, depth=depth + 1)\n                    child_node.key_repr = key\n                    child_node.last = last\n                    child_node.key_separator = \"=\"\n                    append(child_node)\n            pop_visited(obj_id)\n        elif _safe_isinstance(obj, _CONTAINERS):\n            for container_type in _CONTAINERS:\n                if _safe_isinstance(obj, container_type):\n                    obj_type = container_type\n                    break\n\n            push_visited(obj_id)\n\n            open_brace, close_brace, empty = _BRACES[obj_type](obj)\n\n            if reached_max_depth:\n                node = Node(value_repr=f\"{open_brace}...{close_brace}\")\n            elif obj_type.__repr__ != type(obj).__repr__:\n                node = Node(value_repr=to_repr(obj), last=root)\n            elif obj:\n                children = []\n                node = Node(\n                    open_brace=open_brace,\n                    close_brace=close_brace,\n                    children=children,\n                    last=root,\n                )\n                append = children.append\n                num_items = len(obj)\n                last_item_index = num_items - 1\n\n                if _safe_isinstance(obj, _MAPPING_CONTAINERS):\n                    iter_items = iter(obj.items())\n                    if max_length is not None:\n                        iter_items = islice(iter_items, max_length)\n                    for index, (key, child) in enumerate(iter_items):\n                        child_node = _traverse(child, depth=depth + 1)\n                        child_node.key_repr = to_repr(key)\n                        child_node.last = index == last_item_index\n                        append(child_node)\n                else:\n                    iter_values = iter(obj)\n                    if max_length is not None:\n                        iter_values = islice(iter_values, max_length)\n                    for index, child in enumerate(iter_values):\n                        child_node = _traverse(child, depth=depth + 1)\n                        child_node.last = index == last_item_index\n                        append(child_node)\n                if max_length is not None and num_items > max_length:\n                    append(Node(value_repr=f\"... +{num_items - max_length}\", last=True))\n            else:\n                node = Node(empty=empty, children=[], last=root)\n\n            pop_visited(obj_id)\n        else:\n            node = Node(value_repr=to_repr(obj), last=root)\n        node.is_tuple = type(obj) == tuple\n        node.is_namedtuple = _is_namedtuple(obj)\n        return node\n\n    node = _traverse(_object, root=True)\n    return node",
        "line_count": 296,
        "needs_llm_summary": true
      },
      {
        "name": "pretty_repr",
        "args": [
          {
            "name": "_object",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 878,
        "decorators": [],
        "is_async": false,
        "calls": [
          "expand_all",
          "max_depth",
          "Node",
          "indent_size",
          "_safe_isinstance",
          "max_length",
          "traverse",
          "max_width",
          "_object",
          "node.render",
          "max_string"
        ],
        "docstring": "Prettify repr string by expanding on to new lines to fit within a given width.\n\nArgs:\n    _object (Any): Object to repr.\n    max_width (int, optional): Desired maximum width of repr string. Defaults to 80.\n    indent_size (int, optional): Number of spaces to indent. Defaults to 4.\n    max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to None.\n    max_string (int, optional): Maximum length of string before truncating, or None to disable truncating.\n        Defaults to None.\n    max_depth (int, optional): Maximum depth of nested data structure, or None for no depth.\n        Defaults to None.\n    expand_all (bool, optional): Expand all containers regardless of available width. Defaults to False.\n\nReturns:\n    str: A possibly multi-line representation of the object.",
        "code": "def pretty_repr(\n    _object: Any,\n    *,\n    max_width: int = 80,\n    indent_size: int = 4,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> str:\n    \"\"\"Prettify repr string by expanding on to new lines to fit within a given width.\n\n    Args:\n        _object (Any): Object to repr.\n        max_width (int, optional): Desired maximum width of repr string. Defaults to 80.\n        indent_size (int, optional): Number of spaces to indent. Defaults to 4.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable truncating.\n            Defaults to None.\n        max_depth (int, optional): Maximum depth of nested data structure, or None for no depth.\n            Defaults to None.\n        expand_all (bool, optional): Expand all containers regardless of available width. Defaults to False.\n\n    Returns:\n        str: A possibly multi-line representation of the object.\n    \"\"\"\n\n    if _safe_isinstance(_object, Node):\n        node = _object\n    else:\n        node = traverse(\n            _object, max_length=max_length, max_string=max_string, max_depth=max_depth\n        )\n    repr_str: str = node.render(\n        max_width=max_width, indent_size=indent_size, expand_all=expand_all\n    )\n    return repr_str",
        "line_count": 38,
        "needs_llm_summary": true
      },
      {
        "name": "pprint",
        "args": [
          {
            "name": "_object",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 918,
        "decorators": [],
        "is_async": false,
        "calls": [
          "max_depth",
          "expand_all",
          "Pretty",
          "max_length",
          "get_console",
          "indent_guides",
          "_console.print",
          "_object",
          "max_string"
        ],
        "docstring": "A convenience function for pretty printing.\n\nArgs:\n    _object (Any): Object to pretty print.\n    console (Console, optional): Console instance, or None to use default. Defaults to None.\n    max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to None.\n    max_string (int, optional): Maximum length of strings before truncating, or None to disable. Defaults to None.\n    max_depth (int, optional): Maximum depth for nested data structures, or None for unlimited depth. Defaults to None.\n    indent_guides (bool, optional): Enable indentation guides. Defaults to True.\n    expand_all (bool, optional): Expand all containers. Defaults to False.",
        "code": "def pprint(\n    _object: Any,\n    *,\n    console: Optional[\"Console\"] = None,\n    indent_guides: bool = True,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> None:\n    \"\"\"A convenience function for pretty printing.\n\n    Args:\n        _object (Any): Object to pretty print.\n        console (Console, optional): Console instance, or None to use default. Defaults to None.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of strings before truncating, or None to disable. Defaults to None.\n        max_depth (int, optional): Maximum depth for nested data structures, or None for unlimited depth. Defaults to None.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to True.\n        expand_all (bool, optional): Expand all containers. Defaults to False.\n    \"\"\"\n    _console = get_console() if console is None else console\n    _console.print(\n        Pretty(\n            _object,\n            max_length=max_length,\n            max_string=max_string,\n            max_depth=max_depth,\n            indent_guides=indent_guides,\n            expand_all=expand_all,\n            overflow=\"ignore\",\n        ),\n        soft_wrap=True,\n    )",
        "line_count": 35,
        "needs_llm_summary": true
      },
      {
        "name": "display_hook",
        "args": [
          {
            "name": "value",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 200,
        "decorators": [],
        "is_async": false,
        "calls": [
          "console.print",
          "value",
          "overflow",
          "max_depth",
          "Pretty",
          "expand_all",
          "_safe_isinstance",
          "RichRenderable",
          "max_length",
          "indent_guides",
          "crop",
          "max_string"
        ],
        "docstring": "Replacement sys.displayhook which prettifies objects with Rich.",
        "code": "def display_hook(value: Any) -> None:\n        \"\"\"Replacement sys.displayhook which prettifies objects with Rich.\"\"\"\n        if value is not None:\n            assert console is not None\n            builtins._ = None  # type: ignore[attr-defined]\n            console.print(\n                (\n                    value\n                    if _safe_isinstance(value, RichRenderable)\n                    else Pretty(\n                        value,\n                        overflow=overflow,\n                        indent_guides=indent_guides,\n                        max_length=max_length,\n                        max_string=max_string,\n                        max_depth=max_depth,\n                        expand_all=expand_all,\n                    )\n                ),\n                crop=crop,\n            )\n            builtins._ = value",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "_object",
            "type": "Any"
          },
          {
            "name": "highlighter",
            "type": "Optional[HighlighterType]"
          }
        ],
        "return_type": "None",
        "lineno": 273,
        "decorators": [],
        "is_async": false,
        "calls": [
          "no_wrap",
          "max_depth",
          "expand_all",
          "indent_size",
          "insert_line",
          "max_length",
          "indent_guides",
          "ReprHighlighter",
          "_object",
          "margin",
          "max_string"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        _object: Any,\n        highlighter: Optional[\"HighlighterType\"] = None,\n        *,\n        indent_size: int = 4,\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = False,\n        indent_guides: bool = False,\n        max_length: Optional[int] = None,\n        max_string: Optional[int] = None,\n        max_depth: Optional[int] = None,\n        expand_all: bool = False,\n        margin: int = 0,\n        insert_line: bool = False,\n    ) -> None:\n        self._object = _object\n        self.highlighter = highlighter or ReprHighlighter()\n        self.indent_size = indent_size\n        self.justify: Optional[\"JustifyMethod\"] = justify\n        self.overflow: Optional[\"OverflowMethod\"] = overflow\n        self.no_wrap = no_wrap\n        self.indent_guides = indent_guides\n        self.max_length = max_length\n        self.max_string = max_string\n        self.max_depth = max_depth\n        self.expand_all = expand_all\n        self.margin = margin\n        self.insert_line = insert_line",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 304,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.indent_size",
          "pretty_str",
          "pretty_repr",
          "self._object",
          "self.expand_all",
          "options.no_wrap",
          "pretty_text.with_indent_guides",
          "self.max_length",
          "self.highlighter",
          "self.no_wrap",
          "self.max_string",
          "self.max_depth",
          "Text.from_ansi",
          "pick_bool",
          "type",
          "Text",
          "pretty_text"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        pretty_str = pretty_repr(\n            self._object,\n            max_width=options.max_width - self.margin,\n            indent_size=self.indent_size,\n            max_length=self.max_length,\n            max_string=self.max_string,\n            max_depth=self.max_depth,\n            expand_all=self.expand_all,\n        )\n        pretty_text = Text.from_ansi(\n            pretty_str,\n            justify=self.justify or options.justify,\n            overflow=self.overflow or options.overflow,\n            no_wrap=pick_bool(self.no_wrap, options.no_wrap),\n            style=\"pretty\",\n        )\n        pretty_text = (\n            self.highlighter(pretty_text)\n            if pretty_text\n            else Text(\n                f\"{type(self._object)}.__repr__ returned empty string\",\n                style=\"dim italic\",\n            )\n        )\n        if self.indent_guides and not options.ascii_only:\n            pretty_text = pretty_text.with_indent_guides(\n                self.indent_size, style=\"repr.indent\"\n            )\n        if self.insert_line and \"\\n\" in pretty_text:\n            yield \"\"\n        yield pretty_text",
        "line_count": 34,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 339,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.indent_size",
          "pretty_str.splitlines",
          "max",
          "options.max_width",
          "Measurement",
          "line",
          "pretty_repr",
          "self._object",
          "self.expand_all",
          "self.max_length",
          "text_width",
          "self.max_string",
          "self.max_depth",
          "cell_len"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        pretty_str = pretty_repr(\n            self._object,\n            max_width=options.max_width,\n            indent_size=self.indent_size,\n            max_length=self.max_length,\n            max_string=self.max_string,\n            max_depth=self.max_depth,\n            expand_all=self.expand_all,\n        )\n        text_width = (\n            max(cell_len(line) for line in pretty_str.splitlines()) if pretty_str else 0\n        )\n        return Measurement(text_width, text_width)",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "iter_tokens",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Iterable[str]",
        "lineno": 424,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.iter_tokens",
          "self.children",
          "len",
          "child.iter_tokens"
        ],
        "docstring": "Generate tokens for this node.",
        "code": "def iter_tokens(self) -> Iterable[str]:\n        \"\"\"Generate tokens for this node.\"\"\"\n        if self.key_repr:\n            yield self.key_repr\n            yield self.key_separator\n        if self.value_repr:\n            yield self.value_repr\n        elif self.children is not None:\n            if self.children:\n                yield self.open_brace\n                if self.is_tuple and not self.is_namedtuple and len(self.children) == 1:\n                    yield from self.children[0].iter_tokens()\n                    yield \",\"\n                else:\n                    for child in self.children:\n                        yield from child.iter_tokens()\n                        if not child.last:\n                            yield self.separator\n                yield self.close_brace\n            else:\n                yield self.empty",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "check_length",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "start_length",
            "type": "int"
          },
          {
            "name": "max_length",
            "type": "int"
          }
        ],
        "return_type": "bool",
        "lineno": 446,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.iter_tokens",
          "start_length",
          "cell_len",
          "token"
        ],
        "docstring": "Check the length fits within a limit.\n\nArgs:\n    start_length (int): Starting length of the line (indent, prefix, suffix).\n    max_length (int): Maximum length.\n\nReturns:\n    bool: True if the node can be rendered within max length, otherwise False.",
        "code": "def check_length(self, start_length: int, max_length: int) -> bool:\n        \"\"\"Check the length fits within a limit.\n\n        Args:\n            start_length (int): Starting length of the line (indent, prefix, suffix).\n            max_length (int): Maximum length.\n\n        Returns:\n            bool: True if the node can be rendered within max length, otherwise False.\n        \"\"\"\n        total_length = start_length\n        for token in self.iter_tokens():\n            total_length += cell_len(token)\n            if total_length > max_length:\n                return False\n        return True",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 463,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.join",
          "self.iter_tokens"
        ],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        repr_text = \"\".join(self.iter_tokens())\n        return repr_text",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "max_width",
            "type": "int"
          },
          {
            "name": "indent_size",
            "type": "int"
          },
          {
            "name": "expand_all",
            "type": "bool"
          }
        ],
        "return_type": "str",
        "lineno": 467,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "str",
          "line.expand",
          "line",
          "indent_size",
          "unknown.join",
          "_Line",
          "max_width",
          "line.check_length",
          "len",
          "self"
        ],
        "docstring": "Render the node to a pretty repr.\n\nArgs:\n    max_width (int, optional): Maximum width of the repr. Defaults to 80.\n    indent_size (int, optional): Size of indents. Defaults to 4.\n    expand_all (bool, optional): Expand all levels. Defaults to False.\n\nReturns:\n    str: A repr string of the original object.",
        "code": "def render(\n        self, max_width: int = 80, indent_size: int = 4, expand_all: bool = False\n    ) -> str:\n        \"\"\"Render the node to a pretty repr.\n\n        Args:\n            max_width (int, optional): Maximum width of the repr. Defaults to 80.\n            indent_size (int, optional): Size of indents. Defaults to 4.\n            expand_all (bool, optional): Expand all levels. Defaults to False.\n\n        Returns:\n            str: A repr string of the original object.\n        \"\"\"\n        lines = [_Line(node=self, is_root=True)]\n        line_no = 0\n        while line_no < len(lines):\n            line = lines[line_no]\n            if line.expandable and not line.expanded:\n                if expand_all or not line.check_length(max_width):\n                    lines[line_no : line_no + 1] = line.expand(indent_size)\n            line_no += 1\n\n        repr_str = \"\\n\".join(str(line) for line in lines)\n        return repr_str",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "expandable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 507,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "bool"
        ],
        "docstring": "Check if the line may be expanded.",
        "code": "def expandable(self) -> bool:\n        \"\"\"Check if the line may be expanded.\"\"\"\n        return bool(self.node is not None and self.node.children)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "check_length",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "max_length",
            "type": "int"
          }
        ],
        "return_type": "bool",
        "lineno": 511,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.suffix",
          "len",
          "self.text",
          "start_length",
          "self.node.check_length",
          "max_length",
          "self.whitespace",
          "cell_len"
        ],
        "docstring": "Check this line fits within a given number of cells.",
        "code": "def check_length(self, max_length: int) -> bool:\n        \"\"\"Check this line fits within a given number of cells.\"\"\"\n        start_length = (\n            len(self.whitespace) + cell_len(self.text) + cell_len(self.suffix)\n        )\n        assert self.node is not None\n        return self.node.check_length(start_length, max_length)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "expand",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "indent_size",
            "type": "int"
          }
        ],
        "return_type": "Iterable[_Line]",
        "lineno": 519,
        "decorators": [],
        "is_async": false,
        "calls": [
          "child",
          "self.suffix",
          "len",
          "whitespace",
          "self.last",
          "self.node",
          "new_line",
          "_Line",
          "child_whitespace",
          "self.whitespace",
          "node.children",
          "node.open_brace",
          "node.close_brace",
          "loop_last",
          "separator"
        ],
        "docstring": "Expand this line by adding children on their own line.",
        "code": "def expand(self, indent_size: int) -> Iterable[\"_Line\"]:\n        \"\"\"Expand this line by adding children on their own line.\"\"\"\n        node = self.node\n        assert node is not None\n        whitespace = self.whitespace\n        assert node.children\n        if node.key_repr:\n            new_line = yield _Line(\n                text=f\"{node.key_repr}{node.key_separator}{node.open_brace}\",\n                whitespace=whitespace,\n            )\n        else:\n            new_line = yield _Line(text=node.open_brace, whitespace=whitespace)\n        child_whitespace = self.whitespace + \" \" * indent_size\n        tuple_of_one = node.is_tuple and len(node.children) == 1\n        for last, child in loop_last(node.children):\n            separator = \",\" if tuple_of_one else node.separator\n            line = _Line(\n                parent=new_line,\n                node=child,\n                whitespace=child_whitespace,\n                suffix=separator,\n                last=last and not tuple_of_one,\n            )\n            yield line\n\n        yield _Line(\n            text=node.close_brace,\n            whitespace=whitespace,\n            suffix=self.suffix,\n            last=self.last,\n        )",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 552,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.suffix.rstrip"
        ],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        if self.last:\n            return f\"{self.whitespace}{self.text}{self.node or ''}\"\n        else:\n            return (\n                f\"{self.whitespace}{self.text}{self.node or ''}{self.suffix.rstrip()}\"\n            )",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "to_repr",
        "args": [
          {
            "name": "obj",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 601,
        "decorators": [],
        "is_async": false,
        "calls": [
          "str",
          "error",
          "obj",
          "_safe_isinstance",
          "repr",
          "len"
        ],
        "docstring": "Get repr string for an object, but catch errors.",
        "code": "def to_repr(obj: Any) -> str:\n        \"\"\"Get repr string for an object, but catch errors.\"\"\"\n        if (\n            max_string is not None\n            and _safe_isinstance(obj, (bytes, str))\n            and len(obj) > max_string\n        ):\n            truncated = len(obj) - max_string\n            obj_repr = f\"{obj[:max_string]!r}+{truncated}\"\n        else:\n            try:\n                obj_repr = repr(obj)\n            except Exception as error:\n                obj_repr = f\"<repr-error {str(error)!r}>\"\n        return obj_repr",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "_traverse",
        "args": [
          {
            "name": "obj",
            "type": "Any"
          },
          {
            "name": "root",
            "type": "bool"
          },
          {
            "name": "depth",
            "type": "int"
          }
        ],
        "return_type": "Node",
        "lineno": 621,
        "decorators": [],
        "is_async": false,
        "calls": [
          "callable",
          "enumerate",
          "rich_repr_result",
          "empty",
          "obj.items",
          "root",
          "islice",
          "_traverse",
          "container_type",
          "fields",
          "max_length",
          "list",
          "loop_last",
          "type",
          "pop_visited",
          "children",
          "field.name",
          "child_node",
          "attr.name",
          "iter_rich_args",
          "iter_attrs",
          "repr_callable",
          "child",
          "key",
          "arg",
          "attr.repr",
          "obj_id",
          "children.append",
          "_MAPPING_CONTAINERS",
          "iter_values",
          "id",
          "unknown.items",
          "obj.__rich_repr__",
          "args",
          "close_brace",
          "_has_default_namedtuple_repr",
          "_is_dataclass_repr",
          "append",
          "value",
          "str",
          "name",
          "_safe_isinstance",
          "_CONTAINERS",
          "hasattr",
          "obj._asdict",
          "_is_namedtuple",
          "_get_attr_fields",
          "is_dataclass",
          "len",
          "open_brace",
          "getattr",
          "iter_items",
          "obj",
          "_is_attr_object",
          "isclass",
          "last",
          "iter",
          "to_repr",
          "tuple",
          "obj.__class__.__name__",
          "Node",
          "push_visited"
        ],
        "docstring": "Walk the object depth first.",
        "code": "def _traverse(obj: Any, root: bool = False, depth: int = 0) -> Node:\n        \"\"\"Walk the object depth first.\"\"\"\n\n        obj_id = id(obj)\n        if obj_id in visited_ids:\n            # Recursion detected\n            return Node(value_repr=\"...\")\n\n        obj_type = type(obj)\n        children: List[Node]\n        reached_max_depth = max_depth is not None and depth >= max_depth\n\n        def iter_rich_args(rich_args: Any) -> Iterable[Union[Any, Tuple[str, Any]]]:\n            for arg in rich_args:\n                if _safe_isinstance(arg, tuple):\n                    if len(arg) == 3:\n                        key, child, default = arg\n                        if default == child:\n                            continue\n                        yield key, child\n                    elif len(arg) == 2:\n                        key, child = arg\n                        yield key, child\n                    elif len(arg) == 1:\n                        yield arg[0]\n                else:\n                    yield arg\n\n        try:\n            fake_attributes = hasattr(\n                obj, \"awehoi234_wdfjwljet234_234wdfoijsdfmmnxpi492\"\n            )\n        except Exception:\n            fake_attributes = False\n\n        rich_repr_result: Optional[RichReprResult] = None\n        if not fake_attributes:\n            try:\n                if hasattr(obj, \"__rich_repr__\") and not isclass(obj):\n                    rich_repr_result = obj.__rich_repr__()\n            except Exception:\n                pass\n\n        if rich_repr_result is not None:\n            push_visited(obj_id)\n            angular = getattr(obj.__rich_repr__, \"angular\", False)\n            args = list(iter_rich_args(rich_repr_result))\n            class_name = obj.__class__.__name__\n\n            if args:\n                children = []\n                append = children.append\n\n                if reached_max_depth:\n                    if angular:\n                        node = Node(value_repr=f\"<{class_name}...>\")\n                    else:\n                        node = Node(value_repr=f\"{class_name}(...)\")\n                else:\n                    if angular:\n                        node = Node(\n                            open_brace=f\"<{class_name} \",\n                            close_brace=\">\",\n                            children=children,\n                            last=root,\n                            separator=\" \",\n                        )\n                    else:\n                        node = Node(\n                            open_brace=f\"{class_name}(\",\n                            close_brace=\")\",\n                            children=children,\n                            last=root,\n                        )\n                    for last, arg in loop_last(args):\n                        if _safe_isinstance(arg, tuple):\n                            key, child = arg\n                            child_node = _traverse(child, depth=depth + 1)\n                            child_node.last = last\n                            child_node.key_repr = key\n                            child_node.key_separator = \"=\"\n                            append(child_node)\n                        else:\n                            child_node = _traverse(arg, depth=depth + 1)\n                            child_node.last = last\n                            append(child_node)\n            else:\n                node = Node(\n                    value_repr=f\"<{class_name}>\" if angular else f\"{class_name}()\",\n                    children=[],\n                    last=root,\n                )\n            pop_visited(obj_id)\n        elif _is_attr_object(obj) and not fake_attributes:\n            push_visited(obj_id)\n            children = []\n            append = children.append\n\n            attr_fields = _get_attr_fields(obj)\n            if attr_fields:\n                if reached_max_depth:\n                    node = Node(value_repr=f\"{obj.__class__.__name__}(...)\")\n                else:\n                    node = Node(\n                        open_brace=f\"{obj.__class__.__name__}(\",\n                        close_brace=\")\",\n                        children=children,\n                        last=root,\n                    )\n\n                    def iter_attrs() -> (\n                        Iterable[Tuple[str, Any, Optional[Callable[[Any], str]]]]\n                    ):\n                        \"\"\"Iterate over attr fields and values.\"\"\"\n                        for attr in attr_fields:\n                            if attr.repr:\n                                try:\n                                    value = getattr(obj, attr.name)\n                                except Exception as error:\n                                    # Can happen, albeit rarely\n                                    yield (attr.name, error, None)\n                                else:\n                                    yield (\n                                        attr.name,\n                                        value,\n                                        attr.repr if callable(attr.repr) else None,\n                                    )\n\n                    for last, (name, value, repr_callable) in loop_last(iter_attrs()):\n                        if repr_callable:\n                            child_node = Node(value_repr=str(repr_callable(value)))\n                        else:\n                            child_node = _traverse(value, depth=depth + 1)\n                        child_node.last = last\n                        child_node.key_repr = name\n                        child_node.key_separator = \"=\"\n                        append(child_node)\n            else:\n                node = Node(\n                    value_repr=f\"{obj.__class__.__name__}()\", children=[], last=root\n                )\n            pop_visited(obj_id)\n        elif (\n            is_dataclass(obj)\n            and not _safe_isinstance(obj, type)\n            and not fake_attributes\n            and _is_dataclass_repr(obj)\n        ):\n            push_visited(obj_id)\n            children = []\n            append = children.append\n            if reached_max_depth:\n                node = Node(value_repr=f\"{obj.__class__.__name__}(...)\")\n            else:\n                node = Node(\n                    open_brace=f\"{obj.__class__.__name__}(\",\n                    close_brace=\")\",\n                    children=children,\n                    last=root,\n                    empty=f\"{obj.__class__.__name__}()\",\n                )\n\n                for last, field in loop_last(\n                    field\n                    for field in fields(obj)\n                    if field.repr and hasattr(obj, field.name)\n                ):\n                    child_node = _traverse(getattr(obj, field.name), depth=depth + 1)\n                    child_node.key_repr = field.name\n                    child_node.last = last\n                    child_node.key_separator = \"=\"\n                    append(child_node)\n\n            pop_visited(obj_id)\n        elif _is_namedtuple(obj) and _has_default_namedtuple_repr(obj):\n            push_visited(obj_id)\n            class_name = obj.__class__.__name__\n            if reached_max_depth:\n                # If we've reached the max depth, we still show the class name, but not its contents\n                node = Node(\n                    value_repr=f\"{class_name}(...)\",\n                )\n            else:\n                children = []\n                append = children.append\n                node = Node(\n                    open_brace=f\"{class_name}(\",\n                    close_brace=\")\",\n                    children=children,\n                    empty=f\"{class_name}()\",\n                )\n                for last, (key, value) in loop_last(obj._asdict().items()):\n                    child_node = _traverse(value, depth=depth + 1)\n                    child_node.key_repr = key\n                    child_node.last = last\n                    child_node.key_separator = \"=\"\n                    append(child_node)\n            pop_visited(obj_id)\n        elif _safe_isinstance(obj, _CONTAINERS):\n            for container_type in _CONTAINERS:\n                if _safe_isinstance(obj, container_type):\n                    obj_type = container_type\n                    break\n\n            push_visited(obj_id)\n\n            open_brace, close_brace, empty = _BRACES[obj_type](obj)\n\n            if reached_max_depth:\n                node = Node(value_repr=f\"{open_brace}...{close_brace}\")\n            elif obj_type.__repr__ != type(obj).__repr__:\n                node = Node(value_repr=to_repr(obj), last=root)\n            elif obj:\n                children = []\n                node = Node(\n                    open_brace=open_brace,\n                    close_brace=close_brace,\n                    children=children,\n                    last=root,\n                )\n                append = children.append\n                num_items = len(obj)\n                last_item_index = num_items - 1\n\n                if _safe_isinstance(obj, _MAPPING_CONTAINERS):\n                    iter_items = iter(obj.items())\n                    if max_length is not None:\n                        iter_items = islice(iter_items, max_length)\n                    for index, (key, child) in enumerate(iter_items):\n                        child_node = _traverse(child, depth=depth + 1)\n                        child_node.key_repr = to_repr(key)\n                        child_node.last = index == last_item_index\n                        append(child_node)\n                else:\n                    iter_values = iter(obj)\n                    if max_length is not None:\n                        iter_values = islice(iter_values, max_length)\n                    for index, child in enumerate(iter_values):\n                        child_node = _traverse(child, depth=depth + 1)\n                        child_node.last = index == last_item_index\n                        append(child_node)\n                if max_length is not None and num_items > max_length:\n                    append(Node(value_repr=f\"... +{num_items - max_length}\", last=True))\n            else:\n                node = Node(empty=empty, children=[], last=root)\n\n            pop_visited(obj_id)\n        else:\n            node = Node(value_repr=to_repr(obj), last=root)\n        node.is_tuple = type(obj) == tuple\n        node.is_namedtuple = _is_namedtuple(obj)\n        return node",
        "line_count": 252,
        "needs_llm_summary": true
      },
      {
        "name": "iter_rich_args",
        "args": [
          {
            "name": "rich_args",
            "type": "Any"
          }
        ],
        "return_type": "Iterable[Union[Any, Tuple[str, Any]]]",
        "lineno": 633,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_safe_isinstance",
          "tuple",
          "len",
          "arg"
        ],
        "docstring": null,
        "code": "def iter_rich_args(rich_args: Any) -> Iterable[Union[Any, Tuple[str, Any]]]:\n            for arg in rich_args:\n                if _safe_isinstance(arg, tuple):\n                    if len(arg) == 3:\n                        key, child, default = arg\n                        if default == child:\n                            continue\n                        yield key, child\n                    elif len(arg) == 2:\n                        key, child = arg\n                        yield key, child\n                    elif len(arg) == 1:\n                        yield arg[0]\n                else:\n                    yield arg",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 958,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n            1 / 0\n            return \"this will fail\"",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 1013,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n            return \"Hello\\x1b[38;5;239m World!\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "Any"
          }
        ],
        "return_type": "Any",
        "lineno": 233,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value",
          "overflow",
          "max_depth",
          "expand_all",
          "_ipy_display_hook",
          "max_length",
          "indent_guides",
          "get_console",
          "repr",
          "max_string"
        ],
        "docstring": null,
        "code": "def __call__(self, value: Any) -> Any:\n                if self.pprint:\n                    return _ipy_display_hook(\n                        value,\n                        console=get_console(),\n                        overflow=overflow,\n                        indent_guides=indent_guides,\n                        max_length=max_length,\n                        max_string=max_string,\n                        max_depth=max_depth,\n                        expand_all=expand_all,\n                    )\n                else:\n                    return repr(value)",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "iter_attrs",
        "args": [],
        "return_type": "Iterable[Tuple[str, Any, Optional[Callable[Any, str]]]]",
        "lineno": 731,
        "decorators": [],
        "is_async": false,
        "calls": [
          "callable",
          "getattr",
          "obj",
          "attr.repr",
          "attr.name"
        ],
        "docstring": "Iterate over attr fields and values.",
        "code": "def iter_attrs() -> (\n                        Iterable[Tuple[str, Any, Optional[Callable[[Any], str]]]]\n                    ):\n                        \"\"\"Iterate over attr fields and values.\"\"\"\n                        for attr in attr_fields:\n                            if attr.repr:\n                                try:\n                                    value = getattr(obj, attr.name)\n                                except Exception as error:\n                                    # Can happen, albeit rarely\n                                    yield (attr.name, error, None)\n                                else:\n                                    yield (\n                                        attr.name,\n                                        value,\n                                        attr.repr if callable(attr.repr) else None,\n                                    )",
        "line_count": 17,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Pretty",
        "methods": [
          "__init__",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 253,
        "docstring": "A rich renderable that pretty prints an object.\n\nArgs:\n    _object (Any): An object to pretty print.\n    highlighter (HighlighterType, optional): Highlighter object to apply to result, or None for ReprHighlighter. Defaults to None.\n    indent_size (int, optional): Number of spaces in indent. Defaults to 4.\n    justify (JustifyMethod, optional): Justify method, or None for default. Defaults to None.\n    overflow (OverflowMethod, optional): Overflow method, or None for default. Defaults to None.\n    no_wrap (Optional[bool], optional): Disable word wrapping. Defaults to False.\n    indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n    max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to None.\n    max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n    max_depth (int, optional): Maximum depth of nested data structures, or None for no maximum. Defaults to None.\n    expand_all (bool, optional): Expand all containers. Defaults to False.\n    margin (int, optional): Subtrace a margin from width to force containers to expand earlier. Defaults to 0.\n    insert_line (bool, optional): Insert a new line if the output has multiple new lines. Defaults to False."
      },
      {
        "name": "Node",
        "methods": [
          "iter_tokens",
          "check_length",
          "__str__",
          "render"
        ],
        "base_classes": [],
        "lineno": 409,
        "docstring": "A node in a repr tree. May be atomic or a container."
      },
      {
        "name": "_Line",
        "methods": [
          "expandable",
          "check_length",
          "expand",
          "__str__"
        ],
        "base_classes": [],
        "lineno": 494,
        "docstring": "A line in repr output."
      },
      {
        "name": "BrokenRepr",
        "methods": [
          "__repr__"
        ],
        "base_classes": [],
        "lineno": 957,
        "docstring": null
      },
      {
        "name": "StockKeepingUnit",
        "methods": [],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 964,
        "docstring": null
      },
      {
        "name": "Thing",
        "methods": [
          "__repr__"
        ],
        "base_classes": [],
        "lineno": 1012,
        "docstring": null
      },
      {
        "name": "RichFormatter",
        "methods": [
          "__call__"
        ],
        "base_classes": [
          "BaseFormatter"
        ],
        "lineno": 230,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "builtins",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "collections",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "dataclasses",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "inspect",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "reprlib",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 7,
        "type": "import"
      },
      {
        "module": "array",
        "name": "array",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "collections",
        "name": "Counter",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "collections",
        "name": "UserDict",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "collections",
        "name": "UserList",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "collections",
        "name": "defaultdict",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "collections",
        "name": "deque",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "dataclass",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "fields",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "is_dataclass",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "name": "isclass",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "itertools",
        "name": "islice",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "MappingProxyType",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "DefaultDict",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Deque",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Set",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "rich.repr",
        "name": "RichReprResult",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "get_console",
        "alias": null,
        "lineno": 39,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 40,
        "type": "from_import"
      },
      {
        "module": "_pick",
        "name": "pick_bool",
        "alias": null,
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "abc",
        "name": "RichRenderable",
        "alias": null,
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterRenderable",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "attr",
        "alias": "_attr_module",
        "lineno": 33,
        "type": "import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "HighlighterType",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "JustifyMethod",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "OverflowMethod",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleRenderable",
        "alias": null,
        "lineno": 125,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "get_console",
        "alias": null,
        "lineno": 195,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 962,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 1008,
        "type": "from_import"
      },
      {
        "module": "IPython.core.formatters",
        "name": "BaseFormatter",
        "alias": null,
        "lineno": 228,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "_dummy_namedtuple",
        "assigned_to": "collections.namedtuple",
        "lineno": 90
      },
      {
        "name": "_CONTAINERS",
        "assigned_to": "tuple",
        "lineno": 394
      },
      {
        "name": "_MAPPING_CONTAINERS",
        "assigned_to": null,
        "lineno": 395
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "Thing",
      "Pretty",
      "StockKeepingUnit",
      "Counter",
      "BrokenRepr",
      "frozenset",
      "unknown.append",
      "defaultdict",
      "print"
    ],
    "module_level_calls": {
      "function_calls": [
        "Thing",
        "Pretty",
        "StockKeepingUnit",
        "Counter",
        "BrokenRepr",
        "frozenset",
        "data",
        "_attr_module",
        "unknown.append",
        "defaultdict",
        "_BRACES.keys",
        "hasattr",
        "tuple",
        "list",
        "print",
        "int",
        "collections.namedtuple"
      ],
      "class_instantiations": [
        "Thing",
        "Pretty",
        "StockKeepingUnit",
        "Counter",
        "BrokenRepr"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "abc",
        "typing",
        "dataclasses",
        "os",
        "collections",
        "itertools",
        "sys"
      ],
      "third_party": {
        "other": [
          "builtins",
          "inspect",
          "reprlib",
          "array",
          "types",
          "rich",
          "get_console",
          "_loop",
          "_pick",
          "cells",
          "highlighter",
          "jupyter",
          "measure",
          "text",
          "attr",
          "console",
          "IPython"
        ]
      },
      "tech_stack": []
    },
    "line_count": 1017
  },
  "rich/progress.py": {
    "filepath": "../rich/rich/progress.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "track",
        "args": [
          {
            "name": "sequence",
            "type": "Iterable[ProgressType]"
          },
          {
            "name": "description",
            "type": "str"
          },
          {
            "name": "total",
            "type": "Optional[float]"
          },
          {
            "name": "completed",
            "type": "int"
          },
          {
            "name": "auto_refresh",
            "type": "bool"
          },
          {
            "name": "console",
            "type": "Optional[Console]"
          },
          {
            "name": "transient",
            "type": "bool"
          },
          {
            "name": "get_time",
            "type": "Optional[Callable[Any, float]]"
          },
          {
            "name": "refresh_per_second",
            "type": "float"
          },
          {
            "name": "style",
            "type": "StyleType"
          },
          {
            "name": "complete_style",
            "type": "StyleType"
          },
          {
            "name": "finished_style",
            "type": "StyleType"
          },
          {
            "name": "pulse_style",
            "type": "StyleType"
          },
          {
            "name": "update_period",
            "type": "float"
          },
          {
            "name": "disable",
            "type": "bool"
          },
          {
            "name": "show_speed",
            "type": "bool"
          }
        ],
        "return_type": "Iterable[ProgressType]",
        "lineno": 104,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "TimeRemainingColumn",
          "complete_style",
          "sequence",
          "progress.track",
          "get_time",
          "columns.extend",
          "total",
          "description",
          "Progress",
          "completed",
          "pulse_style",
          "show_speed",
          "auto_refresh",
          "BarColumn",
          "TaskProgressColumn",
          "transient",
          "disable",
          "update_period",
          "console",
          "finished_style",
          "TextColumn"
        ],
        "docstring": "Track progress by iterating over a sequence.\n\nYou can also track progress of an iterable, which might require that you additionally specify ``total``.\n\nArgs:\n    sequence (Iterable[ProgressType]): Values you wish to iterate over and track progress.\n    description (str, optional): Description of task show next to progress bar. Defaults to \"Working\".\n    total: (float, optional): Total number of steps. Default is len(sequence).\n    completed (int, optional): Number of steps completed so far. Defaults to 0.\n    auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n    transient: (bool, optional): Clear the progress on exit. Defaults to False.\n    console (Console, optional): Console to write to. Default creates internal Console instance.\n    refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n    style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n    complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n    finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n    pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n    update_period (float, optional): Minimum time (in seconds) between calls to update(). Defaults to 0.1.\n    disable (bool, optional): Disable display of progress.\n    show_speed (bool, optional): Show speed if total isn't known. Defaults to True.\nReturns:\n    Iterable[ProgressType]: An iterable of the values in the sequence.",
        "code": "def track(\n    sequence: Iterable[ProgressType],\n    description: str = \"Working...\",\n    total: Optional[float] = None,\n    completed: int = 0,\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    update_period: float = 0.1,\n    disable: bool = False,\n    show_speed: bool = True,\n) -> Iterable[ProgressType]:\n    \"\"\"Track progress by iterating over a sequence.\n\n    You can also track progress of an iterable, which might require that you additionally specify ``total``.\n\n    Args:\n        sequence (Iterable[ProgressType]): Values you wish to iterate over and track progress.\n        description (str, optional): Description of task show next to progress bar. Defaults to \"Working\".\n        total: (float, optional): Total number of steps. Default is len(sequence).\n        completed (int, optional): Number of steps completed so far. Defaults to 0.\n        auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n        transient: (bool, optional): Clear the progress on exit. Defaults to False.\n        console (Console, optional): Console to write to. Default creates internal Console instance.\n        refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n        update_period (float, optional): Minimum time (in seconds) between calls to update(). Defaults to 0.1.\n        disable (bool, optional): Disable display of progress.\n        show_speed (bool, optional): Show speed if total isn't known. Defaults to True.\n    Returns:\n        Iterable[ProgressType]: An iterable of the values in the sequence.\n\n    \"\"\"\n\n    columns: List[\"ProgressColumn\"] = (\n        [TextColumn(\"[progress.description]{task.description}\")] if description else []\n    )\n    columns.extend(\n        (\n            BarColumn(\n                style=style,\n                complete_style=complete_style,\n                finished_style=finished_style,\n                pulse_style=pulse_style,\n            ),\n            TaskProgressColumn(show_speed=show_speed),\n            TimeRemainingColumn(elapsed_when_finished=True),\n        )\n    )\n    progress = Progress(\n        *columns,\n        auto_refresh=auto_refresh,\n        console=console,\n        transient=transient,\n        get_time=get_time,\n        refresh_per_second=refresh_per_second or 10,\n        disable=disable,\n    )\n\n    with progress:\n        yield from progress.track(\n            sequence,\n            total=total,\n            completed=completed,\n            description=description,\n            update_period=update_period,\n        )",
        "line_count": 76,
        "needs_llm_summary": true
      },
      {
        "name": "wrap_file",
        "args": [
          {
            "name": "file",
            "type": "BinaryIO"
          },
          {
            "name": "total",
            "type": "int"
          }
        ],
        "return_type": "ContextManager[BinaryIO]",
        "lineno": 306,
        "decorators": [],
        "is_async": false,
        "calls": [
          "DownloadColumn",
          "style",
          "_ReadContext",
          "TimeRemainingColumn",
          "complete_style",
          "get_time",
          "columns.extend",
          "total",
          "description",
          "progress",
          "Progress",
          "pulse_style",
          "file",
          "auto_refresh",
          "BarColumn",
          "transient",
          "disable",
          "console",
          "finished_style",
          "TextColumn",
          "progress.wrap_file",
          "reader"
        ],
        "docstring": "Read bytes from a file while tracking progress.\n\nArgs:\n    file (Union[str, PathLike[str], BinaryIO]): The path to the file to read, or a file-like object in binary mode.\n    total (int): Total number of bytes to read.\n    description (str, optional): Description of task show next to progress bar. Defaults to \"Reading\".\n    auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n    transient: (bool, optional): Clear the progress on exit. Defaults to False.\n    console (Console, optional): Console to write to. Default creates internal Console instance.\n    refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n    style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n    complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n    finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n    pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n    disable (bool, optional): Disable display of progress.\nReturns:\n    ContextManager[BinaryIO]: A context manager yielding a progress reader.",
        "code": "def wrap_file(\n    file: BinaryIO,\n    total: int,\n    *,\n    description: str = \"Reading...\",\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    disable: bool = False,\n) -> ContextManager[BinaryIO]:\n    \"\"\"Read bytes from a file while tracking progress.\n\n    Args:\n        file (Union[str, PathLike[str], BinaryIO]): The path to the file to read, or a file-like object in binary mode.\n        total (int): Total number of bytes to read.\n        description (str, optional): Description of task show next to progress bar. Defaults to \"Reading\".\n        auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n        transient: (bool, optional): Clear the progress on exit. Defaults to False.\n        console (Console, optional): Console to write to. Default creates internal Console instance.\n        refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n        disable (bool, optional): Disable display of progress.\n    Returns:\n        ContextManager[BinaryIO]: A context manager yielding a progress reader.\n\n    \"\"\"\n\n    columns: List[\"ProgressColumn\"] = (\n        [TextColumn(\"[progress.description]{task.description}\")] if description else []\n    )\n    columns.extend(\n        (\n            BarColumn(\n                style=style,\n                complete_style=complete_style,\n                finished_style=finished_style,\n                pulse_style=pulse_style,\n            ),\n            DownloadColumn(),\n            TimeRemainingColumn(),\n        )\n    )\n    progress = Progress(\n        *columns,\n        auto_refresh=auto_refresh,\n        console=console,\n        transient=transient,\n        get_time=get_time,\n        refresh_per_second=refresh_per_second or 10,\n        disable=disable,\n    )\n\n    reader = progress.wrap_file(file, total=total, description=description)\n    return _ReadContext(progress, reader)",
        "line_count": 63,
        "needs_llm_summary": true
      },
      {
        "name": "open",
        "args": [
          {
            "name": "file",
            "type": "Union[str, PathLike[str], bytes]"
          },
          {
            "name": "mode",
            "type": "Union[Literal[rt], Literal[r]]"
          },
          {
            "name": "buffering",
            "type": "int"
          },
          {
            "name": "encoding",
            "type": "Optional[str]"
          },
          {
            "name": "errors",
            "type": "Optional[str]"
          },
          {
            "name": "newline",
            "type": "Optional[str]"
          }
        ],
        "return_type": "ContextManager[TextIO]",
        "lineno": 372,
        "decorators": [
          {
            "name": "typing.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def open(\n    file: Union[str, \"PathLike[str]\", bytes],\n    mode: Union[Literal[\"rt\"], Literal[\"r\"]],\n    buffering: int = -1,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n    *,\n    total: Optional[int] = None,\n    description: str = \"Reading...\",\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    disable: bool = False,\n) -> ContextManager[TextIO]:\n    pass",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "open",
        "args": [
          {
            "name": "file",
            "type": "Union[str, PathLike[str], bytes]"
          },
          {
            "name": "mode",
            "type": "Literal[rb]"
          },
          {
            "name": "buffering",
            "type": "int"
          },
          {
            "name": "encoding",
            "type": "Optional[str]"
          },
          {
            "name": "errors",
            "type": "Optional[str]"
          },
          {
            "name": "newline",
            "type": "Optional[str]"
          }
        ],
        "return_type": "ContextManager[BinaryIO]",
        "lineno": 397,
        "decorators": [
          {
            "name": "typing.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def open(\n    file: Union[str, \"PathLike[str]\", bytes],\n    mode: Literal[\"rb\"],\n    buffering: int = -1,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n    *,\n    total: Optional[int] = None,\n    description: str = \"Reading...\",\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    disable: bool = False,\n) -> ContextManager[BinaryIO]:\n    pass",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "open",
        "args": [
          {
            "name": "file",
            "type": "Union[str, PathLike[str], bytes]"
          },
          {
            "name": "mode",
            "type": "Union[Literal[rb], Literal[rt], Literal[r]]"
          },
          {
            "name": "buffering",
            "type": "int"
          },
          {
            "name": "encoding",
            "type": "Optional[str]"
          },
          {
            "name": "errors",
            "type": "Optional[str]"
          },
          {
            "name": "newline",
            "type": "Optional[str]"
          }
        ],
        "return_type": "Union[ContextManager[BinaryIO], ContextManager[TextIO]]",
        "lineno": 421,
        "decorators": [],
        "is_async": false,
        "calls": [
          "DownloadColumn",
          "style",
          "_ReadContext",
          "TimeRemainingColumn",
          "newline",
          "complete_style",
          "encoding",
          "get_time",
          "columns.extend",
          "total",
          "description",
          "mode",
          "progress",
          "Progress",
          "pulse_style",
          "progress.open",
          "file",
          "auto_refresh",
          "BarColumn",
          "transient",
          "disable",
          "console",
          "finished_style",
          "buffering",
          "TextColumn",
          "errors",
          "reader"
        ],
        "docstring": "Read bytes from a file while tracking progress.\n\nArgs:\n    path (Union[str, PathLike[str], BinaryIO]): The path to the file to read, or a file-like object in binary mode.\n    mode (str): The mode to use to open the file. Only supports \"r\", \"rb\" or \"rt\".\n    buffering (int): The buffering strategy to use, see :func:`io.open`.\n    encoding (str, optional): The encoding to use when reading in text mode, see :func:`io.open`.\n    errors (str, optional): The error handling strategy for decoding errors, see :func:`io.open`.\n    newline (str, optional): The strategy for handling newlines in text mode, see :func:`io.open`\n    total: (int, optional): Total number of bytes to read. Must be provided if reading from a file handle. Default for a path is os.stat(file).st_size.\n    description (str, optional): Description of task show next to progress bar. Defaults to \"Reading\".\n    auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n    transient: (bool, optional): Clear the progress on exit. Defaults to False.\n    console (Console, optional): Console to write to. Default creates internal Console instance.\n    refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n    style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n    complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n    finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n    pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n    disable (bool, optional): Disable display of progress.\n    encoding (str, optional): The encoding to use when reading in text mode.\n\nReturns:\n    ContextManager[BinaryIO]: A context manager yielding a progress reader.",
        "code": "def open(\n    file: Union[str, \"PathLike[str]\", bytes],\n    mode: Union[Literal[\"rb\"], Literal[\"rt\"], Literal[\"r\"]] = \"r\",\n    buffering: int = -1,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n    *,\n    total: Optional[int] = None,\n    description: str = \"Reading...\",\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    disable: bool = False,\n) -> Union[ContextManager[BinaryIO], ContextManager[TextIO]]:\n    \"\"\"Read bytes from a file while tracking progress.\n\n    Args:\n        path (Union[str, PathLike[str], BinaryIO]): The path to the file to read, or a file-like object in binary mode.\n        mode (str): The mode to use to open the file. Only supports \"r\", \"rb\" or \"rt\".\n        buffering (int): The buffering strategy to use, see :func:`io.open`.\n        encoding (str, optional): The encoding to use when reading in text mode, see :func:`io.open`.\n        errors (str, optional): The error handling strategy for decoding errors, see :func:`io.open`.\n        newline (str, optional): The strategy for handling newlines in text mode, see :func:`io.open`\n        total: (int, optional): Total number of bytes to read. Must be provided if reading from a file handle. Default for a path is os.stat(file).st_size.\n        description (str, optional): Description of task show next to progress bar. Defaults to \"Reading\".\n        auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n        transient: (bool, optional): Clear the progress on exit. Defaults to False.\n        console (Console, optional): Console to write to. Default creates internal Console instance.\n        refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n        disable (bool, optional): Disable display of progress.\n        encoding (str, optional): The encoding to use when reading in text mode.\n\n    Returns:\n        ContextManager[BinaryIO]: A context manager yielding a progress reader.\n\n    \"\"\"\n\n    columns: List[\"ProgressColumn\"] = (\n        [TextColumn(\"[progress.description]{task.description}\")] if description else []\n    )\n    columns.extend(\n        (\n            BarColumn(\n                style=style,\n                complete_style=complete_style,\n                finished_style=finished_style,\n                pulse_style=pulse_style,\n            ),\n            DownloadColumn(),\n            TimeRemainingColumn(),\n        )\n    )\n    progress = Progress(\n        *columns,\n        auto_refresh=auto_refresh,\n        console=console,\n        transient=transient,\n        get_time=get_time,\n        refresh_per_second=refresh_per_second or 10,\n        disable=disable,\n    )\n\n    reader = progress.open(\n        file,\n        mode=mode,\n        buffering=buffering,\n        encoding=encoding,\n        errors=errors,\n        newline=newline,\n        total=total,\n        description=description,\n    )\n    return _ReadContext(progress, reader)",
        "line_count": 84,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "progress",
            "type": "Progress"
          },
          {
            "name": "task_id",
            "type": "TaskID"
          },
          {
            "name": "update_period",
            "type": "float"
          }
        ],
        "return_type": null,
        "lineno": 67,
        "decorators": [],
        "is_async": false,
        "calls": [
          "progress",
          "Event",
          "super",
          "update_period",
          "task_id",
          "unknown.__init__"
        ],
        "docstring": null,
        "code": "def __init__(self, progress: \"Progress\", task_id: \"TaskID\", update_period: float):\n        self.progress = progress\n        self.task_id = task_id\n        self.update_period = update_period\n        self.done = Event()\n\n        self.completed = 0\n        super().__init__(daemon=True)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "run",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.done.wait",
          "completed",
          "self.progress.update",
          "self.progress.advance",
          "update_period",
          "task_id",
          "self.update_period",
          "self.task_id",
          "wait",
          "self.completed",
          "advance"
        ],
        "docstring": null,
        "code": "def run(self) -> None:\n        task_id = self.task_id\n        advance = self.progress.advance\n        update_period = self.update_period\n        last_completed = 0\n        wait = self.done.wait\n        while not wait(update_period) and self.progress.live.is_started:\n            completed = self.completed\n            if last_completed != completed:\n                advance(task_id, completed - last_completed)\n                last_completed = completed\n\n        self.progress.update(self.task_id, completed=self.completed, refresh=True)",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "_TrackThread",
        "lineno": 90,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.start"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> \"_TrackThread\":\n        self.start()\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 94,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.done.set",
          "self.join"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.done.set()\n        self.join()",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "handle",
            "type": "BinaryIO"
          },
          {
            "name": "progress",
            "type": "Progress"
          },
          {
            "name": "task",
            "type": "TaskID"
          },
          {
            "name": "close_handle",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 185,
        "decorators": [],
        "is_async": false,
        "calls": [
          "progress",
          "close_handle",
          "task",
          "handle"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        handle: BinaryIO,\n        progress: \"Progress\",\n        task: TaskID,\n        close_handle: bool = True,\n    ) -> None:\n        self.handle = handle\n        self.progress = progress\n        self.task = task\n        self.close_handle = close_handle\n        self._closed = False",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "_Reader",
        "lineno": 198,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.handle.__enter__"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> \"_Reader\":\n        self.handle.__enter__()\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 202,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.close"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.close()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__iter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "BinaryIO",
        "lineno": 210,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __iter__(self) -> BinaryIO:\n        return self",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__next__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bytes",
        "lineno": 213,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line",
          "next",
          "self.progress.advance",
          "self.task",
          "self.handle",
          "len"
        ],
        "docstring": null,
        "code": "def __next__(self) -> bytes:\n        line = next(self.handle)\n        self.progress.advance(self.task, advance=len(line))\n        return line",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "closed",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 219,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def closed(self) -> bool:\n        return self._closed",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "fileno",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 222,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.handle.fileno"
        ],
        "docstring": null,
        "code": "def fileno(self) -> int:\n        return self.handle.fileno()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "isatty",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 225,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.handle.isatty"
        ],
        "docstring": null,
        "code": "def isatty(self) -> bool:\n        return self.handle.isatty()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "mode",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 229,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def mode(self) -> str:\n        return self.handle.mode",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "name",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 233,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def name(self) -> str:\n        return self.handle.name",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "readable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 236,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.handle.readable"
        ],
        "docstring": null,
        "code": "def readable(self) -> bool:\n        return self.handle.readable()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "seekable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 239,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.handle.seekable"
        ],
        "docstring": null,
        "code": "def seekable(self) -> bool:\n        return self.handle.seekable()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "writable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 242,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def writable(self) -> bool:\n        return False",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "read",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "size",
            "type": "int"
          }
        ],
        "return_type": "bytes",
        "lineno": 245,
        "decorators": [],
        "is_async": false,
        "calls": [
          "block",
          "self.progress.advance",
          "self.task",
          "size",
          "self.handle.read",
          "len"
        ],
        "docstring": null,
        "code": "def read(self, size: int = -1) -> bytes:\n        block = self.handle.read(size)\n        self.progress.advance(self.task, advance=len(block))\n        return block",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "readinto",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "b",
            "type": "Union[bytearray, memoryview, mmap]"
          }
        ],
        "return_type": null,
        "lineno": 250,
        "decorators": [],
        "is_async": false,
        "calls": [
          "b",
          "self.progress.advance",
          "self.task",
          "n",
          "self.handle.readinto"
        ],
        "docstring": null,
        "code": "def readinto(self, b: Union[bytearray, memoryview, mmap]):  # type: ignore[no-untyped-def, override]\n        n = self.handle.readinto(b)  # type: ignore[attr-defined]\n        self.progress.advance(self.task, advance=n)\n        return n",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "readline",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "size",
            "type": "int"
          }
        ],
        "return_type": "bytes",
        "lineno": 255,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line",
          "self.progress.advance",
          "self.task",
          "size",
          "self.handle.readline",
          "len"
        ],
        "docstring": null,
        "code": "def readline(self, size: int = -1) -> bytes:  # type: ignore[override]\n        line = self.handle.readline(size)\n        self.progress.advance(self.task, advance=len(line))\n        return line",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "readlines",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "hint",
            "type": "int"
          }
        ],
        "return_type": "List[bytes]",
        "lineno": 260,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "sum",
          "hint",
          "self.progress.advance",
          "self.task",
          "map",
          "self.handle.readlines",
          "len"
        ],
        "docstring": null,
        "code": "def readlines(self, hint: int = -1) -> List[bytes]:\n        lines = self.handle.readlines(hint)\n        self.progress.advance(self.task, advance=sum(map(len, lines)))\n        return lines",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "close",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 265,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.handle.close"
        ],
        "docstring": null,
        "code": "def close(self) -> None:\n        if self.close_handle:\n            self.handle.close()\n        self._closed = True",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "seek",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "offset",
            "type": "int"
          },
          {
            "name": "whence",
            "type": "int"
          }
        ],
        "return_type": "int",
        "lineno": 270,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.progress.update",
          "whence",
          "self.task",
          "pos",
          "self.handle.seek",
          "offset"
        ],
        "docstring": null,
        "code": "def seek(self, offset: int, whence: int = 0) -> int:\n        pos = self.handle.seek(offset, whence)\n        self.progress.update(self.task, completed=pos)\n        return pos",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "tell",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 275,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.handle.tell"
        ],
        "docstring": null,
        "code": "def tell(self) -> int:\n        return self.handle.tell()",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "write",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "s",
            "type": "Any"
          }
        ],
        "return_type": "int",
        "lineno": 278,
        "decorators": [],
        "is_async": false,
        "calls": [
          "UnsupportedOperation"
        ],
        "docstring": null,
        "code": "def write(self, s: Any) -> int:\n        raise UnsupportedOperation(\"write\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "writelines",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lines",
            "type": "Iterable[Any]"
          }
        ],
        "return_type": "None",
        "lineno": 281,
        "decorators": [],
        "is_async": false,
        "calls": [
          "UnsupportedOperation"
        ],
        "docstring": null,
        "code": "def writelines(self, lines: Iterable[Any]) -> None:\n        raise UnsupportedOperation(\"writelines\")",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "progress",
            "type": "Progress"
          },
          {
            "name": "reader",
            "type": "_I"
          }
        ],
        "return_type": "None",
        "lineno": 288,
        "decorators": [],
        "is_async": false,
        "calls": [
          "progress"
        ],
        "docstring": null,
        "code": "def __init__(self, progress: \"Progress\", reader: _I) -> None:\n        self.progress = progress\n        self.reader: _I = reader",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "_I",
        "lineno": 292,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.progress.start",
          "self.reader.__enter__"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> _I:\n        self.progress.start()\n        return self.reader.__enter__()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 296,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.reader.__exit__",
          "exc_tb",
          "self.progress.stop",
          "exc_val",
          "exc_type"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.progress.stop()\n        self.reader.__exit__(exc_type, exc_val, exc_tb)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "table_column",
            "type": "Optional[Column]"
          }
        ],
        "return_type": "None",
        "lineno": 512,
        "decorators": [],
        "is_async": false,
        "calls": [
          "table_column"
        ],
        "docstring": null,
        "code": "def __init__(self, table_column: Optional[Column] = None) -> None:\n        self._table_column = table_column\n        self._renderable_cache: Dict[TaskID, Tuple[float, RenderableType]] = {}\n        self._update_time: Optional[float] = None",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "get_table_column",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Column",
        "lineno": 517,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Column"
        ],
        "docstring": "Get a table column, used to build tasks table.",
        "code": "def get_table_column(self) -> Column:\n        \"\"\"Get a table column, used to build tasks table.\"\"\"\n        return self._table_column or Column()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 521,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.render",
          "task.get_time",
          "task"
        ],
        "docstring": "Called by the Progress object to return a renderable for the given task.\n\nArgs:\n    task (Task): An object containing information regarding the task.\n\nReturns:\n    RenderableType: Anything renderable (including str).",
        "code": "def __call__(self, task: \"Task\") -> RenderableType:\n        \"\"\"Called by the Progress object to return a renderable for the given task.\n\n        Args:\n            task (Task): An object containing information regarding the task.\n\n        Returns:\n            RenderableType: Anything renderable (including str).\n        \"\"\"\n        current_time = task.get_time()\n        if self.max_refresh is not None and not task.completed:\n            try:\n                timestamp, renderable = self._renderable_cache[task.id]\n            except KeyError:\n                pass\n            else:\n                if timestamp + self.max_refresh > current_time:\n                    return renderable\n\n        renderable = self.render(task)\n        self._renderable_cache[task.id] = (current_time, renderable)\n        return renderable",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 545,
        "decorators": [
          {
            "name": "abstractmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Should return a renderable object.",
        "code": "def render(self, task: \"Task\") -> RenderableType:\n        \"\"\"Should return a renderable object.\"\"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": null,
        "lineno": 556,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "renderable",
          "unknown.__init__",
          "table_column"
        ],
        "docstring": null,
        "code": "def __init__(\n        self, renderable: RenderableType = \"\", *, table_column: Optional[Column] = None\n    ):\n        self.renderable = renderable\n        super().__init__(table_column=table_column)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 562,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def render(self, task: \"Task\") -> RenderableType:\n        return self.renderable",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "spinner_name",
            "type": "str"
          },
          {
            "name": "style",
            "type": "Optional[StyleType]"
          },
          {
            "name": "speed",
            "type": "float"
          },
          {
            "name": "finished_text",
            "type": "TextType"
          },
          {
            "name": "table_column",
            "type": "Optional[Column]"
          }
        ],
        "return_type": null,
        "lineno": 576,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "finished_text",
          "str",
          "Spinner",
          "super",
          "style",
          "speed",
          "Text.from_markup",
          "table_column",
          "spinner_name",
          "unknown.__init__"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        spinner_name: str = \"dots\",\n        style: Optional[StyleType] = \"progress.spinner\",\n        speed: float = 1.0,\n        finished_text: TextType = \" \",\n        table_column: Optional[Column] = None,\n    ):\n        self.spinner = Spinner(spinner_name, style=style, speed=speed)\n        self.finished_text = (\n            Text.from_markup(finished_text)\n            if isinstance(finished_text, str)\n            else finished_text\n        )\n        super().__init__(table_column=table_column)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "set_spinner",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "spinner_name",
            "type": "str"
          },
          {
            "name": "spinner_style",
            "type": "Optional[StyleType]"
          },
          {
            "name": "speed",
            "type": "float"
          }
        ],
        "return_type": "None",
        "lineno": 592,
        "decorators": [],
        "is_async": false,
        "calls": [
          "spinner_name",
          "speed",
          "Spinner",
          "spinner_style"
        ],
        "docstring": "Set a new spinner.\n\nArgs:\n    spinner_name (str): Spinner name, see python -m rich.spinner.\n    spinner_style (Optional[StyleType], optional): Spinner style. Defaults to \"progress.spinner\".\n    speed (float, optional): Speed factor of spinner. Defaults to 1.0.",
        "code": "def set_spinner(\n        self,\n        spinner_name: str,\n        spinner_style: Optional[StyleType] = \"progress.spinner\",\n        speed: float = 1.0,\n    ) -> None:\n        \"\"\"Set a new spinner.\n\n        Args:\n            spinner_name (str): Spinner name, see python -m rich.spinner.\n            spinner_style (Optional[StyleType], optional): Spinner style. Defaults to \"progress.spinner\".\n            speed (float, optional): Speed factor of spinner. Defaults to 1.0.\n        \"\"\"\n        self.spinner = Spinner(spinner_name, style=spinner_style, speed=speed)",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 607,
        "decorators": [],
        "is_async": false,
        "calls": [
          "task.get_time",
          "self.spinner.render"
        ],
        "docstring": null,
        "code": "def render(self, task: \"Task\") -> RenderableType:\n        text = (\n            self.finished_text\n            if task.finished\n            else self.spinner.render(task.get_time())\n        )\n        return text",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text_format",
            "type": "str"
          },
          {
            "name": "style",
            "type": "StyleType"
          },
          {
            "name": "justify",
            "type": "JustifyMethod"
          },
          {
            "name": "markup",
            "type": "bool"
          },
          {
            "name": "highlighter",
            "type": "Optional[Highlighter]"
          },
          {
            "name": "table_column",
            "type": "Optional[Column]"
          }
        ],
        "return_type": "None",
        "lineno": 619,
        "decorators": [],
        "is_async": false,
        "calls": [
          "highlighter",
          "markup",
          "Column",
          "super",
          "style",
          "text_format",
          "unknown.__init__"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        text_format: str,\n        style: StyleType = \"none\",\n        justify: JustifyMethod = \"left\",\n        markup: bool = True,\n        highlighter: Optional[Highlighter] = None,\n        table_column: Optional[Column] = None,\n    ) -> None:\n        self.text_format = text_format\n        self.justify: JustifyMethod = justify\n        self.style = style\n        self.markup = markup\n        self.highlighter = highlighter\n        super().__init__(table_column=table_column or Column(no_wrap=True))",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 635,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "_text",
          "self.highlighter.highlight",
          "self.text_format.format",
          "self.justify",
          "Text.from_markup",
          "text",
          "Text",
          "task"
        ],
        "docstring": null,
        "code": "def render(self, task: \"Task\") -> Text:\n        _text = self.text_format.format(task=task)\n        if self.markup:\n            text = Text.from_markup(_text, style=self.style, justify=self.justify)\n        else:\n            text = Text(_text, style=self.style, justify=self.justify)\n        if self.highlighter:\n            self.highlighter.highlight(text)\n        return text",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "bar_width",
            "type": "Optional[int]"
          },
          {
            "name": "style",
            "type": "StyleType"
          },
          {
            "name": "complete_style",
            "type": "StyleType"
          },
          {
            "name": "finished_style",
            "type": "StyleType"
          },
          {
            "name": "pulse_style",
            "type": "StyleType"
          },
          {
            "name": "table_column",
            "type": "Optional[Column]"
          }
        ],
        "return_type": "None",
        "lineno": 657,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bar_width",
          "super",
          "style",
          "pulse_style",
          "unknown.__init__",
          "complete_style",
          "table_column",
          "finished_style"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        bar_width: Optional[int] = 40,\n        style: StyleType = \"bar.back\",\n        complete_style: StyleType = \"bar.complete\",\n        finished_style: StyleType = \"bar.finished\",\n        pulse_style: StyleType = \"bar.pulse\",\n        table_column: Optional[Column] = None,\n    ) -> None:\n        self.bar_width = bar_width\n        self.style = style\n        self.complete_style = complete_style\n        self.finished_style = finished_style\n        self.pulse_style = pulse_style\n        super().__init__(table_column=table_column)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "ProgressBar",
        "lineno": 673,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "self.finished_style",
          "task.completed",
          "self.pulse_style",
          "self.bar_width",
          "self.complete_style",
          "task.get_time",
          "max",
          "ProgressBar",
          "task.total"
        ],
        "docstring": "Gets a progress bar widget for a task.",
        "code": "def render(self, task: \"Task\") -> ProgressBar:\n        \"\"\"Gets a progress bar widget for a task.\"\"\"\n        return ProgressBar(\n            total=max(0, task.total) if task.total is not None else None,\n            completed=max(0, task.completed),\n            width=None if self.bar_width is None else max(1, self.bar_width),\n            pulse=not task.started,\n            animation_time=task.get_time(),\n            style=self.style,\n            complete_style=self.complete_style,\n            finished_style=self.finished_style,\n            pulse_style=self.pulse_style,\n        )",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 691,
        "decorators": [],
        "is_async": false,
        "calls": [
          "str",
          "delta",
          "timedelta",
          "max",
          "elapsed",
          "int",
          "Text"
        ],
        "docstring": "Show time elapsed.",
        "code": "def render(self, task: \"Task\") -> Text:\n        \"\"\"Show time elapsed.\"\"\"\n        elapsed = task.finished_time if task.finished else task.elapsed\n        if elapsed is None:\n            return Text(\"-:--:--\", style=\"progress.elapsed\")\n        delta = timedelta(seconds=max(0, int(elapsed)))\n        return Text(str(delta), style=\"progress.elapsed\")",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text_format",
            "type": "str"
          },
          {
            "name": "text_format_no_percentage",
            "type": "str"
          },
          {
            "name": "style",
            "type": "StyleType"
          },
          {
            "name": "justify",
            "type": "JustifyMethod"
          },
          {
            "name": "markup",
            "type": "bool"
          },
          {
            "name": "highlighter",
            "type": "Optional[Highlighter]"
          },
          {
            "name": "table_column",
            "type": "Optional[Column]"
          },
          {
            "name": "show_speed",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 714,
        "decorators": [],
        "is_async": false,
        "calls": [
          "highlighter",
          "markup",
          "super",
          "style",
          "text_format_no_percentage",
          "text_format",
          "show_speed",
          "justify",
          "table_column",
          "unknown.__init__"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        text_format: str = \"[progress.percentage]{task.percentage:>3.0f}%\",\n        text_format_no_percentage: str = \"\",\n        style: StyleType = \"none\",\n        justify: JustifyMethod = \"left\",\n        markup: bool = True,\n        highlighter: Optional[Highlighter] = None,\n        table_column: Optional[Column] = None,\n        show_speed: bool = False,\n    ) -> None:\n        self.text_format_no_percentage = text_format_no_percentage\n        self.show_speed = show_speed\n        super().__init__(\n            text_format=text_format,\n            style=style,\n            justify=justify,\n            markup=markup,\n            highlighter=highlighter,\n            table_column=table_column,\n        )",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "render_speed",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "speed",
            "type": "Optional[float]"
          }
        ],
        "return_type": "Text",
        "lineno": 737,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "filesize.pick_unit_and_suffix",
          "int",
          "speed",
          "Text"
        ],
        "docstring": "Render the speed in iterations per second.\n\nArgs:\n    task (Task): A Task object.\n\nReturns:\n    Text: Text object containing the task speed.",
        "code": "def render_speed(cls, speed: Optional[float]) -> Text:\n        \"\"\"Render the speed in iterations per second.\n\n        Args:\n            task (Task): A Task object.\n\n        Returns:\n            Text: Text object containing the task speed.\n        \"\"\"\n        if speed is None:\n            return Text(\"\", style=\"progress.percentage\")\n        unit, suffix = filesize.pick_unit_and_suffix(\n            int(speed),\n            [\"\", \"\u00d710\u00b3\", \"\u00d710\u2076\", \"\u00d710\u2079\", \"\u00d710\u00b9\u00b2\"],\n            1000,\n        )\n        data_speed = speed / unit\n        return Text(f\"{data_speed:.1f}{suffix} it/s\", style=\"progress.percentage\")",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 756,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "text_format.format",
          "_text",
          "self.highlighter.highlight",
          "self.justify",
          "Text.from_markup",
          "self.render_speed",
          "text",
          "Text",
          "task"
        ],
        "docstring": null,
        "code": "def render(self, task: \"Task\") -> Text:\n        if task.total is None and self.show_speed:\n            return self.render_speed(task.finished_speed or task.speed)\n        text_format = (\n            self.text_format_no_percentage if task.total is None else self.text_format\n        )\n        _text = text_format.format(task=task)\n        if self.markup:\n            text = Text.from_markup(_text, style=self.style, justify=self.justify)\n        else:\n            text = Text(_text, style=self.style, justify=self.justify)\n        if self.highlighter:\n            self.highlighter.highlight(text)\n        return text",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "compact",
            "type": "bool"
          },
          {
            "name": "elapsed_when_finished",
            "type": "bool"
          },
          {
            "name": "table_column",
            "type": "Optional[Column]"
          }
        ],
        "return_type": null,
        "lineno": 783,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "compact",
          "elapsed_when_finished",
          "table_column",
          "unknown.__init__"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        compact: bool = False,\n        elapsed_when_finished: bool = False,\n        table_column: Optional[Column] = None,\n    ):\n        self.compact = compact\n        self.elapsed_when_finished = elapsed_when_finished\n        super().__init__(table_column=table_column)",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 793,
        "decorators": [],
        "is_async": false,
        "calls": [
          "formatted",
          "task.time_remaining",
          "divmod",
          "style",
          "minutes",
          "task.finished_time",
          "task_time",
          "int",
          "Text"
        ],
        "docstring": "Show time remaining.",
        "code": "def render(self, task: \"Task\") -> Text:\n        \"\"\"Show time remaining.\"\"\"\n        if self.elapsed_when_finished and task.finished:\n            task_time = task.finished_time\n            style = \"progress.elapsed\"\n        else:\n            task_time = task.time_remaining\n            style = \"progress.remaining\"\n\n        if task.total is None:\n            return Text(\"\", style=style)\n\n        if task_time is None:\n            return Text(\"--:--\" if self.compact else \"-:--:--\", style=style)\n\n        # Based on https://github.com/tqdm/tqdm/blob/master/tqdm/std.py\n        minutes, seconds = divmod(int(task_time), 60)\n        hours, minutes = divmod(minutes, 60)\n\n        if self.compact and not hours:\n            formatted = f\"{minutes:02d}:{seconds:02d}\"\n        else:\n            formatted = f\"{hours:d}:{minutes:02d}:{seconds:02d}\"\n\n        return Text(formatted, style=style)",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 823,
        "decorators": [],
        "is_async": false,
        "calls": [
          "filesize.decimal",
          "task.completed",
          "data_size",
          "int",
          "Text"
        ],
        "docstring": "Show data completed.",
        "code": "def render(self, task: \"Task\") -> Text:\n        \"\"\"Show data completed.\"\"\"\n        data_size = filesize.decimal(int(task.completed))\n        return Text(data_size, style=\"progress.filesize\")",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 832,
        "decorators": [],
        "is_async": false,
        "calls": [
          "filesize.decimal",
          "Text",
          "data_size",
          "int",
          "task.total"
        ],
        "docstring": "Show data completed.",
        "code": "def render(self, task: \"Task\") -> Text:\n        \"\"\"Show data completed.\"\"\"\n        data_size = filesize.decimal(int(task.total)) if task.total is not None else \"\"\n        return Text(data_size, style=\"progress.filesize.total\")",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "separator",
            "type": "str"
          },
          {
            "name": "table_column",
            "type": "Optional[Column]"
          }
        ],
        "return_type": null,
        "lineno": 850,
        "decorators": [],
        "is_async": false,
        "calls": [
          "super",
          "unknown.__init__",
          "separator",
          "table_column"
        ],
        "docstring": null,
        "code": "def __init__(self, separator: str = \"/\", table_column: Optional[Column] = None):\n        self.separator = separator\n        super().__init__(table_column=table_column)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 854,
        "decorators": [],
        "is_async": false,
        "calls": [
          "total",
          "len",
          "str",
          "task.total",
          "task.completed",
          "int",
          "Text"
        ],
        "docstring": "Show completed/total.",
        "code": "def render(self, task: \"Task\") -> Text:\n        \"\"\"Show completed/total.\"\"\"\n        completed = int(task.completed)\n        total = int(task.total) if task.total is not None else \"?\"\n        total_width = len(str(total))\n        return Text(\n            f\"{completed:{total_width}d}{self.separator}{total}\",\n            style=\"progress.download\",\n        )",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "binary_units",
            "type": "bool"
          },
          {
            "name": "table_column",
            "type": "Optional[Column]"
          }
        ],
        "return_type": "None",
        "lineno": 872,
        "decorators": [],
        "is_async": false,
        "calls": [
          "binary_units",
          "super",
          "unknown.__init__",
          "table_column"
        ],
        "docstring": null,
        "code": "def __init__(\n        self, binary_units: bool = False, table_column: Optional[Column] = None\n    ) -> None:\n        self.binary_units = binary_units\n        super().__init__(table_column=table_column)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 878,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unit_and_suffix_calculation_base",
          "filesize.pick_unit_and_suffix",
          "download_status",
          "Text",
          "task.completed",
          "int",
          "task.total"
        ],
        "docstring": "Calculate common unit for completed and total.",
        "code": "def render(self, task: \"Task\") -> Text:\n        \"\"\"Calculate common unit for completed and total.\"\"\"\n        completed = int(task.completed)\n\n        unit_and_suffix_calculation_base = (\n            int(task.total) if task.total is not None else completed\n        )\n        if self.binary_units:\n            unit, suffix = filesize.pick_unit_and_suffix(\n                unit_and_suffix_calculation_base,\n                [\"bytes\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"],\n                1024,\n            )\n        else:\n            unit, suffix = filesize.pick_unit_and_suffix(\n                unit_and_suffix_calculation_base,\n                [\"bytes\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"],\n                1000,\n            )\n        precision = 0 if unit == 1 else 1\n\n        completed_ratio = completed / unit\n        completed_str = f\"{completed_ratio:,.{precision}f}\"\n\n        if task.total is not None:\n            total = int(task.total)\n            total_ratio = total / unit\n            total_str = f\"{total_ratio:,.{precision}f}\"\n        else:\n            total_str = \"?\"\n\n        download_status = f\"{completed_str}/{total_str} {suffix}\"\n        download_text = Text(download_status, style=\"progress.download\")\n        return download_text",
        "line_count": 34,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task",
            "type": "Task"
          }
        ],
        "return_type": "Text",
        "lineno": 917,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Text",
          "int",
          "speed",
          "filesize.decimal"
        ],
        "docstring": "Show data transfer speed.",
        "code": "def render(self, task: \"Task\") -> Text:\n        \"\"\"Show data transfer speed.\"\"\"\n        speed = task.finished_speed or task.speed\n        if speed is None:\n            return Text(\"?\", style=\"progress.data.speed\")\n        data_speed = filesize.decimal(int(speed))\n        return Text(f\"{data_speed}/s\", style=\"progress.data.speed\")",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "get_time",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "float",
        "lineno": 983,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._get_time"
        ],
        "docstring": "float: Get the current time, in seconds.",
        "code": "def get_time(self) -> float:\n        \"\"\"float: Get the current time, in seconds.\"\"\"\n        return self._get_time()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "started",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 988,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "bool: Check if the task as started.",
        "code": "def started(self) -> bool:\n        \"\"\"bool: Check if the task as started.\"\"\"\n        return self.start_time is not None",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "remaining",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[float]",
        "lineno": 993,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Optional[float]: Get the number of steps remaining, if a non-None total was set.",
        "code": "def remaining(self) -> Optional[float]:\n        \"\"\"Optional[float]: Get the number of steps remaining, if a non-None total was set.\"\"\"\n        if self.total is None:\n            return None\n        return self.total - self.completed",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "elapsed",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[float]",
        "lineno": 1000,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.get_time"
        ],
        "docstring": "Optional[float]: Time elapsed since task was started, or ``None`` if the task hasn't started.",
        "code": "def elapsed(self) -> Optional[float]:\n        \"\"\"Optional[float]: Time elapsed since task was started, or ``None`` if the task hasn't started.\"\"\"\n        if self.start_time is None:\n            return None\n        if self.stop_time is not None:\n            return self.stop_time - self.start_time\n        return self.get_time() - self.start_time",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "finished",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 1009,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Check if the task has finished.",
        "code": "def finished(self) -> bool:\n        \"\"\"Check if the task has finished.\"\"\"\n        return self.finished_time is not None",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "percentage",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "float",
        "lineno": 1014,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "max",
          "min",
          "completed"
        ],
        "docstring": "float: Get progress of task as a percentage. If a None total was set, returns 0",
        "code": "def percentage(self) -> float:\n        \"\"\"float: Get progress of task as a percentage. If a None total was set, returns 0\"\"\"\n        if not self.total:\n            return 0.0\n        completed = (self.completed / self.total) * 100.0\n        completed = min(100.0, max(0.0, completed))\n        return completed",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "speed",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[float]",
        "lineno": 1023,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self._progress",
          "progress",
          "sum",
          "next",
          "iter",
          "iter_progress"
        ],
        "docstring": "Optional[float]: Get the estimated speed in steps per second.",
        "code": "def speed(self) -> Optional[float]:\n        \"\"\"Optional[float]: Get the estimated speed in steps per second.\"\"\"\n        if self.start_time is None:\n            return None\n        with self._lock:\n            progress = self._progress\n            if not progress:\n                return None\n            total_time = progress[-1].timestamp - progress[0].timestamp\n            if total_time == 0:\n                return None\n            iter_progress = iter(progress)\n            next(iter_progress)\n            total_completed = sum(sample.completed for sample in iter_progress)\n            speed = total_completed / total_time\n            return speed",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "time_remaining",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[float]",
        "lineno": 1041,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.speed",
          "ceil",
          "self.remaining"
        ],
        "docstring": "Optional[float]: Get estimated time to completion, or ``None`` if no data.",
        "code": "def time_remaining(self) -> Optional[float]:\n        \"\"\"Optional[float]: Get estimated time to completion, or ``None`` if no data.\"\"\"\n        if self.finished:\n            return 0.0\n        speed = self.speed\n        if not speed:\n            return None\n        remaining = self.remaining\n        if remaining is None:\n            return None\n        estimate = ceil(remaining / speed)\n        return estimate",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "_reset",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1054,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._progress.clear"
        ],
        "docstring": "Reset progress.",
        "code": "def _reset(self) -> None:\n        \"\"\"Reset progress.\"\"\"\n        self._progress.clear()\n        self.finished_time = None\n        self.finished_speed = None",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1077,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.console.log",
          "expand",
          "TaskID",
          "transient",
          "RLock",
          "Live",
          "disable",
          "get_console",
          "refresh_per_second",
          "self.get_default_columns",
          "redirect_stdout",
          "redirect_stderr",
          "auto_refresh",
          "self.get_renderable",
          "self.console.print",
          "speed_estimate_period"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        *columns: Union[str, ProgressColumn],\n        console: Optional[Console] = None,\n        auto_refresh: bool = True,\n        refresh_per_second: float = 10,\n        speed_estimate_period: float = 30.0,\n        transient: bool = False,\n        redirect_stdout: bool = True,\n        redirect_stderr: bool = True,\n        get_time: Optional[GetTimeCallable] = None,\n        disable: bool = False,\n        expand: bool = False,\n    ) -> None:\n        assert refresh_per_second > 0, \"refresh_per_second must be > 0\"\n        self._lock = RLock()\n        self.columns = columns or self.get_default_columns()\n        self.speed_estimate_period = speed_estimate_period\n\n        self.disable = disable\n        self.expand = expand\n        self._tasks: Dict[TaskID, Task] = {}\n        self._task_index: TaskID = TaskID(0)\n        self.live = Live(\n            console=console or get_console(),\n            auto_refresh=auto_refresh,\n            refresh_per_second=refresh_per_second,\n            transient=transient,\n            redirect_stdout=redirect_stdout,\n            redirect_stderr=redirect_stderr,\n            get_renderable=self.get_renderable,\n        )\n        self.get_time = get_time or self.console.get_time\n        self.print = self.console.print\n        self.log = self.console.log",
        "line_count": 35,
        "needs_llm_summary": true
      },
      {
        "name": "get_default_columns",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Tuple[ProgressColumn, Ellipsis]",
        "lineno": 1114,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "BarColumn",
          "TextColumn",
          "TimeRemainingColumn",
          "TaskProgressColumn"
        ],
        "docstring": "Get the default columns used for a new Progress instance:\n   - a text column for the description (TextColumn)\n   - the bar itself (BarColumn)\n   - a text column showing completion percentage (TextColumn)\n   - an estimated-time-remaining column (TimeRemainingColumn)\nIf the Progress instance is created without passing a columns argument,\nthe default columns defined here will be used.\n\nYou can also create a Progress instance using custom columns before\nand/or after the defaults, as in this example:\n\n    progress = Progress(\n        SpinnerColumn(),\n        *Progress.get_default_columns(),\n        \"Elapsed:\",\n        TimeElapsedColumn(),\n    )\n\nThis code shows the creation of a Progress display, containing\na spinner to the left, the default columns, and a labeled elapsed\ntime column.",
        "code": "def get_default_columns(cls) -> Tuple[ProgressColumn, ...]:\n        \"\"\"Get the default columns used for a new Progress instance:\n           - a text column for the description (TextColumn)\n           - the bar itself (BarColumn)\n           - a text column showing completion percentage (TextColumn)\n           - an estimated-time-remaining column (TimeRemainingColumn)\n        If the Progress instance is created without passing a columns argument,\n        the default columns defined here will be used.\n\n        You can also create a Progress instance using custom columns before\n        and/or after the defaults, as in this example:\n\n            progress = Progress(\n                SpinnerColumn(),\n                *Progress.get_default_columns(),\n                \"Elapsed:\",\n                TimeElapsedColumn(),\n            )\n\n        This code shows the creation of a Progress display, containing\n        a spinner to the left, the default columns, and a labeled elapsed\n        time column.\n        \"\"\"\n        return (\n            TextColumn(\"[progress.description]{task.description}\"),\n            BarColumn(),\n            TaskProgressColumn(),\n            TimeRemainingColumn(),\n        )",
        "line_count": 29,
        "needs_llm_summary": true
      },
      {
        "name": "console",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Console",
        "lineno": 1145,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def console(self) -> Console:\n        return self.live.console",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "tasks",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "List[Task]",
        "lineno": 1149,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self._tasks.values",
          "list"
        ],
        "docstring": "Get a list of Task instances.",
        "code": "def tasks(self) -> List[Task]:\n        \"\"\"Get a list of Task instances.\"\"\"\n        with self._lock:\n            return list(self._tasks.values())",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "task_ids",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "List[TaskID]",
        "lineno": 1155,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "list",
          "self._tasks.keys"
        ],
        "docstring": "A list of task IDs.",
        "code": "def task_ids(self) -> List[TaskID]:\n        \"\"\"A list of task IDs.\"\"\"\n        with self._lock:\n            return list(self._tasks.keys())",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "finished",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 1161,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self._tasks.values",
          "all"
        ],
        "docstring": "Check if all tasks have been completed.",
        "code": "def finished(self) -> bool:\n        \"\"\"Check if all tasks have been completed.\"\"\"\n        with self._lock:\n            if not self._tasks:\n                return True\n            return all(task.finished for task in self._tasks.values())",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "start",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1168,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.live.start"
        ],
        "docstring": "Start the progress display.",
        "code": "def start(self) -> None:\n        \"\"\"Start the progress display.\"\"\"\n        if not self.disable:\n            self.live.start(refresh=True)",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "stop",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1173,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.console.print",
          "self.live.stop"
        ],
        "docstring": "Stop the progress display.",
        "code": "def stop(self) -> None:\n        \"\"\"Stop the progress display.\"\"\"\n        self.live.stop()\n        if not self.console.is_interactive and not self.console.is_jupyter:\n            self.console.print()",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Self",
        "lineno": 1179,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.start"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> Self:\n        self.start()\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 1183,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.stop"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.stop()",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "track",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "sequence",
            "type": "Iterable[ProgressType]"
          },
          {
            "name": "total",
            "type": "Optional[float]"
          },
          {
            "name": "completed",
            "type": "int"
          },
          {
            "name": "task_id",
            "type": "Optional[TaskID]"
          },
          {
            "name": "description",
            "type": "str"
          },
          {
            "name": "update_period",
            "type": "float"
          }
        ],
        "return_type": "Iterable[ProgressType]",
        "lineno": 1191,
        "decorators": [],
        "is_async": false,
        "calls": [
          "total",
          "description",
          "self.refresh",
          "completed",
          "self.update",
          "length_hint",
          "task_id",
          "update_period",
          "self.add_task",
          "refresh",
          "self.advance",
          "advance",
          "float",
          "_TrackThread",
          "sequence",
          "self"
        ],
        "docstring": "Track progress by iterating over a sequence.\n\nYou can also track progress of an iterable, which might require that you additionally specify ``total``.\n\nArgs:\n    sequence (Iterable[ProgressType]): Values you want to iterate over and track progress.\n    total: (float, optional): Total number of steps. Default is len(sequence).\n    completed (int, optional): Number of steps completed so far. Defaults to 0.\n    task_id: (TaskID): Task to track. Default is new task.\n    description: (str, optional): Description of task, if new task is created.\n    update_period (float, optional): Minimum time (in seconds) between calls to update(). Defaults to 0.1.\n\nReturns:\n    Iterable[ProgressType]: An iterable of values taken from the provided sequence.",
        "code": "def track(\n        self,\n        sequence: Iterable[ProgressType],\n        total: Optional[float] = None,\n        completed: int = 0,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Working...\",\n        update_period: float = 0.1,\n    ) -> Iterable[ProgressType]:\n        \"\"\"Track progress by iterating over a sequence.\n\n        You can also track progress of an iterable, which might require that you additionally specify ``total``.\n\n        Args:\n            sequence (Iterable[ProgressType]): Values you want to iterate over and track progress.\n            total: (float, optional): Total number of steps. Default is len(sequence).\n            completed (int, optional): Number of steps completed so far. Defaults to 0.\n            task_id: (TaskID): Task to track. Default is new task.\n            description: (str, optional): Description of task, if new task is created.\n            update_period (float, optional): Minimum time (in seconds) between calls to update(). Defaults to 0.1.\n\n        Returns:\n            Iterable[ProgressType]: An iterable of values taken from the provided sequence.\n        \"\"\"\n        if total is None:\n            total = float(length_hint(sequence)) or None\n\n        if task_id is None:\n            task_id = self.add_task(description, total=total, completed=completed)\n        else:\n            self.update(task_id, total=total, completed=completed)\n\n        if self.live.auto_refresh:\n            with _TrackThread(self, task_id, update_period) as track_thread:\n                for value in sequence:\n                    yield value\n                    track_thread.completed += 1\n        else:\n            advance = self.advance\n            refresh = self.refresh\n            for value in sequence:\n                yield value\n                advance(task_id, 1)\n                refresh()",
        "line_count": 44,
        "needs_llm_summary": true
      },
      {
        "name": "wrap_file",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "BinaryIO"
          },
          {
            "name": "total",
            "type": "Optional[int]"
          }
        ],
        "return_type": "BinaryIO",
        "lineno": 1236,
        "decorators": [],
        "is_async": false,
        "calls": [
          "total",
          "description",
          "_Reader",
          "ValueError",
          "total_bytes",
          "self.update",
          "task_id",
          "self.add_task",
          "unknown.total",
          "file",
          "self"
        ],
        "docstring": "Track progress file reading from a binary file.\n\nArgs:\n    file (BinaryIO): A file-like object opened in binary mode.\n    total (int, optional): Total number of bytes to read. This must be provided unless a task with a total is also given.\n    task_id (TaskID): Task to track. Default is new task.\n    description (str, optional): Description of task, if new task is created.\n\nReturns:\n    BinaryIO: A readable file-like object in binary mode.\n\nRaises:\n    ValueError: When no total value can be extracted from the arguments or the task.",
        "code": "def wrap_file(\n        self,\n        file: BinaryIO,\n        total: Optional[int] = None,\n        *,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Reading...\",\n    ) -> BinaryIO:\n        \"\"\"Track progress file reading from a binary file.\n\n        Args:\n            file (BinaryIO): A file-like object opened in binary mode.\n            total (int, optional): Total number of bytes to read. This must be provided unless a task with a total is also given.\n            task_id (TaskID): Task to track. Default is new task.\n            description (str, optional): Description of task, if new task is created.\n\n        Returns:\n            BinaryIO: A readable file-like object in binary mode.\n\n        Raises:\n            ValueError: When no total value can be extracted from the arguments or the task.\n        \"\"\"\n        # attempt to recover the total from the task\n        total_bytes: Optional[float] = None\n        if total is not None:\n            total_bytes = total\n        elif task_id is not None:\n            with self._lock:\n                total_bytes = self._tasks[task_id].total\n        if total_bytes is None:\n            raise ValueError(\n                f\"unable to get the total number of bytes, please specify 'total'\"\n            )\n\n        # update total of task or create new task\n        if task_id is None:\n            task_id = self.add_task(description, total=total_bytes)\n        else:\n            self.update(task_id, total=total_bytes)\n\n        return _Reader(file, self, task_id, close_handle=False)",
        "line_count": 41,
        "needs_llm_summary": true
      },
      {
        "name": "open",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "Union[str, PathLike[str], bytes]"
          },
          {
            "name": "mode",
            "type": "Literal[rb]"
          },
          {
            "name": "buffering",
            "type": "int"
          },
          {
            "name": "encoding",
            "type": "Optional[str]"
          },
          {
            "name": "errors",
            "type": "Optional[str]"
          },
          {
            "name": "newline",
            "type": "Optional[str]"
          }
        ],
        "return_type": "BinaryIO",
        "lineno": 1279,
        "decorators": [
          {
            "name": "typing.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def open(\n        self,\n        file: Union[str, \"PathLike[str]\", bytes],\n        mode: Literal[\"rb\"],\n        buffering: int = -1,\n        encoding: Optional[str] = None,\n        errors: Optional[str] = None,\n        newline: Optional[str] = None,\n        *,\n        total: Optional[int] = None,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Reading...\",\n    ) -> BinaryIO:\n        pass",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "open",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "Union[str, PathLike[str], bytes]"
          },
          {
            "name": "mode",
            "type": "Union[Literal[r], Literal[rt]]"
          },
          {
            "name": "buffering",
            "type": "int"
          },
          {
            "name": "encoding",
            "type": "Optional[str]"
          },
          {
            "name": "errors",
            "type": "Optional[str]"
          },
          {
            "name": "newline",
            "type": "Optional[str]"
          }
        ],
        "return_type": "TextIO",
        "lineno": 1295,
        "decorators": [
          {
            "name": "typing.overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def open(\n        self,\n        file: Union[str, \"PathLike[str]\", bytes],\n        mode: Union[Literal[\"r\"], Literal[\"rt\"]],\n        buffering: int = -1,\n        encoding: Optional[str] = None,\n        errors: Optional[str] = None,\n        newline: Optional[str] = None,\n        *,\n        total: Optional[int] = None,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Reading...\",\n    ) -> TextIO:\n        pass",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "open",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "file",
            "type": "Union[str, PathLike[str], bytes]"
          },
          {
            "name": "mode",
            "type": "Union[Literal[rb], Literal[rt], Literal[r]]"
          },
          {
            "name": "buffering",
            "type": "int"
          },
          {
            "name": "encoding",
            "type": "Optional[str]"
          },
          {
            "name": "errors",
            "type": "Optional[str]"
          },
          {
            "name": "newline",
            "type": "Optional[str]"
          }
        ],
        "return_type": "Union[BinaryIO, TextIO]",
        "lineno": 1310,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_Reader",
          "unknown.st_size",
          "newline",
          "RuntimeWarning",
          "encoding",
          "total",
          "description",
          "io.TextIOWrapper",
          "mode",
          "ValueError",
          "self.update",
          "stat",
          "self.add_task",
          "unknown.join",
          "warnings.warn",
          "file",
          "task_id",
          "line_buffering",
          "buffering",
          "io.open",
          "handle",
          "errors",
          "reader",
          "sorted",
          "self"
        ],
        "docstring": "Track progress while reading from a binary file.\n\nArgs:\n    path (Union[str, PathLike[str]]): The path to the file to read.\n    mode (str): The mode to use to open the file. Only supports \"r\", \"rb\" or \"rt\".\n    buffering (int): The buffering strategy to use, see :func:`io.open`.\n    encoding (str, optional): The encoding to use when reading in text mode, see :func:`io.open`.\n    errors (str, optional): The error handling strategy for decoding errors, see :func:`io.open`.\n    newline (str, optional): The strategy for handling newlines in text mode, see :func:`io.open`.\n    total (int, optional): Total number of bytes to read. If none given, os.stat(path).st_size is used.\n    task_id (TaskID): Task to track. Default is new task.\n    description (str, optional): Description of task, if new task is created.\n\nReturns:\n    BinaryIO: A readable file-like object in binary mode.\n\nRaises:\n    ValueError: When an invalid mode is given.",
        "code": "def open(\n        self,\n        file: Union[str, \"PathLike[str]\", bytes],\n        mode: Union[Literal[\"rb\"], Literal[\"rt\"], Literal[\"r\"]] = \"r\",\n        buffering: int = -1,\n        encoding: Optional[str] = None,\n        errors: Optional[str] = None,\n        newline: Optional[str] = None,\n        *,\n        total: Optional[int] = None,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Reading...\",\n    ) -> Union[BinaryIO, TextIO]:\n        \"\"\"Track progress while reading from a binary file.\n\n        Args:\n            path (Union[str, PathLike[str]]): The path to the file to read.\n            mode (str): The mode to use to open the file. Only supports \"r\", \"rb\" or \"rt\".\n            buffering (int): The buffering strategy to use, see :func:`io.open`.\n            encoding (str, optional): The encoding to use when reading in text mode, see :func:`io.open`.\n            errors (str, optional): The error handling strategy for decoding errors, see :func:`io.open`.\n            newline (str, optional): The strategy for handling newlines in text mode, see :func:`io.open`.\n            total (int, optional): Total number of bytes to read. If none given, os.stat(path).st_size is used.\n            task_id (TaskID): Task to track. Default is new task.\n            description (str, optional): Description of task, if new task is created.\n\n        Returns:\n            BinaryIO: A readable file-like object in binary mode.\n\n        Raises:\n            ValueError: When an invalid mode is given.\n        \"\"\"\n        # normalize the mode (always rb, rt)\n        _mode = \"\".join(sorted(mode, reverse=False))\n        if _mode not in (\"br\", \"rt\", \"r\"):\n            raise ValueError(f\"invalid mode {mode!r}\")\n\n        # patch buffering to provide the same behaviour as the builtin `open`\n        line_buffering = buffering == 1\n        if _mode == \"br\" and buffering == 1:\n            warnings.warn(\n                \"line buffering (buffering=1) isn't supported in binary mode, the default buffer size will be used\",\n                RuntimeWarning,\n            )\n            buffering = -1\n        elif _mode in (\"rt\", \"r\"):\n            if buffering == 0:\n                raise ValueError(\"can't have unbuffered text I/O\")\n            elif buffering == 1:\n                buffering = -1\n\n        # attempt to get the total with `os.stat`\n        if total is None:\n            total = stat(file).st_size\n\n        # update total of task or create new task\n        if task_id is None:\n            task_id = self.add_task(description, total=total)\n        else:\n            self.update(task_id, total=total)\n\n        # open the file in binary mode,\n        handle = io.open(file, \"rb\", buffering=buffering)\n        reader = _Reader(handle, self, task_id, close_handle=True)\n\n        # wrap the reader in a `TextIOWrapper` if text mode\n        if mode in (\"r\", \"rt\"):\n            return io.TextIOWrapper(\n                reader,\n                encoding=encoding,\n                errors=errors,\n                newline=newline,\n                line_buffering=line_buffering,\n            )\n\n        return reader",
        "line_count": 76,
        "needs_llm_summary": true
      },
      {
        "name": "start_task",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task_id",
            "type": "TaskID"
          }
        ],
        "return_type": "None",
        "lineno": 1387,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.get_time"
        ],
        "docstring": "Start a task.\n\nStarts a task (used when calculating elapsed time). You may need to call this manually,\nif you called ``add_task`` with ``start=False``.\n\nArgs:\n    task_id (TaskID): ID of task.",
        "code": "def start_task(self, task_id: TaskID) -> None:\n        \"\"\"Start a task.\n\n        Starts a task (used when calculating elapsed time). You may need to call this manually,\n        if you called ``add_task`` with ``start=False``.\n\n        Args:\n            task_id (TaskID): ID of task.\n        \"\"\"\n        with self._lock:\n            task = self._tasks[task_id]\n            if task.start_time is None:\n                task.start_time = self.get_time()",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "stop_task",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task_id",
            "type": "TaskID"
          }
        ],
        "return_type": "None",
        "lineno": 1401,
        "decorators": [],
        "is_async": false,
        "calls": [
          "current_time",
          "self.get_time"
        ],
        "docstring": "Stop a task.\n\nThis will freeze the elapsed time on the task.\n\nArgs:\n    task_id (TaskID): ID of task.",
        "code": "def stop_task(self, task_id: TaskID) -> None:\n        \"\"\"Stop a task.\n\n        This will freeze the elapsed time on the task.\n\n        Args:\n            task_id (TaskID): ID of task.\n        \"\"\"\n        with self._lock:\n            task = self._tasks[task_id]\n            current_time = self.get_time()\n            if task.start_time is None:\n                task.start_time = current_time\n            task.stop_time = current_time",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task_id",
            "type": "TaskID"
          }
        ],
        "return_type": "None",
        "lineno": 1416,
        "decorators": [],
        "is_async": false,
        "calls": [
          "total",
          "description",
          "_progress.popleft",
          "task.elapsed",
          "self.refresh",
          "completed",
          "current_time",
          "fields",
          "update_completed",
          "task.fields.update",
          "visible",
          "popleft",
          "_progress.append",
          "ProgressSample",
          "task._progress",
          "task.completed",
          "self.get_time",
          "task._reset"
        ],
        "docstring": "Update information associated with a task.\n\nArgs:\n    task_id (TaskID): Task id (returned by add_task).\n    total (float, optional): Updates task.total if not None.\n    completed (float, optional): Updates task.completed if not None.\n    advance (float, optional): Add a value to task.completed if not None.\n    description (str, optional): Change task description if not None.\n    visible (bool, optional): Set visible flag if not None.\n    refresh (bool): Force a refresh of progress information. Default is False.\n    **fields (Any): Additional data fields required for rendering.",
        "code": "def update(\n        self,\n        task_id: TaskID,\n        *,\n        total: Optional[float] = None,\n        completed: Optional[float] = None,\n        advance: Optional[float] = None,\n        description: Optional[str] = None,\n        visible: Optional[bool] = None,\n        refresh: bool = False,\n        **fields: Any,\n    ) -> None:\n        \"\"\"Update information associated with a task.\n\n        Args:\n            task_id (TaskID): Task id (returned by add_task).\n            total (float, optional): Updates task.total if not None.\n            completed (float, optional): Updates task.completed if not None.\n            advance (float, optional): Add a value to task.completed if not None.\n            description (str, optional): Change task description if not None.\n            visible (bool, optional): Set visible flag if not None.\n            refresh (bool): Force a refresh of progress information. Default is False.\n            **fields (Any): Additional data fields required for rendering.\n        \"\"\"\n        with self._lock:\n            task = self._tasks[task_id]\n            completed_start = task.completed\n\n            if total is not None and total != task.total:\n                task.total = total\n                task._reset()\n            if advance is not None:\n                task.completed += advance\n            if completed is not None:\n                task.completed = completed\n            if description is not None:\n                task.description = description\n            if visible is not None:\n                task.visible = visible\n            task.fields.update(fields)\n            update_completed = task.completed - completed_start\n\n            current_time = self.get_time()\n            old_sample_time = current_time - self.speed_estimate_period\n            _progress = task._progress\n\n            popleft = _progress.popleft\n            while _progress and _progress[0].timestamp < old_sample_time:\n                popleft()\n            if update_completed > 0:\n                _progress.append(ProgressSample(current_time, update_completed))\n            if (\n                task.total is not None\n                and task.completed >= task.total\n                and task.finished_time is None\n            ):\n                task.finished_time = task.elapsed\n\n        if refresh:\n            self.refresh()",
        "line_count": 60,
        "needs_llm_summary": true
      },
      {
        "name": "reset",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task_id",
            "type": "TaskID"
          }
        ],
        "return_type": "None",
        "lineno": 1477,
        "decorators": [],
        "is_async": false,
        "calls": [
          "total",
          "description",
          "self.refresh",
          "completed",
          "fields",
          "visible",
          "self.get_time",
          "task._reset"
        ],
        "docstring": "Reset a task so completed is 0 and the clock is reset.\n\nArgs:\n    task_id (TaskID): ID of task.\n    start (bool, optional): Start the task after reset. Defaults to True.\n    total (float, optional): New total steps in task, or None to use current total. Defaults to None.\n    completed (int, optional): Number of steps completed. Defaults to 0.\n    visible (bool, optional): Enable display of the task. Defaults to True.\n    description (str, optional): Change task description if not None. Defaults to None.\n    **fields (str): Additional data fields required for rendering.",
        "code": "def reset(\n        self,\n        task_id: TaskID,\n        *,\n        start: bool = True,\n        total: Optional[float] = None,\n        completed: int = 0,\n        visible: Optional[bool] = None,\n        description: Optional[str] = None,\n        **fields: Any,\n    ) -> None:\n        \"\"\"Reset a task so completed is 0 and the clock is reset.\n\n        Args:\n            task_id (TaskID): ID of task.\n            start (bool, optional): Start the task after reset. Defaults to True.\n            total (float, optional): New total steps in task, or None to use current total. Defaults to None.\n            completed (int, optional): Number of steps completed. Defaults to 0.\n            visible (bool, optional): Enable display of the task. Defaults to True.\n            description (str, optional): Change task description if not None. Defaults to None.\n            **fields (str): Additional data fields required for rendering.\n        \"\"\"\n        current_time = self.get_time()\n        with self._lock:\n            task = self._tasks[task_id]\n            task._reset()\n            task.start_time = current_time if start else None\n            if total is not None:\n                task.total = total\n            task.completed = completed\n            if visible is not None:\n                task.visible = visible\n            if fields:\n                task.fields = fields\n            if description is not None:\n                task.description = description\n            task.finished_time = None\n        self.refresh()",
        "line_count": 38,
        "needs_llm_summary": true
      },
      {
        "name": "advance",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task_id",
            "type": "TaskID"
          },
          {
            "name": "advance",
            "type": "float"
          }
        ],
        "return_type": "None",
        "lineno": 1516,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_progress.popleft",
          "task.elapsed",
          "task.speed",
          "current_time",
          "update_completed",
          "_progress.append",
          "popleft",
          "ProgressSample",
          "task._progress",
          "task.completed",
          "_progress",
          "self.get_time",
          "len"
        ],
        "docstring": "Advance task by a number of steps.\n\nArgs:\n    task_id (TaskID): ID of task.\n    advance (float): Number of steps to advance. Default is 1.",
        "code": "def advance(self, task_id: TaskID, advance: float = 1) -> None:\n        \"\"\"Advance task by a number of steps.\n\n        Args:\n            task_id (TaskID): ID of task.\n            advance (float): Number of steps to advance. Default is 1.\n        \"\"\"\n        current_time = self.get_time()\n        with self._lock:\n            task = self._tasks[task_id]\n            completed_start = task.completed\n            task.completed += advance\n            update_completed = task.completed - completed_start\n            old_sample_time = current_time - self.speed_estimate_period\n            _progress = task._progress\n\n            popleft = _progress.popleft\n            while _progress and _progress[0].timestamp < old_sample_time:\n                popleft()\n            while len(_progress) > 1000:\n                popleft()\n            _progress.append(ProgressSample(current_time, update_completed))\n            if (\n                task.total is not None\n                and task.completed >= task.total\n                and task.finished_time is None\n            ):\n                task.finished_time = task.elapsed\n                task.finished_speed = task.speed",
        "line_count": 29,
        "needs_llm_summary": true
      },
      {
        "name": "refresh",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 1546,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.live.refresh"
        ],
        "docstring": "Refresh (render) the progress information.",
        "code": "def refresh(self) -> None:\n        \"\"\"Refresh (render) the progress information.\"\"\"\n        if not self.disable and self.live.is_started:\n            self.live.refresh()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "get_renderable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 1551,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.get_renderables",
          "Group"
        ],
        "docstring": "Get a renderable for the progress display.",
        "code": "def get_renderable(self) -> RenderableType:\n        \"\"\"Get a renderable for the progress display.\"\"\"\n        renderable = Group(*self.get_renderables())\n        return renderable",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "get_renderables",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Iterable[RenderableType]",
        "lineno": 1556,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.tasks",
          "self.make_tasks_table"
        ],
        "docstring": "Get a number of renderables for the progress display.",
        "code": "def get_renderables(self) -> Iterable[RenderableType]:\n        \"\"\"Get a number of renderables for the progress display.\"\"\"\n        table = self.make_tasks_table(self.tasks)\n        yield table",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "make_tasks_table",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "tasks",
            "type": "Iterable[Task]"
          }
        ],
        "return_type": "Table",
        "lineno": 1561,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "column",
          "str",
          "Column",
          "_column.get_table_column",
          "Table.grid",
          "self.expand",
          "task",
          "unknown.copy",
          "_column",
          "table.add_row",
          "column.format"
        ],
        "docstring": "Get a table to render the Progress display.\n\nArgs:\n    tasks (Iterable[Task]): An iterable of Task instances, one per row of the table.\n\nReturns:\n    Table: A table instance.",
        "code": "def make_tasks_table(self, tasks: Iterable[Task]) -> Table:\n        \"\"\"Get a table to render the Progress display.\n\n        Args:\n            tasks (Iterable[Task]): An iterable of Task instances, one per row of the table.\n\n        Returns:\n            Table: A table instance.\n        \"\"\"\n        table_columns = (\n            (\n                Column(no_wrap=True)\n                if isinstance(_column, str)\n                else _column.get_table_column().copy()\n            )\n            for _column in self.columns\n        )\n        table = Table.grid(*table_columns, padding=(0, 1), expand=self.expand)\n\n        for task in tasks:\n            if task.visible:\n                table.add_row(\n                    *(\n                        (\n                            column.format(task=task)\n                            if isinstance(column, str)\n                            else column(task)\n                        )\n                        for column in self.columns\n                    )\n                )\n        return table",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 1594,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.get_renderable"
        ],
        "docstring": "Makes the Progress class itself renderable.",
        "code": "def __rich__(self) -> RenderableType:\n        \"\"\"Makes the Progress class itself renderable.\"\"\"\n        with self._lock:\n            return self.get_renderable()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "add_task",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "description",
            "type": "str"
          },
          {
            "name": "start",
            "type": "bool"
          },
          {
            "name": "total",
            "type": "Optional[float]"
          },
          {
            "name": "completed",
            "type": "int"
          },
          {
            "name": "visible",
            "type": "bool"
          }
        ],
        "return_type": "TaskID",
        "lineno": 1599,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._task_index",
          "description",
          "total",
          "self.refresh",
          "Task",
          "completed",
          "TaskID",
          "fields",
          "self._lock",
          "visible",
          "self.start_task",
          "int",
          "self.get_time",
          "task"
        ],
        "docstring": "Add a new 'task' to the Progress display.\n\nArgs:\n    description (str): A description of the task.\n    start (bool, optional): Start the task immediately (to calculate elapsed time). If set to False,\n        you will need to call `start` manually. Defaults to True.\n    total (float, optional): Number of total steps in the progress if known.\n        Set to None to render a pulsing animation. Defaults to 100.\n    completed (int, optional): Number of steps completed so far. Defaults to 0.\n    visible (bool, optional): Enable display of the task. Defaults to True.\n    **fields (str): Additional data fields required for rendering.\n\nReturns:\n    TaskID: An ID you can use when calling `update`.",
        "code": "def add_task(\n        self,\n        description: str,\n        start: bool = True,\n        total: Optional[float] = 100.0,\n        completed: int = 0,\n        visible: bool = True,\n        **fields: Any,\n    ) -> TaskID:\n        \"\"\"Add a new 'task' to the Progress display.\n\n        Args:\n            description (str): A description of the task.\n            start (bool, optional): Start the task immediately (to calculate elapsed time). If set to False,\n                you will need to call `start` manually. Defaults to True.\n            total (float, optional): Number of total steps in the progress if known.\n                Set to None to render a pulsing animation. Defaults to 100.\n            completed (int, optional): Number of steps completed so far. Defaults to 0.\n            visible (bool, optional): Enable display of the task. Defaults to True.\n            **fields (str): Additional data fields required for rendering.\n\n        Returns:\n            TaskID: An ID you can use when calling `update`.\n        \"\"\"\n        with self._lock:\n            task = Task(\n                self._task_index,\n                description,\n                total,\n                completed,\n                visible=visible,\n                fields=fields,\n                _get_time=self.get_time,\n                _lock=self._lock,\n            )\n            self._tasks[self._task_index] = task\n            if start:\n                self.start_task(self._task_index)\n            new_task_index = self._task_index\n            self._task_index = TaskID(int(self._task_index) + 1)\n        self.refresh()\n        return new_task_index",
        "line_count": 42,
        "needs_llm_summary": true
      },
      {
        "name": "remove_task",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "task_id",
            "type": "TaskID"
          }
        ],
        "return_type": "None",
        "lineno": 1642,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Delete a task if it exists.\n\nArgs:\n    task_id (TaskID): A task ID.",
        "code": "def remove_task(self, task_id: TaskID) -> None:\n        \"\"\"Delete a task if it exists.\n\n        Args:\n            task_id (TaskID): A task ID.\n\n        \"\"\"\n        with self._lock:\n            del self._tasks[task_id]",
        "line_count": 9,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "_TrackThread",
        "methods": [
          "__init__",
          "run",
          "__enter__",
          "__exit__"
        ],
        "base_classes": [
          "Thread"
        ],
        "lineno": 64,
        "docstring": "A thread to periodically update progress."
      },
      {
        "name": "_Reader",
        "methods": [
          "__init__",
          "__enter__",
          "__exit__",
          "__iter__",
          "__next__",
          "closed",
          "fileno",
          "isatty",
          "mode",
          "name",
          "readable",
          "seekable",
          "writable",
          "read",
          "readinto",
          "readline",
          "readlines",
          "close",
          "seek",
          "tell",
          "write",
          "writelines"
        ],
        "base_classes": [
          "RawIOBase",
          "BinaryIO"
        ],
        "lineno": 182,
        "docstring": "A reader that tracks progress while it's being read from."
      },
      {
        "name": "_ReadContext",
        "methods": [
          "__init__",
          "__enter__",
          "__exit__"
        ],
        "base_classes": [
          "unknown",
          "unknown"
        ],
        "lineno": 285,
        "docstring": "A utility class to handle a context for both a reader and a progress."
      },
      {
        "name": "ProgressColumn",
        "methods": [
          "__init__",
          "get_table_column",
          "__call__",
          "render"
        ],
        "base_classes": [
          "ABC"
        ],
        "lineno": 507,
        "docstring": "Base class for a widget to use in progress display."
      },
      {
        "name": "RenderableColumn",
        "methods": [
          "__init__",
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 549,
        "docstring": "A column to insert an arbitrary column.\n\nArgs:\n    renderable (RenderableType, optional): Any renderable. Defaults to empty string."
      },
      {
        "name": "SpinnerColumn",
        "methods": [
          "__init__",
          "set_spinner",
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 566,
        "docstring": "A column with a 'spinner' animation.\n\nArgs:\n    spinner_name (str, optional): Name of spinner animation. Defaults to \"dots\".\n    style (StyleType, optional): Style of spinner. Defaults to \"progress.spinner\".\n    speed (float, optional): Speed factor of spinner. Defaults to 1.0.\n    finished_text (TextType, optional): Text used when task is finished. Defaults to \" \"."
      },
      {
        "name": "TextColumn",
        "methods": [
          "__init__",
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 616,
        "docstring": "A column containing text."
      },
      {
        "name": "BarColumn",
        "methods": [
          "__init__",
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 646,
        "docstring": "Renders a visual progress bar.\n\nArgs:\n    bar_width (Optional[int], optional): Width of bar or None for full width. Defaults to 40.\n    style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n    complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n    finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n    pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\"."
      },
      {
        "name": "TimeElapsedColumn",
        "methods": [
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 688,
        "docstring": "Renders time elapsed."
      },
      {
        "name": "TaskProgressColumn",
        "methods": [
          "__init__",
          "render_speed",
          "render"
        ],
        "base_classes": [
          "TextColumn"
        ],
        "lineno": 700,
        "docstring": "Show task progress as a percentage.\n\nArgs:\n    text_format (str, optional): Format for percentage display. Defaults to \"[progress.percentage]{task.percentage:>3.0f}%\".\n    text_format_no_percentage (str, optional): Format if percentage is unknown. Defaults to \"\".\n    style (StyleType, optional): Style of output. Defaults to \"none\".\n    justify (JustifyMethod, optional): Text justification. Defaults to \"left\".\n    markup (bool, optional): Enable markup. Defaults to True.\n    highlighter (Optional[Highlighter], optional): Highlighter to apply to output. Defaults to None.\n    table_column (Optional[Column], optional): Table Column to use. Defaults to None.\n    show_speed (bool, optional): Show speed if total is unknown. Defaults to False."
      },
      {
        "name": "TimeRemainingColumn",
        "methods": [
          "__init__",
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 772,
        "docstring": "Renders estimated time remaining.\n\nArgs:\n    compact (bool, optional): Render MM:SS when time remaining is less than an hour. Defaults to False.\n    elapsed_when_finished (bool, optional): Render time elapsed when the task is finished. Defaults to False."
      },
      {
        "name": "FileSizeColumn",
        "methods": [
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 820,
        "docstring": "Renders completed filesize."
      },
      {
        "name": "TotalFileSizeColumn",
        "methods": [
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 829,
        "docstring": "Renders total filesize."
      },
      {
        "name": "MofNCompleteColumn",
        "methods": [
          "__init__",
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 838,
        "docstring": "Renders completed count/total, e.g. '  10/1000'.\n\nBest for bounded tasks with int quantities.\n\nSpace pads the completed count so that progress length does not change as task progresses\npast powers of 10.\n\nArgs:\n    separator (str, optional): Text to separate completed and total values. Defaults to \"/\"."
      },
      {
        "name": "DownloadColumn",
        "methods": [
          "__init__",
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 865,
        "docstring": "Renders file size downloaded and total, e.g. '0.5/2.3 GB'.\n\nArgs:\n    binary_units (bool, optional): Use binary units, KiB, MiB etc. Defaults to False."
      },
      {
        "name": "TransferSpeedColumn",
        "methods": [
          "render"
        ],
        "base_classes": [
          "ProgressColumn"
        ],
        "lineno": 914,
        "docstring": "Renders human readable transfer speed."
      },
      {
        "name": "ProgressSample",
        "methods": [],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 926,
        "docstring": "Sample of progress for a given time."
      },
      {
        "name": "Task",
        "methods": [
          "get_time",
          "started",
          "remaining",
          "elapsed",
          "finished",
          "percentage",
          "speed",
          "time_remaining",
          "_reset"
        ],
        "base_classes": [],
        "lineno": 936,
        "docstring": "Information regarding a progress task.\n\nThis object should be considered read-only outside of the :class:`~Progress` class."
      },
      {
        "name": "Progress",
        "methods": [
          "__init__",
          "get_default_columns",
          "console",
          "tasks",
          "task_ids",
          "finished",
          "start",
          "stop",
          "__enter__",
          "__exit__",
          "track",
          "wrap_file",
          "open",
          "open",
          "open",
          "start_task",
          "stop_task",
          "update",
          "reset",
          "advance",
          "refresh",
          "get_renderable",
          "get_renderables",
          "make_tasks_table",
          "__rich__",
          "add_task",
          "remove_task"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 1061,
        "docstring": "Renders an auto-updating progress bar(s).\n\nArgs:\n    console (Console, optional): Optional Console instance. Defaults to an internal Console instance writing to stdout.\n    auto_refresh (bool, optional): Enable auto refresh. If disabled, you will need to call `refresh()`.\n    refresh_per_second (Optional[float], optional): Number of times per second to refresh the progress information or None to use default (10). Defaults to None.\n    speed_estimate_period: (float, optional): Period (in seconds) used to calculate the speed estimate. Defaults to 30.\n    transient: (bool, optional): Clear the progress on exit. Defaults to False.\n    redirect_stdout: (bool, optional): Enable redirection of stdout, so ``print`` may be used. Defaults to True.\n    redirect_stderr: (bool, optional): Enable redirection of stderr. Defaults to True.\n    get_time: (Callable, optional): A callable that gets the current time, or None to use Console.get_time. Defaults to None.\n    disable (bool, optional): Disable progress display. Defaults to False\n    expand (bool, optional): Expand tasks table to fit width. Defaults to False."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "typing",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "warnings",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "abc",
        "name": "ABC",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "abc",
        "name": "abstractmethod",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "collections",
        "name": "deque",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "dataclass",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "field",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "datetime",
        "name": "timedelta",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "io",
        "name": "RawIOBase",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "io",
        "name": "UnsupportedOperation",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "math",
        "name": "ceil",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "mmap",
        "name": "mmap",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "operator",
        "name": "length_hint",
        "alias": null,
        "lineno": 13,
        "type": "from_import"
      },
      {
        "module": "os",
        "name": "PathLike",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "os",
        "name": "stat",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "threading",
        "name": "Event",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "threading",
        "name": "RLock",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "threading",
        "name": "Thread",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "BinaryIO",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "ContextManager",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Deque",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Generic",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Literal",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NewType",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TextIO",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TypeVar",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "filesize",
        "alias": null,
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "get_console",
        "alias": null,
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Group",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "JustifyMethod",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "Highlighter",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "live",
        "name": "Live",
        "alias": null,
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "progress_bar",
        "name": "ProgressBar",
        "alias": null,
        "lineno": 48,
        "type": "from_import"
      },
      {
        "module": "spinner",
        "name": "Spinner",
        "alias": null,
        "lineno": 49,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Column",
        "alias": null,
        "lineno": 51,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 51,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 52,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 52,
        "type": "from_import"
      },
      {
        "module": "typing_extensions",
        "name": "Self",
        "alias": null,
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "random",
        "alias": null,
        "lineno": 1654,
        "type": "import"
      },
      {
        "module": "time",
        "alias": null,
        "lineno": 1655,
        "type": "import"
      },
      {
        "module": "panel",
        "name": "Panel",
        "alias": null,
        "lineno": 1657,
        "type": "from_import"
      },
      {
        "module": "rule",
        "name": "Rule",
        "alias": null,
        "lineno": 1658,
        "type": "from_import"
      },
      {
        "module": "syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 1659,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 1660,
        "type": "from_import"
      },
      {
        "module": "itertools",
        "name": "cycle",
        "alias": null,
        "lineno": 1693,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "TaskID",
        "assigned_to": "NewType",
        "lineno": 54
      },
      {
        "name": "ProgressType",
        "assigned_to": "TypeVar",
        "lineno": 56
      },
      {
        "name": "GetTimeCallable",
        "assigned_to": null,
        "lineno": 58
      },
      {
        "name": "_I",
        "assigned_to": "typing.TypeVar",
        "lineno": 61
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "random.randint",
      "TimeElapsedColumn",
      "Progress",
      "time.sleep",
      "next",
      "Console",
      "Panel",
      "Progress.get_default_columns",
      "Rule",
      "progress.add_task",
      "cycle",
      "Syntax",
      "SpinnerColumn",
      "progress.update",
      "table.add_row",
      "Table",
      "progress.log"
    ],
    "module_level_calls": {
      "function_calls": [
        "examples",
        "time.sleep",
        "next",
        "Panel",
        "task1",
        "Rule",
        "cycle",
        "TextIO",
        "NewType",
        "table.add_row",
        "SpinnerColumn",
        "progress.update",
        "progress.log",
        "Progress",
        "Syntax",
        "random.randint",
        "int",
        "TimeElapsedColumn",
        "typing.TypeVar",
        "Console",
        "task2",
        "progress.add_task",
        "Progress.get_default_columns",
        "console",
        "BinaryIO",
        "progress_renderables",
        "TypeVar",
        "Table"
      ],
      "class_instantiations": [
        "TimeElapsedColumn",
        "Progress",
        "Console",
        "Panel",
        "Rule",
        "Syntax",
        "TypeVar",
        "NewType",
        "Table",
        "SpinnerColumn"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "io",
        "abc",
        "datetime",
        "typing",
        "threading",
        "dataclasses",
        "warnings",
        "os",
        "collections",
        "random",
        "itertools",
        "math",
        "time"
      ],
      "third_party": {
        "other": [
          "__future__",
          "mmap",
          "operator",
          "types",
          "filesize",
          "get_console",
          "console",
          "highlighter",
          "jupyter",
          "live",
          "progress_bar",
          "spinner",
          "style",
          "table",
          "text",
          "typing_extensions",
          "panel",
          "rule",
          "syntax"
        ]
      },
      "tech_stack": []
    },
    "line_count": 1716
  },
  "rich/progress_bar.py": {
    "filepath": "../rich/rich/progress_bar.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "total",
            "type": "Optional[float]"
          },
          {
            "name": "completed",
            "type": "float"
          },
          {
            "name": "width",
            "type": "Optional[int]"
          },
          {
            "name": "pulse",
            "type": "bool"
          },
          {
            "name": "style",
            "type": "StyleType"
          },
          {
            "name": "complete_style",
            "type": "StyleType"
          },
          {
            "name": "finished_style",
            "type": "StyleType"
          },
          {
            "name": "pulse_style",
            "type": "StyleType"
          },
          {
            "name": "animation_time",
            "type": "Optional[float]"
          }
        ],
        "return_type": null,
        "lineno": 33,
        "decorators": [],
        "is_async": false,
        "calls": [
          "total",
          "pulse",
          "completed",
          "style",
          "pulse_style",
          "complete_style",
          "width",
          "animation_time",
          "finished_style"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        total: Optional[float] = 100.0,\n        completed: float = 0,\n        width: Optional[int] = None,\n        pulse: bool = False,\n        style: StyleType = \"bar.back\",\n        complete_style: StyleType = \"bar.complete\",\n        finished_style: StyleType = \"bar.finished\",\n        pulse_style: StyleType = \"bar.pulse\",\n        animation_time: Optional[float] = None,\n    ):\n        self.total = total\n        self.completed = completed\n        self.width = width\n        self.pulse = pulse\n        self.style = style\n        self.complete_style = complete_style\n        self.finished_style = finished_style\n        self.pulse_style = pulse_style\n        self.animation_time = animation_time\n\n        self._pulse_segments: Optional[List[Segment]] = None",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 57,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"<Bar {self.completed!r} of {self.total!r}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "percentage_completed",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[float]",
        "lineno": 61,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "max",
          "min",
          "completed"
        ],
        "docstring": "Calculate percentage complete.",
        "code": "def percentage_completed(self) -> Optional[float]:\n        \"\"\"Calculate percentage complete.\"\"\"\n        if self.total is None:\n            return None\n        completed = (self.completed / self.total) * 100.0\n        completed = min(100, max(0.0, completed))\n        return completed",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_get_pulse_segments",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "fore_style",
            "type": "Style"
          },
          {
            "name": "back_style",
            "type": "Style"
          },
          {
            "name": "color_system",
            "type": "str"
          },
          {
            "name": "no_color",
            "type": "bool"
          },
          {
            "name": "ascii",
            "type": "bool"
          }
        ],
        "return_type": "List[Segment]",
        "lineno": 70,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 16
            }
          }
        ],
        "is_async": false,
        "calls": [
          "fore_style.color.get_truecolor",
          "lru_cache",
          "fore_style",
          "Style",
          "blend_rgb",
          "back_style",
          "back_color",
          "_Style",
          "color",
          "math.pi",
          "fore_color",
          "_Segment",
          "bar",
          "append",
          "PULSE_SIZE",
          "segments.append",
          "Segment",
          "from_triplet",
          "range",
          "cos",
          "back_style.color.get_truecolor",
          "Color.from_triplet",
          "math.cos",
          "ColorTriplet",
          "fade"
        ],
        "docstring": "Get a list of segments to render a pulse animation.\n\nReturns:\n    List[Segment]: A list of segments, one segment per character.",
        "code": "def _get_pulse_segments(\n        self,\n        fore_style: Style,\n        back_style: Style,\n        color_system: str,\n        no_color: bool,\n        ascii: bool = False,\n    ) -> List[Segment]:\n        \"\"\"Get a list of segments to render a pulse animation.\n\n        Returns:\n            List[Segment]: A list of segments, one segment per character.\n        \"\"\"\n        bar = \"-\" if ascii else \"\u2501\"\n        segments: List[Segment] = []\n        if color_system not in (\"standard\", \"eight_bit\", \"truecolor\") or no_color:\n            segments += [Segment(bar, fore_style)] * (PULSE_SIZE // 2)\n            segments += [Segment(\" \" if no_color else bar, back_style)] * (\n                PULSE_SIZE - (PULSE_SIZE // 2)\n            )\n            return segments\n\n        append = segments.append\n        fore_color = (\n            fore_style.color.get_truecolor()\n            if fore_style.color\n            else ColorTriplet(255, 0, 255)\n        )\n        back_color = (\n            back_style.color.get_truecolor()\n            if back_style.color\n            else ColorTriplet(0, 0, 0)\n        )\n        cos = math.cos\n        pi = math.pi\n        _Segment = Segment\n        _Style = Style\n        from_triplet = Color.from_triplet\n\n        for index in range(PULSE_SIZE):\n            position = index / PULSE_SIZE\n            fade = 0.5 + cos(position * pi * 2) / 2.0\n            color = blend_rgb(fore_color, back_color, cross_fade=fade)\n            append(_Segment(bar, _Style(color=from_triplet(color))))\n        return segments",
        "line_count": 45,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "completed",
            "type": "float"
          },
          {
            "name": "total",
            "type": "Optional[float]"
          }
        ],
        "return_type": "None",
        "lineno": 116,
        "decorators": [],
        "is_async": false,
        "calls": [
          "completed"
        ],
        "docstring": "Update progress with new values.\n\nArgs:\n    completed (float): Number of steps completed.\n    total (float, optional): Total number of steps, or ``None`` to not change. Defaults to None.",
        "code": "def update(self, completed: float, total: Optional[float] = None) -> None:\n        \"\"\"Update progress with new values.\n\n        Args:\n            completed (float): Number of steps completed.\n            total (float, optional): Total number of steps, or ``None`` to not change. Defaults to None.\n        \"\"\"\n        self.completed = completed\n        self.total = total if total is not None else self.total",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "_render_pulse",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "ascii",
            "type": "bool"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 126,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "pulse_segments",
          "console.no_color",
          "fore_style",
          "console.get_style",
          "self._get_pulse_segments",
          "self.pulse_style",
          "console.color_system",
          "monotonic",
          "ascii",
          "int",
          "back_style",
          "len"
        ],
        "docstring": "Renders the pulse animation.\n\nArgs:\n    console (Console): Console instance.\n    width (int): Width in characters of pulse animation.\n\nReturns:\n    RenderResult: [description]\n\nYields:\n    Iterator[Segment]: Segments to render pulse",
        "code": "def _render_pulse(\n        self, console: Console, width: int, ascii: bool = False\n    ) -> Iterable[Segment]:\n        \"\"\"Renders the pulse animation.\n\n        Args:\n            console (Console): Console instance.\n            width (int): Width in characters of pulse animation.\n\n        Returns:\n            RenderResult: [description]\n\n        Yields:\n            Iterator[Segment]: Segments to render pulse\n        \"\"\"\n        fore_style = console.get_style(self.pulse_style, default=\"white\")\n        back_style = console.get_style(self.style, default=\"black\")\n\n        pulse_segments = self._get_pulse_segments(\n            fore_style, back_style, console.color_system, console.no_color, ascii=ascii\n        )\n        segment_count = len(pulse_segments)\n        current_time = (\n            monotonic() if self.animation_time is None else self.animation_time\n        )\n        segments = pulse_segments * (int(width / segment_count) + 2)\n        offset = int(-current_time * 15) % segment_count\n        segments = segments[offset : offset + width]\n        yield from segments",
        "line_count": 29,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 156,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "min",
          "self._render_pulse",
          "options.max_width",
          "style",
          "console.get_style",
          "console",
          "complete_style",
          "half_bar_left",
          "width",
          "ascii",
          "max",
          "Segment",
          "int",
          "_Segment",
          "self.completed",
          "self.total"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = min(self.width or options.max_width, options.max_width)\n        ascii = options.legacy_windows or options.ascii_only\n        should_pulse = self.pulse or self.total is None\n        if should_pulse:\n            yield from self._render_pulse(console, width, ascii=ascii)\n            return\n\n        completed: Optional[float] = (\n            min(self.total, max(0, self.completed)) if self.total is not None else None\n        )\n\n        bar = \"-\" if ascii else \"\u2501\"\n        half_bar_right = \" \" if ascii else \"\u2578\"\n        half_bar_left = \" \" if ascii else \"\u257a\"\n        complete_halves = (\n            int(width * 2 * completed / self.total)\n            if self.total and completed is not None\n            else width * 2\n        )\n        bar_count = complete_halves // 2\n        half_bar_count = complete_halves % 2\n        style = console.get_style(self.style)\n        is_finished = self.total is None or self.completed >= self.total\n        complete_style = console.get_style(\n            self.finished_style if is_finished else self.complete_style\n        )\n        _Segment = Segment\n        if bar_count:\n            yield _Segment(bar * bar_count, complete_style)\n        if half_bar_count:\n            yield _Segment(half_bar_right * half_bar_count, complete_style)\n\n        if not console.no_color:\n            remaining_bars = width - bar_count - half_bar_count\n            if remaining_bars and console.color_system is not None:\n                if not half_bar_count and bar_count:\n                    yield _Segment(half_bar_left, style)\n                    remaining_bars -= 1\n                if remaining_bars:\n                    yield _Segment(bar * remaining_bars, style)",
        "line_count": 43,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 200,
        "decorators": [],
        "is_async": false,
        "calls": [
          "options.max_width",
          "self.width",
          "Measurement"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return (\n            Measurement(self.width, self.width)\n            if self.width is not None\n            else Measurement(4, options.max_width)\n        )",
        "line_count": 8,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ProgressBar",
        "methods": [
          "__init__",
          "__repr__",
          "percentage_completed",
          "_get_pulse_segments",
          "update",
          "_render_pulse",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 18,
        "docstring": "Renders a (progress) bar. Used by rich.progress.\n\nArgs:\n    total (float, optional): Number of steps in the bar. Defaults to 100. Set to None to render a pulsing animation.\n    completed (float, optional): Number of steps completed. Defaults to 0.\n    width (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.\n    pulse (bool, optional): Enable pulse effect. Defaults to False. Will pulse if a None total was passed.\n    style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n    complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n    finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n    pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n    animation_time (Optional[float], optional): Time in seconds to use for animation, or None to use system time."
      }
    ],
    "imports": [
      {
        "module": "math",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "functools",
        "name": "lru_cache",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "time",
        "name": "monotonic",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "Color",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "blend_rgb",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "color_triplet",
        "name": "ColorTriplet",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 12,
        "type": "from_import"
      },
      {
        "module": "time",
        "alias": null,
        "lineno": 214,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "PULSE_SIZE",
        "assigned_to": "int",
        "lineno": 15
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "range",
      "bar.update",
      "console.file.write",
      "time.sleep",
      "Console",
      "ProgressBar",
      "console.show_cursor"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "range",
        "bar.update",
        "console.file.write",
        "time.sleep",
        "Console",
        "n",
        "ProgressBar",
        "bar",
        "console.show_cursor"
      ],
      "class_instantiations": [
        "ProgressBar",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "math",
        "functools",
        "time",
        "typing"
      ],
      "third_party": {
        "other": [
          "color",
          "color_triplet",
          "console",
          "jupyter",
          "measure",
          "segment",
          "style"
        ]
      },
      "tech_stack": []
    },
    "line_count": 224
  },
  "rich/prompt.py": {
    "filepath": "../rich/rich/prompt.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "message",
            "type": "TextType"
          }
        ],
        "return_type": "None",
        "lineno": 23,
        "decorators": [],
        "is_async": false,
        "calls": [
          "message"
        ],
        "docstring": null,
        "code": "def __init__(self, message: TextType) -> None:\n        self.message = message",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "TextType",
        "lineno": 26,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich__(self) -> TextType:\n        return self.message",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "prompt",
            "type": "TextType"
          }
        ],
        "return_type": "None",
        "lineno": 54,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "prompt",
          "str",
          "show_default",
          "password",
          "Text.from_markup",
          "get_console",
          "case_sensitive",
          "show_choices",
          "choices"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        prompt: TextType = \"\",\n        *,\n        console: Optional[Console] = None,\n        password: bool = False,\n        choices: Optional[List[str]] = None,\n        case_sensitive: bool = True,\n        show_default: bool = True,\n        show_choices: bool = True,\n    ) -> None:\n        self.console = console or get_console()\n        self.prompt = (\n            Text.from_markup(prompt, style=\"prompt\")\n            if isinstance(prompt, str)\n            else prompt\n        )\n        self.password = password\n        if choices is not None:\n            self.choices = choices\n        self.case_sensitive = case_sensitive\n        self.show_default = show_default\n        self.show_choices = show_choices",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "ask",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "prompt",
            "type": "TextType"
          }
        ],
        "return_type": "Union[DefaultType, PromptType]",
        "lineno": 80,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def ask(\n        cls,\n        prompt: TextType = \"\",\n        *,\n        console: Optional[Console] = None,\n        password: bool = False,\n        choices: Optional[List[str]] = None,\n        case_sensitive: bool = True,\n        show_default: bool = True,\n        show_choices: bool = True,\n        default: DefaultType,\n        stream: Optional[TextIO] = None,\n    ) -> Union[DefaultType, PromptType]:\n        ...",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "ask",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "prompt",
            "type": "TextType"
          }
        ],
        "return_type": "PromptType",
        "lineno": 97,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def ask(\n        cls,\n        prompt: TextType = \"\",\n        *,\n        console: Optional[Console] = None,\n        password: bool = False,\n        choices: Optional[List[str]] = None,\n        case_sensitive: bool = True,\n        show_default: bool = True,\n        show_choices: bool = True,\n        stream: Optional[TextIO] = None,\n    ) -> PromptType:\n        ...",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "ask",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "prompt",
            "type": "TextType"
          }
        ],
        "return_type": "Any",
        "lineno": 112,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "stream",
          "_prompt",
          "prompt",
          "show_choices",
          "password",
          "show_default",
          "cls",
          "case_sensitive",
          "console",
          "choices",
          "default"
        ],
        "docstring": "Shortcut to construct and run a prompt loop and return the result.\n\nExample:\n    >>> filename = Prompt.ask(\"Enter a filename\")\n\nArgs:\n    prompt (TextType, optional): Prompt text. Defaults to \"\".\n    console (Console, optional): A Console instance or None to use global console. Defaults to None.\n    password (bool, optional): Enable password input. Defaults to False.\n    choices (List[str], optional): A list of valid choices. Defaults to None.\n    case_sensitive (bool, optional): Matching of choices should be case-sensitive. Defaults to True.\n    show_default (bool, optional): Show default in prompt. Defaults to True.\n    show_choices (bool, optional): Show choices in prompt. Defaults to True.\n    stream (TextIO, optional): Optional text file open for reading to get input. Defaults to None.",
        "code": "def ask(\n        cls,\n        prompt: TextType = \"\",\n        *,\n        console: Optional[Console] = None,\n        password: bool = False,\n        choices: Optional[List[str]] = None,\n        case_sensitive: bool = True,\n        show_default: bool = True,\n        show_choices: bool = True,\n        default: Any = ...,\n        stream: Optional[TextIO] = None,\n    ) -> Any:\n        \"\"\"Shortcut to construct and run a prompt loop and return the result.\n\n        Example:\n            >>> filename = Prompt.ask(\"Enter a filename\")\n\n        Args:\n            prompt (TextType, optional): Prompt text. Defaults to \"\".\n            console (Console, optional): A Console instance or None to use global console. Defaults to None.\n            password (bool, optional): Enable password input. Defaults to False.\n            choices (List[str], optional): A list of valid choices. Defaults to None.\n            case_sensitive (bool, optional): Matching of choices should be case-sensitive. Defaults to True.\n            show_default (bool, optional): Show default in prompt. Defaults to True.\n            show_choices (bool, optional): Show choices in prompt. Defaults to True.\n            stream (TextIO, optional): Optional text file open for reading to get input. Defaults to None.\n        \"\"\"\n        _prompt = cls(\n            prompt,\n            console=console,\n            password=password,\n            choices=choices,\n            case_sensitive=case_sensitive,\n            show_default=show_default,\n            show_choices=show_choices,\n        )\n        return _prompt(default=default, stream=stream)",
        "line_count": 38,
        "needs_llm_summary": true
      },
      {
        "name": "render_default",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "default",
            "type": "DefaultType"
          }
        ],
        "return_type": "Text",
        "lineno": 151,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Text"
        ],
        "docstring": "Turn the supplied default in to a Text instance.\n\nArgs:\n    default (DefaultType): Default value.\n\nReturns:\n    Text: Text containing rendering of default value.",
        "code": "def render_default(self, default: DefaultType) -> Text:\n        \"\"\"Turn the supplied default in to a Text instance.\n\n        Args:\n            default (DefaultType): Default value.\n\n        Returns:\n            Text: Text containing rendering of default value.\n        \"\"\"\n        return Text(f\"({default})\", \"prompt.default\")",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "make_prompt",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "default",
            "type": "DefaultType"
          }
        ],
        "return_type": "Text",
        "lineno": 162,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "_default",
          "self.render_default",
          "self.prompt_suffix",
          "self.prompt.copy",
          "unknown.join",
          "prompt.append",
          "self.choices",
          "choices",
          "default"
        ],
        "docstring": "Make prompt text.\n\nArgs:\n    default (DefaultType): Default value.\n\nReturns:\n    Text: Text to display in prompt.",
        "code": "def make_prompt(self, default: DefaultType) -> Text:\n        \"\"\"Make prompt text.\n\n        Args:\n            default (DefaultType): Default value.\n\n        Returns:\n            Text: Text to display in prompt.\n        \"\"\"\n        prompt = self.prompt.copy()\n        prompt.end = \"\"\n\n        if self.show_choices and self.choices:\n            _choices = \"/\".join(self.choices)\n            choices = f\"[{_choices}]\"\n            prompt.append(\" \")\n            prompt.append(choices, \"prompt.choices\")\n\n        if (\n            default != ...\n            and self.show_default\n            and isinstance(default, (str, self.response_type))\n        ):\n            prompt.append(\" \")\n            _default = self.render_default(default)\n            prompt.append(_default)\n\n        prompt.append(self.prompt_suffix)\n\n        return prompt",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "get_input",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "prompt",
            "type": "TextType"
          },
          {
            "name": "password",
            "type": "bool"
          },
          {
            "name": "stream",
            "type": "Optional[TextIO]"
          }
        ],
        "return_type": "str",
        "lineno": 194,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "stream",
          "console.input",
          "prompt",
          "password"
        ],
        "docstring": "Get input from user.\n\nArgs:\n    console (Console): Console instance.\n    prompt (TextType): Prompt text.\n    password (bool): Enable password entry.\n\nReturns:\n    str: String from user.",
        "code": "def get_input(\n        cls,\n        console: Console,\n        prompt: TextType,\n        password: bool,\n        stream: Optional[TextIO] = None,\n    ) -> str:\n        \"\"\"Get input from user.\n\n        Args:\n            console (Console): Console instance.\n            prompt (TextType): Prompt text.\n            password (bool): Enable password entry.\n\n        Returns:\n            str: String from user.\n        \"\"\"\n        return console.input(prompt, password=password, stream=stream)",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "check_choice",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "str"
          }
        ],
        "return_type": "bool",
        "lineno": 213,
        "decorators": [],
        "is_async": false,
        "calls": [
          "value.strip",
          "unknown.lower",
          "choice.lower"
        ],
        "docstring": "Check value is in the list of valid choices.\n\nArgs:\n    value (str): Value entered by user.\n\nReturns:\n    bool: True if choice was valid, otherwise False.",
        "code": "def check_choice(self, value: str) -> bool:\n        \"\"\"Check value is in the list of valid choices.\n\n        Args:\n            value (str): Value entered by user.\n\n        Returns:\n            bool: True if choice was valid, otherwise False.\n        \"\"\"\n        assert self.choices is not None\n        if self.case_sensitive:\n            return value.strip() in self.choices\n        return value.strip().lower() in [choice.lower() for choice in self.choices]",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "process_response",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "str"
          }
        ],
        "return_type": "PromptType",
        "lineno": 227,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.index",
          "value.strip",
          "value",
          "self.check_choice",
          "value.lower",
          "InvalidResponse",
          "self.response_type",
          "choice.lower",
          "self.illegal_choice_message",
          "self.validate_error_message"
        ],
        "docstring": "Process response from user, convert to prompt type.\n\nArgs:\n    value (str): String typed by user.\n\nRaises:\n    InvalidResponse: If ``value`` is invalid.\n\nReturns:\n    PromptType: The value to be returned from ask method.",
        "code": "def process_response(self, value: str) -> PromptType:\n        \"\"\"Process response from user, convert to prompt type.\n\n        Args:\n            value (str): String typed by user.\n\n        Raises:\n            InvalidResponse: If ``value`` is invalid.\n\n        Returns:\n            PromptType: The value to be returned from ask method.\n        \"\"\"\n        value = value.strip()\n        try:\n            return_value: PromptType = self.response_type(value)\n        except ValueError:\n            raise InvalidResponse(self.validate_error_message)\n\n        if self.choices is not None:\n            if not self.check_choice(value):\n                raise InvalidResponse(self.illegal_choice_message)\n\n            if not self.case_sensitive:\n                # return the original choice, not the lower case version\n                return_value = self.response_type(\n                    self.choices[\n                        [choice.lower() for choice in self.choices].index(value.lower())\n                    ]\n                )\n        return return_value",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "on_validate_error",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "str"
          },
          {
            "name": "error",
            "type": "InvalidResponse"
          }
        ],
        "return_type": "None",
        "lineno": 258,
        "decorators": [],
        "is_async": false,
        "calls": [
          "error",
          "self.console.print"
        ],
        "docstring": "Called to handle validation error.\n\nArgs:\n    value (str): String entered by user.\n    error (InvalidResponse): Exception instance the initiated the error.",
        "code": "def on_validate_error(self, value: str, error: InvalidResponse) -> None:\n        \"\"\"Called to handle validation error.\n\n        Args:\n            value (str): String entered by user.\n            error (InvalidResponse): Exception instance the initiated the error.\n        \"\"\"\n        self.console.print(error)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "pre_prompt",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 267,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Hook to display something before the prompt.",
        "code": "def pre_prompt(self) -> None:\n        \"\"\"Hook to display something before the prompt.\"\"\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "PromptType",
        "lineno": 271,
        "decorators": [
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __call__(self, *, stream: Optional[TextIO] = None) -> PromptType:\n        ...",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Union[PromptType, DefaultType]",
        "lineno": 275,
        "decorators": [
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __call__(\n        self, *, default: DefaultType, stream: Optional[TextIO] = None\n    ) -> Union[PromptType, DefaultType]:\n        ...",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__call__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Any",
        "lineno": 280,
        "decorators": [],
        "is_async": false,
        "calls": [
          "stream",
          "self.make_prompt",
          "self.pre_prompt",
          "prompt",
          "self.password",
          "self.process_response",
          "value",
          "error",
          "self.console",
          "self.get_input",
          "self.on_validate_error",
          "default"
        ],
        "docstring": "Run the prompt loop.\n\nArgs:\n    default (Any, optional): Optional default value.\n\nReturns:\n    PromptType: Processed value.",
        "code": "def __call__(self, *, default: Any = ..., stream: Optional[TextIO] = None) -> Any:\n        \"\"\"Run the prompt loop.\n\n        Args:\n            default (Any, optional): Optional default value.\n\n        Returns:\n            PromptType: Processed value.\n        \"\"\"\n        while True:\n            self.pre_prompt()\n            prompt = self.make_prompt(default)\n            value = self.get_input(self.console, prompt, self.password, stream=stream)\n            if value == \"\" and default != ...:\n                return default\n            try:\n                return_value = self.process_response(value)\n            except InvalidResponse as error:\n                self.on_validate_error(value, error)\n                continue\n            else:\n                return return_value",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "render_default",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "default",
            "type": "DefaultType"
          }
        ],
        "return_type": "Text",
        "lineno": 353,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.choices",
          "Text"
        ],
        "docstring": "Render the default as (y) or (n) rather than True/False.",
        "code": "def render_default(self, default: DefaultType) -> Text:\n        \"\"\"Render the default as (y) or (n) rather than True/False.\"\"\"\n        yes, no = self.choices\n        return Text(f\"({yes})\" if default else f\"({no})\", style=\"prompt.default\")",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "process_response",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "value",
            "type": "str"
          }
        ],
        "return_type": "bool",
        "lineno": 358,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.validate_error_message",
          "value.strip",
          "InvalidResponse",
          "unknown.lower"
        ],
        "docstring": "Convert choices to a bool.",
        "code": "def process_response(self, value: str) -> bool:\n        \"\"\"Convert choices to a bool.\"\"\"\n        value = value.strip().lower()\n        if value not in self.choices:\n            raise InvalidResponse(self.validate_error_message)\n        return value == self.choices[0]",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "PromptError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 11,
        "docstring": "Exception base class for prompt related errors."
      },
      {
        "name": "InvalidResponse",
        "methods": [
          "__init__",
          "__rich__"
        ],
        "base_classes": [
          "PromptError"
        ],
        "lineno": 15,
        "docstring": "Exception to indicate a response was invalid. Raise this within process_response() to indicate an error\nand provide an error message.\n\nArgs:\n    message (Union[str, Text]): Error message."
      },
      {
        "name": "PromptBase",
        "methods": [
          "__init__",
          "ask",
          "ask",
          "ask",
          "render_default",
          "make_prompt",
          "get_input",
          "check_choice",
          "process_response",
          "on_validate_error",
          "pre_prompt",
          "__call__",
          "__call__",
          "__call__"
        ],
        "base_classes": [
          "unknown"
        ],
        "lineno": 30,
        "docstring": "Ask the user for input until a valid response is received. This is the base class, see one of\nthe concrete classes for examples.\n\nArgs:\n    prompt (TextType, optional): Prompt text. Defaults to \"\".\n    console (Console, optional): A Console instance or None to use global console. Defaults to None.\n    password (bool, optional): Enable password input. Defaults to False.\n    choices (List[str], optional): A list of valid choices. Defaults to None.\n    case_sensitive (bool, optional): Matching of choices should be case-sensitive. Defaults to True.\n    show_default (bool, optional): Show default in prompt. Defaults to True.\n    show_choices (bool, optional): Show choices in prompt. Defaults to True."
      },
      {
        "name": "Prompt",
        "methods": [],
        "base_classes": [
          "unknown"
        ],
        "lineno": 304,
        "docstring": "A prompt that returns a str.\n\nExample:\n    >>> name = Prompt.ask(\"Enter your name\")"
      },
      {
        "name": "IntPrompt",
        "methods": [],
        "base_classes": [
          "unknown"
        ],
        "lineno": 316,
        "docstring": "A prompt that returns an integer.\n\nExample:\n    >>> burrito_count = IntPrompt.ask(\"How many burritos do you want to order\")"
      },
      {
        "name": "FloatPrompt",
        "methods": [],
        "base_classes": [
          "unknown"
        ],
        "lineno": 328,
        "docstring": "A prompt that returns a float.\n\nExample:\n    >>> temperature = FloatPrompt.ask(\"Enter desired temperature\")"
      },
      {
        "name": "Confirm",
        "methods": [
          "render_default",
          "process_response"
        ],
        "base_classes": [
          "unknown"
        ],
        "lineno": 340,
        "docstring": "A yes / no confirmation prompt.\n\nExample:\n    >>> if Confirm.ask(\"Continue\"):\n            run_job()"
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Generic",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TextIO",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TypeVar",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "overload",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "get_console",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 367,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "PromptType",
        "assigned_to": "TypeVar",
        "lineno": 7
      },
      {
        "name": "DefaultType",
        "assigned_to": "TypeVar",
        "lineno": 8
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "IntPrompt.ask",
      "Prompt.ask",
      "Confirm.ask",
      "print",
      "len"
    ],
    "module_level_calls": {
      "function_calls": [
        "password",
        "Prompt.ask",
        "IntPrompt.ask",
        "Confirm.ask",
        "TypeVar",
        "print",
        "len"
      ],
      "class_instantiations": [
        "TypeVar",
        "IntPrompt",
        "Prompt",
        "Confirm"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "get_console",
          "console",
          "text",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 401
  },
  "rich/protocol.py": {
    "filepath": "../rich/rich/protocol.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "is_renderable",
        "args": [
          {
            "name": "check_object",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 10,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "check_object",
          "str",
          "hasattr"
        ],
        "docstring": "Check if an object may be rendered by Rich.",
        "code": "def is_renderable(check_object: Any) -> bool:\n    \"\"\"Check if an object may be rendered by Rich.\"\"\"\n    return (\n        isinstance(check_object, str)\n        or hasattr(check_object, \"__rich__\")\n        or hasattr(check_object, \"__rich_console__\")\n    )",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "rich_cast",
        "args": [
          {
            "name": "renderable",
            "type": "object"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 19,
        "decorators": [],
        "is_async": false,
        "calls": [
          "RenderableType",
          "renderable_type",
          "getattr",
          "isclass",
          "set",
          "rich_visited_set.add",
          "cast_method",
          "_GIBBERISH",
          "renderable",
          "cast",
          "hasattr",
          "type",
          "repr"
        ],
        "docstring": "Cast an object to a renderable by calling __rich__ if present.\n\nArgs:\n    renderable (object): A potentially renderable object\n\nReturns:\n    object: The result of recursively calling __rich__.",
        "code": "def rich_cast(renderable: object) -> \"RenderableType\":\n    \"\"\"Cast an object to a renderable by calling __rich__ if present.\n\n    Args:\n        renderable (object): A potentially renderable object\n\n    Returns:\n        object: The result of recursively calling __rich__.\n    \"\"\"\n    from rich.console import RenderableType\n\n    rich_visited_set: Set[type] = set()  # Prevent potential infinite loop\n    while hasattr(renderable, \"__rich__\") and not isclass(renderable):\n        # Detect object which claim to have all the attributes\n        if hasattr(renderable, _GIBBERISH):\n            return repr(renderable)\n        cast_method = getattr(renderable, \"__rich__\")\n        renderable = cast_method()\n        renderable_type = type(renderable)\n        if renderable_type in rich_visited_set:\n            break\n        rich_visited_set.add(renderable_type)\n\n    return cast(RenderableType, renderable)",
        "line_count": 24,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "cast",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Set",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "inspect",
        "name": "isclass",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "_GIBBERISH",
        "assigned_to": "str",
        "lineno": 7
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "inspect",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 43
  },
  "rich/region.py": {
    "filepath": "../rich/rich/region.py",
    "module_docstring": null,
    "functions": [],
    "classes": [
      {
        "name": "Region",
        "methods": [],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 4,
        "docstring": "Defines a rectangular region of the screen."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {},
      "tech_stack": []
    },
    "line_count": 11
  },
  "rich/repr.py": {
    "filepath": "../rich/rich/repr.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "auto",
        "args": [
          {
            "name": "cls",
            "type": "Optional[Type[T]]"
          }
        ],
        "return_type": "Type[T]",
        "lineno": 28,
        "decorators": [
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def auto(cls: Optional[Type[T]]) -> Type[T]:\n    ...",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "auto",
        "args": [],
        "return_type": "Callable[Any, Type[T]]",
        "lineno": 33,
        "decorators": [
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def auto(*, angular: bool = False) -> Callable[[Type[T]], Type[T]]:\n    ...",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "auto",
        "args": [
          {
            "name": "cls",
            "type": "Optional[Type[T]]"
          }
        ],
        "return_type": "Union[Type[T], Callable[Any, Type[T]]]",
        "lineno": 37,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr_str",
          "self.__init__",
          "partial",
          "do_replace",
          "inspect.signature",
          "auto_repr",
          "arg",
          "auto_rich_repr",
          "unknown.join",
          "signature.parameters.items",
          "append",
          "value",
          "name",
          "ReprError",
          "cls",
          "hasattr",
          "self.__rich_repr__",
          "repr_str.append",
          "len",
          "isinstance",
          "getattr",
          "angular",
          "param.name",
          "tuple",
          "repr",
          "self"
        ],
        "docstring": "Class decorator to create __repr__ from __rich_repr__",
        "code": "def auto(\n    cls: Optional[Type[T]] = None, *, angular: Optional[bool] = None\n) -> Union[Type[T], Callable[[Type[T]], Type[T]]]:\n    \"\"\"Class decorator to create __repr__ from __rich_repr__\"\"\"\n\n    def do_replace(cls: Type[T], angular: Optional[bool] = None) -> Type[T]:\n        def auto_repr(self: T) -> str:\n            \"\"\"Create repr string from __rich_repr__\"\"\"\n            repr_str: List[str] = []\n            append = repr_str.append\n\n            angular: bool = getattr(self.__rich_repr__, \"angular\", False)  # type: ignore[attr-defined]\n            for arg in self.__rich_repr__():  # type: ignore[attr-defined]\n                if isinstance(arg, tuple):\n                    if len(arg) == 1:\n                        append(repr(arg[0]))\n                    else:\n                        key, value, *default = arg\n                        if key is None:\n                            append(repr(value))\n                        else:\n                            if default and default[0] == value:\n                                continue\n                            append(f\"{key}={value!r}\")\n                else:\n                    append(repr(arg))\n            if angular:\n                return f\"<{self.__class__.__name__} {' '.join(repr_str)}>\"\n            else:\n                return f\"{self.__class__.__name__}({', '.join(repr_str)})\"\n\n        def auto_rich_repr(self: Type[T]) -> Result:\n            \"\"\"Auto generate __rich_rep__ from signature of __init__\"\"\"\n            try:\n                signature = inspect.signature(self.__init__)\n                for name, param in signature.parameters.items():\n                    if param.kind == param.POSITIONAL_ONLY:\n                        yield getattr(self, name)\n                    elif param.kind in (\n                        param.POSITIONAL_OR_KEYWORD,\n                        param.KEYWORD_ONLY,\n                    ):\n                        if param.default is param.empty:\n                            yield getattr(self, param.name)\n                        else:\n                            yield param.name, getattr(self, param.name), param.default\n            except Exception as error:\n                raise ReprError(\n                    f\"Failed to auto generate __rich_repr__; {error}\"\n                ) from None\n\n        if not hasattr(cls, \"__rich_repr__\"):\n            auto_rich_repr.__doc__ = \"Build a rich repr\"\n            cls.__rich_repr__ = auto_rich_repr  # type: ignore[attr-defined]\n\n        auto_repr.__doc__ = \"Return repr(self)\"\n        cls.__repr__ = auto_repr  # type: ignore[assignment]\n        if angular is not None:\n            cls.__rich_repr__.angular = angular  # type: ignore[attr-defined]\n        return cls\n\n    if cls is None:\n        return partial(do_replace, angular=angular)\n    else:\n        return do_replace(cls, angular=angular)",
        "line_count": 65,
        "needs_llm_summary": true
      },
      {
        "name": "rich_repr",
        "args": [
          {
            "name": "cls",
            "type": "Optional[Type[T]]"
          }
        ],
        "return_type": "Type[T]",
        "lineno": 105,
        "decorators": [
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def rich_repr(cls: Optional[Type[T]]) -> Type[T]:\n    ...",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "rich_repr",
        "args": [],
        "return_type": "Callable[Any, Type[T]]",
        "lineno": 110,
        "decorators": [
          {
            "name": "overload",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def rich_repr(*, angular: bool = False) -> Callable[[Type[T]], Type[T]]:\n    ...",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "rich_repr",
        "args": [
          {
            "name": "cls",
            "type": "Optional[Type[T]]"
          }
        ],
        "return_type": "Union[Type[T], Callable[Any, Type[T]]]",
        "lineno": 114,
        "decorators": [],
        "is_async": false,
        "calls": [
          "angular",
          "cls",
          "auto"
        ],
        "docstring": null,
        "code": "def rich_repr(\n    cls: Optional[Type[T]] = None, *, angular: bool = False\n) -> Union[Type[T], Callable[[Type[T]], Type[T]]]:\n    if cls is None:\n        return auto(angular=angular)\n    else:\n        return auto(cls)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "do_replace",
        "args": [
          {
            "name": "cls",
            "type": "Type[T]"
          },
          {
            "name": "angular",
            "type": "Optional[bool]"
          }
        ],
        "return_type": "Type[T]",
        "lineno": 42,
        "decorators": [],
        "is_async": false,
        "calls": [
          "repr_str",
          "self.__init__",
          "inspect.signature",
          "auto_repr",
          "arg",
          "auto_rich_repr",
          "unknown.join",
          "signature.parameters.items",
          "append",
          "value",
          "name",
          "ReprError",
          "hasattr",
          "cls",
          "self.__rich_repr__",
          "repr_str.append",
          "len",
          "isinstance",
          "getattr",
          "angular",
          "param.name",
          "tuple",
          "repr",
          "self"
        ],
        "docstring": null,
        "code": "def do_replace(cls: Type[T], angular: Optional[bool] = None) -> Type[T]:\n        def auto_repr(self: T) -> str:\n            \"\"\"Create repr string from __rich_repr__\"\"\"\n            repr_str: List[str] = []\n            append = repr_str.append\n\n            angular: bool = getattr(self.__rich_repr__, \"angular\", False)  # type: ignore[attr-defined]\n            for arg in self.__rich_repr__():  # type: ignore[attr-defined]\n                if isinstance(arg, tuple):\n                    if len(arg) == 1:\n                        append(repr(arg[0]))\n                    else:\n                        key, value, *default = arg\n                        if key is None:\n                            append(repr(value))\n                        else:\n                            if default and default[0] == value:\n                                continue\n                            append(f\"{key}={value!r}\")\n                else:\n                    append(repr(arg))\n            if angular:\n                return f\"<{self.__class__.__name__} {' '.join(repr_str)}>\"\n            else:\n                return f\"{self.__class__.__name__}({', '.join(repr_str)})\"\n\n        def auto_rich_repr(self: Type[T]) -> Result:\n            \"\"\"Auto generate __rich_rep__ from signature of __init__\"\"\"\n            try:\n                signature = inspect.signature(self.__init__)\n                for name, param in signature.parameters.items():\n                    if param.kind == param.POSITIONAL_ONLY:\n                        yield getattr(self, name)\n                    elif param.kind in (\n                        param.POSITIONAL_OR_KEYWORD,\n                        param.KEYWORD_ONLY,\n                    ):\n                        if param.default is param.empty:\n                            yield getattr(self, param.name)\n                        else:\n                            yield param.name, getattr(self, param.name), param.default\n            except Exception as error:\n                raise ReprError(\n                    f\"Failed to auto generate __rich_repr__; {error}\"\n                ) from None\n\n        if not hasattr(cls, \"__rich_repr__\"):\n            auto_rich_repr.__doc__ = \"Build a rich repr\"\n            cls.__rich_repr__ = auto_rich_repr  # type: ignore[attr-defined]\n\n        auto_repr.__doc__ = \"Return repr(self)\"\n        cls.__repr__ = auto_repr  # type: ignore[assignment]\n        if angular is not None:\n            cls.__rich_repr__.angular = angular  # type: ignore[attr-defined]\n        return cls",
        "line_count": 55,
        "needs_llm_summary": true
      },
      {
        "name": "auto_repr",
        "args": [
          {
            "name": "self",
            "type": "T"
          }
        ],
        "return_type": "str",
        "lineno": 43,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "getattr",
          "append",
          "value",
          "arg",
          "repr_str",
          "unknown.join",
          "tuple",
          "self.__rich_repr__",
          "repr_str.append",
          "repr",
          "len"
        ],
        "docstring": "Create repr string from __rich_repr__",
        "code": "def auto_repr(self: T) -> str:\n            \"\"\"Create repr string from __rich_repr__\"\"\"\n            repr_str: List[str] = []\n            append = repr_str.append\n\n            angular: bool = getattr(self.__rich_repr__, \"angular\", False)  # type: ignore[attr-defined]\n            for arg in self.__rich_repr__():  # type: ignore[attr-defined]\n                if isinstance(arg, tuple):\n                    if len(arg) == 1:\n                        append(repr(arg[0]))\n                    else:\n                        key, value, *default = arg\n                        if key is None:\n                            append(repr(value))\n                        else:\n                            if default and default[0] == value:\n                                continue\n                            append(f\"{key}={value!r}\")\n                else:\n                    append(repr(arg))\n            if angular:\n                return f\"<{self.__class__.__name__} {' '.join(repr_str)}>\"\n            else:\n                return f\"{self.__class__.__name__}({', '.join(repr_str)})\"",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "auto_rich_repr",
        "args": [
          {
            "name": "self",
            "type": "Type[T]"
          }
        ],
        "return_type": "Result",
        "lineno": 68,
        "decorators": [],
        "is_async": false,
        "calls": [
          "inspect.signature",
          "getattr",
          "signature.parameters.items",
          "name",
          "ReprError",
          "param.name",
          "self.__init__",
          "self"
        ],
        "docstring": "Auto generate __rich_rep__ from signature of __init__",
        "code": "def auto_rich_repr(self: Type[T]) -> Result:\n            \"\"\"Auto generate __rich_rep__ from signature of __init__\"\"\"\n            try:\n                signature = inspect.signature(self.__init__)\n                for name, param in signature.parameters.items():\n                    if param.kind == param.POSITIONAL_ONLY:\n                        yield getattr(self, name)\n                    elif param.kind in (\n                        param.POSITIONAL_OR_KEYWORD,\n                        param.KEYWORD_ONLY,\n                    ):\n                        if param.default is param.empty:\n                            yield getattr(self, param.name)\n                        else:\n                            yield param.name, getattr(self, param.name), param.default\n            except Exception as error:\n                raise ReprError(\n                    f\"Failed to auto generate __rich_repr__; {error}\"\n                ) from None",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Result",
        "lineno": 127,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_repr__(self) -> Result:\n            yield \"foo\"\n            yield \"bar\", {\"shopping\": [\"eggs\", \"ham\", \"pineapple\"]}\n            yield \"buy\", \"hand sanitizer\"",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ReprError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 23,
        "docstring": "An error occurred when attempting to build a repr."
      },
      {
        "name": "Foo",
        "methods": [
          "__rich_repr__"
        ],
        "base_classes": [],
        "lineno": 126,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "inspect",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "functools",
        "name": "partial",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TypeVar",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "overload",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 133,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "T",
        "assigned_to": "TypeVar",
        "lineno": 16
      },
      {
        "name": "Result",
        "assigned_to": null,
        "lineno": 19
      },
      {
        "name": "RichReprResult",
        "assigned_to": "Result",
        "lineno": 20
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Foo",
      "console.rule",
      "Console"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "Foo",
        "console.rule",
        "foo",
        "Console",
        "Result",
        "TypeVar"
      ],
      "class_instantiations": [
        "TypeVar",
        "Foo",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "functools",
        "typing"
      ],
      "third_party": {
        "other": [
          "inspect",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 150
  },
  "rich/rule.py": {
    "filepath": "../rich/rich/rule.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "title",
            "type": "Union[str, Text]"
          }
        ],
        "return_type": "None",
        "lineno": 23,
        "decorators": [],
        "is_async": false,
        "calls": [
          "end",
          "characters",
          "align",
          "style",
          "ValueError",
          "title",
          "cell_len"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        title: Union[str, Text] = \"\",\n        *,\n        characters: str = \"\u2500\",\n        style: Union[str, Style] = \"rule.line\",\n        end: str = \"\\n\",\n        align: AlignMethod = \"center\",\n    ) -> None:\n        if cell_len(characters) < 1:\n            raise ValueError(\n                \"'characters' argument must have a cell width of at least 1\"\n            )\n        if align not in (\"left\", \"center\", \"right\"):\n            raise ValueError(\n                f'invalid value for align, expected \"left\", \"center\", \"right\" (not {align!r})'\n            )\n        self.title = title\n        self.characters = characters\n        self.style = style\n        self.end = end\n        self.align = align",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 46,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"Rule({self.title!r}, {self.characters!r})\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 49,
        "decorators": [],
        "is_async": false,
        "calls": [
          "characters",
          "self._rule_line",
          "title_text.expand_tabs",
          "right_length",
          "set_cell_size",
          "title_text.plain",
          "self.style",
          "title_text.truncate",
          "rule_text.plain",
          "rule_text.append",
          "truncate_width",
          "left.plain",
          "self.characters.isascii",
          "max",
          "Text",
          "cell_len",
          "console.render_str",
          "options.max_width",
          "self.title",
          "chars_len",
          "width",
          "self.end",
          "title_text.plain.replace",
          "right.truncate",
          "isinstance",
          "left.truncate",
          "title_text"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = options.max_width\n\n        characters = (\n            \"-\"\n            if (options.ascii_only and not self.characters.isascii())\n            else self.characters\n        )\n\n        chars_len = cell_len(characters)\n        if not self.title:\n            yield self._rule_line(chars_len, width)\n            return\n\n        if isinstance(self.title, Text):\n            title_text = self.title\n        else:\n            title_text = console.render_str(self.title, style=\"rule.text\")\n\n        title_text.plain = title_text.plain.replace(\"\\n\", \" \")\n        title_text.expand_tabs()\n\n        required_space = 4 if self.align == \"center\" else 2\n        truncate_width = max(0, width - required_space)\n        if not truncate_width:\n            yield self._rule_line(chars_len, width)\n            return\n\n        rule_text = Text(end=self.end)\n        if self.align == \"center\":\n            title_text.truncate(truncate_width, overflow=\"ellipsis\")\n            side_width = (width - cell_len(title_text.plain)) // 2\n            left = Text(characters * (side_width // chars_len + 1))\n            left.truncate(side_width - 1)\n            right_length = width - cell_len(left.plain) - cell_len(title_text.plain)\n            right = Text(characters * (side_width // chars_len + 1))\n            right.truncate(right_length)\n            rule_text.append(left.plain + \" \", self.style)\n            rule_text.append(title_text)\n            rule_text.append(\" \" + right.plain, self.style)\n        elif self.align == \"left\":\n            title_text.truncate(truncate_width, overflow=\"ellipsis\")\n            rule_text.append(title_text)\n            rule_text.append(\" \")\n            rule_text.append(characters * (width - rule_text.cell_len), self.style)\n        elif self.align == \"right\":\n            title_text.truncate(truncate_width, overflow=\"ellipsis\")\n            rule_text.append(characters * (width - title_text.cell_len - 1), self.style)\n            rule_text.append(\" \")\n            rule_text.append(title_text)\n\n        rule_text.plain = set_cell_size(rule_text.plain, width)\n        yield rule_text",
        "line_count": 55,
        "needs_llm_summary": true
      },
      {
        "name": "_rule_line",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "chars_len",
            "type": "int"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "Text",
        "lineno": 105,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "rule_text.plain",
          "set_cell_size",
          "width",
          "rule_text.truncate",
          "Text"
        ],
        "docstring": null,
        "code": "def _rule_line(self, chars_len: int, width: int) -> Text:\n        rule_text = Text(self.characters * ((width // chars_len) + 1), self.style)\n        rule_text.truncate(width)\n        rule_text.plain = set_cell_size(rule_text.plain, width)\n        return rule_text",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 111,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Measurement"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return Measurement(1, 1)",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Rule",
        "methods": [
          "__init__",
          "__repr__",
          "__rich_console__",
          "_rule_line",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 12,
        "docstring": "A console renderable to draw a horizontal rule (line).\n\nArgs:\n    title (Union[str, Text], optional): Text to render in the rule. Defaults to \"\".\n    characters (str, optional): Character(s) used to draw the line. Defaults to \"\u2500\".\n    style (StyleType, optional): Style of Rule. Defaults to \"rule.line\".\n    end (str, optional): Character at end of Rule. defaults to \"\\\\n\"\n    align (str, optional): How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\"."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "AlignMethod",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "set_cell_size",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 118,
        "type": "import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 120,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "Rule",
      "Console"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "Rule",
        "Console",
        "text"
      ],
      "class_instantiations": [
        "Rule",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "typing"
      ],
      "third_party": {
        "other": [
          "align",
          "cells",
          "console",
          "jupyter",
          "measure",
          "style",
          "text",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 131
  },
  "rich/scope.py": {
    "filepath": "../rich/rich/scope.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "render_scope",
        "args": [
          {
            "name": "scope",
            "type": "Mapping[str, Any]"
          }
        ],
        "return_type": "ConsoleRenderable",
        "lineno": 14,
        "decorators": [],
        "is_async": false,
        "calls": [
          "items_table",
          "highlighter",
          "Table.grid",
          "max_length",
          "scope.items",
          "title",
          "ReprHighlighter",
          "Panel.fit",
          "items_table.add_column",
          "max_string",
          "key.startswith",
          "value",
          "item",
          "key.lower",
          "indent_guides",
          "sort_items",
          "items_table.add_row",
          "Pretty",
          "key_text",
          "Text.assemble",
          "sorted"
        ],
        "docstring": "Render python variables in a given scope.\n\nArgs:\n    scope (Mapping): A mapping containing variable names and values.\n    title (str, optional): Optional title. Defaults to None.\n    sort_keys (bool, optional): Enable sorting of items. Defaults to True.\n    indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n    max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to None.\n    max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n\nReturns:\n    ConsoleRenderable: A renderable object.",
        "code": "def render_scope(\n    scope: \"Mapping[str, Any]\",\n    *,\n    title: Optional[TextType] = None,\n    sort_keys: bool = True,\n    indent_guides: bool = False,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n) -> \"ConsoleRenderable\":\n    \"\"\"Render python variables in a given scope.\n\n    Args:\n        scope (Mapping): A mapping containing variable names and values.\n        title (str, optional): Optional title. Defaults to None.\n        sort_keys (bool, optional): Enable sorting of items. Defaults to True.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n\n    Returns:\n        ConsoleRenderable: A renderable object.\n    \"\"\"\n    highlighter = ReprHighlighter()\n    items_table = Table.grid(padding=(0, 1), expand=False)\n    items_table.add_column(justify=\"right\")\n\n    def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:\n        \"\"\"Sort special variables first, then alphabetically.\"\"\"\n        key, _ = item\n        return (not key.startswith(\"__\"), key.lower())\n\n    items = sorted(scope.items(), key=sort_items) if sort_keys else scope.items()\n    for key, value in items:\n        key_text = Text.assemble(\n            (key, \"scope.key.special\" if key.startswith(\"__\") else \"scope.key\"),\n            (\" =\", \"scope.equals\"),\n        )\n        items_table.add_row(\n            key_text,\n            Pretty(\n                value,\n                highlighter=highlighter,\n                indent_guides=indent_guides,\n                max_length=max_length,\n                max_string=max_string,\n            ),\n        )\n    return Panel.fit(\n        items_table,\n        title=title,\n        border_style=\"scope.border\",\n        padding=(0, 1),\n    )",
        "line_count": 54,
        "needs_llm_summary": true
      },
      {
        "name": "sort_items",
        "args": [
          {
            "name": "item",
            "type": "Tuple[str, Any]"
          }
        ],
        "return_type": "Tuple[bool, str]",
        "lineno": 41,
        "decorators": [],
        "is_async": false,
        "calls": [
          "key.startswith",
          "item",
          "key.lower"
        ],
        "docstring": "Sort special variables first, then alphabetically.",
        "code": "def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:\n        \"\"\"Sort special variables first, then alphabetically.\"\"\"\n        key, _ = item\n        return (not key.startswith(\"__\"), key.lower())",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "test",
        "args": [
          {
            "name": "foo",
            "type": "float"
          },
          {
            "name": "bar",
            "type": "float"
          }
        ],
        "return_type": "None",
        "lineno": 75,
        "decorators": [],
        "is_async": false,
        "calls": [
          "print",
          "locals",
          "render_scope"
        ],
        "docstring": null,
        "code": "def test(foo: float, bar: float) -> None:\n        list_of_things = [1, 2, 3, None, 4, True, False, \"Hello World\"]\n        dict_of_things = {\n            \"version\": \"1.1\",\n            \"method\": \"confirmFruitPurchase\",\n            \"params\": [[\"apple\", \"orange\", \"mangoes\", \"pomelo\"], 1.123],\n            \"id\": \"194521489\",\n        }\n        print(render_scope(locals(), title=\"[i]locals\", sort_keys=False))",
        "line_count": 9,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "collections.abc",
        "name": "Mapping",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "panel",
        "name": "Panel",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleRenderable",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 71,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "print",
      "locals",
      "render_scope",
      "test"
    ],
    "module_level_calls": {
      "function_calls": [
        "print",
        "locals",
        "render_scope",
        "test"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "collections"
      ],
      "third_party": {
        "other": [
          "highlighter",
          "panel",
          "pretty",
          "table",
          "text",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 87
  },
  "rich/screen.py": {
    "filepath": "../rich/rich/screen.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 28,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "Group",
          "application_mode"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        *renderables: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        application_mode: bool = False,\n    ) -> None:\n        from rich.console import Group\n\n        self.renderable = Group(*renderables)\n        self.style = style\n        self.application_mode = application_mode",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 40,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "Segment.line",
          "lines",
          "console.render_lines",
          "style",
          "Segment.set_shape",
          "console.get_style",
          "options.size",
          "loop_last",
          "width",
          "Segment",
          "options.update",
          "height",
          "render_options"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        width, height = options.size\n        style = console.get_style(self.style) if self.style else None\n        render_options = options.update(width=width, height=height)\n        lines = console.render_lines(\n            self.renderable or \"\", render_options, style=style, pad=True\n        )\n        lines = Segment.set_shape(lines, width, height, style=style)\n        new_line = Segment(\"\\n\\r\") if self.application_mode else Segment.line()\n        for last, line in loop_last(lines):\n            yield from line\n            if not last:\n                yield new_line",
        "line_count": 15,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Screen",
        "methods": [
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 18,
        "docstring": "A renderable that fills the terminal screen and crops excess.\n\nArgs:\n    renderable (RenderableType): Child renderable.\n    style (StyleType, optional): Optional background style. Defaults to None."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Group",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Group",
        "alias": null,
        "lineno": 34,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "segment",
          "style",
          "_loop",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 55
  },
  "rich/segment.py": {
    "filepath": "../rich/rich/segment.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "cell_length",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 82,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "text",
          "cell_len",
          "self"
        ],
        "docstring": "The number of terminal cells required to display self.text.\n\nReturns:\n    int: A number of cells.",
        "code": "def cell_length(self) -> int:\n        \"\"\"The number of terminal cells required to display self.text.\n\n        Returns:\n            int: A number of cells.\n        \"\"\"\n        text, _style, control = self\n        return 0 if control else cell_len(text)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Result",
        "lineno": 91,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_repr__(self) -> Result:\n        yield self.text\n        if self.control is None:\n            if self.style is not None:\n                yield self.style\n        else:\n            yield self.style\n            yield self.control",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__bool__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 100,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "self.text"
        ],
        "docstring": "Check if the segment contains text.",
        "code": "def __bool__(self) -> bool:\n        \"\"\"Check if the segment contains text.\"\"\"\n        return bool(self.text)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "is_control",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 105,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Check if the segment contains control codes.",
        "code": "def is_control(self) -> bool:\n        \"\"\"Check if the segment contains control codes.\"\"\"\n        return self.control is not None",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_split_cells",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segment",
            "type": "Segment"
          },
          {
            "name": "cut",
            "type": "int"
          }
        ],
        "return_type": "Tuple[Segment, Segment]",
        "lineno": 111,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "segment",
          "segment.cell_length",
          "len",
          "before",
          "lru_cache",
          "style",
          "cell_size",
          "control",
          "get_character_cell_size",
          "text",
          "Segment",
          "int",
          "_Segment",
          "cell_len"
        ],
        "docstring": "Split a segment in to two at a given cell position.\n\nNote that splitting a double-width character, may result in that character turning\ninto two spaces.\n\nArgs:\n    segment (Segment): A segment to split.\n    cut (int): A cell position to cut on.\n\nReturns:\n    A tuple of two segments.",
        "code": "def _split_cells(cls, segment: \"Segment\", cut: int) -> Tuple[\"Segment\", \"Segment\"]:\n        \"\"\"Split a segment in to two at a given cell position.\n\n        Note that splitting a double-width character, may result in that character turning\n        into two spaces.\n\n        Args:\n            segment (Segment): A segment to split.\n            cut (int): A cell position to cut on.\n\n        Returns:\n            A tuple of two segments.\n        \"\"\"\n        text, style, control = segment\n        _Segment = Segment\n        cell_length = segment.cell_length\n        if cut >= cell_length:\n            return segment, _Segment(\"\", style, control)\n\n        cell_size = get_character_cell_size\n\n        pos = int((cut / cell_length) * len(text))\n\n        while True:\n            before = text[:pos]\n            cell_pos = cell_len(before)\n            out_by = cell_pos - cut\n            if not out_by:\n                return (\n                    _Segment(before, style, control),\n                    _Segment(text[pos:], style, control),\n                )\n            if out_by == -1 and cell_size(text[pos]) == 2:\n                return (\n                    _Segment(text[:pos] + \" \", style, control),\n                    _Segment(\" \" + text[pos + 1 :], style, control),\n                )\n            if out_by == +1 and cell_size(text[pos - 1]) == 2:\n                return (\n                    _Segment(text[: pos - 1] + \" \", style, control),\n                    _Segment(\" \" + text[pos:], style, control),\n                )\n            if cell_pos < cut:\n                pos += 1\n            else:\n                pos -= 1",
        "line_count": 46,
        "needs_llm_summary": true
      },
      {
        "name": "split_cells",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "cut",
            "type": "int"
          }
        ],
        "return_type": "Tuple[Segment, Segment]",
        "lineno": 158,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "self._split_cells",
          "cut",
          "_is_single_cell_widths",
          "text",
          "control",
          "Segment",
          "len",
          "self"
        ],
        "docstring": "Split segment in to two segments at the specified column.\n\nIf the cut point falls in the middle of a 2-cell wide character then it is replaced\nby two spaces, to preserve the display width of the parent segment.\n\nArgs:\n    cut (int): Offset within the segment to cut.\n\nReturns:\n    Tuple[Segment, Segment]: Two segments.",
        "code": "def split_cells(self, cut: int) -> Tuple[\"Segment\", \"Segment\"]:\n        \"\"\"Split segment in to two segments at the specified column.\n\n        If the cut point falls in the middle of a 2-cell wide character then it is replaced\n        by two spaces, to preserve the display width of the parent segment.\n\n        Args:\n            cut (int): Offset within the segment to cut.\n\n        Returns:\n            Tuple[Segment, Segment]: Two segments.\n        \"\"\"\n        text, style, control = self\n        assert cut >= 0\n\n        if _is_single_cell_widths(text):\n            # Fast path with all 1 cell characters\n            if cut >= len(text):\n                return self, Segment(\"\", style, control)\n            return (\n                Segment(text[:cut], style, control),\n                Segment(text[cut:], style, control),\n            )\n\n        return self._split_cells(self, cut)",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "line",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Segment",
        "lineno": 185,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cls"
        ],
        "docstring": "Make a new line segment.",
        "code": "def line(cls) -> \"Segment\":\n        \"\"\"Make a new line segment.\"\"\"\n        return cls(\"\\n\")",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "apply_style",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          },
          {
            "name": "style",
            "type": "Optional[Style]"
          },
          {
            "name": "post_style",
            "type": "Optional[Style]"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 190,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "_style",
          "apply",
          "segments",
          "text",
          "control",
          "cls",
          "style.__add__"
        ],
        "docstring": "Apply style(s) to an iterable of segments.\n\nReturns an iterable of segments where the style is replaced by ``style + segment.style + post_style``.\n\nArgs:\n    segments (Iterable[Segment]): Segments to process.\n    style (Style, optional): Base style. Defaults to None.\n    post_style (Style, optional): Style to apply on top of segment style. Defaults to None.\n\nReturns:\n    Iterable[Segments]: A new iterable of segments (possibly the same iterable).",
        "code": "def apply_style(\n        cls,\n        segments: Iterable[\"Segment\"],\n        style: Optional[Style] = None,\n        post_style: Optional[Style] = None,\n    ) -> Iterable[\"Segment\"]:\n        \"\"\"Apply style(s) to an iterable of segments.\n\n        Returns an iterable of segments where the style is replaced by ``style + segment.style + post_style``.\n\n        Args:\n            segments (Iterable[Segment]): Segments to process.\n            style (Style, optional): Base style. Defaults to None.\n            post_style (Style, optional): Style to apply on top of segment style. Defaults to None.\n\n        Returns:\n            Iterable[Segments]: A new iterable of segments (possibly the same iterable).\n        \"\"\"\n        result_segments = segments\n        if style:\n            apply = style.__add__\n            result_segments = (\n                cls(text, None if control else apply(_style), control)\n                for text, _style, control in result_segments\n            )\n        if post_style:\n            result_segments = (\n                cls(\n                    text,\n                    (\n                        None\n                        if control\n                        else (_style + post_style if _style else post_style)\n                    ),\n                    control,\n                )\n                for text, _style, control in result_segments\n            )\n        return result_segments",
        "line_count": 39,
        "needs_llm_summary": true
      },
      {
        "name": "filter_control",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          },
          {
            "name": "is_control",
            "type": "bool"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 231,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "segments",
          "attrgetter",
          "filter",
          "filterfalse"
        ],
        "docstring": "Filter segments by ``is_control`` attribute.\n\nArgs:\n    segments (Iterable[Segment]): An iterable of Segment instances.\n    is_control (bool, optional): is_control flag to match in search.\n\nReturns:\n    Iterable[Segment]: And iterable of Segment instances.",
        "code": "def filter_control(\n        cls, segments: Iterable[\"Segment\"], is_control: bool = False\n    ) -> Iterable[\"Segment\"]:\n        \"\"\"Filter segments by ``is_control`` attribute.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of Segment instances.\n            is_control (bool, optional): is_control flag to match in search.\n\n        Returns:\n            Iterable[Segment]: And iterable of Segment instances.\n\n        \"\"\"\n        if is_control:\n            return filter(attrgetter(\"control\"), segments)\n        else:\n            return filterfalse(attrgetter(\"control\"), segments)",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "split_lines",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          }
        ],
        "return_type": "Iterable[List[Segment]]",
        "lineno": 250,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "segment",
          "append",
          "_text",
          "style",
          "text.partition",
          "line.append",
          "cls"
        ],
        "docstring": "Split a sequence of segments in to a list of lines.\n\nArgs:\n    segments (Iterable[Segment]): Segments potentially containing line feeds.\n\nYields:\n    Iterable[List[Segment]]: Iterable of segment lists, one per line.",
        "code": "def split_lines(cls, segments: Iterable[\"Segment\"]) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Split a sequence of segments in to a list of lines.\n\n        Args:\n            segments (Iterable[Segment]): Segments potentially containing line feeds.\n\n        Yields:\n            Iterable[List[Segment]]: Iterable of segment lists, one per line.\n        \"\"\"\n        line: List[Segment] = []\n        append = line.append\n\n        for segment in segments:\n            if \"\\n\" in segment.text and not segment.control:\n                text, style, _ = segment\n                while text:\n                    _text, new_line, text = text.partition(\"\\n\")\n                    if _text:\n                        append(cls(_text, style))\n                    if new_line:\n                        yield line\n                        line = []\n                        append = line.append\n            else:\n                append(segment)\n        if line:\n            yield line",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "split_and_crop_lines",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          },
          {
            "name": "length",
            "type": "int"
          },
          {
            "name": "style",
            "type": "Optional[Style]"
          },
          {
            "name": "pad",
            "type": "bool"
          },
          {
            "name": "include_new_lines",
            "type": "bool"
          }
        ],
        "return_type": "Iterable[List[Segment]]",
        "lineno": 279,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "segment",
          "append",
          "adjust_line_length",
          "_text",
          "line",
          "style",
          "text.partition",
          "line.clear",
          "new_line_segment",
          "line.append",
          "cls.adjust_line_length",
          "segment_style",
          "length",
          "cls",
          "pad",
          "cropped_line.append"
        ],
        "docstring": "Split segments in to lines, and crop lines greater than a given length.\n\nArgs:\n    segments (Iterable[Segment]): An iterable of segments, probably\n        generated from console.render.\n    length (int): Desired line length.\n    style (Style, optional): Style to use for any padding.\n    pad (bool): Enable padding of lines that are less than `length`.\n\nReturns:\n    Iterable[List[Segment]]: An iterable of lines of segments.",
        "code": "def split_and_crop_lines(\n        cls,\n        segments: Iterable[\"Segment\"],\n        length: int,\n        style: Optional[Style] = None,\n        pad: bool = True,\n        include_new_lines: bool = True,\n    ) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Split segments in to lines, and crop lines greater than a given length.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of segments, probably\n                generated from console.render.\n            length (int): Desired line length.\n            style (Style, optional): Style to use for any padding.\n            pad (bool): Enable padding of lines that are less than `length`.\n\n        Returns:\n            Iterable[List[Segment]]: An iterable of lines of segments.\n        \"\"\"\n        line: List[Segment] = []\n        append = line.append\n\n        adjust_line_length = cls.adjust_line_length\n        new_line_segment = cls(\"\\n\")\n\n        for segment in segments:\n            if \"\\n\" in segment.text and not segment.control:\n                text, segment_style, _ = segment\n                while text:\n                    _text, new_line, text = text.partition(\"\\n\")\n                    if _text:\n                        append(cls(_text, segment_style))\n                    if new_line:\n                        cropped_line = adjust_line_length(\n                            line, length, style=style, pad=pad\n                        )\n                        if include_new_lines:\n                            cropped_line.append(new_line_segment)\n                        yield cropped_line\n                        line.clear()\n            else:\n                append(segment)\n        if line:\n            yield adjust_line_length(line, length, style=style, pad=pad)",
        "line_count": 45,
        "needs_llm_summary": true
      },
      {
        "name": "adjust_line_length",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "line",
            "type": "List[Segment]"
          },
          {
            "name": "length",
            "type": "int"
          },
          {
            "name": "style",
            "type": "Optional[Style]"
          },
          {
            "name": "pad",
            "type": "bool"
          }
        ],
        "return_type": "List[Segment]",
        "lineno": 326,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "segment.cell_length",
          "segment",
          "sum",
          "append",
          "new_line.append",
          "style",
          "segment_style",
          "set_cell_size",
          "cls",
          "text"
        ],
        "docstring": "Adjust a line to a given width (cropping or padding as required).\n\nArgs:\n    segments (Iterable[Segment]): A list of segments in a single line.\n    length (int): The desired width of the line.\n    style (Style, optional): The style of padding if used (space on the end). Defaults to None.\n    pad (bool, optional): Pad lines with spaces if they are shorter than `length`. Defaults to True.\n\nReturns:\n    List[Segment]: A line of segments with the desired length.",
        "code": "def adjust_line_length(\n        cls,\n        line: List[\"Segment\"],\n        length: int,\n        style: Optional[Style] = None,\n        pad: bool = True,\n    ) -> List[\"Segment\"]:\n        \"\"\"Adjust a line to a given width (cropping or padding as required).\n\n        Args:\n            segments (Iterable[Segment]): A list of segments in a single line.\n            length (int): The desired width of the line.\n            style (Style, optional): The style of padding if used (space on the end). Defaults to None.\n            pad (bool, optional): Pad lines with spaces if they are shorter than `length`. Defaults to True.\n\n        Returns:\n            List[Segment]: A line of segments with the desired length.\n        \"\"\"\n        line_length = sum(segment.cell_length for segment in line)\n        new_line: List[Segment]\n\n        if line_length < length:\n            if pad:\n                new_line = line + [cls(\" \" * (length - line_length), style)]\n            else:\n                new_line = line[:]\n        elif line_length > length:\n            new_line = []\n            append = new_line.append\n            line_length = 0\n            for segment in line:\n                segment_length = segment.cell_length\n                if line_length + segment_length < length or segment.control:\n                    append(segment)\n                    line_length += segment_length\n                else:\n                    text, segment_style, _ = segment\n                    text = set_cell_size(text, length - line_length)\n                    append(cls(text, segment_style))\n                    break\n        else:\n            new_line = line[:]\n        return new_line",
        "line_count": 43,
        "needs_llm_summary": true
      },
      {
        "name": "get_line_length",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "line",
            "type": "List[Segment]"
          }
        ],
        "return_type": "int",
        "lineno": 371,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "sum",
          "text",
          "cell_len",
          "_cell_len"
        ],
        "docstring": "Get the length of list of segments.\n\nArgs:\n    line (List[Segment]): A line encoded as a list of Segments (assumes no '\\\\n' characters),\n\nReturns:\n    int: The length of the line.",
        "code": "def get_line_length(cls, line: List[\"Segment\"]) -> int:\n        \"\"\"Get the length of list of segments.\n\n        Args:\n            line (List[Segment]): A line encoded as a list of Segments (assumes no '\\\\\\\\n' characters),\n\n        Returns:\n            int: The length of the line.\n        \"\"\"\n        _cell_len = cell_len\n        return sum(_cell_len(text) for text, style, control in line if not control)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "get_shape",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "lines",
            "type": "List[List[Segment]]"
          }
        ],
        "return_type": "Tuple[int, int]",
        "lineno": 384,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "lines",
          "line",
          "cls.get_line_length",
          "max",
          "get_line_length",
          "len"
        ],
        "docstring": "Get the shape (enclosing rectangle) of a list of lines.\n\nArgs:\n    lines (List[List[Segment]]): A list of lines (no '\\\\n' characters).\n\nReturns:\n    Tuple[int, int]: Width and height in characters.",
        "code": "def get_shape(cls, lines: List[List[\"Segment\"]]) -> Tuple[int, int]:\n        \"\"\"Get the shape (enclosing rectangle) of a list of lines.\n\n        Args:\n            lines (List[List[Segment]]): A list of lines (no '\\\\\\\\n' characters).\n\n        Returns:\n            Tuple[int, int]: Width and height in characters.\n        \"\"\"\n        get_line_length = cls.get_line_length\n        max_width = max(get_line_length(line) for line in lines) if lines else 0\n        return (max_width, len(lines))",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "set_shape",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "lines",
            "type": "List[List[Segment]]"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "height",
            "type": "Optional[int]"
          },
          {
            "name": "style",
            "type": "Optional[Style]"
          },
          {
            "name": "new_lines",
            "type": "bool"
          }
        ],
        "return_type": "List[List[Segment]]",
        "lineno": 398,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "lines",
          "adjust_line_length",
          "line",
          "style",
          "shaped_lines.extend",
          "cls.adjust_line_length",
          "width",
          "cls",
          "shaped_lines",
          "len"
        ],
        "docstring": "Set the shape of a list of lines (enclosing rectangle).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style, optional): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        ",
        "code": "def set_shape(\n        cls,\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: Optional[int] = None,\n        style: Optional[Style] = None,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Set the shape of a list of lines (enclosing rectangle).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style, optional): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        _height = height or len(lines)\n\n        blank = (\n            [cls(\" \" * width + \"\\n\", style)] if new_lines else [cls(\" \" * width, style)]\n        )\n\n        adjust_line_length = cls.adjust_line_length\n        shaped_lines = lines[:_height]\n        shaped_lines[:] = [\n            adjust_line_length(line, width, style=style) for line in lines\n        ]\n        if len(shaped_lines) < _height:\n            shaped_lines.extend([blank] * (_height - len(shaped_lines)))\n        return shaped_lines",
        "line_count": 34,
        "needs_llm_summary": true
      },
      {
        "name": "align_top",
        "args": [
          {
            "name": "cls",
            "type": "Type[Segment]"
          },
          {
            "name": "lines",
            "type": "List[List[Segment]]"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "height",
            "type": "int"
          },
          {
            "name": "style",
            "type": "Style"
          },
          {
            "name": "new_lines",
            "type": "bool"
          }
        ],
        "return_type": "List[List[Segment]]",
        "lineno": 434,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "style",
          "lines",
          "cls",
          "len"
        ],
        "docstring": "Aligns lines to top (adds extra lines to bottom as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        ",
        "code": "def align_top(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns lines to top (adds extra lines to bottom as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        lines = lines + [[blank]] * extra_lines\n        return lines",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "align_bottom",
        "args": [
          {
            "name": "cls",
            "type": "Type[Segment]"
          },
          {
            "name": "lines",
            "type": "List[List[Segment]]"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "height",
            "type": "int"
          },
          {
            "name": "style",
            "type": "Style"
          },
          {
            "name": "new_lines",
            "type": "bool"
          }
        ],
        "return_type": "List[List[Segment]]",
        "lineno": 463,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "style",
          "lines",
          "cls",
          "len"
        ],
        "docstring": "Aligns render to bottom (adds extra lines above as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added. Defaults to None.\n            new_lines (bool, optional): Padded lines should include \"\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        ",
        "code": "def align_bottom(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns render to bottom (adds extra lines above as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added. Defaults to None.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        lines = [[blank]] * extra_lines + lines\n        return lines",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "align_middle",
        "args": [
          {
            "name": "cls",
            "type": "Type[Segment]"
          },
          {
            "name": "lines",
            "type": "List[List[Segment]]"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "height",
            "type": "int"
          },
          {
            "name": "style",
            "type": "Style"
          },
          {
            "name": "new_lines",
            "type": "bool"
          }
        ],
        "return_type": "List[List[Segment]]",
        "lineno": 492,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "style",
          "lines",
          "cls",
          "len"
        ],
        "docstring": "Aligns lines to middle (adds extra lines to above and below as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        ",
        "code": "def align_middle(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns lines to middle (adds extra lines to above and below as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        top_lines = extra_lines // 2\n        bottom_lines = extra_lines - top_lines\n        lines = [[blank]] * top_lines + lines + [[blank]] * bottom_lines\n        return lines",
        "line_count": 29,
        "needs_llm_summary": true
      },
      {
        "name": "simplify",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 523,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "segment",
          "iter_segments",
          "next",
          "last_segment.style",
          "iter",
          "segments",
          "Segment",
          "_Segment"
        ],
        "docstring": "Simplify an iterable of segments by combining contiguous segments with the same style.\n\nArgs:\n    segments (Iterable[Segment]): An iterable of segments.\n\nReturns:\n    Iterable[Segment]: A possibly smaller iterable of segments that will render the same way.",
        "code": "def simplify(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Simplify an iterable of segments by combining contiguous segments with the same style.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of segments.\n\n        Returns:\n            Iterable[Segment]: A possibly smaller iterable of segments that will render the same way.\n        \"\"\"\n        iter_segments = iter(segments)\n        try:\n            last_segment = next(iter_segments)\n        except StopIteration:\n            return\n\n        _Segment = Segment\n        for segment in iter_segments:\n            if last_segment.style == segment.style and not segment.control:\n                last_segment = _Segment(\n                    last_segment.text + segment.text, last_segment.style\n                )\n            else:\n                yield last_segment\n                last_segment = segment\n        yield last_segment",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "strip_links",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 550,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "segment",
          "style.update_link",
          "text",
          "cls"
        ],
        "docstring": "Remove all links from an iterable of styles.\n\nArgs:\n    segments (Iterable[Segment]): An iterable segments.\n\nYields:\n    Segment: Segments with link removed.",
        "code": "def strip_links(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all links from an iterable of styles.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with link removed.\n        \"\"\"\n        for segment in segments:\n            if segment.control or segment.style is None:\n                yield segment\n            else:\n                text, style, _control = segment\n                yield cls(text, style.update_link(None) if style else None)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "strip_styles",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 567,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "text",
          "cls",
          "control"
        ],
        "docstring": "Remove all styles from an iterable of segments.\n\nArgs:\n    segments (Iterable[Segment]): An iterable segments.\n\nYields:\n    Segment: Segments with styles replace with None",
        "code": "def strip_styles(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all styles from an iterable of segments.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with styles replace with None\n        \"\"\"\n        for text, _style, control in segments:\n            yield cls(text, None, control)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "remove_color",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 580,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "style",
          "cache.get",
          "cls",
          "text",
          "control",
          "colorless_style",
          "style.without_color"
        ],
        "docstring": "Remove all color from an iterable of segments.\n\nArgs:\n    segments (Iterable[Segment]): An iterable segments.\n\nYields:\n    Segment: Segments with colorless style.",
        "code": "def remove_color(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all color from an iterable of segments.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with colorless style.\n        \"\"\"\n\n        cache: Dict[Style, Style] = {}\n        for text, style, control in segments:\n            if style:\n                colorless_style = cache.get(style)\n                if colorless_style is None:\n                    colorless_style = style.without_color\n                    cache[style] = colorless_style\n                yield cls(text, colorless_style, control)\n            else:\n                yield cls(text, None, control)",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "divide",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          },
          {
            "name": "cuts",
            "type": "Iterable[int]"
          }
        ],
        "return_type": "Iterable[List[Segment]]",
        "lineno": 602,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "segment",
          "add_segment",
          "_cell_len",
          "split_segments.copy",
          "segment.split_cells",
          "split_segments.clear",
          "cuts",
          "next",
          "end_pos",
          "iter",
          "cut",
          "cached_cell_len",
          "iter_cuts",
          "text",
          "segments_copy",
          "split_segments.append",
          "segments_clear",
          "before"
        ],
        "docstring": "Divides an iterable of segments in to portions.\n\nArgs:\n    cuts (Iterable[int]): Cell positions where to divide.\n\nYields:\n    [Iterable[List[Segment]]]: An iterable of Segments in List.",
        "code": "def divide(\n        cls, segments: Iterable[\"Segment\"], cuts: Iterable[int]\n    ) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Divides an iterable of segments in to portions.\n\n        Args:\n            cuts (Iterable[int]): Cell positions where to divide.\n\n        Yields:\n            [Iterable[List[Segment]]]: An iterable of Segments in List.\n        \"\"\"\n        split_segments: List[\"Segment\"] = []\n        add_segment = split_segments.append\n\n        iter_cuts = iter(cuts)\n\n        while True:\n            cut = next(iter_cuts, -1)\n            if cut == -1:\n                return\n            if cut != 0:\n                break\n            yield []\n        pos = 0\n\n        segments_clear = split_segments.clear\n        segments_copy = split_segments.copy\n\n        _cell_len = cached_cell_len\n        for segment in segments:\n            text, _style, control = segment\n            while text:\n                end_pos = pos if control else pos + _cell_len(text)\n                if end_pos < cut:\n                    add_segment(segment)\n                    pos = end_pos\n                    break\n\n                if end_pos == cut:\n                    add_segment(segment)\n                    yield segments_copy()\n                    segments_clear()\n                    pos = end_pos\n\n                    cut = next(iter_cuts, -1)\n                    if cut == -1:\n                        if split_segments:\n                            yield segments_copy()\n                        return\n\n                    break\n\n                else:\n                    before, segment = segment.split_cells(cut - pos)\n                    text, _style, control = segment\n                    add_segment(before)\n                    yield segments_copy()\n                    segments_clear()\n                    pos = cut\n\n                cut = next(iter_cuts, -1)\n                if cut == -1:\n                    if split_segments:\n                        yield segments_copy()\n                    return\n\n        yield segments_copy()",
        "line_count": 67,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "segments",
            "type": "Iterable[Segment]"
          },
          {
            "name": "new_lines",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 680,
        "decorators": [],
        "is_async": false,
        "calls": [
          "list",
          "segments",
          "new_lines"
        ],
        "docstring": null,
        "code": "def __init__(self, segments: Iterable[Segment], new_lines: bool = False) -> None:\n        self.segments = list(segments)\n        self.new_lines = new_lines",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 684,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.new_lines:\n            line = Segment.line()\n            for segment in self.segments:\n                yield segment\n                yield line\n        else:\n            yield from self.segments",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lines",
            "type": "Iterable[List[Segment]]"
          },
          {
            "name": "new_lines",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 697,
        "decorators": [],
        "is_async": false,
        "calls": [
          "list",
          "lines",
          "new_lines"
        ],
        "docstring": "A simple renderable containing a number of lines of segments. May be used as an intermediate\nin rendering process.\n\nArgs:\n    lines (Iterable[List[Segment]]): Lists of segments forming lines.\n    new_lines (bool, optional): Insert new lines after each line. Defaults to False.",
        "code": "def __init__(self, lines: Iterable[List[Segment]], new_lines: bool = False) -> None:\n        \"\"\"A simple renderable containing a number of lines of segments. May be used as an intermediate\n        in rendering process.\n\n        Args:\n            lines (Iterable[List[Segment]]): Lists of segments forming lines.\n            new_lines (bool, optional): Insert new lines after each line. Defaults to False.\n        \"\"\"\n        self.lines = list(lines)\n        self.new_lines = new_lines",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 708,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.new_lines:\n            new_line = Segment.line()\n            for line in self.lines:\n                yield from line\n                yield new_line\n        else:\n            for line in self.lines:\n                yield from line",
        "line_count": 11,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "ControlType",
        "methods": [],
        "base_classes": [
          "IntEnum"
        ],
        "lineno": 35,
        "docstring": "Non-printable control codes which typically translate to ANSI codes."
      },
      {
        "name": "Segment",
        "methods": [
          "cell_length",
          "__rich_repr__",
          "__bool__",
          "is_control",
          "_split_cells",
          "split_cells",
          "line",
          "apply_style",
          "filter_control",
          "split_lines",
          "split_and_crop_lines",
          "adjust_line_length",
          "get_line_length",
          "get_shape",
          "set_shape",
          "align_top",
          "align_bottom",
          "align_middle",
          "simplify",
          "strip_links",
          "strip_styles",
          "remove_color",
          "divide"
        ],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 64,
        "docstring": "A piece of text with associated style. Segments are produced by the Console render process and\nare ultimately converted in to strings to be written to the terminal.\n\nArgs:\n    text (str): A piece of text.\n    style (:class:`~rich.style.Style`, optional): An optional style to apply to the text.\n    control (Tuple[ControlCode], optional): Optional sequence of control codes.\n\nAttributes:\n    cell_length (int): The cell length of this Segment."
      },
      {
        "name": "Segments",
        "methods": [
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 671,
        "docstring": "A simple renderable to render an iterable of segments. This class may be useful if\nyou want to print segments outside of a __rich_console__ method.\n\nArgs:\n    segments (Iterable[Segment]): An iterable of segments.\n    new_lines (bool, optional): Add new lines between segments. Defaults to False."
      },
      {
        "name": "SegmentLines",
        "methods": [
          "__init__",
          "__rich_console__"
        ],
        "base_classes": [],
        "lineno": 696,
        "docstring": null
      }
    ],
    "imports": [
      {
        "module": "enum",
        "name": "IntEnum",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "functools",
        "name": "lru_cache",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "itertools",
        "name": "filterfalse",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "logging",
        "name": "getLogger",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "operator",
        "name": "attrgetter",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "_is_single_cell_widths",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cached_cell_len",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "get_character_cell_size",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "set_cell_size",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "repr",
        "name": "Result",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "repr",
        "name": "rich_repr",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 722,
        "type": "from_import"
      },
      {
        "module": "rich.syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 723,
        "type": "from_import"
      },
      {
        "module": "rich.text",
        "name": "Text",
        "alias": null,
        "lineno": 724,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "log",
        "assigned_to": "getLogger",
        "lineno": 32
      },
      {
        "name": "ControlCode",
        "assigned_to": null,
        "lineno": 56
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "console.rule",
      "Console",
      "Text.from_markup",
      "console.render",
      "list",
      "Syntax"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.rule",
        "getLogger",
        "Console",
        "Text.from_markup",
        "fragments",
        "console.render",
        "list",
        "text",
        "code",
        "Syntax"
      ],
      "class_instantiations": [
        "Console",
        "Text",
        "Syntax"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "functools",
        "logging",
        "enum",
        "itertools"
      ],
      "third_party": {
        "other": [
          "operator",
          "cells",
          "repr",
          "style",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 753
  },
  "rich/spinner.py": {
    "filepath": "../rich/rich/spinner.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "name",
            "type": "str"
          },
          {
            "name": "text",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 26,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "KeyError",
          "str",
          "name",
          "style",
          "speed",
          "Text.from_markup",
          "cast",
          "text",
          "float"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        name: str,\n        text: \"RenderableType\" = \"\",\n        *,\n        style: Optional[\"StyleType\"] = None,\n        speed: float = 1.0,\n    ) -> None:\n        try:\n            spinner = SPINNERS[name]\n        except KeyError:\n            raise KeyError(f\"no spinner called {name!r}\")\n        self.text: \"Union[RenderableType, Text]\" = (\n            Text.from_markup(text) if isinstance(text, str) else text\n        )\n        self.name = name\n        self.frames = cast(List[str], spinner[\"frames\"])[:]\n        self.interval = cast(float, spinner[\"interval\"])\n        self.start_time: Optional[float] = None\n        self.style = style\n        self.speed = speed\n        self.frame_no_offset: float = 0.0\n        self._update_speed = 0.0",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 50,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.render",
          "console.get_time"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        yield self.render(console.get_time())",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 55,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.render",
          "options",
          "Measurement.get",
          "text",
          "console"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        text = self.render(0)\n        return Measurement.get(console, options, text)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "time",
            "type": "float"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 61,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "self.text",
          "len",
          "self.frames",
          "Table.grid",
          "frame_no",
          "frame",
          "int",
          "Text.assemble",
          "Text",
          "table.add_row",
          "time",
          "self._update_speed"
        ],
        "docstring": "Render the spinner for a given time.\n\nArgs:\n    time (float): Time in seconds.\n\nReturns:\n    RenderableType: A renderable containing animation frame.",
        "code": "def render(self, time: float) -> \"RenderableType\":\n        \"\"\"Render the spinner for a given time.\n\n        Args:\n            time (float): Time in seconds.\n\n        Returns:\n            RenderableType: A renderable containing animation frame.\n        \"\"\"\n        if self.start_time is None:\n            self.start_time = time\n\n        frame_no = ((time - self.start_time) * self.speed) / (\n            self.interval / 1000.0\n        ) + self.frame_no_offset\n        frame = Text(\n            self.frames[int(frame_no) % len(self.frames)], style=self.style or \"\"\n        )\n\n        if self._update_speed:\n            self.frame_no_offset = frame_no\n            self.start_time = time\n            self.speed = self._update_speed\n            self._update_speed = 0.0\n\n        if not self.text:\n            return frame\n        elif isinstance(self.text, (str, Text)):\n            return Text.assemble(frame, \" \", self.text)\n        else:\n            table = Table.grid(padding=1)\n            table.add_row(frame, self.text)\n            return table",
        "line_count": 33,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 95,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "str",
          "style",
          "speed",
          "Text.from_markup",
          "text"
        ],
        "docstring": "Updates attributes of a spinner after it has been started.\n\nArgs:\n    text (RenderableType, optional): A renderable to display at the right of the spinner (str or Text typically). Defaults to \"\".\n    style (StyleType, optional): Style for spinner animation. Defaults to None.\n    speed (float, optional): Speed factor for animation. Defaults to None.",
        "code": "def update(\n        self,\n        *,\n        text: \"RenderableType\" = \"\",\n        style: Optional[\"StyleType\"] = None,\n        speed: Optional[float] = None,\n    ) -> None:\n        \"\"\"Updates attributes of a spinner after it has been started.\n\n        Args:\n            text (RenderableType, optional): A renderable to display at the right of the spinner (str or Text typically). Defaults to \"\".\n            style (StyleType, optional): Style for spinner animation. Defaults to None.\n            speed (float, optional): Speed factor for animation. Defaults to None.\n        \"\"\"\n        if text:\n            self.text = Text.from_markup(text) if isinstance(text, str) else text\n        if style:\n            self.style = style\n        if speed:\n            self._update_speed = speed",
        "line_count": 20,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Spinner",
        "methods": [
          "__init__",
          "__rich_console__",
          "__rich_measure__",
          "render",
          "update"
        ],
        "base_classes": [],
        "lineno": 13,
        "docstring": "A spinner animation.\n\nArgs:\n    name (str): Name of spinner (run python -m rich.spinner).\n    text (RenderableType, optional): A renderable to display at the right of the spinner (str or Text typically). Defaults to \"\".\n    style (StyleType, optional): Style for spinner animation. Defaults to None.\n    speed (float, optional): Speed factor for animation. Defaults to 1.0.\n\nRaises:\n    KeyError: If name isn't one of the supported spinner animations."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "cast",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "_spinners",
        "name": "SPINNERS",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "table",
        "name": "Table",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 118,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Group",
        "alias": null,
        "lineno": 120,
        "type": "from_import"
      },
      {
        "module": "live",
        "name": "Live",
        "alias": null,
        "lineno": 121,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "Spinner",
      "Live",
      "Group",
      "SPINNERS.keys",
      "sorted",
      "sleep",
      "repr",
      "Text"
    ],
    "module_level_calls": {
      "function_calls": [
        "Spinner",
        "Live",
        "Group",
        "SPINNERS.keys",
        "spinner_name",
        "all_spinners",
        "sorted",
        "sleep",
        "repr",
        "Text"
      ],
      "class_instantiations": [
        "Spinner",
        "Live",
        "Group",
        "SPINNERS",
        "Text"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time",
        "typing"
      ],
      "third_party": {
        "other": [
          "_spinners",
          "measure",
          "table",
          "text",
          "console",
          "style",
          "live"
        ]
      },
      "tech_stack": []
    },
    "line_count": 133
  },
  "rich/status.py": {
    "filepath": "../rich/rich/status.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "status",
            "type": "RenderableType"
          }
        ],
        "return_type": null,
        "lineno": 23,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Spinner",
          "Live",
          "spinner",
          "speed",
          "self.renderable",
          "refresh_per_second",
          "status",
          "console",
          "spinner_style"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        status: RenderableType,\n        *,\n        console: Optional[Console] = None,\n        spinner: str = \"dots\",\n        spinner_style: StyleType = \"status.spinner\",\n        speed: float = 1.0,\n        refresh_per_second: float = 12.5,\n    ):\n        self.status = status\n        self.spinner_style = spinner_style\n        self.speed = speed\n        self._spinner = Spinner(spinner, text=status, style=spinner_style, speed=speed)\n        self._live = Live(\n            self.renderable,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "renderable",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Spinner",
        "lineno": 45,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def renderable(self) -> Spinner:\n        return self._spinner",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "console",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Console",
        "lineno": 49,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get the Console used by the Status objects.",
        "code": "def console(self) -> \"Console\":\n        \"\"\"Get the Console used by the Status objects.\"\"\"\n        return self._live.console",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "update",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "status",
            "type": "Optional[RenderableType]"
          }
        ],
        "return_type": "None",
        "lineno": 53,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.status",
          "self.speed",
          "Spinner",
          "self.spinner_style",
          "spinner",
          "speed",
          "self.renderable",
          "self._spinner.update",
          "self._live.update",
          "status",
          "spinner_style"
        ],
        "docstring": "Update status.\n\nArgs:\n    status (Optional[RenderableType], optional): New status renderable or None for no change. Defaults to None.\n    spinner (Optional[str], optional): New spinner or None for no change. Defaults to None.\n    spinner_style (Optional[StyleType], optional): New spinner style or None for no change. Defaults to None.\n    speed (Optional[float], optional): Speed factor for spinner animation or None for no change. Defaults to None.",
        "code": "def update(\n        self,\n        status: Optional[RenderableType] = None,\n        *,\n        spinner: Optional[str] = None,\n        spinner_style: Optional[StyleType] = None,\n        speed: Optional[float] = None,\n    ) -> None:\n        \"\"\"Update status.\n\n        Args:\n            status (Optional[RenderableType], optional): New status renderable or None for no change. Defaults to None.\n            spinner (Optional[str], optional): New spinner or None for no change. Defaults to None.\n            spinner_style (Optional[StyleType], optional): New spinner style or None for no change. Defaults to None.\n            speed (Optional[float], optional): Speed factor for spinner animation or None for no change. Defaults to None.\n        \"\"\"\n        if status is not None:\n            self.status = status\n        if spinner_style is not None:\n            self.spinner_style = spinner_style\n        if speed is not None:\n            self.speed = speed\n        if spinner is not None:\n            self._spinner = Spinner(\n                spinner, text=self.status, style=self.spinner_style, speed=self.speed\n            )\n            self._live.update(self.renderable, refresh=True)\n        else:\n            self._spinner.update(\n                text=self.status, style=self.spinner_style, speed=self.speed\n            )",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "start",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 85,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._live.start"
        ],
        "docstring": "Start the status animation.",
        "code": "def start(self) -> None:\n        \"\"\"Start the status animation.\"\"\"\n        self._live.start()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "stop",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 89,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._live.stop"
        ],
        "docstring": "Stop the spinner animation.",
        "code": "def stop(self) -> None:\n        \"\"\"Stop the spinner animation.\"\"\"\n        self._live.stop()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__rich__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "RenderableType",
        "lineno": 93,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich__(self) -> RenderableType:\n        return self.renderable",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__enter__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Status",
        "lineno": 96,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.start"
        ],
        "docstring": null,
        "code": "def __enter__(self) -> \"Status\":\n        self.start()\n        return self",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__exit__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "exc_type",
            "type": "Optional[Type[BaseException]]"
          },
          {
            "name": "exc_val",
            "type": "Optional[BaseException]"
          },
          {
            "name": "exc_tb",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 100,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.stop"
        ],
        "docstring": null,
        "code": "def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.stop()",
        "line_count": 7,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Status",
        "methods": [
          "__init__",
          "renderable",
          "console",
          "update",
          "start",
          "stop",
          "__rich__",
          "__enter__",
          "__exit__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 11,
        "docstring": "Displays a status indicator with a 'spinner' animation.\n\nArgs:\n    status (RenderableType): A status renderable (str or Text typically).\n    console (Console, optional): Console instance to use, or None for global console. Defaults to None.\n    spinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to \"dots\".\n    spinner_style (StyleType, optional): Style of spinner. Defaults to \"status.spinner\".\n    speed (float, optional): Speed factor for spinner animation. Defaults to 1.0.\n    refresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5."
      }
    ],
    "imports": [
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "live",
        "name": "Live",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "spinner",
        "name": "Spinner",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "time",
        "name": "sleep",
        "alias": null,
        "lineno": 110,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 112,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "console.log",
      "status.update",
      "Console",
      "sleep",
      "console.status"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.log",
        "status.update",
        "Console",
        "sleep",
        "console.status"
      ],
      "class_instantiations": [
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time",
        "typing"
      ],
      "third_party": {
        "other": [
          "types",
          "console",
          "jupyter",
          "live",
          "spinner",
          "style"
        ]
      },
      "tech_stack": []
    },
    "line_count": 132
  },
  "rich/style.py": {
    "filepath": "../rich/rich/style.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "bit_no",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 26,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self, bit_no: int) -> None:\n        self.bit = 1 << bit_no",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__get__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "Style"
          },
          {
            "name": "objtype",
            "type": "Type[Style]"
          }
        ],
        "return_type": "Optional[bool]",
        "lineno": 29,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __get__(self, obj: \"Style\", objtype: Type[\"Style\"]) -> Optional[bool]:\n        if obj._set_attributes & self.bit:\n            return obj._attributes & self.bit != 0\n        return None",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": null,
        "lineno": 127,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "hash",
          "randint",
          "sum",
          "meta",
          "color",
          "Color",
          "link",
          "_make_color",
          "dumps",
          "Color.parse",
          "bgcolor",
          "self._meta"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        *,\n        color: Optional[Union[Color, str]] = None,\n        bgcolor: Optional[Union[Color, str]] = None,\n        bold: Optional[bool] = None,\n        dim: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        underline: Optional[bool] = None,\n        blink: Optional[bool] = None,\n        blink2: Optional[bool] = None,\n        reverse: Optional[bool] = None,\n        conceal: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        underline2: Optional[bool] = None,\n        frame: Optional[bool] = None,\n        encircle: Optional[bool] = None,\n        overline: Optional[bool] = None,\n        link: Optional[str] = None,\n        meta: Optional[Dict[str, Any]] = None,\n    ):\n        self._ansi: Optional[str] = None\n        self._style_definition: Optional[str] = None\n\n        def _make_color(color: Union[Color, str]) -> Color:\n            return color if isinstance(color, Color) else Color.parse(color)\n\n        self._color = None if color is None else _make_color(color)\n        self._bgcolor = None if bgcolor is None else _make_color(bgcolor)\n        self._set_attributes = sum(\n            (\n                bold is not None,\n                dim is not None and 2,\n                italic is not None and 4,\n                underline is not None and 8,\n                blink is not None and 16,\n                blink2 is not None and 32,\n                reverse is not None and 64,\n                conceal is not None and 128,\n                strike is not None and 256,\n                underline2 is not None and 512,\n                frame is not None and 1024,\n                encircle is not None and 2048,\n                overline is not None and 4096,\n            )\n        )\n        self._attributes = (\n            sum(\n                (\n                    bold and 1 or 0,\n                    dim and 2 or 0,\n                    italic and 4 or 0,\n                    underline and 8 or 0,\n                    blink and 16 or 0,\n                    blink2 and 32 or 0,\n                    reverse and 64 or 0,\n                    conceal and 128 or 0,\n                    strike and 256 or 0,\n                    underline2 and 512 or 0,\n                    frame and 1024 or 0,\n                    encircle and 2048 or 0,\n                    overline and 4096 or 0,\n                )\n            )\n            if self._set_attributes\n            else 0\n        )\n\n        self._link = link\n        self._meta = None if meta is None else dumps(meta)\n        self._link_id = (\n            f\"{randint(0, 999999)}{hash(self._meta)}\" if (link or meta) else \"\"\n        )\n        self._hash: Optional[int] = None\n        self._null = not (self._set_attributes or color or bgcolor or link or meta)",
        "line_count": 75,
        "needs_llm_summary": true
      },
      {
        "name": "null",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Style",
        "lineno": 204,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Create an 'null' style, equivalent to Style(), but more performant.",
        "code": "def null(cls) -> \"Style\":\n        \"\"\"Create an 'null' style, equivalent to Style(), but more performant.\"\"\"\n        return NULL_STYLE",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "from_color",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "color",
            "type": "Optional[Color]"
          },
          {
            "name": "bgcolor",
            "type": "Optional[Color]"
          }
        ],
        "return_type": "Style",
        "lineno": 209,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "color",
          "cls.__new__",
          "Style",
          "bgcolor"
        ],
        "docstring": "Create a new style with colors and no attributes.\n\nReturns:\n    color (Optional[Color]): A (foreground) color, or None for no color. Defaults to None.\n    bgcolor (Optional[Color]): A (background) color, or None for no color. Defaults to None.",
        "code": "def from_color(\n        cls, color: Optional[Color] = None, bgcolor: Optional[Color] = None\n    ) -> \"Style\":\n        \"\"\"Create a new style with colors and no attributes.\n\n        Returns:\n            color (Optional[Color]): A (foreground) color, or None for no color. Defaults to None.\n            bgcolor (Optional[Color]): A (background) color, or None for no color. Defaults to None.\n        \"\"\"\n        style: Style = cls.__new__(Style)\n        style._ansi = None\n        style._style_definition = None\n        style._color = color\n        style._bgcolor = bgcolor\n        style._set_attributes = 0\n        style._attributes = 0\n        style._link = None\n        style._link_id = \"\"\n        style._meta = None\n        style._null = not (color or bgcolor)\n        style._hash = None\n        return style",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "from_meta",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "meta",
            "type": "Optional[Dict[str, Any]]"
          }
        ],
        "return_type": "Style",
        "lineno": 233,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "hash",
          "randint",
          "meta",
          "style._meta",
          "cls.__new__",
          "dumps",
          "Style"
        ],
        "docstring": "Create a new style with meta data.\n\nReturns:\n    meta (Optional[Dict[str, Any]]): A dictionary of meta data. Defaults to None.",
        "code": "def from_meta(cls, meta: Optional[Dict[str, Any]]) -> \"Style\":\n        \"\"\"Create a new style with meta data.\n\n        Returns:\n            meta (Optional[Dict[str, Any]]): A dictionary of meta data. Defaults to None.\n        \"\"\"\n        style: Style = cls.__new__(Style)\n        style._ansi = None\n        style._style_definition = None\n        style._color = None\n        style._bgcolor = None\n        style._set_attributes = 0\n        style._attributes = 0\n        style._link = None\n        style._meta = dumps(meta)\n        style._link_id = f\"{randint(0, 999999)}{hash(style._meta)}\"\n        style._hash = None\n        style._null = not (meta)\n        return style",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "on",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "meta",
            "type": "Optional[Dict[str, Any]]"
          }
        ],
        "return_type": "Style",
        "lineno": 254,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "handlers.items",
          "meta.update",
          "cls.from_meta",
          "meta"
        ],
        "docstring": "Create a blank style with meta information.\n\nExample:\n    style = Style.on(click=self.on_click)\n\nArgs:\n    meta (Optional[Dict[str, Any]], optional): An optional dict of meta information.\n    **handlers (Any): Keyword arguments are translated in to handlers.\n\nReturns:\n    Style: A Style with meta information attached.",
        "code": "def on(cls, meta: Optional[Dict[str, Any]] = None, **handlers: Any) -> \"Style\":\n        \"\"\"Create a blank style with meta information.\n\n        Example:\n            style = Style.on(click=self.on_click)\n\n        Args:\n            meta (Optional[Dict[str, Any]], optional): An optional dict of meta information.\n            **handlers (Any): Keyword arguments are translated in to handlers.\n\n        Returns:\n            Style: A Style with meta information attached.\n        \"\"\"\n        meta = {} if meta is None else meta\n        meta.update({f\"@{key}\": value for key, value in handlers.items()})\n        return cls.from_meta(meta)",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "link_id",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 286,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get a link id, used in ansi code for links.",
        "code": "def link_id(self) -> str:\n        \"\"\"Get a link id, used in ansi code for links.\"\"\"\n        return self._link_id",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 290,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._set_attributes",
          "self._bgcolor.name",
          "append",
          "self._color.name",
          "attributes.append",
          "attributes",
          "unknown.join",
          "self._link"
        ],
        "docstring": "Re-generate style definition from attributes.",
        "code": "def __str__(self) -> str:\n        \"\"\"Re-generate style definition from attributes.\"\"\"\n        if self._style_definition is None:\n            attributes: List[str] = []\n            append = attributes.append\n            bits = self._set_attributes\n            if bits & 0b0000000001111:\n                if bits & 1:\n                    append(\"bold\" if self.bold else \"not bold\")\n                if bits & (1 << 1):\n                    append(\"dim\" if self.dim else \"not dim\")\n                if bits & (1 << 2):\n                    append(\"italic\" if self.italic else \"not italic\")\n                if bits & (1 << 3):\n                    append(\"underline\" if self.underline else \"not underline\")\n            if bits & 0b0000111110000:\n                if bits & (1 << 4):\n                    append(\"blink\" if self.blink else \"not blink\")\n                if bits & (1 << 5):\n                    append(\"blink2\" if self.blink2 else \"not blink2\")\n                if bits & (1 << 6):\n                    append(\"reverse\" if self.reverse else \"not reverse\")\n                if bits & (1 << 7):\n                    append(\"conceal\" if self.conceal else \"not conceal\")\n                if bits & (1 << 8):\n                    append(\"strike\" if self.strike else \"not strike\")\n            if bits & 0b1111000000000:\n                if bits & (1 << 9):\n                    append(\"underline2\" if self.underline2 else \"not underline2\")\n                if bits & (1 << 10):\n                    append(\"frame\" if self.frame else \"not frame\")\n                if bits & (1 << 11):\n                    append(\"encircle\" if self.encircle else \"not encircle\")\n                if bits & (1 << 12):\n                    append(\"overline\" if self.overline else \"not overline\")\n            if self._color is not None:\n                append(self._color.name)\n            if self._bgcolor is not None:\n                append(\"on\")\n                append(self._bgcolor.name)\n            if self._link:\n                append(\"link\")\n                append(self._link)\n            self._style_definition = \" \".join(attributes) or \"none\"\n        return self._style_definition",
        "line_count": 45,
        "needs_llm_summary": true
      },
      {
        "name": "__bool__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 336,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "A Style is false if it has no attributes, colors, or links.",
        "code": "def __bool__(self) -> bool:\n        \"\"\"A Style is false if it has no attributes, colors, or links.\"\"\"\n        return not self._null",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_make_ansi_codes",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "color_system",
            "type": "ColorSystem"
          }
        ],
        "return_type": "str",
        "lineno": 340,
        "decorators": [],
        "is_async": false,
        "calls": [
          "range",
          "self._style_map",
          "append",
          "self._color.downgrade",
          "sgr",
          "sgr.extend",
          "color_system",
          "unknown.join",
          "self._bgcolor.downgrade",
          "sgr.append",
          "unknown.get_ansi_codes"
        ],
        "docstring": "Generate ANSI codes for this style.\n\nArgs:\n    color_system (ColorSystem): Color system.\n\nReturns:\n    str: String containing codes.",
        "code": "def _make_ansi_codes(self, color_system: ColorSystem) -> str:\n        \"\"\"Generate ANSI codes for this style.\n\n        Args:\n            color_system (ColorSystem): Color system.\n\n        Returns:\n            str: String containing codes.\n        \"\"\"\n\n        if self._ansi is None:\n            sgr: List[str] = []\n            append = sgr.append\n            _style_map = self._style_map\n            attributes = self._attributes & self._set_attributes\n            if attributes:\n                if attributes & 1:\n                    append(_style_map[0])\n                if attributes & 2:\n                    append(_style_map[1])\n                if attributes & 4:\n                    append(_style_map[2])\n                if attributes & 8:\n                    append(_style_map[3])\n                if attributes & 0b0000111110000:\n                    for bit in range(4, 9):\n                        if attributes & (1 << bit):\n                            append(_style_map[bit])\n                if attributes & 0b1111000000000:\n                    for bit in range(9, 13):\n                        if attributes & (1 << bit):\n                            append(_style_map[bit])\n            if self._color is not None:\n                sgr.extend(self._color.downgrade(color_system).get_ansi_codes())\n            if self._bgcolor is not None:\n                sgr.extend(\n                    self._bgcolor.downgrade(color_system).get_ansi_codes(\n                        foreground=False\n                    )\n                )\n            self._ansi = \";\".join(sgr)\n        return self._ansi",
        "line_count": 42,
        "needs_llm_summary": true
      },
      {
        "name": "normalize",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "style",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 385,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 1024
            }
          }
        ],
        "is_async": false,
        "calls": [
          "str",
          "lru_cache",
          "style",
          "style.strip",
          "cls.parse",
          "unknown.lower"
        ],
        "docstring": "Normalize a style definition so that styles with the same effect have the same string\nrepresentation.\n\nArgs:\n    style (str): A style definition.\n\nReturns:\n    str: Normal form of style definition.",
        "code": "def normalize(cls, style: str) -> str:\n        \"\"\"Normalize a style definition so that styles with the same effect have the same string\n        representation.\n\n        Args:\n            style (str): A style definition.\n\n        Returns:\n            str: Normal form of style definition.\n        \"\"\"\n        try:\n            return str(cls.parse(style))\n        except errors.StyleSyntaxError:\n            return style.strip().lower()",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "pick_first",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "StyleType",
        "lineno": 401,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "ValueError"
        ],
        "docstring": "Pick first non-None style.",
        "code": "def pick_first(cls, *values: Optional[StyleType]) -> StyleType:\n        \"\"\"Pick first non-None style.\"\"\"\n        for value in values:\n            if value is not None:\n                return value\n        raise ValueError(\"expected at least one non-None style\")",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Result",
        "lineno": 408,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __rich_repr__(self) -> Result:\n        yield \"color\", self.color, None\n        yield \"bgcolor\", self.bgcolor, None\n        yield \"bold\", self.bold, None,\n        yield \"dim\", self.dim, None,\n        yield \"italic\", self.italic, None\n        yield \"underline\", self.underline, None,\n        yield \"blink\", self.blink, None\n        yield \"blink2\", self.blink2, None\n        yield \"reverse\", self.reverse, None\n        yield \"conceal\", self.conceal, None\n        yield \"strike\", self.strike, None\n        yield \"underline2\", self.underline2, None\n        yield \"frame\", self.frame, None\n        yield \"encircle\", self.encircle, None\n        yield \"link\", self.link, None\n        if self._meta:\n            yield \"meta\", self.meta",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "__eq__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "other",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 427,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "self.__hash__",
          "Style",
          "other",
          "other.__hash__"
        ],
        "docstring": null,
        "code": "def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Style):\n            return NotImplemented\n        return self.__hash__() == other.__hash__()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__ne__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "other",
            "type": "Any"
          }
        ],
        "return_type": "bool",
        "lineno": 432,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "self.__hash__",
          "Style",
          "other",
          "other.__hash__"
        ],
        "docstring": null,
        "code": "def __ne__(self, other: Any) -> bool:\n        if not isinstance(other, Style):\n            return NotImplemented\n        return self.__hash__() != other.__hash__()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__hash__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 437,
        "decorators": [],
        "is_async": false,
        "calls": [
          "hash",
          "_hash_getter",
          "self"
        ],
        "docstring": null,
        "code": "def __hash__(self) -> int:\n        if self._hash is not None:\n            return self._hash\n        self._hash = hash(_hash_getter(self))\n        return self._hash",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "color",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[Color]",
        "lineno": 444,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "The foreground color or None if it is not set.",
        "code": "def color(self) -> Optional[Color]:\n        \"\"\"The foreground color or None if it is not set.\"\"\"\n        return self._color",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "bgcolor",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[Color]",
        "lineno": 449,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "The background color or None if it is not set.",
        "code": "def bgcolor(self) -> Optional[Color]:\n        \"\"\"The background color or None if it is not set.\"\"\"\n        return self._bgcolor",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "link",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[str]",
        "lineno": 454,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Link text, if set.",
        "code": "def link(self) -> Optional[str]:\n        \"\"\"Link text, if set.\"\"\"\n        return self._link",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "transparent_background",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 459,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Check if the style specified a transparent background.",
        "code": "def transparent_background(self) -> bool:\n        \"\"\"Check if the style specified a transparent background.\"\"\"\n        return self.bgcolor is None or self.bgcolor.is_default",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "background_style",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 464,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "Style",
          "self.bgcolor"
        ],
        "docstring": "A Style with background only.",
        "code": "def background_style(self) -> \"Style\":\n        \"\"\"A Style with background only.\"\"\"\n        return Style(bgcolor=self.bgcolor)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "meta",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Dict[str, Any]",
        "lineno": 469,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "loads",
          "cast",
          "self._meta"
        ],
        "docstring": "Get meta information (can not be changed after construction).",
        "code": "def meta(self) -> Dict[str, Any]:\n        \"\"\"Get meta information (can not be changed after construction).\"\"\"\n        return {} if self._meta is None else cast(Dict[str, Any], loads(self._meta))",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "without_color",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 474,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.__new__",
          "self._set_attributes",
          "randint",
          "self._attributes",
          "Style",
          "self._link"
        ],
        "docstring": "Get a copy of the style with color removed.",
        "code": "def without_color(self) -> \"Style\":\n        \"\"\"Get a copy of the style with color removed.\"\"\"\n        if self._null:\n            return NULL_STYLE\n        style: Style = self.__new__(Style)\n        style._ansi = None\n        style._style_definition = None\n        style._color = None\n        style._bgcolor = None\n        style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n        style._link = self._link\n        style._link_id = f\"{randint(0, 999999)}\" if self._link else \"\"\n        style._null = False\n        style._meta = None\n        style._hash = None\n        return style",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "parse",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "style_definition",
            "type": "str"
          }
        ],
        "return_type": "Style",
        "lineno": 494,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          },
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 4096
            }
          }
        ],
        "is_async": false,
        "calls": [
          "style_definition.split",
          "cls.null",
          "lru_cache",
          "color",
          "attributes",
          "link",
          "word",
          "next",
          "errors.StyleSyntaxError",
          "STYLE_ATTRIBUTES.get",
          "iter",
          "original_word.lower",
          "Color.parse",
          "bgcolor",
          "Style",
          "words",
          "cls.STYLE_ATTRIBUTES",
          "style_definition.strip"
        ],
        "docstring": "Parse a style definition.\n\nArgs:\n    style_definition (str): A string containing a style.\n\nRaises:\n    errors.StyleSyntaxError: If the style definition syntax is invalid.\n\nReturns:\n    `Style`: A Style instance.",
        "code": "def parse(cls, style_definition: str) -> \"Style\":\n        \"\"\"Parse a style definition.\n\n        Args:\n            style_definition (str): A string containing a style.\n\n        Raises:\n            errors.StyleSyntaxError: If the style definition syntax is invalid.\n\n        Returns:\n            `Style`: A Style instance.\n        \"\"\"\n        if style_definition.strip() == \"none\" or not style_definition:\n            return cls.null()\n\n        STYLE_ATTRIBUTES = cls.STYLE_ATTRIBUTES\n        color: Optional[str] = None\n        bgcolor: Optional[str] = None\n        attributes: Dict[str, Optional[Any]] = {}\n        link: Optional[str] = None\n\n        words = iter(style_definition.split())\n        for original_word in words:\n            word = original_word.lower()\n            if word == \"on\":\n                word = next(words, \"\")\n                if not word:\n                    raise errors.StyleSyntaxError(\"color expected after 'on'\")\n                try:\n                    Color.parse(word)\n                except ColorParseError as error:\n                    raise errors.StyleSyntaxError(\n                        f\"unable to parse {word!r} as background color; {error}\"\n                    ) from None\n                bgcolor = word\n\n            elif word == \"not\":\n                word = next(words, \"\")\n                attribute = STYLE_ATTRIBUTES.get(word)\n                if attribute is None:\n                    raise errors.StyleSyntaxError(\n                        f\"expected style attribute after 'not', found {word!r}\"\n                    )\n                attributes[attribute] = False\n\n            elif word == \"link\":\n                word = next(words, \"\")\n                if not word:\n                    raise errors.StyleSyntaxError(\"URL expected after 'link'\")\n                link = word\n\n            elif word in STYLE_ATTRIBUTES:\n                attributes[STYLE_ATTRIBUTES[word]] = True\n\n            else:\n                try:\n                    Color.parse(word)\n                except ColorParseError as error:\n                    raise errors.StyleSyntaxError(\n                        f\"unable to parse {word!r} as color; {error}\"\n                    ) from None\n                color = word\n        style = Style(color=color, bgcolor=bgcolor, link=link, **attributes)\n        return style",
        "line_count": 64,
        "needs_llm_summary": true
      },
      {
        "name": "get_html_style",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "theme",
            "type": "Optional[TerminalTheme]"
          }
        ],
        "return_type": "str",
        "lineno": 560,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 1024
            }
          }
        ],
        "is_async": false,
        "calls": [
          "foreground_color",
          "append",
          "lru_cache",
          "Color.from_triplet",
          "theme.background_color",
          "unknown.join",
          "color.get_truecolor",
          "theme",
          "css",
          "blend_rgb",
          "css.append",
          "self.color",
          "bgcolor.get_truecolor",
          "self.bgcolor"
        ],
        "docstring": "Get a CSS style rule.",
        "code": "def get_html_style(self, theme: Optional[TerminalTheme] = None) -> str:\n        \"\"\"Get a CSS style rule.\"\"\"\n        theme = theme or DEFAULT_TERMINAL_THEME\n        css: List[str] = []\n        append = css.append\n\n        color = self.color\n        bgcolor = self.bgcolor\n        if self.reverse:\n            color, bgcolor = bgcolor, color\n        if self.dim:\n            foreground_color = (\n                theme.foreground_color if color is None else color.get_truecolor(theme)\n            )\n            color = Color.from_triplet(\n                blend_rgb(foreground_color, theme.background_color, 0.5)\n            )\n        if color is not None:\n            theme_color = color.get_truecolor(theme)\n            append(f\"color: {theme_color.hex}\")\n            append(f\"text-decoration-color: {theme_color.hex}\")\n        if bgcolor is not None:\n            theme_color = bgcolor.get_truecolor(theme, foreground=False)\n            append(f\"background-color: {theme_color.hex}\")\n        if self.bold:\n            append(\"font-weight: bold\")\n        if self.italic:\n            append(\"font-style: italic\")\n        if self.underline:\n            append(\"text-decoration: underline\")\n        if self.strike:\n            append(\"text-decoration: line-through\")\n        if self.overline:\n            append(\"text-decoration: overline\")\n        return \"; \".join(css)",
        "line_count": 35,
        "needs_llm_summary": true
      },
      {
        "name": "combine",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "styles",
            "type": "Iterable[Style]"
          }
        ],
        "return_type": "Style",
        "lineno": 597,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "sum",
          "iter_styles",
          "next",
          "iter",
          "styles"
        ],
        "docstring": "Combine styles and get result.\n\nArgs:\n    styles (Iterable[Style]): Styles to combine.\n\nReturns:\n    Style: A new style instance.",
        "code": "def combine(cls, styles: Iterable[\"Style\"]) -> \"Style\":\n        \"\"\"Combine styles and get result.\n\n        Args:\n            styles (Iterable[Style]): Styles to combine.\n\n        Returns:\n            Style: A new style instance.\n        \"\"\"\n        iter_styles = iter(styles)\n        return sum(iter_styles, next(iter_styles))",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "chain",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Style",
        "lineno": 610,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "sum",
          "iter_styles",
          "next",
          "iter",
          "styles"
        ],
        "docstring": "Combine styles from positional argument in to a single style.\n\nArgs:\n    *styles (Iterable[Style]): Styles to combine.\n\nReturns:\n    Style: A new style instance.",
        "code": "def chain(cls, *styles: \"Style\") -> \"Style\":\n        \"\"\"Combine styles from positional argument in to a single style.\n\n        Args:\n            *styles (Iterable[Style]): Styles to combine.\n\n        Returns:\n            Style: A new style instance.\n        \"\"\"\n        iter_styles = iter(styles)\n        return sum(iter_styles, next(iter_styles))",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "copy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 622,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.__new__",
          "self._set_attributes",
          "randint",
          "self._hash",
          "self._style_definition",
          "self._bgcolor",
          "self._color",
          "self._attributes",
          "Style",
          "self._link",
          "self._ansi",
          "self._meta"
        ],
        "docstring": "Get a copy of this style.\n\nReturns:\n    Style: A new Style instance with identical attributes.",
        "code": "def copy(self) -> \"Style\":\n        \"\"\"Get a copy of this style.\n\n        Returns:\n            Style: A new Style instance with identical attributes.\n        \"\"\"\n        if self._null:\n            return NULL_STYLE\n        style: Style = self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition = self._style_definition\n        style._color = self._color\n        style._bgcolor = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n        style._link = self._link\n        style._link_id = f\"{randint(0, 999999)}\" if self._link else \"\"\n        style._hash = self._hash\n        style._null = False\n        style._meta = self._meta\n        return style",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "clear_meta_and_links",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 645,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 128
            }
          }
        ],
        "is_async": false,
        "calls": [
          "self.__new__",
          "self._set_attributes",
          "self._style_definition",
          "lru_cache",
          "self._bgcolor",
          "self._color",
          "self._attributes",
          "Style",
          "self._ansi"
        ],
        "docstring": "Get a copy of this style with link and meta information removed.\n\nReturns:\n    Style: New style object.",
        "code": "def clear_meta_and_links(self) -> \"Style\":\n        \"\"\"Get a copy of this style with link and meta information removed.\n\n        Returns:\n            Style: New style object.\n        \"\"\"\n        if self._null:\n            return NULL_STYLE\n        style: Style = self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition = self._style_definition\n        style._color = self._color\n        style._bgcolor = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n        style._link = None\n        style._link_id = \"\"\n        style._hash = None\n        style._null = False\n        style._meta = None\n        return style",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "update_link",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "link",
            "type": "Optional[str]"
          }
        ],
        "return_type": "Style",
        "lineno": 667,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.__new__",
          "self._set_attributes",
          "randint",
          "self._style_definition",
          "self._bgcolor",
          "link",
          "self._color",
          "self._attributes",
          "Style",
          "self._meta",
          "self._ansi"
        ],
        "docstring": "Get a copy with a different value for link.\n\nArgs:\n    link (str, optional): New value for link. Defaults to None.\n\nReturns:\n    Style: A new Style instance.",
        "code": "def update_link(self, link: Optional[str] = None) -> \"Style\":\n        \"\"\"Get a copy with a different value for link.\n\n        Args:\n            link (str, optional): New value for link. Defaults to None.\n\n        Returns:\n            Style: A new Style instance.\n        \"\"\"\n        style: Style = self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition = self._style_definition\n        style._color = self._color\n        style._bgcolor = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n        style._link = link\n        style._link_id = f\"{randint(0, 999999)}\" if link else \"\"\n        style._hash = None\n        style._null = False\n        style._meta = self._meta\n        return style",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 690,
        "decorators": [],
        "is_async": false,
        "calls": [
          "color_system",
          "self._make_ansi_codes"
        ],
        "docstring": "Render the ANSI codes for the style.\n\nArgs:\n    text (str, optional): A string to style. Defaults to \"\".\n    color_system (Optional[ColorSystem], optional): Color system to render to. Defaults to ColorSystem.TRUECOLOR.\n\nReturns:\n    str: A string containing ANSI style codes.",
        "code": "def render(\n        self,\n        text: str = \"\",\n        *,\n        color_system: Optional[ColorSystem] = ColorSystem.TRUECOLOR,\n        legacy_windows: bool = False,\n    ) -> str:\n        \"\"\"Render the ANSI codes for the style.\n\n        Args:\n            text (str, optional): A string to style. Defaults to \"\".\n            color_system (Optional[ColorSystem], optional): Color system to render to. Defaults to ColorSystem.TRUECOLOR.\n\n        Returns:\n            str: A string containing ANSI style codes.\n        \"\"\"\n        if not text or color_system is None:\n            return text\n        attrs = self._ansi or self._make_ansi_codes(color_system)\n        rendered = f\"\\x1b[{attrs}m{text}\\x1b[0m\" if attrs else text\n        if self._link and not legacy_windows:\n            rendered = (\n                f\"\\x1b]8;id={self._link_id};{self._link}\\x1b\\\\{rendered}\\x1b]8;;\\x1b\\\\\"\n            )\n        return rendered",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "test",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Optional[str]"
          }
        ],
        "return_type": "None",
        "lineno": 716,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.render",
          "str",
          "text",
          "sys.stdout.write",
          "self"
        ],
        "docstring": "Write text with style directly to terminal.\n\nThis method is for testing purposes only.\n\nArgs:\n    text (Optional[str], optional): Text to style or None for style name.",
        "code": "def test(self, text: Optional[str] = None) -> None:\n        \"\"\"Write text with style directly to terminal.\n\n        This method is for testing purposes only.\n\n        Args:\n            text (Optional[str], optional): Text to style or None for style name.\n\n        \"\"\"\n        text = text or str(self)\n        sys.stdout.write(f\"{self.render(text)}\\n\")",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "_add",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "style",
            "type": "Optional[Style]"
          }
        ],
        "return_type": "Style",
        "lineno": 729,
        "decorators": [
          {
            "name": "lru_cache",
            "args": [],
            "kwargs": {
              "maxsize": 1024
            }
          }
        ],
        "is_async": false,
        "calls": [
          "self.__new__",
          "lru_cache",
          "style._null",
          "dumps",
          "Style"
        ],
        "docstring": null,
        "code": "def _add(self, style: Optional[\"Style\"]) -> \"Style\":\n        if style is None or style._null:\n            return self\n        if self._null:\n            return style\n        new_style: Style = self.__new__(Style)\n        new_style._ansi = None\n        new_style._style_definition = None\n        new_style._color = style._color or self._color\n        new_style._bgcolor = style._bgcolor or self._bgcolor\n        new_style._attributes = (self._attributes & ~style._set_attributes) | (\n            style._attributes & style._set_attributes\n        )\n        new_style._set_attributes = self._set_attributes | style._set_attributes\n        new_style._link = style._link or self._link\n        new_style._link_id = style._link_id or self._link_id\n        new_style._null = style._null\n        if self._meta and style._meta:\n            new_style._meta = dumps({**self.meta, **style.meta})\n        else:\n            new_style._meta = self._meta or style._meta\n        new_style._hash = None\n        return new_style",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "__add__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "style",
            "type": "Optional[Style]"
          }
        ],
        "return_type": "Style",
        "lineno": 753,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "self._add",
          "combined_style.copy"
        ],
        "docstring": null,
        "code": "def __add__(self, style: Optional[\"Style\"]) -> \"Style\":\n        combined_style = self._add(style)\n        return combined_style.copy() if combined_style.link else combined_style",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "default_style",
            "type": "Style"
          }
        ],
        "return_type": "None",
        "lineno": 766,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __init__(self, default_style: \"Style\") -> None:\n        self._stack: List[Style] = [default_style]",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 769,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"<stylestack {self._stack!r}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "current",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 773,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get the Style at the top of the stack.",
        "code": "def current(self) -> Style:\n        \"\"\"Get the Style at the top of the stack.\"\"\"\n        return self._stack[-1]",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "push",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "style",
            "type": "Style"
          }
        ],
        "return_type": "None",
        "lineno": 777,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._stack.append"
        ],
        "docstring": "Push a new style on to the stack.\n\nArgs:\n    style (Style): New style to combine with current style.",
        "code": "def push(self, style: Style) -> None:\n        \"\"\"Push a new style on to the stack.\n\n        Args:\n            style (Style): New style to combine with current style.\n        \"\"\"\n        self._stack.append(self._stack[-1] + style)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "pop",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 785,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._stack.pop"
        ],
        "docstring": "Pop last style and discard.\n\nReturns:\n    Style: New current style (also available as stack.current)",
        "code": "def pop(self) -> Style:\n        \"\"\"Pop last style and discard.\n\n        Returns:\n            Style: New current style (also available as stack.current)\n        \"\"\"\n        self._stack.pop()\n        return self._stack[-1]",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "_make_color",
        "args": [
          {
            "name": "color",
            "type": "Union[Color, str]"
          }
        ],
        "return_type": "Color",
        "lineno": 151,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "color",
          "Color.parse",
          "Color"
        ],
        "docstring": null,
        "code": "def _make_color(color: Union[Color, str]) -> Color:\n            return color if isinstance(color, Color) else Color.parse(color)",
        "line_count": 2,
        "needs_llm_summary": false
      }
    ],
    "classes": [
      {
        "name": "_Bit",
        "methods": [
          "__init__",
          "__get__"
        ],
        "base_classes": [],
        "lineno": 21,
        "docstring": "A descriptor to get/set a style attribute bit."
      },
      {
        "name": "Style",
        "methods": [
          "__init__",
          "null",
          "from_color",
          "from_meta",
          "on",
          "link_id",
          "__str__",
          "__bool__",
          "_make_ansi_codes",
          "normalize",
          "pick_first",
          "__rich_repr__",
          "__eq__",
          "__ne__",
          "__hash__",
          "color",
          "bgcolor",
          "link",
          "transparent_background",
          "background_style",
          "meta",
          "without_color",
          "parse",
          "get_html_style",
          "combine",
          "chain",
          "copy",
          "clear_meta_and_links",
          "update_link",
          "render",
          "test",
          "_add",
          "__add__"
        ],
        "base_classes": [],
        "lineno": 36,
        "docstring": "A terminal style.\n\nA terminal style consists of a color (`color`), a background color (`bgcolor`), and a number of attributes, such\nas bold, italic etc. The attributes have 3 states: they can either be on\n(``True``), off (``False``), or not set (``None``).\n\nArgs:\n    color (Union[Color, str], optional): Color of terminal text. Defaults to None.\n    bgcolor (Union[Color, str], optional): Color of terminal background. Defaults to None.\n    bold (bool, optional): Enable bold text. Defaults to None.\n    dim (bool, optional): Enable dim text. Defaults to None.\n    italic (bool, optional): Enable italic text. Defaults to None.\n    underline (bool, optional): Enable underlined text. Defaults to None.\n    blink (bool, optional): Enabled blinking text. Defaults to None.\n    blink2 (bool, optional): Enable fast blinking text. Defaults to None.\n    reverse (bool, optional): Enabled reverse text. Defaults to None.\n    conceal (bool, optional): Enable concealed text. Defaults to None.\n    strike (bool, optional): Enable strikethrough text. Defaults to None.\n    underline2 (bool, optional): Enable doubly underlined text. Defaults to None.\n    frame (bool, optional): Enable framed text. Defaults to None.\n    encircle (bool, optional): Enable encircled text. Defaults to None.\n    overline (bool, optional): Enable overlined text. Defaults to None.\n    link (str, link): Link URL. Defaults to None."
      },
      {
        "name": "StyleStack",
        "methods": [
          "__init__",
          "__repr__",
          "current",
          "push",
          "pop"
        ],
        "base_classes": [],
        "lineno": 761,
        "docstring": "A stack of styles."
      }
    ],
    "imports": [
      {
        "module": "sys",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "functools",
        "name": "lru_cache",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "operator",
        "name": "attrgetter",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "pickle",
        "name": "dumps",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "pickle",
        "name": "loads",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "random",
        "name": "randint",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "cast",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "errors",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "Color",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "ColorParseError",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "ColorSystem",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "blend_rgb",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "repr",
        "name": "Result",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "repr",
        "name": "rich_repr",
        "alias": null,
        "lineno": 10,
        "type": "from_import"
      },
      {
        "module": "terminal_theme",
        "name": "DEFAULT_TERMINAL_THEME",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      },
      {
        "module": "terminal_theme",
        "name": "TerminalTheme",
        "alias": null,
        "lineno": 11,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "_hash_getter",
        "assigned_to": "attrgetter",
        "lineno": 13
      },
      {
        "name": "StyleType",
        "assigned_to": null,
        "lineno": 18
      },
      {
        "name": "NULL_STYLE",
        "assigned_to": "Style",
        "lineno": 758
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Style",
        "attrgetter"
      ],
      "class_instantiations": [
        "Style"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "functools",
        "pickle",
        "random",
        "sys"
      ],
      "third_party": {
        "other": [
          "operator",
          "errors",
          "color",
          "repr",
          "terminal_theme"
        ]
      },
      "tech_stack": []
    },
    "line_count": 793
  },
  "rich/styled.py": {
    "filepath": "../rich/rich/styled.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          },
          {
            "name": "style",
            "type": "StyleType"
          }
        ],
        "return_type": "None",
        "lineno": 19,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "renderable"
        ],
        "docstring": null,
        "code": "def __init__(self, renderable: \"RenderableType\", style: \"StyleType\") -> None:\n        self.renderable = renderable\n        self.style = style",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 23,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "rendered_segments",
          "options",
          "style",
          "console.get_style",
          "self.renderable",
          "console.render",
          "Segment.apply_style"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        style = console.get_style(self.style)\n        rendered_segments = console.render(self.renderable, options)\n        segments = Segment.apply_style(rendered_segments, style)\n        return segments",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 31,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.renderable",
          "Measurement.get",
          "console",
          "options"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        return Measurement.get(console, options, self.renderable)",
        "line_count": 4,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Styled",
        "methods": [
          "__init__",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [],
        "lineno": 11,
        "docstring": "Apply a style to a renderable.\n\nArgs:\n    renderable (RenderableType): Any renderable.\n    style (StyleType): A style to apply across the entire renderable."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "rich",
        "name": "print",
        "alias": null,
        "lineno": 38,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 39,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "Styled",
      "print",
      "Panel"
    ],
    "module_level_calls": {
      "function_calls": [
        "Styled",
        "print",
        "Panel",
        "panel"
      ],
      "class_instantiations": [
        "Styled",
        "Panel"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "measure",
          "segment",
          "style",
          "console",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 43
  },
  "rich/syntax.py": {
    "filepath": "../rich/rich/syntax.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_get_code_index_for_syntax_position",
        "args": [
          {
            "name": "newlines_offsets",
            "type": "Sequence[int]"
          },
          {
            "name": "position",
            "type": "SyntaxPosition"
          }
        ],
        "return_type": "Optional[int]",
        "lineno": 841,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "position",
          "column_index",
          "newlines_offsets",
          "line_length",
          "len"
        ],
        "docstring": "Returns the index of the code string for the given positions.\n\nArgs:\n    newlines_offsets (Sequence[int]): The offset of each newline character found in the code snippet.\n    position (SyntaxPosition): The position to search for.\n\nReturns:\n    Optional[int]: The index of the code string for this position, or `None`\n        if the given position's line number is out of range (if it's the column that is out of range\n        we silently clamp its value so that it reaches the end of the line)",
        "code": "def _get_code_index_for_syntax_position(\n    newlines_offsets: Sequence[int], position: SyntaxPosition\n) -> Optional[int]:\n    \"\"\"\n    Returns the index of the code string for the given positions.\n\n    Args:\n        newlines_offsets (Sequence[int]): The offset of each newline character found in the code snippet.\n        position (SyntaxPosition): The position to search for.\n\n    Returns:\n        Optional[int]: The index of the code string for this position, or `None`\n            if the given position's line number is out of range (if it's the column that is out of range\n            we silently clamp its value so that it reaches the end of the line)\n    \"\"\"\n    lines_count = len(newlines_offsets)\n\n    line_number, column_index = position\n    if line_number > lines_count or len(newlines_offsets) < (line_number + 1):\n        return None  # `line_number` is out of range\n    line_index = line_number - 1\n    line_length = newlines_offsets[line_index + 1] - newlines_offsets[line_index] - 1\n    # If `column_index` is out of range: let's silently clamp it:\n    column_index = min(line_length, column_index)\n    return newlines_offsets[line_index] + column_index",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "get_style_for_token",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "token_type",
            "type": "TokenType"
          }
        ],
        "return_type": "Style",
        "lineno": 128,
        "decorators": [
          {
            "name": "abstractmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get a style for a given Pygments token.",
        "code": "def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Get a style for a given Pygments token.\"\"\"\n        raise NotImplementedError",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get_background_style",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 133,
        "decorators": [
          {
            "name": "abstractmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get the background color.",
        "code": "def get_background_style(self) -> Style:\n        \"\"\"Get the background color.\"\"\"\n        raise NotImplementedError",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "theme",
            "type": "Union[str, Type[PygmentsStyle]]"
          }
        ],
        "return_type": "None",
        "lineno": 141,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "str",
          "self._background_color",
          "get_style_by_name",
          "theme",
          "self._pygments_style_class.background_color",
          "Style"
        ],
        "docstring": null,
        "code": "def __init__(self, theme: Union[str, Type[PygmentsStyle]]) -> None:\n        self._style_cache: Dict[TokenType, Style] = {}\n        if isinstance(theme, str):\n            try:\n                self._pygments_style_class = get_style_by_name(theme)\n            except ClassNotFound:\n                self._pygments_style_class = get_style_by_name(\"default\")\n        else:\n            self._pygments_style_class = theme\n\n        self._background_color = self._pygments_style_class.background_color\n        self._background_style = Style(bgcolor=self._background_color)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "get_style_for_token",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "token_type",
            "type": "TokenType"
          }
        ],
        "return_type": "Style",
        "lineno": 154,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "token_type",
          "self._pygments_style_class.style_for_token",
          "Style.null",
          "Style"
        ],
        "docstring": "Get a style from a Pygments class.",
        "code": "def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Get a style from a Pygments class.\"\"\"\n        try:\n            return self._style_cache[token_type]\n        except KeyError:\n            try:\n                pygments_style = self._pygments_style_class.style_for_token(token_type)\n            except KeyError:\n                style = Style.null()\n            else:\n                color = pygments_style[\"color\"]\n                bgcolor = pygments_style[\"bgcolor\"]\n                style = Style(\n                    color=\"#\" + color if color else \"#000000\",\n                    bgcolor=\"#\" + bgcolor if bgcolor else self._background_color,\n                    bold=pygments_style[\"bold\"],\n                    italic=pygments_style[\"italic\"],\n                    underline=pygments_style[\"underline\"],\n                )\n            self._style_cache[token_type] = style\n        return style",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "get_background_style",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 176,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_background_style(self) -> Style:\n        return self._background_style",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "style_map",
            "type": "Dict[TokenType, Style]"
          }
        ],
        "return_type": "None",
        "lineno": 183,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style_map",
          "Style.null"
        ],
        "docstring": null,
        "code": "def __init__(self, style_map: Dict[TokenType, Style]) -> None:\n        self.style_map = style_map\n        self._missing_style = Style.null()\n        self._background_style = Style.null()\n        self._style_cache: Dict[TokenType, Style] = {}",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "get_style_for_token",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "token_type",
            "type": "TokenType"
          }
        ],
        "return_type": "Style",
        "lineno": 189,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_style",
          "token",
          "style",
          "token_type",
          "tuple",
          "self.style_map.get",
          "self._missing_style",
          "get_style"
        ],
        "docstring": "Look up style in the style map.",
        "code": "def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Look up style in the style map.\"\"\"\n        try:\n            return self._style_cache[token_type]\n        except KeyError:\n            # Styles form a hierarchy\n            # We need to go from most to least specific\n            # e.g. (\"foo\", \"bar\", \"baz\") to (\"foo\", \"bar\")  to (\"foo\",)\n            get_style = self.style_map.get\n            token = tuple(token_type)\n            style = self._missing_style\n            while token:\n                _style = get_style(token)\n                if _style is not None:\n                    style = _style\n                    break\n                token = token[:-1]\n            self._style_cache[token_type] = style\n            return style",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "get_background_style",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 209,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def get_background_style(self) -> Style:\n        return self._background_style",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__get__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "Syntax"
          },
          {
            "name": "objtype",
            "type": "Type[Syntax]"
          }
        ],
        "return_type": "Tuple[int, int, int, int]",
        "lineno": 232,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Space around the Syntax.",
        "code": "def __get__(self, obj: Syntax, objtype: Type[Syntax]) -> Tuple[int, int, int, int]:\n        \"\"\"Space around the Syntax.\"\"\"\n        return obj._padding",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__set__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "obj",
            "type": "Syntax"
          },
          {
            "name": "padding",
            "type": "PaddingDimensions"
          }
        ],
        "return_type": "None",
        "lineno": 236,
        "decorators": [],
        "is_async": false,
        "calls": [
          "padding",
          "Padding.unpack"
        ],
        "docstring": null,
        "code": "def __set__(self, obj: Syntax, padding: PaddingDimensions) -> None:\n        obj._padding = Padding.unpack(padding)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "get_theme",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "name",
            "type": "Union[str, SyntaxTheme]"
          }
        ],
        "return_type": "SyntaxTheme",
        "lineno": 265,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "isinstance",
          "name",
          "SyntaxTheme",
          "ANSISyntaxTheme",
          "PygmentsSyntaxTheme"
        ],
        "docstring": "Get a syntax theme instance.",
        "code": "def get_theme(cls, name: Union[str, SyntaxTheme]) -> SyntaxTheme:\n        \"\"\"Get a syntax theme instance.\"\"\"\n        if isinstance(name, SyntaxTheme):\n            return name\n        theme: SyntaxTheme\n        if name in RICH_SYNTAX_THEMES:\n            theme = ANSISyntaxTheme(RICH_SYNTAX_THEMES[name])\n        else:\n            theme = PygmentsSyntaxTheme(name)\n        return theme",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "code",
            "type": "str"
          },
          {
            "name": "lexer",
            "type": "Union[Lexer, str]"
          }
        ],
        "return_type": "None",
        "lineno": 276,
        "decorators": [],
        "is_async": false,
        "calls": [
          "word_wrap",
          "Padding.unpack",
          "padding",
          "tab_size",
          "line_range",
          "lexer",
          "set",
          "start_line",
          "background_color",
          "indent_guides",
          "line_numbers",
          "self.get_theme",
          "theme",
          "code",
          "code_width",
          "dedent",
          "Style"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        code: str,\n        lexer: Union[Lexer, str],\n        *,\n        theme: Union[str, SyntaxTheme] = DEFAULT_THEME,\n        dedent: bool = False,\n        line_numbers: bool = False,\n        start_line: int = 1,\n        line_range: Optional[Tuple[Optional[int], Optional[int]]] = None,\n        highlight_lines: Optional[Set[int]] = None,\n        code_width: Optional[int] = None,\n        tab_size: int = 4,\n        word_wrap: bool = False,\n        background_color: Optional[str] = None,\n        indent_guides: bool = False,\n        padding: PaddingDimensions = 0,\n    ) -> None:\n        self.code = code\n        self._lexer = lexer\n        self.dedent = dedent\n        self.line_numbers = line_numbers\n        self.start_line = start_line\n        self.line_range = line_range\n        self.highlight_lines = highlight_lines or set()\n        self.code_width = code_width\n        self.tab_size = tab_size\n        self.word_wrap = word_wrap\n        self.background_color = background_color\n        self.background_style = (\n            Style(bgcolor=background_color) if background_color else Style()\n        )\n        self.indent_guides = indent_guides\n        self._padding = Padding.unpack(padding)\n\n        self._theme = self.get_theme(theme)\n        self._stylized_ranges: List[_SyntaxHighlightRange] = []",
        "line_count": 37,
        "needs_llm_summary": true
      },
      {
        "name": "from_path",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "path",
            "type": "str"
          },
          {
            "name": "encoding",
            "type": "str"
          },
          {
            "name": "lexer",
            "type": "Optional[Union[Lexer, str]]"
          },
          {
            "name": "theme",
            "type": "Union[str, SyntaxTheme]"
          },
          {
            "name": "dedent",
            "type": "bool"
          },
          {
            "name": "line_numbers",
            "type": "bool"
          },
          {
            "name": "line_range",
            "type": "Optional[Tuple[int, int]]"
          },
          {
            "name": "start_line",
            "type": "int"
          },
          {
            "name": "highlight_lines",
            "type": "Optional[Set[int]]"
          },
          {
            "name": "code_width",
            "type": "Optional[int]"
          },
          {
            "name": "tab_size",
            "type": "int"
          },
          {
            "name": "word_wrap",
            "type": "bool"
          },
          {
            "name": "background_color",
            "type": "Optional[str]"
          },
          {
            "name": "indent_guides",
            "type": "bool"
          },
          {
            "name": "padding",
            "type": "PaddingDimensions"
          }
        ],
        "return_type": "Syntax",
        "lineno": 317,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "cls.guess_lexer",
          "lexer",
          "background_color",
          "encoding",
          "word_wrap",
          "tab_size",
          "line_range",
          "line_numbers",
          "code",
          "highlight_lines",
          "dedent",
          "Path",
          "padding",
          "indent_guides",
          "cls",
          "unknown.read_text",
          "start_line",
          "theme",
          "path",
          "code_width"
        ],
        "docstring": "Construct a Syntax object from a file.\n\nArgs:\n    path (str): Path to file to highlight.\n    encoding (str): Encoding of file.\n    lexer (str | Lexer, optional): Lexer to use. If None, lexer will be auto-detected from path/file content.\n    theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to \"emacs\".\n    dedent (bool, optional): Enable stripping of initial whitespace. Defaults to True.\n    line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.\n    start_line (int, optional): Starting number for line numbers. Defaults to 1.\n    line_range (Tuple[int, int], optional): If given should be a tuple of the start and end line to render.\n    highlight_lines (Set[int]): A set of line numbers to highlight.\n    code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.\n    tab_size (int, optional): Size of tabs. Defaults to 4.\n    word_wrap (bool, optional): Enable word wrapping of code.\n    background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.\n    indent_guides (bool, optional): Show indent guides. Defaults to False.\n    padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).\n\nReturns:\n    [Syntax]: A Syntax object that may be printed to the console",
        "code": "def from_path(\n        cls,\n        path: str,\n        encoding: str = \"utf-8\",\n        lexer: Optional[Union[Lexer, str]] = None,\n        theme: Union[str, SyntaxTheme] = DEFAULT_THEME,\n        dedent: bool = False,\n        line_numbers: bool = False,\n        line_range: Optional[Tuple[int, int]] = None,\n        start_line: int = 1,\n        highlight_lines: Optional[Set[int]] = None,\n        code_width: Optional[int] = None,\n        tab_size: int = 4,\n        word_wrap: bool = False,\n        background_color: Optional[str] = None,\n        indent_guides: bool = False,\n        padding: PaddingDimensions = 0,\n    ) -> \"Syntax\":\n        \"\"\"Construct a Syntax object from a file.\n\n        Args:\n            path (str): Path to file to highlight.\n            encoding (str): Encoding of file.\n            lexer (str | Lexer, optional): Lexer to use. If None, lexer will be auto-detected from path/file content.\n            theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to \"emacs\".\n            dedent (bool, optional): Enable stripping of initial whitespace. Defaults to True.\n            line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.\n            start_line (int, optional): Starting number for line numbers. Defaults to 1.\n            line_range (Tuple[int, int], optional): If given should be a tuple of the start and end line to render.\n            highlight_lines (Set[int]): A set of line numbers to highlight.\n            code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.\n            tab_size (int, optional): Size of tabs. Defaults to 4.\n            word_wrap (bool, optional): Enable word wrapping of code.\n            background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.\n            indent_guides (bool, optional): Show indent guides. Defaults to False.\n            padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).\n\n        Returns:\n            [Syntax]: A Syntax object that may be printed to the console\n        \"\"\"\n        code = Path(path).read_text(encoding=encoding)\n\n        if not lexer:\n            lexer = cls.guess_lexer(path, code=code)\n\n        return cls(\n            code,\n            lexer,\n            theme=theme,\n            dedent=dedent,\n            line_numbers=line_numbers,\n            line_range=line_range,\n            start_line=start_line,\n            highlight_lines=highlight_lines,\n            code_width=code_width,\n            tab_size=tab_size,\n            word_wrap=word_wrap,\n            background_color=background_color,\n            indent_guides=indent_guides,\n            padding=padding,\n        )",
        "line_count": 61,
        "needs_llm_summary": true
      },
      {
        "name": "guess_lexer",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "path",
            "type": "str"
          },
          {
            "name": "code",
            "type": "Optional[str]"
          }
        ],
        "return_type": "str",
        "lineno": 380,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "guess_lexer_for_filename",
          "get_lexer_by_name",
          "lexer.name",
          "unknown.lower",
          "path",
          "os.path.splitext",
          "extension",
          "code",
          "ext.lstrip"
        ],
        "docstring": "Guess the alias of the Pygments lexer to use based on a path and an optional string of code.\nIf code is supplied, it will use a combination of the code and the filename to determine the\nbest lexer to use. For example, if the file is ``index.html`` and the file contains Django\ntemplating syntax, then \"html+django\" will be returned. If the file is ``index.html``, and no\ntemplating language is used, the \"html\" lexer will be used. If no string of code\nis supplied, the lexer will be chosen based on the file extension..\n\nArgs:\n    path (AnyStr): The path to the file containing the code you wish to know the lexer for.\n    code (str, optional): Optional string of code that will be used as a fallback if no lexer\n        is found for the supplied path.\n\nReturns:\n    str: The name of the Pygments lexer that best matches the supplied path/code.",
        "code": "def guess_lexer(cls, path: str, code: Optional[str] = None) -> str:\n        \"\"\"Guess the alias of the Pygments lexer to use based on a path and an optional string of code.\n        If code is supplied, it will use a combination of the code and the filename to determine the\n        best lexer to use. For example, if the file is ``index.html`` and the file contains Django\n        templating syntax, then \"html+django\" will be returned. If the file is ``index.html``, and no\n        templating language is used, the \"html\" lexer will be used. If no string of code\n        is supplied, the lexer will be chosen based on the file extension..\n\n        Args:\n            path (AnyStr): The path to the file containing the code you wish to know the lexer for.\n            code (str, optional): Optional string of code that will be used as a fallback if no lexer\n                is found for the supplied path.\n\n        Returns:\n            str: The name of the Pygments lexer that best matches the supplied path/code.\n        \"\"\"\n        lexer: Optional[Lexer] = None\n        lexer_name = \"default\"\n        if code:\n            try:\n                lexer = guess_lexer_for_filename(path, code)\n            except ClassNotFound:\n                pass\n\n        if not lexer:\n            try:\n                _, ext = os.path.splitext(path)\n                if ext:\n                    extension = ext.lstrip(\".\").lower()\n                    lexer = get_lexer_by_name(extension)\n            except ClassNotFound:\n                pass\n\n        if lexer:\n            if lexer.aliases:\n                lexer_name = lexer.aliases[0]\n            else:\n                lexer_name = lexer.name\n\n        return lexer_name",
        "line_count": 40,
        "needs_llm_summary": true
      },
      {
        "name": "_get_base_style",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Style",
        "lineno": 421,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._theme.get_background_style"
        ],
        "docstring": "Get the base style.",
        "code": "def _get_base_style(self) -> Style:\n        \"\"\"Get the base style.\"\"\"\n        default_style = self._theme.get_background_style() + self.background_style\n        return default_style",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "_get_token_color",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "token_type",
            "type": "TokenType"
          }
        ],
        "return_type": "Optional[Color]",
        "lineno": 426,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._theme.get_style_for_token",
          "token_type"
        ],
        "docstring": "Get a color (if any) for the given token.\n\nArgs:\n    token_type (TokenType): A token type tuple from Pygments.\n\nReturns:\n    Optional[Color]: Color from theme, or None for no color.",
        "code": "def _get_token_color(self, token_type: TokenType) -> Optional[Color]:\n        \"\"\"Get a color (if any) for the given token.\n\n        Args:\n            token_type (TokenType): A token type tuple from Pygments.\n\n        Returns:\n            Optional[Color]: Color from theme, or None for no color.\n        \"\"\"\n        style = self._theme.get_style_for_token(token_type)\n        return style.color",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "lexer",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Optional[Lexer]",
        "lineno": 439,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "isinstance",
          "self._lexer",
          "get_lexer_by_name",
          "self.tab_size",
          "Lexer"
        ],
        "docstring": "The lexer for this syntax, or None if no lexer was found.\n\nTries to find the lexer by name if a string was passed to the constructor.",
        "code": "def lexer(self) -> Optional[Lexer]:\n        \"\"\"The lexer for this syntax, or None if no lexer was found.\n\n        Tries to find the lexer by name if a string was passed to the constructor.\n        \"\"\"\n\n        if isinstance(self._lexer, Lexer):\n            return self._lexer\n        try:\n            return get_lexer_by_name(\n                self._lexer,\n                stripnl=False,\n                ensurenl=True,\n                tabsize=self.tab_size,\n            )\n        except ClassNotFound:\n            return None",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "default_lexer",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Lexer",
        "lineno": 458,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.tab_size",
          "get_lexer_by_name"
        ],
        "docstring": "A Pygments Lexer to use if one is not specified or invalid.",
        "code": "def default_lexer(self) -> Lexer:\n        \"\"\"A Pygments Lexer to use if one is not specified or invalid.\"\"\"\n        return get_lexer_by_name(\n            \"text\",\n            stripnl=False,\n            ensurenl=True,\n            tabsize=self.tab_size,\n        )",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "highlight",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "code",
            "type": "str"
          },
          {
            "name": "line_range",
            "type": "Optional[Tuple[Optional[int], Optional[int]]]"
          }
        ],
        "return_type": "Text",
        "lineno": 467,
        "decorators": [],
        "is_async": false,
        "calls": [
          "next",
          "text.append_tokens",
          "text.stylize",
          "tokens_to_spans",
          "line_range",
          "self.tab_size",
          "_get_theme_style",
          "code",
          "self._theme.get_style_for_token",
          "Text",
          "token.partition",
          "self._apply_stylized_ranges",
          "justify",
          "base_style",
          "text",
          "self._get_base_style",
          "tokens",
          "line_tokenize",
          "lexer.get_tokens",
          "text.append",
          "token.endswith",
          "token_type",
          "iter"
        ],
        "docstring": "Highlight code and return a Text instance.\n\nArgs:\n    code (str): Code to highlight.\n    line_range(Tuple[int, int], optional): Optional line range to highlight.\n\nReturns:\n    Text: A text instance containing highlighted syntax.",
        "code": "def highlight(\n        self,\n        code: str,\n        line_range: Optional[Tuple[Optional[int], Optional[int]]] = None,\n    ) -> Text:\n        \"\"\"Highlight code and return a Text instance.\n\n        Args:\n            code (str): Code to highlight.\n            line_range(Tuple[int, int], optional): Optional line range to highlight.\n\n        Returns:\n            Text: A text instance containing highlighted syntax.\n        \"\"\"\n\n        base_style = self._get_base_style()\n        justify: JustifyMethod = (\n            \"default\" if base_style.transparent_background else \"left\"\n        )\n\n        text = Text(\n            justify=justify,\n            style=base_style,\n            tab_size=self.tab_size,\n            no_wrap=not self.word_wrap,\n        )\n        _get_theme_style = self._theme.get_style_for_token\n\n        lexer = self.lexer or self.default_lexer\n\n        if lexer is None:\n            text.append(code)\n        else:\n            if line_range:\n                # More complicated path to only stylize a portion of the code\n                # This speeds up further operations as there are less spans to process\n                line_start, line_end = line_range\n\n                def line_tokenize() -> Iterable[Tuple[Any, str]]:\n                    \"\"\"Split tokens to one per line.\"\"\"\n                    assert lexer  # required to make MyPy happy - we know lexer is not None at this point\n\n                    for token_type, token in lexer.get_tokens(code):\n                        while token:\n                            line_token, new_line, token = token.partition(\"\\n\")\n                            yield token_type, line_token + new_line\n\n                def tokens_to_spans() -> Iterable[Tuple[str, Optional[Style]]]:\n                    \"\"\"Convert tokens to spans.\"\"\"\n                    tokens = iter(line_tokenize())\n                    line_no = 0\n                    _line_start = line_start - 1 if line_start else 0\n\n                    # Skip over tokens until line start\n                    while line_no < _line_start:\n                        try:\n                            _token_type, token = next(tokens)\n                        except StopIteration:\n                            break\n                        yield (token, None)\n                        if token.endswith(\"\\n\"):\n                            line_no += 1\n                    # Generate spans until line end\n                    for token_type, token in tokens:\n                        yield (token, _get_theme_style(token_type))\n                        if token.endswith(\"\\n\"):\n                            line_no += 1\n                            if line_end and line_no >= line_end:\n                                break\n\n                text.append_tokens(tokens_to_spans())\n\n            else:\n                text.append_tokens(\n                    (token, _get_theme_style(token_type))\n                    for token_type, token in lexer.get_tokens(code)\n                )\n            if self.background_color is not None:\n                text.stylize(f\"on {self.background_color}\")\n\n        if self._stylized_ranges:\n            self._apply_stylized_ranges(text)\n\n        return text",
        "line_count": 84,
        "needs_llm_summary": true
      },
      {
        "name": "stylize_range",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "style",
            "type": "StyleType"
          },
          {
            "name": "start",
            "type": "SyntaxPosition"
          },
          {
            "name": "end",
            "type": "SyntaxPosition"
          },
          {
            "name": "style_before",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 552,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_SyntaxHighlightRange",
          "end",
          "style",
          "self._stylized_ranges.append",
          "style_before",
          "start"
        ],
        "docstring": "Adds a custom style on a part of the code, that will be applied to the syntax display when it's rendered.\nLine numbers are 1-based, while column indexes are 0-based.\n\nArgs:\n    style (StyleType): The style to apply.\n    start (Tuple[int, int]): The start of the range, in the form `[line number, column index]`.\n    end (Tuple[int, int]): The end of the range, in the form `[line number, column index]`.\n    style_before (bool): Apply the style before any existing styles.",
        "code": "def stylize_range(\n        self,\n        style: StyleType,\n        start: SyntaxPosition,\n        end: SyntaxPosition,\n        style_before: bool = False,\n    ) -> None:\n        \"\"\"\n        Adds a custom style on a part of the code, that will be applied to the syntax display when it's rendered.\n        Line numbers are 1-based, while column indexes are 0-based.\n\n        Args:\n            style (StyleType): The style to apply.\n            start (Tuple[int, int]): The start of the range, in the form `[line number, column index]`.\n            end (Tuple[int, int]): The end of the range, in the form `[line number, column index]`.\n            style_before (bool): Apply the style before any existing styles.\n        \"\"\"\n        self._stylized_ranges.append(\n            _SyntaxHighlightRange(style, start, end, style_before)\n        )",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "_get_line_numbers_color",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "blend",
            "type": "float"
          }
        ],
        "return_type": "Color",
        "lineno": 573,
        "decorators": [],
        "is_async": false,
        "calls": [
          "background_color.get_truecolor",
          "Token.Text",
          "blend",
          "Color.from_triplet",
          "new_color",
          "self._theme.get_background_style",
          "foreground_color.get_truecolor",
          "Color.default",
          "self._get_token_color",
          "background_style.bgcolor",
          "blend_rgb"
        ],
        "docstring": null,
        "code": "def _get_line_numbers_color(self, blend: float = 0.3) -> Color:\n        background_style = self._theme.get_background_style() + self.background_style\n        background_color = background_style.bgcolor\n        if background_color is None or background_color.is_system_defined:\n            return Color.default()\n        foreground_color = self._get_token_color(Token.Text)\n        if foreground_color is None or foreground_color.is_system_defined:\n            return foreground_color or Color.default()\n        new_color = blend_rgb(\n            background_color.get_truecolor(),\n            foreground_color.get_truecolor(),\n            cross_fade=blend,\n        )\n        return Color.from_triplet(new_color)",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "_numbers_column_width",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 589,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "str",
          "len",
          "self.code.count"
        ],
        "docstring": "Get the number of characters used to render the numbers column.",
        "code": "def _numbers_column_width(self) -> int:\n        \"\"\"Get the number of characters used to render the numbers column.\"\"\"\n        column_width = 0\n        if self.line_numbers:\n            column_width = (\n                len(str(self.start_line + self.code.count(\"\\n\")))\n                + NUMBERS_COLUMN_DEFAULT_PADDING\n            )\n        return column_width",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "_get_number_styles",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          }
        ],
        "return_type": "Tuple[Style, Style, Style]",
        "lineno": 599,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Token.Text",
          "Style.chain",
          "self._get_line_numbers_color",
          "background_style",
          "Style.null",
          "self._theme.get_style_for_token",
          "self._get_base_style",
          "self.background_style",
          "Style"
        ],
        "docstring": "Get background, number, and highlight styles for line numbers.",
        "code": "def _get_number_styles(self, console: Console) -> Tuple[Style, Style, Style]:\n        \"\"\"Get background, number, and highlight styles for line numbers.\"\"\"\n        background_style = self._get_base_style()\n        if background_style.transparent_background:\n            return Style.null(), Style(dim=True), Style.null()\n        if console.color_system in (\"256\", \"truecolor\"):\n            number_style = Style.chain(\n                background_style,\n                self._theme.get_style_for_token(Token.Text),\n                Style(color=self._get_line_numbers_color()),\n                self.background_style,\n            )\n            highlight_number_style = Style.chain(\n                background_style,\n                self._theme.get_style_for_token(Token.Text),\n                Style(bold=True, color=self._get_line_numbers_color(0.9)),\n                self.background_style,\n            )\n        else:\n            number_style = background_style + Style(dim=True)\n            highlight_number_style = background_style + Style(dim=False)\n        return background_style, number_style, highlight_number_style",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 622,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line",
          "self._numbers_column_width",
          "width",
          "Measurement",
          "max",
          "self.padding",
          "self.code.splitlines",
          "cell_len"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        _, right, _, left = self.padding\n        padding = left + right\n        if self.code_width is not None:\n            width = self.code_width + self._numbers_column_width + padding + 1\n            return Measurement(self._numbers_column_width, width)\n        lines = self.code.splitlines()\n        width = (\n            self._numbers_column_width\n            + padding\n            + (max(cell_len(line) for line in lines) if lines else 0)\n        )\n        if self.line_numbers:\n            width += 1\n        return Measurement(self._numbers_column_width, width)",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 640,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Padding",
          "self._get_syntax",
          "options",
          "Segments",
          "segments",
          "any",
          "self.padding",
          "self._get_base_style",
          "console"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        segments = Segments(self._get_syntax(console, options))\n        if any(self.padding):\n            yield Padding(segments, style=self._get_base_style(), pad=self.padding)\n        else:\n            yield segments",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "_get_syntax",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 649,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._process_code",
          "enumerate",
          "lines",
          "console.render_lines",
          "processed_code",
          "style",
          "wrapped_lines",
          "render_options.update",
          "unknown.split",
          "render_options.max_width",
          "console.render",
          "list",
          "loop_first",
          "highlight_number_style",
          "options.update",
          "self.highlight",
          "Style",
          "_Segment.adjust_line_length",
          "text.with_indent_guides",
          "unknown.rjust",
          "highlight_line",
          "line.render",
          "line_pointer",
          "self.tab_size",
          "text.split",
          "unknown.join",
          "max",
          "self._theme.get_style_for_token",
          "text.remove_suffix",
          "_Segment",
          "unknown.transparent_background",
          "Text",
          "self._get_number_styles",
          "str",
          "line",
          "self.highlight_lines.__contains__",
          "line_no",
          "self._numbers_column_width",
          "text",
          "self.line_range",
          "Segment",
          "self.padding",
          "console",
          "self._get_base_style",
          "self.background_style",
          "len",
          "self.code",
          "unknown.with_indent_guides",
          "line_column",
          "number_style",
          "background_style",
          "segments",
          "Comment",
          "ends_on_nl",
          "code_width"
        ],
        "docstring": "Get the Segments for the Syntax object, excluding any vertical/horizontal padding",
        "code": "def _get_syntax(\n        self,\n        console: Console,\n        options: ConsoleOptions,\n    ) -> Iterable[Segment]:\n        \"\"\"\n        Get the Segments for the Syntax object, excluding any vertical/horizontal padding\n        \"\"\"\n        transparent_background = self._get_base_style().transparent_background\n        _pad_top, pad_right, _pad_bottom, pad_left = self.padding\n        horizontal_padding = pad_left + pad_right\n        code_width = (\n            (\n                (options.max_width - self._numbers_column_width - 1)\n                if self.line_numbers\n                else options.max_width\n            )\n            - horizontal_padding\n            if self.code_width is None\n            else self.code_width\n        )\n        code_width = max(0, code_width)\n\n        ends_on_nl, processed_code = self._process_code(self.code)\n        text = self.highlight(processed_code, self.line_range)\n\n        if not self.line_numbers and not self.word_wrap and not self.line_range:\n            if not ends_on_nl:\n                text.remove_suffix(\"\\n\")\n            # Simple case of just rendering text\n            style = (\n                self._get_base_style()\n                + self._theme.get_style_for_token(Comment)\n                + Style(dim=True)\n                + self.background_style\n            )\n            if self.indent_guides and not options.ascii_only:\n                text = text.with_indent_guides(self.tab_size, style=style)\n                text.overflow = \"crop\"\n            if style.transparent_background:\n                yield from console.render(\n                    text, options=options.update(width=code_width)\n                )\n            else:\n                syntax_lines = console.render_lines(\n                    text,\n                    options.update(width=code_width, height=None, justify=\"left\"),\n                    style=self.background_style,\n                    pad=True,\n                    new_lines=True,\n                )\n                for syntax_line in syntax_lines:\n                    yield from syntax_line\n            return\n\n        start_line, end_line = self.line_range or (None, None)\n        line_offset = 0\n        if start_line:\n            line_offset = max(0, start_line - 1)\n        lines: Union[List[Text], Lines] = text.split(\"\\n\", allow_blank=ends_on_nl)\n        if self.line_range:\n            if line_offset > len(lines):\n                return\n            lines = lines[line_offset:end_line]\n\n        if self.indent_guides and not options.ascii_only:\n            style = (\n                self._get_base_style()\n                + self._theme.get_style_for_token(Comment)\n                + Style(dim=True)\n                + self.background_style\n            )\n            lines = (\n                Text(\"\\n\")\n                .join(lines)\n                .with_indent_guides(self.tab_size, style=style + Style(italic=False))\n                .split(\"\\n\", allow_blank=True)\n            )\n\n        numbers_column_width = self._numbers_column_width\n        render_options = options.update(width=code_width)\n\n        highlight_line = self.highlight_lines.__contains__\n        _Segment = Segment\n        new_line = _Segment(\"\\n\")\n\n        line_pointer = \"> \" if options.legacy_windows else \"\u2771 \"\n\n        (\n            background_style,\n            number_style,\n            highlight_number_style,\n        ) = self._get_number_styles(console)\n\n        for line_no, line in enumerate(lines, self.start_line + line_offset):\n            if self.word_wrap:\n                wrapped_lines = console.render_lines(\n                    line,\n                    render_options.update(height=None, justify=\"left\"),\n                    style=background_style,\n                    pad=not transparent_background,\n                )\n            else:\n                segments = list(line.render(console, end=\"\"))\n                if options.no_wrap:\n                    wrapped_lines = [segments]\n                else:\n                    wrapped_lines = [\n                        _Segment.adjust_line_length(\n                            segments,\n                            render_options.max_width,\n                            style=background_style,\n                            pad=not transparent_background,\n                        )\n                    ]\n\n            if self.line_numbers:\n                wrapped_line_left_pad = _Segment(\n                    \" \" * numbers_column_width + \" \", background_style\n                )\n                for first, wrapped_line in loop_first(wrapped_lines):\n                    if first:\n                        line_column = str(line_no).rjust(numbers_column_width - 2) + \" \"\n                        if highlight_line(line_no):\n                            yield _Segment(line_pointer, Style(color=\"red\"))\n                            yield _Segment(line_column, highlight_number_style)\n                        else:\n                            yield _Segment(\"  \", highlight_number_style)\n                            yield _Segment(line_column, number_style)\n                    else:\n                        yield wrapped_line_left_pad\n                    yield from wrapped_line\n                    yield new_line\n            else:\n                for wrapped_line in wrapped_lines:\n                    yield from wrapped_line\n                    yield new_line",
        "line_count": 137,
        "needs_llm_summary": true
      },
      {
        "name": "_apply_stylized_ranges",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Text"
          }
        ],
        "return_type": "None",
        "lineno": 787,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text.stylize",
          "re.finditer",
          "end",
          "re.MULTILINE",
          "_get_code_index_for_syntax_position",
          "stylized_range.start",
          "text.stylize_before",
          "newlines_offsets",
          "stylized_range.end",
          "code",
          "stylized_range.style",
          "start",
          "match.start",
          "text.plain",
          "len"
        ],
        "docstring": "Apply stylized ranges to a text instance,\nusing the given code to determine the right portion to apply the style to.\n\nArgs:\n    text (Text): Text instance to apply the style to.",
        "code": "def _apply_stylized_ranges(self, text: Text) -> None:\n        \"\"\"\n        Apply stylized ranges to a text instance,\n        using the given code to determine the right portion to apply the style to.\n\n        Args:\n            text (Text): Text instance to apply the style to.\n        \"\"\"\n        code = text.plain\n        newlines_offsets = [\n            # Let's add outer boundaries at each side of the list:\n            0,\n            # N.B. using \"\\n\" here is much faster than using metacharacters such as \"^\" or \"\\Z\":\n            *[\n                match.start() + 1\n                for match in re.finditer(\"\\n\", code, flags=re.MULTILINE)\n            ],\n            len(code) + 1,\n        ]\n\n        for stylized_range in self._stylized_ranges:\n            start = _get_code_index_for_syntax_position(\n                newlines_offsets, stylized_range.start\n            )\n            end = _get_code_index_for_syntax_position(\n                newlines_offsets, stylized_range.end\n            )\n            if start is not None and end is not None:\n                if stylized_range.style_before:\n                    text.stylize_before(stylized_range.style, start, end)\n                else:\n                    text.stylize(stylized_range.style, start, end)",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "_process_code",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "code",
            "type": "str"
          }
        ],
        "return_type": "Tuple[bool, str]",
        "lineno": 820,
        "decorators": [],
        "is_async": false,
        "calls": [
          "textwrap.dedent",
          "processed_code",
          "self.tab_size",
          "code.endswith",
          "processed_code.expandtabs"
        ],
        "docstring": "Applies various processing to a raw code string\n(normalises it so it always ends with a line return, dedents it if necessary, etc.)\n\nArgs:\n    code (str): The raw code string to process\n\nReturns:\n    Tuple[bool, str]: the boolean indicates whether the raw code ends with a line return,\n        while the string is the processed code.",
        "code": "def _process_code(self, code: str) -> Tuple[bool, str]:\n        \"\"\"\n        Applies various processing to a raw code string\n        (normalises it so it always ends with a line return, dedents it if necessary, etc.)\n\n        Args:\n            code (str): The raw code string to process\n\n        Returns:\n            Tuple[bool, str]: the boolean indicates whether the raw code ends with a line return,\n                while the string is the processed code.\n        \"\"\"\n        ends_on_nl = code.endswith(\"\\n\")\n        processed_code = code if ends_on_nl else code + \"\\n\"\n        processed_code = (\n            textwrap.dedent(processed_code) if self.dedent else processed_code\n        )\n        processed_code = processed_code.expandtabs(self.tab_size)\n        return ends_on_nl, processed_code",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "line_tokenize",
        "args": [],
        "return_type": "Iterable[Tuple[Any, str]]",
        "lineno": 505,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lexer.get_tokens",
          "code",
          "token.partition"
        ],
        "docstring": "Split tokens to one per line.",
        "code": "def line_tokenize() -> Iterable[Tuple[Any, str]]:\n                    \"\"\"Split tokens to one per line.\"\"\"\n                    assert lexer  # required to make MyPy happy - we know lexer is not None at this point\n\n                    for token_type, token in lexer.get_tokens(code):\n                        while token:\n                            line_token, new_line, token = token.partition(\"\\n\")\n                            yield token_type, line_token + new_line",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "tokens_to_spans",
        "args": [],
        "return_type": "Iterable[Tuple[str, Optional[Style]]]",
        "lineno": 514,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line_tokenize",
          "token.endswith",
          "next",
          "token_type",
          "iter",
          "_get_theme_style",
          "tokens"
        ],
        "docstring": "Convert tokens to spans.",
        "code": "def tokens_to_spans() -> Iterable[Tuple[str, Optional[Style]]]:\n                    \"\"\"Convert tokens to spans.\"\"\"\n                    tokens = iter(line_tokenize())\n                    line_no = 0\n                    _line_start = line_start - 1 if line_start else 0\n\n                    # Skip over tokens until line start\n                    while line_no < _line_start:\n                        try:\n                            _token_type, token = next(tokens)\n                        except StopIteration:\n                            break\n                        yield (token, None)\n                        if token.endswith(\"\\n\"):\n                            line_no += 1\n                    # Generate spans until line end\n                    for token_type, token in tokens:\n                        yield (token, _get_theme_style(token_type))\n                        if token.endswith(\"\\n\"):\n                            line_no += 1\n                            if line_end and line_no >= line_end:\n                                break",
        "line_count": 22,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "SyntaxTheme",
        "methods": [
          "get_style_for_token",
          "get_background_style"
        ],
        "base_classes": [
          "ABC"
        ],
        "lineno": 124,
        "docstring": "Base class for a syntax theme."
      },
      {
        "name": "PygmentsSyntaxTheme",
        "methods": [
          "__init__",
          "get_style_for_token",
          "get_background_style"
        ],
        "base_classes": [
          "SyntaxTheme"
        ],
        "lineno": 138,
        "docstring": "Syntax theme that delegates to Pygments theme."
      },
      {
        "name": "ANSISyntaxTheme",
        "methods": [
          "__init__",
          "get_style_for_token",
          "get_background_style"
        ],
        "base_classes": [
          "SyntaxTheme"
        ],
        "lineno": 180,
        "docstring": "Syntax theme to use standard colors."
      },
      {
        "name": "_SyntaxHighlightRange",
        "methods": [],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 216,
        "docstring": "A range to highlight in a Syntax object.\n`start` and `end` are 2-integers tuples, where the first integer is the line number\n(starting from 1) and the second integer is the column index (starting from 0)."
      },
      {
        "name": "PaddingProperty",
        "methods": [
          "__get__",
          "__set__"
        ],
        "base_classes": [],
        "lineno": 229,
        "docstring": "Descriptor to get and set padding."
      },
      {
        "name": "Syntax",
        "methods": [
          "get_theme",
          "__init__",
          "from_path",
          "guess_lexer",
          "_get_base_style",
          "_get_token_color",
          "lexer",
          "default_lexer",
          "highlight",
          "stylize_range",
          "_get_line_numbers_color",
          "_numbers_column_width",
          "_get_number_styles",
          "__rich_measure__",
          "__rich_console__",
          "_get_syntax",
          "_apply_stylized_ranges",
          "_process_code"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 240,
        "docstring": "Construct a Syntax object to render syntax highlighted code.\n\nArgs:\n    code (str): Code to highlight.\n    lexer (Lexer | str): Lexer to use (see https://pygments.org/docs/lexers/)\n    theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to \"monokai\".\n    dedent (bool, optional): Enable stripping of initial whitespace. Defaults to False.\n    line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.\n    start_line (int, optional): Starting number for line numbers. Defaults to 1.\n    line_range (Tuple[int | None, int | None], optional): If given should be a tuple of the start and end line to render.\n        A value of None in the tuple indicates the range is open in that direction.\n    highlight_lines (Set[int]): A set of line numbers to highlight.\n    code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.\n    tab_size (int, optional): Size of tabs. Defaults to 4.\n    word_wrap (bool, optional): Enable word wrapping.\n    background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.\n    indent_guides (bool, optional): Show indent guides. Defaults to False.\n    padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding)."
      }
    ],
    "imports": [
      {
        "module": "__future__",
        "name": "annotations",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "os.path",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "re",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 5,
        "type": "import"
      },
      {
        "module": "textwrap",
        "alias": null,
        "lineno": 6,
        "type": "import"
      },
      {
        "module": "abc",
        "name": "ABC",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "abc",
        "name": "abstractmethod",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "pathlib",
        "name": "Path",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Set",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "pygments.lexer",
        "name": "Lexer",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "pygments.lexers",
        "name": "get_lexer_by_name",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "pygments.lexers",
        "name": "guess_lexer_for_filename",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "pygments.style",
        "name": "Style",
        "alias": "PygmentsStyle",
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "pygments.styles",
        "name": "get_style_by_name",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Comment",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Error",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Generic",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Keyword",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Name",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Number",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Operator",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "String",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Token",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Whitespace",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "pygments.util",
        "name": "ClassNotFound",
        "alias": null,
        "lineno": 39,
        "type": "from_import"
      },
      {
        "module": "rich.containers",
        "name": "Lines",
        "alias": null,
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "rich.padding",
        "name": "Padding",
        "alias": null,
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "rich.padding",
        "name": "PaddingDimensions",
        "alias": null,
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_first",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "Color",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "color",
        "name": "blend_rgb",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "JustifyMethod",
        "alias": null,
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 48,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 49,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segments",
        "alias": null,
        "lineno": 50,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 51,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 51,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 52,
        "type": "from_import"
      },
      {
        "module": "argparse",
        "alias": null,
        "lineno": 869,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 870,
        "type": "import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 956,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "TokenType",
        "assigned_to": null,
        "lineno": 54
      },
      {
        "name": "WINDOWS",
        "assigned_to": null,
        "lineno": 56
      },
      {
        "name": "DEFAULT_THEME",
        "assigned_to": "str",
        "lineno": 57
      },
      {
        "name": "RICH_SYNTAX_THEMES",
        "assigned_to": null,
        "lineno": 120
      },
      {
        "name": "NUMBERS_COLUMN_DEFAULT_PADDING",
        "assigned_to": "int",
        "lineno": 121
      },
      {
        "name": "SyntaxPosition",
        "assigned_to": null,
        "lineno": 213
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "argparse.ArgumentParser",
      "sys.stdin.read",
      "Console",
      "parser.parse_args",
      "Syntax.from_path",
      "Syntax",
      "parser.add_argument"
    ],
    "module_level_calls": {
      "function_calls": [
        "args.theme",
        "argparse.ArgumentParser",
        "args.width",
        "args.force_color",
        "args.line_numbers",
        "args.word_wrap",
        "args.indent_guides",
        "Style",
        "parser.add_argument",
        "args.background_color",
        "Syntax.from_path",
        "code",
        "Syntax",
        "int",
        "sys.stdin.read",
        "args.padding",
        "Console",
        "args.lexer_name",
        "parser.parse_args",
        "console.print",
        "syntax",
        "args.path",
        "args.soft_wrap"
      ],
      "class_instantiations": [
        "Style",
        "Console",
        "Syntax"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "abc",
        "typing",
        "pathlib",
        "re",
        "os",
        "sys",
        "argparse"
      ],
      "third_party": {
        "other": [
          "__future__",
          "textwrap",
          "pygments",
          "rich",
          "_loop",
          "cells",
          "color",
          "console",
          "jupyter",
          "measure",
          "segment",
          "style",
          "text"
        ]
      },
      "tech_stack": []
    },
    "line_count": 986
  },
  "rich/table.py": {
    "filepath": "../rich/rich/table.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "copy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Column",
        "lineno": 117,
        "decorators": [],
        "is_async": false,
        "calls": [
          "replace",
          "self"
        ],
        "docstring": "Return a copy of this Column.",
        "code": "def copy(self) -> \"Column\":\n        \"\"\"Return a copy of this Column.\"\"\"\n        return replace(self, _cells=[])",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "cells",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Iterable[RenderableType]",
        "lineno": 122,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get all cells in the column, not including header.",
        "code": "def cells(self) -> Iterable[\"RenderableType\"]:\n        \"\"\"Get all cells in the column, not including header.\"\"\"\n        yield from self._cells",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "flexible",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 127,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Check if this column is flexible.",
        "code": "def flexible(self) -> bool:\n        \"\"\"Check if this column is flexible.\"\"\"\n        return self.ratio is not None",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 189,
        "decorators": [],
        "is_async": false,
        "calls": [
          "caption",
          "append_column",
          "style",
          "highlight",
          "list",
          "pad_edge",
          "self.columns",
          "show_edge",
          "Padding.unpack",
          "caption_style",
          "expand",
          "title_style",
          "leading",
          "self.add_column",
          "title",
          "show_header",
          "show_lines",
          "padding",
          "safe_box",
          "str",
          "width",
          "border_style",
          "min_width",
          "header",
          "len",
          "isinstance",
          "box",
          "collapse_padding",
          "self.columns.append",
          "show_footer"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        *headers: Union[Column, str],\n        title: Optional[TextType] = None,\n        caption: Optional[TextType] = None,\n        width: Optional[int] = None,\n        min_width: Optional[int] = None,\n        box: Optional[box.Box] = box.HEAVY_HEAD,\n        safe_box: Optional[bool] = None,\n        padding: PaddingDimensions = (0, 1),\n        collapse_padding: bool = False,\n        pad_edge: bool = True,\n        expand: bool = False,\n        show_header: bool = True,\n        show_footer: bool = False,\n        show_edge: bool = True,\n        show_lines: bool = False,\n        leading: int = 0,\n        style: StyleType = \"none\",\n        row_styles: Optional[Iterable[StyleType]] = None,\n        header_style: Optional[StyleType] = \"table.header\",\n        footer_style: Optional[StyleType] = \"table.footer\",\n        border_style: Optional[StyleType] = None,\n        title_style: Optional[StyleType] = None,\n        caption_style: Optional[StyleType] = None,\n        title_justify: \"JustifyMethod\" = \"center\",\n        caption_justify: \"JustifyMethod\" = \"center\",\n        highlight: bool = False,\n    ) -> None:\n        self.columns: List[Column] = []\n        self.rows: List[Row] = []\n        self.title = title\n        self.caption = caption\n        self.width = width\n        self.min_width = min_width\n        self.box = box\n        self.safe_box = safe_box\n        self._padding = Padding.unpack(padding)\n        self.pad_edge = pad_edge\n        self._expand = expand\n        self.show_header = show_header\n        self.show_footer = show_footer\n        self.show_edge = show_edge\n        self.show_lines = show_lines\n        self.leading = leading\n        self.collapse_padding = collapse_padding\n        self.style = style\n        self.header_style = header_style or \"\"\n        self.footer_style = footer_style or \"\"\n        self.border_style = border_style\n        self.title_style = title_style\n        self.caption_style = caption_style\n        self.title_justify: \"JustifyMethod\" = title_justify\n        self.caption_justify: \"JustifyMethod\" = caption_justify\n        self.highlight = highlight\n        self.row_styles: Sequence[StyleType] = list(row_styles or [])\n        append_column = self.columns.append\n        for header in headers:\n            if isinstance(header, str):\n                self.add_column(header=header)\n            else:\n                header._index = len(self.columns)\n                append_column(header)",
        "line_count": 63,
        "needs_llm_summary": true
      },
      {
        "name": "grid",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Table",
        "lineno": 254,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "padding",
          "expand",
          "collapse_padding",
          "pad_edge",
          "cls"
        ],
        "docstring": "Get a table with no lines, headers, or footer.\n\nArgs:\n    *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.\n    padding (PaddingDimensions, optional): Get padding around cells. Defaults to 0.\n    collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to True.\n    pad_edge (bool, optional): Enable padding around edges of table. Defaults to False.\n    expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n\nReturns:\n    Table: A table instance.",
        "code": "def grid(\n        cls,\n        *headers: Union[Column, str],\n        padding: PaddingDimensions = 0,\n        collapse_padding: bool = True,\n        pad_edge: bool = False,\n        expand: bool = False,\n    ) -> \"Table\":\n        \"\"\"Get a table with no lines, headers, or footer.\n\n        Args:\n            *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.\n            padding (PaddingDimensions, optional): Get padding around cells. Defaults to 0.\n            collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to True.\n            pad_edge (bool, optional): Enable padding around edges of table. Defaults to False.\n            expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n\n        Returns:\n            Table: A table instance.\n        \"\"\"\n        return cls(\n            *headers,\n            box=None,\n            padding=padding,\n            collapse_padding=collapse_padding,\n            show_header=False,\n            show_footer=False,\n            show_edge=False,\n            pad_edge=pad_edge,\n            expand=expand,\n        )",
        "line_count": 31,
        "needs_llm_summary": true
      },
      {
        "name": "expand",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 287,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Setting a non-None self.width implies expand.",
        "code": "def expand(self) -> bool:\n        \"\"\"Setting a non-None self.width implies expand.\"\"\"\n        return self._expand or self.width is not None",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "expand",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "expand",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 292,
        "decorators": [
          {
            "name": "expand.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "expand"
        ],
        "docstring": "Set expand.",
        "code": "def expand(self, expand: bool) -> None:\n        \"\"\"Set expand.\"\"\"\n        self._expand = expand",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "_extra_width",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 297,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "len",
          "self.columns"
        ],
        "docstring": "Get extra width to add to cell content.",
        "code": "def _extra_width(self) -> int:\n        \"\"\"Get extra width to add to cell content.\"\"\"\n        width = 0\n        if self.box and self.show_edge:\n            width += 2\n        if self.box:\n            width += len(self.columns) - 1\n        return width",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "row_count",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 307,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.rows",
          "len"
        ],
        "docstring": "Get the current number of rows.",
        "code": "def row_count(self) -> int:\n        \"\"\"Get the current number of rows.\"\"\"\n        return len(self.rows)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "get_row_style",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "index",
            "type": "int"
          }
        ],
        "return_type": "StyleType",
        "lineno": 311,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.row_styles",
          "console.get_style",
          "Style.null",
          "row_style",
          "len",
          "unknown.style"
        ],
        "docstring": "Get the current row style.",
        "code": "def get_row_style(self, console: \"Console\", index: int) -> StyleType:\n        \"\"\"Get the current row style.\"\"\"\n        style = Style.null()\n        if self.row_styles:\n            style += console.get_style(self.row_styles[index % len(self.row_styles)])\n        row_style = self.rows[index].style\n        if row_style is not None:\n            style += console.get_style(row_style)\n        return style",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 321,
        "decorators": [],
        "is_async": false,
        "calls": [
          "column",
          "sum",
          "self._extra_width",
          "options.max_width",
          "console",
          "self.width",
          "_measure_column",
          "options.update_width",
          "self._calculate_column_widths",
          "self.min_width",
          "minimum_width",
          "Measurement",
          "self._measure_column",
          "max_width",
          "maximum_width",
          "measurement.clamp"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        max_width = options.max_width\n        if self.width is not None:\n            max_width = self.width\n        if max_width < 0:\n            return Measurement(0, 0)\n\n        extra_width = self._extra_width\n        max_width = sum(\n            self._calculate_column_widths(\n                console, options.update_width(max_width - extra_width)\n            )\n        )\n        _measure_column = self._measure_column\n\n        measurements = [\n            _measure_column(console, options.update_width(max_width), column)\n            for column in self.columns\n        ]\n        minimum_width = (\n            sum(measurement.minimum for measurement in measurements) + extra_width\n        )\n        maximum_width = (\n            sum(measurement.maximum for measurement in measurements) + extra_width\n            if (self.width is None)\n            else self.width\n        )\n        measurement = Measurement(minimum_width, maximum_width)\n        measurement = measurement.clamp(self.min_width)\n        return measurement",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "padding",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Tuple[int, int, int, int]",
        "lineno": 355,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get cell padding.",
        "code": "def padding(self) -> Tuple[int, int, int, int]:\n        \"\"\"Get cell padding.\"\"\"\n        return self._padding",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "padding",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "padding",
            "type": "PaddingDimensions"
          }
        ],
        "return_type": "Table",
        "lineno": 360,
        "decorators": [
          {
            "name": "padding.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "padding",
          "Padding.unpack"
        ],
        "docstring": "Set cell padding.",
        "code": "def padding(self, padding: PaddingDimensions) -> \"Table\":\n        \"\"\"Set cell padding.\"\"\"\n        self._padding = Padding.unpack(padding)\n        return self",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "add_column",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "header",
            "type": "RenderableType"
          },
          {
            "name": "footer",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 365,
        "decorators": [],
        "is_async": false,
        "calls": [
          "no_wrap",
          "column",
          "Column",
          "vertical",
          "overflow",
          "footer",
          "self.columns.append",
          "max_width",
          "width",
          "justify",
          "ratio",
          "min_width",
          "header",
          "len",
          "self.columns"
        ],
        "docstring": "Add a column to the table.\n\nArgs:\n    header (RenderableType, optional): Text or renderable for the header.\n        Defaults to \"\".\n    footer (RenderableType, optional): Text or renderable for the footer.\n        Defaults to \"\".\n    header_style (Union[str, Style], optional): Style for the header, or None for default. Defaults to None.\n    highlight (bool, optional): Whether to highlight the text. The default of None uses the value of the table (self) object.\n    footer_style (Union[str, Style], optional): Style for the footer, or None for default. Defaults to None.\n    style (Union[str, Style], optional): Style for the column cells, or None for default. Defaults to None.\n    justify (JustifyMethod, optional): Alignment for cells. Defaults to \"left\".\n    vertical (VerticalAlignMethod, optional): Vertical alignment, one of \"top\", \"middle\", or \"bottom\". Defaults to \"top\".\n    overflow (OverflowMethod): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to \"ellipsis\".\n    width (int, optional): Desired width of column in characters, or None to fit to contents. Defaults to None.\n    min_width (Optional[int], optional): Minimum width of column, or ``None`` for no minimum. Defaults to None.\n    max_width (Optional[int], optional): Maximum width of column, or ``None`` for no maximum. Defaults to None.\n    ratio (int, optional): Flexible ratio for the column (requires ``Table.expand`` or ``Table.width``). Defaults to None.\n    no_wrap (bool, optional): Set to ``True`` to disable wrapping of this column.",
        "code": "def add_column(\n        self,\n        header: \"RenderableType\" = \"\",\n        footer: \"RenderableType\" = \"\",\n        *,\n        header_style: Optional[StyleType] = None,\n        highlight: Optional[bool] = None,\n        footer_style: Optional[StyleType] = None,\n        style: Optional[StyleType] = None,\n        justify: \"JustifyMethod\" = \"left\",\n        vertical: \"VerticalAlignMethod\" = \"top\",\n        overflow: \"OverflowMethod\" = \"ellipsis\",\n        width: Optional[int] = None,\n        min_width: Optional[int] = None,\n        max_width: Optional[int] = None,\n        ratio: Optional[int] = None,\n        no_wrap: bool = False,\n    ) -> None:\n        \"\"\"Add a column to the table.\n\n        Args:\n            header (RenderableType, optional): Text or renderable for the header.\n                Defaults to \"\".\n            footer (RenderableType, optional): Text or renderable for the footer.\n                Defaults to \"\".\n            header_style (Union[str, Style], optional): Style for the header, or None for default. Defaults to None.\n            highlight (bool, optional): Whether to highlight the text. The default of None uses the value of the table (self) object.\n            footer_style (Union[str, Style], optional): Style for the footer, or None for default. Defaults to None.\n            style (Union[str, Style], optional): Style for the column cells, or None for default. Defaults to None.\n            justify (JustifyMethod, optional): Alignment for cells. Defaults to \"left\".\n            vertical (VerticalAlignMethod, optional): Vertical alignment, one of \"top\", \"middle\", or \"bottom\". Defaults to \"top\".\n            overflow (OverflowMethod): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to \"ellipsis\".\n            width (int, optional): Desired width of column in characters, or None to fit to contents. Defaults to None.\n            min_width (Optional[int], optional): Minimum width of column, or ``None`` for no minimum. Defaults to None.\n            max_width (Optional[int], optional): Maximum width of column, or ``None`` for no maximum. Defaults to None.\n            ratio (int, optional): Flexible ratio for the column (requires ``Table.expand`` or ``Table.width``). Defaults to None.\n            no_wrap (bool, optional): Set to ``True`` to disable wrapping of this column.\n        \"\"\"\n\n        column = Column(\n            _index=len(self.columns),\n            header=header,\n            footer=footer,\n            header_style=header_style or \"\",\n            highlight=highlight if highlight is not None else self.highlight,\n            footer_style=footer_style or \"\",\n            style=style or \"\",\n            justify=justify,\n            vertical=vertical,\n            overflow=overflow,\n            width=width,\n            min_width=min_width,\n            max_width=max_width,\n            ratio=ratio,\n            no_wrap=no_wrap,\n        )\n        self.columns.append(column)",
        "line_count": 57,
        "needs_llm_summary": true
      },
      {
        "name": "add_row",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 423,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "style",
          "index",
          "list",
          "type",
          "self.highlight",
          "self.columns",
          "column",
          "cell_renderables",
          "Row",
          "add_cell",
          "Text",
          "renderable",
          "end_section",
          "len",
          "Column",
          "errors.NotRenderableError",
          "self.rows.append",
          "column._cells.append",
          "renderables",
          "columns",
          "self.columns.append",
          "is_renderable"
        ],
        "docstring": "Add a row of renderables.\n\nArgs:\n    *renderables (None or renderable): Each cell in a row must be a renderable object (including str),\n        or ``None`` for a blank cell.\n    style (StyleType, optional): An optional style to apply to the entire row. Defaults to None.\n    end_section (bool, optional): End a section and draw a line. Defaults to False.\n\nRaises:\n    errors.NotRenderableError: If you add something that can't be rendered.",
        "code": "def add_row(\n        self,\n        *renderables: Optional[\"RenderableType\"],\n        style: Optional[StyleType] = None,\n        end_section: bool = False,\n    ) -> None:\n        \"\"\"Add a row of renderables.\n\n        Args:\n            *renderables (None or renderable): Each cell in a row must be a renderable object (including str),\n                or ``None`` for a blank cell.\n            style (StyleType, optional): An optional style to apply to the entire row. Defaults to None.\n            end_section (bool, optional): End a section and draw a line. Defaults to False.\n\n        Raises:\n            errors.NotRenderableError: If you add something that can't be rendered.\n        \"\"\"\n\n        def add_cell(column: Column, renderable: \"RenderableType\") -> None:\n            column._cells.append(renderable)\n\n        cell_renderables: List[Optional[\"RenderableType\"]] = list(renderables)\n\n        columns = self.columns\n        if len(cell_renderables) < len(columns):\n            cell_renderables = [\n                *cell_renderables,\n                *[None] * (len(columns) - len(cell_renderables)),\n            ]\n        for index, renderable in enumerate(cell_renderables):\n            if index == len(columns):\n                column = Column(_index=index, highlight=self.highlight)\n                for _ in self.rows:\n                    add_cell(column, Text(\"\"))\n                self.columns.append(column)\n            else:\n                column = columns[index]\n            if renderable is None:\n                add_cell(column, \"\")\n            elif is_renderable(renderable):\n                add_cell(column, renderable)\n            else:\n                raise errors.NotRenderableError(\n                    f\"unable to render {type(renderable).__name__}; a string or other renderable object is required\"\n                )\n        self.rows.append(Row(style=style, end_section=end_section))",
        "line_count": 46,
        "needs_llm_summary": true
      },
      {
        "name": "add_section",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 470,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": "Add a new section (draw a line after current row).",
        "code": "def add_section(self) -> None:\n        \"\"\"Add a new section (draw a line after current row).\"\"\"\n\n        if self.rows:\n            self.rows[-1].end_section = True",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 476,
        "decorators": [],
        "is_async": false,
        "calls": [
          "sum",
          "self._render",
          "render_options.update",
          "style",
          "self.width",
          "console.render",
          "self.title_style",
          "table_width",
          "widths",
          "self.highlight",
          "options.update",
          "render_options",
          "self.title_justify",
          "console.render_str",
          "str",
          "options.max_width",
          "Style.pick_first",
          "self.title",
          "render_annotation",
          "text",
          "justify",
          "self._extra_width",
          "Segment",
          "console",
          "self.caption_justify",
          "isinstance",
          "self.caption",
          "self.caption_style",
          "options.update_width",
          "self._calculate_column_widths",
          "render_text"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if not self.columns:\n            yield Segment(\"\\n\")\n            return\n\n        max_width = options.max_width\n        if self.width is not None:\n            max_width = self.width\n\n        extra_width = self._extra_width\n        widths = self._calculate_column_widths(\n            console, options.update_width(max_width - extra_width)\n        )\n        table_width = sum(widths) + extra_width\n\n        render_options = options.update(\n            width=table_width, highlight=self.highlight, height=None\n        )\n\n        def render_annotation(\n            text: TextType, style: StyleType, justify: \"JustifyMethod\" = \"center\"\n        ) -> \"RenderResult\":\n            render_text = (\n                console.render_str(text, style=style, highlight=False)\n                if isinstance(text, str)\n                else text\n            )\n            return console.render(\n                render_text, options=render_options.update(justify=justify)\n            )\n\n        if self.title:\n            yield from render_annotation(\n                self.title,\n                style=Style.pick_first(self.title_style, \"table.title\"),\n                justify=self.title_justify,\n            )\n        yield from self._render(console, render_options, widths)\n        if self.caption:\n            yield from render_annotation(\n                self.caption,\n                style=Style.pick_first(self.caption_style, \"table.caption\"),\n                justify=self.caption_justify,\n            )",
        "line_count": 46,
        "needs_llm_summary": true
      },
      {
        "name": "_calculate_column_widths",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "List[int]",
        "lineno": 523,
        "decorators": [],
        "is_async": false,
        "calls": [
          "flexible_width",
          "enumerate",
          "sum",
          "width_ranges",
          "next",
          "excess_width",
          "max_width",
          "any",
          "ratios",
          "widths",
          "self._collapse_widths",
          "self.columns",
          "flex_minimum",
          "column",
          "self._get_padding_width",
          "ratio_distribute",
          "iter_flex_widths",
          "pad_widths",
          "self._measure_column",
          "fixed_widths",
          "options",
          "options.max_width",
          "get_padding_width",
          "column._index",
          "width",
          "self._extra_width",
          "console",
          "ratio_reduce",
          "zip",
          "len",
          "flex_widths",
          "min",
          "iter",
          "options.update_width",
          "columns"
        ],
        "docstring": "Calculate the widths of each column, including padding, not including borders.",
        "code": "def _calculate_column_widths(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> List[int]:\n        \"\"\"Calculate the widths of each column, including padding, not including borders.\"\"\"\n        max_width = options.max_width\n        columns = self.columns\n        width_ranges = [\n            self._measure_column(console, options, column) for column in columns\n        ]\n        widths = [_range.maximum or 1 for _range in width_ranges]\n        get_padding_width = self._get_padding_width\n        extra_width = self._extra_width\n        if self.expand:\n            ratios = [col.ratio or 0 for col in columns if col.flexible]\n            if any(ratios):\n                fixed_widths = [\n                    0 if column.flexible else _range.maximum\n                    for _range, column in zip(width_ranges, columns)\n                ]\n                flex_minimum = [\n                    (column.width or 1) + get_padding_width(column._index)\n                    for column in columns\n                    if column.flexible\n                ]\n                flexible_width = max_width - sum(fixed_widths)\n                flex_widths = ratio_distribute(flexible_width, ratios, flex_minimum)\n                iter_flex_widths = iter(flex_widths)\n                for index, column in enumerate(columns):\n                    if column.flexible:\n                        widths[index] = fixed_widths[index] + next(iter_flex_widths)\n        table_width = sum(widths)\n\n        if table_width > max_width:\n            widths = self._collapse_widths(\n                widths,\n                [(column.width is None and not column.no_wrap) for column in columns],\n                max_width,\n            )\n            table_width = sum(widths)\n            # last resort, reduce columns evenly\n            if table_width > max_width:\n                excess_width = table_width - max_width\n                widths = ratio_reduce(excess_width, [1] * len(widths), widths, widths)\n                table_width = sum(widths)\n\n            width_ranges = [\n                self._measure_column(console, options.update_width(width), column)\n                for width, column in zip(widths, columns)\n            ]\n            widths = [_range.maximum or 0 for _range in width_ranges]\n\n        if (table_width < max_width and self.expand) or (\n            self.min_width is not None and table_width < (self.min_width - extra_width)\n        ):\n            _max_width = (\n                max_width\n                if self.min_width is None\n                else min(self.min_width - extra_width, max_width)\n            )\n            pad_widths = ratio_distribute(_max_width - table_width, widths)\n            widths = [_width + pad for _width, pad in zip(widths, pad_widths)]\n\n        return widths",
        "line_count": 63,
        "needs_llm_summary": true
      },
      {
        "name": "_collapse_widths",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "widths",
            "type": "List[int]"
          },
          {
            "name": "wrapable",
            "type": "List[bool]"
          },
          {
            "name": "max_width",
            "type": "int"
          }
        ],
        "return_type": "List[int]",
        "lineno": 588,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "min",
          "max",
          "sum",
          "ratios",
          "column_difference",
          "max_reduce",
          "excess_width",
          "any",
          "widths",
          "ratio_reduce",
          "zip",
          "len",
          "wrapable"
        ],
        "docstring": "Reduce widths so that the total is under max_width.\n\nArgs:\n    widths (List[int]): List of widths.\n    wrapable (List[bool]): List of booleans that indicate if a column may shrink.\n    max_width (int): Maximum width to reduce to.\n\nReturns:\n    List[int]: A new list of widths.",
        "code": "def _collapse_widths(\n        cls, widths: List[int], wrapable: List[bool], max_width: int\n    ) -> List[int]:\n        \"\"\"Reduce widths so that the total is under max_width.\n\n        Args:\n            widths (List[int]): List of widths.\n            wrapable (List[bool]): List of booleans that indicate if a column may shrink.\n            max_width (int): Maximum width to reduce to.\n\n        Returns:\n            List[int]: A new list of widths.\n        \"\"\"\n        total_width = sum(widths)\n        excess_width = total_width - max_width\n        if any(wrapable):\n            while total_width and excess_width > 0:\n                max_column = max(\n                    width for width, allow_wrap in zip(widths, wrapable) if allow_wrap\n                )\n                second_max_column = max(\n                    width if allow_wrap and width != max_column else 0\n                    for width, allow_wrap in zip(widths, wrapable)\n                )\n                column_difference = max_column - second_max_column\n                ratios = [\n                    (1 if (width == max_column and allow_wrap) else 0)\n                    for width, allow_wrap in zip(widths, wrapable)\n                ]\n                if not any(ratios) or not column_difference:\n                    break\n                max_reduce = [min(excess_width, column_difference)] * len(widths)\n                widths = ratio_reduce(excess_width, ratios, max_reduce, widths)\n\n                total_width = sum(widths)\n                excess_width = total_width - max_width\n        return widths",
        "line_count": 37,
        "needs_llm_summary": true
      },
      {
        "name": "_get_cells",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "column_index",
            "type": "int"
          },
          {
            "name": "column",
            "type": "Column"
          }
        ],
        "return_type": "Iterable[_Cell]",
        "lineno": 626,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "_padding",
          "any",
          "self.columns",
          "raw_cells",
          "console.get_style",
          "self.pad_edge",
          "column.header_style",
          "loop_first_last",
          "max",
          "_Padding",
          "get_padding",
          "get_style",
          "_append",
          "padding",
          "_padding_cache.get",
          "_Cell",
          "self.collapse_padding",
          "renderable",
          "column.footer_style",
          "self.padding",
          "len",
          "Padding",
          "getattr",
          "raw_cells.append",
          "first",
          "last"
        ],
        "docstring": "Get all the cells with padding and optional header.",
        "code": "def _get_cells(\n        self, console: \"Console\", column_index: int, column: Column\n    ) -> Iterable[_Cell]:\n        \"\"\"Get all the cells with padding and optional header.\"\"\"\n\n        collapse_padding = self.collapse_padding\n        pad_edge = self.pad_edge\n        padding = self.padding\n        any_padding = any(padding)\n\n        first_column = column_index == 0\n        last_column = column_index == len(self.columns) - 1\n\n        _padding_cache: Dict[Tuple[bool, bool], Tuple[int, int, int, int]] = {}\n\n        def get_padding(first_row: bool, last_row: bool) -> Tuple[int, int, int, int]:\n            cached = _padding_cache.get((first_row, last_row))\n            if cached:\n                return cached\n            top, right, bottom, left = padding\n\n            if collapse_padding:\n                if not first_column:\n                    left = max(0, left - right)\n                if not last_row:\n                    bottom = max(0, top - bottom)\n\n            if not pad_edge:\n                if first_column:\n                    left = 0\n                if last_column:\n                    right = 0\n                if first_row:\n                    top = 0\n                if last_row:\n                    bottom = 0\n            _padding = (top, right, bottom, left)\n            _padding_cache[(first_row, last_row)] = _padding\n            return _padding\n\n        raw_cells: List[Tuple[StyleType, \"RenderableType\"]] = []\n        _append = raw_cells.append\n        get_style = console.get_style\n        if self.show_header:\n            header_style = get_style(self.header_style or \"\") + get_style(\n                column.header_style\n            )\n            _append((header_style, column.header))\n        cell_style = get_style(column.style or \"\")\n        for cell in column.cells:\n            _append((cell_style, cell))\n        if self.show_footer:\n            footer_style = get_style(self.footer_style or \"\") + get_style(\n                column.footer_style\n            )\n            _append((footer_style, column.footer))\n\n        if any_padding:\n            _Padding = Padding\n            for first, last, (style, renderable) in loop_first_last(raw_cells):\n                yield _Cell(\n                    style,\n                    _Padding(renderable, get_padding(first, last)),\n                    getattr(renderable, \"vertical\", None) or column.vertical,\n                )\n        else:\n            for style, renderable in raw_cells:\n                yield _Cell(\n                    style,\n                    renderable,\n                    getattr(renderable, \"vertical\", None) or column.vertical,\n                )",
        "line_count": 72,
        "needs_llm_summary": true
      },
      {
        "name": "_get_padding_width",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "column_index",
            "type": "int"
          }
        ],
        "return_type": "int",
        "lineno": 699,
        "decorators": [],
        "is_async": false,
        "calls": [
          "max",
          "self.padding"
        ],
        "docstring": "Get extra width from padding.",
        "code": "def _get_padding_width(self, column_index: int) -> int:\n        \"\"\"Get extra width from padding.\"\"\"\n        _, pad_right, _, pad_left = self.padding\n        if self.collapse_padding:\n            if column_index > 0:\n                pad_left = max(0, pad_left - pad_right)\n        return pad_left + pad_right",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "_measure_column",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          },
          {
            "name": "column",
            "type": "Column"
          }
        ],
        "return_type": "Measurement",
        "lineno": 707,
        "decorators": [],
        "is_async": false,
        "calls": [
          "append_min",
          "max_width",
          "Measurement",
          "_min",
          "min_widths.append",
          "self._get_cells",
          "self._get_padding_width",
          "column",
          "_max",
          "Measurement.get",
          "get_render_width",
          "cell.renderable",
          "max",
          "append_max",
          "options",
          "options.max_width",
          "max_widths",
          "max_widths.append",
          "column._index",
          "unknown.with_maximum",
          "console",
          "min_widths",
          "measurement.clamp"
        ],
        "docstring": "Get the minimum and maximum width of the column.",
        "code": "def _measure_column(\n        self,\n        console: \"Console\",\n        options: \"ConsoleOptions\",\n        column: Column,\n    ) -> Measurement:\n        \"\"\"Get the minimum and maximum width of the column.\"\"\"\n\n        max_width = options.max_width\n        if max_width < 1:\n            return Measurement(0, 0)\n\n        padding_width = self._get_padding_width(column._index)\n\n        if column.width is not None:\n            # Fixed width column\n            return Measurement(\n                column.width + padding_width, column.width + padding_width\n            ).with_maximum(max_width)\n        # Flexible column, we need to measure contents\n        min_widths: List[int] = []\n        max_widths: List[int] = []\n        append_min = min_widths.append\n        append_max = max_widths.append\n        get_render_width = Measurement.get\n        for cell in self._get_cells(console, column._index, column):\n            _min, _max = get_render_width(console, options, cell.renderable)\n            append_min(_min)\n            append_max(_max)\n\n        measurement = Measurement(\n            max(min_widths) if min_widths else 1,\n            max(max_widths) if max_widths else max_width,\n        ).with_maximum(max_width)\n        measurement = measurement.clamp(\n            None if column.min_width is None else column.min_width + padding_width,\n            None if column.max_width is None else column.max_width + padding_width,\n        )\n        return measurement",
        "line_count": 39,
        "needs_llm_summary": true
      },
      {
        "name": "_render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          },
          {
            "name": "widths",
            "type": "List[int]"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 747,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "enumerate",
          "console.render_lines",
          "lines",
          "cells",
          "_divider.text.strip",
          "self.safe_box",
          "style",
          "cell.style",
          "_Segment.align_bottom",
          "_cell.vertical",
          "self.leading",
          "list",
          "cells.append",
          "self.get_row_style",
          "Style.null",
          "_box.foot_vertical",
          "_box.foot_right",
          "widths",
          "options.update",
          "_divider.text",
          "_Segment.align_middle",
          "render_options",
          "self._get_cells",
          "self.columns",
          "_box.head_left",
          "column",
          "_Segment.set_shape",
          "_box.mid_left",
          "show_edge",
          "_box.mid_vertical",
          "console.get_style",
          "_box.get_row",
          "cell",
          "self.show_header",
          "max_height",
          "_box.get_top",
          "loop_first_last",
          "cell.renderable",
          "self.show_edge",
          "max",
          "_Segment",
          "get_style",
          "self.show_footer",
          "column.no_wrap",
          "options",
          "self.box.substitute",
          "column.highlight",
          "_box.head_right",
          "column_index",
          "column.justify",
          "_Segment.align_top",
          "row_height",
          "width",
          "_box.head_vertical",
          "_box.mid_right",
          "align_cell",
          "border_style",
          "Segment",
          "column.overflow",
          "console",
          "pick_bool",
          "zip",
          "_box.foot_left",
          "len",
          "_cell.style",
          "range",
          "self.show_lines",
          "_box.get_plain_headed_box",
          "_box.get_bottom",
          "get_row_style",
          "columns",
          "loop_last",
          "row_cell",
          "row_cells",
          "console.safe_box"
        ],
        "docstring": null,
        "code": "def _render(\n        self, console: \"Console\", options: \"ConsoleOptions\", widths: List[int]\n    ) -> \"RenderResult\":\n        table_style = console.get_style(self.style or \"\")\n\n        border_style = table_style + console.get_style(self.border_style or \"\")\n        _column_cells = (\n            self._get_cells(console, column_index, column)\n            for column_index, column in enumerate(self.columns)\n        )\n        row_cells: List[Tuple[_Cell, ...]] = list(zip(*_column_cells))\n        _box = (\n            self.box.substitute(\n                options, safe=pick_bool(self.safe_box, console.safe_box)\n            )\n            if self.box\n            else None\n        )\n        _box = _box.get_plain_headed_box() if _box and not self.show_header else _box\n\n        new_line = Segment.line()\n\n        columns = self.columns\n        show_header = self.show_header\n        show_footer = self.show_footer\n        show_edge = self.show_edge\n        show_lines = self.show_lines\n        leading = self.leading\n\n        _Segment = Segment\n        if _box:\n            box_segments = [\n                (\n                    _Segment(_box.head_left, border_style),\n                    _Segment(_box.head_right, border_style),\n                    _Segment(_box.head_vertical, border_style),\n                ),\n                (\n                    _Segment(_box.mid_left, border_style),\n                    _Segment(_box.mid_right, border_style),\n                    _Segment(_box.mid_vertical, border_style),\n                ),\n                (\n                    _Segment(_box.foot_left, border_style),\n                    _Segment(_box.foot_right, border_style),\n                    _Segment(_box.foot_vertical, border_style),\n                ),\n            ]\n            if show_edge:\n                yield _Segment(_box.get_top(widths), border_style)\n                yield new_line\n        else:\n            box_segments = []\n\n        get_row_style = self.get_row_style\n        get_style = console.get_style\n\n        for index, (first, last, row_cell) in enumerate(loop_first_last(row_cells)):\n            header_row = first and show_header\n            footer_row = last and show_footer\n            row = (\n                self.rows[index - show_header]\n                if (not header_row and not footer_row)\n                else None\n            )\n            max_height = 1\n            cells: List[List[List[Segment]]] = []\n            if header_row or footer_row:\n                row_style = Style.null()\n            else:\n                row_style = get_style(\n                    get_row_style(console, index - 1 if show_header else index)\n                )\n            for width, cell, column in zip(widths, row_cell, columns):\n                render_options = options.update(\n                    width=width,\n                    justify=column.justify,\n                    no_wrap=column.no_wrap,\n                    overflow=column.overflow,\n                    height=None,\n                    highlight=column.highlight,\n                )\n                lines = console.render_lines(\n                    cell.renderable,\n                    render_options,\n                    style=get_style(cell.style) + row_style,\n                )\n                max_height = max(max_height, len(lines))\n                cells.append(lines)\n\n            row_height = max(len(cell) for cell in cells)\n\n            def align_cell(\n                cell: List[List[Segment]],\n                vertical: \"VerticalAlignMethod\",\n                width: int,\n                style: Style,\n            ) -> List[List[Segment]]:\n                if header_row:\n                    vertical = \"bottom\"\n                elif footer_row:\n                    vertical = \"top\"\n\n                if vertical == \"top\":\n                    return _Segment.align_top(cell, width, row_height, style)\n                elif vertical == \"middle\":\n                    return _Segment.align_middle(cell, width, row_height, style)\n                return _Segment.align_bottom(cell, width, row_height, style)\n\n            cells[:] = [\n                _Segment.set_shape(\n                    align_cell(\n                        cell,\n                        _cell.vertical,\n                        width,\n                        get_style(_cell.style) + row_style,\n                    ),\n                    width,\n                    max_height,\n                )\n                for width, _cell, cell, column in zip(widths, row_cell, cells, columns)\n            ]\n\n            if _box:\n                if last and show_footer:\n                    yield _Segment(\n                        _box.get_row(widths, \"foot\", edge=show_edge), border_style\n                    )\n                    yield new_line\n                left, right, _divider = box_segments[0 if first else (2 if last else 1)]\n\n                # If the column divider is whitespace also style it with the row background\n                divider = (\n                    _divider\n                    if _divider.text.strip()\n                    else _Segment(\n                        _divider.text, row_style.background_style + _divider.style\n                    )\n                )\n                for line_no in range(max_height):\n                    if show_edge:\n                        yield left\n                    for last_cell, rendered_cell in loop_last(cells):\n                        yield from rendered_cell[line_no]\n                        if not last_cell:\n                            yield divider\n                    if show_edge:\n                        yield right\n                    yield new_line\n            else:\n                for line_no in range(max_height):\n                    for rendered_cell in cells:\n                        yield from rendered_cell[line_no]\n                    yield new_line\n            if _box and first and show_header:\n                yield _Segment(\n                    _box.get_row(widths, \"head\", edge=show_edge), border_style\n                )\n                yield new_line\n            end_section = row and row.end_section\n            if _box and (show_lines or leading or end_section):\n                if (\n                    not last\n                    and not (show_footer and index >= len(row_cells) - 2)\n                    and not (show_header and header_row)\n                ):\n                    if leading:\n                        yield _Segment(\n                            _box.get_row(widths, \"mid\", edge=show_edge) * leading,\n                            border_style,\n                        )\n                    else:\n                        yield _Segment(\n                            _box.get_row(widths, \"row\", edge=show_edge), border_style\n                        )\n                    yield new_line\n\n        if _box and show_edge:\n            yield _Segment(_box.get_bottom(widths), border_style)\n            yield new_line",
        "line_count": 180,
        "needs_llm_summary": true
      },
      {
        "name": "add_cell",
        "args": [
          {
            "name": "column",
            "type": "Column"
          },
          {
            "name": "renderable",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 441,
        "decorators": [],
        "is_async": false,
        "calls": [
          "column._cells.append",
          "renderable"
        ],
        "docstring": null,
        "code": "def add_cell(column: Column, renderable: \"RenderableType\") -> None:\n            column._cells.append(renderable)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "render_annotation",
        "args": [
          {
            "name": "text",
            "type": "TextType"
          },
          {
            "name": "style",
            "type": "StyleType"
          },
          {
            "name": "justify",
            "type": "JustifyMethod"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 497,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "console.render_str",
          "str",
          "render_options.update",
          "style",
          "console.render",
          "text",
          "justify",
          "render_text"
        ],
        "docstring": null,
        "code": "def render_annotation(\n            text: TextType, style: StyleType, justify: \"JustifyMethod\" = \"center\"\n        ) -> \"RenderResult\":\n            render_text = (\n                console.render_str(text, style=style, highlight=False)\n                if isinstance(text, str)\n                else text\n            )\n            return console.render(\n                render_text, options=render_options.update(justify=justify)\n            )",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "get_padding",
        "args": [
          {
            "name": "first_row",
            "type": "bool"
          },
          {
            "name": "last_row",
            "type": "bool"
          }
        ],
        "return_type": "Tuple[int, int, int, int]",
        "lineno": 641,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_padding_cache.get",
          "padding",
          "max",
          "_padding"
        ],
        "docstring": null,
        "code": "def get_padding(first_row: bool, last_row: bool) -> Tuple[int, int, int, int]:\n            cached = _padding_cache.get((first_row, last_row))\n            if cached:\n                return cached\n            top, right, bottom, left = padding\n\n            if collapse_padding:\n                if not first_column:\n                    left = max(0, left - right)\n                if not last_row:\n                    bottom = max(0, top - bottom)\n\n            if not pad_edge:\n                if first_column:\n                    left = 0\n                if last_column:\n                    right = 0\n                if first_row:\n                    top = 0\n                if last_row:\n                    bottom = 0\n            _padding = (top, right, bottom, left)\n            _padding_cache[(first_row, last_row)] = _padding\n            return _padding",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "header",
        "args": [
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 967,
        "decorators": [],
        "is_async": false,
        "calls": [
          "console.print",
          "highlight",
          "console.rule",
          "text"
        ],
        "docstring": null,
        "code": "def header(text: str) -> None:\n            console.print()\n            console.rule(highlight(text))\n            console.print()",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "align_cell",
        "args": [
          {
            "name": "cell",
            "type": "List[List[Segment]]"
          },
          {
            "name": "vertical",
            "type": "VerticalAlignMethod"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "style",
            "type": "Style"
          }
        ],
        "return_type": "List[List[Segment]]",
        "lineno": 839,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "_Segment.align_bottom",
          "cell",
          "_Segment.align_top",
          "row_height",
          "width",
          "_Segment.align_middle"
        ],
        "docstring": null,
        "code": "def align_cell(\n                cell: List[List[Segment]],\n                vertical: \"VerticalAlignMethod\",\n                width: int,\n                style: Style,\n            ) -> List[List[Segment]]:\n                if header_row:\n                    vertical = \"bottom\"\n                elif footer_row:\n                    vertical = \"top\"\n\n                if vertical == \"top\":\n                    return _Segment.align_top(cell, width, row_height, style)\n                elif vertical == \"middle\":\n                    return _Segment.align_middle(cell, width, row_height, style)\n                return _Segment.align_bottom(cell, width, row_height, style)",
        "line_count": 16,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Column",
        "methods": [
          "copy",
          "cells",
          "flexible"
        ],
        "base_classes": [],
        "lineno": 39,
        "docstring": "Defines a column within a ~Table.\n\nArgs:\n    title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.\n    caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.\n    width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.\n    min_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.\n    box (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.\n    safe_box (Optional[bool], optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.\n    padding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).\n    collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.\n    pad_edge (bool, optional): Enable padding of edge cells. Defaults to True.\n    expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n    show_header (bool, optional): Show a header row. Defaults to True.\n    show_footer (bool, optional): Show a footer row. Defaults to False.\n    show_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.\n    show_lines (bool, optional): Draw lines between every row. Defaults to False.\n    leading (int, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.\n    style (Union[str, Style], optional): Default style for the table. Defaults to \"none\".\n    row_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.\n    header_style (Union[str, Style], optional): Style of the header. Defaults to \"table.header\".\n    footer_style (Union[str, Style], optional): Style of the footer. Defaults to \"table.footer\".\n    border_style (Union[str, Style], optional): Style of the border. Defaults to None.\n    title_style (Union[str, Style], optional): Style of the title. Defaults to None.\n    caption_style (Union[str, Style], optional): Style of the caption. Defaults to None.\n    title_justify (str, optional): Justify method for title. Defaults to \"center\".\n    caption_justify (str, optional): Justify method for caption. Defaults to \"center\".\n    highlight (bool, optional): Highlight cell contents (if str). Defaults to False."
      },
      {
        "name": "Row",
        "methods": [],
        "base_classes": [],
        "lineno": 133,
        "docstring": "Information regarding a row."
      },
      {
        "name": "_Cell",
        "methods": [],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 143,
        "docstring": "A single cell in a table."
      },
      {
        "name": "Table",
        "methods": [
          "__init__",
          "grid",
          "expand",
          "expand",
          "_extra_width",
          "row_count",
          "get_row_style",
          "__rich_measure__",
          "padding",
          "padding",
          "add_column",
          "add_row",
          "add_section",
          "__rich_console__",
          "_calculate_column_widths",
          "_collapse_widths",
          "_get_cells",
          "_get_padding_width",
          "_measure_column",
          "_render"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 154,
        "docstring": "A console renderable to draw a table.\n\nArgs:\n    *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.\n    title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.\n    caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.\n    width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.\n    min_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.\n    box (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.\n    safe_box (Optional[bool], optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.\n    padding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).\n    collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.\n    pad_edge (bool, optional): Enable padding of edge cells. Defaults to True.\n    expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n    show_header (bool, optional): Show a header row. Defaults to True.\n    show_footer (bool, optional): Show a footer row. Defaults to False.\n    show_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.\n    show_lines (bool, optional): Draw lines between every row. Defaults to False.\n    leading (int, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.\n    style (Union[str, Style], optional): Default style for the table. Defaults to \"none\".\n    row_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.\n    header_style (Union[str, Style], optional): Style of the header. Defaults to \"table.header\".\n    footer_style (Union[str, Style], optional): Style of the footer. Defaults to \"table.footer\".\n    border_style (Union[str, Style], optional): Style of the border. Defaults to None.\n    title_style (Union[str, Style], optional): Style of the title. Defaults to None.\n    caption_style (Union[str, Style], optional): Style of the caption. Defaults to None.\n    title_justify (str, optional): Justify method for title. Defaults to \"center\".\n    caption_justify (str, optional): Justify method for caption. Defaults to \"center\".\n    highlight (bool, optional): Highlight cell contents (if str). Defaults to False."
      }
    ],
    "imports": [
      {
        "module": "dataclasses",
        "name": "dataclass",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "field",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "replace",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "box",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "errors",
        "alias": null,
        "lineno": 14,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_first_last",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 15,
        "type": "from_import"
      },
      {
        "module": "_pick",
        "name": "pick_bool",
        "alias": null,
        "lineno": 16,
        "type": "from_import"
      },
      {
        "module": "_ratio",
        "name": "ratio_distribute",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "_ratio",
        "name": "ratio_reduce",
        "alias": null,
        "lineno": 17,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "VerticalAlignMethod",
        "alias": null,
        "lineno": 18,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "padding",
        "name": "Padding",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "padding",
        "name": "PaddingDimensions",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "protocol",
        "name": "is_renderable",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "TextType",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "JustifyMethod",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "OverflowMethod",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 930,
        "type": "from_import"
      },
      {
        "module": "rich.highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 931,
        "type": "from_import"
      },
      {
        "module": "_timer",
        "name": "timer",
        "alias": null,
        "lineno": 933,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "console.rule",
      "header",
      "highlight",
      "Console",
      "ReprHighlighter",
      "table.add_column",
      "table.add_row",
      "timer",
      "Table"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.rule",
        "header",
        "table",
        "highlight",
        "Console",
        "ReprHighlighter",
        "text",
        "table.add_column",
        "table.add_row",
        "timer",
        "Table"
      ],
      "class_instantiations": [
        "Console",
        "ReprHighlighter",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "dataclasses",
        "typing"
      ],
      "third_party": {
        "other": [
          "box",
          "errors",
          "_loop",
          "_pick",
          "_ratio",
          "align",
          "jupyter",
          "measure",
          "padding",
          "protocol",
          "segment",
          "style",
          "text",
          "console",
          "rich",
          "_timer"
        ]
      },
      "tech_stack": []
    },
    "line_count": 1007
  },
  "rich/terminal_theme.py": {
    "filepath": "../rich/rich/terminal_theme.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "background",
            "type": "_ColorTuple"
          },
          {
            "name": "foreground",
            "type": "_ColorTuple"
          },
          {
            "name": "normal",
            "type": "List[_ColorTuple]"
          },
          {
            "name": "bright",
            "type": "Optional[List[_ColorTuple]]"
          }
        ],
        "return_type": "None",
        "lineno": 20,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Palette",
          "ColorTriplet"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        background: _ColorTuple,\n        foreground: _ColorTuple,\n        normal: List[_ColorTuple],\n        bright: Optional[List[_ColorTuple]] = None,\n    ) -> None:\n        self.background_color = ColorTriplet(*background)\n        self.foreground_color = ColorTriplet(*foreground)\n        self.ansi_colors = Palette(normal + (bright or normal))",
        "line_count": 10,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "TerminalTheme",
        "methods": [
          "__init__"
        ],
        "base_classes": [],
        "lineno": 9,
        "docstring": "A color theme used when exporting console content.\n\nArgs:\n    background (Tuple[int, int, int]): The background color.\n    foreground (Tuple[int, int, int]): The foreground (text) color.\n    normal (List[Tuple[int, int, int]]): A list of 8 normal intensity colors.\n    bright (List[Tuple[int, int, int]], optional): A list of 8 bright colors, or None\n        to repeat normal intensity. Defaults to None."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "color_triplet",
        "name": "ColorTriplet",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "palette",
        "name": "Palette",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "_ColorTuple",
        "assigned_to": null,
        "lineno": 6
      },
      {
        "name": "DEFAULT_TERMINAL_THEME",
        "assigned_to": "TerminalTheme",
        "lineno": 32
      },
      {
        "name": "MONOKAI",
        "assigned_to": "TerminalTheme",
        "lineno": 57
      },
      {
        "name": "DIMMED_MONOKAI",
        "assigned_to": "TerminalTheme",
        "lineno": 81
      },
      {
        "name": "NIGHT_OWLISH",
        "assigned_to": "TerminalTheme",
        "lineno": 105
      },
      {
        "name": "SVG_EXPORT_THEME",
        "assigned_to": "TerminalTheme",
        "lineno": 130
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "TerminalTheme"
      ],
      "class_instantiations": [
        "TerminalTheme"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "color_triplet",
          "palette"
        ]
      },
      "tech_stack": []
    },
    "line_count": 154
  },
  "rich/text.py": {
    "filepath": "../rich/rich/text.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 57,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"Span({self.start}, {self.end}, {self.style!r})\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__bool__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 60,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __bool__(self) -> bool:\n        return self.end > self.start",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "split",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "offset",
            "type": "int"
          }
        ],
        "return_type": "Tuple[Span, Optional[Span]]",
        "lineno": 63,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "end",
          "style",
          "Span",
          "span1.end",
          "start",
          "offset",
          "self"
        ],
        "docstring": "Split a span in to 2 from a given offset.",
        "code": "def split(self, offset: int) -> Tuple[\"Span\", Optional[\"Span\"]]:\n        \"\"\"Split a span in to 2 from a given offset.\"\"\"\n\n        if offset < self.start:\n            return self, None\n        if offset >= self.end:\n            return self, None\n\n        start, end, style = self\n        span1 = Span(start, min(end, offset), style)\n        span2 = Span(span1.end, end, style)\n        return span1, span2",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "move",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "offset",
            "type": "int"
          }
        ],
        "return_type": "Span",
        "lineno": 76,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "Span",
          "self"
        ],
        "docstring": "Move start and end by a given offset.\n\nArgs:\n    offset (int): Number of characters to add to start and end.\n\nReturns:\n    TextSpan: A new TextSpan with adjusted position.",
        "code": "def move(self, offset: int) -> \"Span\":\n        \"\"\"Move start and end by a given offset.\n\n        Args:\n            offset (int): Number of characters to add to start and end.\n\n        Returns:\n            TextSpan: A new TextSpan with adjusted position.\n        \"\"\"\n        start, end, style = self\n        return Span(start + offset, end + offset, style)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "right_crop",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "offset",
            "type": "int"
          }
        ],
        "return_type": "Span",
        "lineno": 88,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "end",
          "style",
          "Span",
          "start",
          "offset",
          "self"
        ],
        "docstring": "Crop the span at the given offset.\n\nArgs:\n    offset (int): A value between start and end.\n\nReturns:\n    Span: A new (possibly smaller) span.",
        "code": "def right_crop(self, offset: int) -> \"Span\":\n        \"\"\"Crop the span at the given offset.\n\n        Args:\n            offset (int): A value between start and end.\n\n        Returns:\n            Span: A new (possibly smaller) span.\n        \"\"\"\n        start, end, style = self\n        if offset >= end:\n            return self\n        return Span(start, min(offset, end), style)",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "extend",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "cells",
            "type": "int"
          }
        ],
        "return_type": "Span",
        "lineno": 102,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "Span",
          "start",
          "self"
        ],
        "docstring": "Extend the span by the given number of cells.\n\nArgs:\n    cells (int): Additional space to add to end of span.\n\nReturns:\n    Span: A span.",
        "code": "def extend(self, cells: int) -> \"Span\":\n        \"\"\"Extend the span by the given number of cells.\n\n        Args:\n            cells (int): Additional space to add to end of span.\n\n        Returns:\n            Span: A span.\n        \"\"\"\n        if cells:\n            start, end, style = self\n            return Span(start, end + cells, style)\n        else:\n            return self",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "style",
            "type": "Union[str, Style]"
          }
        ],
        "return_type": "None",
        "lineno": 144,
        "decorators": [],
        "is_async": false,
        "calls": [
          "no_wrap",
          "end",
          "tab_size",
          "strip_control_codes",
          "style",
          "sanitized_text",
          "text",
          "len"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        text: str = \"\",\n        style: Union[str, Style] = \"\",\n        *,\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = None,\n        end: str = \"\\n\",\n        tab_size: Optional[int] = None,\n        spans: Optional[List[Span]] = None,\n    ) -> None:\n        sanitized_text = strip_control_codes(text)\n        self._text = [sanitized_text]\n        self.style = style\n        self.justify: Optional[\"JustifyMethod\"] = justify\n        self.overflow: Optional[\"OverflowMethod\"] = overflow\n        self.no_wrap = no_wrap\n        self.end = end\n        self.tab_size = tab_size\n        self._spans: List[Span] = spans or []\n        self._length: int = len(sanitized_text)",
        "line_count": 22,
        "needs_llm_summary": true
      },
      {
        "name": "__len__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 167,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __len__(self) -> int:\n        return self._length",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__bool__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "bool",
        "lineno": 170,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "self._length"
        ],
        "docstring": null,
        "code": "def __bool__(self) -> bool:\n        return bool(self._length)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__str__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 173,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __str__(self) -> str:\n        return self.plain",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__repr__",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 176,
        "decorators": [],
        "is_async": false,
        "calls": [],
        "docstring": null,
        "code": "def __repr__(self) -> str:\n        return f\"<text {self.plain!r} {self._spans!r} {self.style!r}>\"",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "__add__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "other",
            "type": "Any"
          }
        ],
        "return_type": "Text",
        "lineno": 179,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "self.copy",
          "other",
          "result.append"
        ],
        "docstring": null,
        "code": "def __add__(self, other: Any) -> \"Text\":\n        if isinstance(other, (str, Text)):\n            result = self.copy()\n            result.append(other)\n            return result\n        return NotImplemented",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__eq__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "other",
            "type": "object"
          }
        ],
        "return_type": "bool",
        "lineno": 186,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "other",
          "Text"
        ],
        "docstring": null,
        "code": "def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Text):\n            return NotImplemented\n        return self.plain == other.plain and self._spans == other._spans",
        "line_count": 4,
        "needs_llm_summary": true
      },
      {
        "name": "__contains__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "other",
            "type": "object"
          }
        ],
        "return_type": "bool",
        "lineno": 191,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "str",
          "other",
          "Text"
        ],
        "docstring": null,
        "code": "def __contains__(self, other: object) -> bool:\n        if isinstance(other, str):\n            return other in self.plain\n        elif isinstance(other, Text):\n            return other.plain in self.plain\n        return False",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "__getitem__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "slice",
            "type": "Union[int, slice]"
          }
        ],
        "return_type": "Text",
        "lineno": 198,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "len",
          "self.plain",
          "self.divide",
          "slice.indices",
          "get_text_at",
          "slice",
          "style",
          "Span",
          "_Span",
          "TypeError",
          "int",
          "Text"
        ],
        "docstring": null,
        "code": "def __getitem__(self, slice: Union[int, slice]) -> \"Text\":\n        def get_text_at(offset: int) -> \"Text\":\n            _Span = Span\n            text = Text(\n                self.plain[offset],\n                spans=[\n                    _Span(0, 1, style)\n                    for start, end, style in self._spans\n                    if end > offset >= start\n                ],\n                end=\"\",\n            )\n            return text\n\n        if isinstance(slice, int):\n            return get_text_at(slice)\n        else:\n            start, stop, step = slice.indices(len(self.plain))\n            if step == 1:\n                lines = self.divide([start, stop])\n                return lines[1]\n            else:\n                # This would be a bit of work to implement efficiently\n                # For now, its not required\n                raise TypeError(\"slices with step!=1 are not supported\")",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "cell_len",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 225,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "self.plain",
          "cell_len"
        ],
        "docstring": "Get the number of cells required to render this text.",
        "code": "def cell_len(self) -> int:\n        \"\"\"Get the number of cells required to render this text.\"\"\"\n        return cell_len(self.plain)",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "markup",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 230,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "markup_spans.sort",
          "self.plain",
          "append",
          "output.append",
          "output",
          "unknown.join",
          "plain",
          "escape",
          "itemgetter",
          "offset",
          "len"
        ],
        "docstring": "Get console markup to render this Text.\n\nReturns:\n    str: A string potentially creating markup tags.",
        "code": "def markup(self) -> str:\n        \"\"\"Get console markup to render this Text.\n\n        Returns:\n            str: A string potentially creating markup tags.\n        \"\"\"\n        from .markup import escape\n\n        output: List[str] = []\n\n        plain = self.plain\n        markup_spans = [\n            (0, False, self.style),\n            *((span.start, False, span.style) for span in self._spans),\n            *((span.end, True, span.style) for span in self._spans),\n            (len(plain), True, self.style),\n        ]\n        markup_spans.sort(key=itemgetter(0, 1))\n        position = 0\n        append = output.append\n        for offset, closing, style in markup_spans:\n            if offset > position:\n                append(escape(plain[position:offset]))\n                position = offset\n            if style:\n                append(f\"[/{style}]\" if closing else f\"[{style}]\")\n        markup = \"\".join(output)\n        return markup",
        "line_count": 28,
        "needs_llm_summary": true
      },
      {
        "name": "from_markup",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "Text",
        "lineno": 260,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "end",
          "overflow",
          "style",
          "emoji_variant",
          "emoji",
          "render",
          "text",
          "justify"
        ],
        "docstring": "Create Text instance from markup.\n\nArgs:\n    text (str): A string containing console markup.\n    style (Union[str, Style], optional): Base style for text. Defaults to \"\".\n    emoji (bool, optional): Also render emoji code. Defaults to True.\n    emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults to None.\n    justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n    overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n    end (str, optional): Character to end text with. Defaults to \"\\\\n\".\n\nReturns:\n    Text: A Text instance with markup rendered.",
        "code": "def from_markup(\n        cls,\n        text: str,\n        *,\n        style: Union[str, Style] = \"\",\n        emoji: bool = True,\n        emoji_variant: Optional[EmojiVariant] = None,\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        end: str = \"\\n\",\n    ) -> \"Text\":\n        \"\"\"Create Text instance from markup.\n\n        Args:\n            text (str): A string containing console markup.\n            style (Union[str, Style], optional): Base style for text. Defaults to \"\".\n            emoji (bool, optional): Also render emoji code. Defaults to True.\n            emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults to None.\n            justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n            end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\n\n        Returns:\n            Text: A Text instance with markup rendered.\n        \"\"\"\n        from .markup import render\n\n        rendered_text = render(text, style, emoji=emoji, emoji_variant=emoji_variant)\n        rendered_text.justify = justify\n        rendered_text.overflow = overflow\n        rendered_text.end = end\n        return rendered_text",
        "line_count": 32,
        "needs_llm_summary": true
      },
      {
        "name": "from_ansi",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "text",
            "type": "str"
          }
        ],
        "return_type": "Text",
        "lineno": 294,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "no_wrap",
          "decoder.decode",
          "end",
          "overflow",
          "tab_size",
          "style",
          "AnsiDecoder",
          "justify",
          "text",
          "joiner.join",
          "Text"
        ],
        "docstring": "Create a Text object from a string containing ANSI escape codes.\n\nArgs:\n    text (str): A string containing escape codes.\n    style (Union[str, Style], optional): Base style for text. Defaults to \"\".\n    justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n    overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n    no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.\n    end (str, optional): Character to end text with. Defaults to \"\\\\n\".\n    tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to None.",
        "code": "def from_ansi(\n        cls,\n        text: str,\n        *,\n        style: Union[str, Style] = \"\",\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = None,\n        end: str = \"\\n\",\n        tab_size: Optional[int] = 8,\n    ) -> \"Text\":\n        \"\"\"Create a Text object from a string containing ANSI escape codes.\n\n        Args:\n            text (str): A string containing escape codes.\n            style (Union[str, Style], optional): Base style for text. Defaults to \"\".\n            justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n            no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.\n            end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\n            tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n        \"\"\"\n        from .ansi import AnsiDecoder\n\n        joiner = Text(\n            \"\\n\",\n            justify=justify,\n            overflow=overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n            style=style,\n        )\n        decoder = AnsiDecoder()\n        result = joiner.join(line for line in decoder.decode(text))\n        return result",
        "line_count": 36,
        "needs_llm_summary": true
      },
      {
        "name": "styled",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "text",
            "type": "str"
          },
          {
            "name": "style",
            "type": "StyleType"
          }
        ],
        "return_type": "Text",
        "lineno": 332,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "overflow",
          "style",
          "styled_text.stylize",
          "justify",
          "text",
          "cls"
        ],
        "docstring": "Construct a Text instance with a pre-applied styled. A style applied in this way won't be used\nto pad the text when it is justified.\n\nArgs:\n    text (str): A string containing console markup.\n    style (Union[str, Style]): Style to apply to the text. Defaults to \"\".\n    justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n    overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n\nReturns:\n    Text: A text instance with a style applied to the entire string.",
        "code": "def styled(\n        cls,\n        text: str,\n        style: StyleType = \"\",\n        *,\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n    ) -> \"Text\":\n        \"\"\"Construct a Text instance with a pre-applied styled. A style applied in this way won't be used\n        to pad the text when it is justified.\n\n        Args:\n            text (str): A string containing console markup.\n            style (Union[str, Style]): Style to apply to the text. Defaults to \"\".\n            justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n\n        Returns:\n            Text: A text instance with a style applied to the entire string.\n        \"\"\"\n        styled_text = cls(text, justify=justify, overflow=overflow)\n        styled_text.stylize(style)\n        return styled_text",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "assemble",
        "args": [
          {
            "name": "cls"
          }
        ],
        "return_type": "Text",
        "lineno": 357,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "no_wrap",
          "isinstance",
          "text.apply_meta",
          "meta",
          "text.append",
          "overflow",
          "end",
          "style",
          "tab_size",
          "append",
          "part",
          "justify",
          "cls",
          "Text"
        ],
        "docstring": "Construct a text instance by combining a sequence of strings with optional styles.\nThe positional arguments should be either strings, or a tuple of string + style.\n\nArgs:\n    style (Union[str, Style], optional): Base style for text. Defaults to \"\".\n    justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n    overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n    no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.\n    end (str, optional): Character to end text with. Defaults to \"\\\\n\".\n    tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n    meta (Dict[str, Any], optional). Meta data to apply to text, or None for no meta data. Default to None\n\nReturns:\n    Text: A new text instance.",
        "code": "def assemble(\n        cls,\n        *parts: Union[str, \"Text\", Tuple[str, StyleType]],\n        style: Union[str, Style] = \"\",\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = None,\n        end: str = \"\\n\",\n        tab_size: int = 8,\n        meta: Optional[Dict[str, Any]] = None,\n    ) -> \"Text\":\n        \"\"\"Construct a text instance by combining a sequence of strings with optional styles.\n        The positional arguments should be either strings, or a tuple of string + style.\n\n        Args:\n            style (Union[str, Style], optional): Base style for text. Defaults to \"\".\n            justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n            no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.\n            end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\n            tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n            meta (Dict[str, Any], optional). Meta data to apply to text, or None for no meta data. Default to None\n\n        Returns:\n            Text: A new text instance.\n        \"\"\"\n        text = cls(\n            style=style,\n            justify=justify,\n            overflow=overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n        )\n        append = text.append\n        _Text = Text\n        for part in parts:\n            if isinstance(part, (_Text, str)):\n                append(part)\n            else:\n                append(*part)\n        if meta:\n            text.apply_meta(meta)\n        return text",
        "line_count": 44,
        "needs_llm_summary": true
      },
      {
        "name": "plain",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 403,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "unknown.join",
          "self._text",
          "len"
        ],
        "docstring": "Get the text as a single string.",
        "code": "def plain(self) -> str:\n        \"\"\"Get the text as a single string.\"\"\"\n        if len(self._text) != 1:\n            self._text[:] = [\"\".join(self._text)]\n        return self._text[0]",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "plain",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "new_text",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 410,
        "decorators": [
          {
            "name": "plain.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "sanitized_text",
          "strip_control_codes",
          "self._length",
          "self._trim_spans",
          "new_text",
          "len"
        ],
        "docstring": "Set the text to a new value.",
        "code": "def plain(self, new_text: str) -> None:\n        \"\"\"Set the text to a new value.\"\"\"\n        if new_text != self.plain:\n            sanitized_text = strip_control_codes(new_text)\n            self._text[:] = [sanitized_text]\n            old_length = self._length\n            self._length = len(sanitized_text)\n            if old_length > self._length:\n                self._trim_spans()",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "spans",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "List[Span]",
        "lineno": 421,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Get a reference to the internal list of spans.",
        "code": "def spans(self) -> List[Span]:\n        \"\"\"Get a reference to the internal list of spans.\"\"\"\n        return self._spans",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "spans",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "spans",
            "type": "List[Span]"
          }
        ],
        "return_type": "None",
        "lineno": 426,
        "decorators": [
          {
            "name": "spans.setter",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [],
        "docstring": "Set spans.",
        "code": "def spans(self, spans: List[Span]) -> None:\n        \"\"\"Set spans.\"\"\"\n        self._spans = spans[:]",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "blank_copy",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "plain",
            "type": "str"
          }
        ],
        "return_type": "Text",
        "lineno": 430,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "self.overflow",
          "self.justify",
          "self.tab_size",
          "plain",
          "self.no_wrap",
          "self.end",
          "Text"
        ],
        "docstring": "Return a new Text instance with copied metadata (but not the string or spans).",
        "code": "def blank_copy(self, plain: str = \"\") -> \"Text\":\n        \"\"\"Return a new Text instance with copied metadata (but not the string or spans).\"\"\"\n        copy_self = Text(\n            plain,\n            style=self.style,\n            justify=self.justify,\n            overflow=self.overflow,\n            no_wrap=self.no_wrap,\n            end=self.end,\n            tab_size=self.tab_size,\n        )\n        return copy_self",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "copy",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "Text",
        "lineno": 443,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "self.overflow",
          "self.plain",
          "self.justify",
          "self.tab_size",
          "self.no_wrap",
          "self.end",
          "self._spans",
          "Text"
        ],
        "docstring": "Return a copy of this instance.",
        "code": "def copy(self) -> \"Text\":\n        \"\"\"Return a copy of this instance.\"\"\"\n        copy_self = Text(\n            self.plain,\n            style=self.style,\n            justify=self.justify,\n            overflow=self.overflow,\n            no_wrap=self.no_wrap,\n            end=self.end,\n            tab_size=self.tab_size,\n        )\n        copy_self._spans[:] = self._spans\n        return copy_self",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "stylize",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "style",
            "type": "Union[str, Style]"
          },
          {
            "name": "start",
            "type": "int"
          },
          {
            "name": "end",
            "type": "Optional[int]"
          }
        ],
        "return_type": "None",
        "lineno": 457,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "end",
          "style",
          "Span",
          "length",
          "start",
          "self._spans.append",
          "len",
          "self"
        ],
        "docstring": "Apply a style to the text, or a portion of the text.\n\nArgs:\n    style (Union[str, Style]): Style instance or style definition to apply.\n    start (int): Start offset (negative indexing is supported). Defaults to 0.\n    end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.",
        "code": "def stylize(\n        self,\n        style: Union[str, Style],\n        start: int = 0,\n        end: Optional[int] = None,\n    ) -> None:\n        \"\"\"Apply a style to the text, or a portion of the text.\n\n        Args:\n            style (Union[str, Style]): Style instance or style definition to apply.\n            start (int): Start offset (negative indexing is supported). Defaults to 0.\n            end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.\n        \"\"\"\n        if style:\n            length = len(self)\n            if start < 0:\n                start = length + start\n            if end is None:\n                end = length\n            if end < 0:\n                end = length + end\n            if start >= length or end <= start:\n                # Span not in text or not valid\n                return\n            self._spans.append(Span(start, min(length, end), style))",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "stylize_before",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "style",
            "type": "Union[str, Style]"
          },
          {
            "name": "start",
            "type": "int"
          },
          {
            "name": "end",
            "type": "Optional[int]"
          }
        ],
        "return_type": "None",
        "lineno": 483,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "self._spans.insert",
          "end",
          "style",
          "Span",
          "length",
          "start",
          "len",
          "self"
        ],
        "docstring": "Apply a style to the text, or a portion of the text. Styles will be applied before other styles already present.\n\nArgs:\n    style (Union[str, Style]): Style instance or style definition to apply.\n    start (int): Start offset (negative indexing is supported). Defaults to 0.\n    end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.",
        "code": "def stylize_before(\n        self,\n        style: Union[str, Style],\n        start: int = 0,\n        end: Optional[int] = None,\n    ) -> None:\n        \"\"\"Apply a style to the text, or a portion of the text. Styles will be applied before other styles already present.\n\n        Args:\n            style (Union[str, Style]): Style instance or style definition to apply.\n            start (int): Start offset (negative indexing is supported). Defaults to 0.\n            end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.\n        \"\"\"\n        if style:\n            length = len(self)\n            if start < 0:\n                start = length + start\n            if end is None:\n                end = length\n            if end < 0:\n                end = length + end\n            if start >= length or end <= start:\n                # Span not in text or not valid\n                return\n            self._spans.insert(0, Span(start, min(length, end), style))",
        "line_count": 25,
        "needs_llm_summary": true
      },
      {
        "name": "apply_meta",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "meta",
            "type": "Dict[str, Any]"
          },
          {
            "name": "start",
            "type": "int"
          },
          {
            "name": "end",
            "type": "Optional[int]"
          }
        ],
        "return_type": "None",
        "lineno": 509,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Style.from_meta",
          "meta",
          "end",
          "style",
          "self.stylize",
          "start"
        ],
        "docstring": "Apply metadata to the text, or a portion of the text.\n\nArgs:\n    meta (Dict[str, Any]): A dict of meta information.\n    start (int): Start offset (negative indexing is supported). Defaults to 0.\n    end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.",
        "code": "def apply_meta(\n        self, meta: Dict[str, Any], start: int = 0, end: Optional[int] = None\n    ) -> None:\n        \"\"\"Apply metadata to the text, or a portion of the text.\n\n        Args:\n            meta (Dict[str, Any]): A dict of meta information.\n            start (int): Start offset (negative indexing is supported). Defaults to 0.\n            end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.\n\n        \"\"\"\n        style = Style.from_meta(meta)\n        self.stylize(style, start=start, end=end)",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "on",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "meta",
            "type": "Optional[Dict[str, Any]]"
          }
        ],
        "return_type": "Text",
        "lineno": 523,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Style.from_meta",
          "meta",
          "handlers.items",
          "self.stylize",
          "meta.update"
        ],
        "docstring": "Apply event handlers (used by Textual project).\n\nExample:\n    >>> from rich.text import Text\n    >>> text = Text(\"hello world\")\n    >>> text.on(click=\"view.toggle('world')\")\n\nArgs:\n    meta (Dict[str, Any]): Mapping of meta information.\n    **handlers: Keyword args are prefixed with \"@\" to defined handlers.\n\nReturns:\n    Text: Self is returned to method may be chained.",
        "code": "def on(self, meta: Optional[Dict[str, Any]] = None, **handlers: Any) -> \"Text\":\n        \"\"\"Apply event handlers (used by Textual project).\n\n        Example:\n            >>> from rich.text import Text\n            >>> text = Text(\"hello world\")\n            >>> text.on(click=\"view.toggle('world')\")\n\n        Args:\n            meta (Dict[str, Any]): Mapping of meta information.\n            **handlers: Keyword args are prefixed with \"@\" to defined handlers.\n\n        Returns:\n            Text: Self is returned to method may be chained.\n        \"\"\"\n        meta = {} if meta is None else meta\n        meta.update({f\"@{key}\": value for key, value in handlers.items()})\n        self.stylize(Style.from_meta(meta))\n        return self",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "remove_suffix",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "suffix",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 543,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain.endswith",
          "self.right_crop",
          "suffix",
          "len"
        ],
        "docstring": "Remove a suffix if it exists.\n\nArgs:\n    suffix (str): Suffix to remove.",
        "code": "def remove_suffix(self, suffix: str) -> None:\n        \"\"\"Remove a suffix if it exists.\n\n        Args:\n            suffix (str): Suffix to remove.\n        \"\"\"\n        if self.plain.endswith(suffix):\n            self.right_crop(len(suffix))",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "get_style_at_offset",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "offset",
            "type": "int"
          }
        ],
        "return_type": "Style",
        "lineno": 552,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.style",
          "get_style",
          "console.get_style",
          "span_style",
          "unknown.copy",
          "len",
          "self"
        ],
        "docstring": "Get the style of a character at give offset.\n\nArgs:\n    console (~Console): Console where text will be rendered.\n    offset (int): Offset in to text (negative indexing supported)\n\nReturns:\n    Style: A Style instance.",
        "code": "def get_style_at_offset(self, console: \"Console\", offset: int) -> Style:\n        \"\"\"Get the style of a character at give offset.\n\n        Args:\n            console (~Console): Console where text will be rendered.\n            offset (int): Offset in to text (negative indexing supported)\n\n        Returns:\n            Style: A Style instance.\n        \"\"\"\n        # TODO: This is a little inefficient, it is only used by full justify\n        if offset < 0:\n            offset = len(self) + offset\n        get_style = console.get_style\n        style = get_style(self.style).copy()\n        for start, end, span_style in self._spans:\n            if end > offset >= start:\n                style += get_style(span_style, default=\"\")\n        return style",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "extend_style",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "spaces",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 572,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.spans",
          "self._text.append",
          "new_spaces",
          "span.extend",
          "spaces",
          "len",
          "self"
        ],
        "docstring": "Extend the Text given number of spaces where the spaces have the same style as the last character.\n\nArgs:\n    spaces (int): Number of spaces to add to the Text.",
        "code": "def extend_style(self, spaces: int) -> None:\n        \"\"\"Extend the Text given number of spaces where the spaces have the same style as the last character.\n\n        Args:\n            spaces (int): Number of spaces to add to the Text.\n        \"\"\"\n        if spaces <= 0:\n            return\n        spans = self.spans\n        new_spaces = \" \" * spaces\n        if spans:\n            end_offset = len(self)\n            self._spans[:] = [\n                span.extend(spaces) if span.end >= end_offset else span\n                for span in spans\n            ]\n            self._text.append(new_spaces)\n            self._length += spaces\n        else:\n            self.plain += new_spaces",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "highlight_regex",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "re_highlight",
            "type": "Union[Pattern[str], str]"
          },
          {
            "name": "style",
            "type": "Optional[Union[GetStyleCallable, StyleType]]"
          }
        ],
        "return_type": "int",
        "lineno": 593,
        "decorators": [],
        "is_async": false,
        "calls": [
          "callable",
          "re_highlight",
          "end",
          "style",
          "unknown.keys",
          "re.compile",
          "self.plain",
          "_Span",
          "match.span",
          "str",
          "name",
          "Span",
          "re_highlight.finditer",
          "get_span",
          "plain",
          "isinstance",
          "append_span",
          "self._spans.append",
          "start",
          "match_style",
          "match.groupdict"
        ],
        "docstring": "Highlight text with a regular expression, where group names are\ntranslated to styles.\n\nArgs:\n    re_highlight (Union[re.Pattern, str]): A regular expression object or string.\n    style (Union[GetStyleCallable, StyleType]): Optional style to apply to whole match, or a callable\n        which accepts the matched text and returns a style. Defaults to None.\n    style_prefix (str, optional): Optional prefix to add to style group names.\n\nReturns:\n    int: Number of regex matches",
        "code": "def highlight_regex(\n        self,\n        re_highlight: Union[Pattern[str], str],\n        style: Optional[Union[GetStyleCallable, StyleType]] = None,\n        *,\n        style_prefix: str = \"\",\n    ) -> int:\n        \"\"\"Highlight text with a regular expression, where group names are\n        translated to styles.\n\n        Args:\n            re_highlight (Union[re.Pattern, str]): A regular expression object or string.\n            style (Union[GetStyleCallable, StyleType]): Optional style to apply to whole match, or a callable\n                which accepts the matched text and returns a style. Defaults to None.\n            style_prefix (str, optional): Optional prefix to add to style group names.\n\n        Returns:\n            int: Number of regex matches\n        \"\"\"\n        count = 0\n        append_span = self._spans.append\n        _Span = Span\n        plain = self.plain\n        if isinstance(re_highlight, str):\n            re_highlight = re.compile(re_highlight)\n        for match in re_highlight.finditer(plain):\n            get_span = match.span\n            if style:\n                start, end = get_span()\n                match_style = style(plain[start:end]) if callable(style) else style\n                if match_style is not None and end > start:\n                    append_span(_Span(start, end, match_style))\n\n            count += 1\n            for name in match.groupdict().keys():\n                start, end = get_span(name)\n                if start != -1 and end > start:\n                    append_span(_Span(start, end, f\"{style_prefix}{name}\"))\n        return count",
        "line_count": 39,
        "needs_llm_summary": true
      },
      {
        "name": "highlight_words",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "words",
            "type": "Iterable[str]"
          },
          {
            "name": "style",
            "type": "Union[str, Style]"
          }
        ],
        "return_type": "int",
        "lineno": 633,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain",
          "re.finditer",
          "end",
          "word",
          "re.escape",
          "style",
          "Span",
          "unknown.join",
          "re_words",
          "_Span",
          "start",
          "match.span",
          "add_span",
          "self._spans.append"
        ],
        "docstring": "Highlight words with a style.\n\nArgs:\n    words (Iterable[str]): Words to highlight.\n    style (Union[str, Style]): Style to apply.\n    case_sensitive (bool, optional): Enable case sensitive matching. Defaults to True.\n\nReturns:\n    int: Number of words highlighted.",
        "code": "def highlight_words(\n        self,\n        words: Iterable[str],\n        style: Union[str, Style],\n        *,\n        case_sensitive: bool = True,\n    ) -> int:\n        \"\"\"Highlight words with a style.\n\n        Args:\n            words (Iterable[str]): Words to highlight.\n            style (Union[str, Style]): Style to apply.\n            case_sensitive (bool, optional): Enable case sensitive matching. Defaults to True.\n\n        Returns:\n            int: Number of words highlighted.\n        \"\"\"\n        re_words = \"|\".join(re.escape(word) for word in words)\n        add_span = self._spans.append\n        count = 0\n        _Span = Span\n        for match in re.finditer(\n            re_words, self.plain, flags=0 if case_sensitive else re.IGNORECASE\n        ):\n            start, end = match.span(0)\n            add_span(_Span(start, end, style))\n            count += 1\n        return count",
        "line_count": 28,
        "needs_llm_summary": true
      },
      {
        "name": "rstrip",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 662,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain.rstrip"
        ],
        "docstring": "Strip whitespace from end of text.",
        "code": "def rstrip(self) -> None:\n        \"\"\"Strip whitespace from end of text.\"\"\"\n        self.plain = self.plain.rstrip()",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "rstrip_end",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "size",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 666,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "self.plain",
          "whitespace_match.group",
          "whitespace_count",
          "excess",
          "_re_whitespace.search",
          "self.right_crop",
          "len",
          "self"
        ],
        "docstring": "Remove whitespace beyond a certain width at the end of the text.\n\nArgs:\n    size (int): The desired size of the text.",
        "code": "def rstrip_end(self, size: int) -> None:\n        \"\"\"Remove whitespace beyond a certain width at the end of the text.\n\n        Args:\n            size (int): The desired size of the text.\n        \"\"\"\n        text_length = len(self)\n        if text_length > size:\n            excess = text_length - size\n            whitespace_match = _re_whitespace.search(self.plain)\n            if whitespace_match is not None:\n                whitespace_count = len(whitespace_match.group(0))\n                self.right_crop(min(whitespace_count, excess))",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "set_length",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "new_length",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 680,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.pad_right",
          "self.right_crop",
          "len",
          "self"
        ],
        "docstring": "Set new length of the text, clipping or padding is required.",
        "code": "def set_length(self, new_length: int) -> None:\n        \"\"\"Set new length of the text, clipping or padding is required.\"\"\"\n        length = len(self)\n        if length != new_length:\n            if length < new_length:\n                self.pad_right(new_length - length)\n            else:\n                self.right_crop(length - new_length)",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 689,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "self.wrap",
          "overflow",
          "options.max_width",
          "unknown.join",
          "options.no_wrap",
          "justify",
          "pick_bool",
          "self.no_wrap",
          "self.end",
          "all_lines.render",
          "console",
          "Text"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Iterable[Segment]:\n        tab_size: int = console.tab_size if self.tab_size is None else self.tab_size\n        justify = self.justify or options.justify or DEFAULT_JUSTIFY\n\n        overflow = self.overflow or options.overflow or DEFAULT_OVERFLOW\n\n        lines = self.wrap(\n            console,\n            options.max_width,\n            justify=justify,\n            overflow=overflow,\n            tab_size=tab_size or 8,\n            no_wrap=pick_bool(self.no_wrap, options.no_wrap, False),\n        )\n        all_lines = Text(\"\\n\").join(lines)\n        yield from all_lines.render(console, end=self.end)",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 708,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain",
          "line",
          "word",
          "text.splitlines",
          "text.split",
          "min_text_width",
          "Measurement",
          "max",
          "cell_len",
          "max_text_width"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        text = self.plain\n        lines = text.splitlines()\n        max_text_width = max(cell_len(line) for line in lines) if lines else 0\n        words = text.split()\n        min_text_width = (\n            max(cell_len(word) for word in words) if words else max_text_width\n        )\n        return Measurement(min_text_width, max_text_width)",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "render",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "end",
            "type": "str"
          }
        ],
        "return_type": "Iterable[Segment]",
        "lineno": 720,
        "decorators": [],
        "is_async": false,
        "calls": [
          "get_current_style",
          "enumerate",
          "end",
          "Style.combine",
          "span.style",
          "spans.sort",
          "list",
          "Style.null",
          "itemgetter",
          "partial",
          "self.style",
          "self.plain",
          "console.get_style",
          "stack_append",
          "stack_pop",
          "sorted",
          "spans",
          "_Segment",
          "get_style",
          "style_cache_get",
          "current_style",
          "combine",
          "text",
          "style_id",
          "Segment",
          "self._spans",
          "stack",
          "zip",
          "len",
          "stack.remove",
          "style_cache.get",
          "tuple",
          "stack.append",
          "styles"
        ],
        "docstring": "Render the text as Segments.\n\nArgs:\n    console (Console): Console instance.\n    end (Optional[str], optional): Optional end character.\n\nReturns:\n    Iterable[Segment]: Result of render that may be written to the console.",
        "code": "def render(self, console: \"Console\", end: str = \"\") -> Iterable[\"Segment\"]:\n        \"\"\"Render the text as Segments.\n\n        Args:\n            console (Console): Console instance.\n            end (Optional[str], optional): Optional end character.\n\n        Returns:\n            Iterable[Segment]: Result of render that may be written to the console.\n        \"\"\"\n        _Segment = Segment\n        text = self.plain\n        if not self._spans:\n            yield Segment(text)\n            if end:\n                yield _Segment(end)\n            return\n        get_style = partial(console.get_style, default=Style.null())\n\n        enumerated_spans = list(enumerate(self._spans, 1))\n        style_map = {index: get_style(span.style) for index, span in enumerated_spans}\n        style_map[0] = get_style(self.style)\n\n        spans = [\n            (0, False, 0),\n            *((span.start, False, index) for index, span in enumerated_spans),\n            *((span.end, True, index) for index, span in enumerated_spans),\n            (len(text), True, 0),\n        ]\n        spans.sort(key=itemgetter(0, 1))\n\n        stack: List[int] = []\n        stack_append = stack.append\n        stack_pop = stack.remove\n\n        style_cache: Dict[Tuple[Style, ...], Style] = {}\n        style_cache_get = style_cache.get\n        combine = Style.combine\n\n        def get_current_style() -> Style:\n            \"\"\"Construct current style from stack.\"\"\"\n            styles = tuple(style_map[_style_id] for _style_id in sorted(stack))\n            cached_style = style_cache_get(styles)\n            if cached_style is not None:\n                return cached_style\n            current_style = combine(styles)\n            style_cache[styles] = current_style\n            return current_style\n\n        for (offset, leaving, style_id), (next_offset, _, _) in zip(spans, spans[1:]):\n            if leaving:\n                stack_pop(style_id)\n            else:\n                stack_append(style_id)\n            if next_offset > offset:\n                yield _Segment(text[offset:next_offset], get_current_style())\n        if end:\n            yield _Segment(end)",
        "line_count": 58,
        "needs_llm_summary": true
      },
      {
        "name": "join",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "lines",
            "type": "Iterable[Text]"
          }
        ],
        "return_type": "Text",
        "lineno": 779,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines",
          "append_span",
          "style",
          "self.blank_copy",
          "Span",
          "new_text._text.extend",
          "text.style",
          "text._text",
          "loop_last",
          "iter_text",
          "new_text._spans.extend",
          "extend_text",
          "text",
          "_Span",
          "offset",
          "extend_spans",
          "len",
          "new_text._spans.append"
        ],
        "docstring": "Join text together with this instance as the separator.\n\nArgs:\n    lines (Iterable[Text]): An iterable of Text instances to join.\n\nReturns:\n    Text: A new text instance containing join text.",
        "code": "def join(self, lines: Iterable[\"Text\"]) -> \"Text\":\n        \"\"\"Join text together with this instance as the separator.\n\n        Args:\n            lines (Iterable[Text]): An iterable of Text instances to join.\n\n        Returns:\n            Text: A new text instance containing join text.\n        \"\"\"\n\n        new_text = self.blank_copy()\n\n        def iter_text() -> Iterable[\"Text\"]:\n            if self.plain:\n                for last, line in loop_last(lines):\n                    yield line\n                    if not last:\n                        yield self\n            else:\n                yield from lines\n\n        extend_text = new_text._text.extend\n        append_span = new_text._spans.append\n        extend_spans = new_text._spans.extend\n        offset = 0\n        _Span = Span\n\n        for text in iter_text():\n            extend_text(text._text)\n            if text.style:\n                append_span(_Span(offset, offset + len(text), text.style))\n            extend_spans(\n                _Span(offset + start, offset + end, style)\n                for start, end, style in text._spans\n            )\n            offset += len(text)\n        new_text._length = offset\n        return new_text",
        "line_count": 38,
        "needs_llm_summary": true
      },
      {
        "name": "expand_tabs",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "tab_size",
            "type": "Optional[int]"
          }
        ],
        "return_type": "None",
        "lineno": 818,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain",
          "append",
          "part.extend_style",
          "line",
          "part",
          "new_text.append",
          "self.tab_size",
          "unknown.join",
          "self.split",
          "part.plain.endswith",
          "line.split",
          "spaces",
          "Text",
          "result._spans",
          "new_text",
          "len"
        ],
        "docstring": "Converts tabs to spaces.\n\nArgs:\n    tab_size (int, optional): Size of tabs. Defaults to 8.",
        "code": "def expand_tabs(self, tab_size: Optional[int] = None) -> None:\n        \"\"\"Converts tabs to spaces.\n\n        Args:\n            tab_size (int, optional): Size of tabs. Defaults to 8.\n\n        \"\"\"\n        if \"\\t\" not in self.plain:\n            return\n        if tab_size is None:\n            tab_size = self.tab_size\n        if tab_size is None:\n            tab_size = 8\n\n        new_text: List[Text] = []\n        append = new_text.append\n\n        for line in self.split(\"\\n\", include_separator=True):\n            if \"\\t\" not in line.plain:\n                append(line)\n            else:\n                cell_position = 0\n                parts = line.split(\"\\t\", include_separator=True)\n                for part in parts:\n                    if part.plain.endswith(\"\\t\"):\n                        part._text[-1] = part._text[-1][:-1] + \" \"\n                        cell_position += part.cell_len\n                        tab_remainder = cell_position % tab_size\n                        if tab_remainder:\n                            spaces = tab_size - tab_remainder\n                            part.extend_style(spaces)\n                            cell_position += spaces\n                    else:\n                        cell_position += part.cell_len\n                    append(part)\n\n        result = Text(\"\").join(new_text)\n\n        self._text = [result.plain]\n        self._length = len(self.plain)\n        self._spans[:] = result._spans",
        "line_count": 41,
        "needs_llm_summary": true
      },
      {
        "name": "truncate",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "max_width",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 860,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain",
          "max_width",
          "set_cell_size",
          "cell_len",
          "len"
        ],
        "docstring": "Truncate text if it is longer that a given width.\n\nArgs:\n    max_width (int): Maximum number of characters in text.\n    overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to None, to use self.overflow.\n    pad (bool, optional): Pad with spaces if the length is less than max_width. Defaults to False.",
        "code": "def truncate(\n        self,\n        max_width: int,\n        *,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        pad: bool = False,\n    ) -> None:\n        \"\"\"Truncate text if it is longer that a given width.\n\n        Args:\n            max_width (int): Maximum number of characters in text.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to None, to use self.overflow.\n            pad (bool, optional): Pad with spaces if the length is less than max_width. Defaults to False.\n        \"\"\"\n        _overflow = overflow or self.overflow or DEFAULT_OVERFLOW\n        if _overflow != \"ignore\":\n            length = cell_len(self.plain)\n            if length > max_width:\n                if _overflow == \"ellipsis\":\n                    self.plain = set_cell_size(self.plain, max_width - 1) + \"\u2026\"\n                else:\n                    self.plain = set_cell_size(self.plain, max_width)\n            if pad and length < max_width:\n                spaces = max_width - length\n                self._text = [f\"{self.plain}{' ' * spaces}\"]\n                self._length = len(self.plain)",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "_trim_spans",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 887,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "self.plain",
          "span.style",
          "span.end",
          "Span",
          "span.start",
          "max_offset",
          "_Span",
          "len"
        ],
        "docstring": "Remove or modify any spans that are over the end of the text.",
        "code": "def _trim_spans(self) -> None:\n        \"\"\"Remove or modify any spans that are over the end of the text.\"\"\"\n        max_offset = len(self.plain)\n        _Span = Span\n        self._spans[:] = [\n            (\n                span\n                if span.end < max_offset\n                else _Span(span.start, min(max_offset, span.end), span.style)\n            )\n            for span in self._spans\n            if span.start < max_offset\n        ]",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "pad",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "count",
            "type": "int"
          },
          {
            "name": "character",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 901,
        "decorators": [],
        "is_async": false,
        "calls": [
          "character",
          "style",
          "Span",
          "_Span",
          "len"
        ],
        "docstring": "Pad left and right with a given number of characters.\n\nArgs:\n    count (int): Width of padding.\n    character (str): The character to pad with. Must be a string of length 1.",
        "code": "def pad(self, count: int, character: str = \" \") -> None:\n        \"\"\"Pad left and right with a given number of characters.\n\n        Args:\n            count (int): Width of padding.\n            character (str): The character to pad with. Must be a string of length 1.\n        \"\"\"\n        assert len(character) == 1, \"Character must be a string of length 1\"\n        if count:\n            pad_characters = character * count\n            self.plain = f\"{pad_characters}{self.plain}{pad_characters}\"\n            _Span = Span\n            self._spans[:] = [\n                _Span(start + count, end + count, style)\n                for start, end, style in self._spans\n            ]",
        "line_count": 16,
        "needs_llm_summary": true
      },
      {
        "name": "pad_left",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "count",
            "type": "int"
          },
          {
            "name": "character",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 918,
        "decorators": [],
        "is_async": false,
        "calls": [
          "character",
          "style",
          "Span",
          "_Span",
          "len"
        ],
        "docstring": "Pad the left with a given character.\n\nArgs:\n    count (int): Number of characters to pad.\n    character (str, optional): Character to pad with. Defaults to \" \".",
        "code": "def pad_left(self, count: int, character: str = \" \") -> None:\n        \"\"\"Pad the left with a given character.\n\n        Args:\n            count (int): Number of characters to pad.\n            character (str, optional): Character to pad with. Defaults to \" \".\n        \"\"\"\n        assert len(character) == 1, \"Character must be a string of length 1\"\n        if count:\n            self.plain = f\"{character * count}{self.plain}\"\n            _Span = Span\n            self._spans[:] = [\n                _Span(start + count, end + count, style)\n                for start, end, style in self._spans\n            ]",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "pad_right",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "count",
            "type": "int"
          },
          {
            "name": "character",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 934,
        "decorators": [],
        "is_async": false,
        "calls": [
          "character",
          "len"
        ],
        "docstring": "Pad the right with a given character.\n\nArgs:\n    count (int): Number of characters to pad.\n    character (str, optional): Character to pad with. Defaults to \" \".",
        "code": "def pad_right(self, count: int, character: str = \" \") -> None:\n        \"\"\"Pad the right with a given character.\n\n        Args:\n            count (int): Number of characters to pad.\n            character (str, optional): Character to pad with. Defaults to \" \".\n        \"\"\"\n        assert len(character) == 1, \"Character must be a string of length 1\"\n        if count:\n            self.plain = f\"{self.plain}{character * count}\"",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "align",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "align",
            "type": "AlignMethod"
          },
          {
            "name": "width",
            "type": "int"
          },
          {
            "name": "character",
            "type": "str"
          }
        ],
        "return_type": "None",
        "lineno": 945,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain",
          "excess_space",
          "character",
          "left",
          "width",
          "cell_len",
          "self.truncate",
          "self.pad_left",
          "self.pad_right"
        ],
        "docstring": "Align text to a given width.\n\nArgs:\n    align (AlignMethod): One of \"left\", \"center\", or \"right\".\n    width (int): Desired width.\n    character (str, optional): Character to pad with. Defaults to \" \".",
        "code": "def align(self, align: AlignMethod, width: int, character: str = \" \") -> None:\n        \"\"\"Align text to a given width.\n\n        Args:\n            align (AlignMethod): One of \"left\", \"center\", or \"right\".\n            width (int): Desired width.\n            character (str, optional): Character to pad with. Defaults to \" \".\n        \"\"\"\n        self.truncate(width)\n        excess_space = width - cell_len(self.plain)\n        if excess_space:\n            if align == \"left\":\n                self.pad_right(excess_space, character)\n            elif align == \"center\":\n                left = excess_space // 2\n                self.pad_left(left, character)\n                self.pad_right(excess_space - left, character)\n            else:\n                self.pad_left(excess_space, character)",
        "line_count": 19,
        "needs_llm_summary": true
      },
      {
        "name": "append",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Union[Text, str]"
          },
          {
            "name": "style",
            "type": "Optional[Union[str, Style]]"
          }
        ],
        "return_type": "Text",
        "lineno": 965,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._text.append",
          "style",
          "text_length",
          "ValueError",
          "self._spans.extend",
          "_Span",
          "text._spans.copy",
          "Text",
          "str",
          "sanitized_text",
          "self._length",
          "Span",
          "text.style",
          "text",
          "TypeError",
          "len",
          "isinstance",
          "strip_control_codes",
          "self._spans.append",
          "offset",
          "text.plain",
          "self"
        ],
        "docstring": "Add text with an optional style.\n\nArgs:\n    text (Union[Text, str]): A str or Text to append.\n    style (str, optional): A style name. Defaults to None.\n\nReturns:\n    Text: Returns self for chaining.",
        "code": "def append(\n        self, text: Union[\"Text\", str], style: Optional[Union[str, \"Style\"]] = None\n    ) -> \"Text\":\n        \"\"\"Add text with an optional style.\n\n        Args:\n            text (Union[Text, str]): A str or Text to append.\n            style (str, optional): A style name. Defaults to None.\n\n        Returns:\n            Text: Returns self for chaining.\n        \"\"\"\n\n        if not isinstance(text, (str, Text)):\n            raise TypeError(\"Only str or Text can be appended to Text\")\n\n        if len(text):\n            if isinstance(text, str):\n                sanitized_text = strip_control_codes(text)\n                self._text.append(sanitized_text)\n                offset = len(self)\n                text_length = len(sanitized_text)\n                if style:\n                    self._spans.append(Span(offset, offset + text_length, style))\n                self._length += text_length\n            elif isinstance(text, Text):\n                _Span = Span\n                if style is not None:\n                    raise ValueError(\n                        \"style must not be set when appending Text instance\"\n                    )\n                text_length = self._length\n                if text.style:\n                    self._spans.append(\n                        _Span(text_length, text_length + len(text), text.style)\n                    )\n                self._text.append(text.plain)\n                self._spans.extend(\n                    _Span(start + text_length, end + text_length, style)\n                    for start, end, style in text._spans.copy()\n                )\n                self._length += len(text)\n        return self",
        "line_count": 43,
        "needs_llm_summary": true
      },
      {
        "name": "append_text",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Text"
          }
        ],
        "return_type": "Text",
        "lineno": 1009,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._text.append",
          "text_length",
          "style",
          "self._spans.append",
          "self._length",
          "Span",
          "text.style",
          "self._spans.extend",
          "text",
          "_Span",
          "text._spans.copy",
          "text.plain",
          "len"
        ],
        "docstring": "Append another Text instance. This method is more performant that Text.append, but\nonly works for Text.\n\nArgs:\n    text (Text): The Text instance to append to this instance.\n\nReturns:\n    Text: Returns self for chaining.",
        "code": "def append_text(self, text: \"Text\") -> \"Text\":\n        \"\"\"Append another Text instance. This method is more performant that Text.append, but\n        only works for Text.\n\n        Args:\n            text (Text): The Text instance to append to this instance.\n\n        Returns:\n            Text: Returns self for chaining.\n        \"\"\"\n        _Span = Span\n        text_length = self._length\n        if text.style:\n            self._spans.append(_Span(text_length, text_length + len(text), text.style))\n        self._text.append(text.plain)\n        self._spans.extend(\n            _Span(start + text_length, end + text_length, style)\n            for start, end, style in text._spans.copy()\n        )\n        self._length += len(text)\n        return self",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "append_tokens",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "tokens",
            "type": "Iterable[Tuple[str, Optional[StyleType]]]"
          }
        ],
        "return_type": "Text",
        "lineno": 1031,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self._text.append",
          "content",
          "strip_control_codes",
          "append_span",
          "style",
          "append_text",
          "Span",
          "_Span",
          "offset",
          "self._spans.append",
          "len",
          "self"
        ],
        "docstring": "Append iterable of str and style. Style may be a Style instance or a str style definition.\n\nArgs:\n    tokens (Iterable[Tuple[str, Optional[StyleType]]]): An iterable of tuples containing str content and style.\n\nReturns:\n    Text: Returns self for chaining.",
        "code": "def append_tokens(\n        self, tokens: Iterable[Tuple[str, Optional[StyleType]]]\n    ) -> \"Text\":\n        \"\"\"Append iterable of str and style. Style may be a Style instance or a str style definition.\n\n        Args:\n            tokens (Iterable[Tuple[str, Optional[StyleType]]]): An iterable of tuples containing str content and style.\n\n        Returns:\n            Text: Returns self for chaining.\n        \"\"\"\n        append_text = self._text.append\n        append_span = self._spans.append\n        _Span = Span\n        offset = len(self)\n        for content, style in tokens:\n            content = strip_control_codes(content)\n            append_text(content)\n            if style:\n                append_span(_Span(offset, offset + len(content), style))\n            offset += len(content)\n        self._length = offset\n        return self",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "copy_styles",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "text",
            "type": "Text"
          }
        ],
        "return_type": "None",
        "lineno": 1055,
        "decorators": [],
        "is_async": false,
        "calls": [
          "text._spans",
          "self._spans.extend"
        ],
        "docstring": "Copy styles from another Text instance.\n\nArgs:\n    text (Text): A Text instance to copy styles from, must be the same length.",
        "code": "def copy_styles(self, text: \"Text\") -> None:\n        \"\"\"Copy styles from another Text instance.\n\n        Args:\n            text (Text): A Text instance to copy styles from, must be the same length.\n        \"\"\"\n        self._spans.extend(text._spans)",
        "line_count": 7,
        "needs_llm_summary": true
      },
      {
        "name": "split",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "separator",
            "type": "str"
          }
        ],
        "return_type": "Lines",
        "lineno": 1063,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain",
          "self.divide",
          "re.finditer",
          "lines.pop",
          "re.escape",
          "text.endswith",
          "match.end",
          "flatten_spans",
          "Lines",
          "text",
          "match.span",
          "self.copy",
          "separator"
        ],
        "docstring": "Split rich text in to lines, preserving styles.\n\nArgs:\n    separator (str, optional): String to split on. Defaults to \"\\\\n\".\n    include_separator (bool, optional): Include the separator in the lines. Defaults to False.\n    allow_blank (bool, optional): Return a blank line if the text ends with a separator. Defaults to False.\n\nReturns:\n    List[RichText]: A list of rich text, one per line of the original.",
        "code": "def split(\n        self,\n        separator: str = \"\\n\",\n        *,\n        include_separator: bool = False,\n        allow_blank: bool = False,\n    ) -> Lines:\n        \"\"\"Split rich text in to lines, preserving styles.\n\n        Args:\n            separator (str, optional): String to split on. Defaults to \"\\\\\\\\n\".\n            include_separator (bool, optional): Include the separator in the lines. Defaults to False.\n            allow_blank (bool, optional): Return a blank line if the text ends with a separator. Defaults to False.\n\n        Returns:\n            List[RichText]: A list of rich text, one per line of the original.\n        \"\"\"\n        assert separator, \"separator must not be empty\"\n\n        text = self.plain\n        if separator not in text:\n            return Lines([self.copy()])\n\n        if include_separator:\n            lines = self.divide(\n                match.end() for match in re.finditer(re.escape(separator), text)\n            )\n        else:\n\n            def flatten_spans() -> Iterable[int]:\n                for match in re.finditer(re.escape(separator), text):\n                    start, end = match.span()\n                    yield start\n                    yield end\n\n            lines = Lines(\n                line for line in self.divide(flatten_spans()) if line.plain != separator\n            )\n\n        if not allow_blank and text.endswith(separator):\n            lines.pop()\n\n        return lines",
        "line_count": 43,
        "needs_llm_summary": true
      },
      {
        "name": "divide",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "offsets",
            "type": "Iterable[int]"
          }
        ],
        "return_type": "Lines",
        "lineno": 1107,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.overflow",
          "style",
          "self.justify",
          "list",
          "self.copy",
          "offsets",
          "self.style",
          "self.plain",
          "new_end",
          "Lines",
          "line_count",
          "line_ranges",
          "max",
          "_Span",
          "Text",
          "new_start",
          "Span",
          "text",
          "justify",
          "_Text",
          "zip",
          "len",
          "min",
          "range",
          "overflow",
          "divide_offsets",
          "start_line_no"
        ],
        "docstring": "Divide text in to a number of lines at given offsets.\n\nArgs:\n    offsets (Iterable[int]): Offsets used to divide text.\n\nReturns:\n    Lines: New RichText instances between offsets.",
        "code": "def divide(self, offsets: Iterable[int]) -> Lines:\n        \"\"\"Divide text in to a number of lines at given offsets.\n\n        Args:\n            offsets (Iterable[int]): Offsets used to divide text.\n\n        Returns:\n            Lines: New RichText instances between offsets.\n        \"\"\"\n        _offsets = list(offsets)\n\n        if not _offsets:\n            return Lines([self.copy()])\n\n        text = self.plain\n        text_length = len(text)\n        divide_offsets = [0, *_offsets, text_length]\n        line_ranges = list(zip(divide_offsets, divide_offsets[1:]))\n\n        style = self.style\n        justify = self.justify\n        overflow = self.overflow\n        _Text = Text\n        new_lines = Lines(\n            _Text(\n                text[start:end],\n                style=style,\n                justify=justify,\n                overflow=overflow,\n            )\n            for start, end in line_ranges\n        )\n        if not self._spans:\n            return new_lines\n\n        _line_appends = [line._spans.append for line in new_lines._lines]\n        line_count = len(line_ranges)\n        _Span = Span\n\n        for span_start, span_end, style in self._spans:\n            lower_bound = 0\n            upper_bound = line_count\n            start_line_no = (lower_bound + upper_bound) // 2\n\n            while True:\n                line_start, line_end = line_ranges[start_line_no]\n                if span_start < line_start:\n                    upper_bound = start_line_no - 1\n                elif span_start > line_end:\n                    lower_bound = start_line_no + 1\n                else:\n                    break\n                start_line_no = (lower_bound + upper_bound) // 2\n\n            if span_end < line_end:\n                end_line_no = start_line_no\n            else:\n                end_line_no = lower_bound = start_line_no\n                upper_bound = line_count\n\n                while True:\n                    line_start, line_end = line_ranges[end_line_no]\n                    if span_end < line_start:\n                        upper_bound = end_line_no - 1\n                    elif span_end > line_end:\n                        lower_bound = end_line_no + 1\n                    else:\n                        break\n                    end_line_no = (lower_bound + upper_bound) // 2\n\n            for line_no in range(start_line_no, end_line_no + 1):\n                line_start, line_end = line_ranges[line_no]\n                new_start = max(0, span_start - line_start)\n                new_end = min(span_end - line_start, line_end - line_start)\n                if new_end > new_start:\n                    _line_appends[line_no](_Span(new_start, new_end, style))\n\n        return new_lines",
        "line_count": 78,
        "needs_llm_summary": true
      },
      {
        "name": "right_crop",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "amount",
            "type": "int"
          }
        ],
        "return_type": "None",
        "lineno": 1186,
        "decorators": [],
        "is_async": false,
        "calls": [
          "min",
          "self.plain",
          "span.style",
          "span.end",
          "Span",
          "span.start",
          "max_offset",
          "_Span",
          "len"
        ],
        "docstring": "Remove a number of characters from the end of the text.",
        "code": "def right_crop(self, amount: int = 1) -> None:\n        \"\"\"Remove a number of characters from the end of the text.\"\"\"\n        max_offset = len(self.plain) - amount\n        _Span = Span\n        self._spans[:] = [\n            (\n                span\n                if span.end < max_offset\n                else _Span(span.start, min(max_offset, span.end), span.style)\n            )\n            for span in self._spans\n            if span.start < max_offset\n        ]\n        self._text = [self.plain[:-amount]]\n        self._length -= amount",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "wrap",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "Lines",
        "lineno": 1202,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line.divide",
          "line.truncate",
          "self.no_wrap",
          "offsets",
          "no_wrap",
          "lines.extend",
          "tab_size",
          "new_lines.justify",
          "Lines",
          "line.expand_tabs",
          "line.rstrip_end",
          "str",
          "line",
          "divide_line",
          "self.split",
          "width",
          "pick_bool",
          "console",
          "wrap_overflow",
          "wrap_justify",
          "new_lines"
        ],
        "docstring": "Word wrap the text.\n\nArgs:\n    console (Console): Console instance.\n    width (int): Number of cells available per line.\n    justify (str, optional): Justify method: \"default\", \"left\", \"center\", \"full\", \"right\". Defaults to \"default\".\n    overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to None.\n    tab_size (int, optional): Default tab size. Defaults to 8.\n    no_wrap (bool, optional): Disable wrapping, Defaults to False.\n\nReturns:\n    Lines: Number of lines.",
        "code": "def wrap(\n        self,\n        console: \"Console\",\n        width: int,\n        *,\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        tab_size: int = 8,\n        no_wrap: Optional[bool] = None,\n    ) -> Lines:\n        \"\"\"Word wrap the text.\n\n        Args:\n            console (Console): Console instance.\n            width (int): Number of cells available per line.\n            justify (str, optional): Justify method: \"default\", \"left\", \"center\", \"full\", \"right\". Defaults to \"default\".\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to None.\n            tab_size (int, optional): Default tab size. Defaults to 8.\n            no_wrap (bool, optional): Disable wrapping, Defaults to False.\n\n        Returns:\n            Lines: Number of lines.\n        \"\"\"\n        wrap_justify = justify or self.justify or DEFAULT_JUSTIFY\n        wrap_overflow = overflow or self.overflow or DEFAULT_OVERFLOW\n\n        no_wrap = pick_bool(no_wrap, self.no_wrap, False) or overflow == \"ignore\"\n\n        lines = Lines()\n        for line in self.split(allow_blank=True):\n            if \"\\t\" in line:\n                line.expand_tabs(tab_size)\n            if no_wrap:\n                new_lines = Lines([line])\n            else:\n                offsets = divide_line(str(line), width, fold=wrap_overflow == \"fold\")\n                new_lines = line.divide(offsets)\n            for line in new_lines:\n                line.rstrip_end(width)\n            if wrap_justify:\n                new_lines.justify(\n                    console, width, justify=wrap_justify, overflow=wrap_overflow\n                )\n            for line in new_lines:\n                line.truncate(width, overflow=wrap_overflow)\n            lines.extend(new_lines)\n        return lines",
        "line_count": 47,
        "needs_llm_summary": true
      },
      {
        "name": "fit",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "width",
            "type": "int"
          }
        ],
        "return_type": "Lines",
        "lineno": 1250,
        "decorators": [],
        "is_async": false,
        "calls": [
          "lines.append",
          "append",
          "line",
          "self.split",
          "width",
          "line.set_length",
          "Lines"
        ],
        "docstring": "Fit the text in to given width by chopping in to lines.\n\nArgs:\n    width (int): Maximum characters in a line.\n\nReturns:\n    Lines: Lines container.",
        "code": "def fit(self, width: int) -> Lines:\n        \"\"\"Fit the text in to given width by chopping in to lines.\n\n        Args:\n            width (int): Maximum characters in a line.\n\n        Returns:\n            Lines: Lines container.\n        \"\"\"\n        lines: Lines = Lines()\n        append = lines.append\n        for line in self.split():\n            line.set_length(width)\n            append(line)\n        return lines",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "detect_indentation",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "int",
        "lineno": 1266,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.plain",
          "re.finditer",
          "gcd",
          "re.MULTILINE",
          "reduce",
          "match.group",
          "len"
        ],
        "docstring": "Auto-detect indentation of code.\n\nReturns:\n    int: Number of spaces used to indent code.",
        "code": "def detect_indentation(self) -> int:\n        \"\"\"Auto-detect indentation of code.\n\n        Returns:\n            int: Number of spaces used to indent code.\n        \"\"\"\n\n        _indentations = {\n            len(match.group(1))\n            for match in re.finditer(r\"^( *)(.*)$\", self.plain, flags=re.MULTILINE)\n        }\n\n        try:\n            indentation = (\n                reduce(gcd, [indent for indent in _indentations if not indent % 2]) or 1\n            )\n        except TypeError:\n            indentation = 1\n\n        return indentation",
        "line_count": 20,
        "needs_llm_summary": true
      },
      {
        "name": "with_indent_guides",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "indent_size",
            "type": "Optional[int]"
          }
        ],
        "return_type": "Text",
        "lineno": 1287,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "new_lines.append",
          "re.compile",
          "add_line",
          "line.stylize",
          "self.copy",
          "new_lines.extend",
          "indent",
          "line.plain",
          "unknown.join",
          "text.split",
          "match.group",
          "self.detect_indentation",
          "Text",
          "divmod",
          "line",
          "new_indent",
          "text.blank_copy",
          "re_indent.match",
          "text.expand_tabs",
          "len",
          "_indent_size",
          "new_lines"
        ],
        "docstring": "Adds indent guide lines to text.\n\nArgs:\n    indent_size (Optional[int]): Size of indentation, or None to auto detect. Defaults to None.\n    character (str, optional): Character to use for indentation. Defaults to \"\u2502\".\n    style (Union[Style, str], optional): Style of indent guides.\n\nReturns:\n    Text: New text with indentation guides.",
        "code": "def with_indent_guides(\n        self,\n        indent_size: Optional[int] = None,\n        *,\n        character: str = \"\u2502\",\n        style: StyleType = \"dim green\",\n    ) -> \"Text\":\n        \"\"\"Adds indent guide lines to text.\n\n        Args:\n            indent_size (Optional[int]): Size of indentation, or None to auto detect. Defaults to None.\n            character (str, optional): Character to use for indentation. Defaults to \"\u2502\".\n            style (Union[Style, str], optional): Style of indent guides.\n\n        Returns:\n            Text: New text with indentation guides.\n        \"\"\"\n\n        _indent_size = self.detect_indentation() if indent_size is None else indent_size\n\n        text = self.copy()\n        text.expand_tabs()\n        indent_line = f\"{character}{' ' * (_indent_size - 1)}\"\n\n        re_indent = re.compile(r\"^( *)(.*)$\")\n        new_lines: List[Text] = []\n        add_line = new_lines.append\n        blank_lines = 0\n        for line in text.split(allow_blank=True):\n            match = re_indent.match(line.plain)\n            if not match or not match.group(2):\n                blank_lines += 1\n                continue\n            indent = match.group(1)\n            full_indents, remaining_space = divmod(len(indent), _indent_size)\n            new_indent = f\"{indent_line * full_indents}{' ' * remaining_space}\"\n            line.plain = new_indent + line.plain[len(new_indent) :]\n            line.stylize(style, 0, len(new_indent))\n            if blank_lines:\n                new_lines.extend([Text(new_indent, style=style)] * blank_lines)\n                blank_lines = 0\n            add_line(line)\n        if blank_lines:\n            new_lines.extend([Text(\"\", style=style)] * blank_lines)\n\n        new_text = text.blank_copy(\"\\n\").join(new_lines)\n        return new_text",
        "line_count": 47,
        "needs_llm_summary": true
      },
      {
        "name": "get_text_at",
        "args": [
          {
            "name": "offset",
            "type": "int"
          }
        ],
        "return_type": "Text",
        "lineno": 199,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style",
          "Span",
          "_Span",
          "Text"
        ],
        "docstring": null,
        "code": "def get_text_at(offset: int) -> \"Text\":\n            _Span = Span\n            text = Text(\n                self.plain[offset],\n                spans=[\n                    _Span(0, 1, style)\n                    for start, end, style in self._spans\n                    if end > offset >= start\n                ],\n                end=\"\",\n            )\n            return text",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "get_current_style",
        "args": [],
        "return_type": "Style",
        "lineno": 759,
        "decorators": [],
        "is_async": false,
        "calls": [
          "style_cache_get",
          "current_style",
          "combine",
          "sorted",
          "tuple",
          "styles",
          "stack"
        ],
        "docstring": "Construct current style from stack.",
        "code": "def get_current_style() -> Style:\n            \"\"\"Construct current style from stack.\"\"\"\n            styles = tuple(style_map[_style_id] for _style_id in sorted(stack))\n            cached_style = style_cache_get(styles)\n            if cached_style is not None:\n                return cached_style\n            current_style = combine(styles)\n            style_cache[styles] = current_style\n            return current_style",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "iter_text",
        "args": [],
        "return_type": "Iterable[Text]",
        "lineno": 791,
        "decorators": [],
        "is_async": false,
        "calls": [
          "loop_last",
          "lines"
        ],
        "docstring": null,
        "code": "def iter_text() -> Iterable[\"Text\"]:\n            if self.plain:\n                for last, line in loop_last(lines):\n                    yield line\n                    if not last:\n                        yield self\n            else:\n                yield from lines",
        "line_count": 8,
        "needs_llm_summary": true
      },
      {
        "name": "flatten_spans",
        "args": [],
        "return_type": "Iterable[int]",
        "lineno": 1092,
        "decorators": [],
        "is_async": false,
        "calls": [
          "re.finditer",
          "re.escape",
          "text",
          "match.span",
          "separator"
        ],
        "docstring": null,
        "code": "def flatten_spans() -> Iterable[int]:\n                for match in re.finditer(re.escape(separator), text):\n                    start, end = match.span()\n                    yield start\n                    yield end",
        "line_count": 5,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Span",
        "methods": [
          "__repr__",
          "__bool__",
          "split",
          "move",
          "right_crop",
          "extend"
        ],
        "base_classes": [
          "NamedTuple"
        ],
        "lineno": 47,
        "docstring": "A marked up region in some text."
      },
      {
        "name": "Text",
        "methods": [
          "__init__",
          "__len__",
          "__bool__",
          "__str__",
          "__repr__",
          "__add__",
          "__eq__",
          "__contains__",
          "__getitem__",
          "cell_len",
          "markup",
          "from_markup",
          "from_ansi",
          "styled",
          "assemble",
          "plain",
          "plain",
          "spans",
          "spans",
          "blank_copy",
          "copy",
          "stylize",
          "stylize_before",
          "apply_meta",
          "on",
          "remove_suffix",
          "get_style_at_offset",
          "extend_style",
          "highlight_regex",
          "highlight_words",
          "rstrip",
          "rstrip_end",
          "set_length",
          "__rich_console__",
          "__rich_measure__",
          "render",
          "join",
          "expand_tabs",
          "truncate",
          "_trim_spans",
          "pad",
          "pad_left",
          "pad_right",
          "align",
          "append",
          "append_text",
          "append_tokens",
          "copy_styles",
          "split",
          "divide",
          "right_crop",
          "wrap",
          "fit",
          "detect_indentation",
          "with_indent_guides"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 118,
        "docstring": "Text with color / style.\n\nArgs:\n    text (str, optional): Default unstyled text. Defaults to \"\".\n    style (Union[str, Style], optional): Base style for text. Defaults to \"\".\n    justify (str, optional): Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n    overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n    no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.\n    end (str, optional): Character to end text with. Defaults to \"\\\\n\".\n    tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n    spans (List[Span], optional). A list of predefined style spans. Defaults to None."
      }
    ],
    "imports": [
      {
        "module": "re",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "functools",
        "name": "partial",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "functools",
        "name": "reduce",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "math",
        "name": "gcd",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "operator",
        "name": "itemgetter",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "TYPE_CHECKING",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "NamedTuple",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Pattern",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 19,
        "type": "from_import"
      },
      {
        "module": "_pick",
        "name": "pick_bool",
        "alias": null,
        "lineno": 20,
        "type": "from_import"
      },
      {
        "module": "_wrap",
        "name": "divide_line",
        "alias": null,
        "lineno": 21,
        "type": "from_import"
      },
      {
        "module": "align",
        "name": "AlignMethod",
        "alias": null,
        "lineno": 22,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "cell_len",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "cells",
        "name": "set_cell_size",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "containers",
        "name": "Lines",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "control",
        "name": "strip_control_codes",
        "alias": null,
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "emoji",
        "name": "EmojiVariant",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 28,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 33,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 33,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "JustifyMethod",
        "alias": null,
        "lineno": 33,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "OverflowMethod",
        "alias": null,
        "lineno": 33,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 1337,
        "type": "from_import"
      },
      {
        "module": "markup",
        "name": "escape",
        "alias": null,
        "lineno": 236,
        "type": "from_import"
      },
      {
        "module": "markup",
        "name": "render",
        "alias": null,
        "lineno": 285,
        "type": "from_import"
      },
      {
        "module": "ansi",
        "name": "AnsiDecoder",
        "alias": null,
        "lineno": 316,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "_re_whitespace",
        "assigned_to": "re.compile",
        "lineno": 39
      },
      {
        "name": "TextType",
        "assigned_to": null,
        "lineno": 41
      },
      {
        "name": "GetStyleCallable",
        "assigned_to": null,
        "lineno": 44
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "console.rule",
      "text.highlight_words",
      "Console",
      "Text"
    ],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "console.rule",
        "text.highlight_words",
        "Console",
        "re.compile",
        "text",
        "Text"
      ],
      "class_instantiations": [
        "Console",
        "Text"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "math",
        "functools",
        "re"
      ],
      "third_party": {
        "other": [
          "operator",
          "_loop",
          "_pick",
          "_wrap",
          "align",
          "cells",
          "containers",
          "control",
          "emoji",
          "jupyter",
          "measure",
          "segment",
          "style",
          "console",
          "rich",
          "markup",
          "ansi"
        ]
      },
      "tech_stack": []
    },
    "line_count": 1362
  },
  "rich/theme.py": {
    "filepath": "../rich/rich/theme.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "styles",
            "type": "Optional[Mapping[str, StyleType]]"
          },
          {
            "name": "inherit",
            "type": "bool"
          }
        ],
        "return_type": null,
        "lineno": 18,
        "decorators": [],
        "is_async": false,
        "calls": [
          "isinstance",
          "style",
          "DEFAULT_STYLES.copy",
          "styles.items",
          "self.styles.update",
          "Style.parse",
          "Style"
        ],
        "docstring": null,
        "code": "def __init__(\n        self, styles: Optional[Mapping[str, StyleType]] = None, inherit: bool = True\n    ):\n        self.styles = DEFAULT_STYLES.copy() if inherit else {}\n        if styles is not None:\n            self.styles.update(\n                {\n                    name: style if isinstance(style, Style) else Style.parse(style)\n                    for name, style in styles.items()\n                }\n            )",
        "line_count": 11,
        "needs_llm_summary": true
      },
      {
        "name": "config",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "str",
        "lineno": 31,
        "decorators": [
          {
            "name": "property",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "unknown.join",
          "self.styles.items",
          "sorted"
        ],
        "docstring": "Get contents of a config file for this theme.",
        "code": "def config(self) -> str:\n        \"\"\"Get contents of a config file for this theme.\"\"\"\n        config = \"[styles]\\n\" + \"\\n\".join(\n            f\"{name} = {style}\" for name, style in sorted(self.styles.items())\n        )\n        return config",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "from_file",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "config_file",
            "type": "IO[str]"
          },
          {
            "name": "source",
            "type": "Optional[str]"
          },
          {
            "name": "inherit",
            "type": "bool"
          }
        ],
        "return_type": "Theme",
        "lineno": 39,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "value",
          "config_file",
          "inherit",
          "Theme",
          "config.read_file",
          "config.items",
          "Style.parse",
          "source",
          "configparser.ConfigParser",
          "styles"
        ],
        "docstring": "Load a theme from a text mode file.\n\nArgs:\n    config_file (IO[str]): An open conf file.\n    source (str, optional): The filename of the open file. Defaults to None.\n    inherit (bool, optional): Inherit default styles. Defaults to True.\n\nReturns:\n    Theme: A New theme instance.",
        "code": "def from_file(\n        cls, config_file: IO[str], source: Optional[str] = None, inherit: bool = True\n    ) -> \"Theme\":\n        \"\"\"Load a theme from a text mode file.\n\n        Args:\n            config_file (IO[str]): An open conf file.\n            source (str, optional): The filename of the open file. Defaults to None.\n            inherit (bool, optional): Inherit default styles. Defaults to True.\n\n        Returns:\n            Theme: A New theme instance.\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read_file(config_file, source=source)\n        styles = {name: Style.parse(value) for name, value in config.items(\"styles\")}\n        theme = Theme(styles, inherit=inherit)\n        return theme",
        "line_count": 18,
        "needs_llm_summary": true
      },
      {
        "name": "read",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "path",
            "type": "str"
          },
          {
            "name": "inherit",
            "type": "bool"
          },
          {
            "name": "encoding",
            "type": "Optional[str]"
          }
        ],
        "return_type": "Theme",
        "lineno": 59,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "config_file",
          "inherit",
          "cls.from_file",
          "path",
          "open",
          "encoding"
        ],
        "docstring": "Read a theme from a path.\n\nArgs:\n    path (str): Path to a config file readable by Python configparser module.\n    inherit (bool, optional): Inherit default styles. Defaults to True.\n    encoding (str, optional): Encoding of the config file. Defaults to None.\n\nReturns:\n    Theme: A new theme instance.",
        "code": "def read(\n        cls, path: str, inherit: bool = True, encoding: Optional[str] = None\n    ) -> \"Theme\":\n        \"\"\"Read a theme from a path.\n\n        Args:\n            path (str): Path to a config file readable by Python configparser module.\n            inherit (bool, optional): Inherit default styles. Defaults to True.\n            encoding (str, optional): Encoding of the config file. Defaults to None.\n\n        Returns:\n            Theme: A new theme instance.\n        \"\"\"\n        with open(path, encoding=encoding) as config_file:\n            return cls.from_file(config_file, source=path, inherit=inherit)",
        "line_count": 15,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "theme",
            "type": "Theme"
          }
        ],
        "return_type": "None",
        "lineno": 87,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.get"
        ],
        "docstring": null,
        "code": "def __init__(self, theme: Theme) -> None:\n        self._entries: List[Dict[str, Style]] = [theme.styles]\n        self.get = self._entries[-1].get",
        "line_count": 3,
        "needs_llm_summary": true
      },
      {
        "name": "push_theme",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "theme",
            "type": "Theme"
          },
          {
            "name": "inherit",
            "type": "bool"
          }
        ],
        "return_type": "None",
        "lineno": 91,
        "decorators": [],
        "is_async": false,
        "calls": [
          "theme.styles.copy",
          "self._entries.append",
          "unknown.get",
          "styles"
        ],
        "docstring": "Push a theme on the top of the stack.\n\nArgs:\n    theme (Theme): A Theme instance.\n    inherit (boolean, optional): Inherit styles from current top of stack.",
        "code": "def push_theme(self, theme: Theme, inherit: bool = True) -> None:\n        \"\"\"Push a theme on the top of the stack.\n\n        Args:\n            theme (Theme): A Theme instance.\n            inherit (boolean, optional): Inherit styles from current top of stack.\n        \"\"\"\n        styles: Dict[str, Style]\n        styles = (\n            {**self._entries[-1], **theme.styles} if inherit else theme.styles.copy()\n        )\n        self._entries.append(styles)\n        self.get = self._entries[-1].get",
        "line_count": 13,
        "needs_llm_summary": true
      },
      {
        "name": "pop_theme",
        "args": [
          {
            "name": "self"
          }
        ],
        "return_type": "None",
        "lineno": 105,
        "decorators": [],
        "is_async": false,
        "calls": [
          "unknown.get",
          "ThemeStackError",
          "self._entries",
          "self._entries.pop",
          "len"
        ],
        "docstring": "Pop (and discard) the top-most theme.",
        "code": "def pop_theme(self) -> None:\n        \"\"\"Pop (and discard) the top-most theme.\"\"\"\n        if len(self._entries) == 1:\n            raise ThemeStackError(\"Unable to pop base theme\")\n        self._entries.pop()\n        self.get = self._entries[-1].get",
        "line_count": 6,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Theme",
        "methods": [
          "__init__",
          "config",
          "from_file",
          "read"
        ],
        "base_classes": [],
        "lineno": 8,
        "docstring": "A container for style information, used by :class:`~rich.console.Console`.\n\nArgs:\n    styles (Dict[str, Style], optional): A mapping of style names on to styles. Defaults to None for a theme with no styles.\n    inherit (bool, optional): Inherit default styles. Defaults to True."
      },
      {
        "name": "ThemeStackError",
        "methods": [],
        "base_classes": [
          "Exception"
        ],
        "lineno": 76,
        "docstring": "Base exception for errors related to the theme stack."
      },
      {
        "name": "ThemeStack",
        "methods": [
          "__init__",
          "push_theme",
          "pop_theme"
        ],
        "base_classes": [],
        "lineno": 80,
        "docstring": "A stack of themes.\n\nArgs:\n    theme (Theme): A theme instance"
      }
    ],
    "imports": [
      {
        "module": "configparser",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "IO",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Mapping",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "default_styles",
        "name": "DEFAULT_STYLES",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "Theme",
      "print"
    ],
    "module_level_calls": {
      "function_calls": [
        "Theme",
        "theme.config",
        "print"
      ],
      "class_instantiations": [
        "Theme"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "configparser",
          "default_styles",
          "style"
        ]
      },
      "tech_stack": []
    },
    "line_count": 116
  },
  "rich/themes.py": {
    "filepath": "../rich/rich/themes.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "default_styles",
        "name": "DEFAULT_STYLES",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "theme",
        "name": "Theme",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "DEFAULT",
        "assigned_to": "Theme",
        "lineno": 5
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "Theme",
        "DEFAULT_STYLES"
      ],
      "class_instantiations": [
        "Theme"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "default_styles",
          "theme"
        ]
      },
      "tech_stack": []
    },
    "line_count": 6
  },
  "rich/traceback.py": {
    "filepath": "../rich/rich/traceback.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "_iter_syntax_lines",
        "args": [
          {
            "name": "start",
            "type": "SyntaxPosition"
          },
          {
            "name": "end",
            "type": "SyntaxPosition"
          }
        ],
        "return_type": "Iterable[Tuple[int, int, int]]",
        "lineno": 55,
        "decorators": [],
        "is_async": false,
        "calls": [
          "range",
          "end",
          "line1",
          "loop_first_last",
          "start"
        ],
        "docstring": "Yield start and end positions per line.\n\nArgs:\n    start: Start position.\n    end: End position.\n\nReturns:\n    Iterable of (LINE, COLUMN1, COLUMN2).",
        "code": "def _iter_syntax_lines(\n    start: SyntaxPosition, end: SyntaxPosition\n) -> Iterable[Tuple[int, int, int]]:\n    \"\"\"Yield start and end positions per line.\n\n    Args:\n        start: Start position.\n        end: End position.\n\n    Returns:\n        Iterable of (LINE, COLUMN1, COLUMN2).\n    \"\"\"\n\n    line1, column1 = start\n    line2, column2 = end\n\n    if line1 == line2:\n        yield line1, column1, column2\n    else:\n        for first, last, line_no in loop_first_last(range(line1, line2 + 1)):\n            if first:\n                yield line_no, column1, -1\n            elif last:\n                yield line_no, 0, column2\n            else:\n                yield line_no, 0, -1",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "install",
        "args": [],
        "return_type": "Callable[Any, Any]",
        "lineno": 83,
        "decorators": [],
        "is_async": false,
        "calls": [
          "excepthook",
          "sys.excepthook",
          "bool",
          "locals_max_length",
          "extra_lines",
          "locals_hide_dunder",
          "word_wrap",
          "exception_traceback",
          "kwargs",
          "ipy_display_traceback",
          "type_",
          "default_showtraceback",
          "ip._get_exc_info",
          "locals_hide_sunder",
          "ipy_excepthook_closure",
          "traceback_console.print",
          "show_locals",
          "ip",
          "tb_data.get",
          "tb.tb_next",
          "value",
          "Console",
          "ipy_show_traceback",
          "indent_guides",
          "width",
          "tb",
          "ip.showtraceback",
          "max_frames",
          "tb_offset",
          "suppress",
          "range",
          "traceback",
          "get_ipython",
          "theme",
          "code_width",
          "locals_max_string",
          "Traceback.from_exception"
        ],
        "docstring": "Install a rich traceback handler.\n\nOnce installed, any tracebacks will be printed with syntax highlighting and rich formatting.\n\n\nArgs:\n    console (Optional[Console], optional): Console to write exception to. Default uses internal Console instance.\n    width (Optional[int], optional): Width (in characters) of traceback. Defaults to 100.\n    code_width (Optional[int], optional): Code width (in characters) of traceback. Defaults to 88.\n    extra_lines (int, optional): Extra lines of code. Defaults to 3.\n    theme (Optional[str], optional): Pygments theme to use in traceback. Defaults to ``None`` which will pick\n        a theme appropriate for the platform.\n    word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n    show_locals (bool, optional): Enable display of local variables. Defaults to False.\n    locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to 10.\n    locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n    locals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.\n    locals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.\n    indent_guides (bool, optional): Enable indent guides in code and locals. Defaults to True.\n    suppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n\nReturns:\n    Callable: The previous exception handler that was replaced.",
        "code": "def install(\n    *,\n    console: Optional[Console] = None,\n    width: Optional[int] = 100,\n    code_width: Optional[int] = 88,\n    extra_lines: int = 3,\n    theme: Optional[str] = None,\n    word_wrap: bool = False,\n    show_locals: bool = False,\n    locals_max_length: int = LOCALS_MAX_LENGTH,\n    locals_max_string: int = LOCALS_MAX_STRING,\n    locals_hide_dunder: bool = True,\n    locals_hide_sunder: Optional[bool] = None,\n    indent_guides: bool = True,\n    suppress: Iterable[Union[str, ModuleType]] = (),\n    max_frames: int = 100,\n) -> Callable[[Type[BaseException], BaseException, Optional[TracebackType]], Any]:\n    \"\"\"Install a rich traceback handler.\n\n    Once installed, any tracebacks will be printed with syntax highlighting and rich formatting.\n\n\n    Args:\n        console (Optional[Console], optional): Console to write exception to. Default uses internal Console instance.\n        width (Optional[int], optional): Width (in characters) of traceback. Defaults to 100.\n        code_width (Optional[int], optional): Code width (in characters) of traceback. Defaults to 88.\n        extra_lines (int, optional): Extra lines of code. Defaults to 3.\n        theme (Optional[str], optional): Pygments theme to use in traceback. Defaults to ``None`` which will pick\n            a theme appropriate for the platform.\n        word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n        show_locals (bool, optional): Enable display of local variables. Defaults to False.\n        locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to 10.\n        locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n        locals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.\n        locals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.\n        indent_guides (bool, optional): Enable indent guides in code and locals. Defaults to True.\n        suppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n\n    Returns:\n        Callable: The previous exception handler that was replaced.\n\n    \"\"\"\n    traceback_console = Console(stderr=True) if console is None else console\n\n    locals_hide_sunder = (\n        True\n        if (traceback_console.is_jupyter and locals_hide_sunder is None)\n        else locals_hide_sunder\n    )\n\n    def excepthook(\n        type_: Type[BaseException],\n        value: BaseException,\n        traceback: Optional[TracebackType],\n    ) -> None:\n        exception_traceback = Traceback.from_exception(\n            type_,\n            value,\n            traceback,\n            width=width,\n            code_width=code_width,\n            extra_lines=extra_lines,\n            theme=theme,\n            word_wrap=word_wrap,\n            show_locals=show_locals,\n            locals_max_length=locals_max_length,\n            locals_max_string=locals_max_string,\n            locals_hide_dunder=locals_hide_dunder,\n            locals_hide_sunder=bool(locals_hide_sunder),\n            indent_guides=indent_guides,\n            suppress=suppress,\n            max_frames=max_frames,\n        )\n        traceback_console.print(exception_traceback)\n\n    def ipy_excepthook_closure(ip: Any) -> None:  # pragma: no cover\n        tb_data = {}  # store information about showtraceback call\n        default_showtraceback = ip.showtraceback  # keep reference of default traceback\n\n        def ipy_show_traceback(*args: Any, **kwargs: Any) -> None:\n            \"\"\"wrap the default ip.showtraceback to store info for ip._showtraceback\"\"\"\n            nonlocal tb_data\n            tb_data = kwargs\n            default_showtraceback(*args, **kwargs)\n\n        def ipy_display_traceback(\n            *args: Any, is_syntax: bool = False, **kwargs: Any\n        ) -> None:\n            \"\"\"Internally called traceback from ip._showtraceback\"\"\"\n            nonlocal tb_data\n            exc_tuple = ip._get_exc_info()\n\n            # do not display trace on syntax error\n            tb: Optional[TracebackType] = None if is_syntax else exc_tuple[2]\n\n            # determine correct tb_offset\n            compiled = tb_data.get(\"running_compiled_code\", False)\n            tb_offset = tb_data.get(\"tb_offset\")\n            if tb_offset is None:\n                tb_offset = 1 if compiled else 0\n            # remove ipython internal frames from trace with tb_offset\n            for _ in range(tb_offset):\n                if tb is None:\n                    break\n                tb = tb.tb_next\n\n            excepthook(exc_tuple[0], exc_tuple[1], tb)\n            tb_data = {}  # clear data upon usage\n\n        # replace _showtraceback instead of showtraceback to allow ipython features such as debugging to work\n        # this is also what the ipython docs recommends to modify when subclassing InteractiveShell\n        ip._showtraceback = ipy_display_traceback\n        # add wrapper to capture tb_data\n        ip.showtraceback = ipy_show_traceback\n        ip.showsyntaxerror = lambda *args, **kwargs: ipy_display_traceback(\n            *args, is_syntax=True, **kwargs\n        )\n\n    try:  # pragma: no cover\n        # if within ipython, use customized traceback\n        ip = get_ipython()  # type: ignore[name-defined]\n        ipy_excepthook_closure(ip)\n        return sys.excepthook\n    except Exception:\n        # otherwise use default system hook\n        old_excepthook = sys.excepthook\n        sys.excepthook = excepthook\n        return old_excepthook",
        "line_count": 129,
        "needs_llm_summary": true
      },
      {
        "name": "excepthook",
        "args": [
          {
            "name": "type_",
            "type": "Type[BaseException]"
          },
          {
            "name": "value",
            "type": "BaseException"
          },
          {
            "name": "traceback",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "None",
        "lineno": 134,
        "decorators": [],
        "is_async": false,
        "calls": [
          "bool",
          "locals_max_length",
          "extra_lines",
          "locals_hide_dunder",
          "word_wrap",
          "exception_traceback",
          "type_",
          "locals_hide_sunder",
          "traceback_console.print",
          "show_locals",
          "value",
          "indent_guides",
          "width",
          "max_frames",
          "suppress",
          "traceback",
          "theme",
          "code_width",
          "locals_max_string",
          "Traceback.from_exception"
        ],
        "docstring": null,
        "code": "def excepthook(\n        type_: Type[BaseException],\n        value: BaseException,\n        traceback: Optional[TracebackType],\n    ) -> None:\n        exception_traceback = Traceback.from_exception(\n            type_,\n            value,\n            traceback,\n            width=width,\n            code_width=code_width,\n            extra_lines=extra_lines,\n            theme=theme,\n            word_wrap=word_wrap,\n            show_locals=show_locals,\n            locals_max_length=locals_max_length,\n            locals_max_string=locals_max_string,\n            locals_hide_dunder=locals_hide_dunder,\n            locals_hide_sunder=bool(locals_hide_sunder),\n            indent_guides=indent_guides,\n            suppress=suppress,\n            max_frames=max_frames,\n        )\n        traceback_console.print(exception_traceback)",
        "line_count": 24,
        "needs_llm_summary": true
      },
      {
        "name": "ipy_excepthook_closure",
        "args": [
          {
            "name": "ip",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 159,
        "decorators": [],
        "is_async": false,
        "calls": [
          "excepthook",
          "tb_offset",
          "range",
          "kwargs",
          "ipy_display_traceback",
          "default_showtraceback",
          "ip._get_exc_info",
          "ipy_show_traceback",
          "tb",
          "ip.showtraceback",
          "tb.tb_next",
          "tb_data.get"
        ],
        "docstring": null,
        "code": "def ipy_excepthook_closure(ip: Any) -> None:  # pragma: no cover\n        tb_data = {}  # store information about showtraceback call\n        default_showtraceback = ip.showtraceback  # keep reference of default traceback\n\n        def ipy_show_traceback(*args: Any, **kwargs: Any) -> None:\n            \"\"\"wrap the default ip.showtraceback to store info for ip._showtraceback\"\"\"\n            nonlocal tb_data\n            tb_data = kwargs\n            default_showtraceback(*args, **kwargs)\n\n        def ipy_display_traceback(\n            *args: Any, is_syntax: bool = False, **kwargs: Any\n        ) -> None:\n            \"\"\"Internally called traceback from ip._showtraceback\"\"\"\n            nonlocal tb_data\n            exc_tuple = ip._get_exc_info()\n\n            # do not display trace on syntax error\n            tb: Optional[TracebackType] = None if is_syntax else exc_tuple[2]\n\n            # determine correct tb_offset\n            compiled = tb_data.get(\"running_compiled_code\", False)\n            tb_offset = tb_data.get(\"tb_offset\")\n            if tb_offset is None:\n                tb_offset = 1 if compiled else 0\n            # remove ipython internal frames from trace with tb_offset\n            for _ in range(tb_offset):\n                if tb is None:\n                    break\n                tb = tb.tb_next\n\n            excepthook(exc_tuple[0], exc_tuple[1], tb)\n            tb_data = {}  # clear data upon usage\n\n        # replace _showtraceback instead of showtraceback to allow ipython features such as debugging to work\n        # this is also what the ipython docs recommends to modify when subclassing InteractiveShell\n        ip._showtraceback = ipy_display_traceback\n        # add wrapper to capture tb_data\n        ip.showtraceback = ipy_show_traceback\n        ip.showsyntaxerror = lambda *args, **kwargs: ipy_display_traceback(\n            *args, is_syntax=True, **kwargs\n        )",
        "line_count": 42,
        "needs_llm_summary": true
      },
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "trace",
            "type": "Optional[Trace]"
          }
        ],
        "return_type": null,
        "lineno": 286,
        "decorators": [],
        "is_async": false,
        "calls": [
          "locals_max_length",
          "suppress_entity",
          "locals_max_string",
          "self.suppress.append",
          "extra_lines",
          "locals_hide_dunder",
          "word_wrap",
          "os.path.normpath",
          "ValueError",
          "exc_value",
          "sys.exc_info",
          "locals_hide_sunder",
          "max",
          "show_locals",
          "exc_type",
          "trace",
          "str",
          "os.path.dirname",
          "indent_guides",
          "width",
          "os.path.abspath",
          "max_frames",
          "isinstance",
          "traceback",
          "self.extract",
          "suppress_entity.__file__",
          "path",
          "code_width",
          "Syntax.get_theme"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        trace: Optional[Trace] = None,\n        *,\n        width: Optional[int] = 100,\n        code_width: Optional[int] = 88,\n        extra_lines: int = 3,\n        theme: Optional[str] = None,\n        word_wrap: bool = False,\n        show_locals: bool = False,\n        locals_max_length: int = LOCALS_MAX_LENGTH,\n        locals_max_string: int = LOCALS_MAX_STRING,\n        locals_hide_dunder: bool = True,\n        locals_hide_sunder: bool = False,\n        indent_guides: bool = True,\n        suppress: Iterable[Union[str, ModuleType]] = (),\n        max_frames: int = 100,\n    ):\n        if trace is None:\n            exc_type, exc_value, traceback = sys.exc_info()\n            if exc_type is None or exc_value is None or traceback is None:\n                raise ValueError(\n                    \"Value for 'trace' required if not called in except: block\"\n                )\n            trace = self.extract(\n                exc_type, exc_value, traceback, show_locals=show_locals\n            )\n        self.trace = trace\n        self.width = width\n        self.code_width = code_width\n        self.extra_lines = extra_lines\n        self.theme = Syntax.get_theme(theme or \"ansi_dark\")\n        self.word_wrap = word_wrap\n        self.show_locals = show_locals\n        self.indent_guides = indent_guides\n        self.locals_max_length = locals_max_length\n        self.locals_max_string = locals_max_string\n        self.locals_hide_dunder = locals_hide_dunder\n        self.locals_hide_sunder = locals_hide_sunder\n\n        self.suppress: Sequence[str] = []\n        for suppress_entity in suppress:\n            if not isinstance(suppress_entity, str):\n                assert (\n                    suppress_entity.__file__ is not None\n                ), f\"{suppress_entity!r} must be a module with '__file__' attribute\"\n                path = os.path.dirname(suppress_entity.__file__)\n            else:\n                path = suppress_entity\n            path = os.path.normpath(os.path.abspath(path))\n            self.suppress.append(path)\n        self.max_frames = max(4, max_frames) if max_frames > 0 else 0",
        "line_count": 52,
        "needs_llm_summary": true
      },
      {
        "name": "from_exception",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "exc_type",
            "type": "Type[Any]"
          },
          {
            "name": "exc_value",
            "type": "BaseException"
          },
          {
            "name": "traceback",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "Traceback",
        "lineno": 340,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "locals_max_length",
          "extra_lines",
          "locals_hide_dunder",
          "word_wrap",
          "exc_value",
          "locals_hide_sunder",
          "cls.extract",
          "show_locals",
          "exc_type",
          "rich_traceback",
          "indent_guides",
          "width",
          "cls",
          "max_frames",
          "suppress",
          "traceback",
          "theme",
          "code_width",
          "locals_max_string"
        ],
        "docstring": "Create a traceback from exception info\n\nArgs:\n    exc_type (Type[BaseException]): Exception type.\n    exc_value (BaseException): Exception value.\n    traceback (TracebackType): Python Traceback object.\n    width (Optional[int], optional): Number of characters used to traceback. Defaults to 100.\n    code_width (Optional[int], optional): Number of code characters used to traceback. Defaults to 88.\n    extra_lines (int, optional): Additional lines of code to render. Defaults to 3.\n    theme (str, optional): Override pygments theme used in traceback.\n    word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n    show_locals (bool, optional): Enable display of local variables. Defaults to False.\n    indent_guides (bool, optional): Enable indent guides in code and locals. Defaults to True.\n    locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to 10.\n    locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n    locals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.\n    locals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.\n    suppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n    max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n\nReturns:\n    Traceback: A Traceback instance that may be printed.",
        "code": "def from_exception(\n        cls,\n        exc_type: Type[Any],\n        exc_value: BaseException,\n        traceback: Optional[TracebackType],\n        *,\n        width: Optional[int] = 100,\n        code_width: Optional[int] = 88,\n        extra_lines: int = 3,\n        theme: Optional[str] = None,\n        word_wrap: bool = False,\n        show_locals: bool = False,\n        locals_max_length: int = LOCALS_MAX_LENGTH,\n        locals_max_string: int = LOCALS_MAX_STRING,\n        locals_hide_dunder: bool = True,\n        locals_hide_sunder: bool = False,\n        indent_guides: bool = True,\n        suppress: Iterable[Union[str, ModuleType]] = (),\n        max_frames: int = 100,\n    ) -> \"Traceback\":\n        \"\"\"Create a traceback from exception info\n\n        Args:\n            exc_type (Type[BaseException]): Exception type.\n            exc_value (BaseException): Exception value.\n            traceback (TracebackType): Python Traceback object.\n            width (Optional[int], optional): Number of characters used to traceback. Defaults to 100.\n            code_width (Optional[int], optional): Number of code characters used to traceback. Defaults to 88.\n            extra_lines (int, optional): Additional lines of code to render. Defaults to 3.\n            theme (str, optional): Override pygments theme used in traceback.\n            word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n            show_locals (bool, optional): Enable display of local variables. Defaults to False.\n            indent_guides (bool, optional): Enable indent guides in code and locals. Defaults to True.\n            locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n                Defaults to 10.\n            locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n            locals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.\n            locals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.\n            suppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n            max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n\n        Returns:\n            Traceback: A Traceback instance that may be printed.\n        \"\"\"\n        rich_traceback = cls.extract(\n            exc_type,\n            exc_value,\n            traceback,\n            show_locals=show_locals,\n            locals_max_length=locals_max_length,\n            locals_max_string=locals_max_string,\n            locals_hide_dunder=locals_hide_dunder,\n            locals_hide_sunder=locals_hide_sunder,\n        )\n\n        return cls(\n            rich_traceback,\n            width=width,\n            code_width=code_width,\n            extra_lines=extra_lines,\n            theme=theme,\n            word_wrap=word_wrap,\n            show_locals=show_locals,\n            indent_guides=indent_guides,\n            locals_max_length=locals_max_length,\n            locals_max_string=locals_max_string,\n            locals_hide_dunder=locals_hide_dunder,\n            locals_hide_sunder=locals_hide_sunder,\n            suppress=suppress,\n            max_frames=max_frames,\n        )",
        "line_count": 71,
        "needs_llm_summary": true
      },
      {
        "name": "extract",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "exc_type",
            "type": "Type[BaseException]"
          },
          {
            "name": "exc_value",
            "type": "BaseException"
          },
          {
            "name": "traceback",
            "type": "Optional[TracebackType]"
          }
        ],
        "return_type": "Trace",
        "lineno": 413,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "instruction_index",
          "Traceback.extract",
          "grouped_exceptions.add",
          "next",
          "islice",
          "locals_max_length",
          "frame",
          "exc_value.msg",
          "type",
          "filename.startswith",
          "locals_hide_dunder",
          "_object",
          "_SyntaxError",
          "_IMPORT_CWD",
          "last_instruction",
          "frame_summary.f_locals.items",
          "frame_summary.f_code.co_filename",
          "stack.frames.append",
          "exc_value",
          "cause.__class__",
          "inspect.isfunction",
          "notes",
          "walk_tb",
          "is_cause",
          "grouped_exceptions",
          "locals_hide_sunder",
          "SyntaxError",
          "cause.__traceback__",
          "filename",
          "stacks.append",
          "cause",
          "os.path.isabs",
          "inspect.isclass",
          "key.startswith",
          "Stack",
          "str",
          "instruction_position",
          "append",
          "value",
          "frame_summary.f_locals.get",
          "line_no",
          "stacks",
          "exception.__traceback__",
          "safe_str",
          "Frame",
          "Trace",
          "frame_summary.f_code.co_positions",
          "stack",
          "exc_value.__context__",
          "exc_type.__name__",
          "stack.exceptions.append",
          "isinstance",
          "getattr",
          "pretty.traverse",
          "traceback",
          "get_locals",
          "os.path.join",
          "frame_summary.f_code.co_name",
          "set",
          "show_locals",
          "exception",
          "locals_max_string"
        ],
        "docstring": "Extract traceback information.\n\nArgs:\n    exc_type (Type[BaseException]): Exception type.\n    exc_value (BaseException): Exception value.\n    traceback (TracebackType): Python Traceback object.\n    show_locals (bool, optional): Enable display of local variables. Defaults to False.\n    locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to 10.\n    locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n    locals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.\n    locals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.\n\nReturns:\n    Trace: A Trace instance which you can use to construct a `Traceback`.",
        "code": "def extract(\n        cls,\n        exc_type: Type[BaseException],\n        exc_value: BaseException,\n        traceback: Optional[TracebackType],\n        *,\n        show_locals: bool = False,\n        locals_max_length: int = LOCALS_MAX_LENGTH,\n        locals_max_string: int = LOCALS_MAX_STRING,\n        locals_hide_dunder: bool = True,\n        locals_hide_sunder: bool = False,\n        _visited_exceptions: Optional[Set[BaseException]] = None,\n    ) -> Trace:\n        \"\"\"Extract traceback information.\n\n        Args:\n            exc_type (Type[BaseException]): Exception type.\n            exc_value (BaseException): Exception value.\n            traceback (TracebackType): Python Traceback object.\n            show_locals (bool, optional): Enable display of local variables. Defaults to False.\n            locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n                Defaults to 10.\n            locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n            locals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.\n            locals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.\n\n        Returns:\n            Trace: A Trace instance which you can use to construct a `Traceback`.\n        \"\"\"\n\n        stacks: List[Stack] = []\n        is_cause = False\n\n        from rich import _IMPORT_CWD\n\n        notes: List[str] = getattr(exc_value, \"__notes__\", None) or []\n\n        grouped_exceptions: Set[BaseException] = (\n            set() if _visited_exceptions is None else _visited_exceptions\n        )\n\n        def safe_str(_object: Any) -> str:\n            \"\"\"Don't allow exceptions from __str__ to propagate.\"\"\"\n            try:\n                return str(_object)\n            except Exception:\n                return \"<exception str() failed>\"\n\n        while True:\n            stack = Stack(\n                exc_type=safe_str(exc_type.__name__),\n                exc_value=safe_str(exc_value),\n                is_cause=is_cause,\n                notes=notes,\n            )\n\n            if sys.version_info >= (3, 11):\n                if isinstance(exc_value, (BaseExceptionGroup, ExceptionGroup)):\n                    stack.is_group = True\n                    for exception in exc_value.exceptions:\n                        if exception in grouped_exceptions:\n                            continue\n                        grouped_exceptions.add(exception)\n                        stack.exceptions.append(\n                            Traceback.extract(\n                                type(exception),\n                                exception,\n                                exception.__traceback__,\n                                show_locals=show_locals,\n                                locals_max_length=locals_max_length,\n                                locals_hide_dunder=locals_hide_dunder,\n                                locals_hide_sunder=locals_hide_sunder,\n                                _visited_exceptions=grouped_exceptions,\n                            )\n                        )\n\n            if isinstance(exc_value, SyntaxError):\n                stack.syntax_error = _SyntaxError(\n                    offset=exc_value.offset or 0,\n                    filename=exc_value.filename or \"?\",\n                    lineno=exc_value.lineno or 0,\n                    line=exc_value.text or \"\",\n                    msg=exc_value.msg,\n                    notes=notes,\n                )\n\n            stacks.append(stack)\n            append = stack.frames.append\n\n            def get_locals(\n                iter_locals: Iterable[Tuple[str, object]],\n            ) -> Iterable[Tuple[str, object]]:\n                \"\"\"Extract locals from an iterator of key pairs.\"\"\"\n                if not (locals_hide_dunder or locals_hide_sunder):\n                    yield from iter_locals\n                    return\n                for key, value in iter_locals:\n                    if locals_hide_dunder and key.startswith(\"__\"):\n                        continue\n                    if locals_hide_sunder and key.startswith(\"_\"):\n                        continue\n                    yield key, value\n\n            for frame_summary, line_no in walk_tb(traceback):\n                filename = frame_summary.f_code.co_filename\n\n                last_instruction: Optional[Tuple[Tuple[int, int], Tuple[int, int]]]\n                last_instruction = None\n                if sys.version_info >= (3, 11):\n                    instruction_index = frame_summary.f_lasti // 2\n                    instruction_position = next(\n                        islice(\n                            frame_summary.f_code.co_positions(),\n                            instruction_index,\n                            instruction_index + 1,\n                        )\n                    )\n                    (\n                        start_line,\n                        end_line,\n                        start_column,\n                        end_column,\n                    ) = instruction_position\n                    if (\n                        start_line is not None\n                        and end_line is not None\n                        and start_column is not None\n                        and end_column is not None\n                    ):\n                        last_instruction = (\n                            (start_line, start_column),\n                            (end_line, end_column),\n                        )\n\n                if filename and not filename.startswith(\"<\"):\n                    if not os.path.isabs(filename):\n                        filename = os.path.join(_IMPORT_CWD, filename)\n                if frame_summary.f_locals.get(\"_rich_traceback_omit\", False):\n                    continue\n\n                frame = Frame(\n                    filename=filename or \"?\",\n                    lineno=line_no,\n                    name=frame_summary.f_code.co_name,\n                    locals=(\n                        {\n                            key: pretty.traverse(\n                                value,\n                                max_length=locals_max_length,\n                                max_string=locals_max_string,\n                            )\n                            for key, value in get_locals(frame_summary.f_locals.items())\n                            if not (inspect.isfunction(value) or inspect.isclass(value))\n                        }\n                        if show_locals\n                        else None\n                    ),\n                    last_instruction=last_instruction,\n                )\n                append(frame)\n                if frame_summary.f_locals.get(\"_rich_traceback_guard\", False):\n                    del stack.frames[:]\n\n            if not grouped_exceptions:\n                cause = getattr(exc_value, \"__cause__\", None)\n                if cause is not None and cause is not exc_value:\n                    exc_type = cause.__class__\n                    exc_value = cause\n                    # __traceback__ can be None, e.g. for exceptions raised by the\n                    # 'multiprocessing' module\n                    traceback = cause.__traceback__\n                    is_cause = True\n                    continue\n\n                cause = exc_value.__context__\n                if cause is not None and not getattr(\n                    exc_value, \"__suppress_context__\", False\n                ):\n                    exc_type = cause.__class__\n                    exc_value = cause\n                    traceback = cause.__traceback__\n                    is_cause = False\n                    continue\n            # No cover, code is reached but coverage doesn't recognize it.\n            break  # pragma: no cover\n\n        trace = Trace(stacks=stacks)\n\n        return trace",
        "line_count": 189,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 603,
        "decorators": [],
        "is_async": false,
        "calls": [
          "enumerate",
          "highlighter",
          "group_stack",
          "Panel",
          "stack.syntax_error.msg",
          "self.width",
          "group_last",
          "Style",
          "self._render_stack",
          "self._render_syntax_error",
          "group_exception.stacks",
          "group",
          "Keyword.Constant",
          "theme.get_style_for_token",
          "Theme",
          "reversed",
          "Constrain",
          "Text.from_markup",
          "stack.syntax_error",
          "String",
          "stack_renderable",
          "Operator",
          "ReprHighlighter",
          "Name.Function",
          "String.Delimiter",
          "note",
          "stack.exc_value",
          "render_stack",
          "Name.Constant",
          "traceback_theme",
          "theme.get_background_style",
          "Token",
          "Group",
          "self.theme",
          "self.trace.stacks",
          "stack",
          "console.use_theme",
          "token_style",
          "Name",
          "background_style",
          "TextToken",
          "Comment",
          "Text.assemble",
          "grouped_exceptions.append",
          "loop_last",
          "Number",
          "last",
          "stack.exceptions"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        theme = self.theme\n        background_style = theme.get_background_style()\n        token_style = theme.get_style_for_token\n\n        traceback_theme = Theme(\n            {\n                \"pretty\": token_style(TextToken),\n                \"pygments.text\": token_style(Token),\n                \"pygments.string\": token_style(String),\n                \"pygments.function\": token_style(Name.Function),\n                \"pygments.number\": token_style(Number),\n                \"repr.indent\": token_style(Comment) + Style(dim=True),\n                \"repr.str\": token_style(String),\n                \"repr.brace\": token_style(TextToken) + Style(bold=True),\n                \"repr.number\": token_style(Number),\n                \"repr.bool_true\": token_style(Keyword.Constant),\n                \"repr.bool_false\": token_style(Keyword.Constant),\n                \"repr.none\": token_style(Keyword.Constant),\n                \"scope.border\": token_style(String.Delimiter),\n                \"scope.equals\": token_style(Operator),\n                \"scope.key\": token_style(Name),\n                \"scope.key.special\": token_style(Name.Constant) + Style(dim=True),\n            },\n            inherit=False,\n        )\n\n        highlighter = ReprHighlighter()\n\n        @group()\n        def render_stack(stack: Stack, last: bool) -> RenderResult:\n            if stack.frames:\n                stack_renderable: ConsoleRenderable = Panel(\n                    self._render_stack(stack),\n                    title=\"[traceback.title]Traceback [dim](most recent call last)\",\n                    style=background_style,\n                    border_style=\"traceback.border\",\n                    expand=True,\n                    padding=(0, 1),\n                )\n                stack_renderable = Constrain(stack_renderable, self.width)\n                with console.use_theme(traceback_theme):\n                    yield stack_renderable\n\n            if stack.syntax_error is not None:\n                with console.use_theme(traceback_theme):\n                    yield Constrain(\n                        Panel(\n                            self._render_syntax_error(stack.syntax_error),\n                            style=background_style,\n                            border_style=\"traceback.border.syntax_error\",\n                            expand=True,\n                            padding=(0, 1),\n                            width=self.width,\n                        ),\n                        self.width,\n                    )\n                yield Text.assemble(\n                    (f\"{stack.exc_type}: \", \"traceback.exc_type\"),\n                    highlighter(stack.syntax_error.msg),\n                )\n            elif stack.exc_value:\n                yield Text.assemble(\n                    (f\"{stack.exc_type}: \", \"traceback.exc_type\"),\n                    highlighter(stack.exc_value),\n                )\n            else:\n                yield Text.assemble((f\"{stack.exc_type}\", \"traceback.exc_type\"))\n\n            for note in stack.notes:\n                yield Text.assemble((\"[NOTE] \", \"traceback.note\"), highlighter(note))\n\n            if stack.is_group:\n                for group_no, group_exception in enumerate(stack.exceptions, 1):\n                    grouped_exceptions: List[Group] = []\n                    for group_last, group_stack in loop_last(group_exception.stacks):\n                        grouped_exceptions.append(render_stack(group_stack, group_last))\n                    yield \"\"\n                    yield Constrain(\n                        Panel(\n                            Group(*grouped_exceptions),\n                            title=f\"Sub-exception #{group_no}\",\n                            border_style=\"traceback.group.border\",\n                        ),\n                        self.width,\n                    )\n\n            if not last:\n                if stack.is_cause:\n                    yield Text.from_markup(\n                        \"\\n[i]The above exception was the direct cause of the following exception:\\n\",\n                    )\n                else:\n                    yield Text.from_markup(\n                        \"\\n[i]During handling of the above exception, another exception occurred:\\n\",\n                    )\n\n        for last, stack in loop_last(reversed(self.trace.stacks)):\n            yield render_stack(stack, last)",
        "line_count": 101,
        "needs_llm_summary": true
      },
      {
        "name": "_render_syntax_error",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "syntax_error",
            "type": "_SyntaxError"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 706,
        "decorators": [
          {
            "name": "group",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "min",
          "syntax_error_text",
          "highlighter",
          "str",
          "group",
          "syntax_error_text.stylize",
          "syntax_error.lineno",
          "syntax_error.filename",
          "PathHighlighter",
          "Text.from_markup",
          "os.path.exists",
          "syntax_error.line.rstrip",
          "ReprHighlighter",
          "Text.assemble",
          "path_highlighter",
          "text",
          "offset",
          "len"
        ],
        "docstring": null,
        "code": "def _render_syntax_error(self, syntax_error: _SyntaxError) -> RenderResult:\n        highlighter = ReprHighlighter()\n        path_highlighter = PathHighlighter()\n        if syntax_error.filename != \"<stdin>\":\n            if os.path.exists(syntax_error.filename):\n                text = Text.assemble(\n                    (f\" {syntax_error.filename}\", \"pygments.string\"),\n                    (\":\", \"pygments.text\"),\n                    (str(syntax_error.lineno), \"pygments.number\"),\n                    style=\"pygments.text\",\n                )\n                yield path_highlighter(text)\n        syntax_error_text = highlighter(syntax_error.line.rstrip())\n        syntax_error_text.no_wrap = True\n        offset = min(syntax_error.offset - 1, len(syntax_error_text))\n        syntax_error_text.stylize(\"bold underline\", offset, offset)\n        syntax_error_text += Text.from_markup(\n            \"\\n\" + \" \" * offset + \"[traceback.offset]\u25b2[/]\",\n            style=\"pygments.text\",\n        )\n        yield syntax_error_text",
        "line_count": 21,
        "needs_llm_summary": true
      },
      {
        "name": "_guess_lexer",
        "args": [
          {
            "name": "cls"
          },
          {
            "name": "filename",
            "type": "str"
          },
          {
            "name": "code",
            "type": "str"
          }
        ],
        "return_type": "str",
        "lineno": 729,
        "decorators": [
          {
            "name": "classmethod",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "guess_lexer_for_filename",
          "first_line.startswith",
          "ext",
          "os.path.splitext",
          "cls.LEXERS.get",
          "code.index",
          "code",
          "filename",
          "first_line.lower"
        ],
        "docstring": null,
        "code": "def _guess_lexer(cls, filename: str, code: str) -> str:\n        ext = os.path.splitext(filename)[-1]\n        if not ext:\n            # No extension, look at first line to see if it is a hashbang\n            # Note, this is an educated guess and not a guarantee\n            # If it fails, the only downside is that the code is highlighted strangely\n            new_line_index = code.index(\"\\n\")\n            first_line = code[:new_line_index] if new_line_index != -1 else code\n            if first_line.startswith(\"#!\") and \"python\" in first_line.lower():\n                return \"python\"\n        try:\n            return cls.LEXERS.get(ext) or guess_lexer_for_filename(filename, code).name\n        except ClassNotFound:\n            return \"text\"",
        "line_count": 14,
        "needs_llm_summary": true
      },
      {
        "name": "_render_stack",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "stack",
            "type": "Stack"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 745,
        "decorators": [
          {
            "name": "group",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "enumerate",
          "Columns",
          "end",
          "stack.frames",
          "frame",
          "syntax.stylize_range",
          "any",
          "frame.lineno",
          "_iter_syntax_lines",
          "line.lstrip",
          "render_locals",
          "self.locals_max_length",
          "self.indent_guides",
          "group",
          "render_scope",
          "self._guess_lexer",
          "self.word_wrap",
          "linecache.getlines",
          "PathHighlighter",
          "unknown.join",
          "code",
          "Syntax",
          "frame_filename.startswith",
          "self.code_width",
          "exclude_frames",
          "Text",
          "self.locals_max_string",
          "str",
          "frame.filename.startswith",
          "line",
          "lexer_name",
          "frame.filename",
          "path_highlighter",
          "self.theme",
          "frame.last_instruction",
          "len",
          "range",
          "os.path.exists",
          "path",
          "theme",
          "Text.assemble",
          "frame.locals",
          "start",
          "code_lines"
        ],
        "docstring": null,
        "code": "def _render_stack(self, stack: Stack) -> RenderResult:\n        path_highlighter = PathHighlighter()\n        theme = self.theme\n\n        def render_locals(frame: Frame) -> Iterable[ConsoleRenderable]:\n            if frame.locals:\n                yield render_scope(\n                    frame.locals,\n                    title=\"locals\",\n                    indent_guides=self.indent_guides,\n                    max_length=self.locals_max_length,\n                    max_string=self.locals_max_string,\n                )\n\n        exclude_frames: Optional[range] = None\n        if self.max_frames != 0:\n            exclude_frames = range(\n                self.max_frames // 2,\n                len(stack.frames) - self.max_frames // 2,\n            )\n\n        excluded = False\n        for frame_index, frame in enumerate(stack.frames):\n            if exclude_frames and frame_index in exclude_frames:\n                excluded = True\n                continue\n\n            if excluded:\n                assert exclude_frames is not None\n                yield Text(\n                    f\"\\n... {len(exclude_frames)} frames hidden ...\",\n                    justify=\"center\",\n                    style=\"traceback.error\",\n                )\n                excluded = False\n\n            first = frame_index == 0\n            frame_filename = frame.filename\n            suppressed = any(frame_filename.startswith(path) for path in self.suppress)\n\n            if os.path.exists(frame.filename):\n                text = Text.assemble(\n                    path_highlighter(Text(frame.filename, style=\"pygments.string\")),\n                    (\":\", \"pygments.text\"),\n                    (str(frame.lineno), \"pygments.number\"),\n                    \" in \",\n                    (frame.name, \"pygments.function\"),\n                    style=\"pygments.text\",\n                )\n            else:\n                text = Text.assemble(\n                    \"in \",\n                    (frame.name, \"pygments.function\"),\n                    (\":\", \"pygments.text\"),\n                    (str(frame.lineno), \"pygments.number\"),\n                    style=\"pygments.text\",\n                )\n            if not frame.filename.startswith(\"<\") and not first:\n                yield \"\"\n            yield text\n            if frame.filename.startswith(\"<\"):\n                yield from render_locals(frame)\n                continue\n            if not suppressed:\n                try:\n                    code_lines = linecache.getlines(frame.filename)\n                    code = \"\".join(code_lines)\n                    if not code:\n                        # code may be an empty string if the file doesn't exist, OR\n                        # if the traceback filename is generated dynamically\n                        continue\n                    lexer_name = self._guess_lexer(frame.filename, code)\n                    syntax = Syntax(\n                        code,\n                        lexer_name,\n                        theme=theme,\n                        line_numbers=True,\n                        line_range=(\n                            frame.lineno - self.extra_lines,\n                            frame.lineno + self.extra_lines,\n                        ),\n                        highlight_lines={frame.lineno},\n                        word_wrap=self.word_wrap,\n                        code_width=self.code_width,\n                        indent_guides=self.indent_guides,\n                        dedent=False,\n                    )\n                    yield \"\"\n                except Exception as error:\n                    yield Text.assemble(\n                        (f\"\\n{error}\", \"traceback.error\"),\n                    )\n                else:\n                    if frame.last_instruction is not None:\n                        start, end = frame.last_instruction\n\n                        # Stylize a line at a time\n                        # So that indentation isn't underlined (which looks bad)\n                        for line1, column1, column2 in _iter_syntax_lines(start, end):\n                            try:\n                                if column1 == 0:\n                                    line = code_lines[line1 - 1]\n                                    column1 = len(line) - len(line.lstrip())\n                                if column2 == -1:\n                                    column2 = len(code_lines[line1 - 1])\n                            except IndexError:\n                                # Being defensive here\n                                # If last_instruction reports a line out-of-bounds, we don't want to crash\n                                continue\n\n                            syntax.stylize_range(\n                                style=\"traceback.error_range\",\n                                start=(line1, column1),\n                                end=(line1, column2),\n                            )\n                    yield (\n                        Columns(\n                            [\n                                syntax,\n                                *render_locals(frame),\n                            ],\n                            padding=1,\n                        )\n                        if frame.locals\n                        else syntax\n                    )",
        "line_count": 126,
        "needs_llm_summary": true
      },
      {
        "name": "bar",
        "args": [
          {
            "name": "a",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 877,
        "decorators": [],
        "is_async": false,
        "calls": [
          "print"
        ],
        "docstring": null,
        "code": "def bar(\n        a: Any,\n    ) -> None:  # \u8fd9\u662f\u5bf9\u4e9a\u6d32\u8bed\u8a00\u652f\u6301\u7684\u6d4b\u8bd5\u3002\u9762\u5bf9\u6a21\u68f1\u4e24\u53ef\u7684\u60f3\u6cd5\uff0c\u62d2\u7edd\u731c\u6d4b\u7684\u8bf1\u60d1\n        one = 1\n        print(one / a)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "foo",
        "args": [
          {
            "name": "a",
            "type": "Any"
          }
        ],
        "return_type": "None",
        "lineno": 883,
        "decorators": [],
        "is_async": false,
        "calls": [
          "a",
          "bar"
        ],
        "docstring": null,
        "code": "def foo(a: Any) -> None:\n        _rich_traceback_guard = True\n        zed = {\n            \"characters\": {\n                \"Paul Atreides\",\n                \"Vladimir Harkonnen\",\n                \"Thufir Hawat\",\n                \"Duncan Idaho\",\n            },\n            \"atomic_types\": (None, False, True),\n        }\n        bar(a)",
        "line_count": 12,
        "needs_llm_summary": true
      },
      {
        "name": "error",
        "args": [],
        "return_type": "None",
        "lineno": 896,
        "decorators": [],
        "is_async": false,
        "calls": [
          "foo"
        ],
        "docstring": null,
        "code": "def error() -> None:\n        foo(0)",
        "line_count": 2,
        "needs_llm_summary": false
      },
      {
        "name": "ipy_show_traceback",
        "args": [],
        "return_type": "None",
        "lineno": 163,
        "decorators": [],
        "is_async": false,
        "calls": [
          "default_showtraceback",
          "kwargs"
        ],
        "docstring": "wrap the default ip.showtraceback to store info for ip._showtraceback",
        "code": "def ipy_show_traceback(*args: Any, **kwargs: Any) -> None:\n            \"\"\"wrap the default ip.showtraceback to store info for ip._showtraceback\"\"\"\n            nonlocal tb_data\n            tb_data = kwargs\n            default_showtraceback(*args, **kwargs)",
        "line_count": 5,
        "needs_llm_summary": true
      },
      {
        "name": "ipy_display_traceback",
        "args": [],
        "return_type": "None",
        "lineno": 169,
        "decorators": [],
        "is_async": false,
        "calls": [
          "excepthook",
          "tb_offset",
          "range",
          "ip._get_exc_info",
          "tb",
          "tb.tb_next",
          "tb_data.get"
        ],
        "docstring": "Internally called traceback from ip._showtraceback",
        "code": "def ipy_display_traceback(\n            *args: Any, is_syntax: bool = False, **kwargs: Any\n        ) -> None:\n            \"\"\"Internally called traceback from ip._showtraceback\"\"\"\n            nonlocal tb_data\n            exc_tuple = ip._get_exc_info()\n\n            # do not display trace on syntax error\n            tb: Optional[TracebackType] = None if is_syntax else exc_tuple[2]\n\n            # determine correct tb_offset\n            compiled = tb_data.get(\"running_compiled_code\", False)\n            tb_offset = tb_data.get(\"tb_offset\")\n            if tb_offset is None:\n                tb_offset = 1 if compiled else 0\n            # remove ipython internal frames from trace with tb_offset\n            for _ in range(tb_offset):\n                if tb is None:\n                    break\n                tb = tb.tb_next\n\n            excepthook(exc_tuple[0], exc_tuple[1], tb)\n            tb_data = {}",
        "line_count": 23,
        "needs_llm_summary": true
      },
      {
        "name": "safe_str",
        "args": [
          {
            "name": "_object",
            "type": "Any"
          }
        ],
        "return_type": "str",
        "lineno": 454,
        "decorators": [],
        "is_async": false,
        "calls": [
          "_object",
          "str"
        ],
        "docstring": "Don't allow exceptions from __str__ to propagate.",
        "code": "def safe_str(_object: Any) -> str:\n            \"\"\"Don't allow exceptions from __str__ to propagate.\"\"\"\n            try:\n                return str(_object)\n            except Exception:\n                return \"<exception str() failed>\"",
        "line_count": 6,
        "needs_llm_summary": true
      },
      {
        "name": "render_stack",
        "args": [
          {
            "name": "stack",
            "type": "Stack"
          },
          {
            "name": "last",
            "type": "bool"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 635,
        "decorators": [
          {
            "name": "group",
            "args": [],
            "kwargs": {}
          }
        ],
        "is_async": false,
        "calls": [
          "enumerate",
          "highlighter",
          "group_stack",
          "Panel",
          "stack.syntax_error.msg",
          "self.width",
          "group_last",
          "self._render_stack",
          "self._render_syntax_error",
          "group_exception.stacks",
          "group",
          "Constrain",
          "Text.from_markup",
          "stack.syntax_error",
          "stack_renderable",
          "note",
          "stack.exc_value",
          "render_stack",
          "traceback_theme",
          "Group",
          "stack",
          "console.use_theme",
          "background_style",
          "Text.assemble",
          "grouped_exceptions.append",
          "loop_last",
          "stack.exceptions"
        ],
        "docstring": null,
        "code": "def render_stack(stack: Stack, last: bool) -> RenderResult:\n            if stack.frames:\n                stack_renderable: ConsoleRenderable = Panel(\n                    self._render_stack(stack),\n                    title=\"[traceback.title]Traceback [dim](most recent call last)\",\n                    style=background_style,\n                    border_style=\"traceback.border\",\n                    expand=True,\n                    padding=(0, 1),\n                )\n                stack_renderable = Constrain(stack_renderable, self.width)\n                with console.use_theme(traceback_theme):\n                    yield stack_renderable\n\n            if stack.syntax_error is not None:\n                with console.use_theme(traceback_theme):\n                    yield Constrain(\n                        Panel(\n                            self._render_syntax_error(stack.syntax_error),\n                            style=background_style,\n                            border_style=\"traceback.border.syntax_error\",\n                            expand=True,\n                            padding=(0, 1),\n                            width=self.width,\n                        ),\n                        self.width,\n                    )\n                yield Text.assemble(\n                    (f\"{stack.exc_type}: \", \"traceback.exc_type\"),\n                    highlighter(stack.syntax_error.msg),\n                )\n            elif stack.exc_value:\n                yield Text.assemble(\n                    (f\"{stack.exc_type}: \", \"traceback.exc_type\"),\n                    highlighter(stack.exc_value),\n                )\n            else:\n                yield Text.assemble((f\"{stack.exc_type}\", \"traceback.exc_type\"))\n\n            for note in stack.notes:\n                yield Text.assemble((\"[NOTE] \", \"traceback.note\"), highlighter(note))\n\n            if stack.is_group:\n                for group_no, group_exception in enumerate(stack.exceptions, 1):\n                    grouped_exceptions: List[Group] = []\n                    for group_last, group_stack in loop_last(group_exception.stacks):\n                        grouped_exceptions.append(render_stack(group_stack, group_last))\n                    yield \"\"\n                    yield Constrain(\n                        Panel(\n                            Group(*grouped_exceptions),\n                            title=f\"Sub-exception #{group_no}\",\n                            border_style=\"traceback.group.border\",\n                        ),\n                        self.width,\n                    )\n\n            if not last:\n                if stack.is_cause:\n                    yield Text.from_markup(\n                        \"\\n[i]The above exception was the direct cause of the following exception:\\n\",\n                    )\n                else:\n                    yield Text.from_markup(\n                        \"\\n[i]During handling of the above exception, another exception occurred:\\n\",\n                    )",
        "line_count": 66,
        "needs_llm_summary": true
      },
      {
        "name": "render_locals",
        "args": [
          {
            "name": "frame",
            "type": "Frame"
          }
        ],
        "return_type": "Iterable[ConsoleRenderable]",
        "lineno": 749,
        "decorators": [],
        "is_async": false,
        "calls": [
          "self.locals_max_string",
          "self.locals_max_length",
          "self.indent_guides",
          "render_scope",
          "frame.locals"
        ],
        "docstring": null,
        "code": "def render_locals(frame: Frame) -> Iterable[ConsoleRenderable]:\n            if frame.locals:\n                yield render_scope(\n                    frame.locals,\n                    title=\"locals\",\n                    indent_guides=self.indent_guides,\n                    max_length=self.locals_max_length,\n                    max_string=self.locals_max_string,\n                )",
        "line_count": 9,
        "needs_llm_summary": true
      },
      {
        "name": "get_locals",
        "args": [
          {
            "name": "iter_locals",
            "type": "Iterable[Tuple[str, object]]"
          }
        ],
        "return_type": "Iterable[Tuple[str, object]]",
        "lineno": 502,
        "decorators": [],
        "is_async": false,
        "calls": [
          "key.startswith"
        ],
        "docstring": "Extract locals from an iterator of key pairs.",
        "code": "def get_locals(\n                iter_locals: Iterable[Tuple[str, object]],\n            ) -> Iterable[Tuple[str, object]]:\n                \"\"\"Extract locals from an iterator of key pairs.\"\"\"\n                if not (locals_hide_dunder or locals_hide_sunder):\n                    yield from iter_locals\n                    return\n                for key, value in iter_locals:\n                    if locals_hide_dunder and key.startswith(\"__\"):\n                        continue\n                    if locals_hide_sunder and key.startswith(\"_\"):\n                        continue\n                    yield key, value",
        "line_count": 13,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Frame",
        "methods": [],
        "base_classes": [],
        "lineno": 215,
        "docstring": null
      },
      {
        "name": "_SyntaxError",
        "methods": [],
        "base_classes": [],
        "lineno": 225,
        "docstring": null
      },
      {
        "name": "Stack",
        "methods": [],
        "base_classes": [],
        "lineno": 235,
        "docstring": null
      },
      {
        "name": "Trace",
        "methods": [],
        "base_classes": [],
        "lineno": 247,
        "docstring": null
      },
      {
        "name": "PathHighlighter",
        "methods": [],
        "base_classes": [
          "RegexHighlighter"
        ],
        "lineno": 251,
        "docstring": null
      },
      {
        "name": "Traceback",
        "methods": [
          "__init__",
          "from_exception",
          "extract",
          "__rich_console__",
          "_render_syntax_error",
          "_guess_lexer",
          "_render_stack"
        ],
        "base_classes": [],
        "lineno": 255,
        "docstring": "A Console renderable that renders a traceback.\n\nArgs:\n    trace (Trace, optional): A `Trace` object produced from `extract`. Defaults to None, which uses\n        the last exception.\n    width (Optional[int], optional): Number of characters used to traceback. Defaults to 100.\n    code_width (Optional[int], optional): Number of code characters used to traceback. Defaults to 88.\n    extra_lines (int, optional): Additional lines of code to render. Defaults to 3.\n    theme (str, optional): Override pygments theme used in traceback.\n    word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n    show_locals (bool, optional): Enable display of local variables. Defaults to False.\n    indent_guides (bool, optional): Enable indent guides in code and locals. Defaults to True.\n    locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n        Defaults to 10.\n    locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n    locals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.\n    locals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.\n    suppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n    max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100."
      }
    ],
    "imports": [
      {
        "module": "inspect",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "linecache",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "os",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 4,
        "type": "import"
      },
      {
        "module": "dataclasses",
        "name": "dataclass",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "dataclasses",
        "name": "field",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "itertools",
        "name": "islice",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "traceback",
        "name": "walk_tb",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "ModuleType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "types",
        "name": "TracebackType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Any",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Callable",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Dict",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Iterable",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Sequence",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Set",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Type",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Union",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "pygments.lexers",
        "name": "guess_lexer_for_filename",
        "alias": null,
        "lineno": 23,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Comment",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Keyword",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Name",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Number",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Operator",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "String",
        "alias": null,
        "lineno": 24,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Text",
        "alias": "TextToken",
        "lineno": 25,
        "type": "from_import"
      },
      {
        "module": "pygments.token",
        "name": "Token",
        "alias": null,
        "lineno": 26,
        "type": "from_import"
      },
      {
        "module": "pygments.util",
        "name": "ClassNotFound",
        "alias": null,
        "lineno": 27,
        "type": "from_import"
      },
      {
        "module": "",
        "name": "pretty",
        "alias": null,
        "lineno": 29,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_first_last",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 30,
        "type": "from_import"
      },
      {
        "module": "columns",
        "name": "Columns",
        "alias": null,
        "lineno": 31,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleRenderable",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Group",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "group",
        "alias": null,
        "lineno": 32,
        "type": "from_import"
      },
      {
        "module": "constrain",
        "name": "Constrain",
        "alias": null,
        "lineno": 40,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "RegexHighlighter",
        "alias": null,
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "highlighter",
        "name": "ReprHighlighter",
        "alias": null,
        "lineno": 41,
        "type": "from_import"
      },
      {
        "module": "panel",
        "name": "Panel",
        "alias": null,
        "lineno": 42,
        "type": "from_import"
      },
      {
        "module": "scope",
        "name": "render_scope",
        "alias": null,
        "lineno": 43,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 44,
        "type": "from_import"
      },
      {
        "module": "syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "syntax",
        "name": "SyntaxPosition",
        "alias": null,
        "lineno": 45,
        "type": "from_import"
      },
      {
        "module": "text",
        "name": "Text",
        "alias": null,
        "lineno": 46,
        "type": "from_import"
      },
      {
        "module": "theme",
        "name": "Theme",
        "alias": null,
        "lineno": 47,
        "type": "from_import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 875,
        "type": "import"
      },
      {
        "module": "rich",
        "name": "_IMPORT_CWD",
        "alias": null,
        "lineno": 446,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "WINDOWS",
        "assigned_to": null,
        "lineno": 49
      },
      {
        "name": "LOCALS_MAX_LENGTH",
        "assigned_to": "int",
        "lineno": 51
      },
      {
        "name": "LOCALS_MAX_STRING",
        "assigned_to": "int",
        "lineno": 52
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "install",
      "foo",
      "error",
      "print",
      "bar"
    ],
    "module_level_calls": {
      "function_calls": [
        "a",
        "install",
        "foo",
        "error",
        "print",
        "bar"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [
        "typing",
        "dataclasses",
        "os",
        "itertools",
        "sys"
      ],
      "third_party": {
        "other": [
          "inspect",
          "linecache",
          "traceback",
          "types",
          "pygments",
          "pretty",
          "_loop",
          "columns",
          "console",
          "constrain",
          "highlighter",
          "panel",
          "scope",
          "style",
          "syntax",
          "text",
          "theme",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 900
  },
  "rich/tree.py": {
    "filepath": "../rich/rich/tree.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "__init__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "label",
            "type": "RenderableType"
          }
        ],
        "return_type": "None",
        "lineno": 37,
        "decorators": [],
        "is_async": false,
        "calls": [
          "hide_root",
          "expanded",
          "style",
          "highlight",
          "label",
          "guide_style"
        ],
        "docstring": null,
        "code": "def __init__(\n        self,\n        label: RenderableType,\n        *,\n        style: StyleType = \"tree\",\n        guide_style: StyleType = \"tree.line\",\n        expanded: bool = True,\n        highlight: bool = False,\n        hide_root: bool = False,\n    ) -> None:\n        self.label = label\n        self.style = style\n        self.guide_style = guide_style\n        self.children: List[Tree] = []\n        self.expanded = expanded\n        self.highlight = highlight\n        self.hide_root = hide_root",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "add",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "label",
            "type": "RenderableType"
          }
        ],
        "return_type": "Tree",
        "lineno": 55,
        "decorators": [],
        "is_async": false,
        "calls": [
          "expanded",
          "node",
          "self.children.append",
          "label",
          "Tree"
        ],
        "docstring": "Add a child tree.\n\nArgs:\n    label (RenderableType): The renderable or str for the tree label.\n    style (StyleType, optional): Style of this tree. Defaults to \"tree\".\n    guide_style (StyleType, optional): Style of the guide lines. Defaults to \"tree.line\".\n    expanded (bool, optional): Also display children. Defaults to True.\n    highlight (Optional[bool], optional): Highlight renderable (if str). Defaults to False.\n\nReturns:\n    Tree: A new child Tree, which may be further modified.",
        "code": "def add(\n        self,\n        label: RenderableType,\n        *,\n        style: Optional[StyleType] = None,\n        guide_style: Optional[StyleType] = None,\n        expanded: bool = True,\n        highlight: Optional[bool] = False,\n    ) -> \"Tree\":\n        \"\"\"Add a child tree.\n\n        Args:\n            label (RenderableType): The renderable or str for the tree label.\n            style (StyleType, optional): Style of this tree. Defaults to \"tree\".\n            guide_style (StyleType, optional): Style of the guide lines. Defaults to \"tree.line\".\n            expanded (bool, optional): Also display children. Defaults to True.\n            highlight (Optional[bool], optional): Highlight renderable (if str). Defaults to False.\n\n        Returns:\n            Tree: A new child Tree, which may be further modified.\n        \"\"\"\n        node = Tree(\n            label,\n            style=self.style if style is None else style,\n            guide_style=self.guide_style if guide_style is None else guide_style,\n            expanded=expanded,\n            highlight=self.highlight if highlight is None else highlight,\n        )\n        self.children.append(node)\n        return node",
        "line_count": 30,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_console__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "RenderResult",
        "lineno": 86,
        "decorators": [],
        "is_async": false,
        "calls": [
          "Segment.line",
          "console.render_lines",
          "sum",
          "style",
          "END",
          "next",
          "loop_first",
          "node.children",
          "Style.null",
          "levels.append",
          "guide_style_stack.push",
          "style_stack.pop",
          "Style",
          "options.update",
          "self.highlight",
          "style_stack.push",
          "style.background_style",
          "self.style",
          "stack_node",
          "node.guide_style",
          "levels.pop",
          "self.guide_style",
          "make_guide",
          "console.get_style",
          "CONTINUE",
          "FORK",
          "push",
          "remove_guide_styles",
          "pop",
          "_Segment",
          "get_style",
          "node.style",
          "line",
          "_Segment.apply_style",
          "renderable_lines",
          "Segment",
          "prefix",
          "guide_style_stack.pop",
          "len",
          "StyleStack",
          "range",
          "Styled",
          "iter",
          "node.label",
          "stack.pop",
          "guide_style",
          "stack.append",
          "loop_last"
        ],
        "docstring": null,
        "code": "def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        stack: List[Iterator[Tuple[bool, Tree]]] = []\n        pop = stack.pop\n        push = stack.append\n        new_line = Segment.line()\n\n        get_style = console.get_style\n        null_style = Style.null()\n        guide_style = get_style(self.guide_style, default=\"\") or null_style\n        SPACE, CONTINUE, FORK, END = range(4)\n\n        _Segment = Segment\n\n        def make_guide(index: int, style: Style) -> Segment:\n            \"\"\"Make a Segment for a level of the guide lines.\"\"\"\n            if options.ascii_only:\n                line = self.ASCII_GUIDES[index]\n            else:\n                guide = 1 if style.bold else (2 if style.underline2 else 0)\n                line = self.TREE_GUIDES[0 if options.legacy_windows else guide][index]\n            return _Segment(line, style)\n\n        levels: List[Segment] = [make_guide(CONTINUE, guide_style)]\n        push(iter(loop_last([self])))\n\n        guide_style_stack = StyleStack(get_style(self.guide_style))\n        style_stack = StyleStack(get_style(self.style))\n        remove_guide_styles = Style(bold=False, underline2=False)\n\n        depth = 0\n\n        while stack:\n            stack_node = pop()\n            try:\n                last, node = next(stack_node)\n            except StopIteration:\n                levels.pop()\n                if levels:\n                    guide_style = levels[-1].style or null_style\n                    levels[-1] = make_guide(FORK, guide_style)\n                    guide_style_stack.pop()\n                    style_stack.pop()\n                continue\n            push(stack_node)\n            if last:\n                levels[-1] = make_guide(END, levels[-1].style or null_style)\n\n            guide_style = guide_style_stack.current + get_style(node.guide_style)\n            style = style_stack.current + get_style(node.style)\n            prefix = levels[(2 if self.hide_root else 1) :]\n            renderable_lines = console.render_lines(\n                Styled(node.label, style),\n                options.update(\n                    width=options.max_width\n                    - sum(level.cell_length for level in prefix),\n                    highlight=self.highlight,\n                    height=None,\n                ),\n                pad=options.justify is not None,\n            )\n\n            if not (depth == 0 and self.hide_root):\n                for first, line in loop_first(renderable_lines):\n                    if prefix:\n                        yield from _Segment.apply_style(\n                            prefix,\n                            style.background_style,\n                            post_style=remove_guide_styles,\n                        )\n                    yield from line\n                    yield new_line\n                    if first and prefix:\n                        prefix[-1] = make_guide(\n                            SPACE if last else CONTINUE, prefix[-1].style or null_style\n                        )\n\n            if node.expanded and node.children:\n                levels[-1] = make_guide(\n                    SPACE if last else CONTINUE, levels[-1].style or null_style\n                )\n                levels.append(\n                    make_guide(END if len(node.children) == 1 else FORK, guide_style)\n                )\n                style_stack.push(get_style(node.style))\n                guide_style_stack.push(get_style(node.guide_style))\n                push(iter(loop_last(node.children)))\n                depth += 1",
        "line_count": 89,
        "needs_llm_summary": true
      },
      {
        "name": "__rich_measure__",
        "args": [
          {
            "name": "self"
          },
          {
            "name": "console",
            "type": "Console"
          },
          {
            "name": "options",
            "type": "ConsoleOptions"
          }
        ],
        "return_type": "Measurement",
        "lineno": 176,
        "decorators": [],
        "is_async": false,
        "calls": [
          "max",
          "tree.children",
          "options",
          "iter_tree",
          "Measurement.get",
          "next",
          "measure",
          "iter",
          "tree.label",
          "push",
          "stack.pop",
          "Measurement",
          "stack.append",
          "pop",
          "console",
          "minimum",
          "maximum"
        ],
        "docstring": null,
        "code": "def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        stack: List[Iterator[Tree]] = [iter([self])]\n        pop = stack.pop\n        push = stack.append\n        minimum = 0\n        maximum = 0\n        measure = Measurement.get\n        level = 0\n        while stack:\n            iter_tree = pop()\n            try:\n                tree = next(iter_tree)\n            except StopIteration:\n                level -= 1\n                continue\n            push(iter_tree)\n            min_measure, max_measure = measure(console, options, tree.label)\n            indent = level * 4\n            minimum = max(min_measure + indent, minimum)\n            maximum = max(max_measure + indent, maximum)\n            if tree.expanded and tree.children:\n                push(iter(tree.children))\n                level += 1\n        return Measurement(minimum, maximum)",
        "line_count": 26,
        "needs_llm_summary": true
      },
      {
        "name": "make_guide",
        "args": [
          {
            "name": "index",
            "type": "int"
          },
          {
            "name": "style",
            "type": "Style"
          }
        ],
        "return_type": "Segment",
        "lineno": 101,
        "decorators": [],
        "is_async": false,
        "calls": [
          "line",
          "style",
          "_Segment"
        ],
        "docstring": "Make a Segment for a level of the guide lines.",
        "code": "def make_guide(index: int, style: Style) -> Segment:\n            \"\"\"Make a Segment for a level of the guide lines.\"\"\"\n            if options.ascii_only:\n                line = self.ASCII_GUIDES[index]\n            else:\n                guide = 1 if style.bold else (2 if style.underline2 else 0)\n                line = self.TREE_GUIDES[0 if options.legacy_windows else guide][index]\n            return _Segment(line, style)",
        "line_count": 8,
        "needs_llm_summary": true
      }
    ],
    "classes": [
      {
        "name": "Tree",
        "methods": [
          "__init__",
          "add",
          "__rich_console__",
          "__rich_measure__"
        ],
        "base_classes": [
          "JupyterMixin"
        ],
        "lineno": 14,
        "docstring": "A renderable for a tree structure.\n\nAttributes:\n    ASCII_GUIDES (GuideType): Guide lines used when Console.ascii_only is True.\n    TREE_GUIDES (List[GuideType, GuideType, GuideType]): Default guide lines.\n\nArgs:\n    label (RenderableType): The renderable or str for the tree label.\n    style (StyleType, optional): Style of this tree. Defaults to \"tree\".\n    guide_style (StyleType, optional): Style of the guide lines. Defaults to \"tree.line\".\n    expanded (bool, optional): Also display children. Defaults to True.\n    highlight (bool, optional): Highlight renderable (if str). Defaults to False.\n    hide_root (bool, optional): Hide the root node. Defaults to False."
      }
    ],
    "imports": [
      {
        "module": "typing",
        "name": "Iterator",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Optional",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_first",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "_loop",
        "name": "loop_last",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "Console",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "ConsoleOptions",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderableType",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "console",
        "name": "RenderResult",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "jupyter",
        "name": "JupyterMixin",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "measure",
        "name": "Measurement",
        "alias": null,
        "lineno": 6,
        "type": "from_import"
      },
      {
        "module": "segment",
        "name": "Segment",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "Style",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleStack",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "style",
        "name": "StyleType",
        "alias": null,
        "lineno": 8,
        "type": "from_import"
      },
      {
        "module": "styled",
        "name": "Styled",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Group",
        "alias": null,
        "lineno": 205,
        "type": "from_import"
      },
      {
        "module": "rich.markdown",
        "name": "Markdown",
        "alias": null,
        "lineno": 206,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 207,
        "type": "from_import"
      },
      {
        "module": "rich.syntax",
        "name": "Syntax",
        "alias": null,
        "lineno": 208,
        "type": "from_import"
      },
      {
        "module": "rich.table",
        "name": "Table",
        "alias": null,
        "lineno": 209,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "GuideType",
        "assigned_to": null,
        "lineno": 11
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "console.print",
      "simple_node.add",
      "root.add",
      "Console",
      "Panel.fit",
      "Group",
      "Panel",
      "containers_node.add",
      "Markdown",
      "Tree",
      "node.add",
      "Syntax",
      "table.add_column",
      "table.add_row",
      "Table"
    ],
    "module_level_calls": {
      "function_calls": [
        "root",
        "root.add",
        "Panel",
        "Tree",
        "containers_node.add",
        "table.add_row",
        "simple_node.add",
        "Markdown",
        "code",
        "Syntax",
        "Panel.fit",
        "table",
        "Console",
        "Group",
        "markdown",
        "console.print",
        "syntax",
        "panel",
        "node.add",
        "table.add_column",
        "Table"
      ],
      "class_instantiations": [
        "Panel",
        "Console",
        "Group",
        "Tree",
        "Markdown",
        "Syntax",
        "Table"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "typing"
      ],
      "third_party": {
        "other": [
          "_loop",
          "console",
          "jupyter",
          "measure",
          "segment",
          "style",
          "styled",
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 258
  },
  "setup.py": {
    "filepath": "../rich/setup.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "setuptools",
        "alias": null,
        "lineno": 5,
        "type": "import"
      }
    ],
    "variables": [],
    "is_entry_point": true,
    "main_block_calls": [
      "setuptools.setup"
    ],
    "module_level_calls": {
      "function_calls": [
        "setuptools.setup"
      ],
      "class_instantiations": []
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "setuptools"
        ]
      },
      "tech_stack": []
    },
    "line_count": 9
  },
  "tools/make_emoji.py": {
    "filepath": "../rich/tools/make_emoji.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "emoji.unicode_codes",
        "name": "EMOJI_ALIAS_UNICODE",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      },
      {
        "module": "emoji",
        "alias": null,
        "lineno": 2,
        "type": "import"
      }
    ],
    "variables": [
      {
        "name": "emoji",
        "assigned_to": null,
        "lineno": 9
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "unknown.strip",
        "str",
        "k.lower",
        "emoji",
        "EMOJI_ALIAS_UNICODE.items",
        "f.write",
        "open",
        "print"
      ],
      "class_instantiations": [
        "EMOJI_ALIAS_UNICODE"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "emoji"
        ]
      },
      "tech_stack": []
    },
    "line_count": 13
  },
  "tools/make_terminal_widths.py": {
    "filepath": "../rich/tools/make_terminal_widths.py",
    "module_docstring": null,
    "functions": [
      {
        "name": "make_widths_table",
        "args": [],
        "return_type": "List[Tuple[int, int, int]]",
        "lineno": 13,
        "decorators": [],
        "is_async": false,
        "calls": [
          "range",
          "iter_widths",
          "append",
          "chr",
          "next",
          "table.append",
          "cell_size",
          "iter",
          "_widths",
          "make_table_task",
          "codepoint",
          "wcwidth",
          "progress.add_task",
          "endpoint",
          "len",
          "progress.track"
        ],
        "docstring": null,
        "code": "def make_widths_table() -> List[Tuple[int, int, int]]:\n    table: List[Tuple[int, int, int]] = []\n    append = table.append\n\n    make_table_task = progress.add_task(\"Calculating table...\")\n\n    widths = (\n        (codepoint, wcwidth(chr(codepoint)))\n        for codepoint in range(0, sys.maxunicode + 1)\n    )\n\n    _widths = [(codepoint, width) for codepoint, width in widths if width != 1]\n    iter_widths = iter(_widths)\n\n    endpoint, group_cell_size = next(iter_widths)\n    start_codepoint = end_codepoint = endpoint\n    for codepoint, cell_size in progress.track(\n        iter_widths, task_id=make_table_task, total=len(_widths) - 1\n    ):\n        if cell_size != group_cell_size or codepoint != end_codepoint + 1:\n            append((start_codepoint, end_codepoint, group_cell_size))\n            start_codepoint = end_codepoint = codepoint\n            group_cell_size = cell_size\n        else:\n            end_codepoint = codepoint\n    append((start_codepoint, end_codepoint, group_cell_size))\n    return table",
        "line_count": 27,
        "needs_llm_summary": true
      },
      {
        "name": "get_cell_size",
        "args": [
          {
            "name": "table",
            "type": "List[Tuple[int, int, int]]"
          },
          {
            "name": "character",
            "type": "str"
          }
        ],
        "return_type": "int",
        "lineno": 42,
        "decorators": [],
        "is_async": false,
        "calls": [
          "table",
          "ord",
          "character",
          "len"
        ],
        "docstring": null,
        "code": "def get_cell_size(table: List[Tuple[int, int, int]], character: str) -> int:\n    codepoint = ord(character)\n    lower_bound = 0\n    upper_bound = len(table) - 1\n    index = (lower_bound + upper_bound) // 2\n    while True:\n        start, end, width = table[index]\n        if codepoint < start:\n            upper_bound = index - 1\n        elif codepoint > end:\n            lower_bound = index + 1\n        else:\n            return width\n        if upper_bound < lower_bound:\n            break\n        index = (lower_bound + upper_bound) // 2\n    return 1",
        "line_count": 17,
        "needs_llm_summary": true
      },
      {
        "name": "test",
        "args": [
          {
            "name": "widths_table"
          }
        ],
        "return_type": null,
        "lineno": 61,
        "decorators": [],
        "is_async": false,
        "calls": [
          "get_cell_size",
          "range",
          "character",
          "chr",
          "widths_table",
          "wcwidth",
          "print",
          "codepoint",
          "progress.track"
        ],
        "docstring": null,
        "code": "def test(widths_table):\n    for codepoint in progress.track(\n        range(0, sys.maxunicode + 1), description=\"Testing...\"\n    ):\n        character = chr(codepoint)\n        width1 = get_cell_size(widths_table, character)\n        width2 = wcwidth(character)\n        if width1 != width2:\n            print(f\"{width1} != {width2}\")\n            break",
        "line_count": 10,
        "needs_llm_summary": true
      },
      {
        "name": "run",
        "args": [],
        "return_type": null,
        "lineno": 73,
        "decorators": [],
        "is_async": false,
        "calls": [
          "table_file",
          "widths_table",
          "subprocess.run",
          "make_widths_table",
          "test",
          "fh.write",
          "open"
        ],
        "docstring": null,
        "code": "def run():\n    with progress:\n        widths_table = make_widths_table()\n        test(widths_table)\n    table_file = f\"\"\"# Auto generated by make_terminal_widths.py\n\nCELL_WIDTHS = {widths_table!r}\n\n\"\"\"\n    with open(\"../rich/_cell_widths.py\", \"wt\") as fh:\n        fh.write(table_file)\n\n    subprocess.run(\"black ../rich/_cell_widths.py\", shell=True)",
        "line_count": 13,
        "needs_llm_summary": true
      }
    ],
    "classes": [],
    "imports": [
      {
        "module": "subprocess",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "typing",
        "name": "List",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "typing",
        "name": "Tuple",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "sys",
        "alias": null,
        "lineno": 3,
        "type": "import"
      },
      {
        "module": "rich.progress",
        "name": "Progress",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      },
      {
        "module": "wcwidth",
        "name": "wcwidth",
        "alias": null,
        "lineno": 7,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "progress",
        "assigned_to": "Progress",
        "lineno": 10
      }
    ],
    "is_entry_point": true,
    "main_block_calls": [
      "run"
    ],
    "module_level_calls": {
      "function_calls": [
        "run",
        "Progress"
      ],
      "class_instantiations": [
        "Progress"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "sys",
        "subprocess",
        "typing"
      ],
      "third_party": {
        "other": [
          "rich",
          "wcwidth"
        ]
      },
      "tech_stack": []
    },
    "line_count": 90
  },
  "tools/profile_divide.py": {
    "filepath": "../rich/tools/profile_divide.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich.segment",
        "name": "Segment",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "time",
        "name": "perf_counter",
        "alias": null,
        "lineno": 9,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "text",
        "assigned_to": "str",
        "lineno": 3
      },
      {
        "name": "segments",
        "assigned_to": null,
        "lineno": 6
      },
      {
        "name": "start",
        "assigned_to": "perf_counter",
        "lineno": 11
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "range",
        "perf_counter",
        "print",
        "list",
        "segments",
        "text",
        "Segment",
        "Segment.divide",
        "len"
      ],
      "class_instantiations": [
        "Segment"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 15
  },
  "tools/profile_pretty.py": {
    "filepath": "../rich/tools/profile_pretty.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "json",
        "alias": null,
        "lineno": 1,
        "type": "import"
      },
      {
        "module": "io",
        "alias": null,
        "lineno": 2,
        "type": "import"
      },
      {
        "module": "time",
        "name": "time",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      },
      {
        "module": "rich.pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 5,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 8
      },
      {
        "name": "start",
        "assigned_to": "time",
        "lineno": 15
      },
      {
        "name": "pretty",
        "assigned_to": "Pretty",
        "lineno": 16
      },
      {
        "name": "result",
        "assigned_to": "console.end_capture",
        "lineno": 18
      },
      {
        "name": "taken",
        "assigned_to": null,
        "lineno": 19
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "fh",
        "result",
        "json.load",
        "cats",
        "Pretty",
        "console.end_capture",
        "pretty",
        "Console",
        "print",
        "console.file.getvalue",
        "open",
        "io.StringIO",
        "time",
        "console.begin_capture"
      ],
      "class_instantiations": [
        "Pretty",
        "Console"
      ]
    },
    "dependency_classification": {
      "stdlib": [
        "io",
        "json",
        "time"
      ],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 24
  },
  "tools/stress_test_pretty.py": {
    "filepath": "../rich/tools/stress_test_pretty.py",
    "module_docstring": null,
    "functions": [],
    "classes": [],
    "imports": [
      {
        "module": "rich.console",
        "name": "Console",
        "alias": null,
        "lineno": 1,
        "type": "from_import"
      },
      {
        "module": "rich.panel",
        "name": "Panel",
        "alias": null,
        "lineno": 2,
        "type": "from_import"
      },
      {
        "module": "rich.pretty",
        "name": "Pretty",
        "alias": null,
        "lineno": 3,
        "type": "from_import"
      },
      {
        "module": "rich._timer",
        "name": "timer",
        "alias": null,
        "lineno": 4,
        "type": "from_import"
      }
    ],
    "variables": [
      {
        "name": "DATA",
        "assigned_to": null,
        "lineno": 6
      },
      {
        "name": "console",
        "assigned_to": "Console",
        "lineno": 18
      }
    ],
    "is_entry_point": false,
    "main_block_calls": [],
    "module_level_calls": {
      "function_calls": [
        "console.print",
        "w",
        "range",
        "Pretty",
        "DATA",
        "Console",
        "Panel",
        "timer"
      ],
      "class_instantiations": [
        "Pretty",
        "Console",
        "Panel"
      ]
    },
    "dependency_classification": {
      "stdlib": [],
      "third_party": {
        "other": [
          "rich"
        ]
      },
      "tech_stack": []
    },
    "line_count": 22
  },
  "__analysis_summary__": {
    "total_modules": 123,
    "total_functions": 574,
    "total_classes": 195,
    "dead_code_candidates": {
      "unreferenced_functions": [
        {
          "name": "time_wrapping",
          "module": "benchmarks/benchmarks.py",
          "lineno": 22
        },
        {
          "name": "time_indent_guides",
          "module": "benchmarks/benchmarks.py",
          "lineno": 25
        },
        {
          "name": "time_fit",
          "module": "benchmarks/benchmarks.py",
          "lineno": 28
        },
        {
          "name": "time_split",
          "module": "benchmarks/benchmarks.py",
          "lineno": 31
        },
        {
          "name": "time_divide",
          "module": "benchmarks/benchmarks.py",
          "lineno": 34
        },
        {
          "name": "time_align_center",
          "module": "benchmarks/benchmarks.py",
          "lineno": 37
        },
        {
          "name": "time_render",
          "module": "benchmarks/benchmarks.py",
          "lineno": 40
        },
        {
          "name": "time_wrapping_unicode_heavy",
          "module": "benchmarks/benchmarks.py",
          "lineno": 43
        },
        {
          "name": "time_fit_unicode_heavy",
          "module": "benchmarks/benchmarks.py",
          "lineno": 46
        },
        {
          "name": "time_split_unicode_heavy",
          "module": "benchmarks/benchmarks.py",
          "lineno": 49
        },
        {
          "name": "time_divide_unicode_heavy",
          "module": "benchmarks/benchmarks.py",
          "lineno": 52
        },
        {
          "name": "time_align_center_unicode_heavy",
          "module": "benchmarks/benchmarks.py",
          "lineno": 55
        },
        {
          "name": "time_render_unicode_heavy",
          "module": "benchmarks/benchmarks.py",
          "lineno": 60
        },
        {
          "name": "time_wrapping_unicode_heavy_warm_cache",
          "module": "benchmarks/benchmarks.py",
          "lineno": 70
        },
        {
          "name": "time_text_thin_terminal_heavy_wrapping",
          "module": "benchmarks/benchmarks.py",
          "lineno": 84
        },
        {
          "name": "time_text_thin_terminal_medium_wrapping",
          "module": "benchmarks/benchmarks.py",
          "lineno": 87
        },
        {
          "name": "time_text_wide_terminal_no_wrapping",
          "module": "benchmarks/benchmarks.py",
          "lineno": 90
        },
        {
          "name": "time_table_no_wrapping",
          "module": "benchmarks/benchmarks.py",
          "lineno": 98
        },
        {
          "name": "time_table_heavy_wrapping",
          "module": "benchmarks/benchmarks.py",
          "lineno": 101
        },
        {
          "name": "time_pretty",
          "module": "benchmarks/benchmarks.py",
          "lineno": 135
        },
        {
          "name": "time_pretty_indent_guides",
          "module": "benchmarks/benchmarks.py",
          "lineno": 139
        },
        {
          "name": "time_pretty_justify_center",
          "module": "benchmarks/benchmarks.py",
          "lineno": 143
        },
        {
          "name": "time_parse_ansi",
          "module": "benchmarks/benchmarks.py",
          "lineno": 156
        },
        {
          "name": "time_parse_hex",
          "module": "benchmarks/benchmarks.py",
          "lineno": 159
        },
        {
          "name": "time_parse_mixed_complex_style",
          "module": "benchmarks/benchmarks.py",
          "lineno": 162
        },
        {
          "name": "time_style_add",
          "module": "benchmarks/benchmarks.py",
          "lineno": 165
        },
        {
          "name": "time_downgrade_to_eight_bit",
          "module": "benchmarks/benchmarks.py",
          "lineno": 176
        },
        {
          "name": "time_downgrade_to_standard",
          "module": "benchmarks/benchmarks.py",
          "lineno": 179
        },
        {
          "name": "time_downgrade_to_windows",
          "module": "benchmarks/benchmarks.py",
          "lineno": 182
        },
        {
          "name": "time_downgrade_to_eight_bit",
          "module": "benchmarks/benchmarks.py",
          "lineno": 197
        },
        {
          "name": "time_downgrade_to_standard",
          "module": "benchmarks/benchmarks.py",
          "lineno": 200
        },
        {
          "name": "time_downgrade_to_windows",
          "module": "benchmarks/benchmarks.py",
          "lineno": 203
        },
        {
          "name": "test_divide_complex",
          "module": "benchmarks/benchmarks.py",
          "lineno": 217
        },
        {
          "name": "reconfigure",
          "module": "rich/__init__.py",
          "lineno": 39
        },
        {
          "name": "is_object_one_of_types",
          "module": "rich/_inspect.py",
          "lineno": 258
        },
        {
          "name": "writable",
          "module": "rich/_null_file.py",
          "lineno": 36
        },
        {
          "name": "writelines",
          "module": "rich/_null_file.py",
          "lineno": 39
        },
        {
          "name": "parse_rgb_hex",
          "module": "rich/color.py",
          "lineno": 571
        },
        {
          "name": "_svg_hash",
          "module": "rich/console.py",
          "lineno": 2615
        },
        {
          "name": "decorator",
          "module": "rich/console.py",
          "lineno": 496
        },
        {
          "name": "_buffer_index",
          "module": "rich/console.py",
          "lineno": 787
        },
        {
          "name": "out",
          "module": "rich/console.py",
          "lineno": 1616
        },
        {
          "name": "update_screen",
          "module": "rich/console.py",
          "lineno": 1808
        },
        {
          "name": "_replace",
          "module": "rich/console.py",
          "lineno": 502
        },
        {
          "name": "_combine_regex",
          "module": "rich/highlighter.py",
          "lineno": 8
        },
        {
          "name": "_repr_mimebundle_",
          "module": "rich/jupyter.py",
          "lineno": 25
        },
        {
          "name": "_repr_mimebundle_",
          "module": "rich/jupyter.py",
          "lineno": 41
        },
        {
          "name": "add_split",
          "module": "rich/layout.py",
          "lineno": 286
        },
        {
          "name": "unsplit",
          "module": "rich/layout.py",
          "lineno": 315
        },
        {
          "name": "refresh_screen",
          "module": "rich/layout.py",
          "lineno": 328
        },
        {
          "name": "emit",
          "module": "rich/logging.py",
          "lineno": 132
        },
        {
          "name": "_get_braces_for_defaultdict",
          "module": "rich/pretty.py",
          "lineno": 357
        },
        {
          "name": "_get_braces_for_deque",
          "module": "rich/pretty.py",
          "lineno": 365
        },
        {
          "name": "_get_braces_for_array",
          "module": "rich/pretty.py",
          "lineno": 375
        },
        {
          "name": "pprint",
          "module": "rich/pretty.py",
          "lineno": 918
        },
        {
          "name": "writable",
          "module": "rich/progress.py",
          "lineno": 242
        },
        {
          "name": "writelines",
          "module": "rich/progress.py",
          "lineno": 281
        },
        {
          "name": "set_spinner",
          "module": "rich/progress.py",
          "lineno": 592
        },
        {
          "name": "remove_task",
          "module": "rich/progress.py",
          "lineno": 1642
        },
        {
          "name": "rich_repr",
          "module": "rich/repr.py",
          "lineno": 105
        },
        {
          "name": "rich_repr",
          "module": "rich/repr.py",
          "lineno": 110
        },
        {
          "name": "rich_repr",
          "module": "rich/repr.py",
          "lineno": 114
        },
        {
          "name": "clear_meta_and_links",
          "module": "rich/style.py",
          "lineno": 645
        },
        {
          "name": "add_section",
          "module": "rich/table.py",
          "lineno": 470
        },
        {
          "name": "move",
          "module": "rich/text.py",
          "lineno": 76
        },
        {
          "name": "on",
          "module": "rich/text.py",
          "lineno": 523
        }
      ],
      "unused_classes": [
        {
          "name": "TextSuite",
          "module": "benchmarks/benchmarks.py",
          "lineno": 14
        },
        {
          "name": "TextHotCacheSuite",
          "module": "benchmarks/benchmarks.py",
          "lineno": 64
        },
        {
          "name": "SyntaxWrappingSuite",
          "module": "benchmarks/benchmarks.py",
          "lineno": 75
        },
        {
          "name": "TableSuite",
          "module": "benchmarks/benchmarks.py",
          "lineno": 97
        },
        {
          "name": "PrettySuite",
          "module": "benchmarks/benchmarks.py",
          "lineno": 129
        },
        {
          "name": "StyleSuite",
          "module": "benchmarks/benchmarks.py",
          "lineno": 148
        },
        {
          "name": "ColorSuite",
          "module": "benchmarks/benchmarks.py",
          "lineno": 169
        },
        {
          "name": "ColorSuiteCached",
          "module": "benchmarks/benchmarks.py",
          "lineno": 186
        },
        {
          "name": "SegmentSuite",
          "module": "benchmarks/benchmarks.py",
          "lineno": 207
        },
        {
          "name": "Edge",
          "module": "rich/_ratio.py",
          "lineno": 6
        },
        {
          "name": "VerticalCenter",
          "module": "rich/align.py",
          "lineno": 228
        },
        {
          "name": "ColorType",
          "module": "rich/color.py",
          "lineno": 36
        },
        {
          "name": "RichCast",
          "module": "rich/console.py",
          "lineno": 253
        },
        {
          "name": "RenderHook",
          "module": "rich/console.py",
          "lineno": 550
        },
        {
          "name": "Emoji",
          "module": "rich/emoji.py",
          "lineno": 22
        },
        {
          "name": "ConsoleError",
          "module": "rich/errors.py",
          "lineno": 1
        },
        {
          "name": "StyleError",
          "module": "rich/errors.py",
          "lineno": 5
        },
        {
          "name": "StyleSyntaxError",
          "module": "rich/errors.py",
          "lineno": 9
        },
        {
          "name": "MissingStyle",
          "module": "rich/errors.py",
          "lineno": 13
        },
        {
          "name": "StyleStackError",
          "module": "rich/errors.py",
          "lineno": 17
        },
        {
          "name": "NotRenderableError",
          "module": "rich/errors.py",
          "lineno": 21
        },
        {
          "name": "LiveError",
          "module": "rich/errors.py",
          "lineno": 29
        },
        {
          "name": "NoAltScreen",
          "module": "rich/errors.py",
          "lineno": 33
        },
        {
          "name": "Highlighter",
          "module": "rich/highlighter.py",
          "lineno": 17
        },
        {
          "name": "RegexHighlighter",
          "module": "rich/highlighter.py",
          "lineno": 61
        },
        {
          "name": "ISO8601Highlighter",
          "module": "rich/highlighter.py",
          "lineno": 143
        },
        {
          "name": "JupyterMixin",
          "module": "rich/jupyter.py",
          "lineno": 36
        },
        {
          "name": "LayoutError",
          "module": "rich/layout.py",
          "lineno": 43
        },
        {
          "name": "RowSplitter",
          "module": "rich/layout.py",
          "lineno": 101
        },
        {
          "name": "ColumnSplitter",
          "module": "rich/layout.py",
          "lineno": 121
        },
        {
          "name": "MarkdownElement",
          "module": "rich/markdown.py",
          "lineno": 25
        },
        {
          "name": "UnknownElement",
          "module": "rich/markdown.py",
          "lineno": 82
        },
        {
          "name": "TextElement",
          "module": "rich/markdown.py",
          "lineno": 91
        },
        {
          "name": "Paragraph",
          "module": "rich/markdown.py",
          "lineno": 107
        },
        {
          "name": "Heading",
          "module": "rich/markdown.py",
          "lineno": 127
        },
        {
          "name": "CodeBlock",
          "module": "rich/markdown.py",
          "lineno": 162
        },
        {
          "name": "BlockQuote",
          "module": "rich/markdown.py",
          "lineno": 187
        },
        {
          "name": "HorizontalRule",
          "module": "rich/markdown.py",
          "lineno": 213
        },
        {
          "name": "TableElement",
          "module": "rich/markdown.py",
          "lineno": 225
        },
        {
          "name": "ListElement",
          "module": "rich/markdown.py",
          "lineno": 325
        },
        {
          "name": "ImageItem",
          "module": "rich/markdown.py",
          "lineno": 410
        },
        {
          "name": "Pager",
          "module": "rich/pager.py",
          "lineno": 5
        },
        {
          "name": "ProgressColumn",
          "module": "rich/progress.py",
          "lineno": 507
        },
        {
          "name": "RenderableColumn",
          "module": "rich/progress.py",
          "lineno": 549
        },
        {
          "name": "FileSizeColumn",
          "module": "rich/progress.py",
          "lineno": 820
        },
        {
          "name": "TotalFileSizeColumn",
          "module": "rich/progress.py",
          "lineno": 829
        },
        {
          "name": "MofNCompleteColumn",
          "module": "rich/progress.py",
          "lineno": 838
        },
        {
          "name": "PromptError",
          "module": "rich/prompt.py",
          "lineno": 11
        },
        {
          "name": "PromptBase",
          "module": "rich/prompt.py",
          "lineno": 30
        },
        {
          "name": "FloatPrompt",
          "module": "rich/prompt.py",
          "lineno": 328
        },
        {
          "name": "SegmentLines",
          "module": "rich/segment.py",
          "lineno": 696
        },
        {
          "name": "_Bit",
          "module": "rich/style.py",
          "lineno": 21
        },
        {
          "name": "PaddingProperty",
          "module": "rich/syntax.py",
          "lineno": 229
        }
      ],
      "unused_imports": [
        {
          "module": "examples/attrs.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/attrs.py",
          "import_statement": "import attr",
          "lineno": 4,
          "imported_module": "attr",
          "symbols": [
            "attr"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/downloader.py",
          "import_statement": "import sys",
          "lineno": 6,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/listdir.py",
          "import_statement": "import sys",
          "lineno": 10,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/overflow.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/overflow.py",
          "import_statement": "import rich.console",
          "lineno": 2,
          "imported_module": "rich.console",
          "symbols": [
            "OverflowMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/repr.py",
          "import_statement": "import rich.repr",
          "lineno": 1,
          "imported_module": "rich.repr",
          "symbols": [
            "rich.repr"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/table_movie.py",
          "import_statement": "import contextlib",
          "lineno": 3,
          "imported_module": "contextlib",
          "symbols": [
            "contextmanager"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/top_lite_simulator.py",
          "import_statement": "import dataclasses",
          "lineno": 5,
          "imported_module": "dataclasses",
          "symbols": [
            "dataclass"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/top_lite_simulator.py",
          "import_statement": "import typing",
          "lineno": 11,
          "imported_module": "typing",
          "symbols": [
            "Literal"
          ],
          "needs_llm": false
        },
        {
          "module": "examples/tree.py",
          "import_statement": "import sys",
          "lineno": 7,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_fileno.py",
          "import_statement": "import __future__",
          "lineno": 1,
          "imported_module": "__future__",
          "symbols": [
            "annotations"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_inspect.py",
          "import_statement": "import text",
          "lineno": 12,
          "imported_module": "text",
          "symbols": [
            "TextType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_log_render.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_log_render.py",
          "import_statement": "import console",
          "lineno": 8,
          "imported_module": "console",
          "symbols": [
            "RenderableType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_ratio.py",
          "import_statement": "import dataclasses",
          "lineno": 144,
          "imported_module": "dataclasses",
          "symbols": [
            "dataclass"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_stack.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_timer.py",
          "import_statement": "import contextlib",
          "lineno": 8,
          "imported_module": "contextlib",
          "symbols": [
            "contextlib"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_win32_console.py",
          "import_statement": "import typing",
          "lineno": 18,
          "imported_module": "typing",
          "symbols": [
            "Type"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_windows.py",
          "import_statement": "import dataclasses",
          "lineno": 2,
          "imported_module": "dataclasses",
          "symbols": [
            "dataclass"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_windows.py",
          "import_statement": "import rich._win32_console",
          "lineno": 25,
          "imported_module": "rich._win32_console",
          "symbols": [
            "ENABLE_VIRTUAL_TERMINAL_PROCESSING"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_windows.py",
          "import_statement": "import rich._win32_console",
          "lineno": 25,
          "imported_module": "rich._win32_console",
          "symbols": [
            "LegacyWindowsError"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_windows_renderer.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Sequence"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_windows_renderer.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Tuple"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_windows_renderer.py",
          "import_statement": "import rich.segment",
          "lineno": 4,
          "imported_module": "rich.segment",
          "symbols": [
            "ControlCode"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_windows_renderer.py",
          "import_statement": "import rich.segment",
          "lineno": 4,
          "imported_module": "rich.segment",
          "symbols": [
            "ControlType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/_wrap.py",
          "import_statement": "import __future__",
          "lineno": 1,
          "imported_module": "__future__",
          "symbols": [
            "annotations"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/align.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "Literal"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/ansi.py",
          "import_statement": "import sys",
          "lineno": 2,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/ansi.py",
          "import_statement": "import sys",
          "lineno": 218,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/bar.py",
          "import_statement": "import color",
          "lineno": 3,
          "imported_module": "color",
          "symbols": [
            "Color"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/box.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/cells.py",
          "import_statement": "import __future__",
          "lineno": 1,
          "imported_module": "__future__",
          "symbols": [
            "annotations"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/color.py",
          "import_statement": "import sys",
          "lineno": 2,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/color.py",
          "import_statement": "import _palettes",
          "lineno": 8,
          "imported_module": "_palettes",
          "symbols": [
            "EIGHT_BIT_PALETTE"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/color.py",
          "import_statement": "import repr",
          "lineno": 10,
          "imported_module": "repr",
          "symbols": [
            "rich_repr"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/columns.py",
          "import_statement": "import typing",
          "lineno": 4,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/columns.py",
          "import_statement": "import typing",
          "lineno": 4,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/columns.py",
          "import_statement": "import align",
          "lineno": 6,
          "imported_module": "align",
          "symbols": [
            "AlignMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/columns.py",
          "import_statement": "import text",
          "lineno": 12,
          "imported_module": "text",
          "symbols": [
            "TextType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import abc",
          "lineno": 6,
          "imported_module": "abc",
          "symbols": [
            "abstractmethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import dataclasses",
          "lineno": 7,
          "imported_module": "dataclasses",
          "symbols": [
            "dataclass"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import dataclasses",
          "lineno": 7,
          "imported_module": "dataclasses",
          "symbols": [
            "field"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import time",
          "lineno": 15,
          "imported_module": "time",
          "symbols": [
            "monotonic"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import types",
          "lineno": 16,
          "imported_module": "types",
          "symbols": [
            "ModuleType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import typing",
          "lineno": 17,
          "imported_module": "typing",
          "symbols": [
            "Literal"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import typing",
          "lineno": 17,
          "imported_module": "typing",
          "symbols": [
            "Mapping"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import typing",
          "lineno": 17,
          "imported_module": "typing",
          "symbols": [
            "TextIO"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import typing",
          "lineno": 17,
          "imported_module": "typing",
          "symbols": [
            "runtime_checkable"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import _export_format",
          "lineno": 42,
          "imported_module": "_export_format",
          "symbols": [
            "CONSOLE_HTML_FORMAT"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import _export_format",
          "lineno": 42,
          "imported_module": "_export_format",
          "symbols": [
            "CONSOLE_SVG_FORMAT"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import _log_render",
          "lineno": 44,
          "imported_module": "_log_render",
          "symbols": [
            "FormatTimeCallable"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import emoji",
          "lineno": 48,
          "imported_module": "emoji",
          "symbols": [
            "EmojiVariant"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import region",
          "lineno": 55,
          "imported_module": "region",
          "symbols": [
            "Region"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import terminal_theme",
          "lineno": 61,
          "imported_module": "terminal_theme",
          "symbols": [
            "DEFAULT_TERMINAL_THEME"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import terminal_theme",
          "lineno": 61,
          "imported_module": "terminal_theme",
          "symbols": [
            "SVG_EXPORT_THEME"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/console.py",
          "import_statement": "import terminal_theme",
          "lineno": 61,
          "imported_module": "terminal_theme",
          "symbols": [
            "TerminalTheme"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/containers.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "overload"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/control.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/control.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "Final"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/default_styles.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/emoji.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "Literal"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/file_proxy.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/highlighter.py",
          "import_statement": "import abc",
          "lineno": 2,
          "imported_module": "abc",
          "symbols": [
            "abstractmethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/highlighter.py",
          "import_statement": "import typing",
          "lineno": 3,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/jupyter.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/layout.py",
          "import_statement": "import abc",
          "lineno": 1,
          "imported_module": "abc",
          "symbols": [
            "abstractmethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/layout.py",
          "import_statement": "import typing",
          "lineno": 5,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/layout.py",
          "import_statement": "import highlighter",
          "lineno": 20,
          "imported_module": "highlighter",
          "symbols": [
            "ReprHighlighter"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/layout.py",
          "import_statement": "import repr",
          "lineno": 24,
          "imported_module": "repr",
          "symbols": [
            "rich_repr"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/live.py",
          "import_statement": "import __future__",
          "lineno": 1,
          "imported_module": "__future__",
          "symbols": [
            "annotations"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/live.py",
          "import_statement": "import typing",
          "lineno": 6,
          "imported_module": "typing",
          "symbols": [
            "TextIO"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/live.py",
          "import_statement": "import live_render",
          "lineno": 13,
          "imported_module": "live_render",
          "symbols": [
            "VerticalOverflowMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/live.py",
          "import_statement": "import typing",
          "lineno": 300,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/live.py",
          "import_statement": "import typing",
          "lineno": 300,
          "imported_module": "typing",
          "symbols": [
            "Tuple"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/live_render.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Tuple"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/live_render.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Literal"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/logging.py",
          "import_statement": "import types",
          "lineno": 5,
          "imported_module": "types",
          "symbols": [
            "ModuleType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/logging.py",
          "import_statement": "import typing",
          "lineno": 6,
          "imported_module": "typing",
          "symbols": [
            "ClassVar"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/logging.py",
          "import_statement": "import typing",
          "lineno": 6,
          "imported_module": "typing",
          "symbols": [
            "Iterable"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/logging.py",
          "import_statement": "import typing",
          "lineno": 6,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/logging.py",
          "import_statement": "import typing",
          "lineno": 6,
          "imported_module": "typing",
          "symbols": [
            "Type"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/logging.py",
          "import_statement": "import _log_render",
          "lineno": 11,
          "imported_module": "_log_render",
          "symbols": [
            "FormatTimeCallable"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/logging.py",
          "import_statement": "import highlighter",
          "lineno": 13,
          "imported_module": "highlighter",
          "symbols": [
            "Highlighter"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/logging.py",
          "import_statement": "import highlighter",
          "lineno": 13,
          "imported_module": "highlighter",
          "symbols": [
            "ReprHighlighter"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/markdown.py",
          "import_statement": "import __future__",
          "lineno": 1,
          "imported_module": "__future__",
          "symbols": [
            "annotations"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/markdown.py",
          "import_statement": "import typing",
          "lineno": 4,
          "imported_module": "typing",
          "symbols": [
            "ClassVar"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/markup.py",
          "import_statement": "import typing",
          "lineno": 4,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/padding.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/padding.py",
          "import_statement": "import style",
          "lineno": 14,
          "imported_module": "style",
          "symbols": [
            "Style"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pager.py",
          "import_statement": "import abc",
          "lineno": 1,
          "imported_module": "abc",
          "symbols": [
            "abstractmethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/panel.py",
          "import_statement": "import align",
          "lineno": 3,
          "imported_module": "align",
          "symbols": [
            "AlignMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/panel.py",
          "import_statement": "import box",
          "lineno": 4,
          "imported_module": "box",
          "symbols": [
            "ROUNDED"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/panel.py",
          "import_statement": "import padding",
          "lineno": 8,
          "imported_module": "padding",
          "symbols": [
            "PaddingDimensions"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/panel.py",
          "import_statement": "import style",
          "lineno": 10,
          "imported_module": "style",
          "symbols": [
            "StyleType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/panel.py",
          "import_statement": "import text",
          "lineno": 11,
          "imported_module": "text",
          "symbols": [
            "TextType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/panel.py",
          "import_statement": "import box",
          "lineno": 305,
          "imported_module": "box",
          "symbols": [
            "ROUNDED"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import builtins",
          "lineno": 1,
          "imported_module": "builtins",
          "symbols": [
            "builtins"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import dataclasses",
          "lineno": 3,
          "imported_module": "dataclasses",
          "symbols": [
            "dataclasses"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import reprlib",
          "lineno": 6,
          "imported_module": "reprlib",
          "symbols": [
            "reprlib"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import sys",
          "lineno": 7,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import collections",
          "lineno": 9,
          "imported_module": "collections",
          "symbols": [
            "UserDict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import collections",
          "lineno": 9,
          "imported_module": "collections",
          "symbols": [
            "UserList"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import collections",
          "lineno": 9,
          "imported_module": "collections",
          "symbols": [
            "deque"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import types",
          "lineno": 13,
          "imported_module": "types",
          "symbols": [
            "MappingProxyType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import typing",
          "lineno": 14,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import typing",
          "lineno": 14,
          "imported_module": "typing",
          "symbols": [
            "Set"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import rich.repr",
          "lineno": 30,
          "imported_module": "rich.repr",
          "symbols": [
            "RichReprResult"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/pretty.py",
          "import_statement": "import console",
          "lineno": 50,
          "imported_module": "console",
          "symbols": [
            "JustifyMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/progress.py",
          "import_statement": "import __future__",
          "lineno": 1,
          "imported_module": "__future__",
          "symbols": [
            "annotations"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/progress.py",
          "import_statement": "import abc",
          "lineno": 6,
          "imported_module": "abc",
          "symbols": [
            "abstractmethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/progress.py",
          "import_statement": "import collections",
          "lineno": 7,
          "imported_module": "collections",
          "symbols": [
            "deque"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/progress.py",
          "import_statement": "import dataclasses",
          "lineno": 8,
          "imported_module": "dataclasses",
          "symbols": [
            "dataclass"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/progress.py",
          "import_statement": "import typing",
          "lineno": 17,
          "imported_module": "typing",
          "symbols": [
            "Deque"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/progress.py",
          "import_statement": "import typing",
          "lineno": 17,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/progress.py",
          "import_statement": "import typing",
          "lineno": 17,
          "imported_module": "typing",
          "symbols": [
            "Generic"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/prompt.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Generic"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/prompt.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/prompt.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "overload"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/protocol.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Set"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/repr.py",
          "import_statement": "import typing",
          "lineno": 3,
          "imported_module": "typing",
          "symbols": [
            "Iterable"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/repr.py",
          "import_statement": "import typing",
          "lineno": 3,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/repr.py",
          "import_statement": "import typing",
          "lineno": 3,
          "imported_module": "typing",
          "symbols": [
            "Tuple"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/repr.py",
          "import_statement": "import typing",
          "lineno": 3,
          "imported_module": "typing",
          "symbols": [
            "overload"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/rule.py",
          "import_statement": "import align",
          "lineno": 3,
          "imported_module": "align",
          "symbols": [
            "AlignMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/rule.py",
          "import_statement": "import style",
          "lineno": 8,
          "imported_module": "style",
          "symbols": [
            "Style"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/rule.py",
          "import_statement": "import sys",
          "lineno": 118,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/scope.py",
          "import_statement": "import text",
          "lineno": 8,
          "imported_module": "text",
          "symbols": [
            "TextType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/screen.py",
          "import_statement": "import style",
          "lineno": 4,
          "imported_module": "style",
          "symbols": [
            "StyleType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/screen.py",
          "import_statement": "import console",
          "lineno": 9,
          "imported_module": "console",
          "symbols": [
            "RenderableType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/segment.py",
          "import_statement": "import typing",
          "lineno": 6,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/segment.py",
          "import_statement": "import typing",
          "lineno": 6,
          "imported_module": "typing",
          "symbols": [
            "Sequence"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/segment.py",
          "import_statement": "import repr",
          "lineno": 26,
          "imported_module": "repr",
          "symbols": [
            "rich_repr"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/spinner.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/spinner.py",
          "import_statement": "import style",
          "lineno": 10,
          "imported_module": "style",
          "symbols": [
            "StyleType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/status.py",
          "import_statement": "import style",
          "lineno": 8,
          "imported_module": "style",
          "symbols": [
            "StyleType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/style.py",
          "import_statement": "import typing",
          "lineno": 6,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/style.py",
          "import_statement": "import color",
          "lineno": 9,
          "imported_module": "color",
          "symbols": [
            "ColorParseError"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/style.py",
          "import_statement": "import repr",
          "lineno": 10,
          "imported_module": "repr",
          "symbols": [
            "rich_repr"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/style.py",
          "import_statement": "import terminal_theme",
          "lineno": 11,
          "imported_module": "terminal_theme",
          "symbols": [
            "DEFAULT_TERMINAL_THEME"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import __future__",
          "lineno": 1,
          "imported_module": "__future__",
          "symbols": [
            "annotations"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import abc",
          "lineno": 7,
          "imported_module": "abc",
          "symbols": [
            "abstractmethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import typing",
          "lineno": 9,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import pygments.token",
          "lineno": 27,
          "imported_module": "pygments.token",
          "symbols": [
            "Error"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import pygments.token",
          "lineno": 27,
          "imported_module": "pygments.token",
          "symbols": [
            "Generic"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import pygments.token",
          "lineno": 27,
          "imported_module": "pygments.token",
          "symbols": [
            "Keyword"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import pygments.token",
          "lineno": 27,
          "imported_module": "pygments.token",
          "symbols": [
            "Number"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import pygments.token",
          "lineno": 27,
          "imported_module": "pygments.token",
          "symbols": [
            "Operator"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import pygments.token",
          "lineno": 27,
          "imported_module": "pygments.token",
          "symbols": [
            "String"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import pygments.token",
          "lineno": 27,
          "imported_module": "pygments.token",
          "symbols": [
            "Whitespace"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import pygments.util",
          "lineno": 39,
          "imported_module": "pygments.util",
          "symbols": [
            "ClassNotFound"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import rich.containers",
          "lineno": 41,
          "imported_module": "rich.containers",
          "symbols": [
            "Lines"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/syntax.py",
          "import_statement": "import console",
          "lineno": 47,
          "imported_module": "console",
          "symbols": [
            "JustifyMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/table.py",
          "import_statement": "import dataclasses",
          "lineno": 1,
          "imported_module": "dataclasses",
          "symbols": [
            "dataclass"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/table.py",
          "import_statement": "import dataclasses",
          "lineno": 1,
          "imported_module": "dataclasses",
          "symbols": [
            "field"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/table.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/table.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "Sequence"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/table.py",
          "import_statement": "import console",
          "lineno": 28,
          "imported_module": "console",
          "symbols": [
            "OverflowMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/text.py",
          "import_statement": "import emoji",
          "lineno": 26,
          "imported_module": "emoji",
          "symbols": [
            "EmojiVariant"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/text.py",
          "import_statement": "import console",
          "lineno": 33,
          "imported_module": "console",
          "symbols": [
            "JustifyMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/text.py",
          "import_statement": "import console",
          "lineno": 33,
          "imported_module": "console",
          "symbols": [
            "OverflowMethod"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/theme.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/theme.py",
          "import_statement": "import typing",
          "lineno": 2,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/traceback.py",
          "import_statement": "import dataclasses",
          "lineno": 5,
          "imported_module": "dataclasses",
          "symbols": [
            "dataclass"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/traceback.py",
          "import_statement": "import dataclasses",
          "lineno": 5,
          "imported_module": "dataclasses",
          "symbols": [
            "field"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/traceback.py",
          "import_statement": "import types",
          "lineno": 8,
          "imported_module": "types",
          "symbols": [
            "ModuleType"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/traceback.py",
          "import_statement": "import typing",
          "lineno": 9,
          "imported_module": "typing",
          "symbols": [
            "Dict"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/traceback.py",
          "import_statement": "import typing",
          "lineno": 9,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/traceback.py",
          "import_statement": "import typing",
          "lineno": 9,
          "imported_module": "typing",
          "symbols": [
            "Sequence"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/traceback.py",
          "import_statement": "import typing",
          "lineno": 9,
          "imported_module": "typing",
          "symbols": [
            "Set"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/traceback.py",
          "import_statement": "import pygments.util",
          "lineno": 27,
          "imported_module": "pygments.util",
          "symbols": [
            "ClassNotFound"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/tree.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Iterator"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/tree.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "List"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/tree.py",
          "import_statement": "import typing",
          "lineno": 1,
          "imported_module": "typing",
          "symbols": [
            "Tuple"
          ],
          "needs_llm": false
        },
        {
          "module": "rich/tree.py",
          "import_statement": "import style",
          "lineno": 8,
          "imported_module": "style",
          "symbols": [
            "StyleType"
          ],
          "needs_llm": false
        },
        {
          "module": "tools/make_terminal_widths.py",
          "import_statement": "import sys",
          "lineno": 3,
          "imported_module": "sys",
          "symbols": [
            "sys"
          ],
          "needs_llm": false
        }
      ],
      "unused_global_variables": [
        {
          "module": "benchmarks/snippets.py",
          "name": "PYTHON_SNIPPET",
          "lineno": 1,
          "assigned_to": "str",
          "needs_llm": true
        },
        {
          "module": "benchmarks/snippets.py",
          "name": "PYTHON_DICT",
          "lineno": 70,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "benchmarks/snippets.py",
          "name": "LOREM_IPSUM",
          "lineno": 93,
          "assigned_to": "str",
          "needs_llm": true
        },
        {
          "module": "benchmarks/snippets.py",
          "name": "UNICODE_HEAVY_TEXT",
          "lineno": 105,
          "assigned_to": "str",
          "needs_llm": true
        },
        {
          "module": "benchmarks/snippets.py",
          "name": "MARKUP",
          "lineno": 176,
          "assigned_to": "unknown.join",
          "needs_llm": true
        },
        {
          "module": "examples/fullscreen.py",
          "name": "console",
          "lineno": 17,
          "assigned_to": "Console",
          "needs_llm": true
        },
        {
          "module": "examples/layout.py",
          "name": "console",
          "lineno": 17,
          "assigned_to": "Console",
          "needs_llm": true
        },
        {
          "module": "examples/live_progress.py",
          "name": "job1",
          "lineno": 21,
          "assigned_to": "job_progress.add_task",
          "needs_llm": true
        },
        {
          "module": "examples/live_progress.py",
          "name": "job2",
          "lineno": 22,
          "assigned_to": "job_progress.add_task",
          "needs_llm": true
        },
        {
          "module": "examples/live_progress.py",
          "name": "job3",
          "lineno": 23,
          "assigned_to": "job_progress.add_task",
          "needs_llm": true
        },
        {
          "module": "rich/_cell_widths.py",
          "name": "CELL_WIDTHS",
          "lineno": 3,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "rich/_emoji_codes.py",
          "name": "EMOJI",
          "lineno": 1,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "rich/_export_format.py",
          "name": "CONSOLE_HTML_FORMAT",
          "lineno": 1,
          "assigned_to": "str",
          "needs_llm": true
        },
        {
          "module": "rich/_export_format.py",
          "name": "CONSOLE_SVG_FORMAT",
          "lineno": 20,
          "assigned_to": "str",
          "needs_llm": true
        },
        {
          "module": "rich/_export_format.py",
          "name": "_SVG_FONT_FAMILY",
          "lineno": 75,
          "assigned_to": "str",
          "needs_llm": true
        },
        {
          "module": "rich/_export_format.py",
          "name": "_SVG_CLASSES_PREFIX",
          "lineno": 76,
          "assigned_to": "str",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "NULL_FILE",
          "lineno": 69,
          "assigned_to": "NullFile",
          "needs_llm": true
        },
        {
          "module": "rich/_palettes.py",
          "name": "WINDOWS_PALETTE",
          "lineno": 5,
          "assigned_to": "Palette",
          "needs_llm": true
        },
        {
          "module": "rich/_palettes.py",
          "name": "STANDARD_PALETTE",
          "lineno": 27,
          "assigned_to": "Palette",
          "needs_llm": true
        },
        {
          "module": "rich/_palettes.py",
          "name": "EIGHT_BIT_PALETTE",
          "lineno": 50,
          "assigned_to": "Palette",
          "needs_llm": true
        },
        {
          "module": "rich/_spinners.py",
          "name": "SPINNERS",
          "lineno": 22,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "ENABLE_VIRTUAL_TERMINAL_PROCESSING",
          "lineno": 24,
          "assigned_to": "int",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "WINDOWS",
          "lineno": 18,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "rich/containers.py",
          "name": "T",
          "lineno": 27,
          "assigned_to": "TypeVar",
          "needs_llm": true
        },
        {
          "module": "rich/padding.py",
          "name": "PaddingDimensions",
          "lineno": 16,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "RichReprResult",
          "lineno": 20,
          "assigned_to": "Result",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "log",
          "lineno": 32,
          "assigned_to": "getLogger",
          "needs_llm": true
        },
        {
          "module": "rich/syntax.py",
          "name": "WINDOWS",
          "lineno": 56,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "rich/terminal_theme.py",
          "name": "DEFAULT_TERMINAL_THEME",
          "lineno": 32,
          "assigned_to": "TerminalTheme",
          "needs_llm": true
        },
        {
          "module": "rich/terminal_theme.py",
          "name": "MONOKAI",
          "lineno": 57,
          "assigned_to": "TerminalTheme",
          "needs_llm": true
        },
        {
          "module": "rich/terminal_theme.py",
          "name": "DIMMED_MONOKAI",
          "lineno": 81,
          "assigned_to": "TerminalTheme",
          "needs_llm": true
        },
        {
          "module": "rich/terminal_theme.py",
          "name": "NIGHT_OWLISH",
          "lineno": 105,
          "assigned_to": "TerminalTheme",
          "needs_llm": true
        },
        {
          "module": "rich/terminal_theme.py",
          "name": "SVG_EXPORT_THEME",
          "lineno": 130,
          "assigned_to": "TerminalTheme",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "TextType",
          "lineno": 41,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "rich/themes.py",
          "name": "DEFAULT",
          "lineno": 5,
          "assigned_to": "Theme",
          "needs_llm": true
        },
        {
          "module": "rich/traceback.py",
          "name": "WINDOWS",
          "lineno": 49,
          "assigned_to": null,
          "needs_llm": true
        },
        {
          "module": "rich/tree.py",
          "name": "GuideType",
          "lineno": 11,
          "assigned_to": null,
          "needs_llm": true
        }
      ],
      "unreachable_code": [],
      "suspicious_patterns": [
        {
          "module": "rich/__main__.py",
          "name": "make_test_card",
          "lineno": 39,
          "pattern_type": "long_function",
          "details": "Function is very long (168 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "close",
          "lineno": 6,
          "pattern_type": "empty_function",
          "details": "Function is empty or only contains pass/return None",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "writelines",
          "lineno": 39,
          "pattern_type": "empty_function",
          "details": "Function is empty or only contains pass/return None",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "flush",
          "lineno": 62,
          "pattern_type": "empty_function",
          "details": "Function is empty or only contains pass/return None",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "export_svg",
          "lineno": 2325,
          "pattern_type": "long_function",
          "details": "Function is very long (250 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/json.py",
          "name": "from_data",
          "lineno": 54,
          "pattern_type": "too_many_parameters",
          "details": "Function has 10 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "long_function",
          "details": "Function is very long (126 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "_ipy_display_hook",
          "lineno": 113,
          "pattern_type": "too_many_parameters",
          "details": "Function has 9 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "install",
          "lineno": 171,
          "pattern_type": "too_many_parameters",
          "details": "Function has 8 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "traverse",
          "lineno": 580,
          "pattern_type": "long_function",
          "details": "Function is very long (296 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "_traverse",
          "lineno": 621,
          "pattern_type": "long_function",
          "details": "Function is very long (252 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "track",
          "lineno": 104,
          "pattern_type": "too_many_parameters",
          "details": "Function has 16 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "track",
          "lineno": 1191,
          "pattern_type": "too_many_parameters",
          "details": "Function has 7 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "open",
          "lineno": 1279,
          "pattern_type": "too_many_parameters",
          "details": "Function has 7 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "open",
          "lineno": 1295,
          "pattern_type": "too_many_parameters",
          "details": "Function has 7 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "open",
          "lineno": 1310,
          "pattern_type": "too_many_parameters",
          "details": "Function has 7 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/syntax.py",
          "name": "from_path",
          "lineno": 317,
          "pattern_type": "too_many_parameters",
          "details": "Function has 16 parameters - consider parameter object",
          "needs_llm": true
        },
        {
          "module": "rich/syntax.py",
          "name": "_get_syntax",
          "lineno": 649,
          "pattern_type": "long_function",
          "details": "Function is very long (137 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "_render",
          "lineno": 747,
          "pattern_type": "long_function",
          "details": "Function is very long (180 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/traceback.py",
          "name": "install",
          "lineno": 83,
          "pattern_type": "long_function",
          "details": "Function is very long (129 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/traceback.py",
          "name": "extract",
          "lineno": 413,
          "pattern_type": "long_function",
          "details": "Function is very long (189 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "rich/traceback.py",
          "name": "_render_stack",
          "lineno": 745,
          "pattern_type": "long_function",
          "details": "Function is very long (126 lines) - consider refactoring",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_wrapping",
          "lineno": 22,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_wrapping_unicode_heavy in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_wrapping",
          "lineno": 22,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_wrapping_unicode_heavy_warm_cache in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_fit",
          "lineno": 28,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_fit_unicode_heavy in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_split",
          "lineno": 31,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_split_unicode_heavy in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_divide",
          "lineno": 34,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_divide_unicode_heavy in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_align_center",
          "lineno": 37,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_align_center_unicode_heavy in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_render",
          "lineno": 40,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_render_unicode_heavy in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_wrapping_unicode_heavy",
          "lineno": 43,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_wrapping_unicode_heavy_warm_cache in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "_print_table",
          "lineno": 104,
          "pattern_type": "similar_function_names",
          "details": "Similar to print_table in examples/export.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_pretty",
          "lineno": 135,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_pretty_indent_guides in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "time_pretty",
          "lineno": 135,
          "pattern_type": "similar_function_names",
          "details": "Similar to time_pretty_justify_center in benchmarks/benchmarks.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "test_divide_complex",
          "lineno": 217,
          "pattern_type": "similar_function_names",
          "details": "Similar to test in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "test_divide_complex",
          "lineno": 217,
          "pattern_type": "similar_function_names",
          "details": "Similar to test in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "benchmarks/benchmarks.py",
          "name": "test_divide_complex",
          "lineno": 217,
          "pattern_type": "similar_function_names",
          "details": "Similar to test in tools/make_terminal_widths.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/columns.py",
          "name": "get_content",
          "lineno": 15,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/columns.py",
          "name": "get_content",
          "lineno": 15,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/columns.py",
          "name": "get_content",
          "lineno": 15,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/downloader.py",
          "name": "copy_url",
          "lineno": 47,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/downloader.py",
          "name": "copy_url",
          "lineno": 47,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/downloader.py",
          "name": "copy_url",
          "lineno": 47,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/downloader.py",
          "name": "copy_url",
          "lineno": 47,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/dynamic_progress.py",
          "name": "run_steps",
          "lineno": 23,
          "pattern_type": "similar_function_names",
          "details": "Similar to run in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/dynamic_progress.py",
          "name": "run_steps",
          "lineno": 23,
          "pattern_type": "similar_function_names",
          "details": "Similar to run in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/dynamic_progress.py",
          "name": "run_steps",
          "lineno": 23,
          "pattern_type": "similar_function_names",
          "details": "Similar to run in tools/make_terminal_widths.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_by",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_by",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_by",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_by",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_by",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_by",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_all",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_all",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_all",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_all",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_all",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/exception.py",
          "name": "divide_all",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/export.py",
          "name": "print_table",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/__init__.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/export.py",
          "name": "print_table",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/export.py",
          "name": "print_table",
          "lineno": 11,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/jupyter.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/group2.py",
          "name": "get_panels",
          "lineno": 7,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/group2.py",
          "name": "get_panels",
          "lineno": 7,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/group2.py",
          "name": "get_panels",
          "lineno": 7,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/log.py",
          "name": "test_locals",
          "lineno": 53,
          "pattern_type": "similar_function_names",
          "details": "Similar to test in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/log.py",
          "name": "test_locals",
          "lineno": 53,
          "pattern_type": "similar_function_names",
          "details": "Similar to test in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/log.py",
          "name": "test_locals",
          "lineno": 53,
          "pattern_type": "similar_function_names",
          "details": "Similar to test in tools/make_terminal_widths.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/print_calendar.py",
          "name": "print_calendar",
          "lineno": 20,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/__init__.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/print_calendar.py",
          "name": "print_calendar",
          "lineno": 20,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/print_calendar.py",
          "name": "print_calendar",
          "lineno": 20,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/jupyter.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/rainbow.py",
          "name": "highlight",
          "lineno": 14,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_regex in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/rainbow.py",
          "name": "highlight",
          "lineno": 14,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_words in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/top_lite_simulator.py",
          "name": "create_process_table",
          "lineno": 50,
          "pattern_type": "similar_function_names",
          "details": "Similar to create in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/top_lite_simulator.py",
          "name": "create_process_table",
          "lineno": 50,
          "pattern_type": "similar_function_names",
          "details": "Similar to create in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/top_lite_simulator.py",
          "name": "create_process_table",
          "lineno": 50,
          "pattern_type": "similar_function_names",
          "details": "Similar to create in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/top_lite_simulator.py",
          "name": "create_process_table",
          "lineno": 50,
          "pattern_type": "similar_function_names",
          "details": "Similar to create in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/top_lite_simulator.py",
          "name": "create_process_table",
          "lineno": 50,
          "pattern_type": "similar_function_names",
          "details": "Similar to create in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/top_lite_simulator.py",
          "name": "create_process_table",
          "lineno": 50,
          "pattern_type": "similar_function_names",
          "details": "Similar to create in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/top_lite_simulator.py",
          "name": "create_process_table",
          "lineno": 50,
          "pattern_type": "similar_function_names",
          "details": "Similar to create in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "examples/top_lite_simulator.py",
          "name": "create_process_table",
          "lineno": 50,
          "pattern_type": "similar_function_names",
          "details": "Similar to create in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/__init__.py",
          "name": "get_console",
          "lineno": 23,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/__init__.py",
          "name": "get_console",
          "lineno": 23,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/__init__.py",
          "name": "get_console",
          "lineno": 23,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/__init__.py",
          "name": "print",
          "lineno": 53,
          "pattern_type": "similar_function_names",
          "details": "Similar to print_json in rich/__init__.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/__init__.py",
          "name": "print",
          "lineno": 53,
          "pattern_type": "similar_function_names",
          "details": "Similar to print_json in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/__init__.py",
          "name": "print",
          "lineno": 53,
          "pattern_type": "similar_function_names",
          "details": "Similar to print_exception in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/__init__.py",
          "name": "print_json",
          "lineno": 77,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/__init__.py",
          "name": "print_json",
          "lineno": 77,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/jupyter.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_fileno.py",
          "name": "get_fileno",
          "lineno": 6,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_fileno.py",
          "name": "get_fileno",
          "lineno": 6,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_fileno.py",
          "name": "get_fileno",
          "lineno": 6,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "get_object_types_mro",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_object_types_mro_as_strings in rich/_inspect.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "get_object_types_mro",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "get_object_types_mro",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "get_object_types_mro",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "get_object_types_mro_as_strings",
          "lineno": 245,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "get_object_types_mro_as_strings",
          "lineno": 245,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "get_object_types_mro_as_strings",
          "lineno": 245,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render_buffer in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render_segments in rich/jupyter.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render_pulse in rich/progress_bar.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render_syntax_error in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_inspect.py",
          "name": "_render",
          "lineno": 121,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_loop.py",
          "name": "loop_first",
          "lineno": 6,
          "pattern_type": "similar_function_names",
          "details": "Similar to loop_first_last in rich/_loop.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "close",
          "lineno": 6,
          "pattern_type": "similar_function_names",
          "details": "Similar to closed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "read",
          "lineno": 12,
          "pattern_type": "similar_function_names",
          "details": "Similar to readable in rich/_null_file.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "read",
          "lineno": 12,
          "pattern_type": "similar_function_names",
          "details": "Similar to readline in rich/_null_file.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "read",
          "lineno": 12,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in rich/_null_file.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "read",
          "lineno": 12,
          "pattern_type": "similar_function_names",
          "details": "Similar to readable in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "read",
          "lineno": 12,
          "pattern_type": "similar_function_names",
          "details": "Similar to readinto in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "read",
          "lineno": 12,
          "pattern_type": "similar_function_names",
          "details": "Similar to readline in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "read",
          "lineno": 12,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readable",
          "lineno": 15,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/ansi.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readable",
          "lineno": 15,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readable",
          "lineno": 15,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readline",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in rich/_null_file.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readline",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/ansi.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readline",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readline",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readline",
          "lineno": 18,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readlines",
          "lineno": 21,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/ansi.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readlines",
          "lineno": 21,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readlines",
          "lineno": 21,
          "pattern_type": "similar_function_names",
          "details": "Similar to readline in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "readlines",
          "lineno": 21,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "seek",
          "lineno": 24,
          "pattern_type": "similar_function_names",
          "details": "Similar to seekable in rich/_null_file.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "seek",
          "lineno": 24,
          "pattern_type": "similar_function_names",
          "details": "Similar to seekable in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "seekable",
          "lineno": 27,
          "pattern_type": "similar_function_names",
          "details": "Similar to seek in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "writelines",
          "lineno": 39,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in rich/_null_file.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "writelines",
          "lineno": 39,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in rich/file_proxy.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "writelines",
          "lineno": 39,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "write",
          "lineno": 59,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_text in rich/_win32_console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "write",
          "lineno": 59,
          "pattern_type": "similar_function_names",
          "details": "Similar to write_styled in rich/_win32_console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "write",
          "lineno": 59,
          "pattern_type": "similar_function_names",
          "details": "Similar to writelines in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "fileno",
          "lineno": 65,
          "pattern_type": "similar_function_names",
          "details": "Similar to file in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_null_file.py",
          "name": "fileno",
          "lineno": 65,
          "pattern_type": "similar_function_names",
          "details": "Similar to file in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_stack.py",
          "name": "push",
          "lineno": 14,
          "pattern_type": "similar_function_names",
          "details": "Similar to push_render_hook in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_stack.py",
          "name": "push",
          "lineno": 14,
          "pattern_type": "similar_function_names",
          "details": "Similar to push_theme in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_stack.py",
          "name": "push",
          "lineno": 14,
          "pattern_type": "similar_function_names",
          "details": "Similar to push_theme in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "screen_size",
          "lineno": 387,
          "pattern_type": "similar_function_names",
          "details": "Similar to screen in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "write_text",
          "lineno": 396,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in rich/file_proxy.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "write_text",
          "lineno": 396,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "write_styled",
          "lineno": 405,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in rich/file_proxy.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "write_styled",
          "lineno": 405,
          "pattern_type": "similar_function_names",
          "details": "Similar to write in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_to",
          "lineno": 444,
          "pattern_type": "similar_function_names",
          "details": "Similar to move_cursor_to_column in rich/_win32_console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_to",
          "lineno": 444,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_to",
          "lineno": 444,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_up",
          "lineno": 493,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_up",
          "lineno": 493,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_down",
          "lineno": 503,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_down",
          "lineno": 503,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_forward",
          "lineno": 514,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_forward",
          "lineno": 514,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_to_column",
          "lineno": 526,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_to_column",
          "lineno": 526,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_backward",
          "lineno": 535,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "move_cursor_backward",
          "lineno": 535,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "show_cursor",
          "lineno": 553,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in rich/pager.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_win32_console.py",
          "name": "show_cursor",
          "lineno": 553,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in rich/pager.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_windows.py",
          "name": "get_windows_console_features",
          "lineno": 40,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_windows.py",
          "name": "get_windows_console_features",
          "lineno": 40,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_windows.py",
          "name": "get_windows_console_features",
          "lineno": 40,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_windows.py",
          "name": "get_windows_console_features",
          "lineno": 34,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_windows.py",
          "name": "get_windows_console_features",
          "lineno": 34,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_windows.py",
          "name": "get_windows_console_features",
          "lineno": 34,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_wrap.py",
          "name": "divide_line",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_wrap.py",
          "name": "divide_line",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_wrap.py",
          "name": "divide_line",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_wrap.py",
          "name": "divide_line",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_wrap.py",
          "name": "divide_line",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/_wrap.py",
          "name": "divide_line",
          "lineno": 26,
          "pattern_type": "similar_function_names",
          "details": "Similar to divide in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/align.py",
          "name": "right",
          "lineno": 108,
          "pattern_type": "similar_function_names",
          "details": "Similar to right_crop in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/align.py",
          "name": "right",
          "lineno": 108,
          "pattern_type": "similar_function_names",
          "details": "Similar to right_crop in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/ansi.py",
          "name": "decode",
          "lineno": 126,
          "pattern_type": "similar_function_names",
          "details": "Similar to decode_line in rich/ansi.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/ansi.py",
          "name": "read",
          "lineno": 224,
          "pattern_type": "similar_function_names",
          "details": "Similar to readable in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/ansi.py",
          "name": "read",
          "lineno": 224,
          "pattern_type": "similar_function_names",
          "details": "Similar to readinto in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/ansi.py",
          "name": "read",
          "lineno": 224,
          "pattern_type": "similar_function_names",
          "details": "Similar to readline in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/ansi.py",
          "name": "read",
          "lineno": 224,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_plain_headed_box",
          "lineno": 85,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_plain_headed_box",
          "lineno": 85,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_plain_headed_box",
          "lineno": 85,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_top",
          "lineno": 95,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_top",
          "lineno": 95,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_top",
          "lineno": 95,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_row",
          "lineno": 115,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_row",
          "lineno": 115,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_row",
          "lineno": 115,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_row",
          "lineno": 115,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_row_style in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_bottom",
          "lineno": 164,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_bottom",
          "lineno": 164,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/box.py",
          "name": "get_bottom",
          "lineno": 164,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/cells.py",
          "name": "cell_len",
          "lineno": 51,
          "pattern_type": "similar_function_names",
          "details": "Similar to cell_length in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/cells.py",
          "name": "get_character_cell_size",
          "lineno": 68,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/cells.py",
          "name": "get_character_cell_size",
          "lineno": 68,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/cells.py",
          "name": "get_character_cell_size",
          "lineno": 68,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "parse_rgb_hex",
          "lineno": 571,
          "pattern_type": "similar_function_names",
          "details": "Similar to parse in rich/color.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "parse_rgb_hex",
          "lineno": 571,
          "pattern_type": "similar_function_names",
          "details": "Similar to parse in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "__rich_repr__",
          "lineno": 326,
          "pattern_type": "similar_function_names",
          "details": "Similar to rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "__rich_repr__",
          "lineno": 326,
          "pattern_type": "similar_function_names",
          "details": "Similar to rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "__rich_repr__",
          "lineno": 326,
          "pattern_type": "similar_function_names",
          "details": "Similar to rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "get_truecolor",
          "lineno": 349,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "get_truecolor",
          "lineno": 349,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "get_truecolor",
          "lineno": 349,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "default",
          "lineno": 423,
          "pattern_type": "similar_function_names",
          "details": "Similar to default_lexer in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "parse",
          "lineno": 433,
          "pattern_type": "similar_function_names",
          "details": "Similar to _parse in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "get_ansi_codes",
          "lineno": 485,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "get_ansi_codes",
          "lineno": 485,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color.py",
          "name": "get_ansi_codes",
          "lineno": 485,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color_triplet.py",
          "name": "normalized",
          "lineno": 31,
          "pattern_type": "similar_function_names",
          "details": "Similar to normalize in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/color_triplet.py",
          "name": "normalized",
          "lineno": 31,
          "pattern_type": "similar_function_names",
          "details": "Similar to normalize in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/columns.py",
          "name": "add_renderable",
          "lineno": 54,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_windows_console_features",
          "lineno": 572,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_windows_console_features",
          "lineno": 572,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_windows_console_features",
          "lineno": 572,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "copy",
          "lineno": 153,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy_styles in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 163,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_width in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 163,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_height in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 163,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_dimensions in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 163,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_screen in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 163,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_screen_lines in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 163,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_width",
          "lineno": 200,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_width",
          "lineno": 200,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_width",
          "lineno": 200,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_width",
          "lineno": 200,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_width",
          "lineno": 200,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress_bar.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_width",
          "lineno": 200,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_width",
          "lineno": 200,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_height",
          "lineno": 213,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_height",
          "lineno": 213,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_height",
          "lineno": 213,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_height",
          "lineno": 213,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_height",
          "lineno": 213,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress_bar.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_height",
          "lineno": 213,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_height",
          "lineno": 213,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "reset_height",
          "lineno": 226,
          "pattern_type": "similar_function_names",
          "details": "Similar to reset in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_dimensions",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_dimensions",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_dimensions",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_dimensions",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_dimensions",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress_bar.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_dimensions",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_dimensions",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_svg_style in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_codes in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_tree_icon in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_tree_icon in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_tree_icon in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderable in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_level_text in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_color_distance in rich/palette.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_table_column in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_time in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_default_columns in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderable in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderables in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_input in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_line_length in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_shape in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to __get__ in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_html_style in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to __get__ in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_theme in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_row_style in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_padding in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_at_offset in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_text_at in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_current_style in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get",
          "lineno": 340,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_cell_size in tools/make_terminal_widths.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 420,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_screen in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 420,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_screen_lines in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update",
          "lineno": 420,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "renderables",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "file",
          "lineno": 763,
          "pattern_type": "similar_function_names",
          "details": "Similar to fileno in rich/file_proxy.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "file",
          "lineno": 763,
          "pattern_type": "similar_function_names",
          "details": "Similar to fileno in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "file",
          "lineno": 772,
          "pattern_type": "similar_function_names",
          "details": "Similar to fileno in rich/file_proxy.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "file",
          "lineno": 772,
          "pattern_type": "similar_function_names",
          "details": "Similar to fileno in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "_buffer",
          "lineno": 777,
          "pattern_type": "similar_function_names",
          "details": "Similar to _buffer_index in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "_buffer",
          "lineno": 777,
          "pattern_type": "similar_function_names",
          "details": "Similar to _buffer_index in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "clear_live",
          "lineno": 844,
          "pattern_type": "similar_function_names",
          "details": "Similar to clear in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "clear_live",
          "lineno": 844,
          "pattern_type": "similar_function_names",
          "details": "Similar to clear in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "push_render_hook",
          "lineno": 849,
          "pattern_type": "similar_function_names",
          "details": "Similar to push in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "pop_render_hook",
          "lineno": 858,
          "pattern_type": "similar_function_names",
          "details": "Similar to pop in rich/containers.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "pop_render_hook",
          "lineno": 858,
          "pattern_type": "similar_function_names",
          "details": "Similar to pop in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "push_theme",
          "lineno": 887,
          "pattern_type": "similar_function_names",
          "details": "Similar to push in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "pop_theme",
          "lineno": 898,
          "pattern_type": "similar_function_names",
          "details": "Similar to pop in rich/containers.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "pop_theme",
          "lineno": 898,
          "pattern_type": "similar_function_names",
          "details": "Similar to pop in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "color_system",
          "lineno": 915,
          "pattern_type": "similar_function_names",
          "details": "Similar to color in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "pager",
          "lineno": 1119,
          "pattern_type": "similar_function_names",
          "details": "Similar to _pager in rich/pager.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "line",
          "lineno": 1142,
          "pattern_type": "similar_function_names",
          "details": "Similar to line_tokenize in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "clear",
          "lineno": 1152,
          "pattern_type": "similar_function_names",
          "details": "Similar to clear_meta_and_links in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "show_cursor",
          "lineno": 1196,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in rich/pager.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "show_cursor",
          "lineno": 1196,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in rich/pager.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "measure",
          "lineno": 1283,
          "pattern_type": "similar_function_names",
          "details": "Similar to measure_renderables in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_lines in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_str in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_message in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_bullet in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_number in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render",
          "lineno": 1300,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_lines",
          "lineno": 1351,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "render_str",
          "lineno": 1415,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_style",
          "lineno": 1476,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_style",
          "lineno": 1476,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_style",
          "lineno": 1476,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_style",
          "lineno": 1476,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_style",
          "lineno": 1476,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_style",
          "lineno": 1476,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_at_offset in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "print",
          "lineno": 1648,
          "pattern_type": "similar_function_names",
          "details": "Similar to print_json in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "print",
          "lineno": 1648,
          "pattern_type": "similar_function_names",
          "details": "Similar to print_exception in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "print_json",
          "lineno": 1747,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/jupyter.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen",
          "lineno": 1808,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_screen_lines in rich/console.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen",
          "lineno": 1808,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen",
          "lineno": 1808,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen",
          "lineno": 1808,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen",
          "lineno": 1808,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress_bar.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen",
          "lineno": 1808,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen",
          "lineno": 1808,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen_lines",
          "lineno": 1842,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen_lines",
          "lineno": 1842,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen_lines",
          "lineno": 1842,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen_lines",
          "lineno": 1842,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/progress_bar.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen_lines",
          "lineno": 1842,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "update_screen_lines",
          "lineno": 1842,
          "pattern_type": "similar_function_names",
          "details": "Similar to update in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "print_exception",
          "lineno": 1862,
          "pattern_type": "similar_function_names",
          "details": "Similar to print in rich/jupyter.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "on_broken_pipe",
          "lineno": 2013,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "on_broken_pipe",
          "lineno": 2013,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "_render_buffer",
          "lineno": 2115,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "_replace",
          "lineno": 502,
          "pattern_type": "similar_function_names",
          "details": "Similar to replace in rich/emoji.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_svg_style",
          "lineno": 2356,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "get_svg_style",
          "lineno": 2356,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "escape_text",
          "lineno": 2416,
          "pattern_type": "similar_function_names",
          "details": "Similar to escape in rich/jupyter.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "escape_text",
          "lineno": 2416,
          "pattern_type": "similar_function_names",
          "details": "Similar to escape in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/console.py",
          "name": "align_append",
          "lineno": 1539,
          "pattern_type": "similar_function_names",
          "details": "Similar to align in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/containers.py",
          "name": "append",
          "lineno": 59,
          "pattern_type": "similar_function_names",
          "details": "Similar to append_text in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/containers.py",
          "name": "append",
          "lineno": 59,
          "pattern_type": "similar_function_names",
          "details": "Similar to append_tokens in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/containers.py",
          "name": "append",
          "lineno": 102,
          "pattern_type": "similar_function_names",
          "details": "Similar to append_text in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/containers.py",
          "name": "append",
          "lineno": 102,
          "pattern_type": "similar_function_names",
          "details": "Similar to append_tokens in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/containers.py",
          "name": "extend",
          "lineno": 105,
          "pattern_type": "similar_function_names",
          "details": "Similar to extend_style in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/containers.py",
          "name": "pop",
          "lineno": 108,
          "pattern_type": "similar_function_names",
          "details": "Similar to pop_style in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/containers.py",
          "name": "pop",
          "lineno": 108,
          "pattern_type": "similar_function_names",
          "details": "Similar to pop_theme in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "escape_control_codes",
          "lineno": 195,
          "pattern_type": "similar_function_names",
          "details": "Similar to escape in rich/jupyter.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "escape_control_codes",
          "lineno": 195,
          "pattern_type": "similar_function_names",
          "details": "Similar to escape in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "move",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to move_to_column in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "move",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to move_to in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "move_to_column",
          "lineno": 108,
          "pattern_type": "similar_function_names",
          "details": "Similar to move_to in rich/control.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "move_to_column",
          "lineno": 108,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "move_to",
          "lineno": 132,
          "pattern_type": "similar_function_names",
          "details": "Similar to move in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "clear",
          "lineno": 145,
          "pattern_type": "similar_function_names",
          "details": "Similar to clear_meta_and_links in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "show_cursor",
          "lineno": 150,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in rich/pager.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "show_cursor",
          "lineno": 150,
          "pattern_type": "similar_function_names",
          "details": "Similar to show in rich/pager.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "title",
          "lineno": 163,
          "pattern_type": "similar_function_names",
          "details": "Similar to _title in rich/panel.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "get_codes",
          "lineno": 91,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/control.py",
          "name": "get_codes",
          "lineno": 91,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/file_proxy.py",
          "name": "write",
          "lineno": 28,
          "pattern_type": "similar_function_names",
          "details": "Similar to writelines in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/highlighter.py",
          "name": "highlight",
          "lineno": 42,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_regex in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/highlighter.py",
          "name": "highlight",
          "lineno": 42,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_words in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/highlighter.py",
          "name": "highlight",
          "lineno": 57,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_regex in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/highlighter.py",
          "name": "highlight",
          "lineno": 57,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_words in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/highlighter.py",
          "name": "highlight",
          "lineno": 67,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_regex in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/highlighter.py",
          "name": "highlight",
          "lineno": 67,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_words in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/highlighter.py",
          "name": "highlight",
          "lineno": 123,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_regex in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/highlighter.py",
          "name": "highlight",
          "lineno": 123,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_words in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/jupyter.py",
          "name": "_render_segments",
          "lineno": 59,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/jupyter.py",
          "name": "display",
          "lineno": 84,
          "pattern_type": "similar_function_names",
          "details": "Similar to display_hook in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/jupyter.py",
          "name": "escape",
          "lineno": 60,
          "pattern_type": "similar_function_names",
          "details": "Similar to escape_backslashes in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get_tree_icon",
          "lineno": 86,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get_tree_icon",
          "lineno": 86,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get_tree_icon",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get_tree_icon",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get_tree_icon",
          "lineno": 126,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get_tree_icon",
          "lineno": 126,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "__rich_repr__",
          "lineno": 177,
          "pattern_type": "similar_function_names",
          "details": "Similar to rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "__rich_repr__",
          "lineno": 177,
          "pattern_type": "similar_function_names",
          "details": "Similar to rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "__rich_repr__",
          "lineno": 177,
          "pattern_type": "similar_function_names",
          "details": "Similar to rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "renderable",
          "lineno": 184,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderable in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_level_text in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_color_distance in rich/palette.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_table_column in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_time in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_default_columns in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderable in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderables in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_input in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_line_length in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_shape in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to __get__ in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_html_style in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to __get__ in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_theme in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_row_style in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_padding in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_at_offset in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_text_at in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_current_style in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "get",
          "lineno": 198,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_cell_size in tools/make_terminal_widths.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split",
          "lineno": 261,
          "pattern_type": "similar_function_names",
          "details": "Similar to split_row in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split",
          "lineno": 261,
          "pattern_type": "similar_function_names",
          "details": "Similar to split_column in rich/layout.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split",
          "lineno": 261,
          "pattern_type": "similar_function_names",
          "details": "Similar to split_cells in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split",
          "lineno": 261,
          "pattern_type": "similar_function_names",
          "details": "Similar to split_lines in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split",
          "lineno": 261,
          "pattern_type": "similar_function_names",
          "details": "Similar to split_and_crop_lines in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "add_split",
          "lineno": 286,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split_row",
          "lineno": 299,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split_row",
          "lineno": 299,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split_column",
          "lineno": 307,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "split_column",
          "lineno": 307,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "update",
          "lineno": 319,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "refresh_screen",
          "lineno": 328,
          "pattern_type": "similar_function_names",
          "details": "Similar to refresh in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "refresh_screen",
          "lineno": 328,
          "pattern_type": "similar_function_names",
          "details": "Similar to refresh in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/live.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_message in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_bullet in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_number in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/layout.py",
          "name": "render",
          "lineno": 366,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "stop",
          "lineno": 31,
          "pattern_type": "similar_function_names",
          "details": "Similar to stop_task in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "get_renderable",
          "lineno": 103,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "get_renderable",
          "lineno": 103,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderables in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "start",
          "lineno": 111,
          "pattern_type": "similar_function_names",
          "details": "Similar to started in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "start",
          "lineno": 111,
          "pattern_type": "similar_function_names",
          "details": "Similar to start_task in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "stop",
          "lineno": 145,
          "pattern_type": "similar_function_names",
          "details": "Similar to stop_task in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "renderable",
          "lineno": 211,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/live.py",
          "name": "update",
          "lineno": 226,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "get_level_text",
          "lineno": 117,
          "pattern_type": "similar_function_names",
          "details": "Similar to get in rich/measure.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/logging.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render_message",
          "lineno": 182,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_bullet in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_number in rich/markdown.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/logging.py",
          "name": "render",
          "lineno": 207,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_enter",
          "lineno": 41,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_enter",
          "lineno": 41,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_text",
          "lineno": 48,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_text",
          "lineno": 48,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_leave",
          "lineno": 55,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_leave",
          "lineno": 55,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 62,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 62,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_enter",
          "lineno": 96,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_enter",
          "lineno": 96,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_text",
          "lineno": 100,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_text",
          "lineno": 100,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_leave",
          "lineno": 103,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_leave",
          "lineno": 103,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_enter",
          "lineno": 134,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_enter",
          "lineno": 134,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 195,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 195,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 232,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 232,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 264,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 264,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 276,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 276,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 288,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 288,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_text",
          "lineno": 319,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_text",
          "lineno": 319,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 337,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 337,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 365,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_child_close",
          "lineno": 365,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_bullet",
          "lineno": 369,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "render_number",
          "lineno": 382,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_enter",
          "lineno": 434,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_enter",
          "lineno": 434,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "current_style",
          "lineno": 471,
          "pattern_type": "similar_function_names",
          "details": "Similar to current in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_text",
          "lineno": 475,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markdown.py",
          "name": "on_text",
          "lineno": 475,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "escape",
          "lineno": 48,
          "pattern_type": "similar_function_names",
          "details": "Similar to escape_backslashes in rich/markup.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "_parse",
          "lineno": 73,
          "pattern_type": "similar_function_names",
          "details": "Similar to parse in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "render",
          "lineno": 106,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/markup.py",
          "name": "pop_style",
          "lineno": 146,
          "pattern_type": "similar_function_names",
          "details": "Similar to pop in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "span",
          "lineno": 20,
          "pattern_type": "similar_function_names",
          "details": "Similar to spans in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "span",
          "lineno": 20,
          "pattern_type": "similar_function_names",
          "details": "Similar to spans in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_color_distance in rich/palette.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_table_column in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_time in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_default_columns in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderable in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderables in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_input in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_line_length in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_shape in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to __get__ in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_html_style in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_for_token in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_background_style in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to __get__ in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_theme in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_row_style in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_padding in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_style_at_offset in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_text_at in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_current_style in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/measure.py",
          "name": "get",
          "lineno": 79,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_cell_size in tools/make_terminal_widths.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/panel.py",
          "name": "align_text",
          "lineno": 159,
          "pattern_type": "similar_function_names",
          "details": "Similar to align in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "traverse",
          "lineno": 580,
          "pattern_type": "similar_function_names",
          "details": "Similar to _traverse in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "render",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "expandable",
          "lineno": 507,
          "pattern_type": "similar_function_names",
          "details": "Similar to expand in rich/pretty.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "expandable",
          "lineno": 507,
          "pattern_type": "similar_function_names",
          "details": "Similar to expand in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "expandable",
          "lineno": 507,
          "pattern_type": "similar_function_names",
          "details": "Similar to expand in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/pretty.py",
          "name": "expand",
          "lineno": 519,
          "pattern_type": "similar_function_names",
          "details": "Similar to expand_tabs in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "wrap_file",
          "lineno": 306,
          "pattern_type": "similar_function_names",
          "details": "Similar to wrap in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "closed",
          "lineno": 219,
          "pattern_type": "similar_function_names",
          "details": "Similar to close in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "readable",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "readable",
          "lineno": 236,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "seekable",
          "lineno": 239,
          "pattern_type": "similar_function_names",
          "details": "Similar to seek in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "read",
          "lineno": 245,
          "pattern_type": "similar_function_names",
          "details": "Similar to readinto in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "read",
          "lineno": 245,
          "pattern_type": "similar_function_names",
          "details": "Similar to readline in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "read",
          "lineno": 245,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "readinto",
          "lineno": 250,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "readline",
          "lineno": 255,
          "pattern_type": "similar_function_names",
          "details": "Similar to readlines in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "readline",
          "lineno": 255,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "readlines",
          "lineno": 260,
          "pattern_type": "similar_function_names",
          "details": "Similar to read in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "write",
          "lineno": 278,
          "pattern_type": "similar_function_names",
          "details": "Similar to writelines in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 545,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 562,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 607,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 635,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 673,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_speed in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 691,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render_speed",
          "lineno": 737,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 756,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 756,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 756,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 756,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 756,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 756,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 756,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 756,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 793,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 793,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 793,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 793,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 793,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 793,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 793,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 793,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 823,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 823,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 823,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 823,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 823,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 823,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 823,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 823,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 832,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 832,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 832,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 832,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 832,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 832,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 832,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 832,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 854,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 854,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 854,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 854,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 854,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 854,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 854,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 854,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 878,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 878,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 878,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 878,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 878,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 878,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 878,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 878,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 917,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 917,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_default in rich/prompt.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 917,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_scope in rich/scope.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 917,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 917,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 917,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 917,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "render",
          "lineno": 917,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "started",
          "lineno": 988,
          "pattern_type": "similar_function_names",
          "details": "Similar to start in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "started",
          "lineno": 988,
          "pattern_type": "similar_function_names",
          "details": "Similar to start in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "percentage",
          "lineno": 1014,
          "pattern_type": "similar_function_names",
          "details": "Similar to percentage_completed in rich/progress_bar.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "_reset",
          "lineno": 1054,
          "pattern_type": "similar_function_names",
          "details": "Similar to reset in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "start",
          "lineno": 1168,
          "pattern_type": "similar_function_names",
          "details": "Similar to start_task in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "stop",
          "lineno": 1173,
          "pattern_type": "similar_function_names",
          "details": "Similar to stop_task in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "wrap_file",
          "lineno": 1236,
          "pattern_type": "similar_function_names",
          "details": "Similar to wrap in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "start_task",
          "lineno": 1387,
          "pattern_type": "similar_function_names",
          "details": "Similar to start in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "stop_task",
          "lineno": 1401,
          "pattern_type": "similar_function_names",
          "details": "Similar to stop in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "update",
          "lineno": 1416,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "get_renderable",
          "lineno": 1551,
          "pattern_type": "similar_function_names",
          "details": "Similar to get_renderables in rich/progress.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress.py",
          "name": "add_task",
          "lineno": 1599,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress_bar.py",
          "name": "update",
          "lineno": 116,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/progress_bar.py",
          "name": "_render_pulse",
          "lineno": 126,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/prompt.py",
          "name": "render_default",
          "lineno": 151,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/prompt.py",
          "name": "render_default",
          "lineno": 151,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/prompt.py",
          "name": "render_default",
          "lineno": 151,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/prompt.py",
          "name": "on_validate_error",
          "lineno": 258,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/prompt.py",
          "name": "on_validate_error",
          "lineno": 258,
          "pattern_type": "similar_function_names",
          "details": "Similar to on in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/prompt.py",
          "name": "render_default",
          "lineno": 353,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/prompt.py",
          "name": "render_default",
          "lineno": 353,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/prompt.py",
          "name": "render_default",
          "lineno": 353,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "auto",
          "lineno": 28,
          "pattern_type": "similar_function_names",
          "details": "Similar to auto_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "auto",
          "lineno": 28,
          "pattern_type": "similar_function_names",
          "details": "Similar to auto_rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "auto",
          "lineno": 33,
          "pattern_type": "similar_function_names",
          "details": "Similar to auto_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "auto",
          "lineno": 33,
          "pattern_type": "similar_function_names",
          "details": "Similar to auto_rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "auto",
          "lineno": 37,
          "pattern_type": "similar_function_names",
          "details": "Similar to auto_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "auto",
          "lineno": 37,
          "pattern_type": "similar_function_names",
          "details": "Similar to auto_rich_repr in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 105,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 105,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 105,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 110,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 110,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 110,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 114,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/repr.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 114,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/repr.py",
          "name": "rich_repr",
          "lineno": 114,
          "pattern_type": "similar_function_names",
          "details": "Similar to __rich_repr__ in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/scope.py",
          "name": "render_scope",
          "lineno": 14,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/spinner.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/scope.py",
          "name": "render_scope",
          "lineno": 14,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/scope.py",
          "name": "render_scope",
          "lineno": 14,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "cell_length",
          "lineno": 82,
          "pattern_type": "similar_function_names",
          "details": "Similar to cell_len in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "_split_cells",
          "lineno": 111,
          "pattern_type": "similar_function_names",
          "details": "Similar to split_cells in rich/segment.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "split_cells",
          "lineno": 158,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "split_cells",
          "lineno": 158,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "line",
          "lineno": 185,
          "pattern_type": "similar_function_names",
          "details": "Similar to line_tokenize in rich/syntax.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "split_lines",
          "lineno": 250,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "split_lines",
          "lineno": 250,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "split_and_crop_lines",
          "lineno": 279,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "split_and_crop_lines",
          "lineno": 279,
          "pattern_type": "similar_function_names",
          "details": "Similar to split in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "align_top",
          "lineno": 434,
          "pattern_type": "similar_function_names",
          "details": "Similar to align in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "align_bottom",
          "lineno": 463,
          "pattern_type": "similar_function_names",
          "details": "Similar to align in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/segment.py",
          "name": "align_middle",
          "lineno": 492,
          "pattern_type": "similar_function_names",
          "details": "Similar to align in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/spinner.py",
          "name": "render",
          "lineno": 61,
          "pattern_type": "similar_function_names",
          "details": "Similar to renderable in rich/status.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/spinner.py",
          "name": "render",
          "lineno": 61,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/spinner.py",
          "name": "render",
          "lineno": 61,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/spinner.py",
          "name": "render",
          "lineno": 61,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/spinner.py",
          "name": "render",
          "lineno": 61,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/spinner.py",
          "name": "update",
          "lineno": 95,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/status.py",
          "name": "renderable",
          "lineno": 45,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/status.py",
          "name": "renderable",
          "lineno": 45,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/status.py",
          "name": "update",
          "lineno": 53,
          "pattern_type": "similar_function_names",
          "details": "Similar to update_link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "link_id",
          "lineno": 286,
          "pattern_type": "similar_function_names",
          "details": "Similar to link in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "copy",
          "lineno": 622,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy_styles in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "render",
          "lineno": 690,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "render",
          "lineno": 690,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_annotation in rich/table.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "render",
          "lineno": 690,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "render",
          "lineno": 690,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "_add",
          "lineno": 729,
          "pattern_type": "similar_function_names",
          "details": "Similar to __add__ in rich/style.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "_add",
          "lineno": 729,
          "pattern_type": "similar_function_names",
          "details": "Similar to __add__ in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "_add",
          "lineno": 729,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "__add__",
          "lineno": 753,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "push",
          "lineno": 777,
          "pattern_type": "similar_function_names",
          "details": "Similar to push_theme in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/style.py",
          "name": "pop",
          "lineno": 785,
          "pattern_type": "similar_function_names",
          "details": "Similar to pop_theme in rich/theme.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/syntax.py",
          "name": "guess_lexer",
          "lineno": 380,
          "pattern_type": "similar_function_names",
          "details": "Similar to _guess_lexer in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/syntax.py",
          "name": "highlight",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_regex in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/syntax.py",
          "name": "highlight",
          "lineno": 467,
          "pattern_type": "similar_function_names",
          "details": "Similar to highlight_words in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/syntax.py",
          "name": "stylize_range",
          "lineno": 552,
          "pattern_type": "similar_function_names",
          "details": "Similar to stylize in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "copy",
          "lineno": 117,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy_styles in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "expand",
          "lineno": 287,
          "pattern_type": "similar_function_names",
          "details": "Similar to expand_tabs in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "expand",
          "lineno": 292,
          "pattern_type": "similar_function_names",
          "details": "Similar to expand_tabs in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "padding",
          "lineno": 355,
          "pattern_type": "similar_function_names",
          "details": "Similar to pad in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "padding",
          "lineno": 360,
          "pattern_type": "similar_function_names",
          "details": "Similar to pad in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "add_column",
          "lineno": 365,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "add_row",
          "lineno": 423,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "add_section",
          "lineno": 470,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "_render",
          "lineno": 747,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "_render",
          "lineno": 747,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render_syntax_error in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "_render",
          "lineno": 747,
          "pattern_type": "similar_function_names",
          "details": "Similar to _render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "add_cell",
          "lineno": 441,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "render_annotation",
          "lineno": 497,
          "pattern_type": "similar_function_names",
          "details": "Similar to render in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/table.py",
          "name": "align_cell",
          "lineno": 839,
          "pattern_type": "similar_function_names",
          "details": "Similar to align in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "extend",
          "lineno": 102,
          "pattern_type": "similar_function_names",
          "details": "Similar to extend_style in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "__add__",
          "lineno": 179,
          "pattern_type": "similar_function_names",
          "details": "Similar to add in rich/tree.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "copy",
          "lineno": 443,
          "pattern_type": "similar_function_names",
          "details": "Similar to copy_styles in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "stylize",
          "lineno": 457,
          "pattern_type": "similar_function_names",
          "details": "Similar to stylize_before in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "rstrip",
          "lineno": 662,
          "pattern_type": "similar_function_names",
          "details": "Similar to rstrip_end in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "render",
          "lineno": 720,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "render",
          "lineno": 720,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_locals in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "pad",
          "lineno": 901,
          "pattern_type": "similar_function_names",
          "details": "Similar to pad_left in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "pad",
          "lineno": 901,
          "pattern_type": "similar_function_names",
          "details": "Similar to pad_right in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "append",
          "lineno": 965,
          "pattern_type": "similar_function_names",
          "details": "Similar to append_text in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/text.py",
          "name": "append",
          "lineno": 965,
          "pattern_type": "similar_function_names",
          "details": "Similar to append_tokens in rich/text.py - possible duplicate logic",
          "needs_llm": true
        },
        {
          "module": "rich/traceback.py",
          "name": "_render_stack",
          "lineno": 745,
          "pattern_type": "similar_function_names",
          "details": "Similar to render_stack in rich/traceback.py - possible duplicate logic",
          "needs_llm": true
        }
      ]
    }
  }
}